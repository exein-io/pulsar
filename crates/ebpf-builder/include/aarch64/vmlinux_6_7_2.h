// File autogenerated with `cargo xtask vmlinux`. DO NOT EDIT MANUALLY!
// Kernel 6.7.2 compiled with clang-15

#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

typedef unsigned long long __u64;

typedef __u64 u64;

typedef u64 phys_addr_t;

typedef unsigned short umode_t;

typedef unsigned long __kernel_ulong_t;

typedef __kernel_ulong_t __kernel_size_t;

typedef __kernel_size_t size_t;

struct ctl_table;

typedef long long __kernel_loff_t;

typedef __kernel_loff_t loff_t;

typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	enum {
		SYSCTL_TABLE_TYPE_DEFAULT = 0,
		SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY = 1,
	} type;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

typedef struct {
	int counter;
} atomic_t;

typedef unsigned char __u8;

typedef __u8 u8;

typedef unsigned short __u16;

typedef __u16 u16;

struct qspinlock {
	union {
		atomic_t val;
		struct {
			u8 locked;
			u8 pending;
		};
		struct {
			u16 locked_pending;
			u16 tail;
		};
	};
};

typedef struct qspinlock arch_spinlock_t;

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct spinlock spinlock_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_Generic = 253,
	Root_RAM0 = 1048576,
};

enum {
	false = 0,
	true = 1,
};

typedef unsigned int gfp_t;

typedef _Bool bool;

typedef unsigned int __u32;

typedef __u32 u32;

typedef u32 __kernel_dev_t;

typedef __kernel_dev_t dev_t;

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_COHERENT = 2,
	MEMORY_DEVICE_FS_DAX = 3,
	MEMORY_DEVICE_GENERIC = 4,
	MEMORY_DEVICE_PCI_P2PDMA = 5,
};

enum fault_flag {
	FAULT_FLAG_WRITE = 1,
	FAULT_FLAG_MKWRITE = 2,
	FAULT_FLAG_ALLOW_RETRY = 4,
	FAULT_FLAG_RETRY_NOWAIT = 8,
	FAULT_FLAG_KILLABLE = 16,
	FAULT_FLAG_TRIED = 32,
	FAULT_FLAG_USER = 64,
	FAULT_FLAG_REMOTE = 128,
	FAULT_FLAG_INSTRUCTION = 256,
	FAULT_FLAG_INTERRUPTIBLE = 512,
	FAULT_FLAG_UNSHARE = 1024,
	FAULT_FLAG_ORIG_PTE_VALID = 2048,
	FAULT_FLAG_VMA_LOCK = 4096,
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
	MIGRATE_SYNC_NO_COPY = 3,
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

enum freeze_holder {
	FREEZE_HOLDER_KERNEL = 1,
	FREEZE_HOLDER_USERSPACE = 2,
};

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

enum fp_type {
	FP_STATE_CURRENT = 0,
	FP_STATE_FPSIMD = 1,
	FP_STATE_SVE = 2,
};

struct thread_info {
	unsigned long flags;
	union {
		u64 preempt_count;
		struct {
			u32 count;
			u32 need_resched;
		} preempt;
	};
	u32 cpu;
};

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
	u16 src;
	u16 dst;
};

struct load_weight {
	unsigned long weight;
	u32 inv_weight;
};

struct rb_node {
	unsigned long __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

typedef long long __s64;

typedef __s64 s64;

struct util_est {
	unsigned int enqueued;
	unsigned int ewma;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	unsigned long load_avg;
	unsigned long runnable_avg;
	unsigned long util_avg;
	struct util_est util_est;
};

struct cfs_rq;

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	u64 deadline;
	u64 min_deadline;
	struct list_head group_node;
	unsigned int on_rq;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 prev_sum_exec_runtime;
	u64 vruntime;
	s64 vlag;
	u64 slice;
	u64 nr_migrations;
	int depth;
	struct sched_entity *parent;
	struct cfs_rq *cfs_rq;
	struct cfs_rq *my_q;
	unsigned long runnable_weight;
	long: 64;
	long: 64;
	struct sched_avg avg;
};

struct sched_rt_entity {
	struct list_head run_list;
	unsigned long timeout;
	unsigned long watchdog_stamp;
	unsigned int time_slice;
	unsigned short on_rq;
	unsigned short on_list;
	struct sched_rt_entity *back;
};

typedef s64 ktime_t;

struct timerqueue_node {
	struct rb_node node;
	ktime_t expires;
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
};

struct sched_dl_entity {
	struct rb_node rb_node;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
	struct sched_dl_entity *pi_se;
};

struct sched_statistics {};

struct hlist_node;

struct hlist_head {
	struct hlist_node *first;
};

struct cpumask {
	unsigned long bits[4];
};

typedef struct cpumask cpumask_t;

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct sched_info {
	unsigned long pcount;
	unsigned long long run_delay;
	unsigned long long last_arrival;
	unsigned long long last_queued;
};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

typedef int __kernel_clockid_t;

typedef __kernel_clockid_t clockid_t;

struct __kernel_timespec;

struct old_timespec32;

struct pollfd;

struct restart_block {
	unsigned long arch_data;
	long (*fn)(struct restart_block *);
	union {
		struct {
			u32 __attribute__((btf_type_tag("user"))) *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 __attribute__((btf_type_tag("user"))) *uaddr2;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec __attribute__((btf_type_tag("user"))) *rmtp;
				struct old_timespec32 __attribute__((btf_type_tag("user"))) *compat_rmtp;
			};
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd __attribute__((btf_type_tag("user"))) *ufds;
			int nfds;
			int has_timeout;
			unsigned long tv_sec;
			unsigned long tv_nsec;
		} poll;
	};
};

typedef int __kernel_pid_t;

typedef __kernel_pid_t pid_t;

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

typedef struct raw_spinlock raw_spinlock_t;

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

typedef struct {
	s64 counter;
} atomic64_t;

typedef atomic64_t atomic_long_t;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct mutex {
	atomic_long_t owner;
	raw_spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct posix_cputimers_work {
	struct callback_head work;
	struct mutex mutex;
	unsigned int scheduled;
};

struct sem_undo_list;

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

typedef struct {
	unsigned long sig[1];
} sigset_t;

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

typedef unsigned int __kernel_uid32_t;

typedef __kernel_uid32_t uid_t;

typedef struct {
	uid_t val;
} kuid_t;

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct syscall_user_dispatch {};

struct wake_q_node {
	struct wake_q_node *next;
};

struct task_io_accounting {
	u64 rchar;
	u64 wchar;
	u64 syscr;
	u64 syscw;
	u64 read_bytes;
	u64 write_bytes;
	u64 cancelled_write_bytes;
};

typedef struct {
	unsigned long bits[1];
} nodemask_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

struct arch_tlbflush_unmap_batch {};

struct tlbflush_unmap_batch {
	struct arch_tlbflush_unmap_batch arch;
	bool flush_required;
	bool writable;
};

struct page;

struct page_frag {
	struct page *page;
	__u32 offset;
	__u32 size;
};

struct kmap_ctrl {};

struct timer_list {
	struct hlist_node entry;
	unsigned long expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct llist_head {
	struct llist_node *first;
};

struct cpu_context {
	unsigned long x19;
	unsigned long x20;
	unsigned long x21;
	unsigned long x22;
	unsigned long x23;
	unsigned long x24;
	unsigned long x25;
	unsigned long x26;
	unsigned long x27;
	unsigned long x28;
	unsigned long fp;
	unsigned long sp;
	unsigned long pc;
};

typedef unsigned __int128 __uint128_t;

struct user_fpsimd_state {
	__uint128_t vregs[32];
	__u32 fpsr;
	__u32 fpcr;
	__u32 __reserved[2];
};

struct perf_event;

struct debug_info {
	int suspended_step;
	int bps_disabled;
	int wps_disabled;
	struct perf_event *hbp_break[16];
	struct perf_event *hbp_watch[16];
};

struct ptrauth_key {
	unsigned long lo;
	unsigned long hi;
};

struct ptrauth_keys_user {
	struct ptrauth_key apia;
	struct ptrauth_key apib;
	struct ptrauth_key apda;
	struct ptrauth_key apdb;
	struct ptrauth_key apga;
};

struct ptrauth_keys_kernel {
	struct ptrauth_key apia;
};

struct thread_struct {
	struct cpu_context cpu_context;
	long: 64;
	struct {
		unsigned long tp_value;
		unsigned long tp2_value;
		struct user_fpsimd_state fpsimd_state;
	} uw;
	enum fp_type fp_type;
	unsigned int fpsimd_cpu;
	void *sve_state;
	void *sme_state;
	unsigned int vl[2];
	unsigned int vl_onexec[2];
	unsigned long fault_address;
	unsigned long fault_code;
	struct debug_info debug;
	struct ptrauth_keys_user keys_user;
	struct ptrauth_keys_kernel keys_kernel;
	u64 mte_ctrl;
	u64 sctlr_user;
	u64 svcr;
	u64 tpidr2_el0;
	long: 64;
};

struct sched_class;

struct task_group;

struct rcu_node;

struct mm_struct;

struct address_space;

struct pid;

struct completion;

struct cred;

struct key;

struct nameidata;

struct fs_struct;

struct files_struct;

struct io_uring_task;

struct nsproxy;

struct signal_struct;

struct sighand_struct;

struct audit_context;

struct rt_mutex_waiter;

struct bio_list;

struct blk_plug;

struct reclaim_state;

struct io_context;

struct capture_control;

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct css_set;

struct robust_list_head;

struct compat_robust_list_head;

struct futex_pi_state;

struct perf_event_context;

struct mempolicy;

struct numa_group;

struct rseq;

struct pipe_inode_info;

struct ftrace_ret_stack;

struct mem_cgroup;

struct obj_cgroup;

struct gendisk;

struct uprobe_task;

struct vm_struct;

struct bpf_local_storage;

struct bpf_run_ctx;

struct user_event_mm;

struct task_struct {
	struct thread_info thread_info;
	unsigned int __state;
	unsigned int saved_state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int wakee_flips;
	unsigned long wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct sched_dl_entity dl;
	const struct sched_class *sched_class;
	struct task_group *sched_task_group;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_statistics stats;
	struct hlist_head preempt_notifiers;
	unsigned int btrace_seq;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t *user_cpus_ptr;
	cpumask_t cpus_mask;
	void *migration_pending;
	unsigned short migration_disabled;
	unsigned short migration_flags;
	int rcu_read_lock_nesting;
	union rcu_special rcu_read_unlock_special;
	struct list_head rcu_node_entry;
	struct rcu_node *rcu_blocked_node;
	unsigned long rcu_tasks_nvcsw;
	u8 rcu_tasks_holdout;
	u8 rcu_tasks_idx;
	int rcu_tasks_idle_cpu;
	struct list_head rcu_tasks_holdout_list;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	struct list_head trc_holdout_list;
	struct list_head trc_blkd_node;
	int trc_blkd_cpu;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct address_space *faults_disabled_mapping;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	unsigned long jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	long: 29;
	unsigned int sched_remote_wakeup: 1;
	unsigned int sched_rt_mutex: 1;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int in_user_fault: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int use_memdelay: 1;
	unsigned int in_eventfd: 1;
	unsigned long atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	unsigned long stack_canary;
	struct task_struct __attribute__((btf_type_tag("rcu"))) *real_parent;
	struct task_struct __attribute__((btf_type_tag("rcu"))) *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_node;
	struct completion *vfork_done;
	int __attribute__((btf_type_tag("user"))) *set_child_tid;
	int __attribute__((btf_type_tag("user"))) *clear_child_tid;
	void *worker_private;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	unsigned long nvcsw;
	unsigned long nivcsw;
	u64 start_time;
	u64 start_boottime;
	unsigned long min_flt;
	unsigned long maj_flt;
	struct posix_cputimers posix_cputimers;
	struct posix_cputimers_work posix_cputimers_work;
	const struct cred __attribute__((btf_type_tag("rcu"))) *ptracer_cred;
	const struct cred __attribute__((btf_type_tag("rcu"))) *real_cred;
	const struct cred __attribute__((btf_type_tag("rcu"))) *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct __attribute__((btf_type_tag("rcu"))) *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	unsigned long sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct audit_context *audit_context;
	kuid_t loginuid;
	unsigned int sessionid;
	struct seccomp seccomp;
	struct syscall_user_dispatch syscall_dispatch;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct io_context *io_context;
	struct capture_control *capture_control;
	unsigned long ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	u64 acct_rss_mem1;
	u64 acct_vm_mem1;
	u64 acct_timexpd;
	nodemask_t mems_allowed;
	seqcount_spinlock_t mems_allowed_seq;
	int cpuset_mem_spread_rotor;
	int cpuset_slab_spread_rotor;
	struct css_set __attribute__((btf_type_tag("rcu"))) *cgroups;
	struct list_head cg_list;
	struct robust_list_head __attribute__((btf_type_tag("user"))) *robust_list;
	struct compat_robust_list_head __attribute__((btf_type_tag("user"))) *compat_robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context *perf_event_ctxp;
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct mempolicy *mempolicy;
	short il_prev;
	short pref_node_fork;
	int numa_scan_seq;
	unsigned int numa_scan_period;
	unsigned int numa_scan_period_max;
	int numa_preferred_nid;
	unsigned long numa_migrate_retry;
	u64 node_stamp;
	u64 last_task_numa_placement;
	u64 last_sum_exec_runtime;
	struct callback_head numa_work;
	struct numa_group __attribute__((btf_type_tag("rcu"))) *numa_group;
	unsigned long *numa_faults;
	unsigned long total_numa_faults;
	unsigned long numa_faults_locality[3];
	unsigned long numa_pages_migrated;
	struct rseq __attribute__((btf_type_tag("user"))) *rseq;
	u32 rseq_len;
	u32 rseq_sig;
	unsigned long rseq_event_mask;
	int mm_cid;
	int last_mm_cid;
	int migrate_from_cpu;
	int mm_cid_active;
	struct callback_head cid_work;
	struct tlbflush_unmap_batch tlb_ubc;
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	int nr_dirtied;
	int nr_dirtied_pause;
	unsigned long dirty_paused_when;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	int curr_ret_stack;
	int curr_ret_depth;
	struct ftrace_ret_stack *ret_stack;
	unsigned long long ftrace_timestamp;
	atomic_t trace_overrun;
	atomic_t tracing_graph_pause;
	unsigned long trace_recursion;
	struct mem_cgroup *memcg_in_oom;
	gfp_t memcg_oom_gfp_mask;
	int memcg_oom_order;
	unsigned int memcg_nr_pages_over_high;
	struct mem_cgroup *active_memcg;
	struct obj_cgroup *objcg;
	struct gendisk *throttle_disk;
	struct uprobe_task *utask;
	struct kmap_ctrl kmap_ctrl;
	struct callback_head rcu;
	refcount_t rcu_users;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct timer_list oom_reaper_timer;
	struct vm_struct *stack_vm_area;
	refcount_t stack_refcount;
	void *security;
	struct bpf_local_storage __attribute__((btf_type_tag("rcu"))) *bpf_storage;
	struct bpf_run_ctx *bpf_ctx;
	struct llist_head kretprobe_instances;
	struct user_event_mm *user_event_mm;
	struct thread_struct thread;
};

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)();
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int nr_events;
	unsigned short nr_retries;
	unsigned short nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	struct hrtimer_clock_base clock_base[8];
};

struct rq;

struct rq_flags;

struct affinity_context;

struct sched_class {
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	void (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*wakeup_preempt)(struct rq *, struct task_struct *, int);
	struct task_struct * (*pick_next_task)(struct rq *);
	void (*put_prev_task)(struct rq *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	int (*select_task_rq)(struct task_struct *, int, int);
	struct task_struct * (*pick_task)(struct rq *);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, struct affinity_context *);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	struct rq * (*find_lock_rq)(struct task_struct *, struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
	void (*task_change_group)(struct task_struct *);
};

typedef struct {} lockdep_map_p;

struct maple_tree {
	union {
		spinlock_t ma_lock;
		lockdep_map_p ma_external_lock;
	};
	unsigned int ma_flags;
	void __attribute__((btf_type_tag("rcu"))) *ma_root;
};

typedef u64 pgdval_t;

typedef struct {
	pgdval_t pgd;
} pgd_t;

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

typedef int __s32;

typedef __s32 s32;

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
	struct list_head list;
	s32 __attribute__((btf_type_tag("percpu"))) *counters;
};

typedef struct {
	atomic64_t id;
	void *sigpage;
	refcount_t pinned;
	void *vdso;
	unsigned long flags;
} mm_context_t;

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct file;

struct mm_cid;

struct linux_binfmt;

struct kioctx_table;

struct user_namespace;

struct mmu_notifier_subscriptions;

struct mm_struct {
	struct {
		struct {
			atomic_t mm_count;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
		};
		struct maple_tree mm_mt;
		unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
		unsigned long mmap_base;
		unsigned long mmap_legacy_base;
		unsigned long task_size;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		struct mm_cid __attribute__((btf_type_tag("percpu"))) *pcpu_cid;
		unsigned long mm_cid_next_scan;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		int mm_lock_seq;
		unsigned long hiwater_rss;
		unsigned long hiwater_vm;
		unsigned long total_vm;
		unsigned long locked_vm;
		atomic64_t pinned_vm;
		unsigned long data_vm;
		unsigned long exec_vm;
		unsigned long stack_vm;
		unsigned long def_flags;
		seqcount_t write_protect_seq;
		spinlock_t arg_lock;
		unsigned long start_code;
		unsigned long end_code;
		unsigned long start_data;
		unsigned long end_data;
		unsigned long start_brk;
		unsigned long brk;
		unsigned long start_stack;
		unsigned long arg_start;
		unsigned long arg_end;
		unsigned long env_start;
		unsigned long env_end;
		unsigned long saved_auxv[50];
		struct percpu_counter rss_stat[4];
		struct linux_binfmt *binfmt;
		mm_context_t context;
		unsigned long flags;
		spinlock_t ioctx_lock;
		struct kioctx_table __attribute__((btf_type_tag("rcu"))) *ioctx_table;
		struct task_struct __attribute__((btf_type_tag("rcu"))) *owner;
		struct user_namespace *user_ns;
		struct file __attribute__((btf_type_tag("rcu"))) *exe_file;
		struct mmu_notifier_subscriptions *notifier_subscriptions;
		unsigned long numa_next_scan;
		unsigned long numa_scan_offset;
		int numa_scan_seq;
		atomic_t tlb_flush_pending;
		atomic_t tlb_flush_batched;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
		unsigned long ksm_merging_pages;
		unsigned long ksm_rmap_items;
		unsigned long ksm_zero_pages;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	unsigned long cpu_bitmap[0];
};

typedef unsigned int fmode_t;

struct qrwlock {
	union {
		atomic_t cnts;
		struct {
			u8 wlocked;
			u8 __lstate[3];
		};
	};
	arch_spinlock_t wait_lock;
};

typedef struct qrwlock arch_rwlock_t;

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

struct fown_struct {
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file_ra_state {
	unsigned long start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	loff_t prev_pos;
};

struct vfsmount;

struct dentry;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

typedef u32 errseq_t;

struct inode;

struct file_operations;

struct file {
	union {
		struct llist_node f_llist;
		struct callback_head f_rcuhead;
		unsigned int f_iocb_flags;
	};
	spinlock_t f_lock;
	fmode_t f_mode;
	atomic_long_t f_count;
	struct mutex f_pos_lock;
	loff_t f_pos;
	unsigned int f_flags;
	struct fown_struct f_owner;
	const struct cred *f_cred;
	struct file_ra_state f_ra;
	struct path f_path;
	struct inode *f_inode;
	const struct file_operations *f_op;
	u64 f_version;
	void *f_security;
	void *private_data;
	struct hlist_head *f_ep;
	struct address_space *f_mapping;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
};

struct pid_namespace;

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[0];
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void __attribute__((btf_type_tag("rcu"))) *xa_head;
};

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct proc_ns_operations;

struct ns_common {
	atomic_long_t stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
	refcount_t count;
};

struct kmem_cache;

struct fs_pin;

struct ucounts;

struct pid_namespace {
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace *parent;
	struct fs_pin *bacct;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
	int memfd_noexec_scope;
};

struct nsset;

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

typedef unsigned int __kernel_gid32_t;

typedef __kernel_gid32_t gid_t;

typedef struct {
	gid_t val;
} kgid_t;

typedef struct {
	u64 val;
} kernel_cap_t;

struct user_struct;

struct group_info;

struct cred {
	atomic_long_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	void *security;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

typedef __s64 time64_t;

struct key_type;

struct key_tag;

struct keyring_index_key {
	unsigned long hash;
	union {
		struct {
			u16 desc_len;
			char desc[6];
		};
		unsigned long x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	unsigned long nr_leaves_on_tree;
};

union key_payload {
	void __attribute__((btf_type_tag("rcu"))) *rcu_data0;
	void *data[4];
};

typedef s32 int32_t;

typedef int32_t key_serial_t;

typedef u32 uint32_t;

typedef uint32_t key_perm_t;

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	unsigned short quotalen;
	unsigned short datalen;
	short state;
	unsigned long flags;
	union {
		struct keyring_index_key index_key;
		struct {
			unsigned long hash;
			unsigned long len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct lock_class_key {};

struct key_preparsed_payload;

struct key_match_data;

struct seq_file;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	unsigned long begin;
	unsigned long flags;
};

struct user_struct {
	refcount_t __count;
	struct percpu_counter epoll_watches;
	unsigned long unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
};

struct group_info {
	refcount_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct super_block;

struct mnt_idmap;

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
	struct mnt_idmap *mnt_idmap;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
};

struct lockref {
	union {
		__u64 lock_count;
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	struct qstr d_name;
	struct inode *d_inode;
	unsigned char d_iname[32];
	struct lockref d_lockref;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	unsigned long d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct timespec64 {
	time64_t tv_sec;
	long tv_nsec;
};

typedef u64 blkcnt_t;

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	struct rw_semaphore invalidate_lock;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	unsigned long nrpages;
	unsigned long writeback_index;
	const struct address_space_operations *a_ops;
	unsigned long flags;
	struct rw_semaphore i_mmap_rwsem;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
};

struct posix_acl;

struct inode_operations;

struct bdi_writeback;

struct file_lock_context;

struct cdev;

struct fsnotify_mark_connector;

struct inode {
	umode_t i_mode;
	unsigned short i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	void *i_security;
	unsigned long i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 __i_atime;
	struct timespec64 __i_mtime;
	struct timespec64 __i_ctime;
	spinlock_t i_lock;
	unsigned short i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	unsigned long i_state;
	struct rw_semaphore i_rwsem;
	unsigned long dirtied_when;
	unsigned long dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct bdi_writeback *i_wb;
	int i_wb_frn_winner;
	u16 i_wb_frn_avg_time;
	u16 i_wb_frn_history;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info *i_pipe;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector __attribute__((btf_type_tag("rcu"))) *i_fsnotify_marks;
	void *i_private;
};

typedef long __kernel_long_t;

typedef __kernel_long_t __kernel_ssize_t;

typedef __kernel_ssize_t ssize_t;

struct delayed_call;

struct iattr;

struct kstat;

struct fiemap_extent_info;

struct fileattr;

struct offset_ctx;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct mnt_idmap *, struct inode *, int);
	struct posix_acl * (*get_inode_acl)(struct inode *, int, bool);
	int (*readlink)(struct dentry *, char __attribute__((btf_type_tag("user"))) *, int);
	int (*create)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct mnt_idmap *, struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct mnt_idmap *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct mnt_idmap *, struct dentry *, struct iattr *);
	int (*getattr)(struct mnt_idmap *, const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct mnt_idmap *, struct inode *, struct file *, umode_t);
	struct posix_acl * (*get_acl)(struct mnt_idmap *, struct dentry *, int);
	int (*set_acl)(struct mnt_idmap *, struct dentry *, struct posix_acl *, int);
	int (*fileattr_set)(struct mnt_idmap *, struct dentry *, struct fileattr *);
	int (*fileattr_get)(struct dentry *, struct fileattr *);
	struct offset_ctx * (*get_offset_ctx)(struct inode *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

typedef struct {
	uid_t val;
} vfsuid_t;

typedef struct {
	gid_t val;
} vfsgid_t;

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	union {
		kuid_t ia_uid;
		vfsuid_t ia_vfsuid;
	};
	union {
		kgid_t ia_gid;
		vfsgid_t ia_vfsgid;
	};
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
	u32 dio_mem_align;
	u32 dio_offset_align;
	u64 change_cookie;
};

struct offset_ctx {
	struct xarray xa;
	u32 next_offset;
};

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

typedef long long qsize_t;

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	unsigned long dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct quota_format_ops;

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct rcuwait {
	struct task_struct __attribute__((btf_type_tag("rcu"))) *task;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int __attribute__((btf_type_tag("percpu"))) *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct sb_writers {
	unsigned short frozen;
	unsigned short freeze_holders;
	struct percpu_rw_semaphore rw_sem[3];
};

typedef struct {
	__u8 b[16];
} uuid_t;

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
	struct list_head list;
	int shrinker_id;
	bool memcg_aware;
	struct xarray xa;
};

struct file_system_type;

struct super_operations;

struct dquot_operations;

struct quotactl_ops;

struct export_operations;

struct xattr_handler;

struct block_device;

struct bdev_handle;

struct backing_dev_info;

struct mtd_info;

struct shrinker;

struct workqueue_struct;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	unsigned long s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	unsigned long s_flags;
	unsigned long s_iflags;
	unsigned long s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	void *s_security;
	const struct xattr_handler * const *s_xattr;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct bdev_handle *s_bdev_handle;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector __attribute__((btf_type_tag("rcu"))) *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	struct shrinker *s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_connectors;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
};

struct fs_context;

struct fs_parameter_spec;

struct module;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key invalidate_lock_key;
	struct lock_class_key i_mutex_dir_key;
};

struct p_log;

struct fs_parameter;

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	unsigned short flags;
	const void *data;
};

struct kref {
	refcount_t refcount;
};

struct kset;

struct kobj_type;

struct kernfs_node;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	const struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct module_memory {
	void *base;
	unsigned int size;
	struct mod_tree_node mtn;
};

struct mod_plt_sec {
	int plt_shndx;
	int plt_num_entries;
	int plt_max_entries;
};

struct plt_entry;

struct mod_arch_specific {
	struct mod_plt_sec core;
	struct mod_plt_sec init;
	struct plt_entry *ftrace_trampolines;
};

struct elf64_sym;

typedef struct elf64_sym Elf64_Sym;

struct mod_kallsyms {
	Elf64_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

typedef const int tracepoint_ptr_t;

struct module_attribute;

struct kernel_symbol;

struct kernel_param;

struct exception_table_entry;

struct bug_entry;

struct module_sect_attrs;

struct module_notes_attrs;

struct srcu_struct;

struct bpf_raw_event_map;

struct jump_entry;

struct trace_event_call;

struct trace_eval_map;

struct error_injection_entry;

struct module {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool async_probe_requested;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	struct module_memory mem[7];
	struct mod_arch_specific arch;
	unsigned long taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms __attribute__((btf_type_tag("rcu"))) *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void __attribute__((btf_type_tag("percpu"))) *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int btf_data_size;
	void *btf_data;
	struct jump_entry *jump_entries;
	unsigned int num_jump_entries;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	unsigned int num_ftrace_callsites;
	unsigned long *ftrace_callsites;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	unsigned long *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	struct error_injection_entry *ei_funcs;
	unsigned int num_ei_funcs;
	long: 64;
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kobj_uevent_env;

struct kset_uevent_ops {
	int (* const filter)(const struct kobject *);
	const char * (* const name)(const struct kobject *);
	int (* const uevent)(const struct kobject *, struct kobj_uevent_env *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct sysfs_ops;

struct attribute_group;

struct kobj_ns_type_operations;

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(const struct kobject *);
	const void * (*namespace)(const struct kobject *);
	void (*get_ownership)(const struct kobject *, kuid_t *, kgid_t *);
};

struct attribute;

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct bin_attribute;

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
	struct attribute **attrs;
	struct bin_attribute **bin_attrs;
};

struct vm_area_struct;

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	struct address_space * (*f_mapping)();
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	loff_t (*llseek)(struct file *, struct kobject *, struct bin_attribute *, loff_t, int);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};

typedef u64 sector_t;

struct writeback_control;

struct folio;

struct readahead_control;

struct kiocb;

struct iov_iter;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*read_folio)(struct file *, struct folio *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	bool (*dirty_folio)(struct address_space *, struct folio *);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, struct page **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidate_folio)(struct folio *, size_t, size_t);
	bool (*release_folio)(struct folio *, gfp_t);
	void (*free_folio)(struct folio *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migrate_folio)(struct address_space *, struct folio *, struct folio *, enum migrate_mode);
	int (*launder_folio)(struct folio *);
	bool (*is_partially_uptodate)(struct folio *, size_t, size_t);
	void (*is_dirty_writeback)(struct folio *, bool *, bool *);
	int (*error_remove_page)(struct address_space *, struct page *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
	int (*swap_rw)(struct kiocb *, struct iov_iter *);
};

struct page_pool;

struct dev_pagemap;

struct page {
	unsigned long flags;
	union {
		struct {
			union {
				struct list_head lru;
				struct {
					void *__filler;
					unsigned int mlock_count;
				};
				struct list_head buddy_list;
				struct list_head pcp_list;
			};
			struct address_space *mapping;
			union {
				unsigned long index;
				unsigned long share;
			};
			unsigned long private;
		};
		struct {
			unsigned long pp_magic;
			struct page_pool *pp;
			unsigned long _pp_mapping_pad;
			unsigned long dma_addr;
			atomic_long_t pp_frag_count;
		};
		struct {
			unsigned long compound_head;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
	};
	atomic_t _refcount;
	unsigned long memcg_data;
};

struct range {
	u64 start;
	u64 end;
};

struct vmem_altmap {
	unsigned long base_pfn;
	const unsigned long end_pfn;
	const unsigned long reserve;
	unsigned long free;
	unsigned long align;
	unsigned long alloc;
};

struct percpu_ref_data;

struct percpu_ref {
	unsigned long percpu_count_ptr;
	struct percpu_ref_data *data;
};

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	unsigned long vmemmap_shift;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct {
			struct {} __empty_ranges;
			struct range ranges[0];
		};
	};
};

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

typedef unsigned int vm_fault_t;

struct vm_fault;

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
	int (*memory_failure)(struct dev_pagemap *, unsigned long, unsigned long, int);
};

typedef u64 pteval_t;

typedef struct {
	pteval_t pte;
} pte_t;

typedef u64 pmdval_t;

typedef struct {
	pmdval_t pmd;
} pmd_t;

typedef u64 pudval_t;

typedef struct {
	pudval_t pud;
} pud_t;

typedef struct page *pgtable_t;

struct vm_fault {
	struct {
		struct vm_area_struct *vma;
		gfp_t gfp_mask;
		unsigned long pgoff;
		unsigned long address;
		unsigned long real_address;
	};
	enum fault_flag flags;
	pmd_t *pmd;
	pud_t *pud;
	union {
		pte_t orig_pte;
		pmd_t orig_pmd;
	};
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

typedef unsigned long vm_flags_t;

typedef struct {
	pteval_t pgprot;
} pgprot_t;

struct vm_userfaultfd_ctx {};

struct vma_lock;

struct anon_vma;

struct vm_operations_struct;

struct vma_numab_state;

struct vm_area_struct {
	union {
		struct {
			unsigned long vm_start;
			unsigned long vm_end;
		};
		struct callback_head vm_rcu;
	};
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	union {
		const vm_flags_t vm_flags;
		vm_flags_t __vm_flags;
	};
	int vm_lock_seq;
	struct vma_lock *vm_lock;
	bool detached;
	struct {
		struct rb_node rb;
		unsigned long rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	unsigned long vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct mempolicy *vm_policy;
	struct vma_numab_state *numab_state;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

struct vma_lock {
	struct rw_semaphore lock;
};

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*may_split)(struct vm_area_struct *, unsigned long);
	int (*mremap)(struct vm_area_struct *);
	int (*mprotect)(struct vm_area_struct *, unsigned long, unsigned long, unsigned long);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, unsigned int);
	vm_fault_t (*map_pages)(struct vm_fault *, unsigned long, unsigned long);
	unsigned long (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, unsigned long, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	int (*set_policy)(struct vm_area_struct *, struct mempolicy *);
	struct mempolicy * (*get_policy)(struct vm_area_struct *, unsigned long, unsigned long *);
	struct page * (*find_special_page)(struct vm_area_struct *, unsigned long);
};

struct vma_numab_state {
	unsigned long next_scan;
	unsigned long pids_active_reset;
	unsigned long pids_active[2];
	int prev_scan_seq;
};

typedef struct {
	unsigned long val;
} swp_entry_t;

struct folio {
	union {
		struct {
			unsigned long flags;
			union {
				struct list_head lru;
				struct {
					void *__filler;
					unsigned int mlock_count;
				};
			};
			struct address_space *mapping;
			unsigned long index;
			union {
				void *private;
				swp_entry_t swap;
			};
			atomic_t _mapcount;
			atomic_t _refcount;
			unsigned long memcg_data;
		};
		struct page page;
	};
	union {
		struct {
			unsigned long _flags_1;
			unsigned long _head_1;
			unsigned long _folio_avail;
			atomic_t _entire_mapcount;
			atomic_t _nr_pages_mapped;
			atomic_t _pincount;
			unsigned int _folio_nr_pages;
		};
		struct page __page_1;
	};
	union {
		struct {
			unsigned long _flags_2;
			unsigned long _head_2;
			void *_hugetlb_subpool;
			void *_hugetlb_cgroup;
			void *_hugetlb_cgroup_rsvd;
			void *_hugetlb_hwpoison;
		};
		struct {
			unsigned long _flags_2a;
			unsigned long _head_2a;
			struct list_head _deferred_list;
		};
		struct page __page_2;
	};
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long);
	void *private;
	int ki_flags;
	u16 ki_ioprio;
	union {
		struct wait_page_queue *ki_waitq;
		ssize_t (*dio_complete)(void *);
	};
};

struct iovec {
	void __attribute__((btf_type_tag("user"))) *iov_base;
	__kernel_size_t iov_len;
};

struct kvec;

struct bio_vec;

struct iov_iter {
	u8 iter_type;
	bool copy_mc;
	bool nofault;
	bool data_source;
	size_t iov_offset;
	union {
		struct iovec __ubuf_iovec;
		struct {
			union {
				const struct iovec *__iov;
				const struct kvec *kvec;
				const struct bio_vec *bvec;
				struct xarray *xarray;
				void __attribute__((btf_type_tag("user"))) *ubuf;
			};
			size_t count;
		};
	};
	union {
		unsigned long nr_segs;
		loff_t xarray_start;
	};
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct sock;

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)();
	void * (*grab_current_ns)();
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)();
	void (*drop_ns)(void *);
};

struct kernfs_root;

struct kernfs_elem_dir {
	unsigned long subdirs;
	struct rb_root children;
	struct kernfs_root *root;
	unsigned long rev;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_ops;

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node __attribute__((btf_type_tag("rcu"))) *open;
	loff_t size;
	struct kernfs_node *notify_next;
};

struct kernfs_iattrs;

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	void *priv;
	u64 id;
	unsigned short flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

typedef unsigned int __poll_t;

struct kernfs_open_file;

struct poll_table_struct;

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
	loff_t (*llseek)(struct kernfs_open_file *, loff_t, int);
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

struct kernfs_open_node {
	struct callback_head callback_head;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
	unsigned int nr_mmapped;
	unsigned int nr_to_release;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct kernel_symbol {
	int value_offset;
	int name_offset;
	int namespace_offset;
};

typedef signed char __s8;

typedef __s8 s8;

struct kernel_param_ops;

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

struct exception_table_entry {
	int insn;
	int fixup;
	short type;
	short data;
};

typedef __u32 __le32;

struct plt_entry {
	__le32 adrp;
	__le32 add;
	__le32 br;
};

struct bug_entry {
	int bug_addr_disp;
	int file_disp;
	unsigned short line;
	unsigned short flags;
};

typedef __u32 Elf64_Word;

typedef __u16 Elf64_Half;

typedef __u64 Elf64_Addr;

typedef __u64 Elf64_Xword;

struct elf64_sym {
	Elf64_Word st_name;
	unsigned char st_info;
	unsigned char st_other;
	Elf64_Half st_shndx;
	Elf64_Addr st_value;
	Elf64_Xword st_size;
};

struct lockdep_map {};

struct srcu_data;

struct srcu_usage;

struct srcu_struct {
	unsigned int srcu_idx;
	struct srcu_data __attribute__((btf_type_tag("percpu"))) *sda;
	struct lockdep_map dep_map;
	struct srcu_usage *srcu_sup;
};

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	unsigned long gp_seq[4];
	long len;
	long seglen[4];
	u8 flags;
};

struct srcu_node;

struct srcu_data {
	atomic_long_t srcu_lock_count[2];
	atomic_long_t srcu_unlock_count[2];
	int srcu_nmi_safety;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	unsigned long srcu_gp_seq_needed;
	unsigned long srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	unsigned long grpmask;
	int cpu;
	struct srcu_struct *ssp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct srcu_node {
	spinlock_t lock;
	unsigned long srcu_have_cbs[4];
	unsigned long srcu_data_have_cbs[4];
	unsigned long srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct srcu_usage {
	struct srcu_node *node;
	struct srcu_node *level[3];
	int srcu_size_state;
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	unsigned long srcu_gp_seq;
	unsigned long srcu_gp_seq_needed;
	unsigned long srcu_gp_seq_needed_exp;
	unsigned long srcu_gp_start;
	unsigned long srcu_last_gp_end;
	unsigned long srcu_size_jiffies;
	unsigned long srcu_n_lock_retries;
	unsigned long srcu_n_exp_nodelay;
	bool sda_is_static;
	unsigned long srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	unsigned long reschedule_jiffies;
	unsigned long reschedule_count;
	struct delayed_work work;
	struct srcu_struct *srcu_ssp;
};

struct tracepoint;

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	long: 64;
};

struct static_key_mod;

struct static_key {
	atomic_t enabled;
	union {
		unsigned long type;
		struct jump_entry *entries;
		struct static_key_mod *next;
	};
};

struct static_call_key;

struct tracepoint_func;

struct tracepoint {
	const char *name;
	struct static_key key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	void *probestub;
	int (*regfunc)();
	void (*unregfunc)();
	struct tracepoint_func __attribute__((btf_type_tag("rcu"))) *funcs;
};

struct jump_entry {
	s32 code;
	s32 target;
	long key;
};

struct static_call_key {
	void *func;
};

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct error_injection_entry {
	unsigned long addr;
	int etype;
};

struct kstatfs;

struct dquot;

struct shrink_control;

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *, enum freeze_holder);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *, enum freeze_holder);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot ** (*get_dquots)(struct inode *);
	long (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long (*free_cached_objects)(struct super_block *, struct shrink_control *);
	void (*shutdown)(struct super_block *);
};

typedef __kernel_uid32_t projid_t;

typedef struct {
	projid_t val;
} kprojid_t;

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	unsigned long dq_flags;
	struct mem_dqblk dq_dqb;
};

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	unsigned long nr_to_scan;
	unsigned long nr_scanned;
	struct mem_cgroup *memcg;
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct qc_info;

struct qc_dqblk;

struct qc_state;

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct qc_dqblk {
	int d_fieldmask;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	unsigned long long ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	struct qc_type_state s_state[3];
};

struct fid;

struct iomap;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
	unsigned long flags;
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct mnt_idmap *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

typedef struct {
	int val[2];
} __kernel_fsid_t;

typedef struct fsnotify_mark_connector __attribute__((btf_type_tag("rcu"))) *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	unsigned short type;
	unsigned short flags;
	__kernel_fsid_t fsid;
	union {
		fsnotify_connp_t *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, const struct inode *);
	long: 64;
	long: 64;
	long: 64;
};

struct shrinker {
	unsigned long (*count_objects)(struct shrinker *, struct shrink_control *);
	unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *);
	long batch;
	int seeks;
	unsigned int flags;
	refcount_t refcount;
	struct completion done;
	struct callback_head rcu;
	void *private_data;
	struct list_head list;
	int id;
	atomic_long_t *nr_deferred;
};

struct list_lru_one {
	struct list_head list;
	long nr_items;
};

struct list_lru_node {
	spinlock_t lock;
	struct list_lru_one lru;
	long nr_items;
	long: 64;
	long: 64;
	long: 64;
};

typedef void *fl_owner_t;

struct io_comp_batch;

struct dir_context;

struct file_lock;

struct io_uring_cmd;

struct file_operations {
	struct module *owner;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, struct io_comp_batch *, unsigned int);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long (*unlocked_ioctl)(struct file *, unsigned int, unsigned long);
	long (*compat_ioctl)(struct file *, unsigned int, unsigned long);
	int (*mmap)(struct file *, struct vm_area_struct *);
	unsigned long mmap_supported_flags;
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*splice_eof)(struct file *);
	int (*setlease)(struct file *, int, struct file_lock **, void **);
	long (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
	int (*uring_cmd)(struct io_uring_cmd *, unsigned int);
	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int);
};

typedef bool (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	loff_t pos;
};

struct mm_cid {
	u64 time;
	int cid;
};

struct kioctx;

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx __attribute__((btf_type_tag("rcu"))) *table[0];
};

typedef long long __kernel_time64_t;

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long tv_nsec;
};

typedef s32 old_time32_t;

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct pollfd {
	int fd;
	short events;
	short revents;
};

struct uts_namespace;

struct ipc_namespace;

struct mnt_namespace;

struct net;

struct time_namespace;

struct cgroup_namespace;

struct nsproxy {
	refcount_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct pacct_struct {
	int ac_flag;
	long ac_exitcode;
	unsigned long ac_mem;
	u64 ac_utime;
	u64 ac_stime;
	unsigned long ac_minflt;
	unsigned long ac_majflt;
};

struct core_state;

struct tty_struct;

struct autogroup;

struct taskstats;

struct tty_audit_buf;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	int quick_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exec_task;
	int group_stop_count;
	unsigned int flags;
	struct core_state *core_state;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	unsigned int next_posix_timer_id;
	struct list_head posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	struct autogroup *autogroup;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	unsigned long nvcsw;
	unsigned long nivcsw;
	unsigned long cnvcsw;
	unsigned long cnivcsw;
	unsigned long min_flt;
	unsigned long maj_flt;
	unsigned long cmin_flt;
	unsigned long cmaj_flt;
	unsigned long inblock;
	unsigned long oublock;
	unsigned long cinblock;
	unsigned long coublock;
	unsigned long maxrss;
	unsigned long cmaxrss;
	struct task_io_accounting ioac;
	unsigned long long sum_sched_runtime;
	struct rlimit rlim[16];
	struct pacct_struct pacct;
	struct taskstats *stats;
	unsigned int audit_tty;
	struct tty_audit_buf *tty_audit_buf;
	bool oom_flag_origin;
	short oom_score_adj;
	short oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

typedef void __signalfn_t(int);

typedef __signalfn_t __attribute__((btf_type_tag("user"))) *__sighandler_t;

typedef void __restorefn_t();

typedef __restorefn_t __attribute__((btf_type_tag("user"))) *__sigrestore_t;

struct sigaction {
	__sighandler_t sa_handler;
	unsigned long sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct io_cq;

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	unsigned short ioprio;
	spinlock_t lock;
	struct xarray icq_tree;
	struct io_cq __attribute__((btf_type_tag("rcu"))) *icq_hint;
	struct hlist_head icq_list;
	struct work_struct release_work;
};

struct request_queue;

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

typedef int __kernel_timer_t;

union sigval {
	int sival_int;
	void __attribute__((btf_type_tag("user"))) *sival_ptr;
};

typedef union sigval sigval_t;

typedef __kernel_long_t __kernel_clock_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void __attribute__((btf_type_tag("user"))) *_addr;
		union {
			int _trapno;
			short _addr_lsb;
			struct {
				char _dummy_bnd[8];
				void __attribute__((btf_type_tag("user"))) *_lower;
				void __attribute__((btf_type_tag("user"))) *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[8];
				__u32 _pkey;
			} _addr_pkey;
			struct {
				unsigned long _data;
				__u32 _type;
				__u32 _flags;
			} _perf;
		};
	} _sigfault;
	struct {
		long _band;
		int _fd;
	} _sigpoll;
	struct {
		void __attribute__((btf_type_tag("user"))) *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct cgroup_subsys_state;

struct cgroup;

struct css_set {
	struct cgroup_subsys_state *subsys[14];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[14];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_src_preload_node;
	struct list_head mg_dst_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct robust_list {
	struct robust_list __attribute__((btf_type_tag("user"))) *next;
};

struct robust_list_head {
	struct robust_list list;
	long futex_offset;
	struct robust_list __attribute__((btf_type_tag("user"))) *list_op_pending;
};

typedef u32 compat_uptr_t;

struct compat_robust_list {
	compat_uptr_t next;
};

typedef s32 compat_long_t;

struct compat_robust_list_head {
	struct compat_robust_list list;
	compat_long_t futex_offset;
	compat_uptr_t list_op_pending;
};

struct numa_group {
	refcount_t refcount;
	spinlock_t lock;
	int nr_tasks;
	pid_t gid;
	int active_nodes;
	struct callback_head rcu;
	unsigned long total_faults;
	unsigned long max_faults_cpu;
	unsigned long faults[0];
};

struct rseq {
	__u32 cpu_id_start;
	__u32 cpu_id;
	__u64 rseq_cs;
	__u32 flags;
	__u32 node_id;
	__u32 mm_cid;
	char end[0];
};

struct ftrace_ret_stack {
	unsigned long ret;
	unsigned long func;
	unsigned long long calltime;
	unsigned long long subtime;
	unsigned long fp;
	unsigned long *retp;
};

struct arch_uprobe_task {};

struct uprobe;

struct return_instance;

struct uprobe_task {
	enum uprobe_task_state state;
	union {
		struct {
			struct arch_uprobe_task autask;
			unsigned long vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			unsigned long dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	unsigned long xol_vaddr;
	struct return_instance *return_instances;
	unsigned int depth;
};

struct return_instance {
	struct uprobe *uprobe;
	unsigned long func;
	unsigned long stack;
	unsigned long orig_ret_vaddr;
	bool chained;
	struct return_instance *next;
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	unsigned long size;
	unsigned long flags;
	struct page **pages;
	unsigned int page_order;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct bpf_local_storage_data;

struct bpf_local_storage_map;

struct bpf_local_storage {
	struct bpf_local_storage_data __attribute__((btf_type_tag("rcu"))) *cache[16];
	struct bpf_local_storage_map __attribute__((btf_type_tag("rcu"))) *smap;
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

typedef bool (*stack_trace_consume_fn)(void *, unsigned long);

struct user_pt_regs {
	__u64 regs[31];
	__u64 sp;
	__u64 pc;
	__u64 pstate;
};

struct pt_regs {
	union {
		struct user_pt_regs user_regs;
		struct {
			u64 regs[31];
			u64 sp;
			u64 pc;
			u64 pstate;
		};
	};
	u64 orig_x0;
	s32 syscallno;
	u32 unused2;
	u64 sdei_ttbr1;
	u64 pmr_save;
	u64 stackframe[2];
	u64 lockdep_hardirqs;
	u64 exit_rcu;
};

struct return_address_data {
	unsigned int level;
	void *addr;
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head defer_sync;
	enum dl_dev_state status;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

enum rpm_status {
	RPM_INVALID = -1,
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct device;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	unsigned int must_resume: 1;
	unsigned int may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int needs_force_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	enum rpm_status last_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
};

struct irq_domain;

struct msi_device_data;

struct dev_msi_info {
	struct irq_domain *domain;
	struct msi_device_data *data;
};

struct dev_archdata {};

enum device_removable {
	DEVICE_REMOVABLE_NOT_SUPPORTED = 0,
	DEVICE_REMOVABLE_UNKNOWN = 1,
	DEVICE_FIXED = 2,
	DEVICE_REMOVABLE = 3,
};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct em_perf_domain;

struct dev_pin_info;

struct dma_map_ops;

struct bus_dma_region;

struct device_dma_parameters;

struct dma_coherent_mem;

struct cma;

struct io_tlb_mem;

struct device_node;

struct fwnode_handle;

struct class;

struct iommu_group;

struct dev_iommu;

struct device_physical_location;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	const struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct em_perf_domain *em_pd;
	struct dev_pin_info *pins;
	struct dev_msi_info msi;
	const struct dma_map_ops *dma_ops;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct dma_coherent_mem *dma_mem;
	struct cma *cma_area;
	struct io_tlb_mem *dma_io_tlb_mem;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	int numa_node;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	const struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	struct device_physical_location *physical_location;
	enum device_removable removable;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
	bool can_match: 1;
	bool dma_coherent: 1;
};

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct cpuinfo_32bit {
	u32 reg_id_dfr0;
	u32 reg_id_dfr1;
	u32 reg_id_isar0;
	u32 reg_id_isar1;
	u32 reg_id_isar2;
	u32 reg_id_isar3;
	u32 reg_id_isar4;
	u32 reg_id_isar5;
	u32 reg_id_isar6;
	u32 reg_id_mmfr0;
	u32 reg_id_mmfr1;
	u32 reg_id_mmfr2;
	u32 reg_id_mmfr3;
	u32 reg_id_mmfr4;
	u32 reg_id_mmfr5;
	u32 reg_id_pfr0;
	u32 reg_id_pfr1;
	u32 reg_id_pfr2;
	u32 reg_mvfr0;
	u32 reg_mvfr1;
	u32 reg_mvfr2;
};

struct cpuinfo_arm64 {
	struct cpu cpu;
	struct kobject kobj;
	u64 reg_ctr;
	u64 reg_cntfrq;
	u64 reg_dczid;
	u64 reg_midr;
	u64 reg_revidr;
	u64 reg_gmid;
	u64 reg_smidr;
	u64 reg_id_aa64dfr0;
	u64 reg_id_aa64dfr1;
	u64 reg_id_aa64isar0;
	u64 reg_id_aa64isar1;
	u64 reg_id_aa64isar2;
	u64 reg_id_aa64mmfr0;
	u64 reg_id_aa64mmfr1;
	u64 reg_id_aa64mmfr2;
	u64 reg_id_aa64mmfr3;
	u64 reg_id_aa64pfr0;
	u64 reg_id_aa64pfr1;
	u64 reg_id_aa64zfr0;
	u64 reg_id_aa64smfr0;
	struct cpuinfo_32bit aarch32;
};

struct dev_pm_ops;

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(const struct device *, struct kobj_uevent_env *);
	char * (*devnode)(const struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

struct iommu_ops;

struct bus_type {
	const char *name;
	const char *dev_name;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, struct device_driver *);
	int (*uevent)(const struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	void (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	void (*dma_cleanup)(struct device *);
	const struct dev_pm_ops *pm;
	const struct iommu_ops *iommu_ops;
	bool need_parent_lock;
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

struct of_device_id;

struct acpi_device_id;

struct driver_private;

struct device_driver {
	const char *name;
	const struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

typedef unsigned long kernel_ulong_t;

struct acpi_device_id {
	__u8 id[16];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

enum iommu_cap {
	IOMMU_CAP_CACHE_COHERENCY = 0,
	IOMMU_CAP_NOEXEC = 1,
	IOMMU_CAP_PRE_BOOT_PROTECTION = 2,
	IOMMU_CAP_ENFORCE_CACHE_COHERENCY = 3,
	IOMMU_CAP_DEFERRED_FLUSH = 4,
	IOMMU_CAP_DIRTY_TRACKING = 5,
};

enum iommu_dev_features {
	IOMMU_DEV_FEAT_SVA = 0,
	IOMMU_DEV_FEAT_IOPF = 1,
};

typedef unsigned int ioasid_t;

struct iommu_domain;

struct iommu_user_data;

struct iommu_device;

struct of_phandle_args;

struct iommu_fault_event;

struct iommu_page_response;

struct iommu_domain_ops;

struct iommu_ops {
	bool (*capable)(struct device *, enum iommu_cap);
	void * (*hw_info)(struct device *, u32 *, u32 *);
	struct iommu_domain * (*domain_alloc)(unsigned int);
	struct iommu_domain * (*domain_alloc_user)(struct device *, u32, struct iommu_domain *, const struct iommu_user_data *);
	struct iommu_domain * (*domain_alloc_paging)(struct device *);
	struct iommu_device * (*probe_device)(struct device *);
	void (*release_device)(struct device *);
	void (*probe_finalize)(struct device *);
	struct iommu_group * (*device_group)(struct device *);
	void (*get_resv_regions)(struct device *, struct list_head *);
	int (*of_xlate)(struct device *, struct of_phandle_args *);
	bool (*is_attach_deferred)(struct device *);
	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
	int (*page_response)(struct device *, struct iommu_fault_event *, struct iommu_page_response *);
	int (*def_domain_type)(struct device *);
	void (*remove_dev_pasid)(struct device *, ioasid_t);
	const struct iommu_domain_ops *default_domain_ops;
	unsigned long pgsize_bitmap;
	struct module *owner;
	struct iommu_domain *identity_domain;
	struct iommu_domain *blocked_domain;
	struct iommu_domain *default_domain;
};

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	unsigned long timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	unsigned long event_count;
	unsigned long active_count;
	unsigned long relax_count;
	unsigned long expire_count;
	unsigned long wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct pm_domain_data;

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
	unsigned int clock_op_might_sleep;
	struct mutex clock_mutex;
	struct list_head clock_list;
	struct pm_domain_data *domain_data;
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
	int (*set_performance_state)(struct device *, unsigned int);
};

struct em_perf_state;

struct em_perf_domain {
	struct em_perf_state *table;
	int nr_perf_states;
	unsigned long flags;
	unsigned long cpus[0];
};

struct em_perf_state {
	unsigned long frequency;
	unsigned long power;
	unsigned long cost;
	unsigned long flags;
};

typedef u64 dma_addr_t;

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

struct sg_table;

struct scatterlist;

struct dma_map_ops {
	unsigned int flags;
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, unsigned long);
	void (*free)(struct device *, size_t, void *, dma_addr_t, unsigned long);
	struct page * (*alloc_pages)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	struct sg_table * (*alloc_noncontiguous)(struct device *, size_t, enum dma_data_direction, gfp_t, unsigned long);
	void (*free_noncontiguous)(struct device *, size_t, struct sg_table *, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, unsigned long);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, unsigned long);
	dma_addr_t (*map_page)(struct device *, struct page *, unsigned long, size_t, enum dma_data_direction, unsigned long);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, unsigned long);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, unsigned long);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, unsigned long);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, unsigned long);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, unsigned long);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	size_t (*opt_mapping_size)();
	unsigned long (*get_merge_boundary)(struct device *);
};

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
	u64 offset;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	unsigned int min_align_mask;
	unsigned long segment_boundary_mask;
};

struct class {
	const char *name;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	int (*dev_uevent)(const struct device *, struct kobj_uevent_env *);
	char * (*devnode)(const struct device *, umode_t *);
	void (*class_release)(const struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(const struct device *);
	void (*get_ownership)(const struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
};

enum device_physical_location_panel {
	DEVICE_PANEL_TOP = 0,
	DEVICE_PANEL_BOTTOM = 1,
	DEVICE_PANEL_LEFT = 2,
	DEVICE_PANEL_RIGHT = 3,
	DEVICE_PANEL_FRONT = 4,
	DEVICE_PANEL_BACK = 5,
	DEVICE_PANEL_UNKNOWN = 6,
};

enum device_physical_location_vertical_position {
	DEVICE_VERT_POS_UPPER = 0,
	DEVICE_VERT_POS_CENTER = 1,
	DEVICE_VERT_POS_LOWER = 2,
};

enum device_physical_location_horizontal_position {
	DEVICE_HORI_POS_LEFT = 0,
	DEVICE_HORI_POS_CENTER = 1,
	DEVICE_HORI_POS_RIGHT = 2,
};

struct device_physical_location {
	enum device_physical_location_panel panel;
	enum device_physical_location_vertical_position vertical_position;
	enum device_physical_location_horizontal_position horizontal_position;
	bool dock;
	bool lid;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

enum cpuhp_state {
	CPUHP_INVALID = -1,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_APB_DEAD = 8,
	CPUHP_X86_MCE_DEAD = 9,
	CPUHP_VIRT_NET_DEAD = 10,
	CPUHP_IBMVNIC_DEAD = 11,
	CPUHP_SLUB_DEAD = 12,
	CPUHP_DEBUG_OBJ_DEAD = 13,
	CPUHP_MM_WRITEBACK_DEAD = 14,
	CPUHP_MM_DEMOTION_DEAD = 15,
	CPUHP_MM_VMSTAT_DEAD = 16,
	CPUHP_SOFTIRQ_DEAD = 17,
	CPUHP_NET_MVNETA_DEAD = 18,
	CPUHP_CPUIDLE_DEAD = 19,
	CPUHP_ARM64_FPSIMD_DEAD = 20,
	CPUHP_ARM_OMAP_WAKE_DEAD = 21,
	CPUHP_IRQ_POLL_DEAD = 22,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 23,
	CPUHP_BIO_DEAD = 24,
	CPUHP_ACPI_CPUDRV_DEAD = 25,
	CPUHP_S390_PFAULT_DEAD = 26,
	CPUHP_BLK_MQ_DEAD = 27,
	CPUHP_FS_BUFF_DEAD = 28,
	CPUHP_PRINTK_DEAD = 29,
	CPUHP_MM_MEMCQ_DEAD = 30,
	CPUHP_PERCPU_CNT_DEAD = 31,
	CPUHP_RADIX_DEAD = 32,
	CPUHP_PAGE_ALLOC = 33,
	CPUHP_NET_DEV_DEAD = 34,
	CPUHP_PCI_XGENE_DEAD = 35,
	CPUHP_IOMMU_IOVA_DEAD = 36,
	CPUHP_LUSTRE_CFS_DEAD = 37,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 38,
	CPUHP_PADATA_DEAD = 39,
	CPUHP_AP_DTPM_CPU_DEAD = 40,
	CPUHP_RANDOM_PREPARE = 41,
	CPUHP_WORKQUEUE_PREP = 42,
	CPUHP_POWER_NUMA_PREPARE = 43,
	CPUHP_HRTIMERS_PREPARE = 44,
	CPUHP_PROFILE_PREPARE = 45,
	CPUHP_X2APIC_PREPARE = 46,
	CPUHP_SMPCFD_PREPARE = 47,
	CPUHP_RELAY_PREPARE = 48,
	CPUHP_SLAB_PREPARE = 49,
	CPUHP_MD_RAID5_PREPARE = 50,
	CPUHP_RCUTREE_PREP = 51,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 52,
	CPUHP_POWERPC_PMAC_PREPARE = 53,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 54,
	CPUHP_XEN_PREPARE = 55,
	CPUHP_XEN_EVTCHN_PREPARE = 56,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 57,
	CPUHP_SH_SH3X_PREPARE = 58,
	CPUHP_NET_FLOW_PREPARE = 59,
	CPUHP_TOPOLOGY_PREPARE = 60,
	CPUHP_NET_IUCV_PREPARE = 61,
	CPUHP_ARM_BL_PREPARE = 62,
	CPUHP_TRACE_RB_PREPARE = 63,
	CPUHP_MM_ZS_PREPARE = 64,
	CPUHP_MM_ZSWP_MEM_PREPARE = 65,
	CPUHP_MM_ZSWP_POOL_PREPARE = 66,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 67,
	CPUHP_ZCOMP_PREPARE = 68,
	CPUHP_TIMERS_PREPARE = 69,
	CPUHP_MIPS_SOC_PREPARE = 70,
	CPUHP_BP_PREPARE_DYN = 71,
	CPUHP_BP_PREPARE_DYN_END = 91,
	CPUHP_BP_KICK_AP = 92,
	CPUHP_BRINGUP_CPU = 93,
	CPUHP_AP_IDLE_DEAD = 94,
	CPUHP_AP_OFFLINE = 95,
	CPUHP_AP_CACHECTRL_STARTING = 96,
	CPUHP_AP_SCHED_STARTING = 97,
	CPUHP_AP_RCUTREE_DYING = 98,
	CPUHP_AP_CPU_PM_STARTING = 99,
	CPUHP_AP_IRQ_GIC_STARTING = 100,
	CPUHP_AP_IRQ_HIP04_STARTING = 101,
	CPUHP_AP_IRQ_APPLE_AIC_STARTING = 102,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 103,
	CPUHP_AP_IRQ_BCM2836_STARTING = 104,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 105,
	CPUHP_AP_IRQ_RISCV_STARTING = 106,
	CPUHP_AP_IRQ_LOONGARCH_STARTING = 107,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 108,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 109,
	CPUHP_AP_MICROCODE_LOADER = 110,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 111,
	CPUHP_AP_PERF_X86_STARTING = 112,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 113,
	CPUHP_AP_PERF_X86_CQM_STARTING = 114,
	CPUHP_AP_PERF_X86_CSTATE_STARTING = 115,
	CPUHP_AP_PERF_XTENSA_STARTING = 116,
	CPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 117,
	CPUHP_AP_ARM_VFP_STARTING = 118,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 119,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 120,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 121,
	CPUHP_AP_PERF_ARM_STARTING = 122,
	CPUHP_AP_PERF_RISCV_STARTING = 123,
	CPUHP_AP_ARM_L2X0_STARTING = 124,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 125,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 126,
	CPUHP_AP_ARM_ARCH_TIMER_EVTSTRM_STARTING = 127,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 128,
	CPUHP_AP_JCORE_TIMER_STARTING = 129,
	CPUHP_AP_ARM_TWD_STARTING = 130,
	CPUHP_AP_QCOM_TIMER_STARTING = 131,
	CPUHP_AP_TEGRA_TIMER_STARTING = 132,
	CPUHP_AP_ARMADA_TIMER_STARTING = 133,
	CPUHP_AP_MARCO_TIMER_STARTING = 134,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 135,
	CPUHP_AP_ARC_TIMER_STARTING = 136,
	CPUHP_AP_RISCV_TIMER_STARTING = 137,
	CPUHP_AP_CLINT_TIMER_STARTING = 138,
	CPUHP_AP_CSKY_TIMER_STARTING = 139,
	CPUHP_AP_TI_GP_TIMER_STARTING = 140,
	CPUHP_AP_HYPERV_TIMER_STARTING = 141,
	CPUHP_AP_DUMMY_TIMER_STARTING = 142,
	CPUHP_AP_ARM_XEN_STARTING = 143,
	CPUHP_AP_ARM_XEN_RUNSTATE_STARTING = 144,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 145,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 146,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 147,
	CPUHP_AP_SMPCFD_DYING = 148,
	CPUHP_AP_HRTIMERS_DYING = 149,
	CPUHP_AP_X86_TBOOT_DYING = 150,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 151,
	CPUHP_AP_ONLINE = 152,
	CPUHP_TEARDOWN_CPU = 153,
	CPUHP_AP_ONLINE_IDLE = 154,
	CPUHP_AP_HYPERV_ONLINE = 155,
	CPUHP_AP_KVM_ONLINE = 156,
	CPUHP_AP_SCHED_WAIT_EMPTY = 157,
	CPUHP_AP_SMPBOOT_THREADS = 158,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 159,
	CPUHP_AP_BLK_MQ_ONLINE = 160,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 161,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 162,
	CPUHP_AP_PERF_ONLINE = 163,
	CPUHP_AP_PERF_X86_ONLINE = 164,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 165,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 166,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 167,
	CPUHP_AP_PERF_X86_RAPL_ONLINE = 168,
	CPUHP_AP_PERF_X86_CQM_ONLINE = 169,
	CPUHP_AP_PERF_X86_CSTATE_ONLINE = 170,
	CPUHP_AP_PERF_X86_IDXD_ONLINE = 171,
	CPUHP_AP_PERF_S390_CF_ONLINE = 172,
	CPUHP_AP_PERF_S390_SF_ONLINE = 173,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 174,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 175,
	CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE = 176,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 177,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 178,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 179,
	CPUHP_AP_PERF_ARM_HISI_PA_ONLINE = 180,
	CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE = 181,
	CPUHP_AP_PERF_ARM_HISI_PCIE_PMU_ONLINE = 182,
	CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE = 183,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 184,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 185,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 186,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 187,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 188,
	CPUHP_AP_PERF_ARM_MARVELL_CN10K_DDR_ONLINE = 189,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 190,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 191,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 192,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 193,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 194,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 195,
	CPUHP_AP_PERF_CSKY_ONLINE = 196,
	CPUHP_AP_WATCHDOG_ONLINE = 197,
	CPUHP_AP_WORKQUEUE_ONLINE = 198,
	CPUHP_AP_RANDOM_ONLINE = 199,
	CPUHP_AP_RCUTREE_ONLINE = 200,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 201,
	CPUHP_AP_ONLINE_DYN = 202,
	CPUHP_AP_ONLINE_DYN_END = 232,
	CPUHP_AP_MM_DEMOTION_ONLINE = 233,
	CPUHP_AP_X86_HPET_ONLINE = 234,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 235,
	CPUHP_AP_ACTIVE = 236,
	CPUHP_ONLINE = 237,
};

struct midr_range {
	u32 model;
	u32 rv_min;
	u32 rv_max;
};

struct arm64_midr_revidr;

struct arm64_cpu_capabilities {
	const char *desc;
	u16 capability;
	u16 type;
	bool (*matches)(const struct arm64_cpu_capabilities *, int);
	void (*cpu_enable)(const struct arm64_cpu_capabilities *);
	union {
		struct {
			struct midr_range midr_range;
			const struct arm64_midr_revidr * const fixed_revs;
		};
		const struct midr_range *midr_range_list;
		struct {
			u32 sys_reg;
			u8 field_pos;
			u8 field_width;
			u8 min_field_value;
			u8 hwcap_type;
			bool sign;
			unsigned long hwcap;
		};
	};
	const struct arm64_cpu_capabilities *match_list;
	const struct cpumask *cpus;
};

struct arm64_midr_revidr {
	u32 midr_rv;
	u32 revidr_mask;
};

struct static_key_false {
	struct static_key key;
};

struct arm64_ftr_override;

struct arm64_ftr_bits;

struct arm64_ftr_reg {
	const char *name;
	u64 strict_mask;
	u64 user_mask;
	u64 sys_val;
	u64 user_val;
	struct arm64_ftr_override *override;
	const struct arm64_ftr_bits *ftr_bits;
};

struct arm64_ftr_override {
	u64 val;
	u64 mask;
};

enum ftr_type {
	FTR_EXACT = 0,
	FTR_LOWER_SAFE = 1,
	FTR_HIGHER_SAFE = 2,
	FTR_HIGHER_OR_ZERO_SAFE = 3,
};

struct arm64_ftr_bits {
	bool sign;
	bool visible;
	bool strict;
	enum ftr_type type;
	u8 shift;
	u8 width;
	s64 safe_val;
};

typedef struct cpumask cpumask_var_t[1];

struct __ftr_reg_entry {
	u32 sys_id;
	struct arm64_ftr_reg *reg;
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	u32 nr_extents;
	union {
		struct uid_gid_extent extent[5];
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			struct ctl_table *ctl_table;
			int ctl_table_size;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	unsigned long flags;
	bool parent_could_setfcap;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	long ucount_max[12];
	long rlimit_max[4];
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	atomic_t count;
	atomic_long_t ucount[12];
	atomic_long_t rlimit[4];
};

struct cgroup_namespace {
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
};

struct cgroup_file {
	struct kernfs_node *kn;
	unsigned long notified_at;
	struct timer_list notify_timer;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	unsigned long long sum_exec_runtime;
};

struct cgroup_base_stat {
	struct task_cputime cputime;
};

struct bpf_prog_array;

struct cgroup_bpf {
	struct bpf_prog_array __attribute__((btf_type_tag("rcu"))) *effective[38];
	struct hlist_head progs[38];
	u8 flags[38];
	struct list_head storages;
	struct bpf_prog_array *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_freezer_state {
	bool freeze;
	int e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct psi_group;

struct cgroup {
	struct cgroup_subsys_state self;
	unsigned long flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	struct cgroup_file psi_files[0];
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state __attribute__((btf_type_tag("rcu"))) *subsys[14];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[14];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu __attribute__((btf_type_tag("percpu"))) *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group *psi;
	struct cgroup_bpf bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	struct bpf_local_storage __attribute__((btf_type_tag("rcu"))) *bpf_cgrp_storage;
	struct cgroup *ancestors[0];
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct cgroup cgrp;
	struct cgroup *cgrp_ancestor_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
};

struct u64_stats_sync {};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat subtree_bstat;
	struct cgroup_base_stat last_subtree_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct psi_group {};

struct bpf_prog;

struct bpf_cgroup_storage;

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	union {
		struct bpf_cgroup_storage *cgroup_storage[2];
		u64 bpf_cookie;
	};
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct cgroup_taskset;

struct cftype;

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*css_local_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cftype {
	char name[64];
	unsigned long private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
};

struct taskstats {
	__u16 version;
	__u32 ac_exitcode;
	__u8 ac_flag;
	__u8 ac_nice;
	__u64 cpu_count;
	__u64 cpu_delay_total;
	__u64 blkio_count;
	__u64 blkio_delay_total;
	__u64 swapin_count;
	__u64 swapin_delay_total;
	__u64 cpu_run_real_total;
	__u64 cpu_run_virtual_total;
	char ac_comm[32];
	__u8 ac_sched;
	__u8 ac_pad[3];
	long: 0;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u64 ac_etime;
	__u64 ac_utime;
	__u64 ac_stime;
	__u64 ac_minflt;
	__u64 ac_majflt;
	__u64 coremem;
	__u64 virtmem;
	__u64 hiwater_rss;
	__u64 hiwater_vm;
	__u64 read_char;
	__u64 write_char;
	__u64 read_syscalls;
	__u64 write_syscalls;
	__u64 read_bytes;
	__u64 write_bytes;
	__u64 cancelled_write_bytes;
	__u64 nvcsw;
	__u64 nivcsw;
	__u64 ac_utimescaled;
	__u64 ac_stimescaled;
	__u64 cpu_scaled_run_real_total;
	__u64 freepages_count;
	__u64 freepages_delay_total;
	__u64 thrashing_count;
	__u64 thrashing_delay_total;
	__u64 ac_btime64;
	__u64 compact_count;
	__u64 compact_delay_total;
	__u32 ac_tgid;
	__u64 ac_tgetime;
	__u64 ac_exe_dev;
	__u64 ac_exe_inode;
	__u64 wpcopy_count;
	__u64 wpcopy_delay_total;
	__u64 irq_count;
	__u64 irq_delay_total;
};

struct perf_event_groups {
	struct rb_root tree;
	u64 index;
};

typedef struct {
	atomic_long_t a;
} local_t;

struct perf_event_context {
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head pmu_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	int nr_events;
	int nr_user;
	int is_active;
	int nr_task_data;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	struct perf_event_context *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	int nr_cgroups;
	struct callback_head callback_head;
	local_t nr_pending;
};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = -4,
	PERF_EVENT_STATE_EXIT = -3,
	PERF_EVENT_STATE_ERROR = -2,
	PERF_EVENT_STATE_OFF = -1,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

typedef struct {
	local_t a;
} local64_t;

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 build_id: 1;
	__u64 inherit_thread: 1;
	__u64 remove_on_exec: 1;
	__u64 sigtrap: 1;
	__u64 __reserved_1: 26;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	__u32 __reserved_3;
	__u64 sig_data;
	__u64 config3;
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
};

struct arch_hw_breakpoint_ctrl {
	u32 __reserved: 19;
	u32 len: 8;
	u32 type: 2;
	u32 privilege: 2;
	u32 enabled: 1;
};

struct arch_hw_breakpoint {
	u64 address;
	u64 trigger;
	struct arch_hw_breakpoint_ctrl ctrl;
};

struct rhash_head {
	struct rhash_head __attribute__((btf_type_tag("rcu"))) *next;
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head __attribute__((btf_type_tag("rcu"))) *next;
};

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			unsigned long config_base;
			unsigned long event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct rhlist_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	unsigned long addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

struct irq_work {
	struct __call_single_node node;
	void (*func)(struct irq_work *);
	struct rcuwait irqwait;
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_sample_data;

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct ftrace_ops;

struct ftrace_regs;

typedef void (*ftrace_func_t)(unsigned long, unsigned long, struct ftrace_ops *, struct ftrace_regs *);

struct ftrace_hash;

struct ftrace_ops_hash {
	struct ftrace_hash __attribute__((btf_type_tag("rcu"))) *notrace_hash;
	struct ftrace_hash __attribute__((btf_type_tag("rcu"))) *filter_hash;
	struct mutex regex_lock;
};

enum ftrace_ops_cmd {
	FTRACE_OPS_CMD_ENABLE_SHARE_IPMODIFY_SELF = 0,
	FTRACE_OPS_CMD_ENABLE_SHARE_IPMODIFY_PEER = 1,
	FTRACE_OPS_CMD_DISABLE_SHARE_IPMODIFY_PEER = 2,
};

typedef int (*ftrace_ops_func_t)(struct ftrace_ops *, enum ftrace_ops_cmd);

struct ftrace_ops {
	ftrace_func_t func;
	struct ftrace_ops __attribute__((btf_type_tag("rcu"))) *next;
	unsigned long flags;
	void *private;
	ftrace_func_t saved_func;
	struct ftrace_ops_hash local_hash;
	struct ftrace_ops_hash *func_hash;
	struct ftrace_ops_hash old_hash;
	unsigned long trampoline;
	unsigned long trampoline_size;
	struct list_head list;
	ftrace_ops_func_t ops_func;
	unsigned long direct_call;
};

struct pmu;

struct perf_event_pmu_context;

struct perf_buffer;

struct fasync_struct;

struct perf_addr_filter_range;

struct event_filter;

struct perf_cgroup;

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	unsigned int group_generation;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	struct perf_event_pmu_context *pmu_ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	unsigned long rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	unsigned int pending_wakeup;
	unsigned int pending_kill;
	unsigned int pending_disable;
	unsigned int pending_sigtrap;
	unsigned long pending_addr;
	struct irq_work pending_irq;
	struct callback_head pending_task;
	unsigned int pending_work;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	unsigned long addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	atomic64_t lost_samples;
	u64 (*clock)();
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t orig_overflow_handler;
	struct bpf_prog *prog;
	u64 bpf_cookie;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct ftrace_ops ftrace_ops;
	struct perf_cgroup *cgrp;
	void *security;
	struct list_head sb_list;
	__u32 orig_type;
};

struct perf_cpu_pmu_context;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	struct device *parent;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	int __attribute__((btf_type_tag("percpu"))) *pmu_disable_count;
	struct perf_cpu_pmu_context __attribute__((btf_type_tag("percpu"))) *cpu_pmu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_pmu_context *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_pmu_context *, struct perf_event_pmu_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, unsigned long);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	bool (*filter)(struct pmu *, int);
	int (*check_period)(struct perf_event *, u64);
};

struct perf_event_pmu_context {
	struct pmu *pmu;
	struct perf_event_context *ctx;
	struct list_head pmu_ctx_entry;
	struct list_head pinned_active;
	struct list_head flexible_active;
	unsigned int embedded: 1;
	unsigned int nr_events;
	unsigned int nr_cgroups;
	atomic_t refcount;
	struct callback_head callback_head;
	void *task_ctx_data;
	int rotate_necessary;
};

struct perf_cpu_pmu_context {
	struct perf_event_pmu_context epc;
	struct perf_event_pmu_context *task_epc;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
};

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	unsigned long wakeup;
	unsigned long size;
	u64 aux_flags;
	union {
		void *addr;
		unsigned long head;
	};
	int page;
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct perf_addr_filter_range {
	unsigned long start;
	unsigned long size;
};

union perf_sample_weight {
	__u64 full;
	struct {
		__u32 var1_dw;
		__u16 var2_w;
		__u16 var3_w;
	};
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_blk: 3;
		__u64 mem_hops: 3;
		__u64 mem_rsvd: 18;
	};
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
};

struct perf_callchain_entry;

struct perf_raw_record;

struct perf_branch_stack;

struct perf_sample_data {
	u64 sample_flags;
	u64 period;
	u64 dyn_size;
	u64 type;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	u64 ip;
	struct perf_callchain_entry *callchain;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	union perf_sample_weight weight;
	union perf_mem_data_src data_src;
	u64 txn;
	struct perf_regs regs_user;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 stream_id;
	u64 cgroup;
	u64 addr;
	u64 phys_addr;
	u64 data_page_size;
	u64 code_page_size;
	u64 aux_size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

typedef unsigned long (*perf_copy_f)(void *, const void *, unsigned long, unsigned long);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		unsigned long pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
} __attribute__((packed));

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 spec: 2;
	__u64 new_type: 4;
	__u64 priv: 3;
	__u64 reserved: 31;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct ftrace_regs {
	unsigned long regs[9];
	unsigned long direct_tramp;
	unsigned long fp;
	unsigned long lr;
	unsigned long sp;
	unsigned long pc;
};

struct ftrace_hash {
	unsigned long size_bits;
	struct hlist_head *buckets;
	unsigned long count;
	unsigned long flags;
	struct callback_head rcu;
};

struct perf_cgroup_info;

struct perf_cgroup {
	struct cgroup_subsys_state css;
	struct perf_cgroup_info __attribute__((btf_type_tag("percpu"))) *info;
};

struct perf_cgroup_info {
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	int active;
};

typedef u32 phandle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
	struct list_head suppliers;
	struct list_head consumers;
	u8 flags;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	struct kobject kobj;
	unsigned long _flags;
	void *data;
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

struct fwnode_reference_args;

struct fwnode_endpoint;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*device_dma_supported)(const struct fwnode_handle *);
	enum dev_dma_attr (*device_get_dma_attr)(const struct fwnode_handle *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	void * (*iomap)(struct fwnode_handle *, int);
	int (*irq_get)(const struct fwnode_handle *, unsigned int);
	int (*add_links)(struct fwnode_handle *);
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
	struct bin_attribute attr;
};

enum vec_type {
	ARM64_VEC_SVE = 0,
	ARM64_VEC_SME = 1,
	ARM64_VEC_MAX = 2,
};

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

enum aarch64_insn_imm_type {
	AARCH64_INSN_IMM_ADR = 0,
	AARCH64_INSN_IMM_26 = 1,
	AARCH64_INSN_IMM_19 = 2,
	AARCH64_INSN_IMM_16 = 3,
	AARCH64_INSN_IMM_14 = 4,
	AARCH64_INSN_IMM_12 = 5,
	AARCH64_INSN_IMM_9 = 6,
	AARCH64_INSN_IMM_7 = 7,
	AARCH64_INSN_IMM_6 = 8,
	AARCH64_INSN_IMM_S = 9,
	AARCH64_INSN_IMM_R = 10,
	AARCH64_INSN_IMM_N = 11,
	AARCH64_INSN_IMM_MAX = 12,
};

enum aarch64_insn_register_type {
	AARCH64_INSN_REGTYPE_RT = 0,
	AARCH64_INSN_REGTYPE_RN = 1,
	AARCH64_INSN_REGTYPE_RT2 = 2,
	AARCH64_INSN_REGTYPE_RM = 3,
	AARCH64_INSN_REGTYPE_RD = 4,
	AARCH64_INSN_REGTYPE_RA = 5,
	AARCH64_INSN_REGTYPE_RS = 6,
};

enum mitigation_state {
	SPECTRE_UNAFFECTED = 0,
	SPECTRE_MITIGATED = 1,
	SPECTRE_VULNERABLE = 2,
};

enum kvm_mode {
	KVM_MODE_DEFAULT = 0,
	KVM_MODE_PROTECTED = 1,
	KVM_MODE_NV = 2,
	KVM_MODE_NONE = 3,
};

enum arm64_bp_harden_el1_vectors {
	EL1_VECTOR_BHB_LOOP = 0,
	EL1_VECTOR_BHB_FW = 1,
	EL1_VECTOR_BHB_CLEAR_INSN = 2,
	EL1_VECTOR_KPTI = 3,
};

enum fixed_addresses {
	FIX_HOLE = 0,
	FIX_FDT_END = 1,
	FIX_FDT = 514,
	FIX_EARLYCON_MEM_BASE = 515,
	FIX_TEXT_POKE0 = 516,
	FIX_APEI_GHES_IRQ = 517,
	FIX_APEI_GHES_SEA = 518,
	FIX_ENTRY_TRAMP_TEXT4 = 519,
	FIX_ENTRY_TRAMP_TEXT3 = 520,
	FIX_ENTRY_TRAMP_TEXT2 = 521,
	FIX_ENTRY_TRAMP_TEXT1 = 522,
	__end_of_permanent_fixed_addresses = 523,
	FIX_BTMAP_END = 523,
	FIX_BTMAP_BEGIN = 970,
	FIX_PTE = 971,
	FIX_PMD = 972,
	FIX_PUD = 973,
	FIX_PGD = 974,
	__end_of_fixed_addresses = 975,
};

enum pageflags {
	PG_locked = 0,
	PG_writeback = 1,
	PG_referenced = 2,
	PG_uptodate = 3,
	PG_dirty = 4,
	PG_lru = 5,
	PG_head = 6,
	PG_waiters = 7,
	PG_active = 8,
	PG_workingset = 9,
	PG_error = 10,
	PG_slab = 11,
	PG_owner_priv_1 = 12,
	PG_arch_1 = 13,
	PG_reserved = 14,
	PG_private = 15,
	PG_private_2 = 16,
	PG_mappedtodisk = 17,
	PG_reclaim = 18,
	PG_swapbacked = 19,
	PG_unevictable = 20,
	PG_mlocked = 21,
	PG_hwpoison = 22,
	PG_arch_2 = 23,
	PG_arch_3 = 24,
	__NR_PAGEFLAGS = 25,
	PG_readahead = 18,
	PG_anon_exclusive = 17,
	PG_checked = 12,
	PG_swapcache = 12,
	PG_fscache = 16,
	PG_pinned = 12,
	PG_savepinned = 4,
	PG_foreign = 12,
	PG_xen_remapped = 12,
	PG_isolated = 18,
	PG_reported = 3,
	PG_vmemmap_self_hosted = 12,
	PG_has_hwpoisoned = 10,
	PG_hugetlb = 8,
	PG_large_rmappable = 9,
};

enum {
	CAP_HWCAP = 1,
	CAP_COMPAT_HWCAP = 2,
	CAP_COMPAT_HWCAP2 = 3,
};

typedef unsigned long uintptr_t;

typedef int (*cmp_func_t)(const void *, const void *);

typedef int (*cpu_stop_fn_t)(void *);

typedef void ttbr_replace_func(phys_addr_t);

typedef void kpti_remap_fn(int, int, phys_addr_t, unsigned long);

struct alt_instr;

struct alt_region {
	struct alt_instr *begin;
	struct alt_instr *end;
};

struct alt_instr {
	s32 orig_offset;
	s32 alt_offset;
	u16 cpucap;
	u8 orig_len;
	u8 alt_len;
};

enum aarch64_insn_hint_cr_op {
	AARCH64_INSN_HINT_NOP = 0,
	AARCH64_INSN_HINT_YIELD = 32,
	AARCH64_INSN_HINT_WFE = 64,
	AARCH64_INSN_HINT_WFI = 96,
	AARCH64_INSN_HINT_SEV = 128,
	AARCH64_INSN_HINT_SEVL = 160,
	AARCH64_INSN_HINT_XPACLRI = 224,
	AARCH64_INSN_HINT_PACIA_1716 = 256,
	AARCH64_INSN_HINT_PACIB_1716 = 320,
	AARCH64_INSN_HINT_AUTIA_1716 = 384,
	AARCH64_INSN_HINT_AUTIB_1716 = 448,
	AARCH64_INSN_HINT_PACIAZ = 768,
	AARCH64_INSN_HINT_PACIASP = 800,
	AARCH64_INSN_HINT_PACIBZ = 832,
	AARCH64_INSN_HINT_PACIBSP = 864,
	AARCH64_INSN_HINT_AUTIAZ = 896,
	AARCH64_INSN_HINT_AUTIASP = 928,
	AARCH64_INSN_HINT_AUTIBZ = 960,
	AARCH64_INSN_HINT_AUTIBSP = 992,
	AARCH64_INSN_HINT_ESB = 512,
	AARCH64_INSN_HINT_PSB = 544,
	AARCH64_INSN_HINT_TSB = 576,
	AARCH64_INSN_HINT_CSDB = 640,
	AARCH64_INSN_HINT_CLEARBHB = 704,
	AARCH64_INSN_HINT_BTI = 1024,
	AARCH64_INSN_HINT_BTIC = 1088,
	AARCH64_INSN_HINT_BTIJ = 1152,
	AARCH64_INSN_HINT_BTIJC = 1216,
};

typedef __u64 Elf64_Off;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

typedef struct elf64_shdr Elf64_Shdr;

typedef struct elf64_hdr Elf64_Ehdr;

typedef void (*alternative_cb_t)(struct alt_instr *, __le32 *, __le32 *, int);

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

struct cacheinfo;

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int per_cpu_data_slice_size;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
	bool early_ci_levels;
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct secondary_data {
	struct task_struct *task;
	long status;
};

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	unsigned long eval_value;
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct msi_dev_domain {
	struct xarray store;
	struct irq_domain *domain;
};

struct platform_msi_priv_data;

struct msi_device_data {
	unsigned long properties;
	struct platform_msi_priv_data *platform_data;
	struct mutex mutex;
	struct msi_dev_domain __domains[2];
	unsigned long __iter_idx;
};

struct msi_desc;

struct irq_common_data {
	unsigned int state_use_accessors;
	unsigned int node;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
	unsigned int ipi_offset;
};

struct irq_chip;

struct irq_data {
	u32 mask;
	unsigned int irq;
	unsigned long hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct irqaction;

struct irq_affinity_notify;

struct proc_dir_entry;

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	unsigned int __attribute__((btf_type_tag("percpu"))) *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	unsigned long last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	unsigned long threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	struct hlist_node resend_node;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct pci_msi_desc {
	union {
		u32 msi_mask;
		u32 msix_ctrl;
	};
	struct {
		u8 is_msix: 1;
		u8 multiple: 3;
		u8 multi_cap: 3;
		u8 can_mask: 1;
		u8 is_64: 1;
		u8 is_virtual: 1;
		unsigned int default_irq;
	} msi_attrib;
	union {
		u8 mask_pos;
		void *mask_base;
	};
};

union msi_domain_cookie {
	u64 value;
	void *ptr;
	void *iobase;
};

union msi_instance_cookie {
	u64 value;
	void *ptr;
};

struct msi_desc_data {
	union msi_domain_cookie dcookie;
	union msi_instance_cookie icookie;
};

struct arch_msi_msg_addr_lo {
	u32 address_lo;
};

typedef struct arch_msi_msg_addr_lo arch_msi_msg_addr_lo_t;

struct arch_msi_msg_addr_hi {
	u32 address_hi;
};

typedef struct arch_msi_msg_addr_hi arch_msi_msg_addr_hi_t;

struct arch_msi_msg_data {
	u32 data;
};

typedef struct arch_msi_msg_data arch_msi_msg_data_t;

struct msi_msg {
	union {
		u32 address_lo;
		arch_msi_msg_addr_lo_t arch_addr_lo;
	};
	union {
		u32 address_hi;
		arch_msi_msg_addr_hi_t arch_addr_hi;
	};
	union {
		u32 data;
		arch_msi_msg_data_t arch_data;
	};
};

struct irq_affinity_desc;

struct msi_desc {
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	const void *iommu_cookie;
	struct device_attribute *sysfs_attrs;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	u16 msi_index;
	union {
		struct pci_msi_desc pci;
		struct msi_desc_data data;
	};
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

struct irq_chip {
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	unsigned long flags;
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void __attribute__((btf_type_tag("percpu"))) *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	unsigned long thread_flags;
	unsigned long thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

struct acpi_subtable_header {
	u8 type;
	u8 length;
};

struct acpi_madt_generic_interrupt {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 cpu_interface_number;
	u32 uid;
	u32 flags;
	u32 parking_version;
	u32 performance_interrupt;
	u64 parked_address;
	u64 base_address;
	u64 gicv_base_address;
	u64 gich_base_address;
	u32 vgic_interrupt;
	u64 gicr_base_address;
	u64 arm_mpidr;
	u8 efficiency_class;
	u8 reserved2[1];
	u16 spe_interrupt;
	u16 trbe_interrupt;
} __attribute__((packed));

enum ipi_msg_type {
	IPI_RESCHEDULE = 0,
	IPI_CALL_FUNC = 1,
	IPI_CPU_STOP = 2,
	IPI_CPU_CRASH_STOP = 3,
	IPI_TIMER = 4,
	IPI_IRQ_WORK = 5,
	NR_IPI = 6,
	IPI_CPU_BACKTRACE = 6,
	IPI_KGDB_ROUNDUP = 7,
	MAX_IPI = 8,
};

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_MOVE_PCNTXT = 16384,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
	IRQ_NO_DEBUG = 2097152,
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_FREEING_INITMEM = 2,
	SYSTEM_RUNNING = 3,
	SYSTEM_HALT = 4,
	SYSTEM_POWER_OFF = 5,
	SYSTEM_RESTART = 6,
	SYSTEM_SUSPEND = 7,
};

enum acpi_madt_type {
	ACPI_MADT_TYPE_LOCAL_APIC = 0,
	ACPI_MADT_TYPE_IO_APIC = 1,
	ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2,
	ACPI_MADT_TYPE_NMI_SOURCE = 3,
	ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4,
	ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5,
	ACPI_MADT_TYPE_IO_SAPIC = 6,
	ACPI_MADT_TYPE_LOCAL_SAPIC = 7,
	ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8,
	ACPI_MADT_TYPE_LOCAL_X2APIC = 9,
	ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10,
	ACPI_MADT_TYPE_GENERIC_INTERRUPT = 11,
	ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 12,
	ACPI_MADT_TYPE_GENERIC_MSI_FRAME = 13,
	ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR = 14,
	ACPI_MADT_TYPE_GENERIC_TRANSLATOR = 15,
	ACPI_MADT_TYPE_MULTIPROC_WAKEUP = 16,
	ACPI_MADT_TYPE_CORE_PIC = 17,
	ACPI_MADT_TYPE_LIO_PIC = 18,
	ACPI_MADT_TYPE_HT_PIC = 19,
	ACPI_MADT_TYPE_EIO_PIC = 20,
	ACPI_MADT_TYPE_MSI_PIC = 21,
	ACPI_MADT_TYPE_BIO_PIC = 22,
	ACPI_MADT_TYPE_LPC_PIC = 23,
	ACPI_MADT_TYPE_RINTC = 24,
	ACPI_MADT_TYPE_IMSIC = 25,
	ACPI_MADT_TYPE_APLIC = 26,
	ACPI_MADT_TYPE_PLIC = 27,
	ACPI_MADT_TYPE_RESERVED = 28,
	ACPI_MADT_TYPE_OEM_RESERVED = 128,
};

struct cpu_operations {
	const char *name;
	int (*cpu_init)(unsigned int);
	int (*cpu_prepare)(unsigned int);
	int (*cpu_boot)(unsigned int);
	void (*cpu_postboot)();
	bool (*cpu_can_disable)(unsigned int);
	int (*cpu_disable)(unsigned int);
	void (*cpu_die)(unsigned int);
	int (*cpu_kill)(unsigned int);
};

union acpi_subtable_headers;

typedef int (*acpi_tbl_entry_handler)(union acpi_subtable_headers *, const unsigned long);

struct acpi_hmat_structure {
	u16 type;
	u16 reserved;
	u32 length;
};

struct acpi_prmt_module_header {
	u16 revision;
	u16 length;
};

struct acpi_cedt_header {
	u8 type;
	u8 reserved;
	u16 length;
};

union acpi_subtable_headers {
	struct acpi_subtable_header common;
	struct acpi_hmat_structure hmat;
	struct acpi_prmt_module_header prmt;
	struct acpi_cedt_header cedt;
};

typedef __u64 __le64;

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, unsigned long, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block __attribute__((btf_type_tag("rcu"))) *next;
	int priority;
};

enum scale_freq_source {
	SCALE_FREQ_SOURCE_CPUFREQ = 0,
	SCALE_FREQ_SOURCE_ARCH = 1,
	SCALE_FREQ_SOURCE_CPPC = 2,
};

struct scale_freq_data {
	enum scale_freq_source source;
	void (*set_freq_scale)();
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

typedef void (*smp_call_func_t)(void *);

struct cpc_reg {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct plist_head {
	struct list_head node_list;
};

struct blocking_notifier_head;

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block __attribute__((btf_type_tag("rcu"))) *head;
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct clk;

struct cpufreq_governor;

struct freq_qos_request;

struct cpufreq_frequency_table;

struct cpufreq_stats;

struct thermal_cooling_device;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	bool efficiencies_available;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	bool boost_enabled;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	char *type;
	unsigned long max_state;
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, unsigned long *);
	int (*get_cur_state)(struct thermal_cooling_device *, unsigned long *);
	int (*set_cur_state)(struct thermal_cooling_device *, unsigned long);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, unsigned long, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, unsigned long *);
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_class;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	union {
		void *module;
		atomic_t refcnt;
	};
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head __attribute__((btf_type_tag("percpu"))) *perf_events;
	struct bpf_prog_array __attribute__((btf_type_tag("rcu"))) *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_event_fields;

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const int is_signed;
			const int filter_type;
			const int len;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_iterator;

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
};

struct trace_seq {
	char buffer[4096];
	struct seq_buf seq;
	size_t readpos;
	int full;
};

struct trace_array;

struct tracer;

struct array_buffer;

struct ring_buffer_iter;

struct trace_entry;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	unsigned long iter_flags;
	void *temp;
	unsigned int temp_size;
	char *fmt;
	unsigned int fmt_size;
	long wait_index;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	unsigned long lost_events;
	int leftover;
	int ent_size;
	int cpu;
	u64 ts;
	loff_t pos;
	long idx;
};

struct trace_entry {
	unsigned short type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

typedef long (*syscall_fn_t)(const struct pt_regs *);

enum arm64_hyp_spectre_vector {
	HYP_VECTOR_DIRECT = 0,
	HYP_VECTOR_SPECTRE_DIRECT = 1,
	HYP_VECTOR_INDIRECT = 2,
	HYP_VECTOR_SPECTRE_INDIRECT = 3,
};

typedef void (*bp_hardening_cb_t)();

struct bp_hardening_data {
	enum arm64_hyp_spectre_vector slot;
	bp_hardening_cb_t fn;
};

enum spectre_v4_policy {
	SPECTRE_V4_POLICY_MITIGATION_DYNAMIC = 0,
	SPECTRE_V4_POLICY_MITIGATION_ENABLED = 1,
	SPECTRE_V4_POLICY_MITIGATION_DISABLED = 2,
};

struct spectre_v4_param {
	const char *str;
	enum spectre_v4_policy policy;
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

enum zone_type {
	ZONE_DMA = 0,
	ZONE_DMA32 = 1,
	ZONE_NORMAL = 2,
	ZONE_MOVABLE = 3,
	__MAX_NR_ZONES = 4,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
	BPF_PROG_TYPE_SYSCALL = 31,
	BPF_PROG_TYPE_NETFILTER = 32,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	BPF_SK_SKB_VERDICT = 38,
	BPF_SK_REUSEPORT_SELECT = 39,
	BPF_SK_REUSEPORT_SELECT_OR_MIGRATE = 40,
	BPF_PERF_EVENT = 41,
	BPF_TRACE_KPROBE_MULTI = 42,
	BPF_LSM_CGROUP = 43,
	BPF_STRUCT_OPS = 44,
	BPF_NETFILTER = 45,
	BPF_TCX_INGRESS = 46,
	BPF_TCX_EGRESS = 47,
	BPF_TRACE_UPROBE_MULTI = 48,
	BPF_CGROUP_UNIX_CONNECT = 49,
	BPF_CGROUP_UNIX_SENDMSG = 50,
	BPF_CGROUP_UNIX_RECVMSG = 51,
	BPF_CGROUP_UNIX_GETPEERNAME = 52,
	BPF_CGROUP_UNIX_GETSOCKNAME = 53,
	BPF_NETKIT_PRIMARY = 54,
	BPF_NETKIT_PEER = 55,
	__MAX_BPF_ATTACH_TYPE = 56,
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_KEY = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCK_COMMON = 12,
	PTR_TO_TCP_SOCK = 13,
	PTR_TO_TP_BUFFER = 14,
	PTR_TO_XDP_SOCK = 15,
	PTR_TO_BTF_ID = 16,
	PTR_TO_MEM = 17,
	PTR_TO_BUF = 18,
	PTR_TO_FUNC = 19,
	CONST_PTR_TO_DYNPTR = 20,
	__BPF_REG_TYPE_MAX = 21,
	PTR_TO_MAP_VALUE_OR_NULL = 260,
	PTR_TO_SOCKET_OR_NULL = 267,
	PTR_TO_SOCK_COMMON_OR_NULL = 268,
	PTR_TO_TCP_SOCK_OR_NULL = 269,
	PTR_TO_BTF_ID_OR_NULL = 272,
	__BPF_REG_TYPE_LIMIT = 33554431,
};

enum bpf_cgroup_iter_order {
	BPF_CGROUP_ITER_ORDER_UNSPEC = 0,
	BPF_CGROUP_ITER_SELF_ONLY = 1,
	BPF_CGROUP_ITER_DESCENDANTS_PRE = 2,
	BPF_CGROUP_ITER_DESCENDANTS_POST = 3,
	BPF_CGROUP_ITER_ANCESTORS_UP = 4,
};

enum bpf_iter_task_type {
	BPF_TASK_ITER_ALL = 0,
	BPF_TASK_ITER_TID = 1,
	BPF_TASK_ITER_TGID = 2,
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED = 19,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED = 21,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
	BPF_MAP_TYPE_TASK_STORAGE = 29,
	BPF_MAP_TYPE_BLOOM_FILTER = 30,
	BPF_MAP_TYPE_USER_RINGBUF = 31,
	BPF_MAP_TYPE_CGRP_STORAGE = 32,
};

enum btf_field_type {
	BPF_SPIN_LOCK = 1,
	BPF_TIMER = 2,
	BPF_KPTR_UNREF = 4,
	BPF_KPTR_REF = 8,
	BPF_KPTR_PERCPU = 16,
	BPF_KPTR = 28,
	BPF_LIST_HEAD = 32,
	BPF_LIST_NODE = 64,
	BPF_RB_ROOT = 128,
	BPF_RB_NODE = 256,
	BPF_GRAPH_NODE_OR_ROOT = 480,
	BPF_REFCOUNT = 512,
};

enum arm_smccc_conduit {
	SMCCC_CONDUIT_NONE = 0,
	SMCCC_CONDUIT_SMC = 1,
	SMCCC_CONDUIT_HVC = 2,
};

enum bhb_mitigation_bits {
	BHB_LOOP = 0,
	BHB_FW = 1,
	BHB_HW = 2,
	BHB_INSN = 3,
};

enum aarch64_insn_variant {
	AARCH64_INSN_VARIANT_32BIT = 0,
	AARCH64_INSN_VARIANT_64BIT = 1,
};

enum aarch64_insn_movewide_type {
	AARCH64_INSN_MOVEWIDE_ZERO = 0,
	AARCH64_INSN_MOVEWIDE_KEEP = 1,
	AARCH64_INSN_MOVEWIDE_INVERSE = 2,
};

enum aarch64_insn_register {
	AARCH64_INSN_REG_0 = 0,
	AARCH64_INSN_REG_1 = 1,
	AARCH64_INSN_REG_2 = 2,
	AARCH64_INSN_REG_3 = 3,
	AARCH64_INSN_REG_4 = 4,
	AARCH64_INSN_REG_5 = 5,
	AARCH64_INSN_REG_6 = 6,
	AARCH64_INSN_REG_7 = 7,
	AARCH64_INSN_REG_8 = 8,
	AARCH64_INSN_REG_9 = 9,
	AARCH64_INSN_REG_10 = 10,
	AARCH64_INSN_REG_11 = 11,
	AARCH64_INSN_REG_12 = 12,
	AARCH64_INSN_REG_13 = 13,
	AARCH64_INSN_REG_14 = 14,
	AARCH64_INSN_REG_15 = 15,
	AARCH64_INSN_REG_16 = 16,
	AARCH64_INSN_REG_17 = 17,
	AARCH64_INSN_REG_18 = 18,
	AARCH64_INSN_REG_19 = 19,
	AARCH64_INSN_REG_20 = 20,
	AARCH64_INSN_REG_21 = 21,
	AARCH64_INSN_REG_22 = 22,
	AARCH64_INSN_REG_23 = 23,
	AARCH64_INSN_REG_24 = 24,
	AARCH64_INSN_REG_25 = 25,
	AARCH64_INSN_REG_26 = 26,
	AARCH64_INSN_REG_27 = 27,
	AARCH64_INSN_REG_28 = 28,
	AARCH64_INSN_REG_29 = 29,
	AARCH64_INSN_REG_FP = 29,
	AARCH64_INSN_REG_30 = 30,
	AARCH64_INSN_REG_LR = 30,
	AARCH64_INSN_REG_ZR = 31,
	AARCH64_INSN_REG_SP = 31,
};

enum aarch64_insn_logic_type {
	AARCH64_INSN_LOGIC_AND = 0,
	AARCH64_INSN_LOGIC_BIC = 1,
	AARCH64_INSN_LOGIC_ORR = 2,
	AARCH64_INSN_LOGIC_ORN = 3,
	AARCH64_INSN_LOGIC_EOR = 4,
	AARCH64_INSN_LOGIC_EON = 5,
	AARCH64_INSN_LOGIC_AND_SETFLAGS = 6,
	AARCH64_INSN_LOGIC_BIC_SETFLAGS = 7,
};

struct swap_iocb;

struct writeback_control {
	long nr_to_write;
	long pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int unpinned_fscache_wb: 1;
	unsigned int no_cgroup_owner: 1;
	struct swap_iocb **swap_plug;
	struct bdi_writeback *wb;
	struct inode *inode;
	int wb_id;
	int wb_lcand_id;
	int wb_tcand_id;
	size_t wb_bytes;
	size_t wb_lcand_bytes;
	size_t wb_tcand_bytes;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct bdi_writeback {
	struct backing_dev_info *bdi;
	unsigned long state;
	unsigned long last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	atomic_t writeback_inodes;
	struct percpu_counter stat[4];
	unsigned long bw_time_stamp;
	unsigned long dirtied_stamp;
	unsigned long written_stamp;
	unsigned long write_bandwidth;
	unsigned long avg_write_bandwidth;
	unsigned long dirty_ratelimit;
	unsigned long balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	struct delayed_work bw_dwork;
	unsigned long dirty_sleep;
	struct list_head bdi_node;
	struct percpu_ref refcnt;
	struct fprop_local_percpu memcg_completions;
	struct cgroup_subsys_state *memcg_css;
	struct cgroup_subsys_state *blkcg_css;
	struct list_head memcg_node;
	struct list_head blkcg_node;
	struct list_head b_attached;
	struct list_head offline_node;
	union {
		struct work_struct release_work;
		struct callback_head rcu;
	};
};

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	unsigned long ra_pages;
	unsigned long io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	struct bdi_writeback wb;
	struct list_head wb_list;
	struct xarray cgwb_tree;
	struct mutex cgwb_release_mutex;
	struct rw_semaphore wb_switch_rwsem;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

typedef short __s16;

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

struct bpf_prog_stats;

struct bpf_prog_aux;

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinding_requested: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	u16 call_get_func_ip: 1;
	u16 tstamp_type_access: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_stats __attribute__((btf_type_tag("percpu"))) *stats;
	int __attribute__((btf_type_tag("percpu"))) *active;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	union {
		struct {
			struct {} __empty_insns;
			struct sock_filter insns[0];
		};
		struct {
			struct {} __empty_insnsi;
			struct bpf_insn insnsi[0];
		};
	};
};

typedef struct {
	local64_t v;
} u64_stats_t;

struct bpf_prog_stats {
	u64_stats_t cnt;
	u64_stats_t nsecs;
	u64_stats_t misses;
	struct u64_stats_sync syncp;
	long: 64;
};

struct bpf_ksym {
	unsigned long start;
	unsigned long end;
	char name[512];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct btf;

struct bpf_ctx_arg_aux;

struct bpf_trampoline;

struct btf_type;

struct bpf_jit_poke_descriptor;

struct bpf_kfunc_desc_tab;

struct bpf_kfunc_btf_tab;

struct bpf_prog_ops;

struct bpf_map;

struct btf_mod_pair;

struct bpf_prog_offload;

struct bpf_func_info;

struct bpf_func_info_aux;

struct bpf_line_info;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 real_func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	struct btf *attach_btf;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool dev_bound;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	bool sleepable;
	bool tail_call_reachable;
	bool xdp_has_frags;
	bool exception_cb;
	bool exception_boundary;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	struct bpf_kfunc_desc_tab *kfunc_tab;
	struct bpf_kfunc_btf_tab *kfunc_btf_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct btf_mod_pair *used_btfs;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	u32 verified_insns;
	int cgroup_atype;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	unsigned int (*bpf_exception_cb)(u64, u64, u64);
	void *security;
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	struct module *mod;
	u32 num_exentries;
	struct exception_table_entry *extable;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	u32 btf_id;
};

struct btf_func_model {
	u8 ret_size;
	u8 ret_flags;
	u8 nr_args;
	u8 arg_size[12];
	u8 arg_flags[12];
};

struct bpf_tramp_image;

struct bpf_trampoline {
	struct hlist_node hlist;
	struct ftrace_ops *fops;
	struct mutex mutex;
	refcount_t refcnt;
	u32 flags;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	struct bpf_tramp_image *cur_image;
	struct module *mod;
};

struct bpf_tramp_image {
	void *image;
	struct bpf_ksym ksym;
	struct percpu_ref pcref;
	void *ip_after_call;
	void *ip_epilogue;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	void *aux;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_map_ops;

struct btf_record;

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	void *security;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u64 map_extra;
	u32 map_flags;
	u32 id;
	struct btf_record *record;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	u32 btf_vmlinux_value_type_id;
	struct btf *btf;
	struct obj_cgroup *objcg;
	char name[16];
	long: 64;
	long: 64;
	atomic64_t refcnt;
	atomic64_t usercnt;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
	struct mutex freeze_mutex;
	atomic64_t writecnt;
	struct {
		spinlock_t lock;
		enum bpf_prog_type type;
		bool jited;
		bool xdp_has_frags;
	} owner;
	bool bypass_spec_v1;
	bool frozen;
	bool free_after_mult_rcu_gp;
	s64 __attribute__((btf_type_tag("percpu"))) *elem_count;
	long: 64;
	long: 64;
};

typedef u64 (*bpf_callback_t)(u64, u64, u64, u64, u64);

union bpf_attr;

struct bpf_verifier_env;

struct bpf_func_state;

struct bpf_iter_seq_info;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr __attribute__((btf_type_tag("user"))) *);
	int (*map_lookup_and_delete_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr __attribute__((btf_type_tag("user"))) *);
	int (*map_update_batch)(struct bpf_map *, struct file *, const union bpf_attr *, union bpf_attr __attribute__((btf_type_tag("user"))) *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr __attribute__((btf_type_tag("user"))) *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	long (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	long (*map_delete_elem)(struct bpf_map *, void *);
	long (*map_push_elem)(struct bpf_map *, void *, u64);
	long (*map_pop_elem)(struct bpf_map *, void *);
	long (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_lookup_percpu_elem)(struct bpf_map *, void *, u32);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(struct bpf_map *, void *, bool);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage __attribute__((btf_type_tag("rcu"))) ** (*map_owner_storage_ptr)(void *);
	long (*map_redirect)(struct bpf_map *, u64, u64);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
	long (*map_for_each_callback)(struct bpf_map *, bpf_callback_t, void *, u64);
	u64 (*map_mem_usage)(const struct bpf_map *);
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
		__u64 map_extra;
	};
	struct {
		__u32 map_fd;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		union {
			__u32 attach_prog_fd;
			__u32 attach_btf_obj_fd;
		};
		__u32 core_relo_cnt;
		__u64 fd_array;
		__u64 core_relos;
		__u32 core_relo_rec_size;
		__u32 log_true_size;
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
		__s32 path_fd;
	};
	struct {
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
		union {
			__u32 relative_fd;
			__u32 relative_id;
		};
		__u64 expected_revision;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
		__u32 batch_size;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		union {
			__u32 prog_cnt;
			__u32 count;
		};
		__u64 prog_attach_flags;
		__u64 link_ids;
		__u64 link_attach_flags;
		__u64 revision;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
		__u32 btf_log_true_size;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		union {
			__u32 prog_fd;
			__u32 map_fd;
		};
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
			};
			struct {
				__u64 bpf_cookie;
			} perf_event;
			struct {
				__u32 flags;
				__u32 cnt;
				__u64 syms;
				__u64 addrs;
				__u64 cookies;
			} kprobe_multi;
			struct {
				__u32 target_btf_id;
				__u64 cookie;
			} tracing;
			struct {
				__u32 pf;
				__u32 hooknum;
				__s32 priority;
				__u32 flags;
			} netfilter;
			struct {
				union {
					__u32 relative_fd;
					__u32 relative_id;
				};
				__u64 expected_revision;
			} tcx;
			struct {
				__u64 path;
				__u64 offsets;
				__u64 ref_ctr_offsets;
				__u64 cookies;
				__u32 cnt;
				__u32 flags;
				__u32 pid;
			} uprobe_multi;
			struct {
				union {
					__u32 relative_fd;
					__u32 relative_id;
				};
				__u64 expected_revision;
			} netkit;
		};
	} link_create;
	struct {
		__u32 link_fd;
		union {
			__u32 new_prog_fd;
			__u32 new_map_fd;
		};
		__u32 flags;
		union {
			__u32 old_prog_fd;
			__u32 old_map_fd;
		};
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf_kfunc_set_tab;

struct btf_id_dtor_kfunc_tab;

struct btf_struct_metas;

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
	struct btf_kfunc_set_tab *kfunc_set_tab;
	struct btf_id_dtor_kfunc_tab *dtor_kfunc_tab;
	struct btf_struct_metas *struct_meta_tab;
	struct btf *base_btf;
	u32 start_id;
	u32 start_str_off;
	char name[56];
	bool kernel_btf;
};

struct bpf_iter_aux_info;

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct bpf_iter_aux_info {
	struct bpf_map *map;
	struct {
		struct cgroup *start;
		enum bpf_cgroup_iter_order order;
	} cgroup;
	struct {
		enum bpf_iter_task_type type;
		u32 pid;
	} task;
};

typedef void (*btf_dtor_kfunc_t)(void *);

struct btf_field_kptr {
	struct btf *btf;
	struct module *module;
	btf_dtor_kfunc_t dtor;
	u32 btf_id;
};

struct btf_field_graph_root {
	struct btf *btf;
	u32 value_btf_id;
	u32 node_offset;
	struct btf_record *value_rec;
};

struct btf_field {
	u32 offset;
	u32 size;
	enum btf_field_type type;
	union {
		struct btf_field_kptr kptr;
		struct btf_field_graph_root graph_root;
	};
};

struct btf_record {
	u32 cnt;
	u32 field_mask;
	int spin_lock_off;
	int timer_off;
	int refcount_off;
	struct btf_field fields[0];
};

struct obj_cgroup {
	struct percpu_ref refcnt;
	struct mem_cgroup *memcg;
	atomic_t nr_charged_bytes;
	union {
		struct list_head list;
		struct callback_head rcu;
	};
};

struct cacheline_padding {
	char x[0];
};

struct page_counter {
	atomic_long_t usage;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	unsigned long emin;
	atomic_long_t min_usage;
	atomic_long_t children_min_usage;
	unsigned long elow;
	atomic_long_t low_usage;
	atomic_long_t children_low_usage;
	unsigned long watermark;
	unsigned long failcnt;
	struct cacheline_padding _pad2_;
	unsigned long min;
	unsigned long low;
	unsigned long high;
	unsigned long max;
	struct page_counter *parent;
	long: 64;
	long: 64;
	long: 64;
};

struct mem_cgroup_id {
	int id;
	refcount_t ref;
};

struct vmpressure {
	unsigned long scanned;
	unsigned long reclaimed;
	unsigned long tree_scanned;
	unsigned long tree_reclaimed;
	spinlock_t sr_lock;
	struct list_head events;
	struct mutex events_lock;
	struct work_struct work;
};

struct mem_cgroup_threshold_ary;

struct mem_cgroup_thresholds {
	struct mem_cgroup_threshold_ary *primary;
	struct mem_cgroup_threshold_ary *spare;
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

struct wb_domain {
	spinlock_t lock;
	struct fprop_global completions;
	struct timer_list period_timer;
	unsigned long period_time;
	unsigned long dirty_limit_tstamp;
	unsigned long dirty_limit;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct memcg_cgwb_frn {
	u64 bdi_id;
	int memcg_id;
	u64 at;
	struct wb_completion done;
};

struct deferred_split {
	spinlock_t split_queue_lock;
	struct list_head split_queue;
	unsigned long split_queue_len;
};

struct memcg_vmstats;

struct memcg_vmstats_percpu;

struct mem_cgroup_per_node;

struct mem_cgroup {
	struct cgroup_subsys_state css;
	struct mem_cgroup_id id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct page_counter memory;
	union {
		struct page_counter swap;
		struct page_counter memsw;
	};
	struct page_counter kmem;
	struct page_counter tcpmem;
	struct work_struct high_work;
	unsigned long soft_limit;
	struct vmpressure vmpressure;
	bool oom_group;
	bool oom_lock;
	int under_oom;
	int swappiness;
	int oom_kill_disable;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct cgroup_file swap_events_file;
	struct mutex thresholds_lock;
	struct mem_cgroup_thresholds thresholds;
	struct mem_cgroup_thresholds memsw_thresholds;
	struct list_head oom_notify;
	unsigned long move_charge_at_immigrate;
	spinlock_t move_lock;
	unsigned long move_lock_flags;
	struct cacheline_padding _pad1_;
	struct memcg_vmstats *vmstats;
	atomic_long_t memory_events[9];
	atomic_long_t memory_events_local[9];
	unsigned long socket_pressure;
	bool tcpmem_active;
	int tcpmem_pressure;
	int kmemcg_id;
	struct obj_cgroup __attribute__((btf_type_tag("rcu"))) *objcg;
	struct obj_cgroup *orig_objcg;
	struct list_head objcg_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	atomic_t moving_account;
	struct task_struct *move_lock_task;
	struct memcg_vmstats_percpu __attribute__((btf_type_tag("percpu"))) *vmstats_percpu;
	struct list_head cgwb_list;
	struct wb_domain cgwb_domain;
	struct memcg_cgwb_frn cgwb_frn[4];
	struct list_head event_list;
	spinlock_t event_list_lock;
	struct deferred_split deferred_split_queue;
	struct mem_cgroup_per_node *nodeinfo[0];
	long: 64;
};

struct eventfd_ctx;

struct mem_cgroup_threshold {
	struct eventfd_ctx *eventfd;
	unsigned long threshold;
};

struct mem_cgroup_threshold_ary {
	int current_threshold;
	unsigned int size;
	struct mem_cgroup_threshold entries[0];
};

struct memcg_vmstats_percpu {
	long state[50];
	unsigned long events[19];
	long state_prev[50];
	unsigned long events_prev[19];
	unsigned long nr_page_events;
	unsigned long targets[2];
};

struct pglist_data;

struct lruvec {
	struct list_head lists[5];
	spinlock_t lru_lock;
	unsigned long anon_cost;
	unsigned long file_cost;
	atomic_long_t nonresident_age;
	unsigned long refaults[2];
	unsigned long flags;
	struct pglist_data *pgdat;
};

struct lruvec_stats {
	long state[43];
	long state_local[43];
	long state_pending[43];
};

struct mem_cgroup_reclaim_iter {
	struct mem_cgroup *position;
	unsigned int generation;
};

struct lruvec_stats_percpu;

struct shrinker_info;

struct mem_cgroup_per_node {
	struct lruvec lruvec;
	struct lruvec_stats_percpu __attribute__((btf_type_tag("percpu"))) *lruvec_stats_percpu;
	struct lruvec_stats lruvec_stats;
	unsigned long lru_zone_size[20];
	struct mem_cgroup_reclaim_iter iter;
	struct shrinker_info __attribute__((btf_type_tag("rcu"))) *shrinker_info;
	struct rb_node tree_node;
	unsigned long usage_in_excess;
	bool on_tree;
	struct mem_cgroup *memcg;
};

struct free_area {
	struct list_head free_list[6];
	unsigned long nr_free;
};

struct per_cpu_pages;

struct per_cpu_zonestat;

struct zone {
	unsigned long _watermark[4];
	unsigned long watermark_boost;
	unsigned long nr_reserved_highatomic;
	long lowmem_reserve[4];
	int node;
	struct pglist_data *zone_pgdat;
	struct per_cpu_pages __attribute__((btf_type_tag("percpu"))) *per_cpu_pageset;
	struct per_cpu_zonestat __attribute__((btf_type_tag("percpu"))) *per_cpu_zonestats;
	int pageset_high_min;
	int pageset_high_max;
	int pageset_batch;
	unsigned long zone_start_pfn;
	atomic_long_t managed_pages;
	unsigned long spanned_pages;
	unsigned long present_pages;
	unsigned long present_early_pages;
	unsigned long cma_pages;
	const char *name;
	unsigned long nr_isolate_pageblock;
	seqlock_t span_seqlock;
	int initialized;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	struct free_area free_area[11];
	unsigned long flags;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	unsigned long percpu_drift_mark;
	unsigned long compact_cached_free_pfn;
	unsigned long compact_cached_migrate_pfn[2];
	unsigned long compact_init_migrate_pfn;
	unsigned long compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	long: 0;
	struct cacheline_padding _pad3_;
	atomic_long_t vm_stat[10];
	atomic_long_t vm_numa_event[6];
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[65];
};

struct memory_failure_stats {
	unsigned long total;
	unsigned long ignored;
	unsigned long failed;
	unsigned long delayed;
	unsigned long recovered;
};

struct per_cpu_nodestat;

struct memory_tier;

struct pglist_data {
	struct zone node_zones[4];
	struct zonelist node_zonelists[2];
	int nr_zones;
	spinlock_t node_size_lock;
	unsigned long node_start_pfn;
	unsigned long node_present_pages;
	unsigned long node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	wait_queue_head_t reclaim_wait[4];
	atomic_t nr_writeback_throttled;
	unsigned long nr_reclaim_start;
	struct mutex kswapd_lock;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	bool proactive_compact_trigger;
	unsigned long totalreserve_pages;
	unsigned long min_unmapped_pages;
	unsigned long min_slab_pages;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	struct deferred_split deferred_split_queue;
	unsigned int nbp_rl_start;
	unsigned long nbp_rl_nr_cand;
	unsigned int nbp_threshold;
	unsigned int nbp_th_start;
	unsigned long nbp_th_nr_cand;
	struct lruvec __lruvec;
	unsigned long flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	struct per_cpu_nodestat __attribute__((btf_type_tag("percpu"))) *per_cpu_nodestats;
	atomic_long_t vm_stat[43];
	struct memory_tier __attribute__((btf_type_tag("rcu"))) *memtier;
	struct memory_failure_stats mf_stats;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct per_cpu_pages {
	spinlock_t lock;
	int count;
	int high;
	int high_min;
	int high_max;
	int batch;
	u8 flags;
	u8 alloc_factor;
	u8 expire;
	short free_count;
	struct list_head lists[13];
	long: 64;
	long: 64;
};

struct per_cpu_zonestat {
	s8 vm_stat_diff[10];
	s8 stat_threshold;
	unsigned long vm_numa_event[6];
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[43];
};

struct memory_tier {
	struct list_head list;
	struct list_head memory_types;
	int adistance_start;
	struct device dev;
	nodemask_t lower_tier_mask;
};

struct lruvec_stats_percpu {
	long state[43];
	long state_prev[43];
};

struct shrinker_info_unit;

struct shrinker_info {
	struct callback_head rcu;
	int map_nr_max;
	struct shrinker_info_unit *unit[0];
};

struct shrinker_info_unit {
	atomic_long_t nr_deferred[64];
	unsigned long map[1];
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr __attribute__((btf_type_tag("user"))) *);
};

struct btf_mod_pair {
	struct btf *btf;
	struct module *module;
};

struct net_device;

struct bpf_offload_dev;

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct disk_stats;

struct blk_holder_ops;

struct partition_meta_info;

struct block_device {
	sector_t bd_start_sect;
	sector_t bd_nr_sectors;
	struct gendisk *bd_disk;
	struct request_queue *bd_queue;
	struct disk_stats __attribute__((btf_type_tag("percpu"))) *bd_stats;
	unsigned long bd_stamp;
	bool bd_read_only;
	u8 bd_partno;
	bool bd_write_holder;
	bool bd_has_submit_bio;
	dev_t bd_dev;
	struct inode *bd_inode;
	atomic_t bd_openers;
	spinlock_t bd_size_lock;
	void *bd_claiming;
	void *bd_holder;
	const struct blk_holder_ops *bd_holder_ops;
	struct mutex bd_holder_lock;
	int bd_fsfreeze_count;
	int bd_holders;
	struct kobject *bd_holder_dir;
	struct mutex bd_fsfreeze_mutex;
	struct super_block *bd_fsfreeze_sb;
	struct partition_meta_info *bd_meta_info;
	bool bd_ro_warned;
	struct device bd_device;
};

struct disk_stats {
	u64 nsecs[4];
	unsigned long sectors[4];
	unsigned long ios[4];
	unsigned long merges[4];
	unsigned long io_ticks;
	local_t in_flight[2];
};

struct blk_holder_ops {
	void (*mark_dead)(struct block_device *, bool);
	void (*sync)(struct block_device *);
};

struct bio;

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

typedef __u32 blk_opf_t;

typedef u8 blk_status_t;

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
} __attribute__((packed));

typedef unsigned int blk_qc_t;

typedef void bio_end_io_t(struct bio *);

struct bio_issue {
	u64 value;
};

struct blkcg_gq;

struct bio_integrity_payload;

struct bio_set;

struct bio {
	struct bio *bi_next;
	struct block_device *bi_bdev;
	blk_opf_t bi_opf;
	unsigned short bi_flags;
	unsigned short bi_ioprio;
	blk_status_t bi_status;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	blk_qc_t bi_cookie;
	bio_end_io_t *bi_end_io;
	void *bi_private;
	struct blkcg_gq *bi_blkg;
	struct bio_issue bi_issue;
	union {
		struct bio_integrity_payload *bi_integrity;
	};
	unsigned short bi_vcnt;
	unsigned short bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct bio_integrity_payload {
	struct bio *bip_bio;
	struct bvec_iter bip_iter;
	unsigned short bip_vcnt;
	unsigned short bip_max_vcnt;
	unsigned short bip_flags;
	struct bvec_iter bio_iter;
	struct work_struct bip_work;
	struct bio_vec *bip_vec;
	struct bio_vec bip_inline_vecs[0];
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_alloc_cache;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	struct bio_alloc_cache __attribute__((btf_type_tag("percpu"))) *cache;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	mempool_t bio_integrity_pool;
	mempool_t bvec_integrity_pool;
	unsigned int back_pad;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
	struct hlist_node cpuhp_dead;
};

struct bio_alloc_cache {
	struct bio *free_list;
	struct bio *free_list_irq;
	unsigned int nr;
	unsigned int nr_irq;
};

struct bpf_run_ctx {};

struct arm_smccc_res {
	unsigned long a0;
	unsigned long a1;
	unsigned long a2;
	unsigned long a3;
};

struct ftr_set_desc {
	char name[20];
	struct arm64_ftr_override *override;
	struct {
		char name[10];
		u8 shift;
		u8 width;
		bool (*filter)(u64);
	} fields[0];
};

struct arm_cpuidle_irq_context {};

struct aarch64_insn_patch {
	void **text_addrs;
	u32 *new_insns;
	int insn_cnt;
	atomic_t cpu_count;
};

struct fregs_offset {
	const char *name;
	int offset;
};

enum aarch64_insn_branch_type {
	AARCH64_INSN_BRANCH_NOLINK = 0,
	AARCH64_INSN_BRANCH_LINK = 1,
	AARCH64_INSN_BRANCH_RETURN = 2,
	AARCH64_INSN_BRANCH_COMP_ZERO = 3,
	AARCH64_INSN_BRANCH_COMP_NONZERO = 4,
};

enum {
	FTRACE_UPDATE_CALLS = 1,
	FTRACE_DISABLE_CALLS = 2,
	FTRACE_UPDATE_TRACE_FUNC = 4,
	FTRACE_START_FUNC_RET = 8,
	FTRACE_STOP_FUNC_RET = 16,
	FTRACE_MAY_SLEEP = 32,
};

enum {
	FTRACE_FL_ENABLED = 2147483648,
	FTRACE_FL_REGS = 1073741824,
	FTRACE_FL_REGS_EN = 536870912,
	FTRACE_FL_TRAMP = 268435456,
	FTRACE_FL_TRAMP_EN = 134217728,
	FTRACE_FL_IPMODIFY = 67108864,
	FTRACE_FL_DISABLED = 33554432,
	FTRACE_FL_DIRECT = 16777216,
	FTRACE_FL_DIRECT_EN = 8388608,
	FTRACE_FL_CALL_OPS = 4194304,
	FTRACE_FL_CALL_OPS_EN = 2097152,
	FTRACE_FL_TOUCHED = 1048576,
	FTRACE_FL_MODIFIED = 524288,
};

struct dyn_arch_ftrace {};

struct dyn_ftrace {
	unsigned long ip;
	unsigned long flags;
	struct dyn_arch_ftrace arch;
};

struct frame_tail {
	struct frame_tail __attribute__((btf_type_tag("user"))) *fp;
	unsigned long lr;
};

struct compat_frame_tail {
	compat_uptr_t fp;
	u32 sp;
	u32 lr;
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short contexts;
	bool contexts_maxed;
};

enum jump_label_type {
	JUMP_LABEL_NOP = 0,
	JUMP_LABEL_JMP = 1,
};

typedef int (*pte_fn_t)(pte_t *, unsigned long, void *);

struct stack_info {
	unsigned long low;
	unsigned long high;
};

typedef unsigned long efi_status_t;

typedef struct {
	u32 type;
	u32 pad;
	u64 phys_addr;
	u64 virt_addr;
	u64 num_pages;
	u64 attribute;
} efi_memory_desc_t;

struct set_perm_data {
	const efi_memory_desc_t *md;
	bool has_bti;
};

struct pvclock_vcpu_stolen_time;

struct pv_time_stolen_time_region {
	struct pvclock_vcpu_stolen_time __attribute__((btf_type_tag("rcu"))) *kaddr;
};

struct pvclock_vcpu_stolen_time {
	__le32 revision;
	__le32 attributes;
	__le64 stolen_time;
	u8 padding[48];
};

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

typedef phys_addr_t resource_size_t;

enum {
	ASSUME_PERFECT = 255,
	ASSUME_VALID_DTB = 1,
	ASSUME_VALID_INPUT = 2,
	ASSUME_LATEST = 4,
	ASSUME_NO_ROLLBACK = 8,
	ASSUME_LIBFDT_ORDER = 16,
	ASSUME_LIBFDT_FLAWLESS = 32,
};

typedef __u32 __be32;

typedef __be32 fdt32_t;

struct fdt_header {
	fdt32_t magic;
	fdt32_t totalsize;
	fdt32_t off_dt_struct;
	fdt32_t off_dt_strings;
	fdt32_t off_mem_rsvmap;
	fdt32_t version;
	fdt32_t last_comp_version;
	fdt32_t boot_cpuid_phys;
	fdt32_t size_dt_strings;
	fdt32_t size_dt_struct;
};

typedef u8 uint8_t;

typedef __u64 __be64;

typedef __be64 fdt64_t;

struct fdt_reserve_entry {
	fdt64_t address;
	fdt64_t size;
};

typedef u64 uint64_t;

struct fdt_property {
	fdt32_t tag;
	fdt32_t len;
	fdt32_t nameoff;
	char data[0];
};

struct fdt_node_header {
	fdt32_t tag;
	char name[0];
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_MOVE_PCNTXT = 32768,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_HANDLE_ENFORCE_IRQCTX = 134217728,
	IRQD_AFFINITY_ON_ACTIVATE = 268435456,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 536870912,
	IRQD_RESEND_WHEN_IN_PROGRESS = 1073741824,
};

typedef unsigned long kimage_entry_t;

struct kexec_segment {
	union {
		void __attribute__((btf_type_tag("user"))) *buf;
		void *kbuf;
	};
	size_t bufsz;
	unsigned long mem;
	size_t memsz;
};

struct kimage_arch {
	void *dtb;
	phys_addr_t dtb_mem;
	phys_addr_t kern_reloc;
	phys_addr_t el2_vectors;
	phys_addr_t ttbr0;
	phys_addr_t ttbr1;
	phys_addr_t zero_page;
	unsigned long phys_offset;
	unsigned long t0sz;
};

struct purgatory_info {
	const Elf64_Ehdr *ehdr;
	Elf64_Shdr *sechdrs;
	void *purgatory_buf;
};

struct kexec_file_ops;

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	unsigned long start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	unsigned long nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	unsigned long control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	struct kimage_arch arch;
	void *kernel_buf;
	unsigned long kernel_buf_len;
	void *initrd_buf;
	unsigned long initrd_buf_len;
	char *cmdline_buf;
	unsigned long cmdline_buf_len;
	const struct kexec_file_ops *fops;
	void *image_loader_data;
	struct purgatory_info purgatory_info;
	void *elf_headers;
	unsigned long elf_headers_sz;
	unsigned long elf_load_addr;
};

typedef int kexec_probe_t(const char *, unsigned long);

typedef void *kexec_load_t(struct kimage *, char *, unsigned long, char *, unsigned long, char *, unsigned long);

typedef int kexec_cleanup_t(void *);

struct kexec_file_ops {
	kexec_probe_t *probe;
	kexec_load_t *load;
	kexec_cleanup_t *cleanup;
};

struct trans_pgd_info {
	void * (*trans_alloc_page)(void *);
	void *trans_alloc_arg;
};

struct reclaim_state {
	unsigned long reclaimed;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct wait_page_queue {
	struct folio *folio;
	int bit_nr;
	wait_queue_entry_t wait;
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	struct file_ra_state *ra;
	unsigned long _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
	bool _workingset;
	unsigned long _pflags;
};

struct swap_cluster_info {
	spinlock_t lock;
	unsigned int data: 24;
	unsigned int flags: 8;
};

struct swap_cluster_list {
	struct swap_cluster_info head;
	struct swap_cluster_info tail;
};

struct percpu_cluster;

struct swap_info_struct {
	struct percpu_ref users;
	unsigned long flags;
	short prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	struct swap_cluster_info *cluster_info;
	struct swap_cluster_list free_clusters;
	unsigned int lowest_bit;
	unsigned int highest_bit;
	unsigned int pages;
	unsigned int inuse_pages;
	unsigned int cluster_next;
	unsigned int cluster_nr;
	unsigned int __attribute__((btf_type_tag("percpu"))) *cluster_next_cpu;
	struct percpu_cluster __attribute__((btf_type_tag("percpu"))) *percpu_cluster;
	struct rb_root swap_extent_root;
	struct bdev_handle *bdev_handle;
	struct block_device *bdev;
	struct file *swap_file;
	unsigned int old_block_size;
	struct completion comp;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct swap_cluster_list discard_clusters;
	struct plist_node avail_lists[0];
};

struct percpu_cluster {
	struct swap_cluster_info index;
	unsigned int next;
};

typedef struct {
	pgd_t pgd;
} p4d_t;

struct hstate {
	struct mutex resize_lock;
	int next_nid_to_alloc;
	int next_nid_to_free;
	unsigned int order;
	unsigned int demote_order;
	unsigned long mask;
	unsigned long max_huge_pages;
	unsigned long nr_huge_pages;
	unsigned long free_huge_pages;
	unsigned long resv_huge_pages;
	unsigned long surplus_huge_pages;
	unsigned long nr_overcommit_huge_pages;
	struct list_head hugepage_activelist;
	struct list_head hugepage_freelists[16];
	unsigned int max_huge_pages_node[16];
	unsigned int nr_huge_pages_node[16];
	unsigned int free_huge_pages_node[16];
	unsigned int surplus_huge_pages_node[16];
	struct cftype cgroup_files_dfl[8];
	struct cftype cgroup_files_legacy[10];
	char name[32];
};

struct hugepage_subpool;

struct hugetlbfs_sb_info {
	long max_inodes;
	long free_inodes;
	spinlock_t stat_lock;
	struct hstate *hstate;
	struct hugepage_subpool *spool;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct hugepage_subpool {
	spinlock_t lock;
	long count;
	long max_hpages;
	long used_hpages;
	struct hstate *hstate;
	long min_hpages;
	long rsv_hpages;
};

enum vgic_irq_config {
	VGIC_CONFIG_EDGE = 0,
	VGIC_CONFIG_LEVEL = 1,
};

enum iodev_type {
	IODEV_CPUIF = 0,
	IODEV_DIST = 1,
	IODEV_REDIST = 2,
	IODEV_ITS = 3,
};

enum mmu_notifier_event {
	MMU_NOTIFY_UNMAP = 0,
	MMU_NOTIFY_CLEAR = 1,
	MMU_NOTIFY_PROTECTION_VMA = 2,
	MMU_NOTIFY_PROTECTION_PAGE = 3,
	MMU_NOTIFY_SOFT_DIRTY = 4,
	MMU_NOTIFY_RELEASE = 5,
	MMU_NOTIFY_MIGRATE = 6,
	MMU_NOTIFY_EXCLUSIVE = 7,
};

enum kvm_stat_kind {
	KVM_STAT_VM = 0,
	KVM_STAT_VCPU = 1,
};

struct kvm_guest_debug_arch {
	__u64 dbg_bcr[16];
	__u64 dbg_bvr[16];
	__u64 dbg_wcr[16];
	__u64 dbg_wvr[16];
};

typedef u64 gpa_t;

struct kvm_vcpu;

struct kvm_cpu_context {
	struct user_pt_regs regs;
	u64 spsr_abt;
	u64 spsr_und;
	u64 spsr_irq;
	u64 spsr_fiq;
	struct user_fpsimd_state fp_regs;
	u64 sys_regs[166];
	struct kvm_vcpu *__hyp_running_vcpu;
	long: 64;
};

struct kvm_vcpu_fault_info {
	u64 esr_el2;
	u64 far_el2;
	u64 hpfar_el2;
	u64 disr_el1;
};

struct vgic_v2_cpu_if {
	u32 vgic_hcr;
	u32 vgic_vmcr;
	u32 vgic_apr;
	u32 vgic_lr[64];
	unsigned int used_lrs;
};

typedef unsigned long irq_hw_number_t;

struct its_vm;

struct its_vpe {
	struct page *vpt_page;
	struct its_vm *its_vm;
	atomic_t vlpi_count;
	int irq;
	irq_hw_number_t vpe_db_lpi;
	bool resident;
	bool ready;
	union {
		struct {
			int vpe_proxy_event;
			bool idai;
		};
		struct {
			struct fwnode_handle *fwnode;
			struct irq_domain *sgi_domain;
			struct {
				u8 priority;
				bool enabled;
				bool group;
			} sgi_config[16];
			atomic_t vmapp_count;
		};
	};
	raw_spinlock_t vpe_lock;
	u16 col_idx;
	u16 vpe_id;
	bool pending_last;
};

struct vgic_v3_cpu_if {
	u32 vgic_hcr;
	u32 vgic_vmcr;
	u32 vgic_sre;
	u32 vgic_ap0r[4];
	u32 vgic_ap1r[4];
	u64 vgic_lr[16];
	struct its_vpe its_vpe;
	unsigned int used_lrs;
};

struct irq_ops;

struct vgic_irq {
	raw_spinlock_t irq_lock;
	struct list_head lpi_list;
	struct list_head ap_list;
	struct kvm_vcpu *vcpu;
	struct kvm_vcpu *target_vcpu;
	u32 intid;
	bool line_level;
	bool pending_latch;
	bool active;
	bool enabled;
	bool hw;
	struct kref refcount;
	u32 hwintid;
	unsigned int host_irq;
	union {
		u8 targets;
		u32 mpidr;
	};
	u8 source;
	u8 active_source;
	u8 priority;
	u8 group;
	enum vgic_irq_config config;
	struct irq_ops *ops;
	void *owner;
};

struct kvm_io_device_ops;

struct kvm_io_device {
	const struct kvm_io_device_ops *ops;
};

struct vgic_its;

struct vgic_register_region;

struct vgic_io_device {
	gpa_t base_addr;
	union {
		struct kvm_vcpu *redist_vcpu;
		struct vgic_its *its;
	};
	const struct vgic_register_region *regions;
	enum iodev_type iodev_type;
	int nr_regions;
	struct kvm_io_device dev;
};

struct vgic_redist_region;

struct vgic_cpu {
	union {
		struct vgic_v2_cpu_if vgic_v2;
		struct vgic_v3_cpu_if vgic_v3;
	};
	struct vgic_irq private_irqs[32];
	raw_spinlock_t ap_list_lock;
	struct list_head ap_list_head;
	struct vgic_io_device rd_iodev;
	struct vgic_redist_region *rdreg;
	u32 rdreg_index;
	atomic_t syncr_busy;
	u64 pendbaser;
	atomic_t ctlr;
	u32 num_pri_bits;
	u32 num_id_bits;
};

struct arch_timer_offset {
	u64 *vm_offset;
	u64 *vcpu_offset;
};

struct arch_timer_context {
	struct kvm_vcpu *vcpu;
	struct hrtimer hrtimer;
	u64 ns_frac;
	struct arch_timer_offset offset;
	bool loaded;
	struct {
		bool level;
	} irq;
	u32 host_timer_irq;
};

struct arch_timer_cpu {
	struct arch_timer_context timers[4];
	struct hrtimer bg_timer;
	bool enabled;
};

struct kvm_pmu_events {
	u32 events_host;
	u32 events_guest;
};

struct kvm_pmc {
	u8 idx;
	struct perf_event *perf_event;
};

struct kvm_pmu {
	struct irq_work overflow_work;
	struct kvm_pmu_events events;
	struct kvm_pmc pmc[32];
	int irq_num;
	bool created;
	bool irq_level;
};

struct kvm_mp_state {
	__u32 mp_state;
};

struct kvm_mmu_memory_cache {
	gfp_t gfp_zero;
	gfp_t gfp_custom;
	struct kmem_cache *kmem_cache;
	int capacity;
	int nobjs;
	void **objects;
};

struct vcpu_reset_state {
	unsigned long pc;
	unsigned long r0;
	bool be;
	bool reset;
};

struct kvm_s2_mmu;

struct kvm_vcpu_arch {
	struct kvm_cpu_context ctxt;
	void *sve_state;
	enum fp_type fp_type;
	unsigned int sve_max_vl;
	u64 svcr;
	struct kvm_s2_mmu *hw_mmu;
	u64 hcr_el2;
	u64 mdcr_el2;
	u64 cptr_el2;
	u64 mdcr_el2_host;
	struct kvm_vcpu_fault_info fault;
	enum {
		FP_STATE_FREE = 0,
		FP_STATE_HOST_OWNED = 1,
		FP_STATE_GUEST_OWNED = 2,
	} fp_state;
	u8 cflags;
	u8 iflags;
	u8 sflags;
	bool pause;
	struct kvm_guest_debug_arch *debug_ptr;
	struct kvm_guest_debug_arch vcpu_debug_state;
	struct kvm_guest_debug_arch external_debug_state;
	struct user_fpsimd_state *host_fpsimd_state;
	struct task_struct *parent_task;
	struct {
		struct kvm_guest_debug_arch regs;
		u64 pmscr_el1;
		u64 trfcr_el1;
	} host_debug_state;
	struct vgic_cpu vgic_cpu;
	struct arch_timer_cpu timer_cpu;
	struct kvm_pmu pmu;
	struct {
		u32 mdscr_el1;
		bool pstate_ss;
	} guest_debug_preserved;
	struct kvm_mp_state mp_state;
	spinlock_t mp_state_lock;
	struct kvm_mmu_memory_cache mmu_page_cache;
	u64 vsesr_el2;
	struct vcpu_reset_state reset_state;
	struct {
		u64 last_steal;
		gpa_t base;
	} steal;
	u32 *ccsidr;
};

struct preempt_ops;

struct preempt_notifier {
	struct hlist_node link;
	struct preempt_ops *ops;
};

struct kvm_mmio_fragment {
	gpa_t gpa;
	void *data;
	unsigned int len;
};

struct kvm_vcpu_stat_generic {
	u64 halt_successful_poll;
	u64 halt_attempted_poll;
	u64 halt_poll_invalid;
	u64 halt_wakeup;
	u64 halt_poll_success_ns;
	u64 halt_poll_fail_ns;
	u64 halt_wait_ns;
	u64 halt_poll_success_hist[32];
	u64 halt_poll_fail_hist[32];
	u64 halt_wait_hist[32];
	u64 blocking;
};

struct kvm_vcpu_stat {
	struct kvm_vcpu_stat_generic generic;
	u64 hvc_exit_stat;
	u64 wfe_exit_stat;
	u64 wfi_exit_stat;
	u64 mmio_exit_user;
	u64 mmio_exit_kernel;
	u64 signal_exits;
	u64 exits;
};

struct kvm_dirty_gfn;

struct kvm_dirty_ring {
	u32 dirty_index;
	u32 reset_index;
	u32 size;
	u32 soft_limit;
	struct kvm_dirty_gfn *dirty_gfns;
	int index;
};

struct kvm;

struct kvm_run;

struct kvm_memory_slot;

struct kvm_vcpu {
	struct kvm *kvm;
	struct preempt_notifier preempt_notifier;
	int cpu;
	int vcpu_id;
	int vcpu_idx;
	int ____srcu_idx;
	int mode;
	u64 requests;
	unsigned long guest_debug;
	struct mutex mutex;
	struct kvm_run *run;
	struct rcuwait wait;
	struct pid __attribute__((btf_type_tag("rcu"))) *pid;
	int sigset_active;
	sigset_t sigset;
	unsigned int halt_poll_ns;
	bool valid_wakeup;
	int mmio_needed;
	int mmio_read_completed;
	int mmio_is_write;
	int mmio_cur_fragment;
	int mmio_nr_fragments;
	struct kvm_mmio_fragment mmio_fragments[2];
	struct {
		bool in_spin_loop;
		bool dy_eligible;
	} spin_loop;
	bool preempted;
	bool ready;
	long: 64;
	struct kvm_vcpu_arch arch;
	struct kvm_vcpu_stat stat;
	char stats_id[48];
	struct kvm_dirty_ring dirty_ring;
	struct kvm_memory_slot *last_used_slot;
	u64 last_used_slot_gen;
	long: 64;
};

struct kvm_memslots {
	u64 generation;
	atomic_long_t last_used_slot;
	struct rb_root_cached hva_tree;
	struct rb_root gfn_tree;
	struct hlist_head id_hash[128];
	int node_idx;
};

struct kvm_vm_stat_generic {
	u64 remote_tlb_flush;
	u64 remote_tlb_flush_requests;
};

struct kvm_vm_stat {
	struct kvm_vm_stat_generic generic;
};

struct kvm_vmid {
	atomic64_t id;
};

struct kvm_pgtable;

struct kvm_arch;

struct kvm_s2_mmu {
	struct kvm_vmid vmid;
	phys_addr_t pgd_phys;
	struct kvm_pgtable *pgt;
	u64 vtcr;
	int __attribute__((btf_type_tag("percpu"))) *last_vcpu_ran;
	struct kvm_mmu_memory_cache split_page_cache;
	uint64_t split_page_chunk_size;
	struct kvm_arch *arch;
};

struct its_vm {
	struct fwnode_handle *fwnode;
	struct irq_domain *domain;
	struct page *vprop_page;
	struct its_vpe **vpes;
	int nr_vpes;
	irq_hw_number_t db_lpi_base;
	unsigned long *db_bitmap;
	int nr_db_lpis;
	u32 vlpi_count[16];
};

struct vgic_state_iter;

struct vgic_dist {
	bool in_kernel;
	bool ready;
	bool initialized;
	u32 vgic_model;
	u32 implementation_rev;
	bool v2_groups_user_writable;
	bool msis_require_devid;
	int nr_spis;
	gpa_t vgic_dist_base;
	union {
		gpa_t vgic_cpu_base;
		struct list_head rd_regions;
	};
	bool enabled;
	bool nassgireq;
	struct vgic_irq *spis;
	struct vgic_io_device dist_iodev;
	bool has_its;
	bool table_write_in_progress;
	u64 propbaser;
	raw_spinlock_t lpi_list_lock;
	struct list_head lpi_list_head;
	int lpi_list_count;
	struct list_head lpi_translation_cache;
	struct vgic_state_iter *iter;
	struct its_vm its_vm;
};

struct arch_timer_vm_data {
	u64 voffset;
	u64 poffset;
	u8 ppi[4];
};

struct kvm_smccc_features {
	unsigned long std_bmap;
	unsigned long std_hyp_bmap;
	unsigned long vendor_hyp_bmap;
};

typedef unsigned int pkvm_handle_t;

struct kvm_hyp_memcache {
	phys_addr_t head;
	unsigned long nr_pages;
};

struct kvm_protected_vm {
	pkvm_handle_t handle;
	struct kvm_hyp_memcache teardown_mc;
};

struct kvm_mpidr_data;

struct arm_pmu;

struct kvm_arch {
	struct kvm_s2_mmu mmu;
	struct vgic_dist vgic;
	struct arch_timer_vm_data timer_data;
	u32 psci_version;
	struct mutex config_lock;
	unsigned long flags;
	unsigned long vcpu_features[1];
	struct kvm_mpidr_data *mpidr_data;
	unsigned long *pmu_filter;
	struct arm_pmu *arm_pmu;
	cpumask_var_t supported_cpus;
	u8 pmcr_n;
	struct kvm_smccc_features smccc_feat;
	struct maple_tree smccc_filter;
	u64 id_regs[56];
	struct kvm_protected_vm pkvm;
};

struct mmu_notifier_ops;

struct mmu_notifier {
	struct hlist_node hlist;
	const struct mmu_notifier_ops *ops;
	struct mm_struct *mm;
	struct callback_head rcu;
	unsigned int users;
};

struct kvm_io_bus;

struct kvm_coalesced_mmio_ring;

struct kvm_irq_routing_table;

struct kvm_stat_data;

struct kvm {
	rwlock_t mmu_lock;
	struct mutex slots_lock;
	struct mutex slots_arch_lock;
	struct mm_struct *mm;
	unsigned long nr_memslot_pages;
	struct kvm_memslots __memslots[2];
	struct kvm_memslots __attribute__((btf_type_tag("rcu"))) *memslots[1];
	struct xarray vcpu_array;
	atomic_t nr_memslots_dirty_logging;
	spinlock_t mn_invalidate_lock;
	unsigned long mn_active_invalidate_count;
	struct rcuwait mn_memslots_update_rcuwait;
	spinlock_t gpc_lock;
	struct list_head gpc_list;
	atomic_t online_vcpus;
	int max_vcpus;
	int created_vcpus;
	int last_boosted_vcpu;
	struct list_head vm_list;
	struct mutex lock;
	struct kvm_io_bus __attribute__((btf_type_tag("rcu"))) *buses[4];
	struct {
		spinlock_t lock;
		struct list_head items;
		struct list_head resampler_list;
		struct mutex resampler_lock;
	} irqfds;
	struct list_head ioeventfds;
	struct kvm_vm_stat stat;
	struct kvm_arch arch;
	refcount_t users_count;
	struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;
	spinlock_t ring_lock;
	struct list_head coalesced_zones;
	struct mutex irq_lock;
	struct kvm_irq_routing_table __attribute__((btf_type_tag("rcu"))) *irq_routing;
	struct hlist_head irq_ack_notifier_list;
	struct mmu_notifier mmu_notifier;
	unsigned long mmu_invalidate_seq;
	long mmu_invalidate_in_progress;
	unsigned long mmu_invalidate_range_start;
	unsigned long mmu_invalidate_range_end;
	struct list_head devices;
	u64 manual_dirty_log_protect;
	struct dentry *debugfs_dentry;
	struct kvm_stat_data **debugfs_stat_data;
	struct srcu_struct srcu;
	struct srcu_struct irq_srcu;
	pid_t userspace_pid;
	bool override_halt_poll_ns;
	unsigned int max_halt_poll_ns;
	u32 dirty_ring_size;
	bool dirty_ring_with_bitmap;
	bool vm_bugged;
	bool vm_dead;
	char stats_id[48];
};

struct kvm_io_range {
	gpa_t addr;
	int len;
	struct kvm_io_device *dev;
};

struct kvm_io_bus {
	int dev_count;
	int ioeventfd_count;
	struct kvm_io_range range[0];
};

struct kvm_io_device_ops {
	int (*read)(struct kvm_vcpu *, struct kvm_io_device *, gpa_t, int, void *);
	int (*write)(struct kvm_vcpu *, struct kvm_io_device *, gpa_t, int, const void *);
	void (*destructor)(struct kvm_io_device *);
};

struct irq_ops {
	unsigned long flags;
	bool (*get_input_level)(int);
};

struct kvm_device;

struct vgic_its {
	gpa_t vgic_its_base;
	bool enabled;
	struct vgic_io_device iodev;
	struct kvm_device *dev;
	u64 baser_device_table;
	u64 baser_coll_table;
	struct mutex cmd_lock;
	u64 cbaser;
	u32 creadr;
	u32 cwriter;
	u32 abi_rev;
	struct mutex its_lock;
	struct list_head device_list;
	struct list_head collection_list;
};

struct kvm_device_ops;

struct kvm_device {
	const struct kvm_device_ops *ops;
	struct kvm *kvm;
	void *private;
	struct list_head vm_node;
};

struct kvm_device_attr;

struct kvm_device_ops {
	const char *name;
	int (*create)(struct kvm_device *, u32);
	void (*init)(struct kvm_device *);
	void (*destroy)(struct kvm_device *);
	void (*release)(struct kvm_device *);
	int (*set_attr)(struct kvm_device *, struct kvm_device_attr *);
	int (*get_attr)(struct kvm_device *, struct kvm_device_attr *);
	int (*has_attr)(struct kvm_device *, struct kvm_device_attr *);
	long (*ioctl)(struct kvm_device *, unsigned int, unsigned long);
	int (*mmap)(struct kvm_device *, struct vm_area_struct *);
};

struct kvm_device_attr {
	__u32 flags;
	__u32 group;
	__u64 attr;
	__u64 addr;
};

struct vgic_register_region {
	unsigned int reg_offset;
	unsigned int len;
	unsigned int bits_per_irq;
	unsigned int access_flags;
	union {
		unsigned long (*read)(struct kvm_vcpu *, gpa_t, unsigned int);
		unsigned long (*its_read)(struct kvm *, struct vgic_its *, gpa_t, unsigned int);
	};
	union {
		void (*write)(struct kvm_vcpu *, gpa_t, unsigned int, unsigned long);
		void (*its_write)(struct kvm *, struct vgic_its *, gpa_t, unsigned int, unsigned long);
	};
	unsigned long (*uaccess_read)(struct kvm_vcpu *, gpa_t, unsigned int);
	union {
		int (*uaccess_write)(struct kvm_vcpu *, gpa_t, unsigned int, unsigned long);
		int (*uaccess_its_write)(struct kvm *, struct vgic_its *, gpa_t, unsigned int, unsigned long);
	};
};

struct kvm_mpidr_data {
	u64 mpidr_mask;
	struct {
		struct {} __empty_cmpidr_to_idx;
		u16 cmpidr_to_idx[0];
	};
};

struct kvm_coalesced_mmio {
	__u64 phys_addr;
	__u32 len;
	union {
		__u32 pad;
		__u32 pio;
	};
	__u8 data[8];
};

struct kvm_coalesced_mmio_ring {
	__u32 first;
	__u32 last;
	struct kvm_coalesced_mmio coalesced_mmio[0];
};

struct kvm_irq_routing_table {
	int chip[988];
	u32 nr_rt_entries;
	struct hlist_head map[0];
};

struct mmu_notifier_range;

struct mmu_notifier_ops {
	void (*release)(struct mmu_notifier *, struct mm_struct *);
	int (*clear_flush_young)(struct mmu_notifier *, struct mm_struct *, unsigned long, unsigned long);
	int (*clear_young)(struct mmu_notifier *, struct mm_struct *, unsigned long, unsigned long);
	int (*test_young)(struct mmu_notifier *, struct mm_struct *, unsigned long);
	void (*change_pte)(struct mmu_notifier *, struct mm_struct *, unsigned long, pte_t);
	int (*invalidate_range_start)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range_end)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*arch_invalidate_secondary_tlbs)(struct mmu_notifier *, struct mm_struct *, unsigned long, unsigned long);
	struct mmu_notifier * (*alloc_notifier)(struct mm_struct *);
	void (*free_notifier)(struct mmu_notifier *);
};

struct mmu_notifier_range {
	struct mm_struct *mm;
	unsigned long start;
	unsigned long end;
	unsigned int flags;
	enum mmu_notifier_event event;
	void *owner;
};

struct _kvm_stats_desc;

struct kvm_stat_data {
	struct kvm *kvm;
	const struct _kvm_stats_desc *desc;
	enum kvm_stat_kind kind;
};

struct kvm_stats_desc {
	__u32 flags;
	__s16 exponent;
	__u16 size;
	__u32 offset;
	__u32 bucket_size;
	char name[0];
};

struct _kvm_stats_desc {
	struct kvm_stats_desc desc;
	char name[48];
};

struct preempt_ops {
	void (*sched_in)(struct preempt_notifier *, int);
	void (*sched_out)(struct preempt_notifier *, struct task_struct *);
};

struct kvm_debug_exit_arch {
	__u32 hsr;
	__u32 hsr_high;
	__u64 far;
};

struct kvm_hyperv_exit {
	__u32 type;
	__u32 pad1;
	union {
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 evt_page;
			__u64 msg_page;
		} synic;
		struct {
			__u64 input;
			__u64 result;
			__u64 params[2];
		} hcall;
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 status;
			__u64 send_page;
			__u64 recv_page;
			__u64 pending_page;
		} syndbg;
	} u;
};

struct kvm_xen_exit {
	__u32 type;
	union {
		struct {
			__u32 longmode;
			__u32 cpl;
			__u64 input;
			__u64 result;
			__u64 params[6];
		} hcall;
	} u;
};

struct kvm_sync_regs {
	__u64 device_irq_level;
};

struct kvm_run {
	__u8 request_interrupt_window;
	__u8 immediate_exit;
	__u8 padding1[6];
	__u32 exit_reason;
	__u8 ready_for_interrupt_injection;
	__u8 if_flag;
	__u16 flags;
	__u64 cr8;
	__u64 apic_base;
	union {
		struct {
			__u64 hardware_exit_reason;
		} hw;
		struct {
			__u64 hardware_entry_failure_reason;
			__u32 cpu;
		} fail_entry;
		struct {
			__u32 exception;
			__u32 error_code;
		} ex;
		struct {
			__u8 direction;
			__u8 size;
			__u16 port;
			__u32 count;
			__u64 data_offset;
		} io;
		struct {
			struct kvm_debug_exit_arch arch;
		} debug;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} mmio;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} iocsr_io;
		struct {
			__u64 nr;
			__u64 args[6];
			__u64 ret;
			union {
				__u64 flags;
			};
		} hypercall;
		struct {
			__u64 rip;
			__u32 is_write;
			__u32 pad;
		} tpr_access;
		struct {
			__u8 icptcode;
			__u16 ipa;
			__u32 ipb;
		} s390_sieic;
		__u64 s390_reset_flags;
		struct {
			__u64 trans_exc_code;
			__u32 pgm_code;
		} s390_ucontrol;
		struct {
			__u32 dcrn;
			__u32 data;
			__u8 is_write;
		} dcr;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 data[16];
		} internal;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 flags;
			union {
				struct {
					__u8 insn_size;
					__u8 insn_bytes[15];
				};
			};
		} emulation_failure;
		struct {
			__u64 gprs[32];
		} osi;
		struct {
			__u64 nr;
			__u64 ret;
			__u64 args[9];
		} papr_hcall;
		struct {
			__u16 subchannel_id;
			__u16 subchannel_nr;
			__u32 io_int_parm;
			__u32 io_int_word;
			__u32 ipb;
			__u8 dequeued;
		} s390_tsch;
		struct {
			__u32 epr;
		} epr;
		struct {
			__u32 type;
			__u32 ndata;
			union {
				__u64 data[16];
			};
		} system_event;
		struct {
			__u64 addr;
			__u8 ar;
			__u8 reserved;
			__u8 fc;
			__u8 sel1;
			__u16 sel2;
		} s390_stsi;
		struct {
			__u8 vector;
		} eoi;
		struct kvm_hyperv_exit hyperv;
		struct {
			__u64 esr_iss;
			__u64 fault_ipa;
		} arm_nisv;
		struct {
			__u8 error;
			__u8 pad[7];
			__u32 reason;
			__u32 index;
			__u64 data;
		} msr;
		struct kvm_xen_exit xen;
		struct {
			unsigned long extension_id;
			unsigned long function_id;
			unsigned long args[6];
			unsigned long ret[2];
		} riscv_sbi;
		struct {
			unsigned long csr_num;
			unsigned long new_value;
			unsigned long write_mask;
			unsigned long ret_value;
		} riscv_csr;
		struct {
			__u32 flags;
		} notify;
		char padding[256];
	};
	__u64 kvm_valid_regs;
	__u64 kvm_dirty_regs;
	union {
		struct kvm_sync_regs regs;
		char padding[2048];
	} s;
};

struct kvm_dirty_gfn {
	__u32 flags;
	__u32 slot;
	__u64 offset;
};

struct interval_tree_node {
	struct rb_node rb;
	unsigned long start;
	unsigned long last;
	unsigned long __subtree_last;
};

typedef u64 gfn_t;

struct kvm_arch_memory_slot {};

struct kvm_memory_slot {
	struct hlist_node id_node[2];
	struct interval_tree_node hva_node[2];
	struct rb_node gfn_node[2];
	gfn_t base_gfn;
	unsigned long npages;
	unsigned long *dirty_bitmap;
	struct kvm_arch_memory_slot arch;
	unsigned long userspace_addr;
	u32 flags;
	short id;
	u16 as_id;
};

struct vgic_redist_region {
	u32 index;
	gpa_t base;
	u32 count;
	u32 free_index;
	struct list_head list;
};

enum vcpu_sysreg {
	__INVALID_SYSREG__ = 0,
	MPIDR_EL1 = 1,
	CLIDR_EL1 = 2,
	CSSELR_EL1 = 3,
	SCTLR_EL1 = 4,
	ACTLR_EL1 = 5,
	CPACR_EL1 = 6,
	ZCR_EL1 = 7,
	TTBR0_EL1 = 8,
	TTBR1_EL1 = 9,
	TCR_EL1 = 10,
	TCR2_EL1 = 11,
	ESR_EL1 = 12,
	AFSR0_EL1 = 13,
	AFSR1_EL1 = 14,
	FAR_EL1 = 15,
	MAIR_EL1 = 16,
	VBAR_EL1 = 17,
	CONTEXTIDR_EL1 = 18,
	TPIDR_EL0 = 19,
	TPIDRRO_EL0 = 20,
	TPIDR_EL1 = 21,
	AMAIR_EL1 = 22,
	CNTKCTL_EL1 = 23,
	PAR_EL1 = 24,
	MDSCR_EL1 = 25,
	MDCCINT_EL1 = 26,
	OSLSR_EL1 = 27,
	DISR_EL1 = 28,
	PMCR_EL0 = 29,
	PMSELR_EL0 = 30,
	PMEVCNTR0_EL0 = 31,
	PMEVCNTR30_EL0 = 61,
	PMCCNTR_EL0 = 62,
	PMEVTYPER0_EL0 = 63,
	PMEVTYPER30_EL0 = 93,
	PMCCFILTR_EL0 = 94,
	PMCNTENSET_EL0 = 95,
	PMINTENSET_EL1 = 96,
	PMOVSSET_EL0 = 97,
	PMUSERENR_EL0 = 98,
	APIAKEYLO_EL1 = 99,
	APIAKEYHI_EL1 = 100,
	APIBKEYLO_EL1 = 101,
	APIBKEYHI_EL1 = 102,
	APDAKEYLO_EL1 = 103,
	APDAKEYHI_EL1 = 104,
	APDBKEYLO_EL1 = 105,
	APDBKEYHI_EL1 = 106,
	APGAKEYLO_EL1 = 107,
	APGAKEYHI_EL1 = 108,
	ELR_EL1 = 109,
	SP_EL1 = 110,
	SPSR_EL1 = 111,
	CNTVOFF_EL2 = 112,
	CNTV_CVAL_EL0 = 113,
	CNTV_CTL_EL0 = 114,
	CNTP_CVAL_EL0 = 115,
	CNTP_CTL_EL0 = 116,
	RGSR_EL1 = 117,
	GCR_EL1 = 118,
	TFSR_EL1 = 119,
	TFSRE0_EL1 = 120,
	PIR_EL1 = 121,
	PIRE0_EL1 = 122,
	DACR32_EL2 = 123,
	IFSR32_EL2 = 124,
	FPEXC32_EL2 = 125,
	DBGVCR32_EL2 = 126,
	VPIDR_EL2 = 127,
	VMPIDR_EL2 = 128,
	SCTLR_EL2 = 129,
	ACTLR_EL2 = 130,
	HCR_EL2 = 131,
	MDCR_EL2 = 132,
	CPTR_EL2 = 133,
	HSTR_EL2 = 134,
	HACR_EL2 = 135,
	HCRX_EL2 = 136,
	TTBR0_EL2 = 137,
	TTBR1_EL2 = 138,
	TCR_EL2 = 139,
	VTTBR_EL2 = 140,
	VTCR_EL2 = 141,
	SPSR_EL2 = 142,
	ELR_EL2 = 143,
	AFSR0_EL2 = 144,
	AFSR1_EL2 = 145,
	ESR_EL2 = 146,
	FAR_EL2 = 147,
	HPFAR_EL2 = 148,
	MAIR_EL2 = 149,
	AMAIR_EL2 = 150,
	VBAR_EL2 = 151,
	RVBAR_EL2 = 152,
	CONTEXTIDR_EL2 = 153,
	TPIDR_EL2 = 154,
	CNTHCTL_EL2 = 155,
	SP_EL2 = 156,
	HFGRTR_EL2 = 157,
	HFGWTR_EL2 = 158,
	HFGITR_EL2 = 159,
	HDFGRTR_EL2 = 160,
	HDFGWTR_EL2 = 161,
	CNTHP_CTL_EL2 = 162,
	CNTHP_CVAL_EL2 = 163,
	CNTHV_CTL_EL2 = 164,
	CNTHV_CVAL_EL2 = 165,
	NR_SYS_REGS = 166,
};

typedef u64 kvm_pte_t;

typedef kvm_pte_t __attribute__((btf_type_tag("rcu"))) *kvm_pteref_t;

enum kvm_pgtable_stage2_flags {
	KVM_PGTABLE_S2_NOFWB = 1,
	KVM_PGTABLE_S2_IDMAP = 2,
};

enum kvm_pgtable_prot {
	KVM_PGTABLE_PROT_X = 1ULL,
	KVM_PGTABLE_PROT_W = 2ULL,
	KVM_PGTABLE_PROT_R = 4ULL,
	KVM_PGTABLE_PROT_DEVICE = 8ULL,
	KVM_PGTABLE_PROT_SW0 = 36028797018963968ULL,
	KVM_PGTABLE_PROT_SW1 = 72057594037927936ULL,
	KVM_PGTABLE_PROT_SW2 = 144115188075855872ULL,
	KVM_PGTABLE_PROT_SW3 = 288230376151711744ULL,
};

typedef bool (*kvm_pgtable_force_pte_cb_t)(u64, u64, enum kvm_pgtable_prot);

struct kvm_pgtable_mm_ops;

struct kvm_pgtable {
	u32 ia_bits;
	u32 start_level;
	kvm_pteref_t pgd;
	struct kvm_pgtable_mm_ops *mm_ops;
	struct kvm_s2_mmu *mmu;
	enum kvm_pgtable_stage2_flags flags;
	kvm_pgtable_force_pte_cb_t force_pte_cb;
};

struct kvm_pgtable_mm_ops {
	void * (*zalloc_page)(void *);
	void * (*zalloc_pages_exact)(size_t);
	void (*free_pages_exact)(void *, size_t);
	void (*free_unlinked_table)(void *, u32);
	void (*get_page)(void *);
	void (*put_page)(void *);
	int (*page_count)(void *);
	void * (*phys_to_virt)(phys_addr_t);
	phys_addr_t (*virt_to_phys)(void *);
	void (*dcache_clean_inval_poc)(void *, size_t);
	void (*icache_inval_pou)(void *, size_t);
};

enum vgic_type {
	VGIC_V2 = 0,
	VGIC_V3 = 1,
};

enum kvm_bus {
	KVM_MMIO_BUS = 0,
	KVM_PIO_BUS = 1,
	KVM_VIRTIO_CCW_NOTIFY_BUS = 2,
	KVM_FAST_MMIO_BUS = 3,
	KVM_NR_BUSES = 4,
};

enum kvm_device_type {
	KVM_DEV_TYPE_FSL_MPIC_20 = 1,
	KVM_DEV_TYPE_FSL_MPIC_42 = 2,
	KVM_DEV_TYPE_XICS = 3,
	KVM_DEV_TYPE_VFIO = 4,
	KVM_DEV_TYPE_ARM_VGIC_V2 = 5,
	KVM_DEV_TYPE_FLIC = 6,
	KVM_DEV_TYPE_ARM_VGIC_V3 = 7,
	KVM_DEV_TYPE_ARM_VGIC_ITS = 8,
	KVM_DEV_TYPE_XIVE = 9,
	KVM_DEV_TYPE_ARM_PV_TIME = 10,
	KVM_DEV_TYPE_RISCV_AIA = 11,
	KVM_DEV_TYPE_MAX = 12,
};

typedef __u16 __le16;

struct vgic_vmcr {
	u32 grpen0;
	u32 grpen1;
	u32 ackctl;
	u32 fiqen;
	u32 cbpr;
	u32 eoim;
	u32 abpr;
	u32 bpr;
	u32 pmr;
};

union hyp_spinlock {
	u32 __val;
	struct {
		u16 owner;
		u16 next;
	};
};

typedef union hyp_spinlock hyp_spinlock_t;

struct hyp_pool {
	hyp_spinlock_t lock;
	struct list_head free_area[11];
	phys_addr_t range_start;
	phys_addr_t range_end;
	unsigned short max_order;
};

struct kvm_vcpu___2;

struct kvm_cpu_context___2 {
	struct user_pt_regs regs;
	u64 spsr_abt;
	u64 spsr_und;
	u64 spsr_irq;
	u64 spsr_fiq;
	struct user_fpsimd_state fp_regs;
	u64 sys_regs[166];
	struct kvm_vcpu___2 *__hyp_running_vcpu;
	long: 64;
};

struct vgic_irq___2 {
	raw_spinlock_t irq_lock;
	struct list_head lpi_list;
	struct list_head ap_list;
	struct kvm_vcpu___2 *vcpu;
	struct kvm_vcpu___2 *target_vcpu;
	u32 intid;
	bool line_level;
	bool pending_latch;
	bool active;
	bool enabled;
	bool hw;
	struct kref refcount;
	u32 hwintid;
	unsigned int host_irq;
	union {
		u8 targets;
		u32 mpidr;
	};
	u8 source;
	u8 active_source;
	u8 priority;
	u8 group;
	enum vgic_irq_config config;
	struct irq_ops *ops;
	void *owner;
};

struct kvm_io_device_ops___2;

struct kvm_io_device___2 {
	const struct kvm_io_device_ops___2 *ops;
};

struct vgic_its___2;

struct vgic_io_device___2 {
	gpa_t base_addr;
	union {
		struct kvm_vcpu___2 *redist_vcpu;
		struct vgic_its___2 *its;
	};
	const struct vgic_register_region *regions;
	enum iodev_type iodev_type;
	int nr_regions;
	struct kvm_io_device___2 dev;
};

struct vgic_cpu___2 {
	union {
		struct vgic_v2_cpu_if vgic_v2;
		struct vgic_v3_cpu_if vgic_v3;
	};
	struct vgic_irq___2 private_irqs[32];
	raw_spinlock_t ap_list_lock;
	struct list_head ap_list_head;
	struct vgic_io_device___2 rd_iodev;
	struct vgic_redist_region *rdreg;
	u32 rdreg_index;
	atomic_t syncr_busy;
	u64 pendbaser;
	atomic_t ctlr;
	u32 num_pri_bits;
	u32 num_id_bits;
};

struct arch_timer_context___2 {
	struct kvm_vcpu___2 *vcpu;
	struct hrtimer hrtimer;
	u64 ns_frac;
	struct arch_timer_offset offset;
	bool loaded;
	struct {
		bool level;
	} irq;
	u32 host_timer_irq;
};

struct arch_timer_cpu___2 {
	struct arch_timer_context___2 timers[4];
	struct hrtimer bg_timer;
	bool enabled;
};

struct kvm_s2_mmu___2;

struct kvm_vcpu_arch___2 {
	struct kvm_cpu_context___2 ctxt;
	void *sve_state;
	enum fp_type fp_type;
	unsigned int sve_max_vl;
	u64 svcr;
	struct kvm_s2_mmu___2 *hw_mmu;
	u64 hcr_el2;
	u64 mdcr_el2;
	u64 cptr_el2;
	u64 mdcr_el2_host;
	struct kvm_vcpu_fault_info fault;
	enum {
		FP_STATE_FREE___2 = 0,
		FP_STATE_HOST_OWNED___2 = 1,
		FP_STATE_GUEST_OWNED___2 = 2,
	} fp_state;
	u8 cflags;
	u8 iflags;
	u8 sflags;
	bool pause;
	struct kvm_guest_debug_arch *debug_ptr;
	struct kvm_guest_debug_arch vcpu_debug_state;
	struct kvm_guest_debug_arch external_debug_state;
	struct user_fpsimd_state *host_fpsimd_state;
	struct task_struct *parent_task;
	struct {
		struct kvm_guest_debug_arch regs;
		u64 pmscr_el1;
		u64 trfcr_el1;
	} host_debug_state;
	struct vgic_cpu___2 vgic_cpu;
	struct arch_timer_cpu___2 timer_cpu;
	struct kvm_pmu pmu;
	struct {
		u32 mdscr_el1;
		bool pstate_ss;
	} guest_debug_preserved;
	struct kvm_mp_state mp_state;
	spinlock_t mp_state_lock;
	struct kvm_mmu_memory_cache mmu_page_cache;
	u64 vsesr_el2;
	struct vcpu_reset_state reset_state;
	struct {
		u64 last_steal;
		gpa_t base;
	} steal;
	u32 *ccsidr;
};

struct kvm___2;

struct kvm_vcpu___2 {
	struct kvm___2 *kvm;
	struct preempt_notifier preempt_notifier;
	int cpu;
	int vcpu_id;
	int vcpu_idx;
	int ____srcu_idx;
	int mode;
	u64 requests;
	unsigned long guest_debug;
	struct mutex mutex;
	struct kvm_run *run;
	struct rcuwait wait;
	struct pid __attribute__((btf_type_tag("rcu"))) *pid;
	int sigset_active;
	sigset_t sigset;
	unsigned int halt_poll_ns;
	bool valid_wakeup;
	int mmio_needed;
	int mmio_read_completed;
	int mmio_is_write;
	int mmio_cur_fragment;
	int mmio_nr_fragments;
	struct kvm_mmio_fragment mmio_fragments[2];
	struct {
		bool in_spin_loop;
		bool dy_eligible;
	} spin_loop;
	bool preempted;
	bool ready;
	long: 64;
	struct kvm_vcpu_arch___2 arch;
	struct kvm_vcpu_stat stat;
	char stats_id[48];
	struct kvm_dirty_ring dirty_ring;
	struct kvm_memory_slot *last_used_slot;
	u64 last_used_slot_gen;
	long: 64;
};

struct kvm_pgtable___2;

struct kvm_arch___2;

struct kvm_s2_mmu___2 {
	struct kvm_vmid vmid;
	phys_addr_t pgd_phys;
	struct kvm_pgtable___2 *pgt;
	u64 vtcr;
	int __attribute__((btf_type_tag("percpu"))) *last_vcpu_ran;
	struct kvm_mmu_memory_cache split_page_cache;
	uint64_t split_page_chunk_size;
	struct kvm_arch___2 *arch;
};

struct vgic_dist___2 {
	bool in_kernel;
	bool ready;
	bool initialized;
	u32 vgic_model;
	u32 implementation_rev;
	bool v2_groups_user_writable;
	bool msis_require_devid;
	int nr_spis;
	gpa_t vgic_dist_base;
	union {
		gpa_t vgic_cpu_base;
		struct list_head rd_regions;
	};
	bool enabled;
	bool nassgireq;
	struct vgic_irq___2 *spis;
	struct vgic_io_device___2 dist_iodev;
	bool has_its;
	bool table_write_in_progress;
	u64 propbaser;
	raw_spinlock_t lpi_list_lock;
	struct list_head lpi_list_head;
	int lpi_list_count;
	struct list_head lpi_translation_cache;
	struct vgic_state_iter *iter;
	struct its_vm its_vm;
};

struct kvm_arch___2 {
	struct kvm_s2_mmu___2 mmu;
	struct vgic_dist___2 vgic;
	struct arch_timer_vm_data timer_data;
	u32 psci_version;
	struct mutex config_lock;
	unsigned long flags;
	unsigned long vcpu_features[1];
	struct kvm_mpidr_data *mpidr_data;
	unsigned long *pmu_filter;
	struct arm_pmu *arm_pmu;
	cpumask_var_t supported_cpus;
	u8 pmcr_n;
	struct kvm_smccc_features smccc_feat;
	struct maple_tree smccc_filter;
	u64 id_regs[56];
	struct kvm_protected_vm pkvm;
};

struct kvm_io_bus___2;

struct kvm_stat_data___2;

struct kvm___2 {
	rwlock_t mmu_lock;
	struct mutex slots_lock;
	struct mutex slots_arch_lock;
	struct mm_struct *mm;
	unsigned long nr_memslot_pages;
	struct kvm_memslots __memslots[2];
	struct kvm_memslots __attribute__((btf_type_tag("rcu"))) *memslots[1];
	struct xarray vcpu_array;
	atomic_t nr_memslots_dirty_logging;
	spinlock_t mn_invalidate_lock;
	unsigned long mn_active_invalidate_count;
	struct rcuwait mn_memslots_update_rcuwait;
	spinlock_t gpc_lock;
	struct list_head gpc_list;
	atomic_t online_vcpus;
	int max_vcpus;
	int created_vcpus;
	int last_boosted_vcpu;
	struct list_head vm_list;
	struct mutex lock;
	struct kvm_io_bus___2 __attribute__((btf_type_tag("rcu"))) *buses[4];
	struct {
		spinlock_t lock;
		struct list_head items;
		struct list_head resampler_list;
		struct mutex resampler_lock;
	} irqfds;
	struct list_head ioeventfds;
	struct kvm_vm_stat stat;
	struct kvm_arch___2 arch;
	refcount_t users_count;
	struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;
	spinlock_t ring_lock;
	struct list_head coalesced_zones;
	struct mutex irq_lock;
	struct kvm_irq_routing_table __attribute__((btf_type_tag("rcu"))) *irq_routing;
	struct hlist_head irq_ack_notifier_list;
	struct mmu_notifier mmu_notifier;
	unsigned long mmu_invalidate_seq;
	long mmu_invalidate_in_progress;
	unsigned long mmu_invalidate_range_start;
	unsigned long mmu_invalidate_range_end;
	struct list_head devices;
	u64 manual_dirty_log_protect;
	struct dentry *debugfs_dentry;
	struct kvm_stat_data___2 **debugfs_stat_data;
	struct srcu_struct srcu;
	struct srcu_struct irq_srcu;
	pid_t userspace_pid;
	bool override_halt_poll_ns;
	unsigned int max_halt_poll_ns;
	u32 dirty_ring_size;
	bool dirty_ring_with_bitmap;
	bool vm_bugged;
	bool vm_dead;
	char stats_id[48];
};

struct kvm_io_range___2 {
	gpa_t addr;
	int len;
	struct kvm_io_device___2 *dev;
};

struct kvm_io_bus___2 {
	int dev_count;
	int ioeventfd_count;
	struct kvm_io_range___2 range[0];
};

struct kvm_io_device_ops___2 {
	int (*read)(struct kvm_vcpu___2 *, struct kvm_io_device___2 *, gpa_t, int, void *);
	int (*write)(struct kvm_vcpu___2 *, struct kvm_io_device___2 *, gpa_t, int, const void *);
	void (*destructor)(struct kvm_io_device___2 *);
};

typedef kvm_pte_t *kvm_pteref_t___2;

struct kvm_pgtable___2 {
	u32 ia_bits;
	u32 start_level;
	kvm_pteref_t___2 pgd;
	struct kvm_pgtable_mm_ops *mm_ops;
	struct kvm_s2_mmu___2 *mmu;
	enum kvm_pgtable_stage2_flags flags;
	kvm_pgtable_force_pte_cb_t force_pte_cb;
};

struct kvm_device___2;

struct vgic_its___2 {
	gpa_t vgic_its_base;
	bool enabled;
	struct vgic_io_device___2 iodev;
	struct kvm_device___2 *dev;
	u64 baser_device_table;
	u64 baser_coll_table;
	struct mutex cmd_lock;
	u64 cbaser;
	u32 creadr;
	u32 cwriter;
	u32 abi_rev;
	struct mutex its_lock;
	struct list_head device_list;
	struct list_head collection_list;
};

struct kvm_device_ops___2;

struct kvm_device___2 {
	const struct kvm_device_ops___2 *ops;
	struct kvm___2 *kvm;
	void *private;
	struct list_head vm_node;
};

struct kvm_device_ops___2 {
	const char *name;
	int (*create)(struct kvm_device___2 *, u32);
	void (*init)(struct kvm_device___2 *);
	void (*destroy)(struct kvm_device___2 *);
	void (*release)(struct kvm_device___2 *);
	int (*set_attr)(struct kvm_device___2 *, struct kvm_device_attr *);
	int (*get_attr)(struct kvm_device___2 *, struct kvm_device_attr *);
	int (*has_attr)(struct kvm_device___2 *, struct kvm_device_attr *);
	long (*ioctl)(struct kvm_device___2 *, unsigned int, unsigned long);
	int (*mmap)(struct kvm_device___2 *, struct vm_area_struct *);
};

struct kvm_stat_data___2 {
	struct kvm___2 *kvm;
	const struct _kvm_stats_desc *desc;
	enum kvm_stat_kind kind;
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
	MEMBLOCK_DRIVER_MANAGED = 8,
	MEMBLOCK_RSRV_NOINIT = 16,
};

enum kvm_pgtable_walk_flags {
	KVM_PGTABLE_WALK_LEAF = 1,
	KVM_PGTABLE_WALK_TABLE_PRE = 2,
	KVM_PGTABLE_WALK_TABLE_POST = 4,
	KVM_PGTABLE_WALK_SHARED = 8,
	KVM_PGTABLE_WALK_HANDLE_FAULT = 16,
	KVM_PGTABLE_WALK_SKIP_BBM_TLBI = 32,
	KVM_PGTABLE_WALK_SKIP_CMO = 64,
};

enum pkvm_page_state {
	PKVM_PAGE_OWNED = 0ULL,
	PKVM_PAGE_SHARED_OWNED = 36028797018963968ULL,
	PKVM_PAGE_SHARED_BORROWED = 72057594037927936ULL,
	__PKVM_PAGE_RESERVED = 108086391056891904ULL,
	PKVM_NOPAGE = 108086391056891905ULL,
};

enum pkvm_component_id {
	PKVM_ID_HOST = 0,
	PKVM_ID_HYP = 1,
	PKVM_ID_FFA = 2,
};

struct kvm_host_data {
	struct kvm_cpu_context___2 host_ctxt;
};

struct kvm_nvhe_init_params {
	unsigned long mair_el2;
	unsigned long tcr_el2;
	unsigned long tpidr_el2;
	unsigned long stack_hyp_va;
	unsigned long stack_pa;
	phys_addr_t pgd_pa;
	unsigned long hcr_el2;
	unsigned long vttbr;
	unsigned long vtcr;
};

struct hyp_page {
	unsigned short refcount;
	unsigned short order;
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
	int nid;
};

struct kvm_pgtable_visit_ctx;

typedef int (*kvm_pgtable_visitor_fn_t)(const struct kvm_pgtable_visit_ctx *, enum kvm_pgtable_walk_flags);

struct kvm_pgtable_walker {
	const kvm_pgtable_visitor_fn_t cb;
	void * const arg;
	const enum kvm_pgtable_walk_flags flags;
};

struct kvm_pgtable_visit_ctx {
	kvm_pte_t *ptep;
	kvm_pte_t old;
	void *arg;
	struct kvm_pgtable_mm_ops *mm_ops;
	u64 start;
	u64 addr;
	u64 end;
	u32 level;
	enum kvm_pgtable_walk_flags flags;
};

enum reboot_mode {
	REBOOT_UNDEFINED = -1,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

struct syscall_metadata {
	const char *name;
	int syscall_nr;
	int nb_args;
	const char **types;
	const char **args;
	struct list_head enter_fields;
	struct trace_event_call *enter_event;
	struct trace_event_call *exit_event;
};

enum sys_off_mode {
	SYS_OFF_MODE_POWER_OFF_PREPARE = 0,
	SYS_OFF_MODE_POWER_OFF = 1,
	SYS_OFF_MODE_RESTART_PREPARE = 2,
	SYS_OFF_MODE_RESTART = 3,
};

struct sys_off_data;

struct sys_off_handler {
	struct notifier_block nb;
	int (*sys_off_cb)(struct sys_off_data *);
	void *cb_data;
	enum sys_off_mode mode;
	bool blocking;
	void *list;
	struct device *dev;
};

struct sys_off_data {
	int mode;
	void *cb_data;
	const char *cmd;
	struct device *dev;
};

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block __attribute__((btf_type_tag("rcu"))) *head;
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_RANDOM_START = 0,
	KMALLOC_RANDOM_END = 0,
	KMALLOC_RECLAIM = 1,
	KMALLOC_DMA = 2,
	KMALLOC_CGROUP = 3,
	NR_KMALLOC_TYPES = 4,
};

enum {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_INACTIVE_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_INACTIVE = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
	WORK_NR_COLORS = 16,
	WORK_CPU_UNBOUND = 256,
	WORK_STRUCT_FLAG_BITS = 8,
	WORK_OFFQ_FLAG_BASE = 4,
	__WORK_OFFQ_CANCELING = 4,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_POOL_SHIFT = 5,
	WORK_OFFQ_LEFT = 59,
	WORK_OFFQ_POOL_BITS = 31,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 24,
};

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	unsigned long timeout;
	bool handoff_set;
};

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct __va_list {
	void *__stack;
	void *__gr_top;
	void *__vr_top;
	int __gr_offs;
	int __vr_offs;
};

typedef __builtin_va_list va_list;

enum clocksource_ids {
	CSID_GENERIC = 0,
	CSID_ARM_ARCH_COUNTER = 1,
	CSID_MAX = 2,
};

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_ARCHTIMER = 1,
	VDSO_CLOCKMODE_ARCHTIMER_NOCOMPAT = 2,
	VDSO_CLOCKMODE_MAX = 3,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

struct clocksource {
	u64 (*read)(struct clocksource *);
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	u32 uncertainty_margin;
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	enum clocksource_ids id;
	enum vdso_clock_mode vdso_clock_mode;
	unsigned long flags;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct module *owner;
};

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

struct clock_read_data {
	u64 epoch_ns;
	u64 epoch_cyc;
	u64 sched_clock_mask;
	u64 (*read_sched_clock)();
	u32 mult;
	u32 shift;
};

struct clock_data {
	seqcount_latch_t seq;
	struct clock_read_data read_data[2];
	ktime_t wrap_kt;
	unsigned long rate;
	u64 (*actual_read_sched_clock)();
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)();
	void (*resume)();
	void (*shutdown)();
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

enum {
	FOLL_WRITE = 1,
	FOLL_GET = 2,
	FOLL_DUMP = 4,
	FOLL_FORCE = 8,
	FOLL_NOWAIT = 16,
	FOLL_NOFAULT = 32,
	FOLL_HWPOISON = 64,
	FOLL_ANON = 128,
	FOLL_LONGTERM = 256,
	FOLL_SPLIT_PMD = 512,
	FOLL_PCI_P2PDMA = 1024,
	FOLL_INTERRUPTIBLE = 2048,
	FOLL_HONOR_NUMA_FAULT = 4096,
};

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

struct rt_waiter_node {
	struct rb_node entry;
	int prio;
	u64 deadline;
};

struct rt_mutex_base;

struct ww_acquire_ctx;

struct rt_mutex_waiter {
	struct rt_waiter_node tree;
	struct rt_waiter_node pi_tree;
	struct task_struct *task;
	struct rt_mutex_base *lock;
	unsigned int wake_state;
	struct ww_acquire_ctx *ww_ctx;
};

struct rt_mutex_base {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

union futex_key {
	struct {
		u64 i_seq;
		unsigned long pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		unsigned long address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		unsigned long word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex_base pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct futex_q;

typedef void futex_wake_fn(struct wake_q_head *, struct futex_q *);

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	futex_wake_fn *wake;
	void *wake_data;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
	atomic_t requeue_state;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
};

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct uts_namespace {
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_FANOTIFY_GROUPS = 10,
	UCOUNT_FANOTIFY_MARKS = 11,
	UCOUNT_COUNTS = 12,
};

typedef unsigned int slab_flags_t;

enum audit_nfcfgop {
	AUDIT_XT_OP_REGISTER = 0,
	AUDIT_XT_OP_REPLACE = 1,
	AUDIT_XT_OP_UNREGISTER = 2,
	AUDIT_NFT_OP_TABLE_REGISTER = 3,
	AUDIT_NFT_OP_TABLE_UNREGISTER = 4,
	AUDIT_NFT_OP_CHAIN_REGISTER = 5,
	AUDIT_NFT_OP_CHAIN_UNREGISTER = 6,
	AUDIT_NFT_OP_RULE_REGISTER = 7,
	AUDIT_NFT_OP_RULE_UNREGISTER = 8,
	AUDIT_NFT_OP_SET_REGISTER = 9,
	AUDIT_NFT_OP_SET_UNREGISTER = 10,
	AUDIT_NFT_OP_SETELEM_REGISTER = 11,
	AUDIT_NFT_OP_SETELEM_UNREGISTER = 12,
	AUDIT_NFT_OP_GEN_REGISTER = 13,
	AUDIT_NFT_OP_OBJ_REGISTER = 14,
	AUDIT_NFT_OP_OBJ_UNREGISTER = 15,
	AUDIT_NFT_OP_OBJ_RESET = 16,
	AUDIT_NFT_OP_FLOWTABLE_REGISTER = 17,
	AUDIT_NFT_OP_FLOWTABLE_UNREGISTER = 18,
	AUDIT_NFT_OP_SETELEM_RESET = 19,
	AUDIT_NFT_OP_RULE_RESET = 20,
	AUDIT_NFT_OP_INVALID = 21,
};

struct audit_nfcfgop_tab {
	enum audit_nfcfgop op;
	const char *s;
};

typedef int __kernel_mqd_t;

typedef __kernel_mqd_t mqd_t;

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct audit_cap_data {
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	union {
		unsigned int fE;
		kernel_cap_t effective;
	};
	kernel_cap_t ambient;
	kuid_t rootid;
};

struct audit_ntp_val {
	long long oldval;
	long long newval;
};

struct audit_ntp_data {
	struct audit_ntp_val vals[6];
};

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

enum audit_state {
	AUDIT_STATE_DISABLED = 0,
	AUDIT_STATE_BUILD = 1,
	AUDIT_STATE_RECORD = 2,
};

struct filename;

struct audit_names {
	struct list_head list;
	struct filename *name;
	int name_len;
	bool hidden;
	unsigned long ino;
	dev_t dev;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	u32 osid;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	unsigned char type;
	bool should_free;
};

struct audit_proctitle {
	int len;
	char *value;
};

struct audit_aux_data;

struct __kernel_sockaddr_storage;

struct audit_tree_refs;

struct audit_context {
	int dummy;
	enum {
		AUDIT_CTX_UNUSED = 0,
		AUDIT_CTX_SYSCALL = 1,
		AUDIT_CTX_URING = 2,
	} context;
	enum audit_state state;
	enum audit_state current_state;
	unsigned int serial;
	int major;
	int uring_op;
	struct timespec64 ctime;
	unsigned long argv[4];
	long return_code;
	u64 prio;
	int return_valid;
	struct audit_names preallocated_names[5];
	int name_count;
	struct list_head names_list;
	char *filterkey;
	struct path pwd;
	struct audit_aux_data *aux;
	struct audit_aux_data *aux_pids;
	struct __kernel_sockaddr_storage *sockaddr;
	size_t sockaddr_len;
	pid_t ppid;
	kuid_t uid;
	kuid_t euid;
	kuid_t suid;
	kuid_t fsuid;
	kgid_t gid;
	kgid_t egid;
	kgid_t sgid;
	kgid_t fsgid;
	unsigned long personality;
	int arch;
	pid_t target_pid;
	kuid_t target_auid;
	kuid_t target_uid;
	unsigned int target_sessionid;
	u32 target_sid;
	char target_comm[16];
	struct audit_tree_refs *trees;
	struct audit_tree_refs *first_trees;
	struct list_head killed_trees;
	int tree_count;
	int type;
	union {
		struct {
			int nargs;
			long args[6];
		} socketcall;
		struct {
			kuid_t uid;
			kgid_t gid;
			umode_t mode;
			u32 osid;
			int has_perm;
			uid_t perm_uid;
			gid_t perm_gid;
			umode_t perm_mode;
			unsigned long qbytes;
		} ipc;
		struct {
			mqd_t mqdes;
			struct mq_attr mqstat;
		} mq_getsetattr;
		struct {
			mqd_t mqdes;
			int sigev_signo;
		} mq_notify;
		struct {
			mqd_t mqdes;
			size_t msg_len;
			unsigned int msg_prio;
			struct timespec64 abs_timeout;
		} mq_sendrecv;
		struct {
			int oflag;
			umode_t mode;
			struct mq_attr attr;
		} mq_open;
		struct {
			pid_t pid;
			struct audit_cap_data cap;
		} capset;
		struct {
			int fd;
			int flags;
		} mmap;
		struct open_how openat2;
		struct {
			int argc;
		} execve;
		struct {
			char *name;
		} module;
		struct {
			struct audit_ntp_data ntp_data;
			struct timespec64 tk_injoffset;
		} time;
	};
	int fds[2];
	struct audit_proctitle proctitle;
};

struct filename {
	const char *name;
	const char __attribute__((btf_type_tag("user"))) *uptr;
	atomic_t refcnt;
	struct audit_names *aname;
	const char iname[0];
};

struct linux_binprm;

struct coredump_params;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	unsigned long min_coredump;
};

struct linux_binprm {
	struct vm_area_struct *vma;
	unsigned long vma_pages;
	struct mm_struct *mm;
	unsigned long p;
	unsigned long argmin;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	unsigned long loader;
	unsigned long exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

typedef unsigned int tcflag_t;

typedef unsigned char cc_t;

typedef unsigned int speed_t;

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct winsize {
	unsigned short ws_row;
	unsigned short ws_col;
	unsigned short ws_xpixel;
	unsigned short ws_ypixel;
};

struct tty_driver;

struct tty_port;

struct tty_operations;

struct tty_ldisc;

struct tty_struct {
	struct kref kref;
	int index;
	struct device *dev;
	struct tty_driver *driver;
	struct tty_port *port;
	const struct tty_operations *ops;
	struct tty_ldisc *ldisc;
	struct ld_semaphore ldisc_sem;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	struct ktermios termios;
	struct ktermios termios_locked;
	char name[64];
	unsigned long flags;
	int count;
	unsigned int receive_room;
	struct winsize winsize;
	struct {
		spinlock_t lock;
		bool stopped;
		bool tco_stopped;
		unsigned long unused[0];
	} flow;
	struct {
		struct pid *pgrp;
		struct pid *session;
		spinlock_t lock;
		unsigned char pktstatus;
		bool packet;
		unsigned long unused[0];
	} ctrl;
	bool hw_stopped;
	bool closing;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	int write_cnt;
	unsigned char *write_buf;
	struct list_head tty_files;
	struct work_struct SAK_work;
};

struct tty_driver {
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short type;
	short subtype;
	struct ktermios init_termios;
	unsigned long flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	unsigned int used;
	unsigned int size;
	unsigned int commit;
	unsigned int lookahead;
	unsigned int read;
	bool flags;
	long: 0;
	u8 data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	unsigned long flags;
	unsigned long iflags;
	unsigned char console: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	unsigned char *xmit_buf;
	struct {
		union {
			struct __kfifo kfifo;
			unsigned char *type;
			const unsigned char *const_type;
			char (*rectype)[0];
			unsigned char *ptr;
			const unsigned char *ptr_const;
		};
		unsigned char buf[0];
	} xmit_fifo;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct tty_port_operations {
	bool (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, bool);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_port_client_operations {
	size_t (*receive_buf)(struct tty_port *, const u8 *, const u8 *, size_t);
	void (*lookahead_buf)(struct tty_port *, const u8 *, const u8 *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

struct serial_icounter_struct;

struct serial_struct;

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	ssize_t (*write)(struct tty_struct *, const u8 *, size_t);
	int (*put_char)(struct tty_struct *, u8);
	void (*flush_chars)(struct tty_struct *);
	unsigned int (*write_room)(struct tty_struct *);
	unsigned int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, unsigned long);
	long (*compat_ioctl)(struct tty_struct *, unsigned int, unsigned long);
	void (*set_termios)(struct tty_struct *, const struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, char);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct tty_ldisc_ops;

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_ldisc_ops {
	char *name;
	int num;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, u8 *, size_t, void **, unsigned long);
	ssize_t (*write)(struct tty_struct *, struct file *, const u8 *, size_t);
	int (*ioctl)(struct tty_struct *, unsigned int, unsigned long);
	int (*compat_ioctl)(struct tty_struct *, unsigned int, unsigned long);
	void (*set_termios)(struct tty_struct *, const struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	void (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const u8 *, const u8 *, size_t);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, bool);
	size_t (*receive_buf2)(struct tty_struct *, const u8 *, const u8 *, size_t);
	void (*lookahead_buf)(struct tty_struct *, const u8 *, const u8 *, size_t);
	struct module *owner;
};

struct audit_aux_data {
	struct audit_aux_data *next;
	int type;
};

typedef unsigned short __kernel_sa_family_t;

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

struct audit_chunk;

struct audit_tree_refs {
	struct audit_tree_refs *next;
	struct audit_chunk *c[31];
};

enum {
	TASK_COMM_LEN = 16,
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

enum {
	Audit_equal = 0,
	Audit_not_equal = 1,
	Audit_bitmask = 2,
	Audit_bittest = 3,
	Audit_lt = 4,
	Audit_gt = 5,
	Audit_le = 6,
	Audit_ge = 7,
	Audit_bad = 8,
};

enum auditsc_class_t {
	AUDITSC_NATIVE = 0,
	AUDITSC_COMPAT = 1,
	AUDITSC_OPEN = 2,
	AUDITSC_OPENAT = 3,
	AUDITSC_SOCKETCALL = 4,
	AUDITSC_EXECVE = 5,
	AUDITSC_OPENAT2 = 6,
	AUDITSC_NVALS = 7,
};

struct audit_field;

struct audit_watch;

struct audit_tree;

struct audit_fsnotify_mark;

struct audit_krule {
	u32 pflags;
	u32 flags;
	u32 listnr;
	u32 action;
	u32 mask[64];
	u32 buflen;
	u32 field_count;
	char *filterkey;
	struct audit_field *fields;
	struct audit_field *arch_f;
	struct audit_field *inode_f;
	struct audit_watch *watch;
	struct audit_tree *tree;
	struct audit_fsnotify_mark *exe;
	struct list_head rlist;
	struct list_head list;
	u64 prio;
};

struct audit_entry {
	struct list_head list;
	struct callback_head rcu;
	struct audit_krule rule;
};

struct audit_field {
	u32 type;
	union {
		u32 val;
		kuid_t uid;
		kgid_t gid;
		struct {
			char *lsm_str;
			void *lsm_rule;
		};
	};
	u32 op;
};

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kuid_t rootid;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
};

typedef int __kernel_key_t;

typedef __kernel_key_t key_t;

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	unsigned long seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct audit_aux_data_bprm_fcaps {
	struct audit_aux_data d;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	struct audit_cap_data old_pcap;
	struct audit_cap_data new_pcap;
};

struct audit_aux_data_pids {
	struct audit_aux_data d;
	pid_t target_pid[16];
	kuid_t target_auid[16];
	kuid_t target_uid[16];
	unsigned int target_sessionid[16];
	u32 target_sid[16];
	char target_comm[256];
	int pid_count;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[12];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

struct fanotify_response_info_header {
	__u8 type;
	__u8 pad;
	__u16 len;
};

struct fanotify_response_info_audit_rule {
	struct fanotify_response_info_header hdr;
	__u32 rule_number;
	__u32 subj_trust;
	__u32 obj_trust;
};

struct trace_buffer;

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu __attribute__((btf_type_tag("percpu"))) *data;
	u64 time_start;
	int cpu;
};

struct trace_pid_list;

struct trace_event_file;

struct eventfs_inode;

struct trace_options;

struct trace_func_repeats;

struct trace_array {
	struct list_head list;
	char *name;
	struct array_buffer array_buffer;
	struct trace_pid_list __attribute__((btf_type_tag("rcu"))) *filtered_pids;
	struct trace_pid_list __attribute__((btf_type_tag("rcu"))) *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int sys_refcount_enter;
	int sys_refcount_exit;
	struct trace_event_file __attribute__((btf_type_tag("rcu"))) *enter_syscall_files[457];
	struct trace_event_file __attribute__((btf_type_tag("rcu"))) *exit_syscall_files[457];
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct eventfs_inode *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	cpumask_var_t pipe_cpumask;
	int ref;
	int trace_ref;
	struct ftrace_ops *ops;
	struct trace_pid_list __attribute__((btf_type_tag("rcu"))) *function_pids;
	struct trace_pid_list __attribute__((btf_type_tag("rcu"))) *function_no_pids;
	struct list_head func_probes;
	struct list_head mod_trace;
	struct list_head mod_notrace;
	int function_enabled;
	int no_filter_buffering_ref;
	struct list_head hist_vars;
	struct trace_func_repeats __attribute__((btf_type_tag("percpu"))) *last_func_repeats;
	bool ring_buffer_expanded;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	unsigned long entries;
	unsigned long saved_latency;
	unsigned long critical_start;
	unsigned long critical_end;
	unsigned long critical_sequence;
	unsigned long nice;
	unsigned long policy;
	unsigned long rt_priority;
	unsigned long skipped_entries;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	int ftrace_ignore_pid;
	bool ignore_pid;
};

union upper_chunk;

union lower_chunk;

struct trace_pid_list {
	raw_spinlock_t lock;
	struct irq_work refill_irqwork;
	union upper_chunk *upper[256];
	union upper_chunk *upper_list;
	union lower_chunk *lower_list;
	int free_upper_chunks;
	int free_lower_chunks;
};

struct prog_entry;

struct event_filter {
	struct prog_entry __attribute__((btf_type_tag("rcu"))) *prog;
	char *filter_string;
};

struct filter_pred;

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

union upper_chunk {
	union upper_chunk *next;
	union lower_chunk *data[256];
};

union lower_chunk {
	union lower_chunk *next;
	unsigned long data[256];
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter __attribute__((btf_type_tag("rcu"))) *filter;
	struct eventfs_inode *ei;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	unsigned long flags;
	atomic_t ref;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

struct event_subsystem;

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct eventfs_inode *ei;
	int ref_count;
	int nr_events;
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

struct tracer_flags;

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool noboot;
};

struct tracer_opt;

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

struct trace_option_dentry;

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

struct trace_func_repeats {
	unsigned long ip;
	unsigned long parent_ip;
	unsigned long count;
	u64 ts_last_call;
};

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_FIELDS = 256,
	TRACE_ITER_PRINTK = 512,
	TRACE_ITER_ANNOTATE = 1024,
	TRACE_ITER_USERSTACKTRACE = 2048,
	TRACE_ITER_SYM_USEROBJ = 4096,
	TRACE_ITER_PRINTK_MSGONLY = 8192,
	TRACE_ITER_CONTEXT_INFO = 16384,
	TRACE_ITER_LATENCY_FMT = 32768,
	TRACE_ITER_RECORD_CMD = 65536,
	TRACE_ITER_RECORD_TGID = 131072,
	TRACE_ITER_OVERWRITE = 262144,
	TRACE_ITER_STOP_ON_FREE = 524288,
	TRACE_ITER_IRQ_INFO = 1048576,
	TRACE_ITER_MARKERS = 2097152,
	TRACE_ITER_EVENT_FORK = 4194304,
	TRACE_ITER_PAUSE_ON_TRACE = 8388608,
	TRACE_ITER_HASH_PTR = 16777216,
	TRACE_ITER_FUNCTION = 33554432,
	TRACE_ITER_FUNC_FORK = 67108864,
	TRACE_ITER_DISPLAY_GRAPH = 134217728,
	TRACE_ITER_STACKTRACE = 268435456,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_RDYN_STRING = 3,
	FILTER_PTR_STRING = 4,
	FILTER_TRACE_FN = 5,
	FILTER_CPUMASK = 6,
	FILTER_COMM = 7,
	FILTER_CPU = 8,
	FILTER_STACKTRACE = 9,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
	EVENT_FILE_FL_FREED = 2048,
};

struct syscall_trace_enter {
	struct trace_entry ent;
	int nr;
	unsigned long args[0];
};

struct syscall_trace_exit {
	struct trace_entry ent;
	int nr;
	long ret;
};

struct ring_buffer_event;

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	unsigned int trace_ctx;
	struct pt_regs *regs;
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct syscall_tp_t {
	struct trace_entry ent;
	int syscall_nr;
	unsigned long args[6];
};

struct syscall_tp_t___2 {
	struct trace_entry ent;
	int syscall_nr;
	unsigned long ret;
};

struct tnum {
	u64 value;
	u64 mask;
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct pcpu_freelist {
	struct pcpu_freelist_head __attribute__((btf_type_tag("percpu"))) *freelist;
	struct pcpu_freelist_head extralist;
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	raw_spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist __attribute__((btf_type_tag("percpu"))) *local_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list __attribute__((btf_type_tag("percpu"))) *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_array_aux;

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		struct {
			struct {} __empty_value;
			char value[0];
		};
		struct {
			struct {} __empty_ptrs;
			void *ptrs[0];
		};
		struct {
			struct {} __empty_pptrs;
			void __attribute__((btf_type_tag("percpu"))) *pptrs[0];
		};
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_array_aux {
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct fd {
	struct file *file;
	unsigned int flags;
};

struct ref_tracker_dir {};

struct raw_notifier_head {
	struct notifier_block __attribute__((btf_type_tag("rcu"))) *head;
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	u8 sysctl_txrehash;
	struct prot_inuse __attribute__((btf_type_tag("percpu"))) *prot_inuse;
	struct cpumask *rps_default_mask;
};

struct ipstats_mib;

struct tcp_mib;

struct linux_mib;

struct udp_mib;

struct icmp_mib;

struct icmpmsg_mib;

struct icmpv6_mib;

struct icmpv6msg_mib;

struct netns_mib {
	struct ipstats_mib __attribute__((btf_type_tag("percpu"))) *ip_statistics;
	struct ipstats_mib __attribute__((btf_type_tag("percpu"))) *ipv6_statistics;
	struct tcp_mib __attribute__((btf_type_tag("percpu"))) *tcp_statistics;
	struct linux_mib __attribute__((btf_type_tag("percpu"))) *net_statistics;
	struct udp_mib __attribute__((btf_type_tag("percpu"))) *udp_statistics;
	struct udp_mib __attribute__((btf_type_tag("percpu"))) *udp_stats_in6;
	struct udp_mib __attribute__((btf_type_tag("percpu"))) *udplite_statistics;
	struct udp_mib __attribute__((btf_type_tag("percpu"))) *udplite_stats_in6;
	struct icmp_mib __attribute__((btf_type_tag("percpu"))) *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct icmpv6_mib __attribute__((btf_type_tag("percpu"))) *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct unix_table {
	spinlock_t *locks;
	struct hlist_head *buckets;
};

struct netns_unix {
	struct unix_table table;
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct inet_hashinfo;

struct inet_timewait_death_row {
	refcount_t tw_refcount;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct local_ports {
	seqlock_t lock;
	int range[2];
	bool warned;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

typedef struct {
	u64 key[2];
} siphash_key_t;

struct udp_table;

struct ipv4_devconf;

struct ip_ra_chain;

struct inet_peer_base;

struct fqdir;

struct tcp_congestion_ops;

struct tcp_fastopen_context;

struct fib_notifier_ops;

struct netns_ipv4 {
	struct inet_timewait_death_row tcp_death_row;
	struct udp_table *udp_table;
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain __attribute__((btf_type_tag("rcu"))) *ra_chain;
	struct mutex ra_mutex;
	bool fib_has_custom_local_routes;
	bool fib_offload_disabled;
	u8 sysctl_tcp_shrink_window;
	struct hlist_head *fib_table_hash;
	struct sock *fibnl;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	u8 sysctl_icmp_echo_ignore_all;
	u8 sysctl_icmp_echo_enable_probe;
	u8 sysctl_icmp_echo_ignore_broadcasts;
	u8 sysctl_icmp_ignore_bogus_error_responses;
	u8 sysctl_icmp_errors_use_inbound_ifaddr;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	u32 ip_rt_min_pmtu;
	int ip_rt_mtu_expires;
	int ip_rt_min_advmss;
	struct local_ports ip_local_ports;
	u8 sysctl_tcp_ecn;
	u8 sysctl_tcp_ecn_fallback;
	u8 sysctl_ip_default_ttl;
	u8 sysctl_ip_no_pmtu_disc;
	u8 sysctl_ip_fwd_use_pmtu;
	u8 sysctl_ip_fwd_update_priority;
	u8 sysctl_ip_nonlocal_bind;
	u8 sysctl_ip_autobind_reuse;
	u8 sysctl_ip_dynaddr;
	u8 sysctl_ip_early_demux;
	u8 sysctl_tcp_early_demux;
	u8 sysctl_udp_early_demux;
	u8 sysctl_nexthop_compat_mode;
	u8 sysctl_fwmark_reflect;
	u8 sysctl_tcp_fwmark_accept;
	u8 sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_intvl;
	u8 sysctl_tcp_keepalive_probes;
	u8 sysctl_tcp_syn_retries;
	u8 sysctl_tcp_synack_retries;
	u8 sysctl_tcp_syncookies;
	u8 sysctl_tcp_migrate_req;
	u8 sysctl_tcp_comp_sack_nr;
	u8 sysctl_tcp_backlog_ack_defer;
	u8 sysctl_tcp_pingpong_thresh;
	int sysctl_tcp_reordering;
	u8 sysctl_tcp_retries1;
	u8 sysctl_tcp_retries2;
	u8 sysctl_tcp_orphan_retries;
	u8 sysctl_tcp_tw_reuse;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	u8 sysctl_tcp_sack;
	u8 sysctl_tcp_window_scaling;
	u8 sysctl_tcp_timestamps;
	u8 sysctl_tcp_early_retrans;
	u8 sysctl_tcp_recovery;
	u8 sysctl_tcp_thin_linear_timeouts;
	u8 sysctl_tcp_slow_start_after_idle;
	u8 sysctl_tcp_retrans_collapse;
	u8 sysctl_tcp_stdurg;
	u8 sysctl_tcp_rfc1337;
	u8 sysctl_tcp_abort_on_overflow;
	u8 sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_adv_win_scale;
	u8 sysctl_tcp_dsack;
	u8 sysctl_tcp_app_win;
	u8 sysctl_tcp_frto;
	u8 sysctl_tcp_nometrics_save;
	u8 sysctl_tcp_no_ssthresh_metrics_save;
	u8 sysctl_tcp_moderate_rcvbuf;
	u8 sysctl_tcp_tso_win_divisor;
	u8 sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_rtt_wlen;
	u8 sysctl_tcp_min_tso_segs;
	u8 sysctl_tcp_tso_rtt_log;
	u8 sysctl_tcp_autocorking;
	u8 sysctl_tcp_reflect_tos;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	unsigned int sysctl_tcp_child_ehash_entries;
	unsigned long sysctl_tcp_comp_sack_delay_ns;
	unsigned long sysctl_tcp_comp_sack_slack_ns;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops __attribute__((btf_type_tag("rcu"))) *tcp_congestion_control;
	struct tcp_fastopen_context __attribute__((btf_type_tag("rcu"))) *tcp_fastopen_ctx;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	unsigned long tfo_active_disable_stamp;
	u32 tcp_challenge_timestamp;
	u32 tcp_challenge_count;
	u8 sysctl_tcp_plb_enabled;
	u8 sysctl_tcp_plb_idle_rehash_rounds;
	u8 sysctl_tcp_plb_rehash_rounds;
	u8 sysctl_tcp_plb_suspend_rto_sec;
	int sysctl_tcp_plb_cong_thresh;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	u8 sysctl_fib_notify_on_flag_change;
	u8 sysctl_tcp_syn_linear_timeouts;
	u8 sysctl_igmp_llm_reports;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	unsigned int sysctl_udp_child_hash_entries;
	unsigned long *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dst_entry;

struct sk_buff;

struct neighbour;

struct dst_ops {
	unsigned short family;
	unsigned int gc_thresh;
	void (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, unsigned long);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	struct percpu_counter pcpuc_entries;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	u32 multipath_hash_fields;
	u8 multipath_hash_policy;
	u8 bindv6only;
	u8 flowlabel_consistency;
	u8 auto_flowlabels;
	int icmpv6_time;
	u8 icmpv6_echo_ignore_all;
	u8 icmpv6_echo_ignore_multicast;
	u8 icmpv6_echo_ignore_anycast;
	unsigned long icmpv6_ratemask[4];
	unsigned long *icmpv6_ratemask_ptr;
	u8 anycast_src_echo_reply;
	u8 ip_nonlocal_bind;
	u8 fwmark_reflect;
	u8 flowlabel_state_ranges;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	u32 ioam6_id;
	u64 ioam6_id_wide;
	u8 skip_notify_on_dev_down;
	u8 fib_notify_on_flag_change;
	u8 icmpv6_error_anycast_as_unicast;
};

struct ioam6_pernet_data;

struct ipv6_devconf;

struct fib6_info;

struct rt6_info;

struct rt6_statistics;

struct fib6_table;

struct fib_rules_ops;

struct seg6_pernet_data;

struct netns_ipv6 {
	struct dst_ops ip6_dst_ops;
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	atomic_t ip6_rt_gc_expire;
	unsigned long ip6_rt_last_gc;
	unsigned char flowlabel_has_excl;
	bool fib6_has_custom_rules;
	unsigned int fib6_rules_require_fldissect;
	unsigned int fib6_routes_require_src;
	struct rt6_info *ip6_prohibit_entry;
	struct rt6_info *ip6_blk_hole_entry;
	struct fib6_table *fib6_local_tbl;
	struct fib_rules_ops *fib6_rules_ops;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	struct hlist_head *inet6_addr_lst;
	spinlock_t addrconf_hash_lock;
	struct delayed_work addr_chk_work;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	struct ioam6_pernet_data *ioam6_data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nf_logger;

struct nf_hook_entries;

struct netns_nf {
	struct proc_dir_entry *proc_netfilter;
	const struct nf_logger __attribute__((btf_type_tag("rcu"))) *nf_loggers[11];
	struct ctl_table_header *nf_log_dir_header;
	struct nf_hook_entries __attribute__((btf_type_tag("rcu"))) *hooks_ipv4[5];
	struct nf_hook_entries __attribute__((btf_type_tag("rcu"))) *hooks_ipv6[5];
	struct nf_hook_entries __attribute__((btf_type_tag("rcu"))) *hooks_bridge[5];
	unsigned int defrag_ipv4_users;
	unsigned int defrag_ipv6_users;
};

struct nf_generic_net {
	unsigned int timeout;
};

struct nf_tcp_net {
	unsigned int timeouts[14];
	u8 tcp_loose;
	u8 tcp_be_liberal;
	u8 tcp_max_retrans;
	u8 tcp_ignore_invalid_rst;
};

struct nf_udp_net {
	unsigned int timeouts[2];
};

struct nf_icmp_net {
	unsigned int timeout;
};

struct nf_dccp_net {
	u8 dccp_loose;
	unsigned int dccp_timeout[10];
};

struct nf_sctp_net {
	unsigned int timeouts[10];
};

struct nf_ip_net {
	struct nf_generic_net generic;
	struct nf_tcp_net tcp;
	struct nf_udp_net udp;
	struct nf_icmp_net icmp;
	struct nf_icmp_net icmpv6;
	struct nf_dccp_net dccp;
	struct nf_sctp_net sctp;
};

struct ip_conntrack_stat;

struct nf_ct_event_notifier;

struct netns_ct {
	bool ecache_dwork_pending;
	u8 sysctl_log_invalid;
	u8 sysctl_events;
	u8 sysctl_acct;
	u8 sysctl_tstamp;
	u8 sysctl_checksum;
	struct ip_conntrack_stat __attribute__((btf_type_tag("percpu"))) *stat;
	struct nf_ct_event_notifier __attribute__((btf_type_tag("rcu"))) *nf_conntrack_event_cb;
	struct nf_ip_net nf_ct_proto;
};

struct netns_bpf {
	struct bpf_prog_array __attribute__((btf_type_tag("rcu"))) *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct netns_ipvs;

struct can_dev_rcv_lists;

struct can_pkg_stats;

struct can_rcv_lists_stats;

struct netns_can {
	struct proc_dir_entry *proc_dir;
	struct proc_dir_entry *pde_stats;
	struct proc_dir_entry *pde_reset_stats;
	struct proc_dir_entry *pde_rcvlist_all;
	struct proc_dir_entry *pde_rcvlist_fil;
	struct proc_dir_entry *pde_rcvlist_inv;
	struct proc_dir_entry *pde_rcvlist_sff;
	struct proc_dir_entry *pde_rcvlist_eff;
	struct proc_dir_entry *pde_rcvlist_err;
	struct proc_dir_entry *bcmproc_dir;
	struct can_dev_rcv_lists *rx_alldev_list;
	spinlock_t rcvlists_lock;
	struct timer_list stattimer;
	struct can_pkg_stats *pkg_stats;
	struct can_rcv_lists_stats *rcv_lists_stats;
	struct hlist_head cgw_list;
};

struct netns_xdp {
	struct mutex lock;
	struct hlist_head list;
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	spinlock_t rules_mod_lock;
	atomic_t dev_unreg_count;
	unsigned int dev_base_seq;
	u32 ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct ref_tracker_dir refcnt_tracker;
	struct ref_tracker_dir notrefcnt_tracker;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct xarray dev_by_index;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct netns_nf nf;
	struct netns_ct ct;
	struct net_generic __attribute__((btf_type_tag("rcu"))) *gen;
	struct netns_bpf bpf;
	u64 net_cookie;
	struct netns_ipvs *ipvs;
	struct netns_can can;
	struct netns_xdp xdp;
	struct sock *crypto_nlsk;
	struct sock *diag_nlsk;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef u32 xdp_features_t;

typedef u64 netdev_features_t;

struct net_device_stats {
	union {
		unsigned long rx_packets;
		atomic_long_t __rx_packets;
	};
	union {
		unsigned long tx_packets;
		atomic_long_t __tx_packets;
	};
	union {
		unsigned long rx_bytes;
		atomic_long_t __rx_bytes;
	};
	union {
		unsigned long tx_bytes;
		atomic_long_t __tx_bytes;
	};
	union {
		unsigned long rx_errors;
		atomic_long_t __rx_errors;
	};
	union {
		unsigned long tx_errors;
		atomic_long_t __tx_errors;
	};
	union {
		unsigned long rx_dropped;
		atomic_long_t __rx_dropped;
	};
	union {
		unsigned long tx_dropped;
		atomic_long_t __tx_dropped;
	};
	union {
		unsigned long multicast;
		atomic_long_t __multicast;
	};
	union {
		unsigned long collisions;
		atomic_long_t __collisions;
	};
	union {
		unsigned long rx_length_errors;
		atomic_long_t __rx_length_errors;
	};
	union {
		unsigned long rx_over_errors;
		atomic_long_t __rx_over_errors;
	};
	union {
		unsigned long rx_crc_errors;
		atomic_long_t __rx_crc_errors;
	};
	union {
		unsigned long rx_frame_errors;
		atomic_long_t __rx_frame_errors;
	};
	union {
		unsigned long rx_fifo_errors;
		atomic_long_t __rx_fifo_errors;
	};
	union {
		unsigned long rx_missed_errors;
		atomic_long_t __rx_missed_errors;
	};
	union {
		unsigned long tx_aborted_errors;
		atomic_long_t __tx_aborted_errors;
	};
	union {
		unsigned long tx_carrier_errors;
		atomic_long_t __tx_carrier_errors;
	};
	union {
		unsigned long tx_fifo_errors;
		atomic_long_t __tx_fifo_errors;
	};
	union {
		unsigned long tx_heartbeat_errors;
		atomic_long_t __tx_heartbeat_errors;
	};
	union {
		unsigned long tx_window_errors;
		atomic_long_t __tx_window_errors;
	};
	union {
		unsigned long rx_compressed;
		atomic_long_t __rx_compressed;
	};
	union {
		unsigned long tx_compressed;
		atomic_long_t __tx_compressed;
	};
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
	struct rb_root tree;
};

struct wireless_dev;

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

typedef struct {
	struct net __attribute__((btf_type_tag("rcu"))) *net;
} possible_net_t;

enum netdev_ml_priv_type {
	ML_PRIV_NONE = 0,
	ML_PRIV_CAN = 1,
};

enum netdev_stat_type {
	NETDEV_PCPU_STAT_NONE = 0,
	NETDEV_PCPU_STAT_LSTATS = 1,
	NETDEV_PCPU_STAT_TSTATS = 2,
	NETDEV_PCPU_STAT_DSTATS = 3,
};

struct garp_port;

struct mrp_port;

typedef __s16 s16;

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

struct sfp_bus;

struct udp_tunnel_nic;

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

typedef struct {} netdevice_tracker;

struct netdev_name_node;

struct dev_ifalias;

struct net_device_ops;

struct xdp_metadata_ops;

struct net_device_core_stats;

struct ethtool_ops;

struct ndisc_ops;

struct header_ops;

struct in_device;

struct inet6_dev;

struct vlan_info;

struct dsa_port;

struct netdev_rx_queue;

struct bpf_mprog_entry;

struct netdev_queue;

struct cpu_rmap;

struct Qdisc;

struct xdp_dev_bulk_queue;

struct xps_dev_maps;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct pcpu_dstats;

struct rtnl_link_ops;

struct netprio_map;

struct phy_device;

struct udp_tunnel_nic_info;

struct rtnl_hw_stats64;

struct devlink_port;

struct net_device {
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias __attribute__((btf_type_tag("rcu"))) *ifalias;
	unsigned long mem_end;
	unsigned long mem_start;
	unsigned long base_addr;
	unsigned long state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	unsigned int flags;
	xdp_features_t xdp_features;
	unsigned long long priv_flags;
	const struct net_device_ops *netdev_ops;
	const struct xdp_metadata_ops *xdp_metadata_ops;
	int ifindex;
	unsigned short gflags;
	unsigned short hard_header_len;
	unsigned int mtu;
	unsigned short needed_headroom;
	unsigned short needed_tailroom;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	unsigned int min_mtu;
	unsigned int max_mtu;
	unsigned short type;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	int group;
	struct net_device_stats stats;
	struct net_device_core_stats __attribute__((btf_type_tag("percpu"))) *core_stats;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct ethtool_ops *ethtool_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct header_ops *header_ops;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	unsigned short neigh_priv_len;
	unsigned short dev_id;
	unsigned short dev_port;
	unsigned short padded;
	spinlock_t addr_list_lock;
	int irq;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct in_device __attribute__((btf_type_tag("rcu"))) *ip_ptr;
	struct inet6_dev __attribute__((btf_type_tag("rcu"))) *ip6_ptr;
	struct vlan_info __attribute__((btf_type_tag("rcu"))) *vlan_info;
	struct dsa_port *dsa_ptr;
	struct wireless_dev *ieee80211_ptr;
	const unsigned char *dev_addr;
	struct netdev_rx_queue *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog __attribute__((btf_type_tag("rcu"))) *xdp_prog;
	unsigned long gro_flush_timeout;
	int napi_defer_hard_irqs;
	unsigned int gro_max_size;
	unsigned int gro_ipv4_max_size;
	unsigned int xdp_zc_max_segs;
	rx_handler_func_t __attribute__((btf_type_tag("rcu"))) *rx_handler;
	void __attribute__((btf_type_tag("rcu"))) *rx_handler_data;
	struct bpf_mprog_entry __attribute__((btf_type_tag("rcu"))) *tcx_ingress;
	struct netdev_queue __attribute__((btf_type_tag("rcu"))) *ingress_queue;
	struct nf_hook_entries __attribute__((btf_type_tag("rcu"))) *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct netdev_queue *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc __attribute__((btf_type_tag("rcu"))) *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue __attribute__((btf_type_tag("percpu"))) *xdp_bulkq;
	struct xps_dev_maps __attribute__((btf_type_tag("rcu"))) *xps_maps[2];
	struct bpf_mprog_entry __attribute__((btf_type_tag("rcu"))) *tcx_egress;
	struct nf_hook_entries __attribute__((btf_type_tag("rcu"))) *nf_hooks_egress;
	struct hlist_head qdisc_hash[16];
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	int __attribute__((btf_type_tag("percpu"))) *pcpu_refcnt;
	struct ref_tracker_dir refcnt_tracker;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED = 0,
		NETREG_REGISTERED = 1,
		NETREG_UNREGISTERING = 2,
		NETREG_UNREGISTERED = 3,
		NETREG_RELEASED = 4,
		NETREG_DUMMY = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	possible_net_t nd_net;
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	enum netdev_stat_type pcpu_stat_type: 8;
	union {
		struct pcpu_lstats __attribute__((btf_type_tag("percpu"))) *lstats;
		struct pcpu_sw_netstats __attribute__((btf_type_tag("percpu"))) *tstats;
		struct pcpu_dstats __attribute__((btf_type_tag("percpu"))) *dstats;
	};
	struct garp_port __attribute__((btf_type_tag("rcu"))) *garp_port;
	struct mrp_port __attribute__((btf_type_tag("rcu"))) *mrp_port;
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	unsigned int gso_max_size;
	unsigned int tso_max_size;
	u16 gso_max_segs;
	u16 tso_max_segs;
	unsigned int gso_ipv4_max_size;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	struct netprio_map __attribute__((btf_type_tag("rcu"))) *priomap;
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	bool proto_down;
	unsigned int wol_enabled: 1;
	unsigned int threaded: 1;
	struct list_head net_notifier_list;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct bpf_xdp_entity xdp_state[3];
	u8 dev_addr_shadow[32];
	netdevice_tracker linkwatch_dev_tracker;
	netdevice_tracker watchdog_dev_tracker;
	netdevice_tracker dev_registered_tracker;
	struct rtnl_hw_stats64 *offload_xstats_l3;
	struct devlink_port *devlink_port;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

enum netdev_tx {
	__NETDEV_TX_MIN = -2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

typedef __u16 __be16;

enum tc_setup_type {
	TC_QUERY_CAPS = 0,
	TC_SETUP_QDISC_MQPRIO = 1,
	TC_SETUP_CLSU32 = 2,
	TC_SETUP_CLSFLOWER = 3,
	TC_SETUP_CLSMATCHALL = 4,
	TC_SETUP_CLSBPF = 5,
	TC_SETUP_BLOCK = 6,
	TC_SETUP_QDISC_CBS = 7,
	TC_SETUP_QDISC_RED = 8,
	TC_SETUP_QDISC_PRIO = 9,
	TC_SETUP_QDISC_MQ = 10,
	TC_SETUP_QDISC_ETF = 11,
	TC_SETUP_ROOT_QDISC = 12,
	TC_SETUP_QDISC_GRED = 13,
	TC_SETUP_QDISC_TAPRIO = 14,
	TC_SETUP_FT = 15,
	TC_SETUP_QDISC_ETS = 16,
	TC_SETUP_QDISC_TBF = 17,
	TC_SETUP_QDISC_FIFO = 18,
	TC_SETUP_QDISC_HTB = 19,
	TC_SETUP_ACT = 20,
};

struct ifreq;

struct if_settings;

struct ifmap;

struct neigh_parms;

struct rtnl_link_stats64;

struct ifla_vf_info;

struct ifla_vf_stats;

struct nlattr;

struct ifla_vf_guid;

struct netlink_ext_ack;

struct ndmsg;

struct nlmsghdr;

struct netlink_callback;

struct netdev_phys_item_id;

struct netdev_bpf;

struct xdp_frame;

struct xdp_buff;

struct ip_tunnel_parm;

struct net_device_path_ctx;

struct net_device_path;

struct skb_shared_hwtstamps;

struct kernel_hwtstamp_config;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocbond)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocwandev)(struct net_device *, struct if_settings *);
	int (*ndo_siocdevprivate)(struct net_device *, struct ifreq *, void __attribute__((btf_type_tag("user"))) *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	struct net_device * (*ndo_sk_get_lower_dev)(struct net_device *, struct sock *);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del_bulk)(struct nlmsghdr *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_mdb_add)(struct net_device *, struct nlattr **, u16, struct netlink_ext_ack *);
	int (*ndo_mdb_del)(struct net_device *, struct nlattr **, struct netlink_ext_ack *);
	int (*ndo_mdb_dump)(struct net_device *, struct sk_buff *, struct netlink_callback *);
	int (*ndo_mdb_get)(struct net_device *, struct nlattr **, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	struct net_device * (*ndo_xdp_get_xmit_slave)(struct net_device *, struct xdp_buff *);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
	int (*ndo_fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *);
	ktime_t (*ndo_get_tstamp)(struct net_device *, const struct skb_shared_hwtstamps *, bool);
	int (*ndo_hwtstamp_get)(struct net_device *, struct kernel_hwtstamp_config *);
	int (*ndo_hwtstamp_set)(struct net_device *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
};

typedef __u32 __wsum;

typedef unsigned int sk_buff_data_t;

struct skb_ext;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				unsigned long dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
		struct llist_node ll_node;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			unsigned long _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
		unsigned long _sk_redir;
	};
	unsigned long _nfct;
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 pp_recycle: 1;
	__u8 active_extensions;
	union {
		struct {
			__u8 __pkt_type_offset[0];
			__u8 pkt_type: 3;
			__u8 ignore_df: 1;
			__u8 dst_pending_confirm: 1;
			__u8 ip_summed: 2;
			__u8 ooo_okay: 1;
			__u8 __mono_tc_offset[0];
			__u8 mono_delivery_time: 1;
			__u8 tc_at_ingress: 1;
			__u8 tc_skip_classify: 1;
			__u8 remcsum_offload: 1;
			__u8 csum_complete_sw: 1;
			__u8 csum_level: 2;
			__u8 inner_protocol_type: 1;
			__u8 l4_hash: 1;
			__u8 sw_hash: 1;
			__u8 wifi_acked_valid: 1;
			__u8 wifi_acked: 1;
			__u8 no_fcs: 1;
			__u8 encapsulation: 1;
			__u8 encap_hdr_csum: 1;
			__u8 csum_valid: 1;
			__u8 ndisc_nodetype: 2;
			__u8 ipvs_property: 1;
			__u8 offload_fwd_mark: 1;
			__u8 offload_l3_fwd_mark: 1;
			__u8 redirected: 1;
			__u8 nf_skip_egress: 1;
			__u8 slow_gro: 1;
			__u16 tc_index;
			u16 alloc_cpu;
			union {
				__wsum csum;
				struct {
					__u16 csum_start;
					__u16 csum_offset;
				};
			};
			__u32 priority;
			int skb_iif;
			__u32 hash;
			union {
				u32 vlan_all;
				struct {
					__be16 vlan_proto;
					__u16 vlan_tci;
				};
			};
			union {
				unsigned int napi_id;
				unsigned int sender_cpu;
			};
			union {
				__u32 mark;
				__u32 reserved_tailroom;
			};
			union {
				__be16 inner_protocol;
				__u8 inner_ipproto;
			};
			__u16 inner_transport_header;
			__u16 inner_network_header;
			__u16 inner_mac_header;
			__be16 protocol;
			__u16 transport_header;
			__u16 network_header;
			__u16 mac_header;
		};
		struct {
			__u8 __pkt_type_offset[0];
			__u8 pkt_type: 3;
			__u8 ignore_df: 1;
			__u8 dst_pending_confirm: 1;
			__u8 ip_summed: 2;
			__u8 ooo_okay: 1;
			__u8 __mono_tc_offset[0];
			__u8 mono_delivery_time: 1;
			__u8 tc_at_ingress: 1;
			__u8 tc_skip_classify: 1;
			__u8 remcsum_offload: 1;
			__u8 csum_complete_sw: 1;
			__u8 csum_level: 2;
			__u8 inner_protocol_type: 1;
			__u8 l4_hash: 1;
			__u8 sw_hash: 1;
			__u8 wifi_acked_valid: 1;
			__u8 wifi_acked: 1;
			__u8 no_fcs: 1;
			__u8 encapsulation: 1;
			__u8 encap_hdr_csum: 1;
			__u8 csum_valid: 1;
			__u8 ndisc_nodetype: 2;
			__u8 ipvs_property: 1;
			__u8 offload_fwd_mark: 1;
			__u8 offload_l3_fwd_mark: 1;
			__u8 redirected: 1;
			__u8 nf_skip_egress: 1;
			__u8 slow_gro: 1;
			__u16 tc_index;
			u16 alloc_cpu;
			union {
				__wsum csum;
				struct {
					__u16 csum_start;
					__u16 csum_offset;
				};
			};
			__u32 priority;
			int skb_iif;
			__u32 hash;
			union {
				u32 vlan_all;
				struct {
					__be16 vlan_proto;
					__u16 vlan_tci;
				};
			};
			union {
				unsigned int napi_id;
				unsigned int sender_cpu;
			};
			union {
				__u32 mark;
				__u32 reserved_tailroom;
			};
			union {
				__be16 inner_protocol;
				__u8 inner_ipproto;
			};
			__u16 inner_transport_header;
			__u16 inner_network_header;
			__u16 inner_mac_header;
			__be16 protocol;
			__u16 transport_header;
			__u16 network_header;
			__u16 mac_header;
		} headers;
	};
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	struct skb_ext *extensions;
};

struct skb_ext {
	refcount_t refcnt;
	u8 offset[1];
	u8 chunks;
	long: 0;
	char data[0];
};

typedef __kernel_sa_family_t sa_family_t;

struct sockaddr {
	sa_family_t sa_family;
	union {
		char sa_data_min[14];
		struct {
			struct {} __empty_sa_data;
			char sa_data[0];
		};
	};
};

struct ifmap {
	unsigned long mem_start;
	unsigned long mem_end;
	unsigned short base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

typedef struct {
	unsigned short encoding;
	unsigned short parity;
} raw_hdlc_proto;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	unsigned short lmi;
	unsigned short dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef struct {
	unsigned short dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	unsigned short loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	unsigned short loopback;
	unsigned int slot_map;
} te1_settings;

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto __attribute__((btf_type_tag("user"))) *raw_hdlc;
		cisco_proto __attribute__((btf_type_tag("user"))) *cisco;
		fr_proto __attribute__((btf_type_tag("user"))) *fr;
		fr_proto_pvc __attribute__((btf_type_tag("user"))) *fr_pvc;
		fr_proto_pvc_info __attribute__((btf_type_tag("user"))) *fr_pvc_info;
		x25_hdlc_proto __attribute__((btf_type_tag("user"))) *x25;
		sync_serial_settings __attribute__((btf_type_tag("user"))) *sync;
		te1_settings __attribute__((btf_type_tag("user"))) *te1;
	} ifs_ifsu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void __attribute__((btf_type_tag("user"))) *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
	__u64 rx_otherhost_dropped;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct ifla_vf_guid {
	__u32 vf;
	__u64 guid;
};

struct nla_policy;

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	const struct nlattr *miss_nest;
	u16 miss_type;
	u8 cookie[20];
	u8 cookie_len;
	char _msg_buf[80];
};

struct netlink_range_validation;

struct netlink_range_validation_signed;

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		u16 strict_start_type;
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		const struct netlink_range_validation *range;
		const struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
	};
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long args[6];
	};
};

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

struct bpf_offloaded_map;

struct xsk_buff_pool;

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct bpf_map_dev_ops;

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_frame {
	void *data;
	u16 len;
	u16 headroom;
	u32 metasize;
	struct xdp_mem_info mem;
	struct net_device *dev_rx;
	u32 frame_sz;
	u32 flags;
};

struct xdp_rxq_info;

struct xdp_txq_info;

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
	u32 flags;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	unsigned int napi_id;
	u32 frag_size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct net_device_path_ctx {
	const struct net_device *dev;
	u8 daddr[6];
	int num_vlans;
	struct {
		u16 id;
		__be16 proto;
	} vlan[2];
};

enum net_device_path_type {
	DEV_PATH_ETHERNET = 0,
	DEV_PATH_VLAN = 1,
	DEV_PATH_BRIDGE = 2,
	DEV_PATH_PPPOE = 3,
	DEV_PATH_DSA = 4,
	DEV_PATH_MTK_WDMA = 5,
};

struct net_device_path {
	enum net_device_path_type type;
	const struct net_device *dev;
	union {
		struct {
			u16 id;
			__be16 proto;
			u8 h_dest[6];
		} encap;
		struct {
			enum {
				DEV_PATH_BR_VLAN_KEEP = 0,
				DEV_PATH_BR_VLAN_TAG = 1,
				DEV_PATH_BR_VLAN_UNTAG = 2,
				DEV_PATH_BR_VLAN_UNTAG_HW = 3,
			} vlan_mode;
			u16 vlan_id;
			__be16 vlan_proto;
		} bridge;
		struct {
			int port;
			u16 proto;
		} dsa;
		struct {
			u8 wdma_idx;
			u8 queue;
			u16 wcid;
			u8 bss;
			u8 amsdu;
		} mtk_wdma;
	};
};

struct skb_shared_hwtstamps {
	union {
		ktime_t hwtstamp;
		void *netdev_data;
	};
};

enum xdp_rss_hash_type {
	XDP_RSS_L3_IPV4 = 1,
	XDP_RSS_L3_IPV6 = 2,
	XDP_RSS_L3_DYNHDR = 4,
	XDP_RSS_L4 = 8,
	XDP_RSS_L4_TCP = 16,
	XDP_RSS_L4_UDP = 32,
	XDP_RSS_L4_SCTP = 64,
	XDP_RSS_L4_IPSEC = 128,
	XDP_RSS_TYPE_NONE = 0,
	XDP_RSS_TYPE_L2 = 0,
	XDP_RSS_TYPE_L3_IPV4 = 1,
	XDP_RSS_TYPE_L3_IPV6 = 2,
	XDP_RSS_TYPE_L3_IPV4_OPT = 5,
	XDP_RSS_TYPE_L3_IPV6_EX = 6,
	XDP_RSS_TYPE_L4_ANY = 8,
	XDP_RSS_TYPE_L4_IPV4_TCP = 25,
	XDP_RSS_TYPE_L4_IPV4_UDP = 41,
	XDP_RSS_TYPE_L4_IPV4_SCTP = 73,
	XDP_RSS_TYPE_L4_IPV4_IPSEC = 137,
	XDP_RSS_TYPE_L4_IPV6_TCP = 26,
	XDP_RSS_TYPE_L4_IPV6_UDP = 42,
	XDP_RSS_TYPE_L4_IPV6_SCTP = 74,
	XDP_RSS_TYPE_L4_IPV6_IPSEC = 138,
	XDP_RSS_TYPE_L4_IPV6_TCP_EX = 30,
	XDP_RSS_TYPE_L4_IPV6_UDP_EX = 46,
	XDP_RSS_TYPE_L4_IPV6_SCTP_EX = 78,
};

struct xdp_md;

struct xdp_metadata_ops {
	int (*xmo_rx_timestamp)(const struct xdp_md *, u64 *);
	int (*xmo_rx_hash)(const struct xdp_md *, u32 *, enum xdp_rss_hash_type *);
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct net_device_core_stats {
	unsigned long rx_dropped;
	unsigned long tx_dropped;
	unsigned long rx_nohandler;
	unsigned long rx_otherhost_dropped;
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

struct ethtool_drvinfo;

struct ethtool_regs;

struct ethtool_wolinfo;

struct ethtool_link_ext_state_info;

struct ethtool_link_ext_stats;

struct ethtool_eeprom;

struct ethtool_coalesce;

struct kernel_ethtool_coalesce;

struct ethtool_ringparam;

struct kernel_ethtool_ringparam;

struct ethtool_pause_stats;

struct ethtool_pauseparam;

struct ethtool_test;

struct ethtool_stats;

struct ethtool_rxnfc;

struct ethtool_flash;

struct ethtool_channels;

struct ethtool_dump;

struct ethtool_ts_info;

struct ethtool_modinfo;

struct ethtool_eee;

struct ethtool_tunable;

struct ethtool_link_ksettings;

struct ethtool_fec_stats;

struct ethtool_fecparam;

struct ethtool_module_eeprom;

struct ethtool_eth_phy_stats;

struct ethtool_eth_mac_stats;

struct ethtool_eth_ctrl_stats;

struct ethtool_rmon_stats;

struct ethtool_rmon_hist_range;

struct ethtool_module_power_mode_params;

struct ethtool_mm_state;

struct ethtool_mm_cfg;

struct ethtool_mm_stats;

struct ethtool_ops {
	u32 cap_link_lanes_supported: 1;
	u32 supported_coalesce_params;
	u32 supported_ring_params;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	void (*get_link_ext_stats)(struct net_device *, struct ethtool_link_ext_stats *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_eee *);
	int (*set_eee)(struct net_device *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	void (*get_fec_stats)(struct net_device *, struct ethtool_fec_stats *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
	void (*get_eth_phy_stats)(struct net_device *, struct ethtool_eth_phy_stats *);
	void (*get_eth_mac_stats)(struct net_device *, struct ethtool_eth_mac_stats *);
	void (*get_eth_ctrl_stats)(struct net_device *, struct ethtool_eth_ctrl_stats *);
	void (*get_rmon_stats)(struct net_device *, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
	int (*get_module_power_mode)(struct net_device *, struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
	int (*set_module_power_mode)(struct net_device *, const struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
	int (*get_mm)(struct net_device *, struct ethtool_mm_state *);
	int (*set_mm)(struct net_device *, struct ethtool_mm_cfg *, struct netlink_ext_ack *);
	void (*get_mm_stats)(struct net_device *, struct ethtool_mm_stats *);
};

struct nd_opt_hdr;

struct ndisc_options;

struct prefix_info;

struct in6_addr;

struct ndisc_ops {
	int (*is_useropt)(u8);
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

struct hh_cache;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, unsigned short, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

struct sk_buff_list {
	struct sk_buff *next;
	struct sk_buff *prev;
};

struct sk_buff_head {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
		};
		struct sk_buff_list list;
	};
	__u32 qlen;
	spinlock_t lock;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	unsigned long hh_data[12];
};

struct neigh_table;

struct neigh_ops;

struct neighbour {
	struct neighbour __attribute__((btf_type_tag("rcu"))) *next;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	unsigned long confirmed;
	unsigned long updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	unsigned long used;
	atomic_t probes;
	u8 nud_state;
	u8 type;
	u8 dead;
	u8 protocol;
	u32 flags;
	seqlock_t ha_lock;
	long: 0;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct list_head managed_list;
	struct callback_head rcu;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u8 primary_key[0];
};

struct ipv4_devconf {
	void *sysctl;
	int data[33];
	unsigned long state[1];
};

struct in_ifaddr;

struct ip_mc_list;

struct in_device {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr __attribute__((btf_type_tag("rcu"))) *ifa_list;
	struct ip_mc_list __attribute__((btf_type_tag("rcu"))) *mc_list;
	struct ip_mc_list __attribute__((btf_type_tag("rcu"))) * __attribute__((btf_type_tag("rcu"))) *mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	unsigned long mr_v1_seen;
	unsigned long mr_v2_seen;
	unsigned long mr_maxdelay;
	unsigned long mr_qi;
	unsigned long mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	u32 mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__s32 forwarding;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__u32 ra_defrtr_metric;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_min_lft;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 proxy_ndp;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 disable_ipv6;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	__s32 accept_untracked_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 disable_policy;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	__u32 ioam6_id;
	__u32 ioam6_id_wide;
	__u8 ioam6_enabled;
	__u8 ndisc_evict_nocarrier;
	__u8 ra_honor_pio_life;
	struct ctl_table_header *sysctl_header;
};

struct icmpv6_mib_device;

struct icmpv6msg_mib_device;

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib __attribute__((btf_type_tag("percpu"))) *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct ifmcaddr6;

struct ifacaddr6;

struct inet6_dev {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head addr_list;
	struct ifmcaddr6 __attribute__((btf_type_tag("rcu"))) *mc_list;
	struct ifmcaddr6 __attribute__((btf_type_tag("rcu"))) *mc_tomb;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	unsigned long mc_v1_seen;
	unsigned long mc_qi;
	unsigned long mc_qri;
	unsigned long mc_maxdelay;
	struct delayed_work mc_gq_work;
	struct delayed_work mc_ifc_work;
	struct delayed_work mc_dad_work;
	struct delayed_work mc_query_work;
	struct delayed_work mc_report_work;
	struct sk_buff_head mc_query_queue;
	struct sk_buff_head mc_report_queue;
	spinlock_t mc_query_lock;
	spinlock_t mc_report_lock;
	struct mutex mc_lock;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	unsigned long tstamp;
	struct callback_head rcu;
	unsigned int ra_mtu;
};

struct vlan_group {
	unsigned int nr_vlan_devs;
	struct hlist_node hlist;
	struct net_device **vlan_devices_arrays[16];
};

struct vlan_info {
	struct net_device *real_dev;
	struct vlan_group grp;
	struct list_head vid_list;
	unsigned int nr_vids;
	struct callback_head rcu;
};

struct bpf_mprog_fp {
	struct bpf_prog *prog;
};

struct bpf_mprog_bundle;

struct bpf_mprog_entry {
	struct bpf_mprog_fp fp_items[64];
	struct bpf_mprog_bundle *parent;
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	unsigned long slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	long: 64;
	long: 64;
};

struct netdev_queue {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct Qdisc __attribute__((btf_type_tag("rcu"))) *qdisc;
	struct Qdisc __attribute__((btf_type_tag("rcu"))) *qdisc_sleeping;
	struct kobject kobj;
	int numa_node;
	unsigned long tx_maxrate;
	atomic_long_t trans_timeout;
	struct net_device *sb_dev;
	struct xsk_buff_pool *pool;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	unsigned long trans_start;
	unsigned long state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dql dql;
};

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct gnet_stats_basic_sync {
	u64_stats_t bytes;
	u64_stats_t packets;
	struct u64_stats_sync syncp;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct Qdisc_ops;

struct qdisc_size_table;

struct net_rate_estimator;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table __attribute__((btf_type_tag("rcu"))) *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator __attribute__((btf_type_tag("rcu"))) *rate_est;
	struct gnet_stats_basic_sync __attribute__((btf_type_tag("percpu"))) *cpu_bstats;
	struct gnet_stats_queue __attribute__((btf_type_tag("percpu"))) *cpu_qstats;
	int pad;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	unsigned long state;
	unsigned long state2;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t busylock;
	spinlock_t seqlock;
	struct callback_head rcu;
	netdevice_tracker dev_tracker;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long privdata[0];
};

struct Qdisc_class_ops;

struct gnet_dump;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	void (*change_real_num_tx)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct tcmsg;

struct qdisc_walker;

struct tcf_block;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, unsigned long, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, unsigned long);
	void (*qlen_notify)(struct Qdisc *, unsigned long);
	unsigned long (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, unsigned long *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, unsigned long, struct netlink_ext_ack *);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, unsigned long, struct netlink_ext_ack *);
	unsigned long (*bind_tcf)(struct Qdisc *, unsigned long, u32);
	void (*unbind_tcf)(struct Qdisc *, unsigned long);
	int (*dump)(struct Qdisc *, unsigned long, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, unsigned long, struct gnet_dump *);
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	unsigned short tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct flow_block {
	struct list_head cb_list;
};

struct tcf_chain;

struct tcf_block {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_proto;

struct tcf_proto_ops;

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto __attribute__((btf_type_tag("rcu"))) *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct tcf_result;

struct tcf_proto {
	struct tcf_proto __attribute__((btf_type_tag("rcu"))) *next;
	void __attribute__((btf_type_tag("rcu"))) *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

enum skb_drop_reason {
	SKB_NOT_DROPPED_YET = 0,
	SKB_CONSUMED = 1,
	SKB_DROP_REASON_NOT_SPECIFIED = 2,
	SKB_DROP_REASON_NO_SOCKET = 3,
	SKB_DROP_REASON_PKT_TOO_SMALL = 4,
	SKB_DROP_REASON_TCP_CSUM = 5,
	SKB_DROP_REASON_SOCKET_FILTER = 6,
	SKB_DROP_REASON_UDP_CSUM = 7,
	SKB_DROP_REASON_NETFILTER_DROP = 8,
	SKB_DROP_REASON_OTHERHOST = 9,
	SKB_DROP_REASON_IP_CSUM = 10,
	SKB_DROP_REASON_IP_INHDR = 11,
	SKB_DROP_REASON_IP_RPFILTER = 12,
	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST = 13,
	SKB_DROP_REASON_XFRM_POLICY = 14,
	SKB_DROP_REASON_IP_NOPROTO = 15,
	SKB_DROP_REASON_SOCKET_RCVBUFF = 16,
	SKB_DROP_REASON_PROTO_MEM = 17,
	SKB_DROP_REASON_TCP_AUTH_HDR = 18,
	SKB_DROP_REASON_TCP_MD5NOTFOUND = 19,
	SKB_DROP_REASON_TCP_MD5UNEXPECTED = 20,
	SKB_DROP_REASON_TCP_MD5FAILURE = 21,
	SKB_DROP_REASON_TCP_AONOTFOUND = 22,
	SKB_DROP_REASON_TCP_AOUNEXPECTED = 23,
	SKB_DROP_REASON_TCP_AOKEYNOTFOUND = 24,
	SKB_DROP_REASON_TCP_AOFAILURE = 25,
	SKB_DROP_REASON_SOCKET_BACKLOG = 26,
	SKB_DROP_REASON_TCP_FLAGS = 27,
	SKB_DROP_REASON_TCP_ZEROWINDOW = 28,
	SKB_DROP_REASON_TCP_OLD_DATA = 29,
	SKB_DROP_REASON_TCP_OVERWINDOW = 30,
	SKB_DROP_REASON_TCP_OFOMERGE = 31,
	SKB_DROP_REASON_TCP_RFC7323_PAWS = 32,
	SKB_DROP_REASON_TCP_OLD_SEQUENCE = 33,
	SKB_DROP_REASON_TCP_INVALID_SEQUENCE = 34,
	SKB_DROP_REASON_TCP_RESET = 35,
	SKB_DROP_REASON_TCP_INVALID_SYN = 36,
	SKB_DROP_REASON_TCP_CLOSE = 37,
	SKB_DROP_REASON_TCP_FASTOPEN = 38,
	SKB_DROP_REASON_TCP_OLD_ACK = 39,
	SKB_DROP_REASON_TCP_TOO_OLD_ACK = 40,
	SKB_DROP_REASON_TCP_ACK_UNSENT_DATA = 41,
	SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE = 42,
	SKB_DROP_REASON_TCP_OFO_DROP = 43,
	SKB_DROP_REASON_IP_OUTNOROUTES = 44,
	SKB_DROP_REASON_BPF_CGROUP_EGRESS = 45,
	SKB_DROP_REASON_IPV6DISABLED = 46,
	SKB_DROP_REASON_NEIGH_CREATEFAIL = 47,
	SKB_DROP_REASON_NEIGH_FAILED = 48,
	SKB_DROP_REASON_NEIGH_QUEUEFULL = 49,
	SKB_DROP_REASON_NEIGH_DEAD = 50,
	SKB_DROP_REASON_TC_EGRESS = 51,
	SKB_DROP_REASON_QDISC_DROP = 52,
	SKB_DROP_REASON_CPU_BACKLOG = 53,
	SKB_DROP_REASON_XDP = 54,
	SKB_DROP_REASON_TC_INGRESS = 55,
	SKB_DROP_REASON_UNHANDLED_PROTO = 56,
	SKB_DROP_REASON_SKB_CSUM = 57,
	SKB_DROP_REASON_SKB_GSO_SEG = 58,
	SKB_DROP_REASON_SKB_UCOPY_FAULT = 59,
	SKB_DROP_REASON_DEV_HDR = 60,
	SKB_DROP_REASON_DEV_READY = 61,
	SKB_DROP_REASON_FULL_RING = 62,
	SKB_DROP_REASON_NOMEM = 63,
	SKB_DROP_REASON_HDR_TRUNC = 64,
	SKB_DROP_REASON_TAP_FILTER = 65,
	SKB_DROP_REASON_TAP_TXFILTER = 66,
	SKB_DROP_REASON_ICMP_CSUM = 67,
	SKB_DROP_REASON_INVALID_PROTO = 68,
	SKB_DROP_REASON_IP_INADDRERRORS = 69,
	SKB_DROP_REASON_IP_INNOROUTES = 70,
	SKB_DROP_REASON_PKT_TOO_BIG = 71,
	SKB_DROP_REASON_DUP_FRAG = 72,
	SKB_DROP_REASON_FRAG_REASM_TIMEOUT = 73,
	SKB_DROP_REASON_FRAG_TOO_FAR = 74,
	SKB_DROP_REASON_TCP_MINTTL = 75,
	SKB_DROP_REASON_IPV6_BAD_EXTHDR = 76,
	SKB_DROP_REASON_IPV6_NDISC_FRAG = 77,
	SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT = 78,
	SKB_DROP_REASON_IPV6_NDISC_BAD_CODE = 79,
	SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS = 80,
	SKB_DROP_REASON_IPV6_NDISC_NS_OTHERHOST = 81,
	SKB_DROP_REASON_QUEUE_PURGE = 82,
	SKB_DROP_REASON_TC_ERROR = 83,
	SKB_DROP_REASON_MAX = 84,
	SKB_DROP_REASON_SUBSYS_MASK = 4294901760,
};

struct tcf_result {
	union {
		struct {
			unsigned long class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
	};
	enum skb_drop_reason drop_reason;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct tcf_walker;

struct tcf_exts;

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, unsigned long, u32, struct nlattr **, void **, u32, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, unsigned long, void *, unsigned long);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	struct tcf_exts * (*get_exts)(const struct tcf_proto *, u32);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct net_rate_estimator {
	struct gnet_stats_basic_sync *bstats;
	spinlock_t *stats_lock;
	bool running;
	struct gnet_stats_basic_sync __attribute__((btf_type_tag("percpu"))) *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	unsigned long next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

struct nf_hook_state;

typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);

struct nf_hook_entry {
	nf_hookfn *hook;
	void *priv;
};

struct nf_hook_entries {
	u16 num_hook_entries;
	struct nf_hook_entry hooks[0];
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	struct bpf_prog *xdp_prog;
	unsigned int count;
};

struct xps_map;

struct xps_dev_maps {
	struct callback_head rcu;
	unsigned int nr_ids;
	s16 num_tc;
	struct xps_map __attribute__((btf_type_tag("rcu"))) *attr_map[0];
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_sw_netstats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_dstats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_drops;
	u64 tx_packets;
	u64 tx_bytes;
	u64 tx_drops;
	struct u64_stats_sync syncp;
	long: 64;
	long: 64;
};

struct rtnl_link_ops {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	struct net_device * (*alloc)(struct nlattr **, const char *, unsigned char, unsigned int, unsigned int);
	void (*setup)(struct net_device *);
	bool netns_refund;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct netprio_map {
	struct callback_head rcu;
	u32 priomap_len;
	u32 priomap[0];
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_info;

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

struct rtnl_hw_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
};

struct prot_inuse {
	int all;
	int val[64];
};

struct ipstats_mib {
	u64 mibs[38];
	struct u64_stats_sync syncp;
};

struct tcp_mib {
	unsigned long mibs[16];
};

struct linux_mib {
	unsigned long mibs[132];
};

struct udp_mib {
	unsigned long mibs[10];
};

struct icmp_mib {
	unsigned long mibs[30];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	unsigned long mibs[7];
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct ip_ra_chain {
	struct ip_ra_chain __attribute__((btf_type_tag("rcu"))) *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

struct rhashtable_compare_arg;

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct bucket_table;

struct rhashtable {
	struct bucket_table __attribute__((btf_type_tag("rcu"))) *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct inet_frags;

struct fqdir {
	long high_thresh;
	long low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t mem;
	struct work_struct destroy_work;
	struct llist_node free_list;
	long: 64;
	long: 64;
};

struct inet_frag_queue;

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	u8 mono_delivery_time;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table __attribute__((btf_type_tag("rcu"))) *future_tbl;
	struct lockdep_map dep_map;
	long: 64;
	struct rhash_lock_head __attribute__((btf_type_tag("rcu"))) *buckets[0];
};

struct rhash_lock_head {};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

struct ack_sample;

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	void (*cong_control)(struct sock *, const struct rate_sample *);
	u32 (*undo_cwnd)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
};

typedef struct {
	atomic_t refcnt;
} rcuref_t;

struct uncached_list;

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	unsigned long _metrics;
	unsigned long expires;
	void *__pad1;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	unsigned short flags;
	short obsolete;
	unsigned short header_len;
	unsigned short trailer_len;
	rcuref_t __rcuref;
	int __use;
	unsigned long lastuse;
	struct callback_head callback_head;
	short error;
	short __pad;
	__u32 tclassid;
	netdevice_tracker dev_tracker;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
	struct lwtunnel_state *lwtstate;
};

enum nf_log_type {
	NF_LOG_TYPE_LOG = 0,
	NF_LOG_TYPE_ULOG = 1,
	NF_LOG_TYPE_MAX = 2,
};

typedef u8 u_int8_t;

struct nf_loginfo;

typedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);

struct nf_logger {
	char *name;
	enum nf_log_type type;
	nf_logfn *logfn;
	struct module *me;
};

struct ip_conntrack_stat {
	unsigned int found;
	unsigned int invalid;
	unsigned int insert;
	unsigned int insert_failed;
	unsigned int clash_resolve;
	unsigned int drop;
	unsigned int early_drop;
	unsigned int error;
	unsigned int expect_new;
	unsigned int expect_create;
	unsigned int expect_delete;
	unsigned int search_restart;
	unsigned int chaintoolong;
};

struct nf_ct_event;

struct nf_exp_event;

struct nf_ct_event_notifier {
	int (*ct_event)(unsigned int, const struct nf_ct_event *);
	int (*exp_event)(unsigned int, const struct nf_exp_event *);
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		struct {
			struct {} __empty_ptr;
			void *ptr[0];
		};
	};
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1ULL,
	IFF_EBRIDGE = 2ULL,
	IFF_BONDING = 4ULL,
	IFF_ISATAP = 8ULL,
	IFF_WAN_HDLC = 16ULL,
	IFF_XMIT_DST_RELEASE = 32ULL,
	IFF_DONT_BRIDGE = 64ULL,
	IFF_DISABLE_NETPOLL = 128ULL,
	IFF_MACVLAN_PORT = 256ULL,
	IFF_BRIDGE_PORT = 512ULL,
	IFF_OVS_DATAPATH = 1024ULL,
	IFF_TX_SKB_SHARING = 2048ULL,
	IFF_UNICAST_FLT = 4096ULL,
	IFF_TEAM_PORT = 8192ULL,
	IFF_SUPP_NOFCS = 16384ULL,
	IFF_LIVE_ADDR_CHANGE = 32768ULL,
	IFF_MACVLAN = 65536ULL,
	IFF_XMIT_DST_RELEASE_PERM = 131072ULL,
	IFF_L3MDEV_MASTER = 262144ULL,
	IFF_NO_QUEUE = 524288ULL,
	IFF_OPENVSWITCH = 1048576ULL,
	IFF_L3MDEV_SLAVE = 2097152ULL,
	IFF_TEAM = 4194304ULL,
	IFF_RXFH_CONFIGURED = 8388608ULL,
	IFF_PHONY_HEADROOM = 16777216ULL,
	IFF_MACSEC = 33554432ULL,
	IFF_NO_RX_HANDLER = 67108864ULL,
	IFF_FAILOVER = 134217728ULL,
	IFF_FAILOVER_SLAVE = 268435456ULL,
	IFF_L3MDEV_RX_HANDLER = 536870912ULL,
	IFF_NO_ADDRCONF = 1073741824ULL,
	IFF_TX_SKB_NO_LINEAR = 2147483648ULL,
	IFF_CHANGE_PROTO_DOWN = 4294967296ULL,
	IFF_SEE_ALL_HWTSTAMP_REQUESTS = 8589934592ULL,
};

enum netdev_xdp_act {
	NETDEV_XDP_ACT_BASIC = 1,
	NETDEV_XDP_ACT_REDIRECT = 2,
	NETDEV_XDP_ACT_NDO_XMIT = 4,
	NETDEV_XDP_ACT_XSK_ZEROCOPY = 8,
	NETDEV_XDP_ACT_HW_OFFLOAD = 16,
	NETDEV_XDP_ACT_RX_SG = 32,
	NETDEV_XDP_ACT_NDO_XMIT_SG = 64,
	NETDEV_XDP_ACT_MASK = 127,
};

enum xdp_buff_flags {
	XDP_FLAGS_HAS_FRAGS = 1,
	XDP_FLAGS_FRAGS_PF_MEMALLOC = 2,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
	BPF_F_LINK = 8192,
	BPF_F_PATH_FD = 16384,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_F_BROADCAST = 8,
	BPF_F_EXCLUDE_INGRESS = 16,
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_PRE_UNINIT = 18,
	NETDEV_RELEASE = 19,
	NETDEV_NOTIFY_PEERS = 20,
	NETDEV_JOIN = 21,
	NETDEV_CHANGEUPPER = 22,
	NETDEV_RESEND_IGMP = 23,
	NETDEV_PRECHANGEMTU = 24,
	NETDEV_CHANGEINFODATA = 25,
	NETDEV_BONDING_INFO = 26,
	NETDEV_PRECHANGEUPPER = 27,
	NETDEV_CHANGELOWERSTATE = 28,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 29,
	NETDEV_UDP_TUNNEL_DROP_INFO = 30,
	NETDEV_CHANGE_TX_QUEUE_LEN = 31,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 32,
	NETDEV_CVLAN_FILTER_DROP_INFO = 33,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 34,
	NETDEV_SVLAN_FILTER_DROP_INFO = 35,
	NETDEV_OFFLOAD_XSTATS_ENABLE = 36,
	NETDEV_OFFLOAD_XSTATS_DISABLE = 37,
	NETDEV_OFFLOAD_XSTATS_REPORT_USED = 38,
	NETDEV_OFFLOAD_XSTATS_REPORT_DELTA = 39,
	NETDEV_XDP_FEAT_CHANGE = 40,
};

struct bpf_dtab_netdev;

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev __attribute__((btf_type_tag("rcu"))) **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
	long: 64;
	long: 64;
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

typedef struct bio_vec skb_frag_t;

struct skb_shared_info {
	__u8 flags;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	unsigned short gso_size;
	unsigned short gso_segs;
	struct sk_buff *frag_list;
	struct skb_shared_hwtstamps hwtstamps;
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	unsigned int xdp_frags_size;
	void *destructor_arg;
	skb_frag_t frags[17];
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u64 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	u32 flags;
	u32 kern_flags;
	u32 map_id;
	enum bpf_map_type map_type;
	struct bpf_nh_params nh;
};

typedef unsigned int (*bpf_dispatcher_fn)(const void *, const struct bpf_insn *, unsigned int (*)(const void *, const struct bpf_insn *));

typedef void (*rcu_callback_t)(struct callback_head *);

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

typedef unsigned long ulong;

struct fc_log;

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
	bool exclusive: 1;
};

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	unsigned long num_children;
	unsigned long num_active_vmas;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

struct mempolicy {
	atomic_t refcnt;
	unsigned short mode;
	unsigned short flags;
	nodemask_t nodes;
	int home_node;
	union {
		nodemask_t cpuset_mems_allowed;
		nodemask_t user_nodemask;
	} w;
};

typedef unsigned int blk_mode_t;

struct block_device_operations;

struct timer_rand_state;

struct disk_events;

struct badblocks;

struct blk_independent_access_ranges;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	unsigned short events;
	unsigned short event_flags;
	struct xarray part_tbl;
	struct block_device *part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	struct bio_set bio_split;
	int flags;
	unsigned long state;
	struct mutex open_mutex;
	unsigned int open_partitions;
	struct backing_dev_info *bdi;
	struct kobject queue_kobj;
	struct kobject *slave_dir;
	struct list_head slave_bdevs;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
	u64 diskseq;
	blk_mode_t open_mode;
	struct blk_independent_access_ranges *ia_ranges;
};

struct blk_zone;

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

enum blk_unique_id {
	BLK_UID_T10 = 1,
	BLK_UID_EUI64 = 2,
	BLK_UID_NAA = 3,
};

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	void (*submit_bio)(struct bio *);
	int (*poll_bio)(struct bio *, struct io_comp_batch *, unsigned int);
	int (*open)(struct gendisk *, blk_mode_t);
	void (*release)(struct gendisk *);
	int (*ioctl)(struct block_device *, blk_mode_t, unsigned int, unsigned long);
	int (*compat_ioctl)(struct block_device *, blk_mode_t, unsigned int, unsigned long);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	int (*set_read_only)(struct block_device *, bool);
	void (*free_disk)(struct gendisk *);
	void (*swap_slot_free_notify)(struct block_device *, unsigned long);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	int (*get_unique_id)(struct gendisk *, u8 *, enum blk_unique_id);
	struct module *owner;
	const struct pr_ops *pr_ops;
	int (*alternative_gpt_sector)(struct gendisk *, sector_t *);
};

struct request;

struct io_comp_batch {
	struct request *req_list;
	bool need_ts;
	void (*complete)(struct io_comp_batch *);
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

struct pr_keys;

struct pr_held_reservation;

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
	int (*pr_read_keys)(struct block_device *, struct pr_keys *);
	int (*pr_read_reservation)(struct block_device *, struct pr_held_reservation *);
};

struct blk_integrity_profile;

struct blk_integrity {
	const struct blk_integrity_profile *profile;
	unsigned char flags;
	unsigned char tuple_size;
	unsigned char interval_exp;
	unsigned char tag_size;
};

enum blk_bounce {
	BLK_BOUNCE_NONE = 0,
	BLK_BOUNCE_HIGH = 1,
};

enum blk_zoned_model {
	BLK_ZONED_NONE = 0,
	BLK_ZONED_HA = 1,
	BLK_ZONED_HM = 2,
};

struct queue_limits {
	enum blk_bounce bounce;
	unsigned long seg_boundary_mask;
	unsigned long virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_user_sectors;
	unsigned int max_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_secure_erase_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int zone_write_granularity;
	unsigned short max_segments;
	unsigned short max_integrity_segments;
	unsigned short max_discard_segments;
	unsigned char misaligned;
	unsigned char discard_misaligned;
	unsigned char raid_partial_stripes_expensive;
	enum blk_zoned_model zoned;
	unsigned int dma_alignment;
};

struct elevator_queue;

struct blk_queue_stats;

struct rq_qos;

struct blk_mq_ops;

struct blk_mq_ctx;

struct blk_mq_tags;

struct blk_trace;

struct blk_flush_queue;

struct blk_mq_tag_set;

struct request_queue {
	struct request *last_merge;
	struct elevator_queue *elevator;
	struct percpu_ref q_usage_counter;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	struct mutex rq_qos_mutex;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx __attribute__((btf_type_tag("percpu"))) *queue_ctx;
	unsigned int queue_depth;
	struct xarray hctx_table;
	unsigned int nr_hw_queues;
	void *queuedata;
	unsigned long queue_flags;
	atomic_t pm_only;
	int id;
	spinlock_t queue_lock;
	struct gendisk *disk;
	refcount_t refs;
	struct kobject *mq_kobj;
	struct blk_integrity integrity;
	struct device *dev;
	enum rpm_status rpm_status;
	unsigned long nr_requests;
	unsigned int dma_pad_mask;
	unsigned int rq_timeout;
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_tags;
	struct blk_mq_tags *sched_shared_tags;
	struct list_head icq_list;
	unsigned long blkcg_pols[1];
	struct blkcg_gq *root_blkg;
	struct list_head blkg_list;
	struct mutex blkcg_mutex;
	struct queue_limits limits;
	unsigned int required_elevator_features;
	int node;
	struct blk_trace __attribute__((btf_type_tag("rcu"))) *blk_trace;
	struct blk_flush_queue *fq;
	struct list_head flush_list;
	struct list_head requeue_list;
	spinlock_t requeue_lock;
	struct delayed_work requeue_work;
	struct mutex sysfs_lock;
	struct mutex sysfs_dir_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	int quiesce_depth;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	struct mutex debugfs_mutex;
	bool mq_sysfs_init_done;
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

struct blk_mq_hw_ctx;

struct blk_mq_queue_data;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	void (*queue_rqs)(struct request **);
	int (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *, int);
	void (*set_rq_budget_token)(struct request *, int);
	int (*get_rq_budget_token)(struct request *);
	enum blk_eh_timer_return (*timeout)(struct request *);
	int (*poll)(struct blk_mq_hw_ctx *, struct io_comp_batch *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	void (*map_queues)(struct blk_mq_tag_set *);
	void (*show_rq)(struct seq_file *, struct request *);
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		long: 64;
	};
	unsigned int cpu;
	unsigned short index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	long: 64;
};

struct blk_integrity_iter;

typedef blk_status_t integrity_processing_fn(struct blk_integrity_iter *);

typedef void integrity_prepare_fn(struct request *);

typedef void integrity_complete_fn(struct request *, unsigned int);

struct blk_integrity_profile {
	integrity_processing_fn *generate_fn;
	integrity_processing_fn *verify_fn;
	integrity_prepare_fn *prepare_fn;
	integrity_complete_fn *complete_fn;
	const char *name;
};

struct rchan;

struct blk_trace {
	int trace_state;
	struct rchan *rchan;
	unsigned long __attribute__((btf_type_tag("percpu"))) *sequence;
	unsigned char __attribute__((btf_type_tag("percpu"))) *msg_data;
	u16 act_mask;
	u64 start_lba;
	u64 end_lba;
	u32 pid;
	u32 dev;
	struct dentry *dir;
	struct list_head running_list;
	atomic_t dropped;
};

struct blk_independent_access_range {
	struct kobject kobj;
	sector_t sector;
	sector_t nr_sectors;
};

struct blk_independent_access_ranges {
	struct kobject kobj;
	bool sysfs_registered;
	unsigned int nr_ia_ranges;
	struct blk_independent_access_range ia_range[0];
};

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

struct blk_plug {
	struct request *mq_list;
	struct request *cached_rq;
	unsigned short nr_ios;
	unsigned short rq_count;
	bool multiple_queues;
	bool has_elevator;
	struct list_head cb_list;
};

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

struct compact_control {
	struct list_head freepages;
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	unsigned long free_pfn;
	unsigned long migrate_pfn;
	unsigned long fast_start_pfn;
	struct zone *zone;
	unsigned long total_migrate_scanned;
	unsigned long total_free_scanned;
	unsigned short fast_search_fail;
	short search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool finish_pageblock;
	bool alloc_contig;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fs_parse_result {
	bool negated;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
	};
};

struct bdev_handle {
	struct block_device *bdev;
	void *holder;
	blk_mode_t mode;
};

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, unsigned long);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_end)(void *, unsigned long);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_end)(void *, unsigned long);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long, unsigned long, unsigned long long, unsigned long, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long, long, long);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, unsigned long, unsigned long, unsigned long, unsigned long, int);

typedef void (*btf_trace_mm_vmscan_write_folio)(void *, struct folio *);

struct reclaim_stat;

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, unsigned long, unsigned long, struct reclaim_stat *, int, int);

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
};

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, unsigned long, unsigned long, unsigned long, unsigned long, int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, unsigned long);

typedef void (*btf_trace_mm_vmscan_throttled)(void *, int, int, int, int);

struct trace_print_flags {
	unsigned long mask;
	const char *name;
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_BOUNCE = 8,
	NR_FREE_CMA_PAGES = 9,
	NR_VM_ZONE_STAT_ITEMS = 10,
};

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 2,
	N_MEMORY = 3,
	N_CPU = 4,
	N_GENERIC_INITIATOR = 5,
	NR_NODE_STATES = 6,
};

enum vmscan_throttle_state {
	VMSCAN_THROTTLE_WRITEBACK = 0,
	VMSCAN_THROTTLE_ISOLATED = 1,
	VMSCAN_THROTTLE_NOPROGRESS = 2,
	VMSCAN_THROTTLE_CONGESTED = 3,
	NR_VMSCAN_THROTTLE = 4,
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_THROTTLED_WRITTEN = 33,
	NR_KERNEL_MISC_RECLAIMABLE = 34,
	NR_FOLL_PIN_ACQUIRED = 35,
	NR_FOLL_PIN_RELEASED = 36,
	NR_KERNEL_STACK_KB = 37,
	NR_PAGETABLE = 38,
	NR_SECONDARY_PAGETABLE = 39,
	NR_SWAPCACHE = 40,
	PGPROMOTE_SUCCESS = 41,
	PGPROMOTE_CANDIDATE = 42,
	NR_VM_NODE_STAT_ITEMS = 43,
};

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA = 4,
	PGALLOC_DMA32 = 5,
	PGALLOC_NORMAL = 6,
	PGALLOC_MOVABLE = 7,
	ALLOCSTALL_DMA = 8,
	ALLOCSTALL_DMA32 = 9,
	ALLOCSTALL_NORMAL = 10,
	ALLOCSTALL_MOVABLE = 11,
	PGSCAN_SKIP_DMA = 12,
	PGSCAN_SKIP_DMA32 = 13,
	PGSCAN_SKIP_NORMAL = 14,
	PGSCAN_SKIP_MOVABLE = 15,
	PGFREE = 16,
	PGACTIVATE = 17,
	PGDEACTIVATE = 18,
	PGLAZYFREE = 19,
	PGFAULT = 20,
	PGMAJFAULT = 21,
	PGLAZYFREED = 22,
	PGREFILL = 23,
	PGREUSE = 24,
	PGSTEAL_KSWAPD = 25,
	PGSTEAL_DIRECT = 26,
	PGSTEAL_KHUGEPAGED = 27,
	PGDEMOTE_KSWAPD = 28,
	PGDEMOTE_DIRECT = 29,
	PGDEMOTE_KHUGEPAGED = 30,
	PGSCAN_KSWAPD = 31,
	PGSCAN_DIRECT = 32,
	PGSCAN_KHUGEPAGED = 33,
	PGSCAN_DIRECT_THROTTLE = 34,
	PGSCAN_ANON = 35,
	PGSCAN_FILE = 36,
	PGSTEAL_ANON = 37,
	PGSTEAL_FILE = 38,
	PGSCAN_ZONE_RECLAIM_FAILED = 39,
	PGINODESTEAL = 40,
	SLABS_SCANNED = 41,
	KSWAPD_INODESTEAL = 42,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 43,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 44,
	PAGEOUTRUN = 45,
	PGROTATED = 46,
	DROP_PAGECACHE = 47,
	DROP_SLAB = 48,
	OOM_KILL = 49,
	NUMA_PTE_UPDATES = 50,
	NUMA_HUGE_PTE_UPDATES = 51,
	NUMA_HINT_FAULTS = 52,
	NUMA_HINT_FAULTS_LOCAL = 53,
	NUMA_PAGE_MIGRATE = 54,
	PGMIGRATE_SUCCESS = 55,
	PGMIGRATE_FAIL = 56,
	THP_MIGRATION_SUCCESS = 57,
	THP_MIGRATION_FAIL = 58,
	THP_MIGRATION_SPLIT = 59,
	COMPACTMIGRATE_SCANNED = 60,
	COMPACTFREE_SCANNED = 61,
	COMPACTISOLATED = 62,
	COMPACTSTALL = 63,
	COMPACTFAIL = 64,
	COMPACTSUCCESS = 65,
	KCOMPACTD_WAKE = 66,
	KCOMPACTD_MIGRATE_SCANNED = 67,
	KCOMPACTD_FREE_SCANNED = 68,
	HTLB_BUDDY_PGALLOC = 69,
	HTLB_BUDDY_PGALLOC_FAIL = 70,
	CMA_ALLOC_SUCCESS = 71,
	CMA_ALLOC_FAIL = 72,
	UNEVICTABLE_PGCULLED = 73,
	UNEVICTABLE_PGSCANNED = 74,
	UNEVICTABLE_PGRESCUED = 75,
	UNEVICTABLE_PGMLOCKED = 76,
	UNEVICTABLE_PGMUNLOCKED = 77,
	UNEVICTABLE_PGCLEARED = 78,
	UNEVICTABLE_PGSTRANDED = 79,
	THP_FAULT_ALLOC = 80,
	THP_FAULT_FALLBACK = 81,
	THP_FAULT_FALLBACK_CHARGE = 82,
	THP_COLLAPSE_ALLOC = 83,
	THP_COLLAPSE_ALLOC_FAILED = 84,
	THP_FILE_ALLOC = 85,
	THP_FILE_FALLBACK = 86,
	THP_FILE_FALLBACK_CHARGE = 87,
	THP_FILE_MAPPED = 88,
	THP_SPLIT_PAGE = 89,
	THP_SPLIT_PAGE_FAILED = 90,
	THP_DEFERRED_SPLIT_PAGE = 91,
	THP_SPLIT_PMD = 92,
	THP_SCAN_EXCEED_NONE_PTE = 93,
	THP_SCAN_EXCEED_SWAP_PTE = 94,
	THP_SCAN_EXCEED_SHARED_PTE = 95,
	THP_ZERO_PAGE_ALLOC = 96,
	THP_ZERO_PAGE_ALLOC_FAILED = 97,
	THP_SWPOUT = 98,
	THP_SWPOUT_FALLBACK = 99,
	BALLOON_INFLATE = 100,
	BALLOON_DEFLATE = 101,
	BALLOON_MIGRATE = 102,
	SWAP_RA = 103,
	SWAP_RA_HIT = 104,
	KSM_SWPIN_COPY = 105,
	COW_KSM = 106,
	NR_VM_EVENT_ITEMS = 107,
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_LARGE_FOLIO_SUPPORT = 6,
	AS_RELEASE_ALWAYS = 7,
	AS_STABLE_WRITES = 8,
};

enum folio_references {
	FOLIOREF_RECLAIM = 0,
	FOLIOREF_RECLAIM_CLEAN = 1,
	FOLIOREF_KEEP = 2,
	FOLIOREF_ACTIVATE = 3,
};

enum ttu_flags {
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_SYNC = 16,
	TTU_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
};

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
	SWP_SCANNING = 16384,
};

enum page_memcg_data_flags {
	MEMCG_DATA_OBJCGS = 1,
	MEMCG_DATA_KMEM = 2,
	__NR_MEMCG_DATA_FLAGS = 4,
};

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_LONGTERM_PIN = 7,
	MR_DEMOTION = 8,
	MR_TYPES = 9,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	WMARK_PROMO = 3,
	NR_WMARK = 4,
};

enum lruvec_flags {
	LRUVEC_CGROUP_CONGESTED = 0,
	LRUVEC_NODE_CONGESTED = 1,
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_OOM_GROUP_KILL = 5,
	MEMCG_SWAP_HIGH = 6,
	MEMCG_SWAP_MAX = 7,
	MEMCG_SWAP_FAIL = 8,
	MEMCG_NR_MEMORY_EVENTS = 9,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_FAVOR_DYNMODS = 16,
	CGRP_ROOT_CPUSET_V2_MODE = 65536,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 131072,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 262144,
	CGRP_ROOT_MEMORY_HUGETLB_ACCOUNTING = 524288,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_CMA = 4,
	MIGRATE_ISOLATE = 5,
	MIGRATE_TYPES = 6,
};

enum {
	ZONELIST_FALLBACK = 0,
	ZONELIST_NOFALLBACK = 1,
	MAX_ZONELISTS = 2,
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
	ZONE_RECLAIM_ACTIVE = 1,
	ZONE_BELOW_HIGH = 2,
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	unsigned long gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	unsigned long gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	unsigned long nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long nr_objects_to_shrink;
	unsigned long gfp_flags;
	unsigned long cache_items;
	unsigned long long delta;
	unsigned long total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long unused_scan;
	long new_scan;
	int retval;
	long total_scan;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	unsigned long nr_requested;
	unsigned long nr_scanned;
	unsigned long nr_skipped;
	unsigned long nr_taken;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_write_folio {
	struct trace_entry ent;
	unsigned long pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	unsigned long nr_scanned;
	unsigned long nr_reclaimed;
	unsigned long nr_dirty;
	unsigned long nr_writeback;
	unsigned long nr_congested;
	unsigned long nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	unsigned long nr_ref_keep;
	unsigned long nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	unsigned long nr_taken;
	unsigned long nr_active;
	unsigned long nr_deactivated;
	unsigned long nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	unsigned long gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_throttled {
	struct trace_entry ent;
	int nid;
	int usec_timeout;
	int usec_delayed;
	int reason;
	char __data[0];
};

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
};

typedef struct pglist_data pg_data_t;

struct scan_control {
	unsigned long nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	unsigned long anon_cost;
	unsigned long file_cost;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int proactive: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	unsigned int no_demotion: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	unsigned long nr_scanned;
	unsigned long nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	unsigned int generation;
};

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

typedef struct folio *new_folio_t(struct folio *, unsigned long);

typedef void free_folio_t(struct folio *, unsigned long);

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_write_folio {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

struct trace_event_data_offsets_mm_vmscan_throttled {};

struct folio_batch {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct folio *folios[15];
};

typedef __u64 __addrpair;

typedef __u32 __portpair;

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct proto;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	unsigned short skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		unsigned long skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	unsigned short skc_tx_queue_mapping;
	unsigned short skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
};

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

struct sock_cgroup_data {
	struct cgroup *cgroup;
	u32 classid;
	u16 prioidx;
};

typedef struct {} netns_tracker;

struct sk_filter;

struct socket_wq;

struct socket;

struct sock_reuseport;

struct sock {
	struct sock_common __sk_common;
	struct dst_entry __attribute__((btf_type_tag("rcu"))) *sk_rx_dst;
	int sk_rx_dst_ifindex;
	u32 sk_rx_dst_cookie;
	socket_lock_t sk_lock;
	atomic_t sk_drops;
	int sk_rcvlowat;
	struct sk_buff_head sk_error_queue;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	int sk_forward_alloc;
	u32 sk_reserved_mem;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	int sk_rcvbuf;
	int sk_disconnects;
	struct sk_filter __attribute__((btf_type_tag("rcu"))) *sk_filter;
	union {
		struct socket_wq __attribute__((btf_type_tag("rcu"))) *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	struct dst_entry __attribute__((btf_type_tag("rcu"))) *sk_dst_cache;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	unsigned long sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff_head sk_write_queue;
	__s32 sk_peek_off;
	int sk_write_pending;
	__u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	long sk_sndtimeo;
	struct timer_list sk_timer;
	__u32 sk_priority;
	__u32 sk_mark;
	unsigned long sk_pacing_rate;
	unsigned long sk_max_pacing_rate;
	struct page_frag sk_frag;
	netdev_features_t sk_route_caps;
	int sk_gso_type;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	__u32 sk_txhash;
	u8 sk_gso_disabled: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_userlocks: 4;
	u8 sk_pacing_shift;
	u16 sk_type;
	u16 sk_protocol;
	u16 sk_gso_max_segs;
	unsigned long sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	u8 sk_txrehash;
	u8 sk_prefer_busy_poll;
	u16 sk_busy_poll_budget;
	spinlock_t sk_peer_lock;
	int sk_bind_phc;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	long sk_rcvtimeo;
	ktime_t sk_stamp;
	atomic_t sk_tskey;
	atomic_t sk_zckey;
	u32 sk_tsflags;
	u8 sk_shutdown;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	bool sk_use_task_frag;
	struct socket *sk_socket;
	void *sk_user_data;
	void *sk_security;
	struct sock_cgroup_data sk_cgrp_data;
	struct mem_cgroup *sk_memcg;
	void (*sk_state_change)(struct sock *);
	void (*sk_data_ready)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport __attribute__((btf_type_tag("rcu"))) *sk_reuseport_cb;
	struct bpf_local_storage __attribute__((btf_type_tag("rcu"))) *sk_bpf_storage;
	struct callback_head sk_rcu;
	netns_tracker ns_tracker;
	struct hlist_node sk_bind2_node;
};

struct smc_hashinfo;

typedef struct {
	union {
		void *kernel;
		void __attribute__((btf_type_tag("user"))) *user;
	};
	bool is_kernel: 1;
} sockptr_t;

struct msghdr;

struct sk_psock;

struct request_sock_ops;

struct timewait_sock_ops;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, int, int *, bool);
	int (*ioctl)(struct sock *, int, int *);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char __attribute__((btf_type_tag("user"))) *, int __attribute__((btf_type_tag("user"))) *);
	void (*keepalive)(struct sock *, int);
	int (*compat_ioctl)(struct sock *, unsigned int, unsigned long);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int *);
	void (*splice_eof)(struct socket *);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	bool (*bpf_bypass_getsockopt)(int, int);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, unsigned short);
	void (*put_port)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*sock_is_readable)(struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	int __attribute__((btf_type_tag("percpu"))) *per_cpu_fw_alloc;
	struct percpu_counter *sockets_allocated;
	unsigned long *memory_pressure;
	long *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	unsigned int ipv6_pinfo_offset;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	unsigned int __attribute__((btf_type_tag("percpu"))) *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct ubuf_info;

struct msghdr {
	void *msg_name;
	int msg_namelen;
	int msg_inq;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void __attribute__((btf_type_tag("user"))) *msg_control_user;
	};
	bool msg_control_is_user: 1;
	bool msg_get_inq: 1;
	unsigned int msg_flags;
	__kernel_size_t msg_controllen;
	struct kiocb *msg_iocb;
	struct ubuf_info *msg_ubuf;
	int (*sg_from_iter)(struct sock *, struct sk_buff *, struct iov_iter *, size_t);
};

struct ubuf_info {
	void (*callback)(struct sk_buff *, struct ubuf_info *, bool);
	refcount_t refcnt;
	u8 flags;
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	u32 qlen;
	int data[14];
	unsigned long data_state[1];
};

struct pneigh_entry;

struct neigh_statistics;

struct neigh_hash_table;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	unsigned long last_flush;
	struct delayed_work gc_work;
	struct delayed_work managed_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	struct list_head managed_list;
	rwlock_t lock;
	unsigned long last_rand;
	struct neigh_statistics __attribute__((btf_type_tag("percpu"))) *stats;
	struct neigh_hash_table __attribute__((btf_type_tag("rcu"))) *nht;
	struct pneigh_entry **phash_buckets;
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 flags;
	u8 protocol;
	u32 key[0];
};

struct neigh_statistics {
	unsigned long allocs;
	unsigned long destroys;
	unsigned long hash_grows;
	unsigned long res_failed;
	unsigned long lookups;
	unsigned long hits;
	unsigned long rcv_probes_mcast;
	unsigned long rcv_probes_ucast;
	unsigned long periodic_gc_runs;
	unsigned long forced_gc_runs;
	unsigned long unres_discards;
	unsigned long table_fulls;
};

struct neigh_hash_table {
	struct neighbour __attribute__((btf_type_tag("rcu"))) **hash_buckets;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

enum hwtstamp_source {
	HWTSTAMP_SOURCE_NETDEV = 0,
	HWTSTAMP_SOURCE_PHYLIB = 1,
};

struct kernel_hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
	struct ifreq *ifr;
	bool copied_to_user;
	enum hwtstamp_source source;
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	union {
		__u8 flags;
		struct {
			__u8 reserved: 6;
			__u8 autoconf: 1;
			__u8 onlink: 1;
		};
	};
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

struct ip6_sf_list;

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 __attribute__((btf_type_tag("rcu"))) *next;
	struct ip6_sf_list __attribute__((btf_type_tag("rcu"))) *mca_sources;
	struct ip6_sf_list __attribute__((btf_type_tag("rcu"))) *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	unsigned long mca_sfcount[2];
	struct delayed_work mca_work;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	unsigned long mca_cstamp;
	unsigned long mca_tstamp;
	struct callback_head rcu;
};

struct ip6_sf_list {
	struct ip6_sf_list __attribute__((btf_type_tag("rcu"))) *sf_next;
	struct in6_addr sf_addr;
	unsigned long sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
	struct callback_head rcu;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	unsigned long aca_cstamp;
	unsigned long aca_tstamp;
	struct callback_head rcu;
};

struct icmpv6_mib_device {
	atomic_long_t mibs[7];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	unsigned long flags;
	struct callback_head rcu;
	long: 64;
};

struct proto_ops;

struct socket {
	socket_state state;
	short type;
	unsigned long flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq wq;
};

typedef struct {
	size_t written;
	size_t count;
	union {
		char __attribute__((btf_type_tag("user"))) *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

typedef int (*skb_read_actor_t)(struct sock *, struct sk_buff *);

struct proto_ops {
	int family;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, int, bool);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, unsigned long);
	int (*compat_ioctl)(struct socket *, unsigned int, unsigned long);
	int (*gettstamp)(struct socket *, void __attribute__((btf_type_tag("user"))) *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char __attribute__((btf_type_tag("user"))) *, int __attribute__((btf_type_tag("user"))) *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*splice_eof)(struct socket *);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*read_skb)(struct sock *, skb_read_actor_t);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct kmem_cache_order_objects {
	unsigned int x;
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu __attribute__((btf_type_tag("percpu"))) *cpu_slab;
	slab_flags_t flags;
	unsigned long min_partial;
	unsigned int size;
	unsigned int object_size;
	struct reciprocal_value reciprocal_size;
	unsigned int offset;
	unsigned int cpu_partial;
	unsigned int cpu_partial_slabs;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject kobj;
	unsigned int remote_node_defrag_ratio;
	struct kmem_cache_node *node[16];
};

typedef unsigned __int128 __u128;

typedef __u128 u128;

typedef u128 freelist_full_t;

typedef union {
	struct {
		void *freelist;
		unsigned long counter;
	};
	freelist_full_t full;
} freelist_aba_t;

typedef struct {} local_lock_t;

struct slab;

struct kmem_cache_cpu {
	union {
		struct {
			void **freelist;
			unsigned long tid;
		};
		freelist_aba_t freelist_tid;
	};
	struct slab *slab;
	struct slab *partial;
	local_lock_t lock;
};

struct slab {
	unsigned long __page_flags;
	struct kmem_cache *slab_cache;
	union {
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct slab *next;
					int slabs;
				};
			};
			union {
				struct {
					void *freelist;
					union {
						unsigned long counters;
						struct {
							unsigned int inuse: 16;
							unsigned int objects: 15;
							unsigned int frozen: 1;
						};
					};
				};
				freelist_aba_t freelist_counter;
			};
		};
		struct callback_head callback_head;
	};
	unsigned int __unused;
	atomic_t __page_refcount;
	unsigned long memcg_data;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	unsigned long nr_partial;
	struct list_head partial;
	atomic_long_t nr_slabs;
	atomic_long_t total_objects;
	struct list_head full;
};

struct request_sock;

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
	u32 timeout;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	int (*twsk_unique)(struct sock *, struct sock *, void *);
	void (*twsk_destructor)(struct sock *);
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct memcg_vmstats {
	long state[50];
	unsigned long events[19];
	long state_local[50];
	unsigned long events_local[19];
	long state_pending[50];
	unsigned long events_pending[19];
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	u16 num_closed_socks;
	u16 incoming_cpu;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog __attribute__((btf_type_tag("rcu"))) *prog;
	struct sock *socks[0];
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct fib_rule;

struct flowi;

struct fib_lookup_arg;

struct fib_rule_hdr;

struct fib_rules_ops {
	int family;
	struct list_head list;
	int rule_size;
	int addr_size;
	int unresolved_rules;
	int nr_goto_rules;
	unsigned int fib_rules_seq;
	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
	bool (*suppress)(struct fib_rule *, int, struct fib_lookup_arg *);
	int (*match)(struct fib_rule *, struct flowi *, int);
	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*delete)(struct fib_rule *);
	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
	size_t (*nlmsg_payload)(struct fib_rule *);
	void (*flush_cache)(struct fib_rules_ops *);
	int nlgroup;
	struct list_head rules_list;
	struct module *owner;
	struct net *fro_net;
	struct callback_head rcu;
};

struct fib_kuid_range {
	kuid_t start;
	kuid_t end;
};

struct fib_rule_port_range {
	__u16 start;
	__u16 end;
};

struct fib_rule {
	struct list_head list;
	int iifindex;
	int oifindex;
	u32 mark;
	u32 mark_mask;
	u32 flags;
	u32 table;
	u8 action;
	u8 l3mdev;
	u8 proto;
	u8 ip_proto;
	u32 target;
	__be64 tun_id;
	struct fib_rule __attribute__((btf_type_tag("rcu"))) *ctarget;
	struct net *fr_net;
	refcount_t refcnt;
	u32 pref;
	int suppress_ifgroup;
	int suppress_prefixlen;
	char iifname[16];
	char oifname[16];
	struct fib_kuid_range uid_range;
	struct fib_rule_port_range sport_range;
	struct fib_rule_port_range dport_range;
	struct callback_head rcu;
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	int flowic_l3mdev;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	__u32 flowic_multipath_hash;
	struct flowi_tunnel flowic_tun_key;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
	} u;
};

struct fib_lookup_arg {
	void *lookup_ptr;
	const void *lookup_data;
	void *result;
	struct fib_rule *rule;
	u32 table;
	int flags;
};

struct fib_rule_hdr {
	__u8 family;
	__u8 dst_len;
	__u8 src_len;
	__u8 tos;
	__u8 table;
	__u8 res1;
	__u8 res2;
	__u8 action;
	__u32 flags;
};

struct mem_cgroup_tree_per_node;

struct mem_cgroup_tree {
	struct mem_cgroup_tree_per_node *rb_tree_per_node[16];
};

struct mem_cgroup_tree_per_node {
	struct rb_root rb_root;
	struct rb_node *rb_rightmost;
	spinlock_t lock;
};

struct memory_stat {
	const char *name;
	unsigned int idx;
};

struct move_charge_struct {
	spinlock_t lock;
	struct mm_struct *mm;
	struct mem_cgroup *from;
	struct mem_cgroup *to;
	unsigned long flags;
	unsigned long precharge;
	unsigned long moved_charge;
	unsigned long moved_swap;
	struct task_struct *moving_task;
	wait_queue_head_t waitq;
};

struct memcg_stock_pcp {
	local_lock_t stock_lock;
	struct mem_cgroup *cached;
	unsigned int nr_pages;
	struct obj_cgroup *cached_objcg;
	struct pglist_data *cached_pgdat;
	unsigned int nr_bytes;
	int nr_slab_reclaimable_b;
	int nr_slab_unreclaimable_b;
	struct work_struct work;
	unsigned long flags;
};

enum page_walk_lock {
	PGWALK_RDLOCK = 0,
	PGWALK_WRLOCK = 1,
	PGWALK_WRLOCK_VERIFY = 2,
};

struct mm_walk;

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, unsigned long, unsigned long, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, unsigned long, unsigned long, struct mm_walk *);
	int (*pud_entry)(pud_t *, unsigned long, unsigned long, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, unsigned long, unsigned long, struct mm_walk *);
	int (*pte_entry)(pte_t *, unsigned long, unsigned long, struct mm_walk *);
	int (*pte_hole)(unsigned long, unsigned long, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, unsigned long, unsigned long, unsigned long, struct mm_walk *);
	int (*test_walk)(unsigned long, unsigned long, struct mm_walk *);
	int (*pre_vma)(unsigned long, unsigned long, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
	enum page_walk_lock walk_lock;
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

struct numa_stat {
	const char *name;
	unsigned int lru_mask;
};

enum cgroup_subsys_id {
	cpuset_cgrp_id = 0,
	cpu_cgrp_id = 1,
	cpuacct_cgrp_id = 2,
	io_cgrp_id = 3,
	memory_cgrp_id = 4,
	devices_cgrp_id = 5,
	freezer_cgrp_id = 6,
	net_cls_cgrp_id = 7,
	perf_event_cgrp_id = 8,
	net_prio_cgrp_id = 9,
	hugetlb_cgrp_id = 10,
	pids_cgrp_id = 11,
	rdma_cgrp_id = 12,
	misc_cgrp_id = 13,
	CGROUP_SUBSYS_COUNT = 14,
};

enum {
	CSS_TASK_ITER_PROCS = 1,
	CSS_TASK_ITER_THREADED = 2,
	CSS_TASK_ITER_SKIPPED = 65536,
};

enum memcg_stat_item {
	MEMCG_SWAP = 43,
	MEMCG_SOCK = 44,
	MEMCG_PERCPU_B = 45,
	MEMCG_VMALLOC = 46,
	MEMCG_KMEM = 47,
	MEMCG_ZSWAP_B = 48,
	MEMCG_ZSWAPPED = 49,
	MEMCG_NR_STAT = 50,
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

enum numa_stat_item {
	NUMA_HIT = 0,
	NUMA_MISS = 1,
	NUMA_FOREIGN = 2,
	NUMA_INTERLEAVE_HIT = 3,
	NUMA_LOCAL = 4,
	NUMA_OTHER = 5,
	NR_VM_NUMA_EVENT_ITEMS = 6,
};

enum writeback_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_VM_WRITEBACK_STAT_ITEMS = 2,
};

enum mem_cgroup_events_target {
	MEM_CGROUP_TARGET_THRESH = 0,
	MEM_CGROUP_TARGET_SOFTLIMIT = 1,
	MEM_CGROUP_NTARGETS = 2,
};

enum hk_type {
	HK_TYPE_TIMER = 0,
	HK_TYPE_RCU = 1,
	HK_TYPE_MISC = 2,
	HK_TYPE_SCHED = 3,
	HK_TYPE_TICK = 4,
	HK_TYPE_DOMAIN = 5,
	HK_TYPE_WQ = 6,
	HK_TYPE_MANAGED_IRQ = 7,
	HK_TYPE_KTHREAD = 8,
	HK_TYPE_MAX = 9,
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

enum mc_target_type {
	MC_TARGET_NONE = 0,
	MC_TARGET_PAGE = 1,
	MC_TARGET_SWAP = 2,
	MC_TARGET_DEVICE = 3,
};

enum res_type {
	_MEM = 0,
	_MEMSWAP = 1,
	_KMEM = 2,
	_TCP = 3,
};

enum {
	RES_USAGE = 0,
	RES_LIMIT = 1,
	RES_MAX_USAGE = 2,
	RES_FAILCNT = 3,
	RES_SOFT_LIMIT = 4,
};

struct oom_wait_info {
	struct mem_cgroup *memcg;
	wait_queue_entry_t wait;
};

struct mem_cgroup_eventfd_list {
	struct list_head list;
	struct eventfd_ctx *eventfd;
};

typedef struct poll_table_struct poll_table;

struct mem_cgroup_event {
	struct mem_cgroup *memcg;
	struct eventfd_ctx *eventfd;
	struct list_head list;
	int (*register_event)(struct mem_cgroup *, struct eventfd_ctx *, const char *);
	void (*unregister_event)(struct mem_cgroup *, struct eventfd_ctx *);
	poll_table pt;
	wait_queue_head_t *wqh;
	wait_queue_entry_t wait;
	struct work_struct remove;
};

typedef __kernel_ulong_t ino_t;

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

struct uncharge_gather {
	struct mem_cgroup *memcg;
	unsigned long nr_memory;
	unsigned long pgpgout;
	unsigned long nr_kmem;
	int nid;
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	unsigned long totalpages;
	struct task_struct *chosen;
	long chosen_points;
	enum oom_constraint constraint;
};

union mc_target {
	struct page *page;
	swp_entry_t ent;
};

typedef unsigned int fgf_t;

typedef void (*swap_func_t)(void *, void *, int);

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

enum fsnotify_iter_type {
	FSNOTIFY_ITER_TYPE_INODE = 0,
	FSNOTIFY_ITER_TYPE_VFSMOUNT = 1,
	FSNOTIFY_ITER_TYPE_SB = 2,
	FSNOTIFY_ITER_TYPE_PARENT = 3,
	FSNOTIFY_ITER_TYPE_INODE2 = 4,
	FSNOTIFY_ITER_TYPE_COUNT = 5,
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_PATH = 1,
	FSNOTIFY_EVENT_INODE = 2,
	FSNOTIFY_EVENT_DENTRY = 3,
	FSNOTIFY_EVENT_ERROR = 4,
};

struct mount;

struct mnt_namespace {
	struct ns_common ns;
	struct mount *root;
	struct list_head list;
	spinlock_t ns_lock;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	wait_queue_head_t poll;
	u64 event;
	unsigned int mounts;
	unsigned int pending_mounts;
};

struct mnt_pcp;

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp __attribute__((btf_type_tag("percpu"))) *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector __attribute__((btf_type_tag("rcu"))) *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

struct fs_error_report {
	int error;
	struct inode *inode;
	struct super_block *sb;
};

struct fsnotify_group;

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignore_mask;
	unsigned int flags;
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fanotify_group_private_data {
	struct hlist_head *merge_hash;
	struct list_head access_list;
	wait_queue_head_t access_waitq;
	int flags;
	int f_flags;
	struct ucounts *ucounts;
	mempool_t error_events_pool;
};

struct fsnotify_ops;

struct fsnotify_event;

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	unsigned int priority;
	bool shutdown;
	int flags;
	unsigned int owner_flags;
	struct mutex mark_mutex;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
		struct fanotify_group_private_data fanotify_data;
	};
};

struct fsnotify_iter_info;

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_group *, struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[5];
	struct fsnotify_group *current_group;
	unsigned int report_mask;
	int srcu_idx;
};

struct fsnotify_event {
	struct list_head list;
};

struct wait_bit_key {
	void *flags;
	int bit_nr;
	unsigned long timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

struct name_snapshot {
	struct qstr name;
	unsigned char inline_name[32];
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long (*proc_ioctl)(struct file *, unsigned int, unsigned long);
	long (*proc_compat_ioctl)(struct file *, unsigned int, unsigned long);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	unsigned long (*proc_get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

struct kernel_cpustat {
	u64 cpustat[10];
};

struct kernel_stat {
	unsigned long irqs_sum;
	unsigned int softirqs[10];
};

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
	struct rw_semaphore kernfs_rwsem;
	struct rw_semaphore kernfs_iattr_rwsem;
	struct rw_semaphore kernfs_supers_rwsem;
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct simple_xattrs {
	struct rb_root rb_root;
	rwlock_t lock;
};

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
};

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_HIDDEN = 512,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
	KERNFS_REMOVING = 16384,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

struct simple_xattr {
	struct rb_node rb_node;
	char *name;
	size_t size;
	char value[0];
};

typedef unsigned int tid_t;

struct transaction_chp_stats_s {
	unsigned long cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct journal_s;

typedef struct journal_s journal_t;

struct journal_head;

struct transaction_s;

typedef struct transaction_s transaction_t;

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	unsigned long t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	unsigned long t_max_wait;
	unsigned long t_start;
	unsigned long t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	unsigned long t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct transaction_run_stats_s {
	unsigned long rs_wait;
	unsigned long rs_request_delay;
	unsigned long rs_running;
	unsigned long rs_locked;
	unsigned long rs_flushing;
	unsigned long rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	unsigned long ts_tid;
	unsigned long ts_requested;
	struct transaction_run_stats_s run;
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

struct buffer_head;

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct jbd2_revoke_table_s;

struct jbd2_inode;

struct crypto_shash;

struct journal_s {
	unsigned long j_flags;
	unsigned long j_atomic_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	struct shrinker *j_shrinker;
	struct percpu_counter j_checkpoint_jh_count;
	transaction_t *j_shrink_transaction;
	unsigned long j_head;
	unsigned long j_tail;
	unsigned long j_free;
	unsigned long j_first;
	unsigned long j_last;
	unsigned long j_fc_first;
	unsigned long j_fc_off;
	unsigned long j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	unsigned long long j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	unsigned long j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	struct crypto_shash *j_chksum_driver;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int, tid_t);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
	int (*j_bmap)(struct journal_s *, sector_t *);
};

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	unsigned long b_state;
	struct buffer_head *b_this_page;
	union {
		struct page *b_page;
		struct folio *b_folio;
	};
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

struct fiemap_extent;

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent __attribute__((btf_type_tag("user"))) *fi_extents_start;
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__be32 s_head;
	__u32 s_padding[40];
	__be32 s_checksum;
	__u8 s_users[768];
};

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	unsigned long i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct crypto_alg;

struct crypto_tfm {
	refcount_t refcnt;
	u32 crt_flags;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	void *__crt_ctx[0];
};

struct crypto_shash {
	unsigned int descsize;
	struct crypto_tfm base;
};

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
};

struct crypto_instance;

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct jbd2_buffer_trigger_type;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_POLLED = 22,
	__REQ_ALLOC_CACHE = 23,
	__REQ_SWAP = 24,
	__REQ_DRV = 25,
	__REQ_FS_PRIVATE = 26,
	__REQ_NOUNMAP = 27,
	__REQ_NR_BITS = 28,
};

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

typedef int ext4_grpblk_t;

typedef unsigned int ext4_group_t;

struct ext4_group_info {
	unsigned long bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	int bb_avg_fragment_size_order;
	ext4_grpblk_t bb_largest_free_order;
	ext4_group_t bb_group;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	struct list_head bb_avg_fragment_size_node;
	struct list_head bb_largest_free_order_node;
	ext4_grpblk_t bb_counters[0];
};

typedef unsigned long long ext4_fsblk_t;

typedef __u32 ext4_lblk_t;

struct extent_status;

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	unsigned long i_flags;
	struct rw_semaphore xattr_sem;
	union {
		struct list_head i_orphan;
		unsigned int i_orphan_idx;
	};
	struct list_head i_fc_dilist;
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	struct rb_root i_prealloc_node;
	rwlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	unsigned int i_reserved_data_blocks;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	qsize_t i_reserved_quota;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	struct dquot *i_dquot[3];
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	ext4_fsblk_t es_pblk;
};

struct ext4_orphan_block;

struct ext4_orphan_info {
	int of_blocks;
	__u32 of_csum_seed;
	struct ext4_orphan_block *of_binfo;
};

struct ext4_es_stats {
	unsigned long es_stats_shrunk;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct ext4_journal_trigger {
	struct jbd2_buffer_trigger_type tr_triggers;
	struct super_block *sb;
};

struct fscrypt_dummy_policy {};

struct dax_device;

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[10];
	unsigned long fc_num_commits;
	unsigned long fc_ineligible_commits;
	unsigned long fc_failed_commits;
	unsigned long fc_skipped_commits;
	unsigned long fc_numblks;
	u64 s_fc_avg_commit_time;
};

struct ext4_fc_alloc_region;

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_super_block;

struct blockgroup_lock;

struct ext4_system_blocks;

struct ext4_locality_group;

struct flex_groups;

struct ext4_li_request;

struct mb_cache;

struct ext4_sb_info {
	unsigned long s_desc_size;
	unsigned long s_inodes_per_block;
	unsigned long s_blocks_per_group;
	unsigned long s_clusters_per_group;
	unsigned long s_inodes_per_group;
	unsigned long s_itb_per_group;
	unsigned long s_gdb_count;
	unsigned long s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	unsigned long s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head * __attribute__((btf_type_tag("rcu"))) *s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	unsigned long s_mount_flags;
	unsigned int s_def_mount_opt;
	unsigned int s_def_mount_opt2;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	unsigned short s_mount_state;
	unsigned short s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct percpu_counter s_sra_exceeded_retry_limit;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct buffer_head *s_mmp_bh;
	struct journal_s *s_journal;
	unsigned long s_ext4_flags;
	struct mutex s_orphan_lock;
	struct list_head s_orphan;
	struct ext4_orphan_info s_orphan_info;
	unsigned long s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct bdev_handle *s_journal_bdev_handle;
	char __attribute__((btf_type_tag("rcu"))) *s_qf_names[3];
	int s_jquota_fmt;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks __attribute__((btf_type_tag("rcu"))) *s_system_blks;
	struct ext4_group_info ** __attribute__((btf_type_tag("rcu"))) *s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	unsigned short *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list[2];
	struct list_head s_discard_list;
	struct work_struct s_discard_work;
	atomic_t s_retry_alloc_pending;
	struct list_head *s_mb_avg_fragment_size;
	rwlock_t *s_mb_avg_fragment_size_locks;
	struct list_head *s_mb_largest_free_orders;
	rwlock_t *s_mb_largest_free_orders_locks;
	unsigned long s_stripe;
	unsigned int s_mb_max_linear_groups;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_max_dir_size_kb;
	unsigned long s_mb_last_group;
	unsigned long s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	unsigned int s_mb_best_avail_max_trim_order;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_cX_ex_scanned[5];
	atomic_t s_bal_groups_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_len_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	atomic_t s_bal_p2_aligned_bad_suggestions;
	atomic_t s_bal_goal_fast_bad_suggestions;
	atomic_t s_bal_best_avail_bad_suggestions;
	atomic64_t s_bal_cX_groups_considered[5];
	atomic64_t s_bal_cX_hits[5];
	atomic64_t s_bal_cX_failed[5];
	atomic_t s_mb_buddies_generated;
	atomic64_t s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group __attribute__((btf_type_tag("percpu"))) *s_locality_groups;
	unsigned long s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups * __attribute__((btf_type_tag("rcu"))) *s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	unsigned long s_last_trim_minblks;
	struct crypto_shash *s_chksum_driver;
	__u32 s_csum_seed;
	struct shrinker *s_es_shrinker;
	struct list_head s_es_list;
	long s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache *s_ea_block_cache;
	struct mb_cache *s_ea_inode_cache;
	long: 64;
	spinlock_t s_es_lock;
	struct ext4_journal_trigger s_journal_triggers[1];
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	u64 s_dax_part_off;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	spinlock_t s_error_lock;
	int s_add_error_count;
	int s_first_error_code;
	__u32 s_first_error_line;
	__u32 s_first_error_ino;
	__u64 s_first_error_block;
	const char *s_first_error_func;
	time64_t s_first_error_time;
	int s_last_error_code;
	__u32 s_last_error_line;
	__u32 s_last_error_ino;
	__u64 s_last_error_block;
	const char *s_last_error_func;
	time64_t s_last_error_time;
	struct work_struct s_sb_upd_work;
	atomic_t s_fc_subtid;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	tid_t s_fc_ineligible_tid;
	struct ext4_fc_replay_state s_fc_replay_state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_orphan_file_inum;
	__le32 s_reserved[94];
	__le32 s_checksum;
};

struct bgl_lock {
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blockgroup_lock {
	struct bgl_lock locks[128];
};

struct ext4_orphan_block {
	atomic_t ob_free_entries;
	struct buffer_head *ob_bh;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	unsigned long lr_next_sched;
	unsigned long lr_timeout;
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	unsigned long h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
};

struct posix_acl_entry {
	short e_tag;
	unsigned short e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	struct callback_head a_rcu;
	unsigned int a_count;
	struct posix_acl_entry a_entries[0];
};

struct kstatfs {
	long f_type;
	long f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long f_namelen;
	long f_frsize;
	long f_flags;
	long f_spare[4];
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u64 ino;
			u32 gen;
		} __attribute__((packed)) i64;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		struct {
			struct {} __empty_raw;
			__u32 raw[0];
		};
	};
};

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, unsigned long);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, unsigned long, struct writeback_control *);

struct ext4_map_blocks;

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
};

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_read_folio)(void *, struct inode *, struct folio *);

typedef void (*btf_trace_ext4_release_folio)(void *, struct inode *, struct folio *);

typedef void (*btf_trace_ext4_invalidate_folio)(void *, struct folio *, size_t, size_t);

typedef void (*btf_trace_ext4_journalled_invalidate_folio)(void *, struct folio *, size_t, size_t);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, unsigned long long, unsigned long long);

struct ext4_allocation_context;

struct ext4_prealloc_space;

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	ext4_grpblk_t ac_orig_goal_len;
	__u32 ac_groups_considered;
	__u32 ac_flags;
	__u16 ac_groups_scanned;
	__u16 ac_groups_linear_remaining;
	__u16 ac_found;
	__u16 ac_cX_found[5];
	__u16 ac_tail;
	__u16 ac_buddy;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct page *ac_bitmap_page;
	struct page *ac_buddy_page;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_prealloc_space {
	union {
		struct rb_node inode_node;
		struct list_head lg_list;
	} pa_node;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	unsigned short pa_type;
	union {
		rwlock_t *inode_lock;
		spinlock_t *lg_lock;
	} pa_node_lock;
	struct inode *pa_inode;
};

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, unsigned long long, unsigned int);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, unsigned long long);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, unsigned long, int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, unsigned long);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, unsigned long);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, unsigned long);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, unsigned long, bool);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

struct ext4_extent;

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, unsigned long);

typedef void (*btf_trace_ext4_journal_start_sb)(void *, struct super_block *, int, int, int, int, unsigned long);

typedef void (*btf_trace_ext4_journal_start_inode)(void *, struct inode *, int, int, int, int, unsigned long);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, unsigned long);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, unsigned short);

struct partial_cluster;

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_insert_delayed_block)(void *, struct inode *, struct extent_status *, bool);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

struct ext4_fsmap;

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, unsigned long);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *, tid_t);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int, tid_t);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, handle_t *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, handle_t *, struct inode *, long, long, int);

typedef void (*btf_trace_ext4_fc_cleanup)(void *, journal_t *, int, tid_t);

typedef void (*btf_trace_ext4_update_sb)(void *, struct super_block *, ext4_fsblk_t, unsigned int);

typedef void (*exitcall_t)();

struct ext4_lazy_init {
	unsigned long li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_err_translation {
	int code;
	int errno;
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct constant_table {
	const char *name;
	int value;
};

enum {
	_DQUOT_USAGE_ENABLED = 0,
	_DQUOT_LIMITS_ENABLED = 1,
	_DQUOT_SUSPENDED = 2,
	_DQUOT_STATE_FLAGS = 3,
};

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_REASON_ENCRYPTED_FILENAME = 9,
	EXT4_FC_REASON_MAX = 10,
};

enum req_op {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_APPEND = 13,
	REQ_OP_ZONE_RESET = 15,
	REQ_OP_ZONE_RESET_ALL = 17,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb = 6,
	Opt_nouid32 = 7,
	Opt_debug = 8,
	Opt_removed = 9,
	Opt_user_xattr = 10,
	Opt_acl = 11,
	Opt_auto_da_alloc = 12,
	Opt_noauto_da_alloc = 13,
	Opt_noload = 14,
	Opt_commit = 15,
	Opt_min_batch_time = 16,
	Opt_max_batch_time = 17,
	Opt_journal_dev = 18,
	Opt_journal_path = 19,
	Opt_journal_checksum = 20,
	Opt_journal_async_commit = 21,
	Opt_abort = 22,
	Opt_data_journal = 23,
	Opt_data_ordered = 24,
	Opt_data_writeback = 25,
	Opt_data_err_abort = 26,
	Opt_data_err_ignore = 27,
	Opt_test_dummy_encryption = 28,
	Opt_inlinecrypt = 29,
	Opt_usrjquota = 30,
	Opt_grpjquota = 31,
	Opt_quota = 32,
	Opt_noquota = 33,
	Opt_barrier = 34,
	Opt_nobarrier = 35,
	Opt_err = 36,
	Opt_usrquota = 37,
	Opt_grpquota = 38,
	Opt_prjquota = 39,
	Opt_dax = 40,
	Opt_dax_always = 41,
	Opt_dax_inode = 42,
	Opt_dax_never = 43,
	Opt_stripe = 44,
	Opt_delalloc = 45,
	Opt_nodelalloc = 46,
	Opt_warn_on_error = 47,
	Opt_nowarn_on_error = 48,
	Opt_mblk_io_submit = 49,
	Opt_debug_want_extra_isize = 50,
	Opt_nomblk_io_submit = 51,
	Opt_block_validity = 52,
	Opt_noblock_validity = 53,
	Opt_inode_readahead_blks = 54,
	Opt_journal_ioprio = 55,
	Opt_dioread_nolock = 56,
	Opt_dioread_lock = 57,
	Opt_discard = 58,
	Opt_nodiscard = 59,
	Opt_init_itable = 60,
	Opt_noinit_itable = 61,
	Opt_max_dir_size_kb = 62,
	Opt_nojournal_checksum = 63,
	Opt_nombcache = 64,
	Opt_no_prefetch_block_bitmaps = 65,
	Opt_mb_optimize_scan = 66,
	Opt_errors = 67,
	Opt_data = 68,
	Opt_data_err = 69,
	Opt_jqfmt = 70,
	Opt_dax_type = 71,
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

enum {
	I_DATA_SEM_NORMAL = 0,
	I_DATA_SEM_OTHER = 1,
	I_DATA_SEM_QUOTA = 2,
	I_DATA_SEM_EA = 3,
};

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
	IOPRIO_CLASS_INVALID = 7,
};

enum {
	IOPRIO_HINT_NONE = 0,
	IOPRIO_HINT_DEV_DURATION_LIMIT_1 = 1,
	IOPRIO_HINT_DEV_DURATION_LIMIT_2 = 2,
	IOPRIO_HINT_DEV_DURATION_LIMIT_3 = 3,
	IOPRIO_HINT_DEV_DURATION_LIMIT_4 = 4,
	IOPRIO_HINT_DEV_DURATION_LIMIT_5 = 5,
	IOPRIO_HINT_DEV_DURATION_LIMIT_6 = 6,
	IOPRIO_HINT_DEV_DURATION_LIMIT_7 = 7,
};

enum {
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DESTROYING = 32768,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_ORDERED_EXPLICIT = 524288,
	WQ_MAX_ACTIVE = 512,
	WQ_UNBOUND_MAX_ACTIVE = 512,
	WQ_DFL_ACTIVE = 256,
};

enum ext4_journal_trigger_type {
	EXT4_JTR_ORPHAN_FILE = 0,
	EXT4_JTR_NONE = 1,
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FC_INELIGIBLE = 1,
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned long ip;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long nr_to_write;
	long pages_skipped;
	loff_t range_start;
	loff_t range_end;
	unsigned long writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned long first_page;
	long nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long pages_skipped;
	unsigned long writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4__folio_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned long index;
	char __data[0];
};

struct trace_event_raw_ext4_invalidate_folio_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned long index;
	size_t offset;
	size_t length;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	unsigned int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned long count;
	int flags;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_sb {
	struct trace_entry ent;
	dev_t dev;
	unsigned long ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	int type;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_inode {
	struct trace_entry ent;
	unsigned long ino;
	dev_t dev;
	unsigned long ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	int type;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	unsigned long ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned short len;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	unsigned short ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	unsigned short eh_entries;
	char __data[0];
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	unsigned long long scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_block {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool allocated;
	char __data[0];
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	unsigned int fc_ineligible_rc[10];
	unsigned long fc_commits;
	unsigned long fc_ineligible_commits;
	unsigned long fc_numblks;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_dentry {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	long start;
	long end;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_cleanup {
	struct trace_entry ent;
	dev_t dev;
	int j_fc_off;
	int full;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_update_sb {
	struct trace_entry ent;
	dev_t dev;
	ext4_fsblk_t fsblk;
	unsigned int flags;
	char __data[0];
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct shash_desc {
	struct crypto_shash *tfm;
	void *__ctx[0];
};

struct ext4_fs_context {
	char *s_qf_names[3];
	struct fscrypt_dummy_policy dummy_enc_policy;
	int s_jquota_fmt;
	unsigned short qname_spec;
	unsigned long vals_s_flags;
	unsigned long mask_s_flags;
	unsigned long journal_devnum;
	unsigned long s_commit_interval;
	unsigned long s_stripe;
	unsigned int s_inode_readahead_blks;
	unsigned int s_want_extra_isize;
	unsigned int s_li_wait_mult;
	unsigned int s_max_dir_size_kb;
	unsigned int journal_ioprio;
	unsigned int vals_s_mount_opt;
	unsigned int mask_s_mount_opt;
	unsigned int vals_s_mount_opt2;
	unsigned int mask_s_mount_opt2;
	unsigned int opt_flags;
	unsigned int spec;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	kuid_t s_resuid;
	kgid_t s_resgid;
	ext4_fsblk_t s_sb_block;
};

struct ext4_mount_options {
	unsigned long s_mount_opt;
	unsigned long s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	unsigned long s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
	int s_jquota_fmt;
	char *s_qf_names[3];
};

typedef int (*writepage_t)(struct folio *, struct writeback_control *, void *);

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_ext4__folio_op {};

struct trace_event_data_offsets_ext4_invalidate_folio_op {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_journal_start_sb {};

struct trace_event_data_offsets_ext4_journal_start_inode {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_insert_delayed_block {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_dentry {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

struct trace_event_data_offsets_ext4_fc_cleanup {};

struct trace_event_data_offsets_ext4_update_sb {};

struct va_format {
	const char *fmt;
	va_list *va;
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct file_lock_operations;

struct lock_manager_operations;

struct file_lock {
	struct file_lock *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct *fl_fasync;
	unsigned long fl_break_time;
	unsigned long fl_downgrade_time;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
		struct {
			struct inode *inode;
		} ceph;
	} fl_u;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct lock_manager_operations {
	void *lm_mod_owner;
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_break)(struct file_lock *);
	int (*lm_change)(struct file_lock *, int, struct list_head *);
	void (*lm_setup)(struct file_lock *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lock *);
	bool (*lm_lock_expirable)(struct file_lock *);
	void (*lm_expire_lock)();
};

struct rpc_timer {
	struct list_head list;
	unsigned long expires;
	struct delayed_work dwork;
};

struct rpc_wait_queue {
	spinlock_t lock;
	struct list_head tasks[4];
	unsigned char maxpriority;
	unsigned char priority;
	unsigned char nr;
	unsigned short qlen;
	struct rpc_timer timer_list;
	const char *name;
};

struct nfs_seqid_counter {
	ktime_t create_time;
	int owner_id;
	int flags;
	u32 counter;
	spinlock_t lock;
	struct list_head list;
	struct rpc_wait_queue wait;
};

struct nfs4_stateid_struct {
	union {
		char data[16];
		struct {
			__be32 seqid;
			char other[12];
		};
	};
	enum {
		NFS4_INVALID_STATEID_TYPE = 0,
		NFS4_SPECIAL_STATEID_TYPE = 1,
		NFS4_OPEN_STATEID_TYPE = 2,
		NFS4_LOCK_STATEID_TYPE = 3,
		NFS4_DELEGATION_STATEID_TYPE = 4,
		NFS4_LAYOUT_STATEID_TYPE = 5,
		NFS4_PNFS_DS_STATEID_TYPE = 6,
		NFS4_REVOKED_STATEID_TYPE = 7,
	} type;
};

typedef struct nfs4_stateid_struct nfs4_stateid;

struct nfs4_state;

struct nfs4_lock_state {
	struct list_head ls_locks;
	struct nfs4_state *ls_state;
	unsigned long ls_flags;
	struct nfs_seqid_counter ls_seqid;
	nfs4_stateid ls_stateid;
	refcount_t ls_count;
	fl_owner_t ls_owner;
};

struct nfs4_state_owner;

struct nfs4_state {
	struct list_head open_states;
	struct list_head inode_states;
	struct list_head lock_states;
	struct nfs4_state_owner *owner;
	struct inode *inode;
	unsigned long flags;
	spinlock_t state_lock;
	seqlock_t seqlock;
	nfs4_stateid stateid;
	nfs4_stateid open_stateid;
	unsigned int n_rdonly;
	unsigned int n_wronly;
	unsigned int n_rdwr;
	fmode_t state;
	refcount_t count;
	wait_queue_head_t waitq;
	struct callback_head callback_head;
};

struct nfs_server;

struct nfs4_state_owner {
	struct nfs_server *so_server;
	struct list_head so_lru;
	unsigned long so_expires;
	struct rb_node so_server_node;
	const struct cred *so_cred;
	spinlock_t so_lock;
	atomic_t so_count;
	unsigned long so_flags;
	struct list_head so_states;
	struct nfs_seqid_counter so_seqid;
	seqcount_spinlock_t so_reclaim_seqcount;
	struct mutex so_delegreturn_mutex;
};

enum nfs4_change_attr_type {
	NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2,
	NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3,
	NFS4_CHANGE_TYPE_IS_UNDEFINED = 4,
};

struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};

typedef u32 rpc_authflavor_t;

struct nfs_auth_info {
	unsigned int flavor_len;
	rpc_authflavor_t flavors[12];
};

struct ida {
	struct xarray xa;
};

struct nfs_client;

struct rpc_clnt;

struct nlm_host;

struct nfs_iostats;

struct pnfs_layoutdriver_type;

struct nfs_server {
	struct nfs_client *nfs_client;
	struct list_head client_link;
	struct list_head master_link;
	struct rpc_clnt *client;
	struct rpc_clnt *client_acl;
	struct nlm_host *nlm_host;
	struct nfs_iostats __attribute__((btf_type_tag("percpu"))) *io_stats;
	atomic_long_t writeback;
	unsigned int write_congested;
	unsigned int flags;
	unsigned int fattr_valid;
	unsigned int caps;
	unsigned int rsize;
	unsigned int rpages;
	unsigned int wsize;
	unsigned int wpages;
	unsigned int wtmult;
	unsigned int dtsize;
	unsigned short port;
	unsigned int bsize;
	unsigned int gxasize;
	unsigned int sxasize;
	unsigned int lxasize;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namelen;
	unsigned int options;
	unsigned int clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	struct nfs_fsid fsid;
	int s_sysfs_id;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	unsigned long mount_time;
	struct super_block *super;
	dev_t s_dev;
	struct nfs_auth_info auth_info;
	u32 pnfs_blksize;
	u32 attr_bitmask[3];
	u32 attr_bitmask_nl[3];
	u32 exclcreat_bitmask[3];
	u32 cache_consistency_bitmask[3];
	u32 acl_bitmask;
	u32 fh_expire_type;
	struct pnfs_layoutdriver_type *pnfs_curr_ld;
	struct rpc_wait_queue roc_rpcwaitq;
	void *pnfs_ld_data;
	struct rb_root state_owners;
	struct ida openowner_id;
	struct ida lockowner_id;
	struct list_head state_owners_lru;
	struct list_head layouts;
	struct list_head delegations;
	struct list_head ss_copies;
	unsigned long delegation_gen;
	unsigned long mig_gen;
	unsigned long mig_status;
	void (*destroy)(struct nfs_server *);
	atomic_t active;
	struct __kernel_sockaddr_storage mountd_address;
	size_t mountd_addrlen;
	u32 mountd_version;
	unsigned short mountd_port;
	unsigned short mountd_protocol;
	struct rpc_wait_queue uoc_rpcwaitq;
	unsigned int read_hdrsize;
	const struct cred *cred;
	bool has_sec_mnt_opts;
	struct kobject kobj;
};

enum xprtsec_policies {
	RPC_XPRTSEC_NONE = 0,
	RPC_XPRTSEC_TLS_ANON = 1,
	RPC_XPRTSEC_TLS_X509 = 2,
};

struct xprtsec_parms {
	enum xprtsec_policies policy;
	key_serial_t cert_serial;
	key_serial_t privkey_serial;
};

typedef struct {
	char data[8];
} nfs4_verifier;

struct nfs_rpc_ops;

struct nfs_subversion;

struct idmap;

struct nfs4_minor_version_ops;

struct nfs4_slot_table;

struct nfs4_session;

struct nfs41_server_owner;

struct nfs41_server_scope;

struct nfs41_impl_id;

struct nfs_client {
	refcount_t cl_count;
	atomic_t cl_mds_count;
	int cl_cons_state;
	unsigned long cl_res_state;
	unsigned long cl_flags;
	struct __kernel_sockaddr_storage cl_addr;
	size_t cl_addrlen;
	char *cl_hostname;
	char *cl_acceptor;
	struct list_head cl_share_link;
	struct list_head cl_superblocks;
	struct rpc_clnt *cl_rpcclient;
	const struct nfs_rpc_ops *rpc_ops;
	int cl_proto;
	struct nfs_subversion *cl_nfs_mod;
	u32 cl_minorversion;
	unsigned int cl_nconnect;
	unsigned int cl_max_connect;
	const char *cl_principal;
	struct xprtsec_parms cl_xprtsec;
	struct list_head cl_ds_clients;
	u64 cl_clientid;
	nfs4_verifier cl_confirm;
	unsigned long cl_state;
	spinlock_t cl_lock;
	unsigned long cl_lease_time;
	unsigned long cl_last_renewal;
	struct delayed_work cl_renewd;
	struct rpc_wait_queue cl_rpcwaitq;
	struct idmap *cl_idmap;
	const char *cl_owner_id;
	u32 cl_cb_ident;
	const struct nfs4_minor_version_ops *cl_mvops;
	unsigned long cl_mig_gen;
	struct nfs4_slot_table *cl_slot_tbl;
	u32 cl_seqid;
	u32 cl_exchange_flags;
	struct nfs4_session *cl_session;
	bool cl_preserve_clid;
	struct nfs41_server_owner *cl_serverowner;
	struct nfs41_server_scope *cl_serverscope;
	struct nfs41_impl_id *cl_implid;
	unsigned long cl_sp4_flags;
	wait_queue_head_t cl_lock_waitq;
	char cl_ipaddr[48];
	struct net *cl_net;
	struct list_head pending_cb_stateids;
};

struct rpc_xprt_switch;

struct rpc_xprt;

struct rpc_xprt_iter_ops;

struct rpc_xprt_iter {
	struct rpc_xprt_switch __attribute__((btf_type_tag("rcu"))) *xpi_xpswitch;
	struct rpc_xprt *xpi_cursor;
	const struct rpc_xprt_iter_ops *xpi_ops;
};

struct rpc_pipe_dir_head {
	struct list_head pdh_entries;
	struct dentry *pdh_dentry;
};

struct rpc_rtt {
	unsigned long timeo;
	unsigned long srtt[5];
	unsigned long sdrtt[5];
	int ntimeouts[5];
};

struct rpc_timeout {
	unsigned long to_initval;
	unsigned long to_maxval;
	unsigned long to_increment;
	unsigned int to_retries;
	unsigned char to_exponential;
};

struct rpc_procinfo;

struct rpc_auth;

struct rpc_stat;

struct rpc_iostats;

struct rpc_program;

struct rpc_sysfs_client;

struct rpc_clnt {
	refcount_t cl_count;
	unsigned int cl_clid;
	struct list_head cl_clients;
	struct list_head cl_tasks;
	atomic_t cl_pid;
	spinlock_t cl_lock;
	struct rpc_xprt __attribute__((btf_type_tag("rcu"))) *cl_xprt;
	const struct rpc_procinfo *cl_procinfo;
	u32 cl_prog;
	u32 cl_vers;
	u32 cl_maxproc;
	struct rpc_auth *cl_auth;
	struct rpc_stat *cl_stats;
	struct rpc_iostats *cl_metrics;
	unsigned int cl_softrtry: 1;
	unsigned int cl_softerr: 1;
	unsigned int cl_discrtry: 1;
	unsigned int cl_noretranstimeo: 1;
	unsigned int cl_autobind: 1;
	unsigned int cl_chatty: 1;
	unsigned int cl_shutdown: 1;
	struct xprtsec_parms cl_xprtsec;
	struct rpc_rtt *cl_rtt;
	const struct rpc_timeout *cl_timeout;
	atomic_t cl_swapper;
	int cl_nodelen;
	char cl_nodename[65];
	struct rpc_pipe_dir_head cl_pipedir_objects;
	struct rpc_clnt *cl_parent;
	struct rpc_rtt cl_rtt_default;
	struct rpc_timeout cl_timeout_default;
	const struct rpc_program *cl_program;
	const char *cl_principal;
	struct rpc_sysfs_client *cl_sysfs;
	union {
		struct rpc_xprt_iter cl_xpi;
		struct work_struct cl_work;
	};
	const struct cred *cl_cred;
	unsigned int cl_max_connect;
	struct super_block *pipefs_sb;
};

struct rpc_xprt_ops;

struct rpc_task;

struct svc_xprt;

struct svc_serv;

struct xprt_class;

struct rpc_sysfs_xprt;

struct rpc_xprt {
	struct kref kref;
	const struct rpc_xprt_ops *ops;
	unsigned int id;
	const struct rpc_timeout *timeout;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	int prot;
	unsigned long cong;
	unsigned long cwnd;
	size_t max_payload;
	struct rpc_wait_queue binding;
	struct rpc_wait_queue sending;
	struct rpc_wait_queue pending;
	struct rpc_wait_queue backlog;
	struct list_head free;
	unsigned int max_reqs;
	unsigned int min_reqs;
	unsigned int num_reqs;
	unsigned long state;
	unsigned char resvport: 1;
	unsigned char reuseport: 1;
	atomic_t swapper;
	unsigned int bind_index;
	struct list_head xprt_switch;
	unsigned long bind_timeout;
	unsigned long reestablish_timeout;
	struct xprtsec_parms xprtsec;
	unsigned int connect_cookie;
	struct work_struct task_cleanup;
	struct timer_list timer;
	unsigned long last_used;
	unsigned long idle_timeout;
	unsigned long connect_timeout;
	unsigned long max_reconnect_timeout;
	atomic_long_t queuelen;
	spinlock_t transport_lock;
	spinlock_t reserve_lock;
	spinlock_t queue_lock;
	u32 xid;
	struct rpc_task *snd_task;
	struct list_head xmit_queue;
	atomic_long_t xmit_queuelen;
	struct svc_xprt *bc_xprt;
	struct svc_serv *bc_serv;
	unsigned int bc_alloc_max;
	unsigned int bc_alloc_count;
	atomic_t bc_slot_count;
	spinlock_t bc_pa_lock;
	struct list_head bc_pa_list;
	struct rb_root recv_queue;
	struct {
		unsigned long bind_count;
		unsigned long connect_count;
		unsigned long connect_start;
		unsigned long connect_time;
		unsigned long sends;
		unsigned long recvs;
		unsigned long bad_xids;
		unsigned long max_slots;
		unsigned long long req_u;
		unsigned long long bklog_u;
		unsigned long long sending_u;
		unsigned long long pending_u;
	} stat;
	struct net *xprt_net;
	netns_tracker ns_tracker;
	const char *servername;
	const char *address_strings[6];
	struct callback_head rcu;
	const struct xprt_class *xprt_class;
	struct rpc_sysfs_xprt *xprt_sysfs;
	bool main;
};

struct rpc_rqst;

struct xdr_buf;

struct rpc_xprt_ops {
	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
	void (*rpcbind)(struct rpc_task *);
	void (*set_port)(struct rpc_xprt *, unsigned short);
	void (*connect)(struct rpc_xprt *, struct rpc_task *);
	int (*get_srcaddr)(struct rpc_xprt *, char *, size_t);
	unsigned short (*get_srcport)(struct rpc_xprt *);
	int (*buf_alloc)(struct rpc_task *);
	void (*buf_free)(struct rpc_task *);
	int (*prepare_request)(struct rpc_rqst *, struct xdr_buf *);
	int (*send_request)(struct rpc_rqst *);
	void (*wait_for_reply_request)(struct rpc_task *);
	void (*timer)(struct rpc_xprt *, struct rpc_task *);
	void (*release_request)(struct rpc_task *);
	void (*close)(struct rpc_xprt *);
	void (*destroy)(struct rpc_xprt *);
	void (*set_connect_timeout)(struct rpc_xprt *, unsigned long, unsigned long);
	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
	int (*enable_swap)(struct rpc_xprt *);
	void (*disable_swap)(struct rpc_xprt *);
	void (*inject_disconnect)(struct rpc_xprt *);
	int (*bc_setup)(struct rpc_xprt *, unsigned int);
	size_t (*bc_maxpayload)(struct rpc_xprt *);
	unsigned int (*bc_num_slots)(struct rpc_xprt *);
	void (*bc_free_rqst)(struct rpc_rqst *);
	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
};

struct rpc_wait {
	struct list_head list;
	struct list_head links;
	struct list_head timer_list;
};

struct rpc_message {
	const struct rpc_procinfo *rpc_proc;
	void *rpc_argp;
	void *rpc_resp;
	const struct cred *rpc_cred;
};

struct rpc_call_ops;

struct rpc_cred;

struct rpc_task {
	atomic_t tk_count;
	int tk_status;
	struct list_head tk_task;
	void (*tk_callback)(struct rpc_task *);
	void (*tk_action)(struct rpc_task *);
	unsigned long tk_timeout;
	unsigned long tk_runstate;
	struct rpc_wait_queue *tk_waitqueue;
	union {
		struct work_struct tk_work;
		struct rpc_wait tk_wait;
	} u;
	struct rpc_message tk_msg;
	void *tk_calldata;
	const struct rpc_call_ops *tk_ops;
	struct rpc_clnt *tk_client;
	struct rpc_xprt *tk_xprt;
	struct rpc_cred *tk_op_cred;
	struct rpc_rqst *tk_rqstp;
	struct workqueue_struct *tk_workqueue;
	ktime_t tk_start;
	pid_t tk_owner;
	int tk_rpc_status;
	unsigned short tk_flags;
	unsigned short tk_timeouts;
	unsigned short tk_pid;
	unsigned char tk_priority: 2;
	unsigned char tk_garb_retry: 2;
	unsigned char tk_cred_retry: 2;
};

struct xdr_stream;

typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);

typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);

struct rpc_procinfo {
	u32 p_proc;
	kxdreproc_t p_encode;
	kxdrdproc_t p_decode;
	unsigned int p_arglen;
	unsigned int p_replen;
	unsigned int p_timer;
	u32 p_statidx;
	const char *p_name;
};

struct xdr_buf {
	struct kvec head[1];
	struct kvec tail[1];
	struct bio_vec *bvec;
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int flags;
	unsigned int buflen;
	unsigned int len;
};

struct lwq_node {
	struct llist_node node;
};

struct rpc_rqst {
	struct rpc_xprt *rq_xprt;
	struct xdr_buf rq_snd_buf;
	struct xdr_buf rq_rcv_buf;
	struct rpc_task *rq_task;
	struct rpc_cred *rq_cred;
	__be32 rq_xid;
	int rq_cong;
	u32 rq_seqno;
	int rq_enc_pages_num;
	struct page **rq_enc_pages;
	void (*rq_release_snd_buf)(struct rpc_rqst *);
	union {
		struct list_head rq_list;
		struct rb_node rq_recv;
	};
	struct list_head rq_xmit;
	struct list_head rq_xmit2;
	void *rq_buffer;
	size_t rq_callsize;
	void *rq_rbuffer;
	size_t rq_rcvsize;
	size_t rq_xmit_bytes_sent;
	size_t rq_reply_bytes_recvd;
	struct xdr_buf rq_private_buf;
	unsigned long rq_majortimeo;
	unsigned long rq_minortimeo;
	unsigned long rq_timeout;
	ktime_t rq_rtt;
	unsigned int rq_retries;
	unsigned int rq_connect_cookie;
	atomic_t rq_pin;
	u32 rq_bytes_sent;
	ktime_t rq_xtime;
	int rq_ntrans;
	struct lwq_node rq_bc_list;
	unsigned long rq_bc_pa_state;
	struct list_head rq_bc_pa_list;
};

struct rpc_credops;

struct rpc_cred {
	struct hlist_node cr_hash;
	struct list_head cr_lru;
	struct callback_head cr_rcu;
	struct rpc_auth *cr_auth;
	const struct rpc_credops *cr_ops;
	unsigned long cr_expire;
	unsigned long cr_flags;
	refcount_t cr_count;
	const struct cred *cr_cred;
};

struct rpc_authops;

struct rpc_cred_cache;

struct rpc_auth {
	unsigned int au_cslack;
	unsigned int au_rslack;
	unsigned int au_verfsize;
	unsigned int au_ralign;
	unsigned long au_flags;
	const struct rpc_authops *au_ops;
	rpc_authflavor_t au_flavor;
	refcount_t au_count;
	struct rpc_cred_cache *au_credcache;
};

struct rpc_auth_create_args;

struct auth_cred;

struct rpcsec_gss_info;

struct rpc_authops {
	struct module *owner;
	rpc_authflavor_t au_flavor;
	char *au_name;
	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
	void (*destroy)(struct rpc_auth *);
	int (*hash_cred)(struct auth_cred *, unsigned int);
	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
	int (*ping)(struct rpc_clnt *);
};

struct rpc_auth_create_args {
	rpc_authflavor_t pseudoflavor;
	const char *target_name;
};

struct auth_cred {
	const struct cred *cred;
	const char *principal;
};

struct rpcsec_gss_oid {
	unsigned int len;
	u8 data[32];
};

struct rpcsec_gss_info {
	struct rpcsec_gss_oid oid;
	u32 qop;
	u32 service;
};

struct rpc_credops {
	const char *cr_name;
	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
	void (*crdestroy)(struct rpc_cred *);
	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
	int (*crrefresh)(struct rpc_task *);
	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
	int (*crkey_timeout)(struct rpc_cred *);
	char * (*crstringify_acceptor)(struct rpc_cred *);
	bool (*crneed_reencode)(struct rpc_task *);
};

struct xdr_stream {
	__be32 *p;
	struct xdr_buf *buf;
	__be32 *end;
	struct kvec *iov;
	struct kvec scratch;
	struct page **page_ptr;
	void *page_kaddr;
	unsigned int nwords;
	struct rpc_rqst *rqst;
};

struct rpc_call_ops {
	void (*rpc_call_prepare)(struct rpc_task *, void *);
	void (*rpc_call_done)(struct rpc_task *, void *);
	void (*rpc_count_stats)(struct rpc_task *, void *);
	void (*rpc_release)(void *);
};

struct xprt_create;

struct xprt_class {
	struct list_head list;
	int ident;
	struct rpc_xprt * (*setup)(struct xprt_create *);
	struct module *owner;
	char name[32];
	const char *netid[0];
};

struct xprt_create {
	int ident;
	struct net *net;
	struct sockaddr *srcaddr;
	struct sockaddr *dstaddr;
	size_t addrlen;
	const char *servername;
	struct svc_xprt *bc_xprt;
	struct rpc_xprt_switch *bc_xps;
	unsigned int flags;
	struct xprtsec_parms xprtsec;
	unsigned long connect_timeout;
	unsigned long reconnect_timeout;
};

struct rpc_sysfs_xprt_switch;

struct rpc_xprt_switch {
	spinlock_t xps_lock;
	struct kref xps_kref;
	unsigned int xps_id;
	unsigned int xps_nxprts;
	unsigned int xps_nactive;
	unsigned int xps_nunique_destaddr_xprts;
	atomic_long_t xps_queuelen;
	struct list_head xps_xprt_list;
	struct net *xps_net;
	const struct rpc_xprt_iter_ops *xps_iter_ops;
	struct rpc_sysfs_xprt_switch *xps_sysfs;
	struct callback_head xps_rcu;
};

struct rpc_xprt_iter_ops {
	void (*xpi_rewind)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
};

struct rpc_stat {
	const struct rpc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int netreconn;
	unsigned int rpccnt;
	unsigned int rpcretrans;
	unsigned int rpcauthrefresh;
	unsigned int rpcgarbage;
};

struct rpc_version;

struct rpc_program {
	const char *name;
	u32 number;
	unsigned int nrvers;
	const struct rpc_version **version;
	struct rpc_stat *stats;
	const char *pipe_dir_name;
};

struct rpc_version {
	u32 number;
	unsigned int nrprocs;
	const struct rpc_procinfo *procs;
	unsigned int *counts;
};

struct rpc_sysfs_client {
	struct kobject kobject;
	struct net *net;
	struct rpc_clnt *clnt;
	struct rpc_xprt_switch *xprt_switch;
};

struct nlmclnt_operations;

struct nfs_fh;

struct nfs_fsinfo;

struct nfs_fattr;

struct nfs_access_entry;

struct nfs_unlinkdata;

struct nfs_renamedata;

struct nfs_readdir_arg;

struct nfs_readdir_res;

struct nfs_fsstat;

struct nfs_pathconf;

struct nfs_entry;

struct nfs_pgio_header;

struct nfs_commit_data;

struct nfs_open_context;

struct nfs_client_initdata;

struct nfs_rpc_ops {
	u32 version;
	const struct dentry_operations *dentry_ops;
	const struct inode_operations *dir_inode_ops;
	const struct inode_operations *file_inode_ops;
	const struct file_operations *file_ops;
	const struct nlmclnt_operations *nlmclnt_ops;
	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*submount)(struct fs_context *, struct nfs_server *);
	int (*try_get_tree)(struct fs_context *);
	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct inode *);
	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
	int (*lookup)(struct inode *, struct dentry *, struct nfs_fh *, struct nfs_fattr *);
	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *);
	int (*access)(struct inode *, struct nfs_access_entry *, const struct cred *);
	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
	int (*remove)(struct inode *, struct dentry *);
	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
	int (*unlink_done)(struct rpc_task *, struct inode *);
	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
	int (*link)(struct inode *, struct inode *, const struct qstr *);
	int (*symlink)(struct inode *, struct dentry *, struct folio *, unsigned int, struct iattr *);
	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
	int (*rmdir)(struct inode *, const struct qstr *);
	int (*readdir)(struct nfs_readdir_arg *, struct nfs_readdir_res *);
	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
	int (*lock)(struct file *, int, struct file_lock *);
	int (*lock_check_bounds)(const struct file_lock *);
	void (*clear_acl_cache)(struct inode *);
	void (*close_context)(struct nfs_open_context *, int);
	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
	int (*have_delegation)(struct inode *, fmode_t);
	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
	void (*free_client)(struct nfs_client *);
	struct nfs_server * (*create_server)(struct fs_context *);
	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
	int (*discover_trunking)(struct nfs_server *, struct nfs_fh *);
	void (*enable_swap)(struct inode *);
	void (*disable_swap)(struct inode *);
};

struct nlmclnt_operations {
	void (*nlmclnt_alloc_call)(void *);
	bool (*nlmclnt_unlock_prepare)(struct rpc_task *, void *);
	void (*nlmclnt_release_call)(void *);
};

struct nfs_fh {
	unsigned short size;
	unsigned char data[128];
};

struct nfs_fsinfo {
	struct nfs_fattr *fattr;
	__u32 rtmax;
	__u32 rtpref;
	__u32 rtmult;
	__u32 wtmax;
	__u32 wtpref;
	__u32 wtmult;
	__u32 dtpref;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	__u32 lease_time;
	__u32 nlayouttypes;
	__u32 layouttype[8];
	__u32 blksize;
	__u32 clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	__u32 xattr_support;
};

struct nfs4_string;

struct nfs4_threshold;

struct nfs4_label;

struct nfs_fattr {
	unsigned int valid;
	umode_t mode;
	__u32 nlink;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	__u64 size;
	union {
		struct {
			__u32 blocksize;
			__u32 blocks;
		} nfs2;
		struct {
			__u64 used;
		} nfs3;
	} du;
	struct nfs_fsid fsid;
	__u64 fileid;
	__u64 mounted_on_fileid;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	__u64 change_attr;
	__u64 pre_change_attr;
	__u64 pre_size;
	struct timespec64 pre_mtime;
	struct timespec64 pre_ctime;
	unsigned long time_start;
	unsigned long gencount;
	struct nfs4_string *owner_name;
	struct nfs4_string *group_name;
	struct nfs4_threshold *mdsthreshold;
	struct nfs4_label *label;
};

struct nfs4_string {
	unsigned int len;
	char *data;
};

struct nfs4_threshold {
	__u32 bm;
	__u32 l_type;
	__u64 rd_sz;
	__u64 wr_sz;
	__u64 rd_io_sz;
	__u64 wr_io_sz;
};

struct nfs4_label {
	uint32_t lfs;
	uint32_t pi;
	u32 len;
	char *label;
};

struct nfs_access_entry {
	struct rb_node rb_node;
	struct list_head lru;
	kuid_t fsuid;
	kgid_t fsgid;
	struct group_info *group_info;
	u64 timestamp;
	__u32 mask;
	struct callback_head callback_head;
};

struct nfs4_slot;

struct nfs4_sequence_args {
	struct nfs4_slot *sa_slot;
	u8 sa_cache_this: 1;
	u8 sa_privileged: 1;
};

struct nfs_removeargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct qstr name;
};

struct nfs4_sequence_res {
	struct nfs4_slot *sr_slot;
	unsigned long sr_timestamp;
	int sr_status;
	u32 sr_status_flags;
	u32 sr_highest_slotid;
	u32 sr_target_highest_slotid;
};

struct nfs4_change_info {
	u32 atomic;
	u64 before;
	u64 after;
};

struct nfs_removeres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs_fattr *dir_attr;
	struct nfs4_change_info cinfo;
};

struct nfs_unlinkdata {
	struct nfs_removeargs args;
	struct nfs_removeres res;
	struct dentry *dentry;
	wait_queue_head_t wq;
	const struct cred *cred;
	struct nfs_fattr dir_attr;
	long timeout;
};

struct nfs_renameargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *old_dir;
	const struct nfs_fh *new_dir;
	const struct qstr *old_name;
	const struct qstr *new_name;
};

struct nfs_renameres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs4_change_info old_cinfo;
	struct nfs_fattr *old_fattr;
	struct nfs4_change_info new_cinfo;
	struct nfs_fattr *new_fattr;
};

struct nfs_renamedata {
	struct nfs_renameargs args;
	struct nfs_renameres res;
	struct rpc_task task;
	const struct cred *cred;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct nfs_fattr old_fattr;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct nfs_fattr new_fattr;
	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
	long timeout;
	bool cancelled;
};

struct nfs_readdir_arg {
	struct dentry *dentry;
	const struct cred *cred;
	__be32 *verf;
	u64 cookie;
	struct page **pages;
	unsigned int page_len;
	bool plus;
};

struct nfs_readdir_res {
	__be32 *verf;
};

struct nfs_fsstat {
	struct nfs_fattr *fattr;
	__u64 tbytes;
	__u64 fbytes;
	__u64 abytes;
	__u64 tfiles;
	__u64 ffiles;
	__u64 afiles;
};

struct nfs_pathconf {
	struct nfs_fattr *fattr;
	__u32 max_link;
	__u32 max_namelen;
};

struct nfs_entry {
	__u64 ino;
	__u64 cookie;
	const char *name;
	unsigned int len;
	int eof;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	unsigned char d_type;
	struct nfs_server *server;
};

struct nfs_write_verifier {
	char data[8];
};

enum nfs3_stable_how {
	NFS_UNSTABLE = 0,
	NFS_DATA_SYNC = 1,
	NFS_FILE_SYNC = 2,
	NFS_INVALID_STABLE_HOW = -1,
};

struct nfs_writeverf {
	struct nfs_write_verifier verifier;
	enum nfs3_stable_how committed;
};

struct nfs_lock_context;

struct nfs_pgio_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct nfs_open_context *context;
	struct nfs_lock_context *lock_context;
	nfs4_stateid stateid;
	__u64 offset;
	__u32 count;
	unsigned int pgbase;
	struct page **pages;
	union {
		unsigned int replen;
		struct {
			const u32 *bitmask;
			u32 bitmask_store[3];
			enum nfs3_stable_how stable;
		};
	};
};

struct nfs_pgio_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	__u64 count;
	__u32 op_status;
	union {
		struct {
			unsigned int replen;
			int eof;
			void *scratch;
		};
		struct {
			struct nfs_writeverf *verf;
			const struct nfs_server *server;
		};
	};
};

struct nfs_page_array {
	struct page **pagevec;
	unsigned int npages;
	struct page *page_array[8];
};

struct nfs_page;

struct pnfs_layout_segment;

struct nfs_pgio_completion_ops;

struct nfs_rw_ops;

struct nfs_io_completion;

struct nfs_direct_req;

struct nfs_pgio_header {
	struct inode *inode;
	const struct cred *cred;
	struct list_head pages;
	struct nfs_page *req;
	struct nfs_writeverf verf;
	fmode_t rw_mode;
	struct pnfs_layout_segment *lseg;
	loff_t io_start;
	const struct rpc_call_ops *mds_ops;
	void (*release)(struct nfs_pgio_header *);
	const struct nfs_pgio_completion_ops *completion_ops;
	const struct nfs_rw_ops *rw_ops;
	struct nfs_io_completion *io_completion;
	struct nfs_direct_req *dreq;
	int pnfs_error;
	int error;
	unsigned int good_bytes;
	unsigned long flags;
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct nfs_pgio_args args;
	struct nfs_pgio_res res;
	unsigned long timestamp;
	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
	__u64 mds_offset;
	struct nfs_page_array page_array;
	struct nfs_client *ds_clp;
	u32 ds_commit_idx;
	u32 pgio_mirror_idx;
};

struct nfs_page {
	struct list_head wb_list;
	union {
		struct page *wb_page;
		struct folio *wb_folio;
	};
	struct nfs_lock_context *wb_lock_context;
	unsigned long wb_index;
	unsigned int wb_offset;
	unsigned int wb_pgbase;
	unsigned int wb_bytes;
	struct kref wb_kref;
	unsigned long wb_flags;
	struct nfs_write_verifier wb_verf;
	struct nfs_page *wb_this_page;
	struct nfs_page *wb_head;
	unsigned short wb_nio;
};

struct nfs_lock_context {
	refcount_t count;
	struct list_head list;
	struct nfs_open_context *open_context;
	fl_owner_t lockowner;
	atomic_t io_count;
	struct callback_head callback_head;
};

struct nfs_open_context {
	struct nfs_lock_context lock_context;
	fl_owner_t flock_owner;
	struct dentry *dentry;
	const struct cred *cred;
	struct rpc_cred __attribute__((btf_type_tag("rcu"))) *ll_cred;
	struct nfs4_state *state;
	fmode_t mode;
	unsigned long flags;
	int error;
	struct list_head list;
	struct nfs4_threshold *mdsthreshold;
	struct callback_head callback_head;
};

struct nfs_pgio_completion_ops {
	void (*error_cleanup)(struct list_head *, int);
	void (*init_hdr)(struct nfs_pgio_header *);
	void (*completion)(struct nfs_pgio_header *);
	void (*reschedule_io)(struct nfs_pgio_header *);
};

struct rpc_task_setup;

struct nfs_rw_ops {
	struct nfs_pgio_header * (*rw_alloc_header)();
	void (*rw_free_header)(struct nfs_pgio_header *);
	int (*rw_done)(struct rpc_task *, struct nfs_pgio_header *, struct inode *);
	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *, const struct nfs_rpc_ops *, struct rpc_task_setup *, int);
};

struct rpc_task_setup {
	struct rpc_task *task;
	struct rpc_clnt *rpc_client;
	struct rpc_xprt *rpc_xprt;
	struct rpc_cred *rpc_op_cred;
	const struct rpc_message *rpc_message;
	const struct rpc_call_ops *callback_ops;
	void *callback_data;
	struct workqueue_struct *workqueue;
	unsigned short flags;
	signed char priority;
};

struct nfs_mds_commit_info {
	atomic_t rpcs_out;
	atomic_long_t ncommit;
	struct list_head list;
};

struct pnfs_commit_ops;

struct pnfs_ds_commit_info {
	struct list_head commits;
	unsigned int nwritten;
	unsigned int ncommitting;
	const struct pnfs_commit_ops *ops;
};

struct nfs_direct_req {
	struct kref kref;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct kiocb *iocb;
	struct inode *inode;
	atomic_t io_count;
	spinlock_t lock;
	loff_t io_start;
	ssize_t count;
	ssize_t max_count;
	ssize_t bytes_left;
	ssize_t error;
	struct completion completion;
	struct nfs_mds_commit_info mds_cinfo;
	struct pnfs_ds_commit_info ds_cinfo;
	struct work_struct work;
	int flags;
};

struct nfs_commit_info;

struct pnfs_commit_ops {
	void (*setup_ds_info)(struct pnfs_ds_commit_info *, struct pnfs_layout_segment *);
	void (*release_ds_info)(struct pnfs_ds_commit_info *, struct inode *);
	int (*commit_pagelist)(struct inode *, struct list_head *, int, struct nfs_commit_info *);
	void (*mark_request_commit)(struct nfs_page *, struct pnfs_layout_segment *, struct nfs_commit_info *, u32);
	void (*clear_request_commit)(struct nfs_page *, struct nfs_commit_info *);
	int (*scan_commit_lists)(struct nfs_commit_info *, int);
	void (*recover_commit_reqs)(struct list_head *, struct nfs_commit_info *);
	struct nfs_page * (*search_commit_reqs)(struct nfs_commit_info *, struct folio *);
};

struct nfs_commitargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	__u64 offset;
	__u32 count;
	const u32 *bitmask;
};

struct nfs_commitres {
	struct nfs4_sequence_res seq_res;
	__u32 op_status;
	struct nfs_fattr *fattr;
	struct nfs_writeverf *verf;
	const struct nfs_server *server;
};

struct nfs_commit_completion_ops;

struct nfs_commit_data {
	struct rpc_task task;
	struct inode *inode;
	const struct cred *cred;
	struct nfs_fattr fattr;
	struct nfs_writeverf verf;
	struct list_head pages;
	struct list_head list;
	struct nfs_direct_req *dreq;
	struct nfs_commitargs args;
	struct nfs_commitres res;
	struct nfs_open_context *context;
	struct pnfs_layout_segment *lseg;
	struct nfs_client *ds_clp;
	int ds_commit_index;
	loff_t lwb;
	const struct rpc_call_ops *mds_ops;
	const struct nfs_commit_completion_ops *completion_ops;
	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
	unsigned long flags;
};

struct nfs_commit_completion_ops {
	void (*completion)(struct nfs_commit_data *);
	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
};

struct nfs_commit_info {
	struct inode *inode;
	struct nfs_mds_commit_info *mds;
	struct pnfs_ds_commit_info *ds;
	struct nfs_direct_req *dreq;
	const struct nfs_commit_completion_ops *completion_ops;
};

struct nfs_client_initdata {
	unsigned long init_flags;
	const char *hostname;
	const struct __kernel_sockaddr_storage *addr;
	const char *nodename;
	const char *ip_addr;
	size_t addrlen;
	struct nfs_subversion *nfs_mod;
	int proto;
	u32 minorversion;
	unsigned int nconnect;
	unsigned int max_connect;
	struct net *net;
	const struct rpc_timeout *timeparms;
	const struct cred *cred;
	struct xprtsec_parms xprtsec;
	unsigned long connect_timeout;
	unsigned long reconnect_timeout;
};

struct nfs_seqid;

struct nfs4_state_recovery_ops;

struct nfs4_state_maintenance_ops;

struct nfs4_mig_recovery_ops;

struct nfs4_minor_version_ops {
	u32 minor_version;
	unsigned int init_caps;
	int (*init_client)(struct nfs_client *);
	void (*shutdown_client)(struct nfs_client *);
	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
	int (*test_and_free_expired)(struct nfs_server *, nfs4_stateid *, const struct cred *);
	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
	const struct rpc_call_ops *call_sync_ops;
	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
	const struct nfs4_state_maintenance_ops *state_renewal_ops;
	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
};

struct nfs_seqid {
	struct nfs_seqid_counter *sequence;
	struct list_head list;
	struct rpc_task *task;
};

struct nfs4_state_recovery_ops {
	int owner_flag_bit;
	int state_flag_bit;
	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
	int (*establish_clid)(struct nfs_client *, const struct cred *);
	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
};

struct nfs4_state_maintenance_ops {
	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
	int (*renew_lease)(struct nfs_client *, const struct cred *);
};

struct nfs4_fs_locations;

struct nfs4_mig_recovery_ops {
	int (*get_locations)(struct nfs_server *, struct nfs_fh *, struct nfs4_fs_locations *, struct page *, const struct cred *);
	int (*fsid_present)(struct inode *, const struct cred *);
};

struct nfs4_pathname {
	unsigned int ncomponents;
	struct nfs4_string components[512];
};

struct nfs4_fs_location {
	unsigned int nservers;
	struct nfs4_string servers[10];
	struct nfs4_pathname rootpath;
};

struct nfs4_fs_locations {
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
	struct nfs4_pathname fs_path;
	int nlocations;
	struct nfs4_fs_location locations[10];
};

struct nfs41_server_owner {
	uint64_t minor_id;
	uint32_t major_id_sz;
	char major_id[1024];
};

struct nfs41_server_scope {
	uint32_t server_scope_sz;
	char server_scope[1024];
};

struct nfstime4 {
	u64 seconds;
	u32 nseconds;
};

struct nfs41_impl_id {
	char domain[1025];
	char name[1025];
	struct nfstime4 date;
};

struct nfs_iostats {
	unsigned long long bytes[8];
	unsigned long events[27];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

enum xprt_transports {
	XPRT_TRANSPORT_UDP = 17,
	XPRT_TRANSPORT_TCP = 6,
	XPRT_TRANSPORT_BC_TCP = -2147483642,
	XPRT_TRANSPORT_RDMA = 256,
	XPRT_TRANSPORT_BC_RDMA = -2147483392,
	XPRT_TRANSPORT_LOCAL = 257,
	XPRT_TRANSPORT_TCP_TLS = 258,
};

struct lwq {
	spinlock_t lock;
	struct llist_node *ready;
	struct llist_head new;
};

struct svc_program;

struct svc_stat;

struct svc_pool;

struct svc_serv {
	struct svc_program *sv_program;
	struct svc_stat *sv_stats;
	spinlock_t sv_lock;
	struct kref sv_refcnt;
	unsigned int sv_nrthreads;
	unsigned int sv_maxconn;
	unsigned int sv_max_payload;
	unsigned int sv_max_mesg;
	unsigned int sv_xdrsize;
	struct list_head sv_permsocks;
	struct list_head sv_tempsocks;
	int sv_tmpcnt;
	struct timer_list sv_temptimer;
	char *sv_name;
	unsigned int sv_nrpools;
	struct svc_pool *sv_pools;
	int (*sv_threadfn)(void *);
	struct lwq sv_cb_list;
	bool sv_bc_enabled;
};

enum svc_auth_status {
	SVC_GARBAGE = 1,
	SVC_SYSERR = 2,
	SVC_VALID = 3,
	SVC_NEGATIVE = 4,
	SVC_OK = 5,
	SVC_DROP = 6,
	SVC_CLOSE = 7,
	SVC_DENIED = 8,
	SVC_PENDING = 9,
	SVC_COMPLETE = 10,
};

struct svc_version;

struct svc_rqst;

struct svc_process_info;

struct svc_program {
	struct svc_program *pg_next;
	u32 pg_prog;
	unsigned int pg_lovers;
	unsigned int pg_hivers;
	unsigned int pg_nvers;
	const struct svc_version **pg_vers;
	char *pg_name;
	char *pg_class;
	struct svc_stat *pg_stats;
	enum svc_auth_status (*pg_authenticate)(struct svc_rqst *);
	__be32 (*pg_init_request)(struct svc_rqst *, const struct svc_program *, struct svc_process_info *);
	int (*pg_rpcbind_set)(struct net *, const struct svc_program *, u32, int, unsigned short, unsigned short);
};

struct svc_procedure;

struct svc_version {
	u32 vs_vers;
	u32 vs_nproc;
	const struct svc_procedure *vs_proc;
	unsigned long __attribute__((btf_type_tag("percpu"))) *vs_count;
	u32 vs_xdrsize;
	bool vs_hidden;
	bool vs_rpcb_optnl;
	bool vs_need_cong_ctrl;
	int (*vs_dispatch)(struct svc_rqst *);
};

struct svc_procedure {
	__be32 (*pc_func)(struct svc_rqst *);
	bool (*pc_decode)(struct svc_rqst *, struct xdr_stream *);
	bool (*pc_encode)(struct svc_rqst *, struct xdr_stream *);
	void (*pc_release)(struct svc_rqst *);
	unsigned int pc_argsize;
	unsigned int pc_argzero;
	unsigned int pc_ressize;
	unsigned int pc_cachetype;
	unsigned int pc_xdrressize;
	const char *pc_name;
};

struct gss_api_mech;

struct svc_cred {
	kuid_t cr_uid;
	kgid_t cr_gid;
	struct group_info *cr_group_info;
	u32 cr_flavor;
	char *cr_raw_principal;
	char *cr_principal;
	char *cr_targ_princ;
	struct gss_api_mech *cr_gss_mech;
};

struct cache_deferred_req;

struct cache_req {
	struct cache_deferred_req * (*defer)(struct cache_req *);
	unsigned long thread_wait;
};

struct auth_ops;

struct svc_deferred_req;

struct auth_domain;

struct svc_rqst {
	struct list_head rq_all;
	struct llist_node rq_idle;
	struct callback_head rq_rcu_head;
	struct svc_xprt *rq_xprt;
	struct __kernel_sockaddr_storage rq_addr;
	size_t rq_addrlen;
	struct __kernel_sockaddr_storage rq_daddr;
	size_t rq_daddrlen;
	struct svc_serv *rq_server;
	struct svc_pool *rq_pool;
	const struct svc_procedure *rq_procinfo;
	struct auth_ops *rq_authop;
	struct svc_cred rq_cred;
	void *rq_xprt_ctxt;
	struct svc_deferred_req *rq_deferred;
	struct xdr_buf rq_arg;
	struct xdr_stream rq_arg_stream;
	struct xdr_stream rq_res_stream;
	struct page *rq_scratch_page;
	struct xdr_buf rq_res;
	struct page *rq_pages[260];
	struct page **rq_respages;
	struct page **rq_next_page;
	struct page **rq_page_end;
	struct folio_batch rq_fbatch;
	struct kvec rq_vec[259];
	struct bio_vec rq_bvec[259];
	__be32 rq_xid;
	u32 rq_prog;
	u32 rq_vers;
	u32 rq_proc;
	u32 rq_prot;
	int rq_cachetype;
	unsigned long rq_flags;
	ktime_t rq_qtime;
	void *rq_argp;
	void *rq_resp;
	__be32 *rq_accept_statp;
	void *rq_auth_data;
	__be32 rq_auth_stat;
	int rq_auth_slack;
	int rq_reserved;
	ktime_t rq_stime;
	struct cache_req rq_chandle;
	struct auth_domain *rq_client;
	struct auth_domain *rq_gssclient;
	struct task_struct *rq_task;
	struct net *rq_bc_net;
	void **rq_lease_breaker;
	unsigned int rq_status_counter;
};

struct svc_pool {
	unsigned int sp_id;
	struct lwq sp_xprts;
	atomic_t sp_nrthreads;
	struct list_head sp_all_threads;
	struct llist_head sp_idle_threads;
	struct percpu_counter sp_messages_arrived;
	struct percpu_counter sp_sockets_queued;
	struct percpu_counter sp_threads_woken;
	unsigned long sp_flags;
};

struct auth_ops {
	char *name;
	struct module *owner;
	int flavour;
	enum svc_auth_status (*accept)(struct svc_rqst *);
	int (*release)(struct svc_rqst *);
	void (*domain_release)(struct auth_domain *);
	enum svc_auth_status (*set_client)(struct svc_rqst *);
};

struct auth_domain {
	struct kref ref;
	struct hlist_node hash;
	char *name;
	struct auth_ops *flavour;
	struct callback_head callback_head;
};

struct gss_api_ops;

struct pf_desc;

struct gss_api_mech {
	struct list_head gm_list;
	struct module *gm_owner;
	struct rpcsec_gss_oid gm_oid;
	char *gm_name;
	const struct gss_api_ops *gm_ops;
	int gm_pf_num;
	struct pf_desc *gm_pfs;
	const char *gm_upcall_enctypes;
};

struct gss_ctx;

struct xdr_netobj;

struct gss_api_ops {
	int (*gss_import_sec_context)(const void *, size_t, struct gss_ctx *, time64_t *, gfp_t);
	u32 (*gss_get_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_verify_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_wrap)(struct gss_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*gss_unwrap)(struct gss_ctx *, int, int, struct xdr_buf *);
	void (*gss_delete_sec_context)(void *);
};

struct gss_ctx {
	struct gss_api_mech *mech_type;
	void *internal_ctx_id;
	unsigned int slack;
	unsigned int align;
};

struct xdr_netobj {
	unsigned int len;
	u8 *data;
};

struct pf_desc {
	u32 pseudoflavor;
	u32 qop;
	u32 service;
	char *name;
	char *auth_domain_name;
	struct auth_domain *domain;
	bool datatouch;
};

struct cache_head;

struct cache_deferred_req {
	struct hlist_node hash;
	struct list_head recent;
	struct cache_head *item;
	void *owner;
	void (*revisit)(struct cache_deferred_req *, int);
};

struct svc_deferred_req {
	u32 prot;
	struct svc_xprt *xprt;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	struct __kernel_sockaddr_storage daddr;
	size_t daddrlen;
	void *xprt_ctxt;
	struct cache_deferred_req handle;
	int argslen;
	__be32 args[0];
};

struct cache_head {
	struct hlist_node cache_list;
	time64_t expiry_time;
	time64_t last_refresh;
	struct kref ref;
	unsigned long flags;
};

struct svc_stat {
	struct svc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int rpccnt;
	unsigned int rpcbadfmt;
	unsigned int rpcbadauth;
	unsigned int rpcbadclnt;
};

struct svc_process_info {
	union {
		int (*dispatch)(struct svc_rqst *);
		struct {
			unsigned int lovers;
			unsigned int hivers;
		} mismatch;
	};
};

struct nfs4_slot {
	struct nfs4_slot_table *table;
	struct nfs4_slot *next;
	unsigned long generation;
	u32 slot_nr;
	u32 seq_nr;
	u32 seq_nr_last_acked;
	u32 seq_nr_highest_sent;
	unsigned int privileged: 1;
	unsigned int seq_done: 1;
};

struct nfs4_slot_table {
	struct nfs4_session *session;
	struct nfs4_slot *slots;
	unsigned long used_slots[16];
	spinlock_t slot_tbl_lock;
	struct rpc_wait_queue slot_tbl_waitq;
	wait_queue_head_t slot_waitq;
	u32 max_slots;
	u32 max_slotid;
	u32 highest_used_slotid;
	u32 target_highest_slotid;
	u32 server_highest_slotid;
	s32 d_target_highest_slotid;
	s32 d2_target_highest_slotid;
	unsigned long generation;
	struct completion complete;
	unsigned long slot_tbl_state;
};

struct nfs4_sessionid {
	unsigned char data[16];
};

struct nfs4_channel_attrs {
	u32 max_rqst_sz;
	u32 max_resp_sz;
	u32 max_resp_sz_cached;
	u32 max_ops;
	u32 max_reqs;
};

struct nfs4_session {
	struct nfs4_sessionid sess_id;
	u32 flags;
	unsigned long session_state;
	u32 hash_alg;
	u32 ssv_len;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_slot_table fc_slot_table;
	struct nfs4_channel_attrs bc_attrs;
	struct nfs4_slot_table bc_slot_table;
	struct nfs_client *clp;
};

struct pnfs_layout_range {
	u32 iomode;
	u64 offset;
	u64 length;
};

struct pnfs_layout_hdr;

struct pnfs_layout_segment {
	struct list_head pls_list;
	struct list_head pls_lc_list;
	struct list_head pls_commits;
	struct pnfs_layout_range pls_range;
	refcount_t pls_refcount;
	u32 pls_seq;
	unsigned long pls_flags;
	struct pnfs_layout_hdr *pls_layout;
};

enum pnfs_iomode {
	IOMODE_READ = 1,
	IOMODE_RW = 2,
	IOMODE_ANY = 3,
};

struct pnfs_layout_hdr {
	refcount_t plh_refcount;
	atomic_t plh_outstanding;
	struct list_head plh_layouts;
	struct list_head plh_bulk_destroy;
	struct list_head plh_segs;
	struct list_head plh_return_segs;
	unsigned long plh_block_lgets;
	unsigned long plh_retry_timestamp;
	unsigned long plh_flags;
	nfs4_stateid plh_stateid;
	u32 plh_barrier;
	u32 plh_return_seq;
	enum pnfs_iomode plh_return_iomode;
	loff_t plh_lwb;
	const struct cred *plh_lc_cred;
	struct inode *plh_inode;
	struct callback_head plh_rcu;
};

enum pnfs_try_status {
	PNFS_ATTEMPTED = 0,
	PNFS_NOT_ATTEMPTED = 1,
	PNFS_TRY_AGAIN = 2,
};

struct nfs4_layoutget_res;

struct nfs_pageio_ops;

struct nfs4_deviceid_node;

struct pnfs_device;

struct nfs4_layoutreturn_args;

struct nfs4_layoutcommit_data;

struct nfs4_layoutcommit_args;

struct nfs42_layoutstat_args;

struct pnfs_layoutdriver_type {
	struct list_head pnfs_tblid;
	const u32 id;
	const char *name;
	struct module *owner;
	unsigned int flags;
	unsigned int max_deviceinfo_size;
	unsigned int max_layoutget_response;
	int (*set_layoutdriver)(struct nfs_server *, const struct nfs_fh *);
	int (*clear_layoutdriver)(struct nfs_server *);
	struct pnfs_layout_hdr * (*alloc_layout_hdr)(struct inode *, gfp_t);
	void (*free_layout_hdr)(struct pnfs_layout_hdr *);
	struct pnfs_layout_segment * (*alloc_lseg)(struct pnfs_layout_hdr *, struct nfs4_layoutget_res *, gfp_t);
	void (*free_lseg)(struct pnfs_layout_segment *);
	void (*add_lseg)(struct pnfs_layout_hdr *, struct pnfs_layout_segment *, struct list_head *);
	void (*return_range)(struct pnfs_layout_hdr *, struct pnfs_layout_range *);
	const struct nfs_pageio_ops *pg_read_ops;
	const struct nfs_pageio_ops *pg_write_ops;
	struct pnfs_ds_commit_info * (*get_ds_info)(struct inode *);
	int (*sync)(struct inode *, bool);
	enum pnfs_try_status (*read_pagelist)(struct nfs_pgio_header *);
	enum pnfs_try_status (*write_pagelist)(struct nfs_pgio_header *, int);
	void (*free_deviceid_node)(struct nfs4_deviceid_node *);
	struct nfs4_deviceid_node * (*alloc_deviceid_node)(struct nfs_server *, struct pnfs_device *, gfp_t);
	int (*prepare_layoutreturn)(struct nfs4_layoutreturn_args *);
	void (*cleanup_layoutcommit)(struct nfs4_layoutcommit_data *);
	int (*prepare_layoutcommit)(struct nfs4_layoutcommit_args *);
	int (*prepare_layoutstats)(struct nfs42_layoutstat_args *);
	void (*cancel_io)(struct pnfs_layout_segment *);
};

struct nfs4_layoutdriver_data;

struct nfs4_layoutget_res {
	struct nfs4_sequence_res seq_res;
	int status;
	__u32 return_on_close;
	struct pnfs_layout_range range;
	__u32 type;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data *layoutp;
};

struct nfs4_layoutdriver_data {
	struct page **pages;
	__u32 pglen;
	__u32 len;
};

struct nfs_pageio_descriptor;

struct nfs_pgio_mirror;

struct nfs_pageio_ops {
	void (*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);
	size_t (*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *, struct nfs_page *);
	int (*pg_doio)(struct nfs_pageio_descriptor *);
	unsigned int (*pg_get_mirror_count)(struct nfs_pageio_descriptor *, struct nfs_page *);
	void (*pg_cleanup)(struct nfs_pageio_descriptor *);
	struct nfs_pgio_mirror * (*pg_get_mirror)(struct nfs_pageio_descriptor *, u32);
	u32 (*pg_set_mirror)(struct nfs_pageio_descriptor *, u32);
};

struct nfs_pgio_mirror {
	struct list_head pg_list;
	unsigned long pg_bytes_written;
	size_t pg_count;
	size_t pg_bsize;
	unsigned int pg_base;
	unsigned char pg_recoalesce: 1;
};

struct nfs_pageio_descriptor {
	struct inode *pg_inode;
	const struct nfs_pageio_ops *pg_ops;
	const struct nfs_rw_ops *pg_rw_ops;
	int pg_ioflags;
	int pg_error;
	const struct rpc_call_ops *pg_rpc_callops;
	const struct nfs_pgio_completion_ops *pg_completion_ops;
	struct pnfs_layout_segment *pg_lseg;
	struct nfs_io_completion *pg_io_completion;
	struct nfs_direct_req *pg_dreq;
	unsigned int pg_bsize;
	u32 pg_mirror_count;
	struct nfs_pgio_mirror *pg_mirrors;
	struct nfs_pgio_mirror pg_mirrors_static[1];
	struct nfs_pgio_mirror *pg_mirrors_dynamic;
	u32 pg_mirror_idx;
	unsigned short pg_maxretrans;
	unsigned char pg_moreio: 1;
};

struct nfs4_deviceid {
	char data[16];
};

struct nfs4_deviceid_node {
	struct hlist_node node;
	struct hlist_node tmpnode;
	const struct pnfs_layoutdriver_type *ld;
	const struct nfs_client *nfs_client;
	unsigned long flags;
	unsigned long timestamp_unavailable;
	struct nfs4_deviceid deviceid;
	struct callback_head rcu;
	atomic_t ref;
};

struct pnfs_device {
	struct nfs4_deviceid dev_id;
	unsigned int layout_type;
	unsigned int mincount;
	unsigned int maxcount;
	struct page **pages;
	unsigned int pgbase;
	unsigned int pglen;
	unsigned char nocache: 1;
};

struct nfs4_xdr_opaque_data;

struct nfs4_layoutreturn_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_layout_hdr *layout;
	struct inode *inode;
	struct pnfs_layout_range range;
	nfs4_stateid stateid;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data *ld_private;
};

struct nfs4_xdr_opaque_ops;

struct nfs4_xdr_opaque_data {
	const struct nfs4_xdr_opaque_ops *ops;
	void *data;
};

struct nfs4_xdr_opaque_ops {
	void (*encode)(struct xdr_stream *, const void *, const struct nfs4_xdr_opaque_data *);
	void (*free)(struct nfs4_xdr_opaque_data *);
};

struct nfs4_layoutcommit_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid stateid;
	__u64 lastbytewritten;
	struct inode *inode;
	const u32 *bitmask;
	size_t layoutupdate_len;
	struct page *layoutupdate_page;
	struct page **layoutupdate_pages;
	__be32 *start_p;
};

struct nfs4_layoutcommit_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
	int status;
};

struct nfs4_layoutcommit_data {
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct list_head lseg_list;
	const struct cred *cred;
	struct inode *inode;
	struct nfs4_layoutcommit_args args;
	struct nfs4_layoutcommit_res res;
};

struct nfs42_layoutstat_devinfo;

struct nfs42_layoutstat_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct inode *inode;
	nfs4_stateid stateid;
	int num_dev;
	struct nfs42_layoutstat_devinfo *devinfo;
};

struct nfs42_layoutstat_devinfo {
	struct nfs4_deviceid dev_id;
	__u64 offset;
	__u64 length;
	__u64 read_count;
	__u64 read_bytes;
	__u64 write_count;
	__u64 write_bytes;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data ld_private;
};

typedef void (*btf_trace_nfs4_setclientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_setclientid_confirm)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew_async)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_exchange_id)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_create_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_destroy_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_destroy_clientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_bind_conn_to_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_sequence)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_reclaim_complete)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_sequence_done)(void *, const struct nfs4_session *, const struct nfs4_sequence_res *);

struct cb_sequenceargs;

struct cb_sequenceres;

typedef void (*btf_trace_nfs4_cb_sequence)(void *, const struct cb_sequenceargs *, const struct cb_sequenceres *, __be32);

struct referring_call_list;

struct cb_sequenceargs {
	struct sockaddr *csa_addr;
	struct nfs4_sessionid csa_sessionid;
	uint32_t csa_sequenceid;
	uint32_t csa_slotid;
	uint32_t csa_highestslotid;
	uint32_t csa_cachethis;
	uint32_t csa_nrclists;
	struct referring_call_list *csa_rclists;
};

struct referring_call;

struct referring_call_list {
	struct nfs4_sessionid rcl_sessionid;
	uint32_t rcl_nrefcalls;
	struct referring_call *rcl_refcalls;
};

struct referring_call {
	uint32_t rc_sequenceid;
	uint32_t rc_slotid;
};

struct cb_sequenceres {
	__be32 csr_status;
	struct nfs4_sessionid csr_sessionid;
	uint32_t csr_sequenceid;
	uint32_t csr_slotid;
	uint32_t csr_highestslotid;
	uint32_t csr_target_highestslotid;
};

typedef void (*btf_trace_nfs4_cb_seqid_err)(void *, const struct cb_sequenceargs *, __be32);

typedef void (*btf_trace_nfs4_cb_offload)(void *, const struct nfs_fh *, const nfs4_stateid *, uint64_t, int, int);

typedef void (*btf_trace_nfs4_setup_sequence)(void *, const struct nfs4_session *, const struct nfs4_sequence_args *);

typedef void (*btf_trace_nfs4_state_mgr)(void *, const struct nfs_client *);

typedef void (*btf_trace_nfs4_state_mgr_failed)(void *, const struct nfs_client *, const char *, int);

typedef void (*btf_trace_nfs4_xdr_bad_operation)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs4_xdr_status)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs4_xdr_bad_filehandle)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs_cb_no_clp)(void *, __be32, u32);

typedef void (*btf_trace_nfs_cb_badprinc)(void *, __be32, u32);

typedef void (*btf_trace_nfs4_open_reclaim)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_expired)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_file)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_cached_open)(void *, const struct nfs4_state *);

struct nfs_closeargs;

struct nfs_closeres;

typedef void (*btf_trace_nfs4_close)(void *, const struct nfs4_state *, const struct nfs_closeargs *, const struct nfs_closeres *, int);

struct nfs_closeargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
	fmode_t fmode;
	u32 share_access;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs4_layoutreturn_res;

struct nfs_closeres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fattr *fattr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct nfs4_layoutreturn_res {
	struct nfs4_sequence_res seq_res;
	u32 lrs_present;
	nfs4_stateid stateid;
};

typedef void (*btf_trace_nfs4_get_lock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_unlock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_set_lock)(void *, const struct file_lock *, const struct nfs4_state *, const nfs4_stateid *, int, int);

typedef void (*btf_trace_nfs4_state_lock_reclaim)(void *, const struct nfs4_state *, const struct nfs4_lock_state *);

typedef void (*btf_trace_nfs4_set_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_reclaim_delegation)(void *, const struct inode *, fmode_t);

struct nfs4_delegreturnargs;

struct nfs4_delegreturnres;

typedef void (*btf_trace_nfs4_delegreturn_exit)(void *, const struct nfs4_delegreturnargs *, const struct nfs4_delegreturnres *, int);

struct nfs4_delegreturnargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fhandle;
	const nfs4_stateid *stateid;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs4_delegreturnres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

typedef void (*btf_trace_nfs4_test_delegation_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_test_open_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_test_lock_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_lookup)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_symlink)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mkdir)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mknod)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_remove)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_get_fs_locations)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_secinfo)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_lookupp)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_rename)(void *, const struct inode *, const struct qstr *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_access)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readlink)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readdir)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_get_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_set_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_get_security_label)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_set_security_label)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_setattr)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_delegreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_close_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_getattr)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_lookup_root)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_fsinfo)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_cb_getattr)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, int);

typedef void (*btf_trace_nfs4_cb_recall)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_cb_layoutrecall_file)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_map_name_to_uid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_group_to_gid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_uid_to_name)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_gid_to_group)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_pnfs_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_pnfs_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_commit)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_pnfs_commit_ds)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_layoutget)(void *, const struct nfs_open_context *, const struct pnfs_layout_range *, const struct pnfs_layout_range *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutcommit)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutreturn_on_close)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layouterror)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutstats)(void *, const struct inode *, const nfs4_stateid *, int);

enum pnfs_update_layout_reason {
	PNFS_UPDATE_LAYOUT_UNKNOWN = 0,
	PNFS_UPDATE_LAYOUT_NO_PNFS = 1,
	PNFS_UPDATE_LAYOUT_RD_ZEROLEN = 2,
	PNFS_UPDATE_LAYOUT_MDSTHRESH = 3,
	PNFS_UPDATE_LAYOUT_NOMEM = 4,
	PNFS_UPDATE_LAYOUT_BULK_RECALL = 5,
	PNFS_UPDATE_LAYOUT_IO_TEST_FAIL = 6,
	PNFS_UPDATE_LAYOUT_FOUND_CACHED = 7,
	PNFS_UPDATE_LAYOUT_RETURN = 8,
	PNFS_UPDATE_LAYOUT_RETRY = 9,
	PNFS_UPDATE_LAYOUT_BLOCKED = 10,
	PNFS_UPDATE_LAYOUT_INVALID_OPEN = 11,
	PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET = 12,
	PNFS_UPDATE_LAYOUT_EXIT = 13,
};

typedef void (*btf_trace_pnfs_update_layout)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *, enum pnfs_update_layout_reason);

typedef void (*btf_trace_pnfs_mds_fallback_pg_init_read)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_pg_init_write)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_pg_get_mirror_count)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_read_done)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_write_done)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_read_pagelist)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_write_pagelist)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_nfs4_deviceid_free)(void *, const struct nfs_client *, const struct nfs4_deviceid *);

typedef void (*btf_trace_nfs4_getdeviceinfo)(void *, const struct nfs_server *, const struct nfs4_deviceid *, int);

typedef void (*btf_trace_nfs4_find_deviceid)(void *, const struct nfs_server *, const struct nfs4_deviceid *, int);

typedef void (*btf_trace_ff_layout_read_error)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_ff_layout_write_error)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_ff_layout_commit_error)(void *, const struct nfs_commit_data *);

struct nfs42_seek_args;

struct nfs42_seek_res;

typedef void (*btf_trace_nfs4_llseek)(void *, const struct inode *, const struct nfs42_seek_args *, const struct nfs42_seek_res *, int);

struct nfs42_seek_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *sa_fh;
	nfs4_stateid sa_stateid;
	u64 sa_offset;
	u32 sa_what;
};

struct nfs42_seek_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
	u32 sr_eof;
	u64 sr_offset;
};

struct nfs42_falloc_args;

typedef void (*btf_trace_nfs4_fallocate)(void *, const struct inode *, const struct nfs42_falloc_args *, int);

struct nfs42_falloc_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *falloc_fh;
	nfs4_stateid falloc_stateid;
	u64 falloc_offset;
	u64 falloc_length;
	const u32 *falloc_bitmask;
};

typedef void (*btf_trace_nfs4_deallocate)(void *, const struct inode *, const struct nfs42_falloc_args *, int);

struct nfs42_copy_args;

struct nfs42_copy_res;

struct nl4_server;

typedef void (*btf_trace_nfs4_copy)(void *, const struct inode *, const struct inode *, const struct nfs42_copy_args *, const struct nfs42_copy_res *, const struct nl4_server *, int);

struct nfs42_copy_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *src_fh;
	nfs4_stateid src_stateid;
	u64 src_pos;
	struct nfs_fh *dst_fh;
	nfs4_stateid dst_stateid;
	u64 dst_pos;
	u64 count;
	bool sync;
	struct nl4_server *cp_src;
};

struct nfs42_netaddr {
	char netid[5];
	char addr[58];
	u32 netid_len;
	u32 addr_len;
};

enum netloc_type4 {
	NL4_NAME = 1,
	NL4_URL = 2,
	NL4_NETADDR = 3,
};

struct nl4_server {
	enum netloc_type4 nl4_type;
	union {
		struct {
			int nl4_str_sz;
			char nl4_str[1025];
		};
		struct nfs42_netaddr nl4_addr;
	} u;
};

struct nfs42_write_res {
	nfs4_stateid stateid;
	u64 count;
	struct nfs_writeverf verifier;
};

struct nfs42_copy_res {
	struct nfs4_sequence_res seq_res;
	struct nfs42_write_res write_res;
	bool consecutive;
	bool synchronous;
	struct nfs_commitres commit_res;
};

struct nfs42_clone_args;

typedef void (*btf_trace_nfs4_clone)(void *, const struct inode *, const struct inode *, const struct nfs42_clone_args *, int);

struct nfs42_clone_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *src_fh;
	struct nfs_fh *dst_fh;
	nfs4_stateid src_stateid;
	nfs4_stateid dst_stateid;
	__u64 src_offset;
	__u64 dst_offset;
	__u64 count;
	const u32 *dst_bitmask;
};

struct nfs42_copy_notify_args;

struct nfs42_copy_notify_res;

typedef void (*btf_trace_nfs4_copy_notify)(void *, const struct inode *, const struct nfs42_copy_notify_args *, const struct nfs42_copy_notify_res *, int);

struct nfs42_copy_notify_args {
	struct nfs4_sequence_args cna_seq_args;
	struct nfs_fh *cna_src_fh;
	nfs4_stateid cna_src_stateid;
	struct nl4_server cna_dst;
};

struct nfs42_copy_notify_res {
	struct nfs4_sequence_res cnr_seq_res;
	struct nfstime4 cnr_lease_time;
	nfs4_stateid cnr_stateid;
	struct nl4_server cnr_src;
};

struct nfs42_offload_status_args;

typedef void (*btf_trace_nfs4_offload_cancel)(void *, const struct nfs42_offload_status_args *, int);

struct nfs42_offload_status_args {
	struct nfs4_sequence_args osa_seq_args;
	struct nfs_fh *osa_src_fh;
	nfs4_stateid osa_stateid;
};

typedef void (*btf_trace_nfs4_getxattr)(void *, const struct inode *, const char *, int);

typedef void (*btf_trace_nfs4_setxattr)(void *, const struct inode *, const char *, int);

typedef void (*btf_trace_nfs4_removexattr)(void *, const struct inode *, const char *, int);

typedef void (*btf_trace_nfs4_listxattr)(void *, const struct inode *, int);

enum {
	NFS_LAYOUT_RO_FAILED = 0,
	NFS_LAYOUT_RW_FAILED = 1,
	NFS_LAYOUT_BULK_RECALL = 2,
	NFS_LAYOUT_RETURN = 3,
	NFS_LAYOUT_RETURN_LOCK = 4,
	NFS_LAYOUT_RETURN_REQUESTED = 5,
	NFS_LAYOUT_INVALID_STID = 6,
	NFS_LAYOUT_FIRST_LAYOUTGET = 7,
	NFS_LAYOUT_INODE_FREEING = 8,
	NFS_LAYOUT_HASHED = 9,
	NFS_LAYOUT_DRAIN = 10,
};

enum rpc_display_format_t {
	RPC_DISPLAY_ADDR = 0,
	RPC_DISPLAY_PORT = 1,
	RPC_DISPLAY_PROTO = 2,
	RPC_DISPLAY_HEX_ADDR = 3,
	RPC_DISPLAY_HEX_PORT = 4,
	RPC_DISPLAY_NETID = 5,
	RPC_DISPLAY_MAX = 6,
};

struct trace_event_raw_nfs4_clientid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	unsigned long error;
	char __data[0];
};

struct trace_event_raw_nfs4_sequence_done {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int target_highest_slotid;
	unsigned long status_flags;
	unsigned long error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int cachethis;
	unsigned long error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_seqid_err {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int cachethis;
	unsigned long error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_offload {
	struct trace_entry ent;
	unsigned long error;
	u32 fhandle;
	loff_t cb_count;
	int cb_how;
	int cb_stateid_seq;
	u32 cb_stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_setup_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_used_slotid;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr {
	struct trace_entry ent;
	unsigned long state;
	u32 __data_loc_hostname;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr_failed {
	struct trace_entry ent;
	unsigned long error;
	unsigned long state;
	u32 __data_loc_hostname;
	u32 __data_loc_section;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_bad_operation {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	u32 expected;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	unsigned long error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_error_class {
	struct trace_entry ent;
	u32 xid;
	u32 cbident;
	char __data[0];
};

struct nfs4_cached_acl;

struct nfs_delegation;

struct nfs4_xattr_cache;

struct nfs_inode {
	__u64 fileid;
	struct nfs_fh fh;
	unsigned long flags;
	unsigned long cache_validity;
	unsigned long read_cache_jiffies;
	unsigned long attrtimeo;
	unsigned long attrtimeo_timestamp;
	unsigned long attr_gencount;
	struct rb_root access_cache;
	struct list_head access_cache_entry_lru;
	struct list_head access_cache_inode_lru;
	union {
		struct {
			unsigned long cache_change_attribute;
			__be32 cookieverf[2];
			struct rw_semaphore rmdir_sem;
		};
		struct {
			atomic_long_t nrequests;
			atomic_long_t redirtied_pages;
			struct nfs_mds_commit_info commit_info;
			struct mutex commit_mutex;
		};
	};
	struct list_head open_files;
	struct {
		int cnt;
		struct {
			u64 start;
			u64 end;
		} gap[16];
	} *ooo;
	struct nfs4_cached_acl *nfs4_acl;
	struct list_head open_states;
	struct nfs_delegation __attribute__((btf_type_tag("rcu"))) *delegation;
	struct rw_semaphore rwsem;
	struct pnfs_layout_hdr *layout;
	__u64 write_io;
	__u64 read_io;
	struct nfs4_xattr_cache *xattr_cache;
	union {
		struct inode vfs_inode;
	};
};

struct nfs_delegation {
	struct list_head super_list;
	const struct cred *cred;
	struct inode *inode;
	nfs4_stateid stateid;
	fmode_t type;
	unsigned long pagemod_limit;
	__u64 change_attr;
	unsigned long test_gen;
	unsigned long flags;
	refcount_t refcount;
	spinlock_t lock;
	struct callback_head rcu;
};

struct trace_event_raw_nfs4_open_event {
	struct trace_entry ent;
	unsigned long error;
	unsigned long flags;
	unsigned long fmode;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	int stateid_seq;
	u32 stateid_hash;
	int openstateid_seq;
	u32 openstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_cached_open {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_close {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	unsigned long error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lock_event {
	struct trace_entry ent;
	unsigned long error;
	unsigned long cmd;
	unsigned long type;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_set_lock {
	struct trace_entry ent;
	unsigned long error;
	unsigned long cmd;
	unsigned long type;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	int lockstateid_seq;
	u32 lockstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_state_lock_reclaim {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned long state_flags;
	unsigned long lock_flags;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_set_delegation_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	char __data[0];
};

struct trace_event_raw_nfs4_delegreturn_exit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	unsigned long error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_test_stateid_event {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lookup_event {
	struct trace_entry ent;
	dev_t dev;
	unsigned long error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_lookupp {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	unsigned long error;
	char __data[0];
};

struct trace_event_raw_nfs4_rename {
	struct trace_entry ent;
	dev_t dev;
	unsigned long error;
	u64 olddir;
	u32 __data_loc_oldname;
	u64 newdir;
	u32 __data_loc_newname;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned long error;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_stateid_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned long error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_getattr_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int valid;
	unsigned long error;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_callback_event {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_stateid_callback_event {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_dstaddr;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_idmap_event {
	struct trace_entry ent;
	unsigned long error;
	u32 id;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_read_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	unsigned long error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_write_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	unsigned long error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_commit_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned long error;
	loff_t offset;
	u32 count;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_layoutget {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 iomode;
	u64 offset;
	u64 count;
	unsigned long error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_pnfs_update_layout {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u32 fhandle;
	loff_t pos;
	u64 count;
	enum pnfs_iomode iomode;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	long lseg;
	enum pnfs_update_layout_reason reason;
	char __data[0];
};

struct trace_event_raw_pnfs_layout_event {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u32 fhandle;
	loff_t pos;
	u64 count;
	enum pnfs_iomode iomode;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	long lseg;
	char __data[0];
};

struct trace_event_raw_nfs4_deviceid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	unsigned char deviceid[16];
	char __data[0];
};

struct trace_event_raw_nfs4_deviceid_status {
	struct trace_entry ent;
	dev_t dev;
	int status;
	u32 __data_loc_dstaddr;
	unsigned char deviceid[16];
	char __data[0];
};

struct trace_event_raw_nfs4_flexfiles_io_event {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	int stateid_seq;
	u32 stateid_hash;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_ff_layout_commit_error {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_nfs4_llseek {
	struct trace_entry ent;
	unsigned long error;
	u32 fhandle;
	u32 fileid;
	dev_t dev;
	int stateid_seq;
	u32 stateid_hash;
	loff_t offset_s;
	u32 what;
	loff_t offset_r;
	u32 eof;
	char __data[0];
};

struct trace_event_raw_nfs4_sparse_event {
	struct trace_entry ent;
	unsigned long error;
	loff_t offset;
	loff_t len;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_copy {
	struct trace_entry ent;
	unsigned long error;
	u32 src_fhandle;
	u32 src_fileid;
	u32 dst_fhandle;
	u32 dst_fileid;
	dev_t src_dev;
	dev_t dst_dev;
	int src_stateid_seq;
	u32 src_stateid_hash;
	int dst_stateid_seq;
	u32 dst_stateid_hash;
	loff_t src_offset;
	loff_t dst_offset;
	bool sync;
	loff_t len;
	int res_stateid_seq;
	u32 res_stateid_hash;
	loff_t res_count;
	bool res_sync;
	bool res_cons;
	bool intra;
	char __data[0];
};

struct trace_event_raw_nfs4_clone {
	struct trace_entry ent;
	unsigned long error;
	u32 src_fhandle;
	u32 src_fileid;
	u32 dst_fhandle;
	u32 dst_fileid;
	dev_t src_dev;
	dev_t dst_dev;
	loff_t src_offset;
	loff_t dst_offset;
	int src_stateid_seq;
	u32 src_stateid_hash;
	int dst_stateid_seq;
	u32 dst_stateid_hash;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_nfs4_copy_notify {
	struct trace_entry ent;
	unsigned long error;
	u32 fhandle;
	u32 fileid;
	dev_t dev;
	int stateid_seq;
	u32 stateid_hash;
	int res_stateid_seq;
	u32 res_stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_offload_cancel {
	struct trace_entry ent;
	unsigned long error;
	u32 fhandle;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_xattr_event {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_nfs4_clientid_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_state_mgr {
	u32 hostname;
};

struct trace_event_data_offsets_nfs4_state_mgr_failed {
	u32 hostname;
	u32 section;
};

struct trace_event_data_offsets_nfs4_open_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_rename {
	u32 oldname;
	u32 newname;
};

struct trace_event_data_offsets_nfs4_inode_callback_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_inode_stateid_callback_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_idmap_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_deviceid_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_deviceid_status {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_flexfiles_io_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_ff_layout_commit_error {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_xattr_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_sequence_done {};

struct trace_event_data_offsets_nfs4_cb_sequence {};

struct trace_event_data_offsets_nfs4_cb_seqid_err {};

struct trace_event_data_offsets_nfs4_cb_offload {};

struct trace_event_data_offsets_nfs4_setup_sequence {};

struct trace_event_data_offsets_nfs4_xdr_bad_operation {};

struct trace_event_data_offsets_nfs4_xdr_event {};

struct trace_event_data_offsets_nfs4_cb_error_class {};

struct trace_event_data_offsets_nfs4_cached_open {};

struct trace_event_data_offsets_nfs4_close {};

struct trace_event_data_offsets_nfs4_lock_event {};

struct trace_event_data_offsets_nfs4_set_lock {};

struct trace_event_data_offsets_nfs4_state_lock_reclaim {};

struct trace_event_data_offsets_nfs4_set_delegation_event {};

struct trace_event_data_offsets_nfs4_delegreturn_exit {};

struct trace_event_data_offsets_nfs4_test_stateid_event {};

struct trace_event_data_offsets_nfs4_lookupp {};

struct trace_event_data_offsets_nfs4_inode_event {};

struct trace_event_data_offsets_nfs4_inode_stateid_event {};

struct trace_event_data_offsets_nfs4_getattr_event {};

struct trace_event_data_offsets_nfs4_read_event {};

struct trace_event_data_offsets_nfs4_write_event {};

struct trace_event_data_offsets_nfs4_commit_event {};

struct trace_event_data_offsets_nfs4_layoutget {};

struct trace_event_data_offsets_pnfs_update_layout {};

struct trace_event_data_offsets_pnfs_layout_event {};

struct trace_event_data_offsets_nfs4_llseek {};

struct trace_event_data_offsets_nfs4_sparse_event {};

struct trace_event_data_offsets_nfs4_copy {};

struct trace_event_data_offsets_nfs4_clone {};

struct trace_event_data_offsets_nfs4_copy_notify {};

struct trace_event_data_offsets_nfs4_offload_cancel {};

struct ipc_params;

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_ids {
	int in_use;
	unsigned short seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	struct percpu_counter percpu_msg_bytes;
	struct percpu_counter percpu_msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	unsigned long shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct ctl_table_set mq_set;
	struct ctl_table_header *mq_sysctls;
	struct ctl_table_set ipc_set;
	struct ctl_table_header *ipc_sysctls;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	unsigned long q_cbytes;
	unsigned long q_qnum;
	unsigned long q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	long: 64;
	long: 64;
};

typedef unsigned int __kernel_uid_t;

typedef unsigned int __kernel_gid_t;

typedef unsigned int __kernel_mode_t;

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	unsigned short seq;
};

struct msg;

typedef __kernel_long_t __kernel_old_time_t;

typedef int __kernel_ipc_pid_t;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	unsigned long msg_lcbytes;
	unsigned long msg_lqbytes;
	unsigned short msg_cbytes;
	unsigned short msg_qnum;
	unsigned short msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msg_msg;

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long r_msgtype;
	long r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

typedef u32 compat_ulong_t;

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

typedef s32 compat_ssize_t;

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[0];
	unsigned short seq;
	unsigned short __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long msg_stime;
	long msg_rtime;
	long msg_ctime;
	unsigned long msg_cbytes;
	unsigned long msg_qnum;
	unsigned long msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	unsigned long __unused4;
	unsigned long __unused5;
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	unsigned short msgseg;
};

typedef s32 compat_key_t;

typedef u32 __compat_uid32_t;

typedef u32 __compat_gid32_t;

typedef u16 compat_mode_t;

typedef u16 compat_ushort_t;

struct compat_ipc64_perm {
	compat_key_t key;
	__compat_uid32_t uid;
	__compat_gid32_t gid;
	__compat_uid32_t cuid;
	__compat_gid32_t cgid;
	compat_mode_t mode;
	unsigned char __pad1[2];
	compat_ushort_t seq;
	compat_ushort_t __pad2;
	compat_ulong_t unused1;
	compat_ulong_t unused2;
};

typedef s32 compat_pid_t;

struct compat_msqid64_ds {
	struct compat_ipc64_perm msg_perm;
	compat_ulong_t msg_stime;
	compat_ulong_t msg_stime_high;
	compat_ulong_t msg_rtime;
	compat_ulong_t msg_rtime_high;
	compat_ulong_t msg_ctime;
	compat_ulong_t msg_ctime_high;
	compat_ulong_t msg_cbytes;
	compat_ulong_t msg_qnum;
	compat_ulong_t msg_qbytes;
	compat_pid_t msg_lspid;
	compat_pid_t msg_lrpid;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

typedef u16 __compat_uid_t;

typedef u16 __compat_gid_t;

struct compat_ipc_perm {
	key_t key;
	__compat_uid_t uid;
	__compat_gid_t gid;
	__compat_uid_t cuid;
	__compat_gid_t cgid;
	compat_mode_t mode;
	unsigned short seq;
};

typedef u16 compat_ipc_pid_t;

struct compat_msqid_ds {
	struct compat_ipc_perm msg_perm;
	compat_uptr_t msg_first;
	compat_uptr_t msg_last;
	old_time32_t msg_stime;
	old_time32_t msg_rtime;
	old_time32_t msg_ctime;
	compat_ulong_t msg_lcbytes;
	compat_ulong_t msg_lqbytes;
	unsigned short msg_cbytes;
	unsigned short msg_qnum;
	unsigned short msg_qbytes;
	compat_ipc_pid_t msg_lspid;
	compat_ipc_pid_t msg_lrpid;
};

struct compat_msgbuf {
	compat_long_t mtype;
	char mtext[1];
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	struct work_struct free_work;
	void *__ctx[0];
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct crypto_rng;

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	struct crypto_alg base;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct prng_context {
	spinlock_t prng_lock;
	unsigned char rand_data[16];
	unsigned char last_rand_data[16];
	unsigned char DT[16];
	unsigned char I[16];
	unsigned char V[16];
	u32 rand_data_valid;
	struct crypto_cipher *tfm;
	u32 flags;
};

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

enum rq_end_io_ret {
	RQ_END_IO_NONE = 0,
	RQ_END_IO_FREE = 1,
};

typedef enum rq_end_io_ret rq_end_io_fn(struct request *, blk_status_t);

typedef __u32 req_flags_t;

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	blk_opf_t cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int timeout;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	union {
		struct list_head queuelist;
		struct request *rq_next;
	};
	struct block_device *part;
	u64 start_time_ns;
	u64 io_start_time_ns;
	unsigned short stats_sectors;
	unsigned short nr_phys_segments;
	unsigned short nr_integrity_segments;
	unsigned short ioprio;
	enum mq_rq_state state;
	atomic_t ref;
	unsigned long deadline;
	union {
		struct hlist_node hash;
		struct llist_node ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
	};
	struct {
		struct io_cq *icq;
		void *priv[2];
	} elv;
	struct {
		unsigned int seq;
		rq_end_io_fn *saved_end_io;
	} flush;
	u64 fifo_time;
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	bool round_robin;
	struct sbitmap_word *map;
	unsigned int __attribute__((btf_type_tag("percpu"))) *alloc_hint;
};

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		unsigned long state;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	unsigned long flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	unsigned short type;
	unsigned short nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	unsigned long run;
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
};

struct blk_flush_queue {
	spinlock_t mq_flush_lock;
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	unsigned long flush_pending_since;
	struct list_head flush_queue[2];
	unsigned long flush_data_in_flight;
	struct request *flush_rq;
};

struct sbitmap_word {
	unsigned long word;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned long cleared;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait_state;

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	unsigned int min_shallow_depth;
	atomic_t completion_cnt;
	atomic_t wakeup_cnt;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	unsigned int active_queues;
	struct sbitmap_queue bitmap_tags;
	struct sbitmap_queue breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
	spinlock_t lock;
};

struct sbq_wait_state {
	wait_queue_head_t wait;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct blk_mq_tag_set {
	const struct blk_mq_ops *ops;
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	struct blk_mq_tags **tags;
	struct blk_mq_tags *shared_tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
	struct srcu_struct *srcu;
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
};

struct rq_wait;

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct rq_qos_ops;

struct rq_qos {
	const struct rq_qos_ops *ops;
	struct gendisk *disk;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

struct blk_mq_debugfs_attr;

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

typedef void cleanup_cb_t(struct rq_wait *, void *);

struct fdtable {
	unsigned int max_fds;
	struct file __attribute__((btf_type_tag("rcu"))) **fd;
	unsigned long *close_on_exec;
	unsigned long *open_fds;
	unsigned long *full_fds_bits;
	struct callback_head rcu;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable __attribute__((btf_type_tag("rcu"))) *fdt;
	struct fdtable fdtab;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t file_lock;
	unsigned int next_fd;
	unsigned long close_on_exec_init[1];
	unsigned long open_fds_init[1];
	unsigned long full_fds_bits_init[1];
	struct file __attribute__((btf_type_tag("rcu"))) *fd_array[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_ring_ctx;

struct io_wq;

struct io_uring_task {
	int cached_refs;
	const struct io_ring_ctx *last;
	struct io_wq *io_wq;
	struct file *registered_rings[16];
	struct xarray xa;
	struct wait_queue_head wait;
	atomic_t in_cancel;
	atomic_t inflight_tracked;
	struct percpu_counter inflight;
	long: 64;
	long: 64;
	struct {
		struct llist_head task_list;
		struct callback_head task_work;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
};

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
	TWA_SIGNAL_NO_IPI = 3,
};

struct io_fixed_file;

struct io_file_table {
	struct io_fixed_file *files;
	unsigned long *bitmap;
	unsigned int alloc_hint;
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

struct io_kiocb;

struct io_submit_link {
	struct io_kiocb *head;
	struct io_kiocb *last;
};

struct io_submit_state {
	struct io_wq_work_node free_list;
	struct io_wq_work_list compl_reqs;
	struct io_submit_link link;
	bool plug_started;
	bool need_plug;
	unsigned short submit_nr;
	unsigned int cqes_count;
	struct blk_plug plug;
};

struct io_hash_bucket;

struct io_hash_table {
	struct io_hash_bucket *hbs;
	unsigned int hash_bits;
};

struct io_alloc_cache {
	struct io_wq_work_node list;
	unsigned int nr_cached;
	unsigned int max_cached;
	size_t elem_size;
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
	__u64 big_cqe[0];
};

struct io_restriction {
	unsigned long register_op[1];
	unsigned long sqe_op[1];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_rings;

struct io_uring_sqe;

struct io_rsrc_node;

struct io_mapped_ubuf;

struct io_buffer_list;

struct io_ev_fd;

struct io_sq_data;

struct io_rsrc_data;

struct io_wq_hash;

struct io_ring_ctx {
	struct {
		unsigned int flags;
		unsigned int drain_next: 1;
		unsigned int restricted: 1;
		unsigned int off_timeout_used: 1;
		unsigned int drain_active: 1;
		unsigned int has_evfd: 1;
		unsigned int task_complete: 1;
		unsigned int lockless_cq: 1;
		unsigned int syscall_iopoll: 1;
		unsigned int poll_activated: 1;
		unsigned int drain_disabled: 1;
		unsigned int compat: 1;
		struct task_struct *submitter_task;
		struct io_rings *rings;
		struct percpu_ref refs;
		enum task_work_notify_mode notify_method;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex uring_lock;
		u32 *sq_array;
		struct io_uring_sqe *sq_sqes;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		struct io_rsrc_node *rsrc_node;
		atomic_t cancel_seq;
		struct io_file_table file_table;
		unsigned int nr_user_files;
		unsigned int nr_user_bufs;
		struct io_mapped_ubuf **user_bufs;
		struct io_submit_state submit_state;
		struct io_buffer_list *io_bl;
		struct xarray io_bl_xa;
		struct io_hash_table cancel_table_locked;
		struct io_alloc_cache apoll_cache;
		struct io_alloc_cache netmsg_cache;
		struct io_wq_work_list iopoll_list;
		bool poll_multi_queue;
		struct hlist_head cancelable_uring_cmd;
	};
	struct {
		struct io_uring_cqe *cqe_cached;
		struct io_uring_cqe *cqe_sentinel;
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		struct io_ev_fd __attribute__((btf_type_tag("rcu"))) *io_ev_fd;
		unsigned int cq_extra;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct llist_head work_llist;
		unsigned long check_cq;
		atomic_t cq_wait_nr;
		atomic_t cq_timeouts;
		struct wait_queue_head cq_wait;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t timeout_lock;
		struct list_head timeout_list;
		struct list_head ltimeout_list;
		unsigned int cq_last_tm_flush;
		long: 64;
		long: 64;
	};
	struct io_uring_cqe completion_cqes[16];
	spinlock_t completion_lock;
	struct io_wq_work_list locked_free_list;
	unsigned int locked_free_nr;
	struct list_head io_buffers_comp;
	struct list_head cq_overflow_list;
	struct io_hash_table cancel_table;
	struct hlist_head waitid_list;
	struct hlist_head futex_list;
	struct io_alloc_cache futex_cache;
	const struct cred *sq_creds;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct list_head sqd_list;
	unsigned int file_alloc_start;
	unsigned int file_alloc_end;
	struct xarray personalities;
	u32 pers_next;
	struct list_head io_buffers_cache;
	struct hlist_head io_buf_list;
	struct wait_queue_head poll_wq;
	struct io_restriction restrictions;
	struct io_mapped_ubuf *dummy_ubuf;
	struct io_rsrc_data *file_data;
	struct io_rsrc_data *buf_data;
	struct list_head rsrc_ref_list;
	struct io_alloc_cache rsrc_node_cache;
	struct wait_queue_head rsrc_quiesce_wq;
	unsigned int rsrc_quiesce;
	struct socket *ring_sock;
	struct io_wq_hash *hash_map;
	struct user_struct *user;
	struct mm_struct *mm_account;
	struct llist_head fallback_llist;
	struct delayed_work fallback_work;
	struct work_struct exit_work;
	struct list_head tctx_list;
	struct completion ref_comp;
	u32 iowq_limits[2];
	bool iowq_limits_set;
	struct callback_head poll_wq_task_work;
	struct list_head defer_list;
	unsigned int sq_thread_idle;
	unsigned int evfd_last_cq_tail;
	unsigned short n_ring_pages;
	unsigned short n_sqe_pages;
	struct page **ring_pages;
	struct page **sqe_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_uring {
	u32 head;
	u32 tail;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	atomic_t sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	long: 64;
	long: 64;
	struct io_uring_cqe cqes[0];
};

typedef int __kernel_rwf_t;

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
		struct {
			__u32 cmd_op;
			__u32 __pad1;
		};
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
		struct {
			__u32 level;
			__u32 optname;
		};
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
		__u32 rename_flags;
		__u32 unlink_flags;
		__u32 hardlink_flags;
		__u32 xattr_flags;
		__u32 msg_ring_flags;
		__u32 uring_cmd_flags;
		__u32 waitid_flags;
		__u32 futex_flags;
	};
	__u64 user_data;
	union {
		__u16 buf_index;
		__u16 buf_group;
	};
	__u16 personality;
	union {
		__s32 splice_fd_in;
		__u32 file_index;
		__u32 optlen;
		struct {
			__u16 addr_len;
			__u16 __pad3[1];
		};
	};
	union {
		struct {
			__u64 addr3;
			__u64 __pad2[1];
		};
		__u64 optval;
		__u8 cmd[0];
	};
};

struct io_cache_entry {
	struct io_wq_work_node node;
};

struct io_rsrc_put {
	u64 tag;
	union {
		void *rsrc;
		struct file *file;
		struct io_mapped_ubuf *buf;
	};
};

struct io_rsrc_node {
	union {
		struct io_cache_entry cache;
		struct io_ring_ctx *ctx;
	};
	int refs;
	bool empty;
	u16 type;
	struct list_head node;
	struct io_rsrc_put item;
};

struct io_mapped_ubuf {
	u64 ubuf;
	u64 ubuf_end;
	unsigned int nr_bvecs;
	unsigned long acct_pages;
	struct bio_vec bvec[0];
};

struct io_fixed_file {
	unsigned long file_ptr;
};

struct io_cmd_data {
	struct file *file;
	__u8 data[56];
};

struct io_cqe {
	__u64 user_data;
	__s32 res;
	union {
		__u32 flags;
		int fd;
	};
};

struct io_tw_state;

typedef void (*io_req_tw_func_t)(struct io_kiocb *, struct io_tw_state *);

struct io_task_work {
	struct llist_node node;
	io_req_tw_func_t func;
};

struct io_wq_work {
	struct io_wq_work_node list;
	unsigned int flags;
	int cancel_seq;
};

struct io_buffer;

struct async_poll;

struct io_kiocb {
	union {
		struct file *file;
		struct io_cmd_data cmd;
	};
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	unsigned int flags;
	struct io_cqe cqe;
	struct io_ring_ctx *ctx;
	struct task_struct *task;
	struct io_rsrc_node *rsrc_node;
	union {
		struct io_mapped_ubuf *imu;
		struct io_buffer *kbuf;
		struct io_buffer_list *buf_list;
	};
	union {
		struct io_wq_work_node comp_list;
		__poll_t apoll_events;
	};
	atomic_t refs;
	atomic_t poll_refs;
	struct io_task_work io_task_work;
	unsigned int nr_tw;
	struct hlist_node hash_node;
	struct async_poll *apoll;
	void *async_data;
	struct io_kiocb *link;
	const struct cred *creds;
	struct io_wq_work work;
	struct {
		u64 extra1;
		u64 extra2;
	} big_cqe;
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
	__u16 bgid;
};

struct io_uring_buf_ring;

struct io_buffer_list {
	union {
		struct list_head buf_list;
		struct {
			struct page **buf_pages;
			struct io_uring_buf_ring *buf_ring;
		};
		struct callback_head rcu;
	};
	__u16 bgid;
	__u16 buf_nr_pages;
	__u16 nr_entries;
	__u16 head;
	__u16 mask;
	__u8 is_mapped;
	__u8 is_mmap;
	__u8 is_ready;
};

struct io_uring_buf {
	__u64 addr;
	__u32 len;
	__u16 bid;
	__u16 resv;
};

struct io_uring_buf_ring {
	union {
		struct {
			__u64 resv1;
			__u32 resv2;
			__u16 resv3;
			__u16 tail;
		};
		struct {
			struct {} __empty_bufs;
			struct io_uring_buf bufs[0];
		};
	};
};

struct io_tw_state {
	bool locked;
};

struct io_poll {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	int retries;
	struct wait_queue_entry wait;
};

struct async_poll {
	union {
		struct io_poll poll;
		struct io_cache_entry cache;
	};
	struct io_poll *double_poll;
};

struct io_hash_bucket {
	spinlock_t lock;
	struct hlist_head list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_ev_fd {
	struct eventfd_ctx *cq_ev_fd;
	unsigned int eventfd_async: 1;
	struct callback_head rcu;
	atomic_t refs;
	atomic_t ops;
};

struct io_sq_data {
	refcount_t refs;
	atomic_t park_pending;
	struct mutex lock;
	struct list_head ctx_list;
	struct task_struct *thread;
	struct wait_queue_head wait;
	unsigned int sq_thread_idle;
	int sq_cpu;
	pid_t task_pid;
	pid_t task_tgid;
	unsigned long state;
	struct completion exited;
};

struct io_rsrc_data {
	struct io_ring_ctx *ctx;
	u64 **tags;
	unsigned int nr;
	u16 rsrc_type;
	bool quiesce;
};

struct io_wq_hash {
	refcount_t refs;
	unsigned long map;
	struct wait_queue_head wait;
};

struct io_uring_cmd {
	struct file *file;
	const struct io_uring_sqe *sqe;
	union {
		void (*task_work_cb)(struct io_uring_cmd *, unsigned int);
		void *cookie;
	};
	u32 cmd_op;
	u32 flags;
	u8 pdu[32];
};

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, long);

typedef void (*btf_trace_io_uring_file_get)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_defer)(void *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_link)(void *, struct io_kiocb *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_fail_link)(void *, struct io_kiocb *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_complete)(void *, void *, void *, u64, int, unsigned int, u64, u64);

typedef void (*btf_trace_io_uring_submit_req)(void *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_poll_arm)(void *, struct io_kiocb *, int, int);

typedef void (*btf_trace_io_uring_task_add)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_req_failed)(void *, const struct io_uring_sqe *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_cqe_overflow)(void *, void *, unsigned long long, s32, u32, void *);

typedef void (*btf_trace_io_uring_task_work_run)(void *, void *, unsigned int, unsigned int);

typedef void (*btf_trace_io_uring_short_write)(void *, void *, u64, u64, u64);

typedef void (*btf_trace_io_uring_local_work_run)(void *, void *, int, unsigned int);

struct creds;

enum {
	REQ_F_FIXED_FILE = 1,
	REQ_F_IO_DRAIN = 2,
	REQ_F_LINK = 4,
	REQ_F_HARDLINK = 8,
	REQ_F_FORCE_ASYNC = 16,
	REQ_F_BUFFER_SELECT = 32,
	REQ_F_CQE_SKIP = 64,
	REQ_F_FAIL = 256,
	REQ_F_INFLIGHT = 512,
	REQ_F_CUR_POS = 1024,
	REQ_F_NOWAIT = 2048,
	REQ_F_LINK_TIMEOUT = 4096,
	REQ_F_NEED_CLEANUP = 8192,
	REQ_F_POLLED = 16384,
	REQ_F_BUFFER_SELECTED = 32768,
	REQ_F_BUFFER_RING = 65536,
	REQ_F_REISSUE = 131072,
	REQ_F_SUPPORT_NOWAIT = 536870912,
	REQ_F_ISREG = 1073741824,
	REQ_F_CREDS = 262144,
	REQ_F_REFCOUNT = 524288,
	REQ_F_ARM_LTIMEOUT = 1048576,
	REQ_F_ASYNC_DATA = 2097152,
	REQ_F_SKIP_LINK_CQES = 4194304,
	REQ_F_SINGLE_POLL = 8388608,
	REQ_F_DOUBLE_POLL = 16777216,
	REQ_F_PARTIAL_IO = 33554432,
	REQ_F_APOLL_MULTISHOT = 67108864,
	REQ_F_CLEAR_POLLIN = 134217728,
	REQ_F_HASH_LOCKED = 268435456,
	REQ_F_POLL_NO_LAZY = 2147483648,
};

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_HASH_SHIFT = 24,
};

enum {
	IO_CHECK_CQ_OVERFLOW_BIT = 0,
	IO_CHECK_CQ_DROPPED_BIT = 1,
};

enum io_uring_cmd_flags {
	IO_URING_F_COMPLETE_DEFER = 1,
	IO_URING_F_UNLOCKED = 2,
	IO_URING_F_MULTISHOT = 4,
	IO_URING_F_IOWQ = 8,
	IO_URING_F_NONBLOCK = -2147483648,
	IO_URING_F_SQE128 = 256,
	IO_URING_F_CQE32 = 512,
	IO_URING_F_IOPOLL = 1024,
	IO_URING_F_CANCEL = 2048,
	IO_URING_F_COMPAT = 4096,
};

enum {
	IO_APOLL_OK = 0,
	IO_APOLL_ABORTED = 1,
	IO_APOLL_READY = 2,
};

enum {
	IO_EVENTFD_OP_SIGNAL_BIT = 0,
	IO_EVENTFD_OP_FREE_BIT = 1,
};

enum {
	IORING_CQE_BUFFER_SHIFT = 16,
};

enum {
	IOU_F_TWQ_LAZY_WAKE = 1,
};

enum {
	IOU_OK = 0,
	IOU_ISSUE_SKIP_COMPLETE = -529,
	IOU_STOP_MULTISHOT = -125,
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_CQE_SKIP_BIT = 6,
	REQ_F_FAIL_BIT = 8,
	REQ_F_INFLIGHT_BIT = 9,
	REQ_F_CUR_POS_BIT = 10,
	REQ_F_NOWAIT_BIT = 11,
	REQ_F_LINK_TIMEOUT_BIT = 12,
	REQ_F_NEED_CLEANUP_BIT = 13,
	REQ_F_POLLED_BIT = 14,
	REQ_F_BUFFER_SELECTED_BIT = 15,
	REQ_F_BUFFER_RING_BIT = 16,
	REQ_F_REISSUE_BIT = 17,
	REQ_F_CREDS_BIT = 18,
	REQ_F_REFCOUNT_BIT = 19,
	REQ_F_ARM_LTIMEOUT_BIT = 20,
	REQ_F_ASYNC_DATA_BIT = 21,
	REQ_F_SKIP_LINK_CQES_BIT = 22,
	REQ_F_SINGLE_POLL_BIT = 23,
	REQ_F_DOUBLE_POLL_BIT = 24,
	REQ_F_PARTIAL_IO_BIT = 25,
	REQ_F_APOLL_MULTISHOT_BIT = 26,
	REQ_F_CLEAR_POLLIN_BIT = 27,
	REQ_F_HASH_LOCKED_BIT = 28,
	REQ_F_SUPPORT_NOWAIT_BIT = 29,
	REQ_F_ISREG_BIT = 30,
	REQ_F_POLL_NO_LAZY_BIT = 31,
	__REQ_F_LAST_BIT = 32,
};

enum io_uring_op {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_SHUTDOWN = 34,
	IORING_OP_RENAMEAT = 35,
	IORING_OP_UNLINKAT = 36,
	IORING_OP_MKDIRAT = 37,
	IORING_OP_SYMLINKAT = 38,
	IORING_OP_LINKAT = 39,
	IORING_OP_MSG_RING = 40,
	IORING_OP_FSETXATTR = 41,
	IORING_OP_SETXATTR = 42,
	IORING_OP_FGETXATTR = 43,
	IORING_OP_GETXATTR = 44,
	IORING_OP_SOCKET = 45,
	IORING_OP_URING_CMD = 46,
	IORING_OP_SEND_ZC = 47,
	IORING_OP_SENDMSG_ZC = 48,
	IORING_OP_READ_MULTISHOT = 49,
	IORING_OP_WAITID = 50,
	IORING_OP_FUTEX_WAIT = 51,
	IORING_OP_FUTEX_WAKE = 52,
	IORING_OP_FUTEX_WAITV = 53,
	IORING_OP_LAST = 54,
};

enum {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
	IOSQE_CQE_SKIP_SUCCESS_BIT = 6,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_L2TP = 115,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_RAW = 255,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_FILES2 = 13,
	IORING_REGISTER_FILES_UPDATE2 = 14,
	IORING_REGISTER_BUFFERS2 = 15,
	IORING_REGISTER_BUFFERS_UPDATE = 16,
	IORING_REGISTER_IOWQ_AFF = 17,
	IORING_UNREGISTER_IOWQ_AFF = 18,
	IORING_REGISTER_IOWQ_MAX_WORKERS = 19,
	IORING_REGISTER_RING_FDS = 20,
	IORING_UNREGISTER_RING_FDS = 21,
	IORING_REGISTER_PBUF_RING = 22,
	IORING_UNREGISTER_PBUF_RING = 23,
	IORING_REGISTER_SYNC_CANCEL = 24,
	IORING_REGISTER_FILE_ALLOC_RANGE = 25,
	IORING_REGISTER_LAST = 26,
	IORING_REGISTER_USE_REGISTERED_RING = 2147483648,
};

enum {
	IORING_RSRC_FILE = 0,
	IORING_RSRC_BUFFER = 1,
};

enum {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

typedef unsigned int xa_mark_t;

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	long ret;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	int fd;
	char __data[0];
};

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	u8 opcode;
	unsigned int flags;
	struct io_wq_work *work;
	int rw;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	unsigned long long data;
	u8 opcode;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	unsigned long long user_data;
	u8 opcode;
	void *link;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	int res;
	unsigned int cflags;
	u64 extra1;
	u64 extra2;
	char __data[0];
};

struct trace_event_raw_io_uring_submit_req {
	struct trace_entry ent;
	void *ctx;
	void *req;
	unsigned long long user_data;
	u8 opcode;
	u32 flags;
	bool sq_thread;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	void *req;
	unsigned long long user_data;
	u8 opcode;
	int mask;
	int events;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	void *req;
	unsigned long long user_data;
	u8 opcode;
	int mask;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_req_failed {
	struct trace_entry ent;
	void *ctx;
	void *req;
	unsigned long long user_data;
	u8 opcode;
	u8 flags;
	u8 ioprio;
	u64 off;
	u64 addr;
	u32 len;
	u32 op_flags;
	u16 buf_index;
	u16 personality;
	u32 file_index;
	u64 pad1;
	u64 addr3;
	int error;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_cqe_overflow {
	struct trace_entry ent;
	void *ctx;
	unsigned long long user_data;
	s32 res;
	u32 cflags;
	void *ocqe;
	char __data[0];
};

struct trace_event_raw_io_uring_task_work_run {
	struct trace_entry ent;
	void *tctx;
	unsigned int count;
	unsigned int loops;
	char __data[0];
};

struct trace_event_raw_io_uring_short_write {
	struct trace_entry ent;
	void *ctx;
	u64 fpos;
	u64 wanted;
	u64 got;
	char __data[0];
};

struct trace_event_raw_io_uring_local_work_run {
	struct trace_entry ent;
	void *ctx;
	int count;
	unsigned int loops;
	char __data[0];
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_tctx_node {
	struct list_head ctx_node;
	struct task_struct *task;
	struct io_ring_ctx *ctx;
};

struct io_overflow_cqe {
	struct list_head list;
	struct io_uring_cqe cqe;
};

typedef u32 compat_sigset_word;

typedef struct {
	compat_sigset_word sig[2];
} compat_sigset_t;

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int cq_tail;
	unsigned int nr_timeouts;
	ktime_t timeout;
};

struct io_tctx_exit {
	struct callback_head task_work;
	struct completion completion;
	struct io_ring_ctx *ctx;
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 user_addr;
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 user_addr;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

struct trace_event_data_offsets_io_uring_queue_async_work {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_defer {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_fail_link {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_submit_req {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_poll_arm {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_task_add {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_req_failed {
	u32 op_str;
};

struct io_cold_def {
	unsigned short async_size;
	const char *name;
	int (*prep_async)(struct io_kiocb *);
	void (*cleanup)(struct io_kiocb *);
	void (*fail)(struct io_kiocb *);
};

struct io_issue_def {
	unsigned int needs_file: 1;
	unsigned int plug: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int poll_exclusive: 1;
	unsigned int buffer_select: 1;
	unsigned int not_supported: 1;
	unsigned int audit_skip: 1;
	unsigned int ioprio: 1;
	unsigned int iopoll: 1;
	unsigned int iopoll_queue: 1;
	unsigned int manual_alloc: 1;
	unsigned int vectored: 1;
	int (*issue)(struct io_kiocb *, unsigned int);
	int (*prep)(struct io_kiocb *, const struct io_uring_sqe *);
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

typedef bool work_cancel_fn(struct io_wq_work *, void *);

struct io_uring_getevents_arg {
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 pad;
	__u64 ts;
};

struct xa_limit {
	u32 max;
	u32 min;
};

struct io_uring_file_index_range {
	__u32 off;
	__u32 len;
	__u64 resv;
};

typedef void (*task_work_func_t)(struct callback_head *);

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_cqe_overflow {};

struct trace_event_data_offsets_io_uring_task_work_run {};

struct trace_event_data_offsets_io_uring_short_write {};

struct trace_event_data_offsets_io_uring_local_work_run {};

struct io_task_cancel {
	struct task_struct *task;
	bool all;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
	DOMAIN_BUS_PCI_DEVICE_MSI = 11,
	DOMAIN_BUS_PCI_DEVICE_MSIX = 12,
	DOMAIN_BUS_DMAR = 13,
	DOMAIN_BUS_AMDVI = 14,
	DOMAIN_BUS_PCI_DEVICE_IMS = 15,
};

struct irq_fwspec;

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, unsigned long *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, unsigned long *, unsigned int *);
};

struct irq_domain_chip_generic;

struct msi_parent_ops;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct mutex mutex;
	struct irq_domain *root;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct device *dev;
	struct device *pm_dev;
	struct irq_domain *parent;
	const struct msi_parent_ops *msi_parent_ops;
	irq_hw_number_t hwirq_max;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct irq_data __attribute__((btf_type_tag("rcu"))) *revmap[0];
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

struct irq_chip_generic;

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	struct irq_chip_generic *gc[0];
};

struct irq_chip_regs {
	unsigned long enable;
	unsigned long disable;
	unsigned long mask;
	unsigned long ack;
	unsigned long eoi;
	unsigned long type;
	unsigned long polarity;
};

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 type_cache;
	u32 polarity_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	unsigned long installed;
	unsigned long unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

struct msi_domain_info;

struct msi_parent_ops {
	u32 supported_flags;
	const char *prefix;
	bool (*init_dev_msi_info)(struct device *, struct irq_domain *, struct irq_domain *, struct msi_domain_info *);
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct ls_extirq_data {
	void *intpcr;
	raw_spinlock_t lock;
	bool big_endian;
	bool is_ls1021a_or_ls1043a;
	u32 nirq;
	struct irq_fwspec map[12];
};

struct platform_device;

struct platform_device_id;

struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*remove_new)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
	bool driver_managed_dma;
};

struct pdev_archdata {};

struct resource;

struct mfd_cell;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	const char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	unsigned long flags;
	unsigned long desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct exiu_irq_data {
	void *base;
	u32 spi_base;
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

struct scatterlist {
	unsigned long page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
	unsigned int dma_length;
	unsigned int dma_flags;
};

struct iopf_device_param;

struct iommu_fault_param;

struct iommu_fwspec;

struct dev_iommu {
	struct mutex lock;
	struct iommu_fault_param *fault_param;
	struct iopf_device_param *iopf_param;
	struct iommu_fwspec *fwspec;
	struct iommu_device *iommu_dev;
	void *priv;
	u32 max_pasids;
	u32 attach_deferred: 1;
	u32 pci_32bit_workaround: 1;
	u32 require_direct: 1;
	u32 shadow_on_flush: 1;
};

struct iommu_fault;

typedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);

struct iommu_fault_param {
	iommu_dev_fault_handler_t handler;
	void *data;
	struct list_head faults;
	struct mutex lock;
};

struct iommu_fault_unrecoverable {
	__u32 reason;
	__u32 flags;
	__u32 pasid;
	__u32 perm;
	__u64 addr;
	__u64 fetch_addr;
};

struct iommu_fault_page_request {
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 perm;
	__u64 addr;
	__u64 private_data[2];
};

struct iommu_fault {
	__u32 type;
	__u32 padding;
	union {
		struct iommu_fault_unrecoverable event;
		struct iommu_fault_page_request prm;
		__u8 padding2[56];
	};
};

struct iommu_fwspec {
	const struct iommu_ops *ops;
	struct fwnode_handle *iommu_fwnode;
	u32 flags;
	unsigned int num_ids;
	u32 ids[0];
};

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, unsigned long, int, void *);

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

enum iommu_page_response_code {
	IOMMU_PAGE_RESP_SUCCESS = 0,
	IOMMU_PAGE_RESP_INVALID = 1,
	IOMMU_PAGE_RESP_FAILURE = 2,
};

struct iommu_dirty_ops;

struct iommu_dma_cookie;

struct iommu_domain {
	unsigned int type;
	const struct iommu_domain_ops *ops;
	const struct iommu_dirty_ops *dirty_ops;
	unsigned long pgsize_bitmap;
	struct iommu_domain_geometry geometry;
	struct iommu_dma_cookie *iova_cookie;
	enum iommu_page_response_code (*iopf_handler)(struct iommu_fault *, void *);
	void *fault_data;
	union {
		struct {
			iommu_fault_handler_t handler;
			void *handler_token;
		};
		struct {
			struct mm_struct *mm;
			int users;
		};
	};
};

struct iommu_iotlb_gather;

struct iommu_domain_ops {
	int (*attach_dev)(struct iommu_domain *, struct device *);
	int (*set_dev_pasid)(struct iommu_domain *, struct device *, ioasid_t);
	int (*map_pages)(struct iommu_domain *, unsigned long, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
	size_t (*unmap_pages)(struct iommu_domain *, unsigned long, size_t, size_t, struct iommu_iotlb_gather *);
	void (*flush_iotlb_all)(struct iommu_domain *);
	int (*iotlb_sync_map)(struct iommu_domain *, unsigned long, size_t);
	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
	bool (*enforce_cache_coherency)(struct iommu_domain *);
	int (*enable_nesting)(struct iommu_domain *);
	int (*set_pgtable_quirks)(struct iommu_domain *, unsigned long);
	void (*free)(struct iommu_domain *);
};

struct iommu_iotlb_gather {
	unsigned long start;
	unsigned long end;
	size_t pgsize;
	struct list_head freelist;
	bool queued;
};

struct iommu_dirty_bitmap;

struct iommu_dirty_ops {
	int (*set_dirty_tracking)(struct iommu_domain *, bool);
	int (*read_and_clear_dirty)(struct iommu_domain *, unsigned long, size_t, unsigned long, struct iommu_dirty_bitmap *);
};

struct iova_bitmap;

struct iommu_dirty_bitmap {
	struct iova_bitmap *bitmap;
	struct iommu_iotlb_gather *gather;
};

struct iommu_user_data {
	unsigned int type;
	void __attribute__((btf_type_tag("user"))) *uptr;
	size_t len;
};

struct iommu_device {
	struct list_head list;
	const struct iommu_ops *ops;
	struct fwnode_handle *fwnode;
	struct device *dev;
	struct iommu_group *singleton_group;
	u32 max_pasids;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct iommu_fault_event {
	struct iommu_fault fault;
	struct list_head list;
};

struct iommu_page_response {
	__u32 argsz;
	__u32 version;
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 code;
};

struct fsl_mc_version {
	u32 major;
	u32 minor;
	u32 revision;
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(const struct bus_type *, char *);
	ssize_t (*store)(const struct bus_type *, const char *, size_t);
};

enum fsl_mc_pool_type {
	FSL_MC_POOL_DPMCP = 0,
	FSL_MC_POOL_DPBP = 1,
	FSL_MC_POOL_DPCON = 2,
	FSL_MC_POOL_IRQ = 3,
	FSL_MC_NUM_POOL_TYPES = 4,
};

enum device_link_state {
	DL_STATE_NONE = -1,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

enum dprc_region_type {
	DPRC_REGION_TYPE_MC_PORTAL = 0,
	DPRC_REGION_TYPE_QBMAN_PORTAL = 1,
	DPRC_REGION_TYPE_QBMAN_MEM_BACKED_PORTAL = 2,
};

enum mc_cmd_status {
	MC_CMD_STATUS_OK = 0,
	MC_CMD_STATUS_READY = 1,
	MC_CMD_STATUS_AUTH_ERR = 3,
	MC_CMD_STATUS_NO_PRIVILEGE = 4,
	MC_CMD_STATUS_DMA_ERR = 5,
	MC_CMD_STATUS_CONFIG_ERR = 6,
	MC_CMD_STATUS_TIMEOUT = 7,
	MC_CMD_STATUS_NO_RESOURCE = 8,
	MC_CMD_STATUS_NO_MEMORY = 9,
	MC_CMD_STATUS_BUSY = 10,
	MC_CMD_STATUS_UNSUPPORTED_OP = 11,
	MC_CMD_STATUS_INVALID_STATE = 12,
};

enum bus_notifier_event {
	BUS_NOTIFY_ADD_DEVICE = 0,
	BUS_NOTIFY_DEL_DEVICE = 1,
	BUS_NOTIFY_REMOVED_DEVICE = 2,
	BUS_NOTIFY_BIND_DRIVER = 3,
	BUS_NOTIFY_BOUND_DRIVER = 4,
	BUS_NOTIFY_UNBIND_DRIVER = 5,
	BUS_NOTIFY_UNBOUND_DRIVER = 6,
	BUS_NOTIFY_DRIVER_NOT_BOUND = 7,
};

struct fsl_mc_obj_desc {
	char type[16];
	int id;
	u16 vendor;
	u16 ver_major;
	u16 ver_minor;
	u8 irq_count;
	u8 region_count;
	u32 state;
	char label[16];
	u16 flags;
};

struct fsl_mc_io;

struct fsl_mc_device_irq;

struct fsl_mc_resource;

struct device_link;

struct fsl_mc_device {
	struct device dev;
	u64 dma_mask;
	u16 flags;
	u32 icid;
	u16 mc_handle;
	struct fsl_mc_io *mc_io;
	struct fsl_mc_obj_desc obj_desc;
	struct resource *regions;
	struct fsl_mc_device_irq **irqs;
	struct fsl_mc_resource *resource;
	struct device_link *consumer_link;
	const char *driver_override;
};

struct fsl_mc_io {
	struct device *dev;
	u16 flags;
	u32 portal_size;
	phys_addr_t portal_phys_addr;
	void *portal_virt_addr;
	struct fsl_mc_device *dpmcp_dev;
	union {
		struct mutex mutex;
		raw_spinlock_t spinlock;
	};
};

struct fsl_mc_resource_pool;

struct fsl_mc_resource {
	enum fsl_mc_pool_type type;
	s32 id;
	void *data;
	struct fsl_mc_resource_pool *parent_pool;
	struct list_head node;
};

struct fsl_mc_device_irq {
	unsigned int virq;
	struct fsl_mc_device *mc_dev;
	u8 dev_irq_index;
	struct fsl_mc_resource resource;
};

struct fsl_mc_bus;

struct fsl_mc_resource_pool {
	enum fsl_mc_pool_type type;
	int max_count;
	int free_count;
	struct mutex mutex;
	struct list_head free_list;
	struct fsl_mc_bus *mc_bus;
};

struct dprc_attributes {
	int container_id;
	u32 icid;
	int portal_id;
	u64 options;
};

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

struct fsl_mc_uapi {
	struct miscdevice misc;
	struct device *device;
	struct mutex mutex;
	u32 local_instance_in_use;
	struct fsl_mc_io *static_mc_io;
};

struct fsl_mc_bus {
	struct fsl_mc_device mc_dev;
	struct fsl_mc_resource_pool resource_pools[4];
	struct fsl_mc_device_irq *irq_resources;
	struct mutex scan_mutex;
	struct dprc_attributes dprc_attr;
	struct fsl_mc_uapi uapi_misc;
	int irq_enabled;
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct work_struct rm_work;
	bool supplier_preactivated;
};

struct fsl_mc_device_id;

struct fsl_mc_driver {
	struct device_driver driver;
	const struct fsl_mc_device_id *match_id_table;
	int (*probe)(struct fsl_mc_device *);
	void (*remove)(struct fsl_mc_device *);
	void (*shutdown)(struct fsl_mc_device *);
	int (*suspend)(struct fsl_mc_device *, pm_message_t);
	int (*resume)(struct fsl_mc_device *);
	bool driver_managed_dma;
};

struct fsl_mc_device_id {
	__u16 vendor;
	const char obj_type[16];
};

struct dpmng_rsp_get_version {
	__le32 revision;
	__le32 version_major;
	__le32 version_minor;
};

struct mc_cmd_header {
	u8 src_id;
	u8 flags_hw;
	u8 status;
	u8 flags_sw;
	__le16 token;
	__le16 cmd_id;
};

struct dprc_region_desc {
	u32 base_offset;
	u32 size;
	u32 flags;
	enum dprc_region_type type;
	u64 base_address;
};

struct fsl_mc_addr_translation_range;

struct fsl_mc {
	struct fsl_mc_device *root_mc_bus_dev;
	u8 num_translation_ranges;
	struct fsl_mc_addr_translation_range *translation_ranges;
	void *fsl_mc_regs;
};

struct fsl_mc_addr_translation_range {
	enum dprc_region_type mc_region_type;
	u64 start_mc_offset;
	u64 end_mc_offset;
	phys_addr_t start_phys_addr;
};

struct dprc_endpoint {
	char type[16];
	int id;
	u16 if_id;
};

struct fsl_mc_command {
	__le64 header;
	__le64 params[7];
};

struct of_bus;

struct of_pci_range_parser {
	struct device_node *node;
	struct of_bus *bus;
	const __be32 *range;
	const __be32 *end;
	int na;
	int ns;
	int pna;
	bool dma;
};

struct of_pci_range {
	union {
		u64 pci_addr;
		u64 bus_addr;
	};
	u64 cpu_addr;
	u64 size;
	u32 flags;
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
	PHY_MODE_LVDS = 18,
	PHY_MODE_DP = 19,
};

enum phy_media {
	PHY_MEDIA_DEFAULT = 0,
	PHY_MEDIA_SR = 1,
	PHY_MEDIA_DAC = 2,
};

struct phy;

union phy_configure_opts;

struct phy_ops {
	int (*init)(struct phy *);
	int (*exit)(struct phy *);
	int (*power_on)(struct phy *);
	int (*power_off)(struct phy *);
	int (*set_mode)(struct phy *, enum phy_mode, int);
	int (*set_media)(struct phy *, enum phy_media);
	int (*set_speed)(struct phy *, int);
	int (*configure)(struct phy *, union phy_configure_opts *);
	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy *);
	int (*calibrate)(struct phy *);
	void (*release)(struct phy *);
	struct module *owner;
};

struct phy_attrs {
	u32 bus_width;
	u32 max_link_rate;
	enum phy_mode mode;
};

struct regulator;

struct phy {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
	struct dentry *debugfs;
};

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	unsigned long hs_clk_rate;
	unsigned long lp_clk_rate;
	unsigned char lanes;
};

struct phy_configure_opts_dp {
	unsigned int link_rate;
	unsigned int lanes;
	unsigned int voltage[4];
	unsigned int pre[4];
	u8 ssc: 1;
	u8 set_rate: 1;
	u8 set_lanes: 1;
	u8 set_voltages: 1;
};

struct phy_configure_opts_lvds {
	unsigned int bits_per_lane_and_dclk_cycle;
	unsigned long differential_clk_rate;
	unsigned int lanes;
	bool is_slave;
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
	struct phy_configure_opts_dp dp;
	struct phy_configure_opts_lvds lvds;
};

struct regmap;

struct phy_axg_mipi_pcie_analog_priv {
	struct phy *phy;
	struct regmap *regmap;
	bool dsi_configured;
	bool dsi_enabled;
	bool powered;
	struct phy_configure_opts_mipi_dphy config;
};

struct phy_provider {
	struct device *dev;
	struct device_node *children;
	struct module *owner;
	struct list_head list;
	struct phy * (*of_xlate)(struct device *, struct of_phandle_args *);
};

struct clk_hw;

struct clk_rate_request;

struct clk_duty;

struct clk_ops {
	int (*prepare)(struct clk_hw *);
	void (*unprepare)(struct clk_hw *);
	int (*is_prepared)(struct clk_hw *);
	void (*unprepare_unused)(struct clk_hw *);
	int (*enable)(struct clk_hw *);
	void (*disable)(struct clk_hw *);
	int (*is_enabled)(struct clk_hw *);
	void (*disable_unused)(struct clk_hw *);
	int (*save_context)(struct clk_hw *);
	void (*restore_context)(struct clk_hw *);
	unsigned long (*recalc_rate)(struct clk_hw *, unsigned long);
	long (*round_rate)(struct clk_hw *, unsigned long, unsigned long *);
	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
	int (*set_parent)(struct clk_hw *, u8);
	u8 (*get_parent)(struct clk_hw *);
	int (*set_rate)(struct clk_hw *, unsigned long, unsigned long);
	int (*set_rate_and_parent)(struct clk_hw *, unsigned long, unsigned long, u8);
	unsigned long (*recalc_accuracy)(struct clk_hw *, unsigned long);
	int (*get_phase)(struct clk_hw *);
	int (*set_phase)(struct clk_hw *, int);
	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*init)(struct clk_hw *);
	void (*terminate)(struct clk_hw *);
	void (*debug_init)(struct clk_hw *, struct dentry *);
};

struct clk_core;

struct clk_init_data;

struct clk_hw {
	struct clk_core *core;
	struct clk *clk;
	const struct clk_init_data *init;
};

struct clk_parent_data;

struct clk_init_data {
	const char *name;
	const struct clk_ops *ops;
	const char * const *parent_names;
	const struct clk_parent_data *parent_data;
	const struct clk_hw **parent_hws;
	u8 num_parents;
	unsigned long flags;
};

struct clk_parent_data {
	const struct clk_hw *hw;
	const char *fw_name;
	const char *name;
	int index;
};

struct clk_rate_request {
	struct clk_core *core;
	unsigned long rate;
	unsigned long min_rate;
	unsigned long max_rate;
	unsigned long best_parent_rate;
	struct clk_hw *best_parent_hw;
};

struct clk_duty {
	unsigned int num;
	unsigned int den;
};

struct usb2phy_reg {
	unsigned int offset;
	unsigned int bitend;
	unsigned int bitstart;
	unsigned int disable;
	unsigned int enable;
};

struct rockchip_usb2phy_port_cfg {
	struct usb2phy_reg phy_sus;
	struct usb2phy_reg bvalid_det_en;
	struct usb2phy_reg bvalid_det_st;
	struct usb2phy_reg bvalid_det_clr;
	struct usb2phy_reg disfall_en;
	struct usb2phy_reg disfall_st;
	struct usb2phy_reg disfall_clr;
	struct usb2phy_reg disrise_en;
	struct usb2phy_reg disrise_st;
	struct usb2phy_reg disrise_clr;
	struct usb2phy_reg id_det_en;
	struct usb2phy_reg id_det_st;
	struct usb2phy_reg id_det_clr;
	struct usb2phy_reg ls_det_en;
	struct usb2phy_reg ls_det_st;
	struct usb2phy_reg ls_det_clr;
	struct usb2phy_reg utmi_avalid;
	struct usb2phy_reg utmi_bvalid;
	struct usb2phy_reg utmi_id;
	struct usb2phy_reg utmi_ls;
	struct usb2phy_reg utmi_hstdet;
};

struct rockchip_chg_det_reg {
	struct usb2phy_reg cp_det;
	struct usb2phy_reg dcp_det;
	struct usb2phy_reg dp_det;
	struct usb2phy_reg idm_sink_en;
	struct usb2phy_reg idp_sink_en;
	struct usb2phy_reg idp_src_en;
	struct usb2phy_reg rdm_pdwn_en;
	struct usb2phy_reg vdm_src_en;
	struct usb2phy_reg vdp_src_en;
	struct usb2phy_reg opmode;
};

struct rockchip_usb2phy;

struct rockchip_usb2phy_cfg {
	unsigned int reg;
	unsigned int num_ports;
	int (*phy_tuning)(struct rockchip_usb2phy *);
	struct usb2phy_reg clkout_ctl;
	const struct rockchip_usb2phy_port_cfg port_cfgs[2];
	const struct rockchip_chg_det_reg chg_det;
};

enum usb_chg_state {
	USB_CHG_STATE_UNDEFINED = 0,
	USB_CHG_STATE_WAIT_FOR_DCD = 1,
	USB_CHG_STATE_DCD_DONE = 2,
	USB_CHG_STATE_PRIMARY_DONE = 3,
	USB_CHG_STATE_SECONDARY_DONE = 4,
	USB_CHG_STATE_DETECTED = 5,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum usb_otg_state {
	OTG_STATE_UNDEFINED = 0,
	OTG_STATE_B_IDLE = 1,
	OTG_STATE_B_SRP_INIT = 2,
	OTG_STATE_B_PERIPHERAL = 3,
	OTG_STATE_B_WAIT_ACON = 4,
	OTG_STATE_B_HOST = 5,
	OTG_STATE_A_IDLE = 6,
	OTG_STATE_A_WAIT_VRISE = 7,
	OTG_STATE_A_WAIT_BCON = 8,
	OTG_STATE_A_HOST = 9,
	OTG_STATE_A_SUSPEND = 10,
	OTG_STATE_A_PERIPHERAL = 11,
	OTG_STATE_A_WAIT_VFALL = 12,
	OTG_STATE_A_VBUS_ERR = 13,
};

enum usb_dr_mode {
	USB_DR_MODE_UNKNOWN = 0,
	USB_DR_MODE_HOST = 1,
	USB_DR_MODE_PERIPHERAL = 2,
	USB_DR_MODE_OTG = 3,
};

struct rockchip_usb2phy_port {
	struct phy *phy;
	unsigned int port_id;
	bool suspended;
	bool vbus_attached;
	bool host_disconnect;
	int bvalid_irq;
	int id_irq;
	int ls_irq;
	int otg_mux_irq;
	struct mutex mutex;
	struct delayed_work chg_work;
	struct delayed_work otg_sm_work;
	struct delayed_work sm_work;
	const struct rockchip_usb2phy_port_cfg *port_cfg;
	struct notifier_block event_nb;
	enum usb_otg_state state;
	enum usb_dr_mode mode;
};

struct reset_control;

struct extcon_dev;

struct rockchip_usb2phy {
	struct device *dev;
	struct regmap *grf;
	struct regmap *usbgrf;
	struct clk *clk;
	struct clk *clk480m;
	struct clk_hw clk480m_hw;
	struct reset_control *phy_reset;
	enum usb_chg_state chg_state;
	enum power_supply_type chg_type;
	u8 dcd_retries;
	struct extcon_dev *edev;
	int irq;
	const struct rockchip_usb2phy_cfg *phy_cfg;
	struct rockchip_usb2phy_port ports[2];
};

enum rockchip_usb2phy_port_id {
	USB2PHY_PORT_OTG = 0,
	USB2PHY_PORT_HOST = 1,
	USB2PHY_NUM_PORTS = 2,
};

enum rockchip_usb2phy_host_state {
	PHY_STATE_HS_ONLINE = 0,
	PHY_STATE_DISCONNECT = 1,
	PHY_STATE_CONNECT = 2,
	PHY_STATE_FS_LS_ONLINE = 4,
};

struct pinctrl_pin_desc;

struct pinctrl_ops;

struct pinmux_ops;

struct pinconf_ops;

struct pinconf_generic_params;

struct pin_config_item;

struct pinctrl_desc {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct pinctrl_ops *pctlops;
	const struct pinmux_ops *pmxops;
	const struct pinconf_ops *confops;
	struct module *owner;
	unsigned int num_custom_params;
	const struct pinconf_generic_params *custom_params;
	const struct pin_config_item *custom_conf_items;
	bool link_consumers;
};

struct pinctrl_pin_desc {
	unsigned int number;
	const char *name;
	void *drv_data;
};

struct pinctrl_dev;

struct pinctrl_map;

struct pinctrl_ops {
	int (*get_groups_count)(struct pinctrl_dev *);
	const char * (*get_group_name)(struct pinctrl_dev *, unsigned int);
	int (*get_group_pins)(struct pinctrl_dev *, unsigned int, const unsigned int **, unsigned int *);
	void (*pin_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	int (*dt_node_to_map)(struct pinctrl_dev *, struct device_node *, struct pinctrl_map **, unsigned int *);
	void (*dt_free_map)(struct pinctrl_dev *, struct pinctrl_map *, unsigned int);
};

struct pinctrl;

struct pinctrl_state;

struct pinctrl_dev {
	struct list_head node;
	struct pinctrl_desc *desc;
	struct xarray pin_desc_tree;
	struct xarray pin_group_tree;
	unsigned int num_groups;
	struct xarray pin_function_tree;
	unsigned int num_functions;
	struct list_head gpio_ranges;
	struct device *dev;
	struct module *owner;
	void *driver_data;
	struct pinctrl *p;
	struct pinctrl_state *hog_default;
	struct pinctrl_state *hog_sleep;
	struct mutex mutex;
	struct dentry *device_root;
};

struct pinctrl {
	struct list_head node;
	struct device *dev;
	struct list_head states;
	struct pinctrl_state *state;
	struct list_head dt_maps;
	struct kref users;
};

struct pinctrl_state {
	struct list_head node;
	const char *name;
	struct list_head settings;
};

struct pinctrl_map_mux {
	const char *group;
	const char *function;
};

struct pinctrl_map_configs {
	const char *group_or_pin;
	unsigned long *configs;
	unsigned int num_configs;
};

enum pinctrl_map_type {
	PIN_MAP_TYPE_INVALID = 0,
	PIN_MAP_TYPE_DUMMY_STATE = 1,
	PIN_MAP_TYPE_MUX_GROUP = 2,
	PIN_MAP_TYPE_CONFIGS_PIN = 3,
	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
};

struct pinctrl_map {
	const char *dev_name;
	const char *name;
	enum pinctrl_map_type type;
	const char *ctrl_dev_name;
	union {
		struct pinctrl_map_mux mux;
		struct pinctrl_map_configs configs;
	} data;
};

struct pinctrl_gpio_range;

struct pinmux_ops {
	int (*request)(struct pinctrl_dev *, unsigned int);
	int (*free)(struct pinctrl_dev *, unsigned int);
	int (*get_functions_count)(struct pinctrl_dev *);
	const char * (*get_function_name)(struct pinctrl_dev *, unsigned int);
	int (*get_function_groups)(struct pinctrl_dev *, unsigned int, const char * const **, unsigned int *);
	int (*set_mux)(struct pinctrl_dev *, unsigned int, unsigned int);
	int (*gpio_request_enable)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	void (*gpio_disable_free)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	bool strict;
};

struct gpio_chip;

struct pinctrl_gpio_range {
	struct list_head node;
	const char *name;
	unsigned int id;
	unsigned int base;
	unsigned int pin_base;
	unsigned int npins;
	const unsigned int *pins;
	struct gpio_chip *gc;
};

union gpio_irq_fwspec;

struct gpio_irq_chip {
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct fwnode_handle *fwnode;
	struct irq_domain *parent_domain;
	int (*child_to_parent_hwirq)(struct gpio_chip *, unsigned int, unsigned int, unsigned int *, unsigned int *);
	int (*populate_parent_alloc_arg)(struct gpio_chip *, union gpio_irq_fwspec *, unsigned int, unsigned int);
	unsigned int (*child_offset_to_irq)(struct gpio_chip *, unsigned int);
	struct irq_domain_ops child_irq_domain_ops;
	irq_flow_handler_t handler;
	unsigned int default_type;
	struct lock_class_key *lock_key;
	struct lock_class_key *request_key;
	irq_flow_handler_t parent_handler;
	union {
		void *parent_handler_data;
		void **parent_handler_data_array;
	};
	unsigned int num_parents;
	unsigned int *parents;
	unsigned int *map;
	bool threaded;
	bool per_parent_data;
	bool initialized;
	bool domain_is_allocated_externally;
	int (*init_hw)(struct gpio_chip *);
	void (*init_valid_mask)(struct gpio_chip *, unsigned long *, unsigned int);
	unsigned long *valid_mask;
	unsigned int first;
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
};

struct gpio_device;

struct gpio_chip {
	const char *label;
	struct gpio_device *gpiodev;
	struct device *parent;
	struct fwnode_handle *fwnode;
	struct module *owner;
	int (*request)(struct gpio_chip *, unsigned int);
	void (*free)(struct gpio_chip *, unsigned int);
	int (*get_direction)(struct gpio_chip *, unsigned int);
	int (*direction_input)(struct gpio_chip *, unsigned int);
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	int (*get)(struct gpio_chip *, unsigned int);
	int (*get_multiple)(struct gpio_chip *, unsigned long *, unsigned long *);
	void (*set)(struct gpio_chip *, unsigned int, int);
	void (*set_multiple)(struct gpio_chip *, unsigned long *, unsigned long *);
	int (*set_config)(struct gpio_chip *, unsigned int, unsigned long);
	int (*to_irq)(struct gpio_chip *, unsigned int);
	void (*dbg_show)(struct seq_file *, struct gpio_chip *);
	int (*init_valid_mask)(struct gpio_chip *, unsigned long *, unsigned int);
	int (*add_pin_ranges)(struct gpio_chip *);
	int (*en_hw_timestamp)(struct gpio_chip *, u32, unsigned long);
	int (*dis_hw_timestamp)(struct gpio_chip *, u32, unsigned long);
	int base;
	u16 ngpio;
	u16 offset;
	const char * const *names;
	bool can_sleep;
	unsigned long (*read_reg)(void *);
	void (*write_reg)(void *, unsigned long);
	bool be_bits;
	void *reg_dat;
	void *reg_set;
	void *reg_clr;
	void *reg_dir_out;
	void *reg_dir_in;
	bool bgpio_dir_unreadable;
	int bgpio_bits;
	raw_spinlock_t bgpio_lock;
	unsigned long bgpio_data;
	unsigned long bgpio_dir;
	struct gpio_irq_chip irq;
	unsigned long *valid_mask;
	unsigned int of_gpio_n_cells;
	int (*of_xlate)(struct gpio_chip *, const struct of_phandle_args *, u32 *);
};

struct msi_alloc_info {
	struct msi_desc *desc;
	irq_hw_number_t hwirq;
	unsigned long flags;
	union {
		unsigned long ul;
		void *ptr;
	} scratchpad[2];
};

typedef struct msi_alloc_info msi_alloc_info_t;

union gpio_irq_fwspec {
	struct irq_fwspec fwspec;
	msi_alloc_info_t msiinfo;
};

struct pinconf_ops {
	bool is_generic;
	int (*pin_config_get)(struct pinctrl_dev *, unsigned int, unsigned long *);
	int (*pin_config_set)(struct pinctrl_dev *, unsigned int, unsigned long *, unsigned int);
	int (*pin_config_group_get)(struct pinctrl_dev *, unsigned int, unsigned long *);
	int (*pin_config_group_set)(struct pinctrl_dev *, unsigned int, unsigned long *, unsigned int);
	void (*pin_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_group_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned long);
};

enum pin_config_param {
	PIN_CONFIG_BIAS_BUS_HOLD = 0,
	PIN_CONFIG_BIAS_DISABLE = 1,
	PIN_CONFIG_BIAS_HIGH_IMPEDANCE = 2,
	PIN_CONFIG_BIAS_PULL_DOWN = 3,
	PIN_CONFIG_BIAS_PULL_PIN_DEFAULT = 4,
	PIN_CONFIG_BIAS_PULL_UP = 5,
	PIN_CONFIG_DRIVE_OPEN_DRAIN = 6,
	PIN_CONFIG_DRIVE_OPEN_SOURCE = 7,
	PIN_CONFIG_DRIVE_PUSH_PULL = 8,
	PIN_CONFIG_DRIVE_STRENGTH = 9,
	PIN_CONFIG_DRIVE_STRENGTH_UA = 10,
	PIN_CONFIG_INPUT_DEBOUNCE = 11,
	PIN_CONFIG_INPUT_ENABLE = 12,
	PIN_CONFIG_INPUT_SCHMITT = 13,
	PIN_CONFIG_INPUT_SCHMITT_ENABLE = 14,
	PIN_CONFIG_MODE_LOW_POWER = 15,
	PIN_CONFIG_MODE_PWM = 16,
	PIN_CONFIG_OUTPUT = 17,
	PIN_CONFIG_OUTPUT_ENABLE = 18,
	PIN_CONFIG_OUTPUT_IMPEDANCE_OHMS = 19,
	PIN_CONFIG_PERSIST_STATE = 20,
	PIN_CONFIG_POWER_SOURCE = 21,
	PIN_CONFIG_SKEW_DELAY = 22,
	PIN_CONFIG_SLEEP_HARDWARE_STATE = 23,
	PIN_CONFIG_SLEW_RATE = 24,
	PIN_CONFIG_END = 127,
	PIN_CONFIG_MAX = 255,
};

struct pinconf_generic_params {
	const char * const property;
	enum pin_config_param param;
	u32 default_value;
};

struct pin_config_item {
	const enum pin_config_param param;
	const char * const display;
	const char * const format;
	bool has_arg;
};

enum owl_pinconf_drv {
	OWL_PINCONF_DRV_2MA = 0,
	OWL_PINCONF_DRV_4MA = 1,
	OWL_PINCONF_DRV_8MA = 2,
	OWL_PINCONF_DRV_12MA = 3,
};

struct owl_pinctrl_soc_data;

struct owl_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctrldev;
	struct gpio_chip chip;
	raw_spinlock_t lock;
	struct clk *clk;
	const struct owl_pinctrl_soc_data *soc;
	void *base;
	unsigned int num_irq;
	unsigned int *irq;
};

struct owl_pinmux_func;

struct owl_pingroup;

struct owl_padinfo;

struct owl_gpio_port;

struct owl_pinctrl_soc_data {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct owl_pinmux_func *functions;
	unsigned int nfunctions;
	const struct owl_pingroup *groups;
	unsigned int ngroups;
	const struct owl_padinfo *padinfo;
	unsigned int ngpios;
	const struct owl_gpio_port *ports;
	unsigned int nports;
	int (*padctl_val2arg)(const struct owl_padinfo *, unsigned int, u32 *);
	int (*padctl_arg2val)(const struct owl_padinfo *, unsigned int, u32 *);
};

struct owl_pinmux_func {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct owl_pingroup {
	const char *name;
	unsigned int *pads;
	unsigned int npads;
	unsigned int *funcs;
	unsigned int nfuncs;
	int mfpctl_reg;
	unsigned int mfpctl_shift;
	unsigned int mfpctl_width;
	int drv_reg;
	unsigned int drv_shift;
	unsigned int drv_width;
	int sr_reg;
	unsigned int sr_shift;
	unsigned int sr_width;
};

struct owl_pullctl;

struct owl_st;

struct owl_padinfo {
	int pad;
	struct owl_pullctl *pullctl;
	struct owl_st *st;
};

struct owl_pullctl {
	int reg;
	unsigned int shift;
	unsigned int width;
};

struct owl_st {
	int reg;
	unsigned int shift;
	unsigned int width;
};

struct owl_gpio_port {
	unsigned int offset;
	unsigned int pins;
	unsigned int outen;
	unsigned int inen;
	unsigned int dat;
	unsigned int intc_ctl;
	unsigned int intc_pd;
	unsigned int intc_msk;
	unsigned int intc_type;
	u8 shared_ctl_offset;
};

struct meson_pmx_group;

struct meson_pmx_func;

struct meson_bank;

struct meson_pinctrl;

struct meson_pinctrl_data {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	struct meson_pmx_group *groups;
	struct meson_pmx_func *funcs;
	unsigned int num_pins;
	unsigned int num_groups;
	unsigned int num_funcs;
	struct meson_bank *banks;
	unsigned int num_banks;
	const struct pinmux_ops *pmx_ops;
	void *pmx_data;
	int (*parse_dt)(struct meson_pinctrl *);
};

struct meson_pmx_group {
	const char *name;
	const unsigned int *pins;
	unsigned int num_pins;
	const void *data;
};

struct meson_pmx_func {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct meson_reg_desc {
	unsigned int reg;
	unsigned int bit;
};

struct meson_bank {
	const char *name;
	unsigned int first;
	unsigned int last;
	int irq_first;
	int irq_last;
	struct meson_reg_desc regs[6];
};

struct meson_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pcdev;
	struct pinctrl_desc desc;
	struct meson_pinctrl_data *data;
	struct regmap *reg_mux;
	struct regmap *reg_pullen;
	struct regmap *reg_pull;
	struct regmap *reg_gpio;
	struct regmap *reg_ds;
	struct gpio_chip chip;
	struct fwnode_handle *fwnode;
};

struct meson_pmx_bank;

struct meson_axg_pmx_data {
	struct meson_pmx_bank *pmx_banks;
	unsigned int num_pmx_banks;
};

struct meson_pmx_bank {
	const char *name;
	unsigned int first;
	unsigned int last;
	unsigned int reg;
	unsigned int offset;
};

struct pinfunction;

struct msm_pingroup;

struct msm_gpio_wakeirq_map;

struct msm_pinctrl_soc_data {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct pinfunction *functions;
	unsigned int nfunctions;
	const struct msm_pingroup *groups;
	unsigned int ngroups;
	unsigned int ngpios;
	bool pull_no_keeper;
	const char * const *tiles;
	unsigned int ntiles;
	const int *reserved_gpios;
	const struct msm_gpio_wakeirq_map *wakeirq_map;
	unsigned int nwakeirq_map;
	bool wakeirq_dual_edge_errata;
	unsigned int gpio_func;
	unsigned int egpio_func;
};

struct pinfunction {
	const char *name;
	const char * const *groups;
	size_t ngroups;
};

struct pingroup {
	const char *name;
	const unsigned int *pins;
	size_t npins;
};

struct msm_pingroup {
	struct pingroup grp;
	unsigned int *funcs;
	unsigned int nfuncs;
	u32 ctl_reg;
	u32 io_reg;
	u32 intr_cfg_reg;
	u32 intr_status_reg;
	u32 intr_target_reg;
	unsigned int tile: 2;
	unsigned int mux_bit: 5;
	unsigned int pull_bit: 5;
	unsigned int drv_bit: 5;
	unsigned int i2c_pull_bit: 5;
	unsigned int od_bit: 5;
	unsigned int egpio_enable: 5;
	unsigned int egpio_present: 5;
	unsigned int oe_bit: 5;
	unsigned int in_bit: 5;
	unsigned int out_bit: 5;
	unsigned int intr_enable_bit: 5;
	unsigned int intr_status_bit: 5;
	unsigned int intr_ack_high: 1;
	long: 1;
	unsigned int intr_target_bit: 5;
	unsigned int intr_target_width: 5;
	unsigned int intr_target_kpss_val: 5;
	unsigned int intr_raw_status_bit: 5;
	unsigned int intr_polarity_bit: 5;
	unsigned int intr_detection_bit: 5;
	int: 2;
	unsigned int intr_detection_width: 5;
};

struct msm_gpio_wakeirq_map {
	unsigned int gpio;
	unsigned int wakeirq;
};

enum uniphier_pin_pull_dir {
	UNIPHIER_PIN_PULL_UP = 0,
	UNIPHIER_PIN_PULL_DOWN = 1,
	UNIPHIER_PIN_PULL_UP_FIXED = 2,
	UNIPHIER_PIN_PULL_DOWN_FIXED = 3,
	UNIPHIER_PIN_PULL_NONE = 4,
};

enum uniphier_pin_drv_type {
	UNIPHIER_PIN_DRV_1BIT = 0,
	UNIPHIER_PIN_DRV_2BIT = 1,
	UNIPHIER_PIN_DRV_3BIT = 2,
	UNIPHIER_PIN_DRV_FIXED4 = 3,
	UNIPHIER_PIN_DRV_FIXED5 = 4,
	UNIPHIER_PIN_DRV_FIXED8 = 5,
	UNIPHIER_PIN_DRV_NONE = 6,
};

struct uniphier_pinctrl_reg_region {
	struct list_head node;
	unsigned int base;
	unsigned int nregs;
	u32 vals[0];
};

struct uniphier_pinctrl_socdata;

struct uniphier_pinctrl_priv {
	struct pinctrl_desc pctldesc;
	struct pinctrl_dev *pctldev;
	struct regmap *regmap;
	const struct uniphier_pinctrl_socdata *socdata;
	struct list_head reg_regions;
};

struct uniphier_pinctrl_group;

struct uniphier_pinmux_function;

struct uniphier_pinctrl_socdata {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct uniphier_pinctrl_group *groups;
	int groups_count;
	const struct uniphier_pinmux_function *functions;
	int functions_count;
	int (*get_gpio_muxval)(unsigned int, unsigned int);
	unsigned int caps;
};

struct uniphier_pinctrl_group {
	const char *name;
	const unsigned int *pins;
	unsigned int num_pins;
	const int *muxvals;
};

struct uniphier_pinmux_function {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct pinctrl_setting_mux;

struct pin_desc {
	struct pinctrl_dev *pctldev;
	const char *name;
	bool dynamic_name;
	void *drv_data;
	unsigned int mux_usecount;
	const char *mux_owner;
	const struct pinctrl_setting_mux *mux_setting;
	const char *gpio_owner;
};

struct pinctrl_setting_mux {
	unsigned int group;
	unsigned int func;
};

enum i2c_alert_protocol {
	I2C_PROTOCOL_SMBUS_ALERT = 0,
	I2C_PROTOCOL_SMBUS_HOST_NOTIFY = 1,
};

struct i2c_client;

struct i2c_device_id;

struct i2c_board_info;

struct i2c_driver {
	unsigned int class;
	int (*probe)(struct i2c_client *);
	void (*remove)(struct i2c_client *);
	void (*shutdown)(struct i2c_client *);
	void (*alert)(struct i2c_client *, enum i2c_alert_protocol, unsigned int);
	int (*command)(struct i2c_client *, unsigned int, void *);
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const unsigned short *address_list;
	struct list_head clients;
	u32 flags;
};

enum i2c_slave_event {
	I2C_SLAVE_READ_REQUESTED = 0,
	I2C_SLAVE_WRITE_REQUESTED = 1,
	I2C_SLAVE_READ_PROCESSED = 2,
	I2C_SLAVE_WRITE_RECEIVED = 3,
	I2C_SLAVE_STOP = 4,
};

typedef int (*i2c_slave_cb_t)(struct i2c_client *, enum i2c_slave_event, u8 *);

struct i2c_adapter;

struct i2c_client {
	unsigned short flags;
	unsigned short addr;
	char name[20];
	struct i2c_adapter *adapter;
	struct device dev;
	int init_irq;
	int irq;
	struct list_head detected;
	i2c_slave_cb_t slave_cb;
	void *devres_group_id;
};

struct rt_mutex {
	struct rt_mutex_base rtmutex;
};

struct i2c_algorithm;

struct i2c_lock_operations;

struct i2c_bus_recovery_info;

struct i2c_adapter_quirks;

struct i2c_adapter {
	struct module *owner;
	unsigned int class;
	const struct i2c_algorithm *algo;
	void *algo_data;
	const struct i2c_lock_operations *lock_ops;
	struct rt_mutex bus_lock;
	struct rt_mutex mux_lock;
	int timeout;
	int retries;
	struct device dev;
	unsigned long locked_flags;
	int nr;
	char name[48];
	struct completion dev_released;
	struct mutex userspace_clients_lock;
	struct list_head userspace_clients;
	struct i2c_bus_recovery_info *bus_recovery_info;
	const struct i2c_adapter_quirks *quirks;
	struct irq_domain *host_notify_domain;
	struct regulator *bus_regulator;
};

struct i2c_msg;

union i2c_smbus_data;

struct i2c_algorithm {
	int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*smbus_xfer)(struct i2c_adapter *, u16, unsigned short, char, u8, int, union i2c_smbus_data *);
	int (*smbus_xfer_atomic)(struct i2c_adapter *, u16, unsigned short, char, u8, int, union i2c_smbus_data *);
	u32 (*functionality)(struct i2c_adapter *);
	int (*reg_slave)(struct i2c_client *);
	int (*unreg_slave)(struct i2c_client *);
};

struct i2c_msg {
	__u16 addr;
	__u16 flags;
	__u16 len;
	__u8 *buf;
};

union i2c_smbus_data {
	__u8 byte;
	__u16 word;
	__u8 block[34];
};

struct i2c_lock_operations {
	void (*lock_bus)(struct i2c_adapter *, unsigned int);
	int (*trylock_bus)(struct i2c_adapter *, unsigned int);
	void (*unlock_bus)(struct i2c_adapter *, unsigned int);
};

struct gpio_desc;

struct i2c_bus_recovery_info {
	int (*recover_bus)(struct i2c_adapter *);
	int (*get_scl)(struct i2c_adapter *);
	void (*set_scl)(struct i2c_adapter *, int);
	int (*get_sda)(struct i2c_adapter *);
	void (*set_sda)(struct i2c_adapter *, int);
	int (*get_bus_free)(struct i2c_adapter *);
	void (*prepare_recovery)(struct i2c_adapter *);
	void (*unprepare_recovery)(struct i2c_adapter *);
	struct gpio_desc *scl_gpiod;
	struct gpio_desc *sda_gpiod;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_gpio;
};

struct i2c_adapter_quirks {
	u64 flags;
	int max_num_msgs;
	u16 max_write_len;
	u16 max_read_len;
	u16 max_comb_1st_msg_len;
	u16 max_comb_2nd_msg_len;
};

struct i2c_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct software_node;

struct i2c_board_info {
	char type[20];
	unsigned short flags;
	unsigned short addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct software_node *swnode;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct property_entry;

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[1];
		} value;
	};
};

typedef void (*regmap_lock)(void *);

typedef void (*regmap_unlock)(void *);

enum regcache_type {
	REGCACHE_NONE = 0,
	REGCACHE_RBTREE = 1,
	REGCACHE_FLAT = 2,
	REGCACHE_MAPLE = 3,
};

enum regmap_endian {
	REGMAP_ENDIAN_DEFAULT = 0,
	REGMAP_ENDIAN_BIG = 1,
	REGMAP_ENDIAN_LITTLE = 2,
	REGMAP_ENDIAN_NATIVE = 3,
};

struct regmap_access_table;

struct reg_default;

struct regmap_range_cfg;

struct regmap_config {
	const char *name;
	int reg_bits;
	int reg_stride;
	int reg_shift;
	unsigned int reg_base;
	int pad_bits;
	int val_bits;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	bool disable_locking;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	int (*read)(void *, const void *, size_t, void *, size_t);
	int (*write)(void *, const void *, size_t);
	size_t max_raw_read;
	size_t max_raw_write;
	bool fast_io;
	bool io_port;
	unsigned int max_register;
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	unsigned long read_flag_mask;
	unsigned long write_flag_mask;
	bool zero_flag_mask;
	bool use_single_read;
	bool use_single_write;
	bool use_relaxed_mmio;
	bool can_multi_write;
	enum regmap_endian reg_format_endian;
	enum regmap_endian val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
	bool use_hwlock;
	bool use_raw_spinlock;
	unsigned int hwlock_id;
	unsigned int hwlock_mode;
	bool can_sleep;
};

struct regmap_range;

struct regmap_access_table {
	const struct regmap_range *yes_ranges;
	unsigned int n_yes_ranges;
	const struct regmap_range *no_ranges;
	unsigned int n_no_ranges;
};

struct regmap_range {
	unsigned int range_min;
	unsigned int range_max;
};

struct reg_default {
	unsigned int reg;
	unsigned int def;
};

struct regmap_range_cfg {
	const char *name;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct pca953x_reg_config {
	int direction;
	int output;
	int input;
	int invert;
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

struct acpi_gpio_params;

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

typedef void *acpi_handle;

struct acpi_device_status {
	u32 present: 1;
	u32 enabled: 1;
	u32 show_in_ui: 1;
	u32 functional: 1;
	u32 battery_present: 1;
	u32 reserved: 27;
};

struct acpi_device_flags {
	u32 dynamic_status: 1;
	u32 removable: 1;
	u32 ejectable: 1;
	u32 power_manageable: 1;
	u32 match_driver: 1;
	u32 initialized: 1;
	u32 visited: 1;
	u32 hotplug_notify: 1;
	u32 is_dock_station: 1;
	u32 of_compatible_ok: 1;
	u32 coherent_dma: 1;
	u32 cca_seen: 1;
	u32 enumeration_by_parent: 1;
	u32 honor_deps: 1;
	u32 reserved: 18;
};

typedef char acpi_bus_id[8];

struct acpi_pnp_type {
	u32 hardware_id: 1;
	u32 bus_address: 1;
	u32 platform_id: 1;
	u32 backlight: 1;
	u32 reserved: 28;
};

typedef u64 acpi_bus_address;

typedef char acpi_device_name[40];

typedef char acpi_device_class[20];

union acpi_object;

struct acpi_device_pnp {
	acpi_bus_id bus_id;
	int instance_no;
	struct acpi_pnp_type type;
	acpi_bus_address bus_address;
	char *unique_id;
	struct list_head ids;
	acpi_device_name device_name;
	acpi_device_class device_class;
	union acpi_object *str_obj;
};

struct acpi_device_power_flags {
	u32 explicit_get: 1;
	u32 power_resources: 1;
	u32 inrush_current: 1;
	u32 power_removed: 1;
	u32 ignore_parent: 1;
	u32 dsw_present: 1;
	u32 reserved: 26;
};

struct acpi_device_power_state {
	struct {
		u8 valid: 1;
		u8 explicit_set: 1;
		u8 reserved: 6;
	} flags;
	int power;
	int latency;
	struct list_head resources;
};

struct acpi_device_power {
	int state;
	struct acpi_device_power_flags flags;
	struct acpi_device_power_state states[5];
	u8 state_for_enumeration;
};

struct acpi_device_wakeup_flags {
	u8 valid: 1;
	u8 notifier_present: 1;
};

struct acpi_device_wakeup_context {
	void (*func)(struct acpi_device_wakeup_context *);
	struct device *dev;
};

struct acpi_device_wakeup {
	acpi_handle gpe_device;
	u64 gpe_number;
	u64 sleep_state;
	struct list_head resources;
	struct acpi_device_wakeup_flags flags;
	struct acpi_device_wakeup_context context;
	struct wakeup_source *ws;
	int prepare_count;
	int enable_count;
};

struct acpi_device_perf_flags {
	u8 reserved;
};

struct acpi_device_perf_state;

struct acpi_device_perf {
	int state;
	struct acpi_device_perf_flags flags;
	int state_count;
	struct acpi_device_perf_state *states;
};

struct acpi_device_dir {
	struct proc_dir_entry *entry;
};

struct acpi_device_data {
	const union acpi_object *pointer;
	struct list_head properties;
	const union acpi_object *of_compatible;
	struct list_head subnodes;
};

struct acpi_scan_handler;

struct acpi_hotplug_context;

struct acpi_device {
	u32 pld_crc;
	int device_type;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct list_head wakeup_list;
	struct list_head del_list;
	struct acpi_device_status status;
	struct acpi_device_flags flags;
	struct acpi_device_pnp pnp;
	struct acpi_device_power power;
	struct acpi_device_wakeup wakeup;
	struct acpi_device_perf performance;
	struct acpi_device_dir dir;
	struct acpi_device_data data;
	struct acpi_scan_handler *handler;
	struct acpi_hotplug_context *hp;
	const struct acpi_gpio_mapping *driver_gpios;
	void *driver_data;
	struct device dev;
	unsigned int physical_node_count;
	unsigned int dep_unmet;
	struct list_head physical_node_list;
	struct mutex physical_node_lock;
	void (*remove)(struct acpi_device *);
};

typedef u32 acpi_object_type;

typedef u64 acpi_io_address;

union acpi_object {
	acpi_object_type type;
	struct {
		acpi_object_type type;
		u64 value;
	} integer;
	struct {
		acpi_object_type type;
		u32 length;
		char *pointer;
	} string;
	struct {
		acpi_object_type type;
		u32 length;
		u8 *pointer;
	} buffer;
	struct {
		acpi_object_type type;
		u32 count;
		union acpi_object *elements;
	} package;
	struct {
		acpi_object_type type;
		acpi_object_type actual_type;
		acpi_handle handle;
	} reference;
	struct {
		acpi_object_type type;
		u32 proc_id;
		acpi_io_address pblk_address;
		u32 pblk_length;
	} processor;
	struct {
		acpi_object_type type;
		u32 system_level;
		u32 resource_order;
	} power_resource;
};

struct acpi_device_perf_state {
	struct {
		u8 valid: 1;
		u8 reserved: 7;
	} flags;
	u8 power;
	u8 performance;
	int latency;
};

struct acpi_hotplug_profile {
	struct kobject kobj;
	int (*scan_dependent)(struct acpi_device *);
	void (*notify_online)(struct acpi_device *);
	bool enabled: 1;
	bool demand_offline: 1;
};

struct acpi_scan_handler {
	const struct acpi_device_id *ids;
	struct list_head list_node;
	bool (*match)(const char *, const struct acpi_device_id **);
	int (*attach)(struct acpi_device *, const struct acpi_device_id *);
	void (*detach)(struct acpi_device *);
	void (*bind)(struct device *);
	void (*unbind)(struct device *);
	struct acpi_hotplug_profile hotplug;
};

struct acpi_hotplug_context {
	struct acpi_device *self;
	int (*notify)(struct acpi_device *, u32);
	void (*uevent)(struct acpi_device *, u32);
	void (*fixup)(struct acpi_device *);
};

struct pca953x_chip {
	unsigned int gpio_start;
	struct mutex i2c_lock;
	struct regmap *regmap;
	struct mutex irq_lock;
	unsigned long irq_mask[1];
	unsigned long irq_stat[1];
	unsigned long irq_trig_raise[1];
	unsigned long irq_trig_fall[1];
	atomic_t wakeup_path;
	struct i2c_client *client;
	struct gpio_chip gpio_chip;
	unsigned long driver_data;
	struct regulator *regulator;
	const struct pca953x_reg_config *regs;
	u8 (*recalc_addr)(struct pca953x_chip *, int, int);
	bool (*check_reg)(struct pca953x_chip *, unsigned int, u32);
};

typedef struct mutex *class_mutex_t;

struct pca953x_platform_data {
	unsigned int gpio_base;
	int irq_base;
};

struct uniphier_gpio_priv {
	struct gpio_chip chip;
	struct irq_chip irq_chip;
	struct irq_domain *domain;
	void *regs;
	spinlock_t lock;
	u32 saved_vals[0];
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
	PCI_DEV_FLAGS_HAS_MSI_MASKING = 4096,
};

typedef int pci_power_t;

typedef unsigned int pci_channel_state_t;

typedef unsigned short pci_dev_flags_t;

struct pci_vpd {
	struct mutex lock;
	unsigned int len;
	u8 cap;
};

struct pci_bus;

struct pci_slot;

struct aer_stats;

struct rcec_ea;

struct pci_driver;

struct pcie_link_state;

struct pci_sriov;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	unsigned short vendor;
	unsigned short device;
	unsigned short subsystem_vendor;
	unsigned short subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	u16 aer_cap;
	struct aer_stats *aer_stats;
	struct rcec_ea *rcec_ea;
	struct pci_dev *rcec;
	u32 devcap;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	unsigned long *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	u8 pm_cap;
	unsigned int imm_ready: 1;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	struct pcie_link_state *link_state;
	u16 l1ss;
	unsigned int ltr_path: 1;
	unsigned int pasid_no_tlp: 1;
	unsigned int eetlp_prefix_path: 1;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[17];
	struct resource driver_exclusive_resource;
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int is_msi_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	unsigned int rom_bar_overlap: 1;
	unsigned int rom_attr_enabled: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	spinlock_t pcie_cap_lock;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	struct bin_attribute *res_attr[17];
	struct bin_attribute *res_attr_wc[17];
	void *msix_base;
	raw_spinlock_t msi_lock;
	struct pci_vpd vpd;
	union {
		struct pci_sriov *sriov;
		struct pci_dev *physfn;
	};
	u16 ats_cap;
	u8 ats_stu;
	u16 pasid_cap;
	u16 pasid_features;
	u16 acs_cap;
	phys_addr_t rom;
	size_t romlen;
	const char *driver_override;
	unsigned long priv_flags;
	u8 reset_methods[7];
};

typedef unsigned short pci_bus_flags_t;

struct pci_ops;

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	int domain_nr;
	char name[48];
	unsigned short bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
	unsigned int unsafe_warn: 1;
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

struct hotplug_slot;

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

struct rcec_ea {
	u8 nextbusn;
	u8 lastbusn;
	u32 bitmap;
};

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_device_id;

struct pci_error_handlers;

struct pci_driver {
	struct list_head node;
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	int (*sriov_set_msix_vec_count)(struct pci_dev *, int);
	u32 (*sriov_get_vf_total_msix)(struct pci_dev *);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	struct device_driver driver;
	struct pci_dynids dynids;
	bool driver_managed_dma;
};

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
	__u32 override_only;
};

typedef unsigned int pci_ers_result_t;

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
	void (*cor_error_detected)(struct pci_dev *);
};

struct pci_sriov {
	int pos;
	int nres;
	u32 cap;
	u16 ctrl;
	u16 total_VFs;
	u16 initial_VFs;
	u16 num_VFs;
	u16 offset;
	u16 stride;
	u16 vf_device;
	u32 pgsz;
	u8 link;
	u8 max_VF_buses;
	u16 driver_max_VFs;
	struct pci_dev *dev;
	struct pci_dev *self;
	u32 class;
	u8 hdr_type;
	u16 subsystem_vendor;
	u16 subsystem_device;
	resource_size_t barsz[6];
	bool drivers_autoprobe;
};

enum {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_IOV_RESOURCES = 7,
	PCI_IOV_RESOURCE_END = 12,
	PCI_BRIDGE_RESOURCES = 13,
	PCI_BRIDGE_RESOURCE_END = 16,
	PCI_NUM_RESOURCES = 17,
	DEVICE_COUNT_RESOURCE = 17,
};

struct acpiphp_context;

struct acpiphp_bridge {
	struct list_head list;
	struct list_head slots;
	struct kref ref;
	struct acpiphp_context *context;
	int nr_slots;
	struct pci_bus *pci_bus;
	struct pci_dev *pci_dev;
	bool is_going_away;
};

struct acpiphp_slot;

struct acpiphp_func {
	struct acpiphp_bridge *parent;
	struct acpiphp_slot *slot;
	struct list_head sibling;
	u8 function;
	u32 flags;
};

struct acpiphp_context {
	struct acpi_hotplug_context hp;
	struct acpiphp_func func;
	struct acpiphp_bridge *bridge;
	unsigned int refcount;
};

struct slot;

struct acpiphp_slot {
	struct list_head node;
	struct pci_bus *bus;
	struct list_head funcs;
	struct slot *slot;
	u8 device;
	u32 flags;
};

struct hotplug_slot_ops;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, bool);
};

struct slot {
	struct hotplug_slot hotplug_slot;
	struct acpiphp_slot *acpi_slot;
	unsigned int sun;
};

struct acpiphp_root_context {
	struct acpi_hotplug_context hp;
	struct acpiphp_bridge *root_bridge;
};

typedef u32 acpi_status;

typedef u8 acpi_adr_space_type;

typedef acpi_status (*acpi_walk_callback)(acpi_handle, u32, void *, void **);

typedef char *acpi_string;

struct acpi_object_list {
	u32 count;
	union acpi_object *pointer;
};

enum dw_pcie_ltssm {
	DW_PCIE_LTSSM_DETECT_QUIET = 0,
	DW_PCIE_LTSSM_DETECT_ACT = 1,
	DW_PCIE_LTSSM_L0 = 17,
	DW_PCIE_LTSSM_L2_IDLE = 21,
	DW_PCIE_LTSSM_UNKNOWN = 4294967295,
};

struct dw_pcie;

struct dw_pcie_ops {
	u64 (*cpu_addr_fixup)(struct dw_pcie *, u64);
	u32 (*read_dbi)(struct dw_pcie *, void *, u32, size_t);
	void (*write_dbi)(struct dw_pcie *, void *, u32, size_t, u32);
	void (*write_dbi2)(struct dw_pcie *, void *, u32, size_t, u32);
	int (*link_up)(struct dw_pcie *);
	enum dw_pcie_ltssm (*get_ltssm)(struct dw_pcie *);
	int (*start_link)(struct dw_pcie *);
	void (*stop_link)(struct dw_pcie *);
};

struct dw_pcie_host_ops;

struct pci_host_bridge;

struct dw_pcie_rp {
	bool has_msi_ctrl: 1;
	bool cfg0_io_shared: 1;
	u64 cfg0_base;
	void *va_cfg0_base;
	u32 cfg0_size;
	resource_size_t io_base;
	phys_addr_t io_bus_addr;
	u32 io_size;
	int irq;
	const struct dw_pcie_host_ops *ops;
	int msi_irq[8];
	struct irq_domain *irq_domain;
	struct irq_domain *msi_domain;
	dma_addr_t msi_data;
	struct irq_chip *msi_irq_chip;
	u32 num_vectors;
	u32 irq_mask[8];
	struct pci_host_bridge *bridge;
	raw_spinlock_t lock;
	unsigned long msi_irq_in_use[4];
};

struct pci_epc;

struct dw_pcie_ep_ops;

struct pci_epf_bar;

struct dw_pcie_ep {
	struct pci_epc *epc;
	struct list_head func_list;
	const struct dw_pcie_ep_ops *ops;
	phys_addr_t phys_base;
	size_t addr_size;
	size_t page_size;
	u8 bar_to_atu[6];
	phys_addr_t *outbound_addr;
	unsigned long *ib_window_map;
	unsigned long *ob_window_map;
	void *msi_mem;
	phys_addr_t msi_mem_phys;
	struct pci_epf_bar *epf_bar[6];
};

struct dw_edma_region {
	u64 paddr;
	union {
		void *mem;
		void *io;
	} vaddr;
	size_t sz;
};

enum dw_edma_map_format {
	EDMA_MF_EDMA_LEGACY = 0,
	EDMA_MF_EDMA_UNROLL = 1,
	EDMA_MF_HDMA_COMPAT = 5,
	EDMA_MF_HDMA_NATIVE = 7,
};

struct dw_edma;

struct dw_edma_plat_ops;

struct dw_edma_chip {
	struct device *dev;
	int nr_irqs;
	const struct dw_edma_plat_ops *ops;
	u32 flags;
	void *reg_base;
	u16 ll_wr_cnt;
	u16 ll_rd_cnt;
	struct dw_edma_region ll_region_wr[8];
	struct dw_edma_region ll_region_rd[8];
	struct dw_edma_region dt_region_wr[8];
	struct dw_edma_region dt_region_rd[8];
	enum dw_edma_map_format mf;
	struct dw_edma *dw;
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct reset_control_bulk_data {
	const char *id;
	struct reset_control *rstc;
};

struct dw_pcie {
	struct device *dev;
	void *dbi_base;
	void *dbi_base2;
	void *atu_base;
	size_t atu_size;
	u32 num_ib_windows;
	u32 num_ob_windows;
	u32 region_align;
	u64 region_limit;
	struct dw_pcie_rp pp;
	struct dw_pcie_ep ep;
	const struct dw_pcie_ops *ops;
	u32 version;
	u32 type;
	unsigned long caps;
	int num_lanes;
	int link_gen;
	u8 n_fts[2];
	struct dw_edma_chip edma;
	struct clk_bulk_data app_clks[3];
	struct clk_bulk_data core_clks[4];
	struct reset_control_bulk_data app_rsts[3];
	struct reset_control_bulk_data core_rsts[7];
	struct gpio_desc *pe_rst;
	bool suspended;
};

struct dw_pcie_host_ops {
	int (*host_init)(struct dw_pcie_rp *);
	void (*host_deinit)(struct dw_pcie_rp *);
	void (*host_post_init)(struct dw_pcie_rp *);
	int (*msi_host_init)(struct dw_pcie_rp *);
	void (*pme_turn_off)(struct dw_pcie_rp *);
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	struct pci_ops *child_ops;
	void *sysdata;
	int busnr;
	int domain_nr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	void *release_data;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int no_inc_mrrs: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int native_dpc: 1;
	unsigned int native_cxl_error: 1;
	unsigned int preserve_config: 1;
	unsigned int size_windows: 1;
	unsigned int msi_domain: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	long: 64;
	long: 64;
	unsigned long private[0];
};

struct pci_epc_ops;

struct pci_epc_mem;

struct config_group;

struct pci_epc {
	struct device dev;
	struct list_head pci_epf;
	struct mutex list_lock;
	const struct pci_epc_ops *ops;
	struct pci_epc_mem **windows;
	struct pci_epc_mem *mem;
	unsigned int num_windows;
	u8 max_functions;
	u8 *max_vfs;
	struct config_group *group;
	struct mutex lock;
	unsigned long function_num_map;
};

enum pci_barno {
	NO_BAR = -1,
	BAR_0 = 0,
	BAR_1 = 1,
	BAR_2 = 2,
	BAR_3 = 3,
	BAR_4 = 4,
	BAR_5 = 5,
};

enum pci_epc_irq_type {
	PCI_EPC_IRQ_UNKNOWN = 0,
	PCI_EPC_IRQ_LEGACY = 1,
	PCI_EPC_IRQ_MSI = 2,
	PCI_EPC_IRQ_MSIX = 3,
};

struct pci_epf_header;

struct pci_epc_features;

struct pci_epc_ops {
	int (*write_header)(struct pci_epc *, u8, u8, struct pci_epf_header *);
	int (*set_bar)(struct pci_epc *, u8, u8, struct pci_epf_bar *);
	void (*clear_bar)(struct pci_epc *, u8, u8, struct pci_epf_bar *);
	int (*map_addr)(struct pci_epc *, u8, u8, phys_addr_t, u64, size_t);
	void (*unmap_addr)(struct pci_epc *, u8, u8, phys_addr_t);
	int (*set_msi)(struct pci_epc *, u8, u8, u8);
	int (*get_msi)(struct pci_epc *, u8, u8);
	int (*set_msix)(struct pci_epc *, u8, u8, u16, enum pci_barno, u32);
	int (*get_msix)(struct pci_epc *, u8, u8);
	int (*raise_irq)(struct pci_epc *, u8, u8, enum pci_epc_irq_type, u16);
	int (*map_msi_irq)(struct pci_epc *, u8, u8, phys_addr_t, u8, u32, u32 *, u32 *);
	int (*start)(struct pci_epc *);
	void (*stop)(struct pci_epc *);
	const struct pci_epc_features * (*get_features)(struct pci_epc *, u8, u8);
	struct module *owner;
};

enum pci_interrupt_pin {
	PCI_INTERRUPT_UNKNOWN = 0,
	PCI_INTERRUPT_INTA = 1,
	PCI_INTERRUPT_INTB = 2,
	PCI_INTERRUPT_INTC = 3,
	PCI_INTERRUPT_INTD = 4,
};

struct pci_epf_header {
	u16 vendorid;
	u16 deviceid;
	u8 revid;
	u8 progif_code;
	u8 subclass_code;
	u8 baseclass_code;
	u8 cache_line_size;
	u16 subsys_vendor_id;
	u16 subsys_id;
	enum pci_interrupt_pin interrupt_pin;
};

struct pci_epf_bar {
	dma_addr_t phys_addr;
	void *addr;
	size_t size;
	enum pci_barno barno;
	int flags;
};

struct pci_epc_features {
	unsigned int linkup_notifier: 1;
	unsigned int core_init_notifier: 1;
	unsigned int msi_capable: 1;
	unsigned int msix_capable: 1;
	u8 reserved_bar;
	u8 bar_fixed_64bit;
	u64 bar_fixed_size[6];
	size_t align;
};

struct pci_epc_mem_window {
	phys_addr_t phys_base;
	size_t size;
	size_t page_size;
};

struct pci_epc_mem {
	struct pci_epc_mem_window window;
	unsigned long *bitmap;
	int pages;
	struct mutex lock;
};

struct config_item_type;

struct config_item {
	char *ci_name;
	char ci_namebuf[20];
	struct kref ci_kref;
	struct list_head ci_entry;
	struct config_item *ci_parent;
	struct config_group *ci_group;
	const struct config_item_type *ci_type;
	struct dentry *ci_dentry;
};

struct configfs_subsystem;

struct config_group {
	struct config_item cg_item;
	struct list_head cg_children;
	struct configfs_subsystem *cg_subsys;
	struct list_head default_groups;
	struct list_head group_entry;
};

struct configfs_item_operations;

struct configfs_group_operations;

struct configfs_attribute;

struct configfs_bin_attribute;

struct config_item_type {
	struct module *ct_owner;
	struct configfs_item_operations *ct_item_ops;
	struct configfs_group_operations *ct_group_ops;
	struct configfs_attribute **ct_attrs;
	struct configfs_bin_attribute **ct_bin_attrs;
};

struct configfs_item_operations {
	void (*release)(struct config_item *);
	int (*allow_link)(struct config_item *, struct config_item *);
	void (*drop_link)(struct config_item *, struct config_item *);
};

struct configfs_group_operations {
	struct config_item * (*make_item)(struct config_group *, const char *);
	struct config_group * (*make_group)(struct config_group *, const char *);
	void (*disconnect_notify)(struct config_group *, struct config_item *);
	void (*drop_item)(struct config_group *, struct config_item *);
};

struct configfs_attribute {
	const char *ca_name;
	struct module *ca_owner;
	umode_t ca_mode;
	ssize_t (*show)(struct config_item *, char *);
	ssize_t (*store)(struct config_item *, const char *, size_t);
};

struct configfs_bin_attribute {
	struct configfs_attribute cb_attr;
	void *cb_private;
	size_t cb_max_size;
	ssize_t (*read)(struct config_item *, void *, size_t);
	ssize_t (*write)(struct config_item *, const void *, size_t);
};

struct configfs_subsystem {
	struct config_group su_group;
	struct mutex su_mutex;
};

struct dw_pcie_ep_ops {
	void (*pre_init)(struct dw_pcie_ep *);
	void (*ep_init)(struct dw_pcie_ep *);
	void (*deinit)(struct dw_pcie_ep *);
	int (*raise_irq)(struct dw_pcie_ep *, u8, enum pci_epc_irq_type, u16);
	const struct pci_epc_features * (*get_features)(struct dw_pcie_ep *);
	unsigned int (*func_conf_select)(struct dw_pcie_ep *, u8);
	unsigned int (*get_dbi2_offset)(struct dw_pcie_ep *, u8);
};

struct dw_edma_plat_ops {
	int (*irq_vector)(struct device *, unsigned int);
	u64 (*pci_address)(struct device *, phys_addr_t);
};

struct visconti_pcie {
	struct dw_pcie pci;
	void *ulreg_base;
	void *smu_base;
	void *mpu_base;
	struct clk *refclk;
	struct clk *coreclk;
	struct clk *auxclk;
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_fix_screeninfo {
	char id[16];
	unsigned long smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	unsigned long mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_info;

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	u32 blit_x;
	u32 blit_y;
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_deferred_io_pageref;

struct fb_deferred_io;

struct fb_ops;

struct fb_info {
	refcount_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct delayed_work deferred_work;
	unsigned long npagerefs;
	struct fb_deferred_io_pageref *pagerefs;
	struct fb_deferred_io *fbdefio;
	const struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	unsigned long screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	bool skip_vt_switch;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_deferred_io_pageref {
	struct page *page;
	unsigned long offset;
	struct list_head list;
};

struct fb_deferred_io {
	unsigned long delay;
	bool sort_pagereflist;
	int open_count;
	struct mutex lock;
	struct list_head pagereflist;
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct fb_fillrect;

struct fb_copyarea;

struct fb_image;

struct fb_cursor;

struct fb_blit_caps;

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, unsigned long);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, unsigned long);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_blit_caps {
	u32 x;
	u32 y;
	u32 len;
	u32 flags;
};

typedef u64 phys_cpuid_t;

struct acpi_processor_flags {
	u8 power: 1;
	u8 performance: 1;
	u8 throttling: 1;
	u8 limit: 1;
	u8 bm_control: 1;
	u8 bm_check: 1;
	u8 has_cst: 1;
	u8 has_lpi: 1;
	u8 power_setup_done: 1;
	u8 bm_rld_set: 1;
	u8 need_hotplug_init: 1;
};

struct acpi_processor_cx {
	u8 valid;
	u8 type;
	u32 address;
	u8 entry_method;
	u8 index;
	u32 latency;
	u8 bm_sts_skip;
	char desc[32];
};

struct acpi_lpi_state {
	u32 min_residency;
	u32 wake_latency;
	u32 flags;
	u32 arch_flags;
	u32 res_cnt_freq;
	u32 enable_parent_state;
	u64 address;
	u8 index;
	u8 entry_method;
	char desc[32];
};

struct acpi_processor_power {
	int count;
	union {
		struct acpi_processor_cx states[8];
		struct acpi_lpi_state lpi_states[8];
	};
	int timer_broadcast_on_state;
};

struct acpi_pct_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_tsd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_tx {
	u16 power;
	u16 performance;
};

struct acpi_processor_tx_tss;

struct acpi_processor;

struct acpi_processor_throttling {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	unsigned int state_count;
	struct acpi_processor_tx_tss *states_tss;
	struct acpi_tsd_package domain_info;
	cpumask_var_t shared_cpu_map;
	int (*acpi_processor_get_throttling)(struct acpi_processor *);
	int (*acpi_processor_set_throttling)(struct acpi_processor *, int, bool);
	u32 address;
	u8 duty_offset;
	u8 duty_width;
	u8 tsd_valid_flag;
	unsigned int shared_type;
	struct acpi_processor_tx states[16];
};

struct acpi_processor_lx {
	int px;
	int tx;
};

struct acpi_processor_limit {
	struct acpi_processor_lx state;
	struct acpi_processor_lx thermal;
	struct acpi_processor_lx user;
};

struct acpi_processor_performance;

struct acpi_processor {
	acpi_handle handle;
	u32 acpi_id;
	phys_cpuid_t phys_id;
	u32 id;
	u32 pblk;
	int performance_platform_limit;
	int throttling_platform_limit;
	struct acpi_processor_flags flags;
	struct acpi_processor_power power;
	struct acpi_processor_performance *performance;
	struct acpi_processor_throttling throttling;
	struct acpi_processor_limit limit;
	struct thermal_cooling_device *cdev;
	struct device *dev;
	struct freq_qos_request perflib_req;
	struct freq_qos_request thermal_req;
};

struct acpi_psd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_px;

struct acpi_processor_performance {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	unsigned int state_count;
	struct acpi_processor_px *states;
	struct acpi_psd_package domain_info;
	cpumask_var_t shared_cpu_map;
	unsigned int shared_type;
};

struct acpi_processor_px {
	u64 core_frequency;
	u64 power;
	u64 transition_latency;
	u64 bus_master_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_tx_tss {
	u64 freqpercentage;
	u64 power;
	u64 transition_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_errata {
	u8 smp;
	struct {
		u8 throttle: 1;
		u8 fdma: 1;
		u8 reserved: 6;
		u32 bmisx;
	} piix4;
};

typedef u64 acpi_size;

struct acpi_buffer {
	acpi_size length;
	void *pointer;
};

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	u64 dma_mask;
	const struct property_entry *properties;
};

typedef u64 acpi_physical_address;

typedef acpi_status (*acpi_adr_space_handler)(u32, acpi_physical_address, u32, u64 *, void *, void *);

typedef acpi_status (*acpi_adr_space_setup)(acpi_handle, u32, void *, void **);

union acpi_name_union {
	u32 integer;
	char ascii[4];
};

typedef u16 acpi_owner_id;

union acpi_operand_object;

struct acpi_namespace_node {
	union acpi_operand_object *object;
	u8 descriptor_type;
	u8 type;
	u16 flags;
	union acpi_name_union name;
	struct acpi_namespace_node *parent;
	struct acpi_namespace_node *child;
	struct acpi_namespace_node *peer;
	acpi_owner_id owner_id;
};

struct acpi_object_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
};

struct acpi_object_integer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 fill[3];
	u64 value;
};

struct acpi_object_string {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	char *pointer;
	u32 length;
};

struct acpi_object_buffer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 *pointer;
	u32 length;
	u32 aml_length;
	u8 *aml_start;
	struct acpi_namespace_node *node;
};

struct acpi_object_package {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	union acpi_operand_object **elements;
	u8 *aml_start;
	u32 aml_length;
	u32 count;
};

struct acpi_object_event {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	void *os_semaphore;
};

struct acpi_walk_state;

typedef acpi_status (*acpi_internal_method)(struct acpi_walk_state *);

struct acpi_object_method {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 info_flags;
	u8 param_count;
	u8 sync_level;
	union acpi_operand_object *mutex;
	union acpi_operand_object *node;
	u8 *aml_start;
	union {
		acpi_internal_method implementation;
		union acpi_operand_object *handler;
	} dispatch;
	u32 aml_length;
	acpi_owner_id owner_id;
	u8 thread_count;
};

struct acpi_thread_state;

struct acpi_object_mutex {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 sync_level;
	u16 acquisition_depth;
	void *os_mutex;
	u64 thread_id;
	struct acpi_thread_state *owner_thread;
	union acpi_operand_object *prev;
	union acpi_operand_object *next;
	struct acpi_namespace_node *node;
	u8 original_sync_level;
};

struct acpi_object_region {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler;
	union acpi_operand_object *next;
	acpi_physical_address address;
	u32 length;
	void *pointer;
};

struct acpi_object_notify_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_gpe_block_info;

struct acpi_object_device {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	struct acpi_gpe_block_info *gpe_block;
};

struct acpi_object_power_resource {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	u32 system_level;
	u32 resource_order;
};

struct acpi_object_processor {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 proc_id;
	u8 length;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	acpi_io_address address;
};

struct acpi_object_thermal_zone {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_object_field_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
};

struct acpi_object_region_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u16 resource_length;
	union acpi_operand_object *region_obj;
	u8 *resource_buffer;
	u16 pin_number_index;
	u8 *internal_pcc_buffer;
};

struct acpi_object_buffer_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u8 is_create_field;
	union acpi_operand_object *buffer_obj;
};

struct acpi_object_bank_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
	union acpi_operand_object *bank_obj;
};

struct acpi_object_index_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *index_obj;
	union acpi_operand_object *data_obj;
};

typedef void (*acpi_notify_handler)(acpi_handle, u32, void *);

struct acpi_object_notify_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	u32 handler_type;
	acpi_notify_handler handler;
	void *context;
	union acpi_operand_object *next[2];
};

struct acpi_object_addr_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	u8 handler_flags;
	acpi_adr_space_handler handler;
	struct acpi_namespace_node *node;
	void *context;
	void *context_mutex;
	acpi_adr_space_setup setup;
	union acpi_operand_object *region_list;
	union acpi_operand_object *next;
};

struct acpi_object_reference {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 class;
	u8 target_type;
	u8 resolved;
	void *object;
	struct acpi_namespace_node *node;
	union acpi_operand_object **where;
	u8 *index_pointer;
	u8 *aml;
	u32 value;
};

struct acpi_object_extra {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *method_REG;
	struct acpi_namespace_node *scope_node;
	void *region_context;
	u8 *aml_start;
	u32 aml_length;
};

typedef void (*acpi_object_handler)(acpi_handle, void *);

struct acpi_object_data {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	acpi_object_handler handler;
	void *pointer;
};

struct acpi_object_cache_list {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *next;
};

union acpi_operand_object {
	struct acpi_object_common common;
	struct acpi_object_integer integer;
	struct acpi_object_string string;
	struct acpi_object_buffer buffer;
	struct acpi_object_package package;
	struct acpi_object_event event;
	struct acpi_object_method method;
	struct acpi_object_mutex mutex;
	struct acpi_object_region region;
	struct acpi_object_notify_common common_notify;
	struct acpi_object_device device;
	struct acpi_object_power_resource power_resource;
	struct acpi_object_processor processor;
	struct acpi_object_thermal_zone thermal_zone;
	struct acpi_object_field_common common_field;
	struct acpi_object_region_field field;
	struct acpi_object_buffer_field buffer_field;
	struct acpi_object_bank_field bank_field;
	struct acpi_object_index_field index_field;
	struct acpi_object_notify_handler notify;
	struct acpi_object_addr_handler address_space;
	struct acpi_object_reference reference;
	struct acpi_object_extra extra;
	struct acpi_object_data data;
	struct acpi_object_cache_list cache;
	struct acpi_namespace_node node;
};

union acpi_parse_object;

union acpi_generic_state;

struct acpi_parse_state {
	u8 *aml_start;
	u8 *aml;
	u8 *aml_end;
	u8 *pkg_start;
	u8 *pkg_end;
	union acpi_parse_object *start_op;
	struct acpi_namespace_node *start_node;
	union acpi_generic_state *scope;
	union acpi_parse_object *start_scope;
	u32 aml_size;
};

typedef acpi_status (*acpi_parse_downwards)(struct acpi_walk_state *, union acpi_parse_object **);

typedef acpi_status (*acpi_parse_upwards)(struct acpi_walk_state *);

struct acpi_opcode_info;

struct acpi_walk_state {
	struct acpi_walk_state *next;
	u8 descriptor_type;
	u8 walk_type;
	u16 opcode;
	u8 next_op_info;
	u8 num_operands;
	u8 operand_index;
	acpi_owner_id owner_id;
	u8 last_predicate;
	u8 current_result;
	u8 return_used;
	u8 scope_depth;
	u8 pass_number;
	u8 namespace_override;
	u8 result_size;
	u8 result_count;
	u8 *aml;
	u32 arg_types;
	u32 method_breakpoint;
	u32 user_breakpoint;
	u32 parse_flags;
	struct acpi_parse_state parser_state;
	u32 prev_arg_types;
	u32 arg_count;
	u16 method_nesting_depth;
	u8 method_is_nested;
	struct acpi_namespace_node arguments[7];
	struct acpi_namespace_node local_variables[8];
	union acpi_operand_object *operands[9];
	union acpi_operand_object **params;
	u8 *aml_last_while;
	union acpi_operand_object **caller_return_desc;
	union acpi_generic_state *control_state;
	struct acpi_namespace_node *deferred_node;
	union acpi_operand_object *implicit_return_obj;
	struct acpi_namespace_node *method_call_node;
	union acpi_parse_object *method_call_op;
	union acpi_operand_object *method_desc;
	struct acpi_namespace_node *method_node;
	char *method_pathname;
	union acpi_parse_object *op;
	const struct acpi_opcode_info *op_info;
	union acpi_parse_object *origin;
	union acpi_operand_object *result_obj;
	union acpi_generic_state *results;
	union acpi_operand_object *return_desc;
	union acpi_generic_state *scope_info;
	union acpi_parse_object *prev_op;
	union acpi_parse_object *next_op;
	struct acpi_thread_state *thread;
	acpi_parse_downwards descending_callback;
	acpi_parse_upwards ascending_callback;
};

union acpi_parse_value {
	u64 integer;
	u32 size;
	char *string;
	u8 *buffer;
	char *name;
	union acpi_parse_object *arg;
};

struct acpi_parse_obj_common {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
};

struct acpi_parse_obj_named {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	char *path;
	u8 *data;
	u32 length;
	u32 name;
};

struct acpi_parse_obj_asl {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	union acpi_parse_object *child;
	union acpi_parse_object *parent_method;
	char *filename;
	u8 file_changed;
	char *parent_filename;
	char *external_name;
	char *namepath;
	char name_seg[4];
	u32 extra_value;
	u32 column;
	u32 line_number;
	u32 logical_line_number;
	u32 logical_byte_offset;
	u32 end_line;
	u32 end_logical_line;
	u32 acpi_btype;
	u32 aml_length;
	u32 aml_subtree_length;
	u32 final_aml_length;
	u32 final_aml_offset;
	u32 compile_flags;
	u16 parse_opcode;
	u8 aml_opcode_length;
	u8 aml_pkg_len_bytes;
	u8 extra;
	char parse_op_name[20];
};

union acpi_parse_object {
	struct acpi_parse_obj_common common;
	struct acpi_parse_obj_named named;
	struct acpi_parse_obj_asl asl;
};

struct acpi_common_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
};

struct acpi_control_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u16 opcode;
	union acpi_parse_object *predicate_op;
	u8 *aml_predicate_start;
	u8 *package_end;
	u64 loop_timeout;
};

struct acpi_update_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *object;
};

struct acpi_scope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	struct acpi_namespace_node *node;
};

struct acpi_pscope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 arg_count;
	union acpi_parse_object *op;
	u8 *arg_end;
	u8 *pkg_end;
	u32 arg_list;
};

struct acpi_pkg_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 index;
	union acpi_operand_object *source_object;
	union acpi_operand_object *dest_object;
	struct acpi_walk_state *walk_state;
	void *this_target_obj;
	u32 num_packages;
};

struct acpi_thread_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 current_sync_level;
	struct acpi_walk_state *walk_state_list;
	union acpi_operand_object *acquired_mutex_list;
	u64 thread_id;
};

struct acpi_result_values {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *obj_desc[8];
};

struct acpi_global_notify_handler;

struct acpi_notify_info {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 handler_list_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler_list_head;
	struct acpi_global_notify_handler *global;
};

union acpi_generic_state {
	struct acpi_common_state common;
	struct acpi_control_state control;
	struct acpi_update_state update;
	struct acpi_scope_state scope;
	struct acpi_pscope_state parse_scope;
	struct acpi_pkg_state pkg;
	struct acpi_thread_state thread;
	struct acpi_result_values results;
	struct acpi_notify_info notify;
};

struct acpi_global_notify_handler {
	acpi_notify_handler handler;
	void *context;
};

struct acpi_opcode_info {
	u32 parse_args;
	u32 runtime_args;
	u16 flags;
	u8 object_type;
	u8 class;
	u8 type;
};

struct acpi_gpe_xrupt_info;

struct acpi_gpe_register_info;

struct acpi_gpe_event_info;

struct acpi_gpe_block_info {
	struct acpi_namespace_node *node;
	struct acpi_gpe_block_info *previous;
	struct acpi_gpe_block_info *next;
	struct acpi_gpe_xrupt_info *xrupt_block;
	struct acpi_gpe_register_info *register_info;
	struct acpi_gpe_event_info *event_info;
	u64 address;
	u32 register_count;
	u16 gpe_count;
	u16 block_base_number;
	u8 space_id;
	u8 initialized;
};

struct acpi_gpe_xrupt_info {
	struct acpi_gpe_xrupt_info *previous;
	struct acpi_gpe_xrupt_info *next;
	struct acpi_gpe_block_info *gpe_block_list_head;
	u32 interrupt_number;
};

struct acpi_gpe_address {
	u8 space_id;
	u64 address;
};

struct acpi_gpe_register_info {
	struct acpi_gpe_address status_address;
	struct acpi_gpe_address enable_address;
	u16 base_gpe_number;
	u8 enable_for_wake;
	u8 enable_for_run;
	u8 mask_for_run;
	u8 enable_mask;
};

struct acpi_gpe_handler_info;

struct acpi_gpe_notify_info;

union acpi_gpe_dispatch_info {
	struct acpi_namespace_node *method_node;
	struct acpi_gpe_handler_info *handler;
	struct acpi_gpe_notify_info *notify_list;
};

struct acpi_gpe_event_info {
	union acpi_gpe_dispatch_info dispatch;
	struct acpi_gpe_register_info *register_info;
	u8 flags;
	u8 gpe_number;
	u8 runtime_count;
	u8 disable_for_dispatch;
};

typedef u32 (*acpi_gpe_handler)(acpi_handle, u32, void *);

struct acpi_gpe_handler_info {
	acpi_gpe_handler address;
	void *context;
	struct acpi_namespace_node *method_node;
	u8 original_flags;
	u8 originally_enabled;
};

struct acpi_gpe_notify_info {
	struct acpi_namespace_node *device_node;
	struct acpi_gpe_notify_info *next;
};

typedef u32 acpi_mutex_handle;

enum {
	ACPI_REFCLASS_LOCAL = 0,
	ACPI_REFCLASS_ARG = 1,
	ACPI_REFCLASS_REFOF = 2,
	ACPI_REFCLASS_INDEX = 3,
	ACPI_REFCLASS_TABLE = 4,
	ACPI_REFCLASS_NAME = 5,
	ACPI_REFCLASS_DEBUG = 6,
	ACPI_REFCLASS_MAX = 6,
};

struct acpi_common_descriptor {
	void *common_pointer;
	u8 descriptor_type;
};

union acpi_descriptor {
	struct acpi_common_descriptor common;
	union acpi_operand_object object;
	struct acpi_namespace_node node;
	union acpi_parse_object op;
};

struct acpi_memory_attribute {
	u8 write_protect;
	u8 caching;
	u8 range_type;
	u8 translation;
};

struct acpi_io_attribute {
	u8 range_type;
	u8 translation;
	u8 translation_type;
	u8 reserved1;
};

union acpi_resource_attribute {
	struct acpi_memory_attribute mem;
	struct acpi_io_attribute io;
	u8 type_specific;
};

struct acpi_address16_attribute {
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
};

struct acpi_resource_source {
	u8 index;
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_address16 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address16_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_address32_attribute {
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
};

struct acpi_resource_address32 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address32_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_irq {
	u8 descriptor_length;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	union {
		u8 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u8 interrupts[0];
		};
	};
};

struct acpi_resource_dma {
	u8 type;
	u8 bus_master;
	u8 transfer;
	u8 channel_count;
	union {
		u8 channel;
		struct {
			struct {} __Empty_channels;
			u8 channels[0];
		};
	};
};

struct acpi_resource_start_dependent {
	u8 descriptor_length;
	u8 compatibility_priority;
	u8 performance_robustness;
};

struct acpi_resource_io {
	u8 io_decode;
	u8 alignment;
	u8 address_length;
	u16 minimum;
	u16 maximum;
} __attribute__((packed));

struct acpi_resource_fixed_io {
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_dma {
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct acpi_resource_vendor {
	u16 byte_length;
	u8 byte_data[0];
};

struct acpi_resource_vendor_typed {
	u16 byte_length;
	u8 uuid_subtype;
	u8 uuid[16];
	u8 byte_data[0];
} __attribute__((packed));

struct acpi_resource_end_tag {
	u8 checksum;
};

struct acpi_resource_memory24 {
	u8 write_protect;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct acpi_resource_memory32 {
	u8 write_protect;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_memory32 {
	u8 write_protect;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct acpi_address64_attribute {
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
};

struct acpi_resource_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address64_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_extended_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	u8 revision_ID;
	struct acpi_address64_attribute address;
	u64 type_specific;
} __attribute__((packed));

struct acpi_resource_extended_irq {
	u8 producer_consumer;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	struct acpi_resource_source resource_source;
	union {
		u32 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u32 interrupts[0];
		};
	};
} __attribute__((packed));

struct acpi_resource_generic_register {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_resource_gpio {
	u8 revision_id;
	u8 connection_type;
	u8 producer_consumer;
	u8 pin_config;
	u8 shareable;
	u8 wake_capable;
	u8 io_restriction;
	u8 triggering;
	u8 polarity;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_i2c_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 access_mode;
	u16 slave_address;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_spi_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 wire_mode;
	u8 device_polarity;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_uart_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 endian;
	u8 data_bits;
	u8 stop_bits;
	u8 flow_control;
	u8 parity;
	u8 lines_enabled;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u32 default_baud_rate;
} __attribute__((packed));

struct acpi_resource_csi2_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 local_port_instance;
	u8 phy_type;
} __attribute__((packed));

struct acpi_resource_common_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_function {
	u8 revision_id;
	u8 pin_config;
	u8 shareable;
	u16 function_number;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_label {
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_pin_group {
	u8 revision_id;
	u8 producer_consumer;
	u16 pin_table_length;
	u16 vendor_length;
	u16 *pin_table;
	struct acpi_resource_label resource_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_function {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u16 function_number;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_clock_input {
	u8 revision_id;
	u8 mode;
	u8 scale;
	u16 frequency_divisor;
	u32 frequency_numerator;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
};

union acpi_resource_data {
	struct acpi_resource_irq irq;
	struct acpi_resource_dma dma;
	struct acpi_resource_start_dependent start_dpf;
	struct acpi_resource_io io;
	struct acpi_resource_fixed_io fixed_io;
	struct acpi_resource_fixed_dma fixed_dma;
	struct acpi_resource_vendor vendor;
	struct acpi_resource_vendor_typed vendor_typed;
	struct acpi_resource_end_tag end_tag;
	struct acpi_resource_memory24 memory24;
	struct acpi_resource_memory32 memory32;
	struct acpi_resource_fixed_memory32 fixed_memory32;
	struct acpi_resource_address16 address16;
	struct acpi_resource_address32 address32;
	struct acpi_resource_address64 address64;
	struct acpi_resource_extended_address64 ext_address64;
	struct acpi_resource_extended_irq extended_irq;
	struct acpi_resource_generic_register generic_reg;
	struct acpi_resource_gpio gpio;
	struct acpi_resource_i2c_serialbus i2c_serial_bus;
	struct acpi_resource_spi_serialbus spi_serial_bus;
	struct acpi_resource_uart_serialbus uart_serial_bus;
	struct acpi_resource_csi2_serialbus csi2_serial_bus;
	struct acpi_resource_common_serialbus common_serial_bus;
	struct acpi_resource_pin_function pin_function;
	struct acpi_resource_pin_config pin_config;
	struct acpi_resource_pin_group pin_group;
	struct acpi_resource_pin_group_function pin_group_function;
	struct acpi_resource_pin_group_config pin_group_config;
	struct acpi_resource_clock_input clock_input;
	struct acpi_resource_address address;
};

struct acpi_resource {
	u32 type;
	u32 length;
	union acpi_resource_data data;
};

typedef acpi_status (*acpi_walk_resource_callback)(struct acpi_resource *, void *);

struct acpi_vendor_uuid;

struct acpi_vendor_walk_info {
	struct acpi_vendor_uuid *uuid;
	struct acpi_buffer *buffer;
	acpi_status status;
};

struct acpi_vendor_uuid {
	u8 subtype;
	u8 data[16];
};

struct pci_ecam_ops;

struct mcfg_fixup {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
	u16 segment;
	struct resource bus_range;
	const struct pci_ecam_ops *ops;
	struct resource cfgres;
};

struct pci_config_window;

struct pci_ecam_ops {
	unsigned int bus_shift;
	struct pci_ops pci_ops;
	int (*init)(struct pci_config_window *);
};

struct pci_config_window {
	struct resource res;
	struct resource busr;
	unsigned int bus_shift;
	void *priv;
	const struct pci_ecam_ops *ops;
	union {
		void *win;
		void **winp;
	};
	struct device *parent;
};

struct mcfg_entry {
	struct list_head list;
	phys_addr_t addr;
	u16 segment;
	u8 bus_start;
	u8 bus_end;
};

struct acpi_table_header {
	char signature[4];
	u32 length;
	u8 revision;
	u8 checksum;
	char oem_id[6];
	char oem_table_id[8];
	u32 oem_revision;
	char asl_compiler_id[4];
	u32 asl_compiler_revision;
};

struct acpi_table_mcfg {
	struct acpi_table_header header;
	u8 reserved[8];
};

struct acpi_mcfg_allocation {
	u64 address;
	u16 pci_segment;
	u8 start_bus_number;
	u8 end_bus_number;
	u32 reserved;
};

struct acpi_pci_root {
	struct acpi_device *device;
	struct pci_bus *bus;
	u16 segment;
	int bridge_type;
	struct resource secondary;
	u32 osc_support_set;
	u32 osc_control_set;
	u32 osc_ext_support_set;
	u32 osc_ext_control_set;
	phys_addr_t mcfg_addr;
};

typedef int (*acpi_tbl_table_handler)(struct acpi_table_header *);

struct clk_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct clk *clk;
	struct clk_hw *clk_hw;
};

struct clk_lookup_alloc {
	struct clk_lookup cl;
	char dev_id[20];
	char con_id[16];
};

struct scmi_device;

struct scmi_device_id;

struct scmi_driver {
	const char *name;
	int (*probe)(struct scmi_device *);
	void (*remove)(struct scmi_device *);
	const struct scmi_device_id *id_table;
	struct device_driver driver;
};

struct scmi_handle;

struct scmi_device {
	u32 id;
	u8 protocol_id;
	const char *name;
	struct device dev;
	struct scmi_handle *handle;
};

struct scmi_revision_info;

struct scmi_protocol_handle;

struct scmi_notify_ops;

struct scmi_handle {
	struct device *dev;
	struct scmi_revision_info *version;
	int (*devm_protocol_acquire)(struct scmi_device *, u8);
	const void * (*devm_protocol_get)(struct scmi_device *, u8, struct scmi_protocol_handle **);
	void (*devm_protocol_put)(struct scmi_device *, u8);
	bool (*is_transport_atomic)(const struct scmi_handle *, unsigned int *);
	const struct scmi_notify_ops *notify_ops;
};

struct scmi_revision_info {
	u16 major_ver;
	u16 minor_ver;
	u8 num_protocols;
	u8 num_agents;
	u32 impl_ver;
	char vendor_id[16];
	char sub_vendor_id[16];
};

struct scmi_notify_ops {
	int (*devm_event_notifier_register)(struct scmi_device *, u8, u8, const u32 *, struct notifier_block *);
	int (*devm_event_notifier_unregister)(struct scmi_device *, u8, u8, const u32 *, struct notifier_block *);
	int (*event_notifier_register)(const struct scmi_handle *, u8, u8, const u32 *, struct notifier_block *);
	int (*event_notifier_unregister)(const struct scmi_handle *, u8, u8, const u32 *, struct notifier_block *);
};

struct scmi_device_id {
	u8 protocol_id;
	const char *name;
};

struct scmi_clock_info;

struct scmi_clk_proto_ops {
	int (*count_get)(const struct scmi_protocol_handle *);
	const struct scmi_clock_info * (*info_get)(const struct scmi_protocol_handle *, u32);
	int (*rate_get)(const struct scmi_protocol_handle *, u32, u64 *);
	int (*rate_set)(const struct scmi_protocol_handle *, u32, u64);
	int (*enable)(const struct scmi_protocol_handle *, u32, bool);
	int (*disable)(const struct scmi_protocol_handle *, u32, bool);
	int (*state_get)(const struct scmi_protocol_handle *, u32, bool *, bool);
	int (*config_oem_get)(const struct scmi_protocol_handle *, u32, u8, u32 *, u32 *, bool);
	int (*config_oem_set)(const struct scmi_protocol_handle *, u32, u8, u32, bool);
	int (*parent_get)(const struct scmi_protocol_handle *, u32, u32 *);
	int (*parent_set)(const struct scmi_protocol_handle *, u32, u32);
};

struct scmi_xfer_ops;

struct scmi_proto_helpers_ops;

struct scmi_protocol_handle {
	struct device *dev;
	const struct scmi_xfer_ops *xops;
	const struct scmi_proto_helpers_ops *hops;
	int (*set_priv)(const struct scmi_protocol_handle *, void *);
	void * (*get_priv)(const struct scmi_protocol_handle *);
};

struct scmi_clock_info {
	char name[64];
	unsigned int enable_latency;
	bool rate_discrete;
	bool rate_changed_notifications;
	bool rate_change_requested_notifications;
	union {
		struct {
			int num_rates;
			u64 rates[16];
		} list;
		struct {
			u64 min_rate;
			u64 max_rate;
			u64 step_size;
		} range;
	};
	int num_parents;
	u32 *parents;
};

enum scmi_std_protocol {
	SCMI_PROTOCOL_BASE = 16,
	SCMI_PROTOCOL_POWER = 17,
	SCMI_PROTOCOL_SYSTEM = 18,
	SCMI_PROTOCOL_PERF = 19,
	SCMI_PROTOCOL_CLOCK = 20,
	SCMI_PROTOCOL_SENSOR = 21,
	SCMI_PROTOCOL_RESET = 22,
	SCMI_PROTOCOL_VOLTAGE = 23,
	SCMI_PROTOCOL_POWERCAP = 24,
};

struct scmi_clk {
	u32 id;
	struct device *dev;
	struct clk_hw hw;
	const struct scmi_clock_info *info;
	const struct scmi_protocol_handle *ph;
	struct clk_parent_data *parent_data;
};

struct clk_hw_onecell_data {
	unsigned int num;
	struct clk_hw *hws[0];
};

struct berlin2_pll_map {
	const u8 vcodiv[16];
	u8 mult;
	u8 fbdiv_shift;
	u8 rfdiv_shift;
	u8 divsel_shift;
};

struct berlin2_pll {
	struct clk_hw hw;
	void *base;
	struct berlin2_pll_map map;
};

struct hisi_phase_clock {
	unsigned int id;
	const char *name;
	const char *parent_names;
	unsigned long flags;
	unsigned long offset;
	u8 shift;
	u8 width;
	u32 *phase_degrees;
	u32 *phase_regvals;
	u8 phase_num;
};

struct clk_div_table {
	unsigned int val;
	unsigned int div;
};

struct clk_onecell_data {
	struct clk **clks;
	unsigned int clk_num;
};

struct hisi_clock_data {
	struct clk_onecell_data clk_data;
	void *base;
};

struct hisi_fixed_rate_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	unsigned long flags;
	unsigned long fixed_rate;
};

struct hisi_fixed_factor_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	unsigned long mult;
	unsigned long div;
	unsigned long flags;
};

struct hisi_mux_clock {
	unsigned int id;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	unsigned long flags;
	unsigned long offset;
	u8 shift;
	u8 width;
	u8 mux_flags;
	const u32 *table;
	const char *alias;
};

struct hisi_divider_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	unsigned long flags;
	unsigned long offset;
	u8 shift;
	u8 width;
	u8 div_flags;
	struct clk_div_table *table;
	const char *alias;
};

struct hisi_gate_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	unsigned long flags;
	unsigned long offset;
	u8 bit_idx;
	u8 gate_flags;
	const char *alias;
};

struct hi6220_divider_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	unsigned long flags;
	unsigned long offset;
	u8 shift;
	u8 width;
	u32 mask_bit;
	const char *alias;
};

struct clk_imx8mp_audiomix_sel {
	const char *name;
	int clkid;
	const struct clk_parent_data parent;
	const struct clk_parent_data *parents;
	int num_parents;
	u16 reg;
	u8 width;
	u8 shift;
};

enum imx_pll14xx_type {
	PLL_1416X = 0,
	PLL_1443X = 1,
};

struct imx_pll14xx_rate_table;

struct imx_pll14xx_clk {
	enum imx_pll14xx_type type;
	const struct imx_pll14xx_rate_table *rate_table;
	int rate_count;
	int flags;
};

struct imx_pll14xx_rate_table {
	unsigned int rate;
	unsigned int pdiv;
	unsigned int mdiv;
	unsigned int sdiv;
	unsigned int kdiv;
};

struct mtk_gate;

struct mtk_composite;

struct mtk_clk_divider;

struct mtk_fixed_clk;

struct mtk_fixed_factor;

struct mtk_mux;

struct mtk_clk_rst_desc;

struct mtk_clk_desc {
	const struct mtk_gate *clks;
	size_t num_clks;
	const struct mtk_composite *composite_clks;
	size_t num_composite_clks;
	const struct mtk_clk_divider *divider_clks;
	size_t num_divider_clks;
	const struct mtk_fixed_clk *fixed_clks;
	size_t num_fixed_clks;
	const struct mtk_fixed_factor *factor_clks;
	size_t num_factor_clks;
	const struct mtk_mux *mux_clks;
	size_t num_mux_clks;
	const struct mtk_clk_rst_desc *rst_desc;
	spinlock_t *clk_lock;
	bool shared_io;
	int (*clk_notifier_func)(struct device *, struct clk *);
	unsigned int mfg_clk_idx;
};

struct mtk_gate_regs;

struct mtk_gate {
	int id;
	const char *name;
	const char *parent_name;
	const struct mtk_gate_regs *regs;
	int shift;
	const struct clk_ops *ops;
	unsigned long flags;
};

struct mtk_gate_regs {
	u32 sta_ofs;
	u32 clr_ofs;
	u32 set_ofs;
};

struct mtk_composite {
	int id;
	const char *name;
	const char * const *parent_names;
	const char *parent;
	unsigned int flags;
	uint32_t mux_reg;
	uint32_t divider_reg;
	uint32_t gate_reg;
	signed char mux_shift;
	signed char mux_width;
	signed char gate_shift;
	signed char divider_shift;
	signed char divider_width;
	u8 mux_flags;
	signed char num_parents;
};

struct mtk_clk_divider {
	int id;
	const char *name;
	const char *parent_name;
	unsigned long flags;
	u32 div_reg;
	unsigned char div_shift;
	unsigned char div_width;
	unsigned char clk_divider_flags;
	const struct clk_div_table *clk_div_table;
};

struct mtk_fixed_clk {
	int id;
	const char *name;
	const char *parent;
	unsigned long rate;
};

struct mtk_fixed_factor {
	int id;
	const char *name;
	const char *parent_name;
	int mult;
	int div;
	unsigned long flags;
};

struct mtk_mux {
	int id;
	const char *name;
	const char * const *parent_names;
	unsigned int flags;
	u32 mux_ofs;
	u32 set_ofs;
	u32 clr_ofs;
	u32 upd_ofs;
	u8 mux_shift;
	u8 mux_width;
	u8 gate_shift;
	s8 upd_shift;
	const struct clk_ops *ops;
	signed char num_parents;
};

enum mtk_reset_version {
	MTK_RST_SIMPLE = 0,
	MTK_RST_SET_CLR = 1,
	MTK_RST_MAX = 2,
};

struct mtk_clk_rst_desc {
	enum mtk_reset_version version;
	u16 *rst_bank_ofs;
	u32 rst_bank_nr;
	u16 *rst_idx_map;
	u32 rst_idx_map_nr;
};

struct clk_regmap {
	struct clk_hw hw;
	struct regmap *regmap;
	unsigned int enable_reg;
	unsigned int enable_mask;
	bool enable_is_inverted;
};

struct hfpll_data {
	u32 mode_reg;
	u32 l_reg;
	u32 m_reg;
	u32 n_reg;
	u32 user_reg;
	u32 droop_reg;
	u32 config_reg;
	u32 status_reg;
	u8 lock_bit;
	u32 l_val;
	u32 droop_val;
	u32 config_val;
	u32 user_val;
	u32 user_vco_mask;
	unsigned long low_vco_max_rate;
	unsigned long min_rate;
	unsigned long max_rate;
};

struct clk_hfpll {
	const struct hfpll_data *d;
	int init_done;
	struct clk_regmap clkr;
	spinlock_t lock;
};

struct rockchip_cpuclk_rate_table;

struct rockchip_cpuclk_reg_data;

struct rockchip_cpuclk {
	struct clk_hw hw;
	struct clk *alt_parent;
	void *reg_base;
	struct notifier_block clk_nb;
	unsigned int rate_count;
	struct rockchip_cpuclk_rate_table *rate_table;
	const struct rockchip_cpuclk_reg_data *reg_data;
	spinlock_t *lock;
};

struct rockchip_cpuclk_clksel {
	int reg;
	u32 val;
};

struct rockchip_cpuclk_rate_table {
	unsigned long prate;
	struct rockchip_cpuclk_clksel divs[6];
	struct rockchip_cpuclk_clksel pre_muxs[6];
	struct rockchip_cpuclk_clksel post_muxs[6];
};

struct rockchip_cpuclk_reg_data {
	int core_reg[4];
	u8 div_core_shift[4];
	u32 div_core_mask[4];
	int num_cores;
	int mux_core_reg;
	u8 mux_core_alt;
	u8 mux_core_main;
	u8 mux_core_shift;
	u32 mux_core_mask;
};

struct clk_notifier_data {
	struct clk *clk;
	unsigned long old_rate;
	unsigned long new_rate;
};

struct rockchip_inv_clock {
	struct clk_hw hw;
	void *reg;
	int shift;
	int flags;
	spinlock_t *lock;
};

struct reset_controller_dev;

struct reset_control_ops {
	int (*reset)(struct reset_controller_dev *, unsigned long);
	int (*assert)(struct reset_controller_dev *, unsigned long);
	int (*deassert)(struct reset_controller_dev *, unsigned long);
	int (*status)(struct reset_controller_dev *, unsigned long);
};

struct reset_controller_dev {
	const struct reset_control_ops *ops;
	struct module *owner;
	struct list_head list;
	struct list_head reset_control_head;
	struct device *dev;
	struct device_node *of_node;
	int of_reset_n_cells;
	int (*of_xlate)(struct reset_controller_dev *, const struct of_phandle_args *);
	unsigned int nr_resets;
};

struct rockchip_softrst {
	struct reset_controller_dev rcdev;
	const int *lut;
	void *reg_base;
	int num_regs;
	int num_per_reg;
	u8 flags;
	spinlock_t lock;
};

struct samsung_pll_clock;

struct samsung_mux_clock;

struct samsung_div_clock;

struct samsung_gate_clock;

struct samsung_fixed_rate_clock;

struct samsung_fixed_factor_clock;

struct samsung_cpu_clock;

struct samsung_clk_reg_dump;

struct samsung_cmu_info {
	const struct samsung_pll_clock *pll_clks;
	unsigned int nr_pll_clks;
	const struct samsung_mux_clock *mux_clks;
	unsigned int nr_mux_clks;
	const struct samsung_div_clock *div_clks;
	unsigned int nr_div_clks;
	const struct samsung_gate_clock *gate_clks;
	unsigned int nr_gate_clks;
	const struct samsung_fixed_rate_clock *fixed_clks;
	unsigned int nr_fixed_clks;
	const struct samsung_fixed_factor_clock *fixed_factor_clks;
	unsigned int nr_fixed_factor_clks;
	unsigned int nr_clk_ids;
	const struct samsung_cpu_clock *cpu_clks;
	unsigned int nr_cpu_clks;
	const unsigned long *clk_regs;
	unsigned int nr_clk_regs;
	const struct samsung_clk_reg_dump *suspend_regs;
	unsigned int nr_suspend_regs;
	const char *clk_name;
};

enum samsung_pll_type {
	pll_2126 = 0,
	pll_3000 = 1,
	pll_35xx = 2,
	pll_36xx = 3,
	pll_2550 = 4,
	pll_2650 = 5,
	pll_4500 = 6,
	pll_4502 = 7,
	pll_4508 = 8,
	pll_4600 = 9,
	pll_4650 = 10,
	pll_4650c = 11,
	pll_6552 = 12,
	pll_6552_s3c2416 = 13,
	pll_6553 = 14,
	pll_2550x = 15,
	pll_2550xx = 16,
	pll_2650x = 17,
	pll_2650xx = 18,
	pll_1417x = 19,
	pll_1450x = 20,
	pll_1451x = 21,
	pll_1452x = 22,
	pll_1460x = 23,
	pll_0818x = 24,
	pll_0822x = 25,
	pll_0831x = 26,
	pll_142xx = 27,
};

struct samsung_pll_rate_table;

struct samsung_pll_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	unsigned long flags;
	int con_offset;
	int lock_offset;
	enum samsung_pll_type type;
	const struct samsung_pll_rate_table *rate_table;
};

struct samsung_pll_rate_table {
	unsigned int rate;
	unsigned int pdiv;
	unsigned int mdiv;
	unsigned int sdiv;
	unsigned int kdiv;
	unsigned int afc;
	unsigned int mfr;
	unsigned int mrr;
	unsigned int vsel;
};

struct samsung_mux_clock {
	unsigned int id;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	unsigned long flags;
	unsigned long offset;
	u8 shift;
	u8 width;
	u8 mux_flags;
};

struct samsung_div_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	unsigned long flags;
	unsigned long offset;
	u8 shift;
	u8 width;
	u8 div_flags;
	struct clk_div_table *table;
};

struct samsung_gate_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	unsigned long flags;
	unsigned long offset;
	u8 bit_idx;
	u8 gate_flags;
};

struct samsung_fixed_rate_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	unsigned long flags;
	unsigned long fixed_rate;
};

struct samsung_fixed_factor_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	unsigned long mult;
	unsigned long div;
	unsigned long flags;
};

struct exynos_cpuclk_cfg_data;

struct samsung_cpu_clock {
	unsigned int id;
	const char *name;
	unsigned int parent_id;
	unsigned int alt_parent_id;
	unsigned long flags;
	int offset;
	const struct exynos_cpuclk_cfg_data *cfg;
};

struct exynos_cpuclk_cfg_data {
	unsigned long prate;
	unsigned long div0;
	unsigned long div1;
};

struct samsung_clk_reg_dump {
	u32 offset;
	u32 value;
};

struct samsung_clk_provider {
	void *reg_base;
	struct device *dev;
	spinlock_t lock;
	struct clk_hw_onecell_data clk_data;
};

struct ccu_common;

struct ccu_pll_nb {
	struct notifier_block clk_nb;
	struct ccu_common *common;
	u32 enable;
	u32 lock;
};

struct ccu_common {
	void *base;
	u16 reg;
	u16 lock_reg;
	u32 prediv;
	unsigned long features;
	spinlock_t *lock;
	struct clk_hw hw;
};

struct ccu_reset_map;

struct sunxi_ccu_desc {
	struct ccu_common **ccu_clks;
	unsigned long num_ccu_clks;
	struct clk_hw_onecell_data *hw_clks;
	struct ccu_reset_map *resets;
	unsigned long num_resets;
};

struct ccu_reset_map {
	u16 reg;
	u32 bit;
};

struct ccu_reset {
	void *base;
	struct ccu_reset_map *reset_map;
	spinlock_t *lock;
	struct reset_controller_dev rcdev;
};

struct sunxi_ccu {
	const struct sunxi_ccu_desc *desc;
	spinlock_t lock;
	struct ccu_reset reset;
};

struct reg_offset_data {
	u32 base_offset;
	unsigned int pipe_mult;
	unsigned int evnt_mult;
	unsigned int ee_mult;
};

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
	DMAENGINE_ALIGN_128_BYTES = 7,
	DMAENGINE_ALIGN_256_BYTES = 8,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
	DMA_SLAVE_BUSWIDTH_128_BYTES = 128,
};

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum bam_reg {
	BAM_CTRL = 0,
	BAM_REVISION = 1,
	BAM_NUM_PIPES = 2,
	BAM_DESC_CNT_TRSHLD = 3,
	BAM_IRQ_SRCS = 4,
	BAM_IRQ_SRCS_MSK = 5,
	BAM_IRQ_SRCS_UNMASKED = 6,
	BAM_IRQ_STTS = 7,
	BAM_IRQ_CLR = 8,
	BAM_IRQ_EN = 9,
	BAM_CNFG_BITS = 10,
	BAM_IRQ_SRCS_EE = 11,
	BAM_IRQ_SRCS_MSK_EE = 12,
	BAM_P_CTRL = 13,
	BAM_P_RST = 14,
	BAM_P_HALT = 15,
	BAM_P_IRQ_STTS = 16,
	BAM_P_IRQ_CLR = 17,
	BAM_P_IRQ_EN = 18,
	BAM_P_EVNT_DEST_ADDR = 19,
	BAM_P_EVNT_REG = 20,
	BAM_P_SW_OFSTS = 21,
	BAM_P_DATA_FIFO_ADDR = 22,
	BAM_P_DESC_FIFO_ADDR = 23,
	BAM_P_EVNT_GEN_TRSHLD = 24,
	BAM_P_FIFO_SIZES = 25,
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

struct dma_chan;

typedef bool (*dma_filter_fn)(struct dma_chan *, void *);

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

typedef struct {
	unsigned long bits[1];
} dma_cap_mask_t;

typedef s32 dma_cookie_t;

struct dma_async_tx_descriptor;

struct dma_interleaved_template;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	unsigned short max_xor;
	unsigned short max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan *);
	int (*device_router_config)(struct dma_chan *);
	void (*device_free_chan_resources)(struct dma_chan *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, unsigned long, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, unsigned long);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, unsigned long);
	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan *);
	int (*device_resume)(struct dma_chan *);
	int (*device_terminate_all)(struct dma_chan *);
	void (*device_synchronize)(struct dma_chan *);
	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct tasklet_struct {
	struct tasklet_struct *next;
	unsigned long state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(unsigned long);
		void (*callback)(struct tasklet_struct *);
	};
	unsigned long data;
};

struct bam_chan;

struct bam_device {
	void *regs;
	struct device *dev;
	struct dma_device common;
	struct bam_chan *channels;
	u32 num_channels;
	u32 num_ees;
	u32 ee;
	bool controlled_remotely;
	bool powered_remotely;
	u32 active_channels;
	const struct reg_offset_data *layout;
	struct clk *bamclk;
	int irq;
	struct tasklet_struct task;
};

struct dma_chan_dev;

struct dma_chan_percpu;

struct dma_router;

struct dma_chan {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu __attribute__((btf_type_tag("percpu"))) *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

struct dma_chan_dev {
	struct dma_chan *chan;
	struct device device;
	int dev_id;
	bool chan_dma_dev;
};

struct dma_chan_percpu {
	unsigned long memcpy_count;
	unsigned long bytes_transferred;
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

typedef void (*dma_async_tx_callback)(void *);

struct dmaengine_result;

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data;

struct dma_descriptor_metadata_ops;

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
	struct dma_async_tx_descriptor *next;
	struct dma_async_tx_descriptor *parent;
	spinlock_t lock;
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

struct dmaengine_unmap_data {
	u16 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

struct virt_dma_desc;

struct virt_dma_chan {
	struct dma_chan chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct list_head desc_terminated;
	struct virt_dma_desc *cyclic;
};

struct bam_desc_hw;

struct bam_chan {
	struct virt_dma_chan vc;
	struct bam_device *bdev;
	u32 id;
	struct dma_slave_config slave;
	struct bam_desc_hw *fifo_virt;
	dma_addr_t fifo_phys;
	unsigned short head;
	unsigned short tail;
	unsigned int initialized;
	unsigned int paused;
	unsigned int reconfigure;
	struct list_head desc_list;
	struct list_head node;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct bam_desc_hw {
	__le32 addr;
	__le16 size;
	__le16 flags;
};

struct bam_async_desc {
	struct virt_dma_desc vd;
	u32 num_desc;
	u32 xfer_len;
	u16 flags;
	struct bam_desc_hw *curr_desc;
	struct list_head desc_node;
	enum dma_transfer_direction dir;
	size_t length;
	struct bam_desc_hw desc[0];
};

struct of_dma {
	struct list_head of_dma_controllers;
	struct device_node *of_node;
	struct dma_chan * (*of_dma_xlate)(struct of_phandle_args *, struct of_dma *);
	void * (*of_dma_route_allocate)(struct of_phandle_args *, struct of_dma *);
	struct dma_router *dma_router;
	void *of_dma_data;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct imx8_soc_data {
	char *name;
	u32 (*soc_revision)();
};

struct soc_device_attribute {
	const char *machine;
	const char *family;
	const char *revision;
	const char *serial_number;
	const char *soc_id;
	const void *data;
	const struct attribute_group *custom_attr_group;
};

struct smem_partition {
	void *virt_base;
	phys_addr_t phys_base;
	size_t cacheline;
	size_t size;
};

struct smem_region {
	phys_addr_t aux_base;
	void *virt_base;
	size_t size;
};

struct hwspinlock;

struct smem_ptable;

struct qcom_smem {
	struct device *dev;
	struct hwspinlock *hwlock;
	u32 item_count;
	struct platform_device *socinfo;
	struct smem_ptable *ptable;
	struct smem_partition global_partition;
	struct smem_partition partitions[20];
	unsigned int num_regions;
	struct smem_region regions[0];
};

struct smem_ptable_entry {
	__le32 offset;
	__le32 size;
	__le32 flags;
	__le16 host0;
	__le16 host1;
	__le32 cacheline;
	__le32 reserved[7];
};

struct smem_ptable {
	u8 magic[4];
	__le32 version;
	__le32 num_entries;
	__le32 reserved[5];
	struct smem_ptable_entry entry[0];
};

struct smem_partition_header {
	u8 magic[4];
	__le16 host0;
	__le16 host1;
	__le32 size;
	__le32 offset_free_uncached;
	__le32 offset_free_cached;
	__le32 reserved[3];
};

struct smem_info {
	u8 magic[4];
	__le32 size;
	__le32 base_addr;
	__le32 reserved;
	__le16 num_items;
};

struct smem_global_entry {
	__le32 allocated;
	__le32 offset;
	__le32 size;
	__le32 aux_base;
};

struct smem_proc_comm {
	__le32 command;
	__le32 status;
	__le32 params[2];
};

struct smem_header {
	struct smem_proc_comm proc_comm[4];
	__le32 version[32];
	__le32 initialized;
	__le32 free_offset;
	__le32 available;
	__le32 reserved;
	struct smem_global_entry toc[512];
};

struct smem_private_entry {
	u16 canary;
	__le16 item;
	__le32 size;
	__le16 padding_data;
	__le16 padding_hdr;
	__le32 reserved;
};

struct reserved_mem_ops;

struct reserved_mem {
	const char *name;
	unsigned long fdt_node;
	unsigned long phandle;
	const struct reserved_mem_ops *ops;
	phys_addr_t base;
	phys_addr_t size;
	void *priv;
};

struct reserved_mem_ops {
	int (*device_init)(struct reserved_mem *, struct device *);
	void (*device_release)(struct reserved_mem *, struct device *);
};

struct socinfo {
	__le32 fmt;
	__le32 id;
	__le32 ver;
	char build_id[32];
	__le32 raw_id;
	__le32 raw_ver;
	__le32 hw_plat;
	__le32 plat_ver;
	__le32 accessory_chip;
	__le32 hw_plat_subtype;
	__le32 pmic_model;
	__le32 pmic_die_rev;
	__le32 pmic_model_1;
	__le32 pmic_die_rev_1;
	__le32 pmic_model_2;
	__le32 pmic_die_rev_2;
	__le32 foundry_id;
	__le32 serial_num;
	__le32 num_pmics;
	__le32 pmic_array_offset;
	__le32 chip_family;
	__le32 raw_device_family;
	__le32 raw_device_num;
	__le32 nproduct_id;
	char chip_id[32];
	__le32 num_clusters;
	__le32 ncluster_array_offset;
	__le32 num_subset_parts;
	__le32 nsubset_parts_array_offset;
	__le32 nmodem_supported;
	__le32 feature_code;
	__le32 pcode;
	__le32 npartnamemap_offset;
	__le32 nnum_partname_mapping;
	__le32 oem_variant;
	__le32 num_kvps;
	__le32 kvps_offset;
	__le32 num_func_clusters;
	__le32 boot_cluster;
	__le32 boot_core;
};

struct pm_domain_data {
	struct list_head list_node;
	struct device *dev;
};

struct rpmhpd;

struct rpmhpd_desc {
	struct rpmhpd **rpmhpds;
	size_t num_pds;
};

enum gpd_status {
	GENPD_STATE_ON = 0,
	GENPD_STATE_OFF = 1,
};

struct gpd_dev_ops {
	int (*start)(struct device *);
	int (*stop)(struct device *);
};

struct dev_power_governor;

struct genpd_governor_data;

struct opp_table;

struct dev_pm_opp;

struct genpd_power_state;

struct genpd_lock_ops;

struct generic_pm_domain {
	struct device dev;
	struct dev_pm_domain domain;
	struct list_head gpd_list_node;
	struct list_head parent_links;
	struct list_head child_links;
	struct list_head dev_list;
	struct dev_power_governor *gov;
	struct genpd_governor_data *gd;
	struct work_struct power_off_work;
	struct fwnode_handle *provider;
	bool has_provider;
	const char *name;
	atomic_t sd_count;
	enum gpd_status status;
	unsigned int device_count;
	unsigned int suspended_count;
	unsigned int prepared_count;
	unsigned int performance_state;
	cpumask_var_t cpus;
	bool synced_poweroff;
	int (*power_off)(struct generic_pm_domain *);
	int (*power_on)(struct generic_pm_domain *);
	struct raw_notifier_head power_notifiers;
	struct opp_table *opp_table;
	unsigned int (*opp_to_performance_state)(struct generic_pm_domain *, struct dev_pm_opp *);
	int (*set_performance_state)(struct generic_pm_domain *, unsigned int);
	struct gpd_dev_ops dev_ops;
	int (*attach_dev)(struct generic_pm_domain *, struct device *);
	void (*detach_dev)(struct generic_pm_domain *, struct device *);
	unsigned int flags;
	struct genpd_power_state *states;
	void (*free_states)(struct genpd_power_state *, unsigned int);
	unsigned int state_count;
	unsigned int state_idx;
	u64 on_time;
	u64 accounting_time;
	const struct genpd_lock_ops *lock_ops;
	union {
		struct mutex mlock;
		struct {
			spinlock_t slock;
			unsigned long lock_flags;
		};
	};
};

struct rpmhpd {
	struct device *dev;
	struct generic_pm_domain pd;
	struct generic_pm_domain *parent;
	struct rpmhpd *peer;
	const bool active_only;
	unsigned int corner;
	unsigned int active_corner;
	unsigned int enable_corner;
	u32 level[16];
	size_t level_count;
	bool enabled;
	const char *res_name;
	u32 addr;
	bool state_synced;
};

struct dev_power_governor {
	bool (*power_down_ok)(struct dev_pm_domain *);
	bool (*suspend_ok)(struct device *);
};

struct genpd_governor_data {
	s64 max_off_time_ns;
	bool max_off_time_changed;
	ktime_t next_wakeup;
	ktime_t next_hrtimer;
	bool cached_power_down_ok;
	bool cached_power_down_state_idx;
};

struct genpd_power_state {
	s64 power_off_latency_ns;
	s64 power_on_latency_ns;
	s64 residency_ns;
	u64 usage;
	u64 rejected;
	struct fwnode_handle *fwnode;
	u64 idle_time;
	void *data;
};

struct genpd_lock_ops {
	void (*lock)(struct generic_pm_domain *);
	void (*lock_nested)(struct generic_pm_domain *, int);
	int (*lock_interruptible)(struct generic_pm_domain *);
	void (*unlock)(struct generic_pm_domain *);
};

enum cmd_db_hw_type {
	CMD_DB_HW_INVALID = 0,
	CMD_DB_HW_MIN = 3,
	CMD_DB_HW_ARC = 3,
	CMD_DB_HW_VRM = 4,
	CMD_DB_HW_BCM = 5,
	CMD_DB_HW_MAX = 5,
	CMD_DB_HW_ALL = 255,
};

enum rpmh_state {
	RPMH_SLEEP_STATE = 0,
	RPMH_WAKE_ONLY_STATE = 1,
	RPMH_ACTIVE_ONLY_STATE = 2,
};

typedef struct generic_pm_domain * (*genpd_xlate_t)(struct of_phandle_args *, void *);

struct genpd_onecell_data {
	struct generic_pm_domain **domains;
	unsigned int num_domains;
	genpd_xlate_t xlate;
};

struct tcs_cmd {
	u32 addr;
	u32 data;
	u32 wait;
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

struct virtio_pci_common_cfg {
	__le32 device_feature_select;
	__le32 device_feature;
	__le32 guest_feature_select;
	__le32 guest_feature;
	__le16 msix_config;
	__le16 num_queues;
	__u8 device_status;
	__u8 config_generation;
	__le16 queue_select;
	__le16 queue_size;
	__le16 queue_msix_vector;
	__le16 queue_enable;
	__le16 queue_notify_off;
	__le32 queue_desc_lo;
	__le32 queue_desc_hi;
	__le32 queue_avail_lo;
	__le32 queue_avail_hi;
	__le32 queue_used_lo;
	__le32 queue_used_hi;
};

struct virtio_pci_modern_common_cfg {
	struct virtio_pci_common_cfg cfg;
	__le16 queue_notify_data;
	__le16 queue_reset;
};

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct virtio_pci_modern_device {
	struct pci_dev *pci_dev;
	struct virtio_pci_common_cfg *common;
	void *device;
	void *notify_base;
	resource_size_t notify_pa;
	u8 *isr;
	size_t notify_len;
	size_t device_len;
	size_t common_len;
	int notify_map_cap;
	u32 notify_offset_multiplier;
	int modern_bars;
	struct virtio_device_id id;
	int (*device_id_check)(struct pci_dev *);
	u64 dma_mask;
};

typedef void (*xen_gfn_fn_t)(unsigned long, void *);

typedef uint64_t xen_pfn_t;

typedef u16 uint16_t;

typedef uint16_t domid_t;

struct xen_remap_gfn_info;

typedef uint64_t xen_ulong_t;

struct remap_data {
	xen_pfn_t *fgfn;
	int nr_fgfn;
	pgprot_t prot;
	domid_t domid;
	struct vm_area_struct *vma;
	int index;
	struct page **pages;
	struct xen_remap_gfn_info *info;
	int *err_ptr;
	int mapped;
	int h_errs[1];
	xen_ulong_t h_idxs[1];
	xen_pfn_t h_gpfns[1];
	int h_iter;
};

struct xen_remove_from_physmap {
	domid_t domid;
	xen_pfn_t gpfn;
};

struct map_balloon_pages {
	xen_pfn_t *pfns;
	unsigned int idx;
};

typedef struct {
	union {
		xen_ulong_t *p;
		uint64_t q;
	};
} __guest_handle_xen_ulong_t;

typedef struct {
	union {
		xen_pfn_t *p;
		uint64_t q;
	};
} __guest_handle_xen_pfn_t;

typedef struct {
	union {
		int *p;
		uint64_t q;
	};
} __guest_handle_int;

struct xen_add_to_physmap_range {
	domid_t domid;
	uint16_t space;
	uint16_t size;
	domid_t foreign_domid;
	__guest_handle_xen_ulong_t idxs;
	__guest_handle_xen_pfn_t gpfns;
	__guest_handle_int errs;
};

struct remap_pfn {
	struct mm_struct *mm;
	struct page **pages;
	pgprot_t prot;
	unsigned long i;
};

enum regulator_type {
	REGULATOR_VOLTAGE = 0,
	REGULATOR_CURRENT = 1,
};

struct regulator_config;

struct regulator_ops;

struct linear_range;

struct regulator_desc {
	const char *name;
	const char *supply_name;
	const char *of_match;
	bool of_match_full_name;
	const char *regulators_node;
	int (*of_parse_cb)(struct device_node *, const struct regulator_desc *, struct regulator_config *);
	int id;
	unsigned int continuous_voltage_range: 1;
	unsigned int n_voltages;
	unsigned int n_current_limits;
	const struct regulator_ops *ops;
	int irq;
	enum regulator_type type;
	struct module *owner;
	unsigned int min_uV;
	unsigned int uV_step;
	unsigned int linear_min_sel;
	int fixed_uV;
	unsigned int ramp_delay;
	int min_dropout_uV;
	const struct linear_range *linear_ranges;
	const unsigned int *linear_range_selectors_bitfield;
	int n_linear_ranges;
	const unsigned int *volt_table;
	const unsigned int *curr_table;
	unsigned int vsel_range_reg;
	unsigned int vsel_range_mask;
	unsigned int vsel_reg;
	unsigned int vsel_mask;
	unsigned int vsel_step;
	unsigned int csel_reg;
	unsigned int csel_mask;
	unsigned int apply_reg;
	unsigned int apply_bit;
	unsigned int enable_reg;
	unsigned int enable_mask;
	unsigned int enable_val;
	unsigned int disable_val;
	bool enable_is_inverted;
	unsigned int bypass_reg;
	unsigned int bypass_mask;
	unsigned int bypass_val_on;
	unsigned int bypass_val_off;
	unsigned int active_discharge_on;
	unsigned int active_discharge_off;
	unsigned int active_discharge_mask;
	unsigned int active_discharge_reg;
	unsigned int soft_start_reg;
	unsigned int soft_start_mask;
	unsigned int soft_start_val_on;
	unsigned int pull_down_reg;
	unsigned int pull_down_mask;
	unsigned int pull_down_val_on;
	unsigned int ramp_reg;
	unsigned int ramp_mask;
	const unsigned int *ramp_delay_table;
	unsigned int n_ramp_values;
	unsigned int enable_time;
	unsigned int off_on_delay;
	unsigned int poll_enabled_time;
	unsigned int (*of_map_mode)(unsigned int);
};

struct regulator_init_data;

struct regulator_config {
	struct device *dev;
	const struct regulator_init_data *init_data;
	void *driver_data;
	struct device_node *of_node;
	struct regmap *regmap;
	struct gpio_desc *ena_gpiod;
};

struct regulator_state {
	int uV;
	int min_uV;
	int max_uV;
	unsigned int mode;
	int enabled;
	bool changeable;
};

struct notification_limit {
	int prot;
	int err;
	int warn;
};

typedef int suspend_state_t;

struct regulation_constraints {
	const char *name;
	int min_uV;
	int max_uV;
	int uV_offset;
	int min_uA;
	int max_uA;
	int ilim_uA;
	int system_load;
	u32 *max_spread;
	int max_uV_step;
	unsigned int valid_modes_mask;
	unsigned int valid_ops_mask;
	int input_uV;
	struct regulator_state state_disk;
	struct regulator_state state_mem;
	struct regulator_state state_standby;
	struct notification_limit over_curr_limits;
	struct notification_limit over_voltage_limits;
	struct notification_limit under_voltage_limits;
	struct notification_limit temp_limits;
	suspend_state_t initial_state;
	unsigned int initial_mode;
	unsigned int ramp_delay;
	unsigned int settling_time;
	unsigned int settling_time_up;
	unsigned int settling_time_down;
	unsigned int enable_time;
	unsigned int active_discharge;
	unsigned int always_on: 1;
	unsigned int boot_on: 1;
	unsigned int apply_uV: 1;
	unsigned int ramp_disable: 1;
	unsigned int soft_start: 1;
	unsigned int pull_down: 1;
	unsigned int over_current_protection: 1;
	unsigned int over_current_detection: 1;
	unsigned int over_voltage_detection: 1;
	unsigned int under_voltage_detection: 1;
	unsigned int over_temp_detection: 1;
};

struct regulator_consumer_supply;

struct regulator_init_data {
	const char *supply_regulator;
	struct regulation_constraints constraints;
	int num_consumer_supplies;
	struct regulator_consumer_supply *consumer_supplies;
	int (*regulator_init)(void *);
	void *driver_data;
};

struct regulator_dev;

struct regulator_ops {
	int (*list_voltage)(struct regulator_dev *, unsigned int);
	int (*set_voltage)(struct regulator_dev *, int, int, unsigned int *);
	int (*map_voltage)(struct regulator_dev *, int, int);
	int (*set_voltage_sel)(struct regulator_dev *, unsigned int);
	int (*get_voltage)(struct regulator_dev *);
	int (*get_voltage_sel)(struct regulator_dev *);
	int (*set_current_limit)(struct regulator_dev *, int, int);
	int (*get_current_limit)(struct regulator_dev *);
	int (*set_input_current_limit)(struct regulator_dev *, int);
	int (*set_over_current_protection)(struct regulator_dev *, int, int, bool);
	int (*set_over_voltage_protection)(struct regulator_dev *, int, int, bool);
	int (*set_under_voltage_protection)(struct regulator_dev *, int, int, bool);
	int (*set_thermal_protection)(struct regulator_dev *, int, int, bool);
	int (*set_active_discharge)(struct regulator_dev *, bool);
	int (*enable)(struct regulator_dev *);
	int (*disable)(struct regulator_dev *);
	int (*is_enabled)(struct regulator_dev *);
	int (*set_mode)(struct regulator_dev *, unsigned int);
	unsigned int (*get_mode)(struct regulator_dev *);
	int (*get_error_flags)(struct regulator_dev *, unsigned int *);
	int (*enable_time)(struct regulator_dev *);
	int (*set_ramp_delay)(struct regulator_dev *, int);
	int (*set_voltage_time)(struct regulator_dev *, int, int);
	int (*set_voltage_time_sel)(struct regulator_dev *, unsigned int, unsigned int);
	int (*set_soft_start)(struct regulator_dev *);
	int (*get_status)(struct regulator_dev *);
	unsigned int (*get_optimum_mode)(struct regulator_dev *, int, int, int);
	int (*set_load)(struct regulator_dev *, int);
	int (*set_bypass)(struct regulator_dev *, bool);
	int (*get_bypass)(struct regulator_dev *, bool *);
	int (*set_suspend_voltage)(struct regulator_dev *, int);
	int (*set_suspend_enable)(struct regulator_dev *);
	int (*set_suspend_disable)(struct regulator_dev *);
	int (*set_suspend_mode)(struct regulator_dev *, unsigned int);
	int (*resume)(struct regulator_dev *);
	int (*set_pull_down)(struct regulator_dev *);
};

struct regulator_coupler;

struct coupling_desc {
	struct regulator_dev **coupled_rdevs;
	struct regulator_coupler *coupler;
	int n_resolved;
	int n_coupled;
};

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct regulator_enable_gpio;

struct regulator_dev {
	const struct regulator_desc *desc;
	int exclusive;
	u32 use_count;
	u32 open_count;
	u32 bypass_count;
	struct list_head list;
	struct list_head consumer_list;
	struct coupling_desc coupling_desc;
	struct blocking_notifier_head notifier;
	struct ww_mutex mutex;
	struct task_struct *mutex_owner;
	int ref_cnt;
	struct module *owner;
	struct device dev;
	struct regulation_constraints *constraints;
	struct regulator *supply;
	const char *supply_name;
	struct regmap *regmap;
	struct delayed_work disable_work;
	void *reg_data;
	struct dentry *debugfs;
	struct regulator_enable_gpio *ena_pin;
	unsigned int ena_gpio_state: 1;
	unsigned int is_switch: 1;
	ktime_t last_off;
	int cached_err;
	bool use_cached_err;
	spinlock_t err_lock;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	unsigned long stamp;
	unsigned int acquired;
	unsigned short wounded;
	unsigned short is_wait_die;
};

struct linear_range {
	unsigned int min;
	unsigned int min_sel;
	unsigned int max_sel;
	unsigned int step;
};

enum rohm_chip_type {
	ROHM_CHIP_TYPE_BD9571 = 0,
	ROHM_CHIP_TYPE_BD9573 = 1,
	ROHM_CHIP_TYPE_BD9574 = 2,
	ROHM_CHIP_TYPE_BD9576 = 3,
	ROHM_CHIP_TYPE_BD71815 = 4,
	ROHM_CHIP_TYPE_BD71828 = 5,
	ROHM_CHIP_TYPE_BD71837 = 6,
	ROHM_CHIP_TYPE_BD71847 = 7,
	ROHM_CHIP_TYPE_AMOUNT = 8,
};

enum bd9571mwv_regulators {
	VD09 = 0,
	VD18 = 1,
	VD25 = 2,
	VD33 = 3,
	DVFS = 4,
};

struct bd9571mwv_reg {
	struct regmap *regmap;
	u8 bkup_mode_cnt_keepon;
	u8 bkup_mode_cnt_saved;
	bool bkup_mode_enabled;
	bool rstbmode_level;
	bool rstbmode_pulse;
};

enum spmi_regulator_type {
	SPMI_REGULATOR_TYPE_BUCK = 3,
	SPMI_REGULATOR_TYPE_LDO = 4,
	SPMI_REGULATOR_TYPE_VS = 5,
	SPMI_REGULATOR_TYPE_BOOST = 27,
	SPMI_REGULATOR_TYPE_FTS = 28,
	SPMI_REGULATOR_TYPE_BOOST_BYP = 31,
	SPMI_REGULATOR_TYPE_ULT_LDO = 33,
	SPMI_REGULATOR_TYPE_ULT_BUCK = 34,
};

enum spmi_regulator_subtype {
	SPMI_REGULATOR_SUBTYPE_GP_CTL = 8,
	SPMI_REGULATOR_SUBTYPE_RF_CTL = 9,
	SPMI_REGULATOR_SUBTYPE_N50 = 1,
	SPMI_REGULATOR_SUBTYPE_N150 = 2,
	SPMI_REGULATOR_SUBTYPE_N300 = 3,
	SPMI_REGULATOR_SUBTYPE_N600 = 4,
	SPMI_REGULATOR_SUBTYPE_N1200 = 5,
	SPMI_REGULATOR_SUBTYPE_N600_ST = 6,
	SPMI_REGULATOR_SUBTYPE_N1200_ST = 7,
	SPMI_REGULATOR_SUBTYPE_N900_ST = 20,
	SPMI_REGULATOR_SUBTYPE_N300_ST = 21,
	SPMI_REGULATOR_SUBTYPE_P50 = 8,
	SPMI_REGULATOR_SUBTYPE_P150 = 9,
	SPMI_REGULATOR_SUBTYPE_P300 = 10,
	SPMI_REGULATOR_SUBTYPE_P600 = 11,
	SPMI_REGULATOR_SUBTYPE_P1200 = 12,
	SPMI_REGULATOR_SUBTYPE_LN = 16,
	SPMI_REGULATOR_SUBTYPE_LV_P50 = 40,
	SPMI_REGULATOR_SUBTYPE_LV_P150 = 41,
	SPMI_REGULATOR_SUBTYPE_LV_P300 = 42,
	SPMI_REGULATOR_SUBTYPE_LV_P600 = 43,
	SPMI_REGULATOR_SUBTYPE_LV_P1200 = 44,
	SPMI_REGULATOR_SUBTYPE_LV_P450 = 45,
	SPMI_REGULATOR_SUBTYPE_HT_N300_ST = 48,
	SPMI_REGULATOR_SUBTYPE_HT_N600_ST = 49,
	SPMI_REGULATOR_SUBTYPE_HT_N1200_ST = 50,
	SPMI_REGULATOR_SUBTYPE_HT_LVP150 = 59,
	SPMI_REGULATOR_SUBTYPE_HT_LVP300 = 60,
	SPMI_REGULATOR_SUBTYPE_L660_N300_ST = 66,
	SPMI_REGULATOR_SUBTYPE_L660_N600_ST = 67,
	SPMI_REGULATOR_SUBTYPE_L660_P50 = 70,
	SPMI_REGULATOR_SUBTYPE_L660_P150 = 71,
	SPMI_REGULATOR_SUBTYPE_L660_P600 = 73,
	SPMI_REGULATOR_SUBTYPE_L660_LVP150 = 77,
	SPMI_REGULATOR_SUBTYPE_L660_LVP600 = 79,
	SPMI_REGULATOR_SUBTYPE_LV100 = 1,
	SPMI_REGULATOR_SUBTYPE_LV300 = 2,
	SPMI_REGULATOR_SUBTYPE_MV300 = 8,
	SPMI_REGULATOR_SUBTYPE_MV500 = 9,
	SPMI_REGULATOR_SUBTYPE_HDMI = 16,
	SPMI_REGULATOR_SUBTYPE_OTG = 17,
	SPMI_REGULATOR_SUBTYPE_5V_BOOST = 1,
	SPMI_REGULATOR_SUBTYPE_FTS_CTL = 8,
	SPMI_REGULATOR_SUBTYPE_FTS2p5_CTL = 9,
	SPMI_REGULATOR_SUBTYPE_FTS426_CTL = 10,
	SPMI_REGULATOR_SUBTYPE_BB_2A = 1,
	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL1 = 13,
	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL2 = 14,
	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL3 = 15,
	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL4 = 16,
	SPMI_REGULATOR_SUBTYPE_HFS430 = 10,
	SPMI_REGULATOR_SUBTYPE_HT_P150 = 53,
	SPMI_REGULATOR_SUBTYPE_HT_P600 = 61,
	SPMI_REGULATOR_SUBTYPE_HFSMPS_510 = 10,
	SPMI_REGULATOR_SUBTYPE_FTSMPS_510 = 11,
	SPMI_REGULATOR_SUBTYPE_LV_P150_510 = 113,
	SPMI_REGULATOR_SUBTYPE_LV_P300_510 = 114,
	SPMI_REGULATOR_SUBTYPE_LV_P600_510 = 115,
	SPMI_REGULATOR_SUBTYPE_N300_510 = 106,
	SPMI_REGULATOR_SUBTYPE_N600_510 = 107,
	SPMI_REGULATOR_SUBTYPE_N1200_510 = 108,
	SPMI_REGULATOR_SUBTYPE_MV_P50_510 = 122,
	SPMI_REGULATOR_SUBTYPE_MV_P150_510 = 123,
	SPMI_REGULATOR_SUBTYPE_MV_P600_510 = 125,
};

enum spmi_regulator_logical_type {
	SPMI_REGULATOR_LOGICAL_TYPE_SMPS = 0,
	SPMI_REGULATOR_LOGICAL_TYPE_LDO = 1,
	SPMI_REGULATOR_LOGICAL_TYPE_VS = 2,
	SPMI_REGULATOR_LOGICAL_TYPE_BOOST = 3,
	SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS = 4,
	SPMI_REGULATOR_LOGICAL_TYPE_BOOST_BYP = 5,
	SPMI_REGULATOR_LOGICAL_TYPE_LN_LDO = 6,
	SPMI_REGULATOR_LOGICAL_TYPE_ULT_LO_SMPS = 7,
	SPMI_REGULATOR_LOGICAL_TYPE_ULT_HO_SMPS = 8,
	SPMI_REGULATOR_LOGICAL_TYPE_ULT_LDO = 9,
	SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS426 = 10,
	SPMI_REGULATOR_LOGICAL_TYPE_HFS430 = 11,
	SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS3 = 12,
	SPMI_REGULATOR_LOGICAL_TYPE_LDO_510 = 13,
	SPMI_REGULATOR_LOGICAL_TYPE_HFSMPS = 14,
};

struct spmi_voltage_set_points;

struct spmi_regulator_mapping {
	enum spmi_regulator_type type;
	enum spmi_regulator_subtype subtype;
	enum spmi_regulator_logical_type logical_type;
	u32 revision_min;
	u32 revision_max;
	const struct regulator_ops *ops;
	struct spmi_voltage_set_points *set_points;
	int hpm_min_load;
};

struct spmi_voltage_range;

struct spmi_voltage_set_points {
	struct spmi_voltage_range *range;
	int count;
	unsigned int n_voltages;
};

struct spmi_voltage_range {
	int min_uV;
	int max_uV;
	int step_uV;
	int set_point_min_uV;
	int set_point_max_uV;
	unsigned int n_voltages;
	u8 range_sel;
};

struct spmi_regulator_data {
	const char *name;
	u16 base;
	const char *supply;
	const char *ocp;
	u16 force_type;
};

enum spmi_common_regulator_registers {
	SPMI_COMMON_REG_DIG_MAJOR_REV = 1,
	SPMI_COMMON_REG_TYPE = 4,
	SPMI_COMMON_REG_SUBTYPE = 5,
	SPMI_COMMON_REG_VOLTAGE_RANGE = 64,
	SPMI_COMMON_REG_VOLTAGE_SET = 65,
	SPMI_COMMON_REG_MODE = 69,
	SPMI_COMMON_REG_ENABLE = 70,
	SPMI_COMMON_REG_PULL_DOWN = 72,
	SPMI_COMMON_REG_SOFT_START = 76,
	SPMI_COMMON_REG_STEP_CTRL = 97,
};

enum spmi_vs_soft_start_str {
	SPMI_VS_SOFT_START_STR_0P05_UA = 0,
	SPMI_VS_SOFT_START_STR_0P25_UA = 1,
	SPMI_VS_SOFT_START_STR_0P55_UA = 2,
	SPMI_VS_SOFT_START_STR_0P75_UA = 3,
	SPMI_VS_SOFT_START_STR_HW_DEFAULT = 4,
};

enum spmi_common_control_register_index {
	SPMI_COMMON_IDX_VOLTAGE_RANGE = 0,
	SPMI_COMMON_IDX_VOLTAGE_SET = 1,
	SPMI_COMMON_IDX_MODE = 5,
	SPMI_COMMON_IDX_ENABLE = 6,
};

enum spmi_vs_registers {
	SPMI_VS_REG_OCP = 74,
	SPMI_VS_REG_SOFT_START = 76,
};

enum spmi_hfsmps_regulator_registers {
	SPMI_HFSMPS_REG_STEP_CTRL = 60,
	SPMI_HFSMPS_REG_PULL_DOWN = 160,
};

enum spmi_ftsmps426_regulator_registers {
	SPMI_FTSMPS426_REG_VOLTAGE_LSB = 64,
	SPMI_FTSMPS426_REG_VOLTAGE_MSB = 65,
	SPMI_FTSMPS426_REG_VOLTAGE_ULS_LSB = 104,
	SPMI_FTSMPS426_REG_VOLTAGE_ULS_MSB = 105,
};

enum regulator_detection_severity {
	REGULATOR_SEVERITY_PROT = 0,
	REGULATOR_SEVERITY_ERR = 1,
	REGULATOR_SEVERITY_WARN = 2,
};

enum spmi_boost_registers {
	SPMI_BOOST_REG_CURRENT_LIMIT = 74,
};

enum spmi_boost_byp_registers {
	SPMI_BOOST_BYP_REG_CURRENT_LIMIT = 75,
};

enum spmi_saw3_registers {
	SAW3_SECURE = 0,
	SAW3_ID = 4,
	SAW3_SPM_STS = 12,
	SAW3_AVS_STS = 16,
	SAW3_PMIC_STS = 20,
	SAW3_RST = 24,
	SAW3_VCTL = 28,
	SAW3_AVS_CTL = 32,
	SAW3_AVS_LIMIT = 36,
	SAW3_AVS_DLY = 40,
	SAW3_AVS_HYSTERESIS = 44,
	SAW3_SPM_STS2 = 56,
	SAW3_SPM_PMIC_DATA_3 = 76,
	SAW3_VERSION = 4048,
};

struct spmi_regulator {
	struct regulator_desc desc;
	struct device *dev;
	struct delayed_work ocp_work;
	struct regmap *regmap;
	struct spmi_voltage_set_points *set_points;
	enum spmi_regulator_logical_type logical_type;
	int ocp_irq;
	int ocp_count;
	int ocp_max_retries;
	int ocp_retry_delay_ms;
	int hpm_min_load;
	int slew_rate;
	ktime_t vs_enable_time;
	u16 base;
	struct list_head node;
};

struct spmi_regulator_init_data {
	unsigned int pin_ctrl_enable;
	unsigned int pin_ctrl_hpm;
	enum spmi_vs_soft_start_str vs_soft_start_strength;
};

struct brcmstb_reset {
	void *base;
	struct reset_controller_dev rcdev;
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	unsigned short close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	unsigned short closing_wait;
	unsigned short closing_wait2;
	unsigned char *iomem_base;
	unsigned short iomem_reg_shift;
	unsigned int port_high;
	unsigned long iomap_base;
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

enum nbcon_prio {
	NBCON_PRIO_NONE = 0,
	NBCON_PRIO_NORMAL = 1,
	NBCON_PRIO_EMERGENCY = 2,
	NBCON_PRIO_PANIC = 3,
	NBCON_PRIO_MAX = 4,
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_DEVICE_TREE = 10,
	LOCKDOWN_PCMCIA_CIS = 11,
	LOCKDOWN_TIOCSSERIAL = 12,
	LOCKDOWN_MODULE_PARAMETERS = 13,
	LOCKDOWN_MMIOTRACE = 14,
	LOCKDOWN_DEBUGFS = 15,
	LOCKDOWN_XMON_WR = 16,
	LOCKDOWN_BPF_WRITE_USER = 17,
	LOCKDOWN_DBG_WRITE_KERNEL = 18,
	LOCKDOWN_RTAS_ERROR_INJECTION = 19,
	LOCKDOWN_INTEGRITY_MAX = 20,
	LOCKDOWN_KCORE = 21,
	LOCKDOWN_KPROBES = 22,
	LOCKDOWN_BPF_READ_KERNEL = 23,
	LOCKDOWN_DBG_READ_KERNEL = 24,
	LOCKDOWN_PERF = 25,
	LOCKDOWN_TRACEFS = 26,
	LOCKDOWN_XMON_RW = 27,
	LOCKDOWN_XFRM_SECRET = 28,
	LOCKDOWN_CONFIDENTIALITY_MAX = 29,
};

typedef u64 upf_t;

typedef unsigned int upstat_t;

struct circ_buf {
	char *buf;
	int head;
	int tail;
};

struct uart_port;

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	struct circ_buf xmit;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	union {
		__u32 padding[5];
		struct {
			__u8 addr_recv;
			__u8 addr_dest;
			__u8 padding0[2];
			__u32 padding1[4];
		};
	};
};

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct console;

struct uart_ops;

struct serial_port_device;

struct uart_port {
	spinlock_t lock;
	unsigned long iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct ktermios *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int ctrl_id;
	unsigned int port_id;
	unsigned int irq;
	unsigned long irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	bool hw_stopped;
	unsigned int mctrl;
	unsigned int frame_time;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	struct serial_port_device *port_dev;
	unsigned long sysrq;
	u8 sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct serial_rs485 rs485_supported;
	struct gpio_desc *rs485_term_gpio;
	struct gpio_desc *rs485_rx_during_tx_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
};

typedef unsigned int uint;

struct nbcon_write_context;

struct printk_buffers;

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)();
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short flags;
	short index;
	int cflag;
	uint ispeed;
	uint ospeed;
	u64 seq;
	unsigned long dropped;
	void *data;
	struct hlist_node node;
	bool (*write_atomic)(struct console *, struct nbcon_write_context *);
	atomic_t nbcon_state;
	atomic_long_t nbcon_seq;
	struct printk_buffers *pbufs;
};

struct nbcon_context {
	struct console *console;
	unsigned int spinwait_max_us;
	enum nbcon_prio prio;
	unsigned int allow_unsafe_takeover: 1;
	unsigned int backlog: 1;
	struct printk_buffers *pbufs;
	u64 seq;
};

struct nbcon_write_context {
	struct nbcon_context ctxt;
	char *outbuf;
	unsigned int len;
	bool unsafe_takeover;
};

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*start_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, unsigned long);
};

struct serial_port_device {
	struct device dev;
	struct uart_port *port;
};

struct serial_ctrl_device {
	struct device dev;
	struct ida port_ida;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

struct omap_rng_dev;

struct omap_rng_pdata {
	u16 *regs;
	u32 data_size;
	u32 (*data_present)(struct omap_rng_dev *);
	int (*init)(struct omap_rng_dev *);
	void (*cleanup)(struct omap_rng_dev *);
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	unsigned long priv;
	unsigned short quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
	struct completion dying;
};

struct omap_rng_dev {
	void *base;
	struct device *dev;
	const struct omap_rng_pdata *pdata;
	struct hwrng rng;
	struct clk *clk;
	struct clk *clk_reg;
};

enum {
	RNG_OUTPUT_0_REG = 0,
	RNG_OUTPUT_1_REG = 1,
	RNG_OUTPUT_2_REG = 2,
	RNG_OUTPUT_3_REG = 3,
	RNG_STATUS_REG = 4,
	RNG_INTMASK_REG = 5,
	RNG_INTACK_REG = 6,
	RNG_CONTROL_REG = 7,
	RNG_CONFIG_REG = 8,
	RNG_ALARMCNT_REG = 9,
	RNG_FROENABLE_REG = 10,
	RNG_FRODETUNE_REG = 11,
	RNG_ALARMMASK_REG = 12,
	RNG_ALARMSTOP_REG = 13,
	RNG_REV_REG = 14,
	RNG_SYSCONFIG_REG = 15,
};

enum tpm2_cc_attrs {
	TPM2_CC_ATTR_CHANDLES = 25,
	TPM2_CC_ATTR_RHANDLE = 28,
	TPM2_CC_ATTR_VENDOR = 29,
};

enum tpm2_structures {
	TPM2_ST_NO_SESSIONS = 32769,
	TPM2_ST_SESSIONS = 32770,
};

enum tpm2_command_codes {
	TPM2_CC_FIRST = 287,
	TPM2_CC_HIERARCHY_CONTROL = 289,
	TPM2_CC_HIERARCHY_CHANGE_AUTH = 297,
	TPM2_CC_CREATE_PRIMARY = 305,
	TPM2_CC_SEQUENCE_COMPLETE = 318,
	TPM2_CC_SELF_TEST = 323,
	TPM2_CC_STARTUP = 324,
	TPM2_CC_SHUTDOWN = 325,
	TPM2_CC_NV_READ = 334,
	TPM2_CC_CREATE = 339,
	TPM2_CC_LOAD = 343,
	TPM2_CC_SEQUENCE_UPDATE = 348,
	TPM2_CC_UNSEAL = 350,
	TPM2_CC_CONTEXT_LOAD = 353,
	TPM2_CC_CONTEXT_SAVE = 354,
	TPM2_CC_FLUSH_CONTEXT = 357,
	TPM2_CC_VERIFY_SIGNATURE = 375,
	TPM2_CC_GET_CAPABILITY = 378,
	TPM2_CC_GET_RANDOM = 379,
	TPM2_CC_PCR_READ = 382,
	TPM2_CC_PCR_EXTEND = 386,
	TPM2_CC_EVENT_SEQUENCE_COMPLETE = 389,
	TPM2_CC_HASH_SEQUENCE_START = 390,
	TPM2_CC_CREATE_LOADED = 401,
	TPM2_CC_LAST = 403,
};

enum tpm2_return_codes {
	TPM2_RC_SUCCESS = 0,
	TPM2_RC_HASH = 131,
	TPM2_RC_HANDLE = 139,
	TPM2_RC_INITIALIZE = 256,
	TPM2_RC_FAILURE = 257,
	TPM2_RC_DISABLED = 288,
	TPM2_RC_UPGRADE = 301,
	TPM2_RC_COMMAND_CODE = 323,
	TPM2_RC_TESTING = 2314,
	TPM2_RC_REFERENCE_H0 = 2320,
	TPM2_RC_RETRY = 2338,
};

enum tpm_buf_flags {
	TPM_BUF_OVERFLOW = 1,
};

enum tpm2_handle_types {
	TPM2_HT_HMAC_SESSION = 33554432,
	TPM2_HT_POLICY_SESSION = 50331648,
	TPM2_HT_TRANSIENT = 2147483648,
};

enum tpm2_capabilities {
	TPM2_CAP_HANDLES = 1,
	TPM2_CAP_COMMANDS = 2,
	TPM2_CAP_PCRS = 5,
	TPM2_CAP_TPM_PROPERTIES = 6,
};

struct tpm2_context {
	__be64 sequence;
	__be32 saved_handle;
	__be32 hierarchy;
	__be16 blob_size;
} __attribute__((packed));

struct tpm_header {
	__be16 tag;
	__be32 length;
	union {
		__be32 ordinal;
		__be32 return_code;
	};
} __attribute__((packed));

struct tpm_bios_log {
	void *bios_event_log;
	void *bios_event_log_end;
};

struct tpm_chip;

struct tpm_chip_seqops {
	struct tpm_chip *chip;
	const struct seq_operations *seqops;
};

struct tpm_space {
	u32 context_tbl[3];
	u8 *context_buf;
	u32 session_tbl[3];
	u8 *session_buf;
	u32 buf_size;
};

struct tpm_class_ops;

struct tpm_bank_info;

struct tpm_chip {
	struct device dev;
	struct device devs;
	struct cdev cdev;
	struct cdev cdevs;
	struct rw_semaphore ops_sem;
	const struct tpm_class_ops *ops;
	struct tpm_bios_log log;
	struct tpm_chip_seqops bin_log_seqops;
	struct tpm_chip_seqops ascii_log_seqops;
	unsigned int flags;
	int dev_num;
	unsigned long is_open;
	char hwrng_name[64];
	struct hwrng hwrng;
	struct mutex tpm_mutex;
	unsigned long timeout_a;
	unsigned long timeout_b;
	unsigned long timeout_c;
	unsigned long timeout_d;
	bool timeout_adjusted;
	unsigned long duration[4];
	bool duration_adjusted;
	struct dentry *bios_dir[3];
	const struct attribute_group *groups[8];
	unsigned int groups_cnt;
	u32 nr_allocated_banks;
	struct tpm_bank_info *allocated_banks;
	acpi_handle acpi_dev_handle;
	char ppi_version[4];
	struct tpm_space work_space;
	u32 last_cc;
	u32 nr_commands;
	u32 *cc_attrs_tbl;
	int locality;
};

struct tpm_class_ops {
	unsigned int flags;
	const u8 req_complete_mask;
	const u8 req_complete_val;
	bool (*req_canceled)(struct tpm_chip *, u8);
	int (*recv)(struct tpm_chip *, u8 *, size_t);
	int (*send)(struct tpm_chip *, u8 *, size_t);
	void (*cancel)(struct tpm_chip *);
	u8 (*status)(struct tpm_chip *);
	void (*update_timeouts)(struct tpm_chip *, unsigned long *);
	void (*update_durations)(struct tpm_chip *, unsigned long *);
	int (*go_idle)(struct tpm_chip *);
	int (*cmd_ready)(struct tpm_chip *);
	int (*request_locality)(struct tpm_chip *, int);
	int (*relinquish_locality)(struct tpm_chip *, int);
	void (*clk_enable)(struct tpm_chip *, bool);
};

struct tpm_bank_info {
	u16 alg_id;
	u16 digest_size;
	u16 crypto_id;
};

struct tpm2_cap_handles {
	u8 more_data;
	__be32 capability;
	__be32 count;
	__be32 handles[0];
} __attribute__((packed));

struct tpm_buf {
	unsigned int flags;
	u8 *data;
};

struct io_pgtable;

struct io_pgtable_cfg;

struct io_pgtable_init_fns {
	struct io_pgtable * (*alloc)(struct io_pgtable_cfg *, void *);
	void (*free)(struct io_pgtable *);
};

enum io_pgtable_fmt {
	ARM_32_LPAE_S1 = 0,
	ARM_32_LPAE_S2 = 1,
	ARM_64_LPAE_S1 = 2,
	ARM_64_LPAE_S2 = 3,
	ARM_V7S = 4,
	ARM_MALI_LPAE = 5,
	AMD_IOMMU_V1 = 6,
	AMD_IOMMU_V2 = 7,
	APPLE_DART = 8,
	APPLE_DART2 = 9,
	IO_PGTABLE_NUM_FMTS = 10,
};

struct iommu_flush_ops;

struct io_pgtable_cfg {
	unsigned long quirks;
	unsigned long pgsize_bitmap;
	unsigned int ias;
	unsigned int oas;
	bool coherent_walk;
	const struct iommu_flush_ops *tlb;
	struct device *iommu_dev;
	union {
		struct {
			u64 ttbr;
			struct {
				u32 ips: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 tsz: 6;
			} tcr;
			u64 mair;
		} arm_lpae_s1_cfg;
		struct {
			u64 vttbr;
			struct {
				u32 ps: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 sl: 2;
				u32 tsz: 6;
			} vtcr;
		} arm_lpae_s2_cfg;
		struct {
			u32 ttbr;
			u32 tcr;
			u32 nmrr;
			u32 prrr;
		} arm_v7s_cfg;
		struct {
			u64 transtab;
			u64 memattr;
		} arm_mali_lpae_cfg;
		struct {
			u64 ttbr[4];
			u32 n_ttbrs;
		} apple_dart_cfg;
	};
};

struct io_pgtable_ops {
	int (*map_pages)(struct io_pgtable_ops *, unsigned long, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
	size_t (*unmap_pages)(struct io_pgtable_ops *, unsigned long, size_t, size_t, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct io_pgtable_ops *, unsigned long);
	int (*read_and_clear_dirty)(struct io_pgtable_ops *, unsigned long, size_t, unsigned long, struct iommu_dirty_bitmap *);
};

struct io_pgtable {
	enum io_pgtable_fmt fmt;
	void *cookie;
	struct io_pgtable_cfg cfg;
	struct io_pgtable_ops ops;
};

struct iommu_flush_ops {
	void (*tlb_flush_all)(void *);
	void (*tlb_flush_walk)(unsigned long, size_t, size_t, void *);
	void (*tlb_add_page)(struct iommu_iotlb_gather *, unsigned long, size_t, void *);
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

struct msi_domain_ops;

struct msi_domain_info {
	u32 flags;
	enum irq_domain_bus_token bus_token;
	unsigned int hwsize;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*prepare_desc)(struct irq_domain *, msi_alloc_info_t *, struct msi_desc *);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);
	void (*domain_free_irqs)(struct irq_domain *, struct device *);
	void (*msi_post_free)(struct irq_domain *, struct device *);
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct irq_affinity_devres {
	unsigned int count;
	unsigned int irq[0];
};

struct firmware_fallback_config {
	unsigned int force_sysfs_fallback;
	unsigned int ignore_sysfs_fallback;
	int old_timeout;
	int loading_timeout;
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct firmware_cache;

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	bool is_paged_buf;
	struct page **pages;
	int nr_pages;
	int page_array_size;
	bool need_uevent;
	struct list_head pending_list;
	const char *fw_name;
};

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

struct fw_sysfs {
	bool nowait;
	struct device dev;
	struct fw_priv *fw_priv;
	struct firmware *fw;
	void *fw_upload_priv;
};

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(const struct class *, const struct class_attribute *, char *);
	ssize_t (*store)(const struct class *, const struct class_attribute *, const char *, size_t);
};

struct devcd_entry {
	struct device devcd_dev;
	void *data;
	size_t datalen;
	struct mutex mutex;
	bool delete_work;
	struct module *owner;
	ssize_t (*read)(char *, loff_t, size_t, void *, size_t);
	void (*free)(void *);
	struct delayed_work del_wk;
	struct device *failing_dev;
};

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_off_t off_t;

typedef void (*btf_trace_devres_log)(void *, struct device *, const char *, void *, const char *, size_t);

struct trace_event_raw_devres {
	struct trace_entry ent;
	u32 __data_loc_devname;
	struct device *dev;
	const char *op;
	void *node;
	const char *name;
	size_t size;
	char __data[0];
};

struct trace_event_data_offsets_devres {
	u32 devname;
};

struct mfd_cell_acpi_match;

struct mfd_cell {
	const char *name;
	int id;
	int level;
	int (*suspend)(struct platform_device *);
	int (*resume)(struct platform_device *);
	void *platform_data;
	size_t pdata_size;
	const struct mfd_cell_acpi_match *acpi_match;
	const struct software_node *swnode;
	const char *of_compatible;
	u64 of_reg;
	bool use_of_reg;
	int num_resources;
	const struct resource *resources;
	bool ignore_resource_conflicts;
	bool pm_runtime_no_callbacks;
	int num_parent_supplies;
	const char * const *parent_supplies;
};

struct mfd_cell_acpi_match {
	const char *pnpid;
	const unsigned long long adr;
};

struct bgpio_pdata {
	const char *label;
	int base;
	int ngpio;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	unsigned long flags;
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

enum scsi_cmnd_submitter {
	SUBMITTED_BY_BLOCK_LAYER = 0,
	SUBMITTED_BY_SCSI_ERROR_HANDLER = 1,
	SUBMITTED_BY_SCSI_RESET_IOCTL = 2,
} __attribute__((mode(byte)));

enum scsi_timeout_action {
	SCSI_EH_DONE = 0,
	SCSI_EH_RESET_TIMER = 1,
	SCSI_EH_NOT_HANDLED = 2,
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

enum sas_device_type {
	SAS_PHY_UNUSED = 0,
	SAS_END_DEVICE = 1,
	SAS_EDGE_EXPANDER_DEVICE = 2,
	SAS_FANOUT_EXPANDER_DEVICE = 3,
	SAS_HA = 4,
	SAS_SATA_DEV = 5,
	SAS_SATA_PM = 7,
	SAS_SATA_PM_PORT = 8,
	SAS_SATA_PENDING = 9,
};

enum sas_protocol {
	SAS_PROTOCOL_NONE = 0,
	SAS_PROTOCOL_SATA = 1,
	SAS_PROTOCOL_SMP = 2,
	SAS_PROTOCOL_STP = 4,
	SAS_PROTOCOL_SSP = 8,
	SAS_PROTOCOL_ALL = 14,
	SAS_PROTOCOL_STP_ALL = 5,
	SAS_PROTOCOL_INTERNAL_ABORT = 16,
};

enum sas_linkrate {
	SAS_LINK_RATE_UNKNOWN = 0,
	SAS_PHY_DISABLED = 1,
	SAS_PHY_RESET_PROBLEM = 2,
	SAS_SATA_SPINUP_HOLD = 3,
	SAS_SATA_PORT_SELECTOR = 4,
	SAS_PHY_RESET_IN_PROGRESS = 5,
	SAS_LINK_RATE_1_5_GBPS = 8,
	SAS_LINK_RATE_G1 = 8,
	SAS_LINK_RATE_3_0_GBPS = 9,
	SAS_LINK_RATE_G2 = 9,
	SAS_LINK_RATE_6_0_GBPS = 10,
	SAS_LINK_RATE_12_0_GBPS = 11,
	SAS_LINK_RATE_22_5_GBPS = 12,
	SAS_LINK_RATE_FAILED = 16,
	SAS_PHY_VIRTUAL = 17,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

struct sas_identify {
	enum sas_device_type device_type;
	enum sas_protocol initiator_port_protocols;
	enum sas_protocol target_port_protocols;
	u64 sas_address;
	u8 phy_identifier;
};

struct sas_rphy {
	struct device dev;
	struct sas_identify identify;
	struct list_head list;
	struct request_queue *q;
	u32 scsi_target_id;
};

struct sas_host_attrs {
	struct list_head rphy_list;
	struct mutex lock;
	struct request_queue *q;
	u32 next_target_id;
	u32 next_expander_id;
	int next_port_id;
};

struct sas_expander_device {
	int level;
	int next_port_id;
	char vendor_id[9];
	char product_id[17];
	char product_rev[5];
	char component_vendor_id[9];
	u16 component_id;
	u8 component_revision_id;
	struct sas_rphy rphy;
};

struct sas_phy {
	struct device dev;
	int number;
	int enabled;
	struct sas_identify identify;
	enum sas_linkrate negotiated_linkrate;
	enum sas_linkrate minimum_linkrate_hw;
	enum sas_linkrate minimum_linkrate;
	enum sas_linkrate maximum_linkrate_hw;
	enum sas_linkrate maximum_linkrate;
	u32 invalid_dword_count;
	u32 running_disparity_error_count;
	u32 loss_of_dword_sync_count;
	u32 phy_reset_problem_count;
	struct list_head port_siblings;
	void *hostdata;
};

struct sas_port {
	struct device dev;
	int port_identifier;
	int num_phys;
	unsigned int is_backlink: 1;
	struct sas_rphy *rphy;
	struct mutex phy_list_mutex;
	struct list_head phy_list;
	struct list_head del_list;
};

struct Scsi_Host;

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct sas_function_template;

struct sas_domain_function_template;

struct sas_internal {
	struct scsi_transport_template t;
	struct sas_function_template *f;
	struct sas_domain_function_template *dft;
	struct device_attribute private_host_attrs[0];
	struct device_attribute private_phy_attrs[17];
	struct device_attribute private_port_attrs[1];
	struct device_attribute private_rphy_attrs[8];
	struct device_attribute private_end_dev_attrs[5];
	struct device_attribute private_expander_attrs[7];
	struct transport_container phy_attr_cont;
	struct transport_container port_attr_cont;
	struct transport_container rphy_attr_cont;
	struct transport_container end_dev_attr_cont;
	struct transport_container expander_attr_cont;
	struct device_attribute *host_attrs[1];
	struct device_attribute *phy_attrs[18];
	struct device_attribute *port_attrs[2];
	struct device_attribute *rphy_attrs[9];
	struct device_attribute *end_dev_attrs[6];
	struct device_attribute *expander_attrs[8];
};

struct scsi_host_template;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_abort_list;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	const struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct kref tagset_refcnt;
	struct completion tagset_freed;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	unsigned long last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	unsigned short max_cmd_len;
	int this_id;
	int can_queue;
	short cmd_per_lun;
	unsigned short sg_tablesize;
	unsigned short sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int opt_sectors;
	unsigned int max_segment_size;
	unsigned long dma_boundary;
	unsigned long virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int nr_maps;
	unsigned int active_mode: 2;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int queuecommand_may_block: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	unsigned long base;
	unsigned long io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	unsigned long hostdata[0];
};

struct scsi_cmnd;

struct scsi_device;

struct scsi_target;

struct scsi_host_template {
	unsigned int cmd_size;
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void __attribute__((btf_type_tag("user"))) *);
	int (*compat_ioctl)(struct scsi_device *, unsigned int, void __attribute__((btf_type_tag("user"))) *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*slave_alloc)(struct scsi_device *);
	int (*slave_configure)(struct scsi_device *);
	void (*slave_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, unsigned long);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	void (*map_queues)(struct Scsi_Host *);
	int (*mq_poll)(struct Scsi_Host *, unsigned int);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum scsi_timeout_action (*eh_timed_out)(struct scsi_cmnd *);
	bool (*eh_should_retry_cmd)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	int can_queue;
	int this_id;
	unsigned short sg_tablesize;
	unsigned short sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned long dma_boundary;
	unsigned long virt_boundary_mask;
	short cmd_per_lun;
	int tag_alloc_policy;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int queuecommand_may_block: 1;
	unsigned int max_host_blocked;
	const struct attribute_group **shost_groups;
	const struct attribute_group **sdev_groups;
	u64 vendor_id;
	int rpm_autosuspend_delay;
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_cmnd {
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	int budget_token;
	unsigned long jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	enum scsi_cmnd_submitter submitter;
	unsigned short cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char cmnd[32];
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	unsigned int resid_len;
	unsigned int sense_len;
	unsigned char *sense_buffer;
	int flags;
	unsigned long state;
	unsigned int extra_len;
	unsigned char *host_scribble;
	int result;
};

typedef __u64 blist_flags_t;

struct scsi_vpd;

struct scsi_device_handler;

struct bsg_device;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	struct sbitmap budget_map;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	unsigned short queue_depth;
	unsigned short max_queue_depth;
	unsigned short last_queue_full_depth;
	unsigned short last_queue_full_count;
	unsigned long last_queue_full_time;
	unsigned long queue_ramp_up_period;
	unsigned long last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd __attribute__((btf_type_tag("rcu"))) *vpd_pg0;
	struct scsi_vpd __attribute__((btf_type_tag("rcu"))) *vpd_pg83;
	struct scsi_vpd __attribute__((btf_type_tag("rcu"))) *vpd_pg80;
	struct scsi_vpd __attribute__((btf_type_tag("rcu"))) *vpd_pg89;
	struct scsi_vpd __attribute__((btf_type_tag("rcu"))) *vpd_pgb0;
	struct scsi_vpd __attribute__((btf_type_tag("rcu"))) *vpd_pgb1;
	struct scsi_vpd __attribute__((btf_type_tag("rcu"))) *vpd_pgb2;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int manage_system_start_stop: 1;
	unsigned int manage_runtime_start_stop: 1;
	unsigned int manage_shutdown: 1;
	unsigned int force_runtime_start_on_system_start: 1;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int use_16_for_sync: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	unsigned int ignore_media_change: 1;
	unsigned int silence_suspend: 1;
	unsigned int no_vpd_size: 1;
	unsigned int cdl_supported: 1;
	unsigned int cdl_enable: 1;
	unsigned int queue_stopped;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	unsigned long supported_events[1];
	unsigned long pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	atomic_t iotmo_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	struct bsg_device *bsg_dev;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	unsigned long sdev_data[0];
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	unsigned long starget_data[0];
};

struct sas_phy_linkrates;

struct bsg_job;

struct sas_function_template {
	int (*get_linkerrors)(struct sas_phy *);
	int (*get_enclosure_identifier)(struct sas_rphy *, u64 *);
	int (*get_bay_identifier)(struct sas_rphy *);
	int (*phy_reset)(struct sas_phy *, int);
	int (*phy_enable)(struct sas_phy *, int);
	int (*phy_setup)(struct sas_phy *);
	void (*phy_release)(struct sas_phy *);
	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
	void (*smp_handler)(struct bsg_job *, struct Scsi_Host *, struct sas_rphy *);
};

struct sas_phy_linkrates {
	enum sas_linkrate maximum_linkrate;
	enum sas_linkrate minimum_linkrate;
};

struct bsg_buffer {
	unsigned int payload_len;
	int sg_cnt;
	struct scatterlist *sg_list;
};

struct bsg_job {
	struct device *dev;
	struct kref kref;
	unsigned int timeout;
	void *request;
	void *reply;
	unsigned int request_len;
	unsigned int reply_len;
	struct bsg_buffer request_payload;
	struct bsg_buffer reply_payload;
	int result;
	unsigned int reply_payload_rcv_len;
	struct request *bidi_rq;
	struct bio *bidi_bio;
	void *dd_data;
};

struct sas_end_device {
	struct sas_rphy rphy;
	unsigned int ready_led_meaning: 1;
	unsigned int tlr_supported: 1;
	unsigned int tlr_enabled: 1;
	u16 I_T_nexus_loss_timeout;
	u16 initiator_response_timeout;
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

typedef int bsg_job_fn(struct bsg_job *);

typedef enum blk_eh_timer_return bsg_timeout_fn(struct request *);

struct ata_timing {
	unsigned short mode;
	unsigned short setup;
	unsigned short act8b;
	unsigned short rec8b;
	unsigned short cyc8b;
	unsigned short active;
	unsigned short recover;
	unsigned short dmack_hold;
	unsigned short cycle;
	unsigned short udma;
};

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = -1,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_FUA = 512,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_NCQ_SEND_RECV = 2048,
	ATA_DFLAG_NCQ_PRIO = 4096,
	ATA_DFLAG_CDL = 8192,
	ATA_DFLAG_CFG_MASK = 16383,
	ATA_DFLAG_PIO = 16384,
	ATA_DFLAG_NCQ_OFF = 32768,
	ATA_DFLAG_SLEEPING = 65536,
	ATA_DFLAG_DUBIOUS_XFER = 131072,
	ATA_DFLAG_NO_UNLOAD = 262144,
	ATA_DFLAG_UNLOCK_HPA = 524288,
	ATA_DFLAG_INIT_MASK = 1048575,
	ATA_DFLAG_NCQ_PRIO_ENABLED = 1048576,
	ATA_DFLAG_CDL_ENABLED = 2097152,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DFLAG_FEATURES_MASK = 201341696,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DEBOUNCE_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_RESUMING = 65536,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_RTF_FILLED = 4,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_HAS_CDL = 256,
	ATA_QCFLAG_EH = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_QCFLAG_EH_SUCCESS_CMD = 524288,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_HOST_NO_PART = 16,
	ATA_HOST_NO_SSC = 32,
	ATA_HOST_NO_DEVSLP = 64,
	ATA_TMOUT_BOOT = 30000,
	ATA_TMOUT_BOOT_QUICK = 7000,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 10000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_GET_SUCCESS_SENSE = 64,
	ATA_EH_SET_ACTIVE = 128,
	ATA_EH_PERDEV_MASK = 225,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 8,
	ATA_HORKAGE_DIAGNOSTIC = 1,
	ATA_HORKAGE_NODMA = 2,
	ATA_HORKAGE_NONCQ = 4,
	ATA_HORKAGE_MAX_SEC_128 = 8,
	ATA_HORKAGE_BROKEN_HPA = 16,
	ATA_HORKAGE_DISABLE = 32,
	ATA_HORKAGE_HPA_SIZE = 64,
	ATA_HORKAGE_IVB = 256,
	ATA_HORKAGE_STUCK_ERR = 512,
	ATA_HORKAGE_BRIDGE_OK = 1024,
	ATA_HORKAGE_ATAPI_MOD16_DMA = 2048,
	ATA_HORKAGE_FIRMWARE_WARN = 4096,
	ATA_HORKAGE_1_5_GBPS = 8192,
	ATA_HORKAGE_NOSETXFER = 16384,
	ATA_HORKAGE_BROKEN_FPDMA_AA = 32768,
	ATA_HORKAGE_DUMP_ID = 65536,
	ATA_HORKAGE_MAX_SEC_LBA48 = 131072,
	ATA_HORKAGE_ATAPI_DMADIR = 262144,
	ATA_HORKAGE_NO_NCQ_TRIM = 524288,
	ATA_HORKAGE_NOLPM = 1048576,
	ATA_HORKAGE_WD_BROKEN_LPM = 2097152,
	ATA_HORKAGE_ZERO_AFTER_TRIM = 4194304,
	ATA_HORKAGE_NO_DMA_LOG = 8388608,
	ATA_HORKAGE_NOTRIM = 16777216,
	ATA_HORKAGE_MAX_SEC_1024 = 33554432,
	ATA_HORKAGE_MAX_TRIM_128M = 67108864,
	ATA_HORKAGE_NO_NCQ_ON_ATI = 134217728,
	ATA_HORKAGE_NO_ID_DEV_LOG = 268435456,
	ATA_HORKAGE_NO_LOG_DIR = 536870912,
	ATA_HORKAGE_NO_FUA = 1073741824,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum ata_completion_errors {
	AC_ERR_OK = 0,
	AC_ERR_DEV = 1,
	AC_ERR_HSM = 2,
	AC_ERR_TIMEOUT = 4,
	AC_ERR_MEDIA = 8,
	AC_ERR_ATA_BUS = 16,
	AC_ERR_HOST_BUS = 32,
	AC_ERR_SYSTEM = 64,
	AC_ERR_INVALID = 128,
	AC_ERR_OTHER = 256,
	AC_ERR_NODEV_HINT = 512,
	AC_ERR_NCQ = 1024,
};

enum ata_lpm_policy {
	ATA_LPM_UNKNOWN = 0,
	ATA_LPM_MAX_POWER = 1,
	ATA_LPM_MED_POWER = 2,
	ATA_LPM_MED_POWER_WITH_DIPM = 3,
	ATA_LPM_MIN_POWER_WITH_PARTIAL = 4,
	ATA_LPM_MIN_POWER = 5,
};

enum sw_activity {
	OFF = 0,
	BLINK_ON = 1,
	BLINK_OFF = 2,
};

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = -2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_CDL = 24,
	ATA_LOG_CDL_SIZE = 512,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_SENSE_NCQ = 15,
	ATA_LOG_SENSE_NCQ_SIZE = 1024,
	ATA_LOG_CONCURRENT_POSITIONING_RANGES = 71,
	ATA_LOG_SUPPORTED_CAPABILITIES = 3,
	ATA_LOG_CURRENT_SETTINGS = 4,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SETFEATURES_CDL = 13,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	SETFEATURE_SENSE_DATA_SUCC_NCQ = 196,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

struct ata_ering_entry {
	unsigned int eflags;
	unsigned int err_mask;
	u64 timestamp;
};

struct ata_ering {
	int cursor;
	struct ata_ering_entry ring[32];
};

struct ata_link;

struct ata_cpr_log;

struct ata_device {
	struct ata_link *link;
	unsigned int devno;
	unsigned int horkage;
	unsigned long flags;
	struct scsi_device *sdev;
	void *private_data;
	union acpi_object *gtf_cache;
	unsigned int gtf_filter;
	struct device tdev;
	u64 n_sectors;
	u64 n_native_sectors;
	unsigned int class;
	unsigned long unpark_deadline;
	u8 pio_mode;
	u8 dma_mode;
	u8 xfer_mode;
	unsigned int xfer_shift;
	unsigned int multi_count;
	unsigned int max_sectors;
	unsigned int cdb_len;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	u16 cylinders;
	u16 heads;
	u16 sectors;
	long: 64;
	union {
		u16 id[256];
		u32 gscr[128];
	};
	u8 devslp_timing[8];
	u8 ncq_send_recv_cmds[20];
	u8 ncq_non_data_cmds[64];
	u32 zac_zoned_cap;
	u32 zac_zones_optimal_open;
	u32 zac_zones_optimal_nonseq;
	u32 zac_zones_max_open;
	struct ata_cpr_log *cpr_log;
	u8 cdl[512];
	int spdn_cnt;
	struct ata_ering ering;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ata_eh_info {
	struct ata_device *dev;
	u32 serror;
	unsigned int err_mask;
	unsigned int action;
	unsigned int dev_action[2];
	unsigned int flags;
	unsigned int probe_mask;
	char desc[80];
	int desc_len;
};

struct ata_eh_context {
	struct ata_eh_info i;
	int tries[2];
	int cmd_timeout_idx[16];
	unsigned int classes[2];
	unsigned int did_probe_mask;
	unsigned int unloaded_mask;
	unsigned int saved_ncq_enabled;
	u8 saved_xfer_mode[2];
	unsigned long last_reset;
};

struct ata_port;

struct ata_link {
	struct ata_port *ap;
	int pmp;
	struct device tdev;
	unsigned int active_tag;
	u32 sactive;
	unsigned int flags;
	u32 saved_scontrol;
	unsigned int hw_sata_spd_limit;
	unsigned int sata_spd_limit;
	unsigned int sata_spd;
	enum ata_lpm_policy lpm_policy;
	struct ata_eh_info eh_info;
	struct ata_eh_context eh_context;
	struct ata_device device[2];
	unsigned long last_lpm_change;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ata_ioports {
	void *cmd_addr;
	void *data_addr;
	void *error_addr;
	void *feature_addr;
	void *nsect_addr;
	void *lbal_addr;
	void *lbam_addr;
	void *lbah_addr;
	void *device_addr;
	void *status_addr;
	void *command_addr;
	void *altstatus_addr;
	void *ctl_addr;
	void *bmdma_addr;
	void *scr_addr;
};

struct ata_taskfile {
	unsigned long flags;
	u8 protocol;
	u8 ctl;
	u8 hob_feature;
	u8 hob_nsect;
	u8 hob_lbal;
	u8 hob_lbam;
	u8 hob_lbah;
	union {
		u8 error;
		u8 feature;
	};
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	union {
		u8 status;
		u8 command;
	};
	u32 auxiliary;
};

struct ata_queued_cmd;

typedef void (*ata_qc_cb_t)(struct ata_queued_cmd *);

struct ata_queued_cmd {
	struct ata_port *ap;
	struct ata_device *dev;
	struct scsi_cmnd *scsicmd;
	void (*scsidone)(struct scsi_cmnd *);
	struct ata_taskfile tf;
	u8 cdb[16];
	unsigned long flags;
	unsigned int tag;
	unsigned int hw_tag;
	unsigned int n_elem;
	unsigned int orig_n_elem;
	int dma_dir;
	unsigned int sect_size;
	unsigned int nbytes;
	unsigned int extrabytes;
	unsigned int curbytes;
	struct scatterlist sgent;
	struct scatterlist *sg;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	unsigned int err_mask;
	struct ata_taskfile result_tf;
	ata_qc_cb_t complete_fn;
	void *private_data;
	void *lldd_task;
};

struct ata_port_stats {
	unsigned long unhandled_irq;
	unsigned long idle_irq;
	unsigned long rw_reqbuf;
};

typedef u64 async_cookie_t;

struct ata_acpi_drive {
	u32 pio;
	u32 dma;
};

struct ata_acpi_gtm {
	struct ata_acpi_drive drive[2];
	u32 flags;
};

struct ata_port_operations;

struct ata_bmdma_prd;

struct ata_host;

struct ata_port {
	struct Scsi_Host *scsi_host;
	struct ata_port_operations *ops;
	spinlock_t *lock;
	unsigned long flags;
	unsigned int pflags;
	unsigned int print_id;
	unsigned int local_port_no;
	unsigned int port_no;
	struct ata_ioports ioaddr;
	u8 ctl;
	u8 last_ctl;
	struct ata_link *sff_pio_task_link;
	struct delayed_work sff_pio_task;
	struct ata_bmdma_prd *bmdma_prd;
	dma_addr_t bmdma_prd_dma;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	unsigned int cbl;
	struct ata_queued_cmd qcmd[33];
	u64 qc_active;
	int nr_active_links;
	long: 64;
	long: 64;
	struct ata_link link;
	struct ata_link *slave_link;
	int nr_pmp_links;
	struct ata_link *pmp_link;
	struct ata_link *excl_link;
	struct ata_port_stats stats;
	struct ata_host *host;
	struct device *dev;
	struct device tdev;
	struct mutex scsi_scan_mutex;
	struct delayed_work hotplug_task;
	struct delayed_work scsi_rescan_task;
	unsigned int hsm_task_state;
	struct list_head eh_done_q;
	wait_queue_head_t eh_wait_q;
	int eh_tries;
	struct completion park_req_pending;
	pm_message_t pm_mesg;
	enum ata_lpm_policy target_lpm_policy;
	struct timer_list fastdrain_timer;
	unsigned int fastdrain_cnt;
	async_cookie_t cookie;
	int em_message_type;
	void *private_data;
	struct ata_acpi_gtm __acpi_init_gtm;
	u8 *ncq_sense_buf;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 sector_buf[512];
};

typedef int (*ata_prereset_fn_t)(struct ata_link *, unsigned long);

typedef int (*ata_reset_fn_t)(struct ata_link *, unsigned int *, unsigned long);

typedef void (*ata_postreset_fn_t)(struct ata_link *, unsigned int *);

struct ata_port_operations {
	int (*qc_defer)(struct ata_queued_cmd *);
	int (*check_atapi_dma)(struct ata_queued_cmd *);
	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *);
	unsigned int (*qc_issue)(struct ata_queued_cmd *);
	void (*qc_fill_rtf)(struct ata_queued_cmd *);
	void (*qc_ncq_fill_rtf)(struct ata_port *, u64);
	int (*cable_detect)(struct ata_port *);
	unsigned int (*mode_filter)(struct ata_device *, unsigned int);
	void (*set_piomode)(struct ata_port *, struct ata_device *);
	void (*set_dmamode)(struct ata_port *, struct ata_device *);
	int (*set_mode)(struct ata_link *, struct ata_device **);
	unsigned int (*read_id)(struct ata_device *, struct ata_taskfile *, __le16 *);
	void (*dev_config)(struct ata_device *);
	void (*freeze)(struct ata_port *);
	void (*thaw)(struct ata_port *);
	ata_prereset_fn_t prereset;
	ata_reset_fn_t softreset;
	ata_reset_fn_t hardreset;
	ata_postreset_fn_t postreset;
	ata_prereset_fn_t pmp_prereset;
	ata_reset_fn_t pmp_softreset;
	ata_reset_fn_t pmp_hardreset;
	ata_postreset_fn_t pmp_postreset;
	void (*error_handler)(struct ata_port *);
	void (*lost_interrupt)(struct ata_port *);
	void (*post_internal_cmd)(struct ata_queued_cmd *);
	void (*sched_eh)(struct ata_port *);
	void (*end_eh)(struct ata_port *);
	int (*scr_read)(struct ata_link *, unsigned int, u32 *);
	int (*scr_write)(struct ata_link *, unsigned int, u32);
	void (*pmp_attach)(struct ata_port *);
	void (*pmp_detach)(struct ata_port *);
	int (*set_lpm)(struct ata_link *, enum ata_lpm_policy, unsigned int);
	int (*port_suspend)(struct ata_port *, pm_message_t);
	int (*port_resume)(struct ata_port *);
	int (*port_start)(struct ata_port *);
	void (*port_stop)(struct ata_port *);
	void (*host_stop)(struct ata_host *);
	void (*sff_dev_select)(struct ata_port *, unsigned int);
	void (*sff_set_devctl)(struct ata_port *, u8);
	u8 (*sff_check_status)(struct ata_port *);
	u8 (*sff_check_altstatus)(struct ata_port *);
	void (*sff_tf_load)(struct ata_port *, const struct ata_taskfile *);
	void (*sff_tf_read)(struct ata_port *, struct ata_taskfile *);
	void (*sff_exec_command)(struct ata_port *, const struct ata_taskfile *);
	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *, unsigned char *, unsigned int, int);
	void (*sff_irq_on)(struct ata_port *);
	bool (*sff_irq_check)(struct ata_port *);
	void (*sff_irq_clear)(struct ata_port *);
	void (*sff_drain_fifo)(struct ata_queued_cmd *);
	void (*bmdma_setup)(struct ata_queued_cmd *);
	void (*bmdma_start)(struct ata_queued_cmd *);
	void (*bmdma_stop)(struct ata_queued_cmd *);
	u8 (*bmdma_status)(struct ata_port *);
	ssize_t (*em_show)(struct ata_port *, char *);
	ssize_t (*em_store)(struct ata_port *, const char *, size_t);
	ssize_t (*sw_activity_show)(struct ata_device *, char *);
	ssize_t (*sw_activity_store)(struct ata_device *, enum sw_activity);
	ssize_t (*transmit_led_message)(struct ata_port *, u32, ssize_t);
	const struct ata_port_operations *inherits;
};

struct ata_host {
	spinlock_t lock;
	struct device *dev;
	void * const *iomap;
	unsigned int n_ports;
	unsigned int n_tags;
	void *private_data;
	struct ata_port_operations *ops;
	unsigned long flags;
	struct kref kref;
	struct mutex eh_mutex;
	struct task_struct *eh_owner;
	struct ata_port *simplex_claimed;
	struct ata_port *ports[0];
};

struct ata_bmdma_prd {
	__le32 addr;
	__le32 flags_len;
};

struct ata_cpr {
	u8 num;
	u8 num_storage_elements;
	u64 start_lba;
	u64 num_lbas;
};

struct ata_cpr_log {
	u8 nr_cpr;
	struct ata_cpr cpr[0];
};

typedef unsigned char u_char;

struct mtd_ecc_stats {
	__u32 corrected;
	__u32 failed;
	__u32 badblocks;
	__u32 bbtblocks;
};

struct mtd_debug_info {
	struct dentry *dfs_dir;
};

struct mtd_part {
	struct list_head node;
	u64 offset;
	u64 size;
	u32 flags;
};

struct mtd_master {
	struct mutex partitions_lock;
	struct mutex chrdev_lock;
	unsigned int suspended: 1;
};

struct mtd_ooblayout_ops;

struct mtd_pairing_scheme;

struct mtd_erase_region_info;

struct erase_info;

struct mtd_oob_ops;

struct otp_info;

struct nvmem_device;

struct mtd_info {
	u_char type;
	uint32_t flags;
	uint64_t size;
	uint32_t erasesize;
	uint32_t writesize;
	uint32_t writebufsize;
	uint32_t oobsize;
	uint32_t oobavail;
	unsigned int erasesize_shift;
	unsigned int writesize_shift;
	unsigned int erasesize_mask;
	unsigned int writesize_mask;
	unsigned int bitflip_threshold;
	const char *name;
	int index;
	const struct mtd_ooblayout_ops *ooblayout;
	const struct mtd_pairing_scheme *pairing;
	unsigned int ecc_step_size;
	unsigned int ecc_strength;
	int numeraseregions;
	struct mtd_erase_region_info *eraseregions;
	int (*_erase)(struct mtd_info *, struct erase_info *);
	int (*_point)(struct mtd_info *, loff_t, size_t, size_t *, void **, resource_size_t *);
	int (*_unpoint)(struct mtd_info *, loff_t, size_t);
	int (*_read)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_panic_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_read_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_write_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_get_fact_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_fact_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_get_user_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_lock_user_prot_reg)(struct mtd_info *, loff_t, size_t);
	int (*_erase_user_prot_reg)(struct mtd_info *, loff_t, size_t);
	int (*_writev)(struct mtd_info *, const struct kvec *, unsigned long, loff_t, size_t *);
	void (*_sync)(struct mtd_info *);
	int (*_lock)(struct mtd_info *, loff_t, uint64_t);
	int (*_unlock)(struct mtd_info *, loff_t, uint64_t);
	int (*_is_locked)(struct mtd_info *, loff_t, uint64_t);
	int (*_block_isreserved)(struct mtd_info *, loff_t);
	int (*_block_isbad)(struct mtd_info *, loff_t);
	int (*_block_markbad)(struct mtd_info *, loff_t);
	int (*_max_bad_blocks)(struct mtd_info *, loff_t, size_t);
	int (*_suspend)(struct mtd_info *);
	void (*_resume)(struct mtd_info *);
	void (*_reboot)(struct mtd_info *);
	int (*_get_device)(struct mtd_info *);
	void (*_put_device)(struct mtd_info *);
	bool oops_panic_write;
	struct notifier_block reboot_notifier;
	struct mtd_ecc_stats ecc_stats;
	int subpage_sft;
	void *priv;
	struct module *owner;
	struct device dev;
	struct kref refcnt;
	struct mtd_debug_info dbg;
	struct nvmem_device *nvmem;
	struct nvmem_device *otp_user_nvmem;
	struct nvmem_device *otp_factory_nvmem;
	struct mtd_info *parent;
	struct list_head partitions;
	struct mtd_part part;
	struct mtd_master master;
};

struct mtd_oob_region;

struct mtd_ooblayout_ops {
	int (*ecc)(struct mtd_info *, int, struct mtd_oob_region *);
	int (*free)(struct mtd_info *, int, struct mtd_oob_region *);
};

struct mtd_oob_region {
	u32 offset;
	u32 length;
};

struct mtd_pairing_info;

struct mtd_pairing_scheme {
	int ngroups;
	int (*get_info)(struct mtd_info *, int, struct mtd_pairing_info *);
	int (*get_wunit)(struct mtd_info *, const struct mtd_pairing_info *);
};

struct mtd_pairing_info {
	int pair;
	int group;
};

struct mtd_erase_region_info {
	uint64_t offset;
	uint32_t erasesize;
	uint32_t numblocks;
	unsigned long *lockmap;
};

struct erase_info {
	uint64_t addr;
	uint64_t len;
	uint64_t fail_addr;
};

struct mtd_req_stats;

struct mtd_oob_ops {
	unsigned int mode;
	size_t len;
	size_t retlen;
	size_t ooblen;
	size_t oobretlen;
	uint32_t ooboffs;
	uint8_t *datbuf;
	uint8_t *oobbuf;
	struct mtd_req_stats *stats;
};

struct mtd_req_stats {
	unsigned int uncorrectable_errors;
	unsigned int corrected_bitflips;
	unsigned int max_bitflips;
};

struct otp_info {
	__u32 start;
	__u32 length;
	__u32 locked;
};

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
	NVMEM_TYPE_FRAM = 4,
};

enum {
	MTD_OPS_PLACE_OOB = 0,
	MTD_OPS_AUTO_OOB = 1,
	MTD_OPS_RAW = 2,
};

struct mtd_notifier {
	void (*add)(struct mtd_info *);
	void (*remove)(struct mtd_info *);
	struct list_head list;
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

struct nvmem_cell_info;

struct nvmem_keepout;

struct nvmem_layout;

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	const struct nvmem_cell_info *cells;
	int ncells;
	bool add_legacy_fixed_of_cells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool ignore_wp;
	struct nvmem_layout *layout;
	struct device_node *of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

typedef int (*nvmem_cell_post_process_t)(void *, const char *, int, unsigned int, void *, size_t);

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	size_t raw_len;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
	struct device_node *np;
	nvmem_cell_post_process_t read_post_process;
	void *priv;
};

struct nvmem_keepout {
	unsigned int start;
	unsigned int end;
	unsigned char value;
};

struct nvmem_layout {
	const char *name;
	const struct of_device_id *of_match_table;
	int (*add_cells)(struct device *, struct nvmem_device *, struct nvmem_layout *);
	void (*fixup_cell_info)(struct nvmem_device *, struct nvmem_layout *, struct nvmem_cell_info *);
	struct module *owner;
	struct list_head node;
};

struct mtd_part_parser_data {
	unsigned long origin;
};

struct mtd_partition {
	const char *name;
	const char * const *types;
	uint64_t size;
	uint64_t offset;
	uint32_t mask_flags;
	uint32_t add_flags;
	struct device_node *of_node;
};

struct nand_flash_dev {
	char *name;
	union {
		struct {
			uint8_t mfr_id;
			uint8_t dev_id;
		};
		uint8_t id[8];
	};
	unsigned int pagesize;
	unsigned int chipsize;
	unsigned int erasesize;
	unsigned int options;
	uint16_t id_len;
	uint16_t oobsize;
	struct {
		uint16_t strength_ds;
		uint16_t step_ds;
	} ecc;
};

struct nand_manufacturer_ops;

struct nand_manufacturer_desc {
	int id;
	char *name;
	const struct nand_manufacturer_ops *ops;
};

struct nand_chip;

struct nand_onfi_params;

struct nand_manufacturer_ops {
	void (*detect)(struct nand_chip *);
	int (*init)(struct nand_chip *);
	void (*cleanup)(struct nand_chip *);
	void (*fixup_onfi_param_page)(struct nand_chip *, struct nand_onfi_params *);
};

struct nand_memory_organization {
	unsigned int bits_per_cell;
	unsigned int pagesize;
	unsigned int oobsize;
	unsigned int pages_per_eraseblock;
	unsigned int eraseblocks_per_lun;
	unsigned int max_bad_eraseblocks_per_lun;
	unsigned int planes_per_lun;
	unsigned int luns_per_target;
	unsigned int ntargets;
};

enum nand_ecc_engine_type {
	NAND_ECC_ENGINE_TYPE_INVALID = 0,
	NAND_ECC_ENGINE_TYPE_NONE = 1,
	NAND_ECC_ENGINE_TYPE_SOFT = 2,
	NAND_ECC_ENGINE_TYPE_ON_HOST = 3,
	NAND_ECC_ENGINE_TYPE_ON_DIE = 4,
};

enum nand_ecc_placement {
	NAND_ECC_PLACEMENT_UNKNOWN = 0,
	NAND_ECC_PLACEMENT_OOB = 1,
	NAND_ECC_PLACEMENT_INTERLEAVED = 2,
};

enum nand_ecc_algo {
	NAND_ECC_ALGO_UNKNOWN = 0,
	NAND_ECC_ALGO_HAMMING = 1,
	NAND_ECC_ALGO_BCH = 2,
	NAND_ECC_ALGO_RS = 3,
};

struct nand_ecc_props {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	unsigned int strength;
	unsigned int step_size;
	unsigned int flags;
};

struct nand_ecc_context {
	struct nand_ecc_props conf;
	unsigned int nsteps;
	unsigned int total;
	void *priv;
};

struct nand_ecc_engine;

struct nand_ecc {
	struct nand_ecc_props defaults;
	struct nand_ecc_props requirements;
	struct nand_ecc_props user_conf;
	struct nand_ecc_context ctx;
	struct nand_ecc_engine *ondie_engine;
	struct nand_ecc_engine *engine;
};

struct nand_row_converter {
	unsigned int lun_addr_shift;
	unsigned int eraseblock_addr_shift;
};

struct nand_bbt {
	unsigned long *cache;
};

struct nand_ops;

struct nand_device {
	struct mtd_info mtd;
	struct nand_memory_organization memorg;
	struct nand_ecc ecc;
	struct nand_row_converter rowconv;
	struct nand_bbt bbt;
	const struct nand_ops *ops;
};

struct nand_id {
	u8 data[8];
	int len;
};

struct onfi_params;

struct nand_parameters {
	const char *model;
	bool supports_set_get_features;
	bool supports_read_cache;
	unsigned long set_feature_list[4];
	unsigned long get_feature_list[4];
	struct onfi_params *onfi;
};

struct nand_manufacturer {
	const struct nand_manufacturer_desc *desc;
	void *priv;
};

struct nand_interface_config;

struct nand_chip_ops {
	int (*suspend)(struct nand_chip *);
	void (*resume)(struct nand_chip *);
	int (*lock_area)(struct nand_chip *, loff_t, uint64_t);
	int (*unlock_area)(struct nand_chip *, loff_t, uint64_t);
	int (*setup_read_retry)(struct nand_chip *, int);
	int (*choose_interface_config)(struct nand_chip *, struct nand_interface_config *);
};

struct nand_controller_ops;

struct nand_controller {
	struct mutex lock;
	const struct nand_controller_ops *ops;
	struct {
		unsigned int data_only_read: 1;
		unsigned int cont_read: 1;
	} supported_op;
};

struct nand_legacy {
	void *IO_ADDR_R;
	void *IO_ADDR_W;
	void (*select_chip)(struct nand_chip *, int);
	u8 (*read_byte)(struct nand_chip *);
	void (*write_byte)(struct nand_chip *, u8);
	void (*write_buf)(struct nand_chip *, const u8 *, int);
	void (*read_buf)(struct nand_chip *, u8 *, int);
	void (*cmd_ctrl)(struct nand_chip *, int, unsigned int);
	void (*cmdfunc)(struct nand_chip *, unsigned int, int, int);
	int (*dev_ready)(struct nand_chip *);
	int (*waitfunc)(struct nand_chip *);
	int (*block_bad)(struct nand_chip *, loff_t);
	int (*block_markbad)(struct nand_chip *, loff_t);
	int (*set_features)(struct nand_chip *, int, u8 *);
	int (*get_features)(struct nand_chip *, int, u8 *);
	int chip_delay;
	struct nand_controller dummy_controller;
};

struct nand_ecc_ctrl {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	int steps;
	int size;
	int bytes;
	int total;
	int strength;
	int prepad;
	int postpad;
	unsigned int options;
	u8 *calc_buf;
	u8 *code_buf;
	void (*hwctl)(struct nand_chip *, int);
	int (*calculate)(struct nand_chip *, const uint8_t *, uint8_t *);
	int (*correct)(struct nand_chip *, uint8_t *, uint8_t *, uint8_t *);
	int (*read_page_raw)(struct nand_chip *, uint8_t *, int, int);
	int (*write_page_raw)(struct nand_chip *, const uint8_t *, int, int);
	int (*read_page)(struct nand_chip *, uint8_t *, int, int);
	int (*read_subpage)(struct nand_chip *, uint32_t, uint32_t, uint8_t *, int);
	int (*write_subpage)(struct nand_chip *, uint32_t, uint32_t, const uint8_t *, int, int);
	int (*write_page)(struct nand_chip *, const uint8_t *, int, int);
	int (*write_oob_raw)(struct nand_chip *, int);
	int (*read_oob_raw)(struct nand_chip *, int);
	int (*read_oob)(struct nand_chip *, int);
	int (*write_oob)(struct nand_chip *, int);
};

struct nand_bbt_descr;

struct nand_secure_region;

struct nand_chip {
	struct nand_device base;
	struct nand_id id;
	struct nand_parameters parameters;
	struct nand_manufacturer manufacturer;
	struct nand_chip_ops ops;
	struct nand_legacy legacy;
	unsigned int options;
	const struct nand_interface_config *current_interface_config;
	struct nand_interface_config *best_interface_config;
	unsigned int bbt_erase_shift;
	unsigned int bbt_options;
	unsigned int badblockpos;
	unsigned int badblockbits;
	struct nand_bbt_descr *bbt_td;
	struct nand_bbt_descr *bbt_md;
	struct nand_bbt_descr *badblock_pattern;
	u8 *bbt;
	unsigned int page_shift;
	unsigned int phys_erase_shift;
	unsigned int chip_shift;
	unsigned int pagemask;
	unsigned int subpagesize;
	u8 *data_buf;
	u8 *oob_poi;
	struct {
		unsigned int bitflips;
		int page;
	} pagecache;
	unsigned long buf_align;
	struct mutex lock;
	unsigned int suspended: 1;
	wait_queue_head_t resume_wq;
	int cur_cs;
	int read_retries;
	struct nand_secure_region *secure_regions;
	u8 nr_secure_regions;
	struct {
		bool ongoing;
		unsigned int first_page;
		unsigned int last_page;
	} cont_read;
	struct nand_controller *controller;
	struct nand_ecc_ctrl ecc;
	void *priv;
};

enum nand_ecc_engine_integration {
	NAND_ECC_ENGINE_INTEGRATION_INVALID = 0,
	NAND_ECC_ENGINE_INTEGRATION_PIPELINED = 1,
	NAND_ECC_ENGINE_INTEGRATION_EXTERNAL = 2,
};

struct nand_ecc_engine_ops;

struct nand_ecc_engine {
	struct device *dev;
	struct list_head node;
	struct nand_ecc_engine_ops *ops;
	enum nand_ecc_engine_integration integration;
	void *priv;
};

struct nand_page_io_req;

struct nand_ecc_engine_ops {
	int (*init_ctx)(struct nand_device *);
	void (*cleanup_ctx)(struct nand_device *);
	int (*prepare_io_req)(struct nand_device *, struct nand_page_io_req *);
	int (*finish_io_req)(struct nand_device *, struct nand_page_io_req *);
};

enum nand_page_io_req_type {
	NAND_PAGE_READ = 0,
	NAND_PAGE_WRITE = 1,
};

struct nand_pos {
	unsigned int target;
	unsigned int lun;
	unsigned int plane;
	unsigned int eraseblock;
	unsigned int page;
};

struct nand_page_io_req {
	enum nand_page_io_req_type type;
	struct nand_pos pos;
	unsigned int dataoffs;
	unsigned int datalen;
	union {
		const void *out;
		void *in;
	} databuf;
	unsigned int ooboffs;
	unsigned int ooblen;
	union {
		const void *out;
		void *in;
	} oobbuf;
	int mode;
};

struct nand_ops {
	int (*erase)(struct nand_device *, const struct nand_pos *);
	int (*markbad)(struct nand_device *, const struct nand_pos *);
	bool (*isbad)(struct nand_device *, const struct nand_pos *);
};

struct onfi_params {
	int version;
	u16 tPROG;
	u16 tBERS;
	u16 tR;
	u16 tCCS;
	bool fast_tCAD;
	u16 sdr_timing_modes;
	u16 nvddr_timing_modes;
	u16 vendor_revision;
	u8 vendor[88];
};

enum nand_interface_type {
	NAND_SDR_IFACE = 0,
	NAND_NVDDR_IFACE = 1,
};

struct nand_sdr_timings {
	u64 tBERS_max;
	u32 tCCS_min;
	u64 tPROG_max;
	u64 tR_max;
	u32 tALH_min;
	u32 tADL_min;
	u32 tALS_min;
	u32 tAR_min;
	u32 tCEA_max;
	u32 tCEH_min;
	u32 tCH_min;
	u32 tCHZ_max;
	u32 tCLH_min;
	u32 tCLR_min;
	u32 tCLS_min;
	u32 tCOH_min;
	u32 tCS_min;
	u32 tDH_min;
	u32 tDS_min;
	u32 tFEAT_max;
	u32 tIR_min;
	u32 tITC_max;
	u32 tRC_min;
	u32 tREA_max;
	u32 tREH_min;
	u32 tRHOH_min;
	u32 tRHW_min;
	u32 tRHZ_max;
	u32 tRLOH_min;
	u32 tRP_min;
	u32 tRR_min;
	u64 tRST_max;
	u32 tWB_max;
	u32 tWC_min;
	u32 tWH_min;
	u32 tWHR_min;
	u32 tWP_min;
	u32 tWW_min;
};

struct nand_nvddr_timings {
	u64 tBERS_max;
	u32 tCCS_min;
	u64 tPROG_max;
	u64 tR_max;
	u32 tAC_min;
	u32 tAC_max;
	u32 tADL_min;
	u32 tCAD_min;
	u32 tCAH_min;
	u32 tCALH_min;
	u32 tCALS_min;
	u32 tCAS_min;
	u32 tCEH_min;
	u32 tCH_min;
	u32 tCK_min;
	u32 tCS_min;
	u32 tDH_min;
	u32 tDQSCK_min;
	u32 tDQSCK_max;
	u32 tDQSD_min;
	u32 tDQSD_max;
	u32 tDQSHZ_max;
	u32 tDQSQ_max;
	u32 tDS_min;
	u32 tDSC_min;
	u32 tFEAT_max;
	u32 tITC_max;
	u32 tQHS_max;
	u32 tRHW_min;
	u32 tRR_min;
	u32 tRST_max;
	u32 tWB_max;
	u32 tWHR_min;
	u32 tWRCK_min;
	u32 tWW_min;
};

struct nand_timings {
	unsigned int mode;
	union {
		struct nand_sdr_timings sdr;
		struct nand_nvddr_timings nvddr;
	};
};

struct nand_interface_config {
	enum nand_interface_type type;
	struct nand_timings timings;
};

struct nand_operation;

struct nand_controller_ops {
	int (*attach_chip)(struct nand_chip *);
	void (*detach_chip)(struct nand_chip *);
	int (*exec_op)(struct nand_chip *, const struct nand_operation *, bool);
	int (*setup_interface)(struct nand_chip *, int, const struct nand_interface_config *);
};

struct nand_op_instr;

struct nand_operation {
	unsigned int cs;
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
};

enum nand_op_instr_type {
	NAND_OP_CMD_INSTR = 0,
	NAND_OP_ADDR_INSTR = 1,
	NAND_OP_DATA_IN_INSTR = 2,
	NAND_OP_DATA_OUT_INSTR = 3,
	NAND_OP_WAITRDY_INSTR = 4,
};

struct nand_op_cmd_instr {
	u8 opcode;
};

struct nand_op_addr_instr {
	unsigned int naddrs;
	const u8 *addrs;
};

struct nand_op_data_instr {
	unsigned int len;
	union {
		void *in;
		const void *out;
	} buf;
	bool force_8bit;
};

struct nand_op_waitrdy_instr {
	unsigned int timeout_ms;
};

struct nand_op_instr {
	enum nand_op_instr_type type;
	union {
		struct nand_op_cmd_instr cmd;
		struct nand_op_addr_instr addr;
		struct nand_op_data_instr data;
		struct nand_op_waitrdy_instr waitrdy;
	} ctx;
	unsigned int delay_ns;
};

struct nand_bbt_descr {
	int options;
	int pages[8];
	int offs;
	int veroffs;
	uint8_t version[8];
	int len;
	int maxblocks;
	int reserved_block_code;
	uint8_t *pattern;
};

struct nand_secure_region {
	u64 offset;
	u64 size;
};

struct nand_onfi_params {
	u8 sig[4];
	__le16 revision;
	__le16 features;
	__le16 opt_cmd;
	u8 reserved0[2];
	__le16 ext_param_page_length;
	u8 num_of_param_pages;
	u8 reserved1[17];
	char manufacturer[12];
	char model[20];
	u8 jedec_id;
	__le16 date_code;
	u8 reserved2[13];
	__le32 byte_per_page;
	__le16 spare_bytes_per_page;
	__le32 data_bytes_per_ppage;
	__le16 spare_bytes_per_ppage;
	__le32 pages_per_block;
	__le32 blocks_per_lun;
	u8 lun_count;
	u8 addr_cycles;
	u8 bits_per_cell;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 guaranteed_good_blocks;
	__le16 guaranteed_block_endurance;
	u8 programs_per_page;
	u8 ppage_attr;
	u8 ecc_bits;
	u8 interleaved_bits;
	u8 interleaved_ops;
	u8 reserved3[13];
	u8 io_pin_capacitance_max;
	__le16 sdr_timing_modes;
	__le16 program_cache_timing_mode;
	__le16 t_prog;
	__le16 t_bers;
	__le16 t_r;
	__le16 t_ccs;
	u8 nvddr_timing_modes;
	u8 nvddr2_timing_modes;
	u8 nvddr_nvddr2_features;
	__le16 clk_pin_capacitance_typ;
	__le16 io_pin_capacitance_typ;
	__le16 input_pin_capacitance_typ;
	u8 input_pin_capacitance_max;
	u8 driver_strength_support;
	__le16 t_int_r;
	__le16 t_adl;
	u8 reserved4[8];
	__le16 vendor_revision;
	u8 vendor[88];
	__le16 crc;
} __attribute__((packed));

enum spi_mem_data_dir {
	SPI_MEM_NO_DATA = 0,
	SPI_MEM_DATA_IN = 1,
	SPI_MEM_DATA_OUT = 2,
};

enum spi_nor_protocol {
	SNOR_PROTO_1_1_1 = 65793,
	SNOR_PROTO_1_1_2 = 65794,
	SNOR_PROTO_1_1_4 = 65796,
	SNOR_PROTO_1_1_8 = 65800,
	SNOR_PROTO_1_2_2 = 66050,
	SNOR_PROTO_1_4_4 = 66564,
	SNOR_PROTO_1_8_8 = 67592,
	SNOR_PROTO_2_2_2 = 131586,
	SNOR_PROTO_4_4_4 = 263172,
	SNOR_PROTO_8_8_8 = 526344,
	SNOR_PROTO_1_1_1_DTR = 16843009,
	SNOR_PROTO_1_2_2_DTR = 16843266,
	SNOR_PROTO_1_4_4_DTR = 16843780,
	SNOR_PROTO_1_8_8_DTR = 16844808,
	SNOR_PROTO_8_8_8_DTR = 17303560,
};

enum spi_nor_cmd_ext {
	SPI_NOR_EXT_NONE = 0,
	SPI_NOR_EXT_REPEAT = 1,
	SPI_NOR_EXT_INVERT = 2,
	SPI_NOR_EXT_HEX = 3,
};

struct spi_delay {
	u16 value;
	u8 unit;
};

struct spi_controller;

struct spi_statistics;

struct spi_device {
	struct device dev;
	struct spi_controller *controller;
	struct spi_controller *master;
	u32 max_speed_hz;
	u8 chip_select;
	u8 bits_per_word;
	bool rt;
	u32 mode;
	int irq;
	void *controller_state;
	void *controller_data;
	char modalias[32];
	const char *driver_override;
	struct gpio_desc *cs_gpiod;
	struct spi_delay word_delay;
	struct spi_delay cs_setup;
	struct spi_delay cs_hold;
	struct spi_delay cs_inactive;
	struct spi_statistics __attribute__((btf_type_tag("percpu"))) *pcpu_statistics;
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

struct spi_message;

struct spi_transfer;

struct spi_controller_mem_ops;

struct spi_controller_mem_caps;

struct spi_controller {
	struct device dev;
	struct list_head list;
	s16 bus_num;
	u16 num_chipselect;
	u16 dma_alignment;
	u32 mode_bits;
	u32 buswidth_override_bits;
	u32 bits_per_word_mask;
	u32 min_speed_hz;
	u32 max_speed_hz;
	u16 flags;
	bool devm_allocated;
	union {
		bool slave;
		bool target;
	};
	size_t (*max_transfer_size)(struct spi_device *);
	size_t (*max_message_size)(struct spi_device *);
	struct mutex io_mutex;
	struct mutex add_lock;
	spinlock_t bus_lock_spinlock;
	struct mutex bus_lock_mutex;
	bool bus_lock_flag;
	int (*setup)(struct spi_device *);
	int (*set_cs_timing)(struct spi_device *);
	int (*transfer)(struct spi_device *, struct spi_message *);
	void (*cleanup)(struct spi_device *);
	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	struct device *dma_map_dev;
	struct device *cur_rx_dma_dev;
	struct device *cur_tx_dma_dev;
	bool queued;
	struct kthread_worker *kworker;
	struct kthread_work pump_messages;
	spinlock_t queue_lock;
	struct list_head queue;
	struct spi_message *cur_msg;
	struct completion cur_msg_completion;
	bool cur_msg_incomplete;
	bool cur_msg_need_completion;
	bool busy;
	bool running;
	bool rt;
	bool auto_runtime_pm;
	bool cur_msg_mapped;
	char last_cs;
	bool last_cs_mode_high;
	bool fallback;
	struct completion xfer_completion;
	size_t max_dma_len;
	int (*prepare_transfer_hardware)(struct spi_controller *);
	int (*transfer_one_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_transfer_hardware)(struct spi_controller *);
	int (*prepare_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_message)(struct spi_controller *, struct spi_message *);
	union {
		int (*slave_abort)(struct spi_controller *);
		int (*target_abort)(struct spi_controller *);
	};
	void (*set_cs)(struct spi_device *, bool);
	int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	void (*handle_err)(struct spi_controller *, struct spi_message *);
	const struct spi_controller_mem_ops *mem_ops;
	const struct spi_controller_mem_caps *mem_caps;
	struct gpio_desc **cs_gpiods;
	bool use_gpio_descriptors;
	s8 unused_native_cs;
	s8 max_native_cs;
	struct spi_statistics __attribute__((btf_type_tag("percpu"))) *pcpu_statistics;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	void *dummy_rx;
	void *dummy_tx;
	int (*fw_translate_cs)(struct spi_controller *, unsigned int);
	bool ptp_sts_supported;
	unsigned long irq_flags;
	bool queue_empty;
	bool must_async;
};

struct spi_message {
	struct list_head transfers;
	struct spi_device *spi;
	unsigned int is_dma_mapped: 1;
	bool prepared;
	int status;
	void (*complete)(void *);
	void *context;
	unsigned int frame_length;
	unsigned int actual_length;
	struct list_head queue;
	void *state;
	struct list_head resources;
};

struct ptp_system_timestamp;

struct spi_transfer {
	const void *tx_buf;
	void *rx_buf;
	unsigned int len;
	u16 error;
	dma_addr_t tx_dma;
	dma_addr_t rx_dma;
	struct sg_table tx_sg;
	struct sg_table rx_sg;
	unsigned int dummy_data: 1;
	unsigned int cs_off: 1;
	unsigned int cs_change: 1;
	unsigned int tx_nbits: 3;
	unsigned int rx_nbits: 3;
	unsigned int timestamped: 1;
	u8 bits_per_word;
	struct spi_delay delay;
	struct spi_delay cs_change_delay;
	struct spi_delay word_delay;
	u32 speed_hz;
	u32 effective_speed_hz;
	unsigned int ptp_sts_word_pre;
	unsigned int ptp_sts_word_post;
	struct ptp_system_timestamp *ptp_sts;
	struct list_head transfer_list;
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct spi_mem;

struct spi_mem_op;

struct spi_mem_dirmap_desc;

struct spi_controller_mem_ops {
	int (*adjust_op_size)(struct spi_mem *, struct spi_mem_op *);
	bool (*supports_op)(struct spi_mem *, const struct spi_mem_op *);
	int (*exec_op)(struct spi_mem *, const struct spi_mem_op *);
	const char * (*get_name)(struct spi_mem *);
	int (*dirmap_create)(struct spi_mem_dirmap_desc *);
	void (*dirmap_destroy)(struct spi_mem_dirmap_desc *);
	ssize_t (*dirmap_read)(struct spi_mem_dirmap_desc *, u64, size_t, void *);
	ssize_t (*dirmap_write)(struct spi_mem_dirmap_desc *, u64, size_t, const void *);
	int (*poll_status)(struct spi_mem *, const struct spi_mem_op *, u16, u16, unsigned long, unsigned long, unsigned long);
};

struct spi_mem {
	struct spi_device *spi;
	void *drvpriv;
	const char *name;
};

struct spi_mem_op {
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u8 __pad: 7;
		u16 opcode;
	} cmd;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u8 __pad: 7;
		u64 val;
	} addr;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u8 __pad: 7;
	} dummy;
	struct {
		u8 buswidth;
		u8 dtr: 1;
		u8 ecc: 1;
		u8 __pad: 6;
		enum spi_mem_data_dir dir;
		unsigned int nbytes;
		union {
			void *in;
			const void *out;
		} buf;
	} data;
};

struct spi_mem_dirmap_info {
	struct spi_mem_op op_tmpl;
	u64 offset;
	u64 length;
};

struct spi_mem_dirmap_desc {
	struct spi_mem *mem;
	struct spi_mem_dirmap_info info;
	unsigned int nodirmap;
	void *priv;
};

struct spi_controller_mem_caps {
	bool dtr;
	bool ecc;
};

struct spi_statistics {
	struct u64_stats_sync syncp;
	u64_stats_t messages;
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t timedout;
	u64_stats_t spi_sync;
	u64_stats_t spi_sync_immediate;
	u64_stats_t spi_async;
	u64_stats_t bytes;
	u64_stats_t bytes_rx;
	u64_stats_t bytes_tx;
	u64_stats_t transfer_bytes_histo[17];
	u64_stats_t transfers_split_maxsize;
};

struct spi_nor_rww {
	wait_queue_head_t wait;
	bool ongoing_io;
	bool ongoing_rd;
	bool ongoing_pe;
	unsigned int used_banks;
};

struct flash_info;

struct spi_nor_manufacturer;

struct sfdp;

struct spi_nor_controller_ops;

struct spi_nor_flash_parameter;

struct spi_nor {
	struct mtd_info mtd;
	struct mutex lock;
	struct spi_nor_rww rww;
	struct device *dev;
	struct spi_mem *spimem;
	u8 *bouncebuf;
	size_t bouncebuf_size;
	u8 *id;
	const struct flash_info *info;
	const struct spi_nor_manufacturer *manufacturer;
	u8 addr_nbytes;
	u8 erase_opcode;
	u8 read_opcode;
	u8 read_dummy;
	u8 program_opcode;
	enum spi_nor_protocol read_proto;
	enum spi_nor_protocol write_proto;
	enum spi_nor_protocol reg_proto;
	bool sst_write_second;
	u32 flags;
	enum spi_nor_cmd_ext cmd_ext_type;
	struct sfdp *sfdp;
	struct dentry *debugfs_root;
	const struct spi_nor_controller_ops *controller_ops;
	struct spi_nor_flash_parameter *params;
	struct {
		struct spi_mem_dirmap_desc *rdesc;
		struct spi_mem_dirmap_desc *wdesc;
	} dirmap;
	void *priv;
};

struct spi_nor_id;

struct spi_nor_otp_organization;

struct spi_nor_fixups;

struct flash_info {
	char *name;
	const struct spi_nor_id *id;
	size_t size;
	unsigned int sector_size;
	u16 page_size;
	u8 n_banks;
	u8 addr_nbytes;
	u16 flags;
	u8 no_sfdp_flags;
	u8 fixup_flags;
	u8 mfr_flags;
	const struct spi_nor_otp_organization *otp;
	const struct spi_nor_fixups *fixups;
};

struct spi_nor_id {
	const u8 *bytes;
	u8 len;
};

struct spi_nor_otp_organization {
	size_t len;
	loff_t base;
	loff_t offset;
	unsigned int n_regions;
};

struct sfdp_parameter_header;

struct sfdp_bfpt;

struct spi_nor_fixups {
	void (*default_init)(struct spi_nor *);
	int (*post_bfpt)(struct spi_nor *, const struct sfdp_parameter_header *, const struct sfdp_bfpt *);
	int (*post_sfdp)(struct spi_nor *);
	int (*late_init)(struct spi_nor *);
};

struct sfdp_parameter_header {
	u8 id_lsb;
	u8 minor;
	u8 major;
	u8 length;
	u8 parameter_table_pointer[3];
	u8 id_msb;
};

struct sfdp_bfpt {
	u32 dwords[20];
};

struct spi_nor_manufacturer {
	const char *name;
	const struct flash_info *parts;
	unsigned int nparts;
	const struct spi_nor_fixups *fixups;
};

struct sfdp {
	size_t num_dwords;
	u32 *dwords;
};

struct spi_nor_controller_ops {
	int (*prepare)(struct spi_nor *);
	void (*unprepare)(struct spi_nor *);
	int (*read_reg)(struct spi_nor *, u8, u8 *, size_t);
	int (*write_reg)(struct spi_nor *, u8, const u8 *, size_t);
	ssize_t (*read)(struct spi_nor *, loff_t, size_t, u8 *);
	ssize_t (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
	int (*erase)(struct spi_nor *, loff_t);
};

struct spi_nor_hwcaps {
	u32 mask;
};

struct spi_nor_read_command {
	u8 num_mode_clocks;
	u8 num_wait_states;
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_pp_command {
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_erase_region {
	u64 offset;
	u64 size;
};

struct spi_nor_erase_type {
	u32 size;
	u32 size_shift;
	u32 size_mask;
	u8 opcode;
	u8 idx;
};

struct spi_nor_erase_map {
	struct spi_nor_erase_region *regions;
	struct spi_nor_erase_region uniform_region;
	struct spi_nor_erase_type erase_type[4];
	u8 uniform_erase_type;
};

struct spi_nor_otp_ops;

struct spi_nor_otp {
	const struct spi_nor_otp_organization *org;
	const struct spi_nor_otp_ops *ops;
};

struct spi_nor_locking_ops;

struct spi_nor_flash_parameter {
	u64 bank_size;
	u64 size;
	u32 writesize;
	u32 page_size;
	u8 addr_nbytes;
	u8 addr_mode_nbytes;
	u8 rdsr_dummy;
	u8 rdsr_addr_nbytes;
	u8 n_banks;
	u8 n_dice;
	u32 *vreg_offset;
	struct spi_nor_hwcaps hwcaps;
	struct spi_nor_read_command reads[16];
	struct spi_nor_pp_command page_programs[8];
	struct spi_nor_erase_map erase_map;
	struct spi_nor_otp otp;
	int (*set_octal_dtr)(struct spi_nor *, bool);
	int (*quad_enable)(struct spi_nor *);
	int (*set_4byte_addr_mode)(struct spi_nor *, bool);
	u32 (*convert_addr)(struct spi_nor *, u32);
	int (*setup)(struct spi_nor *, const struct spi_nor_hwcaps *);
	int (*ready)(struct spi_nor *);
	const struct spi_nor_locking_ops *locking_ops;
	void *priv;
};

struct spi_nor_otp_ops {
	int (*read)(struct spi_nor *, loff_t, size_t, u8 *);
	int (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
	int (*lock)(struct spi_nor *, unsigned int);
	int (*erase)(struct spi_nor *, loff_t);
	int (*is_locked)(struct spi_nor *, unsigned int);
};

struct spi_nor_locking_ops {
	int (*lock)(struct spi_nor *, loff_t, uint64_t);
	int (*unlock)(struct spi_nor *, loff_t, uint64_t);
	int (*is_locked)(struct spi_nor *, loff_t, uint64_t);
};

enum {
	MSPI_DONE = 1,
	BSPI_DONE = 2,
	BSPI_ERR = 4,
	MSPI_BSPI_DONE = 7,
};

struct bcm_qspi_soc_intc {
	void (*bcm_qspi_int_ack)(struct bcm_qspi_soc_intc *, int);
	void (*bcm_qspi_int_set)(struct bcm_qspi_soc_intc *, int, bool);
	u32 (*bcm_qspi_get_int_status)(struct bcm_qspi_soc_intc *);
};

struct bcm_iproc_intc {
	struct bcm_qspi_soc_intc soc_intc;
	struct platform_device *pdev;
	void *int_reg;
	void *int_status_reg;
	spinlock_t soclock;
	bool big_endian;
};

struct mtk_chip_config {
	u32 sample_sel;
	u32 tick_delay;
};

struct mtk_spi_compatible {
	bool need_pad_sel;
	bool must_tx;
	bool enhance_timing;
	bool dma_ext;
	bool no_need_unprepare;
	bool ipm_design;
};

struct mtk_spi {
	void *base;
	u32 state;
	int pad_num;
	u32 *pad_sel;
	struct clk *parent_clk;
	struct clk *sel_clk;
	struct clk *spi_clk;
	struct clk *spi_hclk;
	struct spi_transfer *cur_transfer;
	u32 xfer_len;
	u32 num_xfered;
	struct scatterlist *tx_sgl;
	struct scatterlist *rx_sgl;
	u32 tx_sgl_len;
	u32 rx_sgl_len;
	const struct mtk_spi_compatible *dev_comp;
	u32 spi_clk_hz;
	struct completion spimem_done;
	bool use_spimem;
	struct device *dev;
	dma_addr_t tx_dma;
	dma_addr_t rx_dma;
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
};

struct mdio_device;

struct phy_package_shared;

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*read_c45)(struct mii_bus *, int, int, int);
	int (*write_c45)(struct mii_bus *, int, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc *reset_gpiod;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
};

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct phy_package_shared {
	int addr;
	refcount_t refcnt;
	unsigned long flags;
	size_t priv_size;
	void *priv;
};

enum cavium_mdiobus_mode {
	UNINIT = 0,
	C22 = 1,
	C45 = 2,
};

struct cavium_mdiobus {
	struct mii_bus *mii_bus;
	void *register_base;
	enum cavium_mdiobus_mode mode;
};

struct cvmx_smix_clk_s {
	u64 phase: 8;
	u64 sample: 4;
	u64 preamble: 1;
	u64 clk_idle: 1;
	u64 reserved_14_14: 1;
	u64 sample_mode: 1;
	u64 sample_hi: 5;
	u64 reserved_21_23: 3;
	u64 mode: 1;
	u64 reserved_25_63: 39;
};

union cvmx_smix_clk {
	u64 u64;
	struct cvmx_smix_clk_s s;
};

struct cvmx_smix_wr_dat_s {
	u64 dat: 16;
	u64 val: 1;
	u64 pending: 1;
	u64 reserved_18_63: 46;
};

union cvmx_smix_wr_dat {
	u64 u64;
	struct cvmx_smix_wr_dat_s s;
};

struct cvmx_smix_cmd_s {
	u64 reg_adr: 5;
	u64 reserved_5_7: 3;
	u64 phy_adr: 5;
	u64 reserved_13_15: 3;
	u64 phy_op: 2;
	u64 reserved_18_63: 46;
};

union cvmx_smix_cmd {
	u64 u64;
	struct cvmx_smix_cmd_s s;
};

struct cvmx_smix_rd_dat_s {
	u64 dat: 16;
	u64 val: 1;
	u64 pending: 1;
	u64 reserved_18_63: 46;
};

union cvmx_smix_rd_dat {
	u64 u64;
	struct cvmx_smix_rd_dat_s s;
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS = 4,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

enum ethtool_link_ext_substate_module {
	ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY = 1,
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
	ETHTOOL_LINK_EXT_STATE_MODULE = 10,
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		enum ethtool_link_ext_substate_module module;
		u32 __link_ext_substate;
	};
};

struct ethtool_link_ext_stats {
	u64 link_down_events;
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct kernel_ethtool_coalesce {
	u8 use_cqe_mode_tx;
	u8 use_cqe_mode_rx;
	u32 tx_aggr_max_bytes;
	u32 tx_aggr_max_frames;
	u32 tx_aggr_time_usecs;
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct kernel_ethtool_ringparam {
	u32 rx_buf_len;
	u8 tcp_data_split;
	u8 tx_push;
	u8 rx_push;
	u32 cqe_size;
	u32 tx_push_buf_len;
	u32 tx_push_buf_max_len;
};

enum ethtool_mac_stats_src {
	ETHTOOL_MAC_STATS_SRC_AGGREGATE = 0,
	ETHTOOL_MAC_STATS_SRC_EMAC = 1,
	ETHTOOL_MAC_STATS_SRC_PMAC = 2,
};

struct ethtool_pause_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 tx_pause_frames;
			u64 rx_pause_frames;
		};
		struct {
			u64 tx_pause_frames;
			u64 rx_pause_frames;
		} stats;
	};
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64 ring_cookie;
	__u32 location;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 rate_matching;
	__u32 reserved[7];
	__u32 link_mode_masks[0];
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		unsigned long supported[2];
		unsigned long advertising[2];
		unsigned long lp_advertising[2];
	} link_modes;
	u32 lanes;
};

struct ethtool_fec_stat {
	u64 total;
	u64 lanes[8];
};

struct ethtool_fec_stats {
	struct ethtool_fec_stat corrected_blocks;
	struct ethtool_fec_stat uncorrectable_blocks;
	struct ethtool_fec_stat corrected_bits;
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

struct ethtool_module_eeprom {
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
	u8 *data;
};

struct ethtool_eth_phy_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 SymbolErrorDuringCarrier;
		};
		struct {
			u64 SymbolErrorDuringCarrier;
		} stats;
	};
};

struct ethtool_eth_mac_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 FramesTransmittedOK;
			u64 SingleCollisionFrames;
			u64 MultipleCollisionFrames;
			u64 FramesReceivedOK;
			u64 FrameCheckSequenceErrors;
			u64 AlignmentErrors;
			u64 OctetsTransmittedOK;
			u64 FramesWithDeferredXmissions;
			u64 LateCollisions;
			u64 FramesAbortedDueToXSColls;
			u64 FramesLostDueToIntMACXmitError;
			u64 CarrierSenseErrors;
			u64 OctetsReceivedOK;
			u64 FramesLostDueToIntMACRcvError;
			u64 MulticastFramesXmittedOK;
			u64 BroadcastFramesXmittedOK;
			u64 FramesWithExcessiveDeferral;
			u64 MulticastFramesReceivedOK;
			u64 BroadcastFramesReceivedOK;
			u64 InRangeLengthErrors;
			u64 OutOfRangeLengthField;
			u64 FrameTooLongErrors;
		};
		struct {
			u64 FramesTransmittedOK;
			u64 SingleCollisionFrames;
			u64 MultipleCollisionFrames;
			u64 FramesReceivedOK;
			u64 FrameCheckSequenceErrors;
			u64 AlignmentErrors;
			u64 OctetsTransmittedOK;
			u64 FramesWithDeferredXmissions;
			u64 LateCollisions;
			u64 FramesAbortedDueToXSColls;
			u64 FramesLostDueToIntMACXmitError;
			u64 CarrierSenseErrors;
			u64 OctetsReceivedOK;
			u64 FramesLostDueToIntMACRcvError;
			u64 MulticastFramesXmittedOK;
			u64 BroadcastFramesXmittedOK;
			u64 FramesWithExcessiveDeferral;
			u64 MulticastFramesReceivedOK;
			u64 BroadcastFramesReceivedOK;
			u64 InRangeLengthErrors;
			u64 OutOfRangeLengthField;
			u64 FrameTooLongErrors;
		} stats;
	};
};

struct ethtool_eth_ctrl_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 MACControlFramesTransmitted;
			u64 MACControlFramesReceived;
			u64 UnsupportedOpcodesReceived;
		};
		struct {
			u64 MACControlFramesTransmitted;
			u64 MACControlFramesReceived;
			u64 UnsupportedOpcodesReceived;
		} stats;
	};
};

struct ethtool_rmon_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 undersize_pkts;
			u64 oversize_pkts;
			u64 fragments;
			u64 jabbers;
			u64 hist[10];
			u64 hist_tx[10];
		};
		struct {
			u64 undersize_pkts;
			u64 oversize_pkts;
			u64 fragments;
			u64 jabbers;
			u64 hist[10];
			u64 hist_tx[10];
		} stats;
	};
};

struct ethtool_rmon_hist_range {
	u16 low;
	u16 high;
};

enum ethtool_module_power_mode_policy {
	ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH = 1,
	ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO = 2,
};

enum ethtool_module_power_mode {
	ETHTOOL_MODULE_POWER_MODE_LOW = 1,
	ETHTOOL_MODULE_POWER_MODE_HIGH = 2,
};

struct ethtool_module_power_mode_params {
	enum ethtool_module_power_mode_policy policy;
	enum ethtool_module_power_mode mode;
};

enum ethtool_mm_verify_status {
	ETHTOOL_MM_VERIFY_STATUS_UNKNOWN = 0,
	ETHTOOL_MM_VERIFY_STATUS_INITIAL = 1,
	ETHTOOL_MM_VERIFY_STATUS_VERIFYING = 2,
	ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED = 3,
	ETHTOOL_MM_VERIFY_STATUS_FAILED = 4,
	ETHTOOL_MM_VERIFY_STATUS_DISABLED = 5,
};

struct ethtool_mm_state {
	u32 verify_time;
	u32 max_verify_time;
	enum ethtool_mm_verify_status verify_status;
	bool tx_enabled;
	bool tx_active;
	bool pmac_enabled;
	bool verify_enabled;
	u32 tx_min_frag_size;
	u32 rx_min_frag_size;
};

struct ethtool_mm_cfg {
	u32 verify_time;
	bool verify_enabled;
	bool tx_enabled;
	bool pmac_enabled;
	u32 tx_min_frag_size;
};

struct ethtool_mm_stats {
	u64 MACMergeFrameAssErrorCount;
	u64 MACMergeFrameSmdErrorCount;
	u64 MACMergeFrameAssOkCount;
	u64 MACMergeFragCountRx;
	u64 MACMergeFragCountTx;
	u64 MACMergeHoldCount;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_ERROR = 3,
	PHY_UP = 4,
	PHY_RUNNING = 5,
	PHY_NOLINK = 6,
	PHY_CABLETEST = 7,
};

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_REVRMII = 8,
	PHY_INTERFACE_MODE_RGMII = 9,
	PHY_INTERFACE_MODE_RGMII_ID = 10,
	PHY_INTERFACE_MODE_RGMII_RXID = 11,
	PHY_INTERFACE_MODE_RGMII_TXID = 12,
	PHY_INTERFACE_MODE_RTBI = 13,
	PHY_INTERFACE_MODE_SMII = 14,
	PHY_INTERFACE_MODE_XGMII = 15,
	PHY_INTERFACE_MODE_XLGMII = 16,
	PHY_INTERFACE_MODE_MOCA = 17,
	PHY_INTERFACE_MODE_PSGMII = 18,
	PHY_INTERFACE_MODE_QSGMII = 19,
	PHY_INTERFACE_MODE_TRGMII = 20,
	PHY_INTERFACE_MODE_100BASEX = 21,
	PHY_INTERFACE_MODE_1000BASEX = 22,
	PHY_INTERFACE_MODE_2500BASEX = 23,
	PHY_INTERFACE_MODE_5GBASER = 24,
	PHY_INTERFACE_MODE_RXAUI = 25,
	PHY_INTERFACE_MODE_XAUI = 26,
	PHY_INTERFACE_MODE_10GBASER = 27,
	PHY_INTERFACE_MODE_25GBASER = 28,
	PHY_INTERFACE_MODE_USXGMII = 29,
	PHY_INTERFACE_MODE_10GKR = 30,
	PHY_INTERFACE_MODE_QUSGMII = 31,
	PHY_INTERFACE_MODE_1000BASEKX = 32,
	PHY_INTERFACE_MODE_MAX = 33,
} phy_interface_t;

struct pse_control;

struct phy_driver;

struct phylink;

struct mii_timestamper;

struct phy_device {
	struct mdio_device mdio;
	struct phy_driver *drv;
	struct device_link *devlink;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int is_on_sfp_module: 1;
	unsigned int mac_managed_pm: 1;
	unsigned int wol_enabled: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	unsigned int irq_suspended: 1;
	unsigned int irq_rerun: 1;
	int rate_matching;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	int speed;
	int duplex;
	int port;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	unsigned long supported[2];
	unsigned long advertising[2];
	unsigned long lp_advertising[2];
	unsigned long adv_old[2];
	unsigned long supported_eee[2];
	unsigned long advertising_eee[2];
	bool eee_enabled;
	unsigned long host_interfaces[1];
	u32 eee_broken_modes;
	struct list_head leds;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	struct pse_control *psec;
	u8 mdix;
	u8 mdix_ctrl;
	int pma_extable;
	unsigned int link_down_events;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

struct phy_tdr_config;

struct phy_plca_cfg;

struct phy_plca_status;

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const unsigned long * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	int (*get_rate_matching)(struct phy_device *, phy_interface_t);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
	int (*get_plca_cfg)(struct phy_device *, struct phy_plca_cfg *);
	int (*set_plca_cfg)(struct phy_device *, const struct phy_plca_cfg *);
	int (*get_plca_status)(struct phy_device *, struct phy_plca_status *);
	int (*led_brightness_set)(struct phy_device *, u8, enum led_brightness);
	int (*led_blink_set)(struct phy_device *, u8, unsigned long *, unsigned long *);
	int (*led_hw_is_supported)(struct phy_device *, u8, unsigned long);
	int (*led_hw_control_set)(struct phy_device *, u8, unsigned long);
	int (*led_hw_control_get)(struct phy_device *, u8, unsigned long *);
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

struct phy_plca_cfg {
	int version;
	int enabled;
	int node_id;
	int node_cnt;
	int to_tmr;
	int burst_cnt;
	int burst_tmr;
};

struct phy_plca_status {
	bool pst;
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct ifreq *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct ethtool_ts_info *);
	struct device *device;
};

struct bcmasp_priv;

struct bcmasp_intf;

struct bcmasp_hw_info;

struct bcmasp_plat_data {
	void (*init_wol)(struct bcmasp_priv *);
	void (*enable_wol)(struct bcmasp_intf *, bool);
	void (*destroy_wol)(struct bcmasp_priv *);
	struct bcmasp_hw_info *hw_info;
};

struct bcmasp_mda_filter {
	int port;
	bool en;
	u8 addr[6];
	u8 mask[6];
};

struct bcmasp_net_filter {
	struct ethtool_rx_flow_spec fs;
	bool claimed;
	bool wake_filter;
	int port;
	unsigned int hw_index;
};

struct bcmasp_priv {
	struct platform_device *pdev;
	struct clk *clk;
	int irq;
	u32 irq_mask;
	struct mutex wol_lock;
	int wol_irq;
	unsigned long wol_irq_enabled_mask;
	void (*init_wol)(struct bcmasp_priv *);
	void (*enable_wol)(struct bcmasp_intf *, bool);
	void (*destroy_wol)(struct bcmasp_priv *);
	void *base;
	struct bcmasp_hw_info *hw_info;
	struct list_head intfs;
	struct bcmasp_mda_filter mda_filters[32];
	spinlock_t mda_lock;
	spinlock_t clk_lock;
	struct bcmasp_net_filter net_filters[32];
	struct mutex net_lock;
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_struct {
	struct list_head poll_list;
	unsigned long state;
	int weight;
	int defer_hard_irqs_count;
	unsigned long gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	int list_owner;
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	unsigned int napi_id;
	struct hrtimer timer;
	struct task_struct *thread;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
};

struct bcmasp_res {
	void *umac;
	void *umac2fb;
	void *rgmii;
	void *tx_spb_ctrl;
	void *tx_spb_top;
	void *tx_epkt_core;
	void *tx_pause_ctrl;
};

struct bcmasp_intf_stats64 {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t rx_errors;
	u64_stats_t rx_dropped;
	u64_stats_t rx_crc_errs;
	u64_stats_t rx_sym_errs;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
};

struct bcmasp_mib_counters {
	u32 edpkt_ts;
	u32 edpkt_rx_pkt_cnt;
	u32 edpkt_hdr_ext_cnt;
	u32 edpkt_hdr_out_cnt;
	u32 umac_frm_cnt;
	u32 fb_frm_cnt;
	u32 fb_rx_fifo_depth;
	u32 fb_out_frm_cnt;
	u32 fb_filt_out_frm_cnt;
	u32 alloc_rx_skb_failed;
	u32 tx_dma_failed;
	u32 mc_filters_full_cnt;
	u32 uc_filters_full_cnt;
	u32 filters_combine_cnt;
	u32 promisc_filters_cnt;
	u32 tx_realloc_offload_failed;
	u32 tx_timeout_cnt;
};

struct bcmasp_intf_ops;

struct bcmasp_desc;

struct bcmasp_tx_cb;

struct bcmasp_intf {
	struct list_head list;
	struct net_device *ndev;
	struct bcmasp_priv *parent;
	int channel;
	int port;
	const struct bcmasp_intf_ops *ops;
	int index;
	struct napi_struct tx_napi;
	void *tx_spb_dma;
	int tx_spb_index;
	int tx_spb_clean_index;
	struct bcmasp_desc *tx_spb_cpu;
	dma_addr_t tx_spb_dma_addr;
	dma_addr_t tx_spb_dma_valid;
	dma_addr_t tx_spb_dma_read;
	struct bcmasp_tx_cb *tx_cbs;
	void *rx_edpkt_cfg;
	void *rx_edpkt_dma;
	int rx_edpkt_index;
	int rx_buf_order;
	struct bcmasp_desc *rx_edpkt_cpu;
	dma_addr_t rx_edpkt_dma_addr;
	dma_addr_t rx_edpkt_dma_read;
	void *rx_ring_cpu;
	dma_addr_t rx_ring_dma;
	dma_addr_t rx_ring_dma_valid;
	struct napi_struct rx_napi;
	struct bcmasp_res res;
	unsigned int crc_fwd;
	struct device_node *phy_dn;
	struct device_node *ndev_dn;
	phy_interface_t phy_interface;
	bool internal_phy;
	int old_pause;
	int old_link;
	int old_duplex;
	u32 msg_enable;
	struct bcmasp_intf_stats64 stats64;
	struct bcmasp_mib_counters mib;
	u32 wolopts;
	u8 sopass[6];
	int wol_irq;
	unsigned int wol_irq_enabled: 1;
	struct ethtool_eee eee;
};

struct bcmasp_intf_ops {
	unsigned long (*rx_desc_read)(struct bcmasp_intf *);
	void (*rx_buffer_write)(struct bcmasp_intf *, dma_addr_t);
	void (*rx_desc_write)(struct bcmasp_intf *, dma_addr_t);
	unsigned long (*tx_read)(struct bcmasp_intf *);
	void (*tx_write)(struct bcmasp_intf *, dma_addr_t);
};

struct bcmasp_desc {
	u64 buf;
	u32 size;
	u32 flags;
};

struct bcmasp_tx_cb {
	struct sk_buff *skb;
	unsigned int bytes_sent;
	bool last;
	dma_addr_t dma_addr;
	__u32 dma_len;
};

struct bcmasp_hw_info {
	u32 rx_ctrl_flush;
	u32 umac2fb;
	u32 rx_ctrl_fb_out_frame_count;
	u32 rx_ctrl_fb_filt_out_frame_count;
	u32 rx_ctrl_fb_rx_fifo_depth;
};

enum asp_rx_filter_id {
	ASP_RX_FILTER_MDA_PROMISC = 0,
	ASP_RX_FILTER_MDA_ALLMULTI = 1,
	ASP_RX_FILTER_MDA_BROADCAST = 2,
	ASP_RX_FILTER_MDA_OWN_ADDR = 3,
	ASP_RX_FILTER_MDA_RES_MAX = 4,
};

enum asp_netfilt_reg_type {
	ASP_NETFILT_MATCH = 0,
	ASP_NETFILT_MASK = 1,
	ASP_NETFILT_MAX = 2,
};

enum asp_rx_net_filter_block {
	ASP_RX_FILTER_NET_L2 = 0,
	ASP_RX_FILTER_NET_L3_0 = 1,
	ASP_RX_FILTER_NET_L3_1 = 2,
	ASP_RX_FILTER_NET_L4 = 3,
	ASP_RX_FILTER_NET_BLOCK_MAX = 4,
};

struct of_dev_auxdata {
	char *compatible;
	resource_size_t phys_addr;
	char *name;
	void *platform_data;
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
	DEVLINK_PORT_FLAVOUR_PCI_SF = 7,
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_pci_sf_attrs {
	u32 controller;
	u32 sf;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
		struct devlink_port_pci_sf_attrs pci_sf;
	};
};

struct devlink;

struct devlink_port_ops;

struct ib_device;

struct devlink_rate;

struct devlink_linecard;

struct devlink_port {
	struct list_head list;
	struct list_head region_list;
	struct devlink *devlink;
	const struct devlink_port_ops *ops;
	unsigned int index;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	union {
		struct {
			struct net_device *netdev;
			int ifindex;
			char ifname[16];
		} type_eth;
		struct {
			struct ib_device *ibdev;
		} type_ib;
	};
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	u8 registered: 1;
	u8 initialized: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct devlink_rate *devlink_rate;
	struct devlink_linecard *linecard;
	u32 rel_index;
};

enum devlink_port_fn_state {
	DEVLINK_PORT_FN_STATE_INACTIVE = 0,
	DEVLINK_PORT_FN_STATE_ACTIVE = 1,
};

enum devlink_port_fn_opstate {
	DEVLINK_PORT_FN_OPSTATE_DETACHED = 0,
	DEVLINK_PORT_FN_OPSTATE_ATTACHED = 1,
};

struct devlink_port_ops {
	int (*port_split)(struct devlink *, struct devlink_port *, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_del)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
	int (*port_fn_hw_addr_get)(struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_fn_hw_addr_set)(struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
	int (*port_fn_roce_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_roce_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_migratable_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_migratable_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_state_get)(struct devlink_port *, enum devlink_port_fn_state *, enum devlink_port_fn_opstate *, struct netlink_ext_ack *);
	int (*port_fn_state_set)(struct devlink_port *, enum devlink_port_fn_state, struct netlink_ext_ack *);
	int (*port_fn_ipsec_crypto_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_ipsec_crypto_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_ipsec_packet_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_ipsec_packet_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
};

enum devlink_rate_type {
	DEVLINK_RATE_TYPE_LEAF = 0,
	DEVLINK_RATE_TYPE_NODE = 1,
};

struct devlink_rate {
	struct list_head list;
	enum devlink_rate_type type;
	struct devlink *devlink;
	void *priv;
	u64 tx_share;
	u64 tx_max;
	struct devlink_rate *parent;
	union {
		struct devlink_port *devlink_port;
		struct {
			char *name;
			refcount_t refcnt;
		};
	};
	u32 tx_priority;
	u32 tx_weight;
};

enum dpaa2_eth_fq_type {
	DPAA2_RX_FQ = 0,
	DPAA2_TX_CONF_FQ = 1,
	DPAA2_RX_ERR_FQ = 2,
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

enum dpmac_eth_if {
	DPMAC_ETH_IF_MII = 0,
	DPMAC_ETH_IF_RMII = 1,
	DPMAC_ETH_IF_SMII = 2,
	DPMAC_ETH_IF_GMII = 3,
	DPMAC_ETH_IF_RGMII = 4,
	DPMAC_ETH_IF_SGMII = 5,
	DPMAC_ETH_IF_QSGMII = 6,
	DPMAC_ETH_IF_XAUI = 7,
	DPMAC_ETH_IF_XFI = 8,
	DPMAC_ETH_IF_CAUI = 9,
	DPMAC_ETH_IF_1000BASEX = 10,
	DPMAC_ETH_IF_USXGMII = 11,
};

enum dpmac_link_type {
	DPMAC_LINK_TYPE_NONE = 0,
	DPMAC_LINK_TYPE_FIXED = 1,
	DPMAC_LINK_TYPE_PHY = 2,
	DPMAC_LINK_TYPE_BACKPLANE = 3,
};

enum phylink_op_type {
	PHYLINK_NETDEV = 0,
	PHYLINK_DEV = 1,
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_STATS_STD = 16,
	ETH_SS_STATS_ETH_PHY = 17,
	ETH_SS_STATS_ETH_MAC = 18,
	ETH_SS_STATS_ETH_CTRL = 19,
	ETH_SS_STATS_RMON = 20,
	ETH_SS_COUNT = 21,
};

enum net_prot {
	NET_PROT_NONE = 0,
	NET_PROT_PAYLOAD = 1,
	NET_PROT_ETH = 2,
	NET_PROT_VLAN = 3,
	NET_PROT_IPV4 = 4,
	NET_PROT_IPV6 = 5,
	NET_PROT_IP = 6,
	NET_PROT_TCP = 7,
	NET_PROT_UDP = 8,
	NET_PROT_UDP_LITE = 9,
	NET_PROT_IPHC = 10,
	NET_PROT_SCTP = 11,
	NET_PROT_SCTP_CHUNK_DATA = 12,
	NET_PROT_PPPOE = 13,
	NET_PROT_PPP = 14,
	NET_PROT_PPPMUX = 15,
	NET_PROT_PPPMUX_SUBFRM = 16,
	NET_PROT_L2TPV2 = 17,
	NET_PROT_L2TPV3_CTRL = 18,
	NET_PROT_L2TPV3_SESS = 19,
	NET_PROT_LLC = 20,
	NET_PROT_LLC_SNAP = 21,
	NET_PROT_NLPID = 22,
	NET_PROT_SNAP = 23,
	NET_PROT_MPLS = 24,
	NET_PROT_IPSEC_AH = 25,
	NET_PROT_IPSEC_ESP = 26,
	NET_PROT_UDP_ENC_ESP = 27,
	NET_PROT_MACSEC = 28,
	NET_PROT_GRE = 29,
	NET_PROT_MINENCAP = 30,
	NET_PROT_DCCP = 31,
	NET_PROT_ICMP = 32,
	NET_PROT_IGMP = 33,
	NET_PROT_ARP = 34,
	NET_PROT_CAPWAP_DATA = 35,
	NET_PROT_CAPWAP_CTRL = 36,
	NET_PROT_RFC2684 = 37,
	NET_PROT_ICMPV6 = 38,
	NET_PROT_FCOE = 39,
	NET_PROT_FIP = 40,
	NET_PROT_ISCSI = 41,
	NET_PROT_GTP = 42,
	NET_PROT_USER_DEFINED_L2 = 43,
	NET_PROT_USER_DEFINED_L3 = 44,
	NET_PROT_USER_DEFINED_L4 = 45,
	NET_PROT_USER_DEFINED_L5 = 46,
	NET_PROT_USER_DEFINED_SHIM1 = 47,
	NET_PROT_USER_DEFINED_SHIM2 = 48,
	NET_PROT_DUMMY_LAST = 49,
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_BIND_PHC = 32768,
	SOF_TIMESTAMPING_OPT_ID_TCP = 65536,
	SOF_TIMESTAMPING_LAST = 65536,
	SOF_TIMESTAMPING_MASK = 131071,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	ETHTOOL_TX_COPYBREAK_BUF_SIZE = 4,
	__ETHTOOL_TUNABLE_COUNT = 5,
};

struct dpaa2_eth_drv_stats {
	__u64 tx_conf_frames;
	__u64 tx_conf_bytes;
	__u64 tx_sg_frames;
	__u64 tx_sg_bytes;
	__u64 tx_tso_frames;
	__u64 tx_tso_bytes;
	__u64 rx_sg_frames;
	__u64 rx_sg_bytes;
	__u64 tx_converted_sg_frames;
	__u64 tx_converted_sg_bytes;
	__u64 tx_portal_busy;
};

struct dpaa2_eth_priv;

struct dpaa2_eth_channel;

struct dpaa2_fd;

struct dpaa2_eth_fq;

typedef void dpaa2_eth_consume_cb_t(struct dpaa2_eth_priv *, struct dpaa2_eth_channel *, const struct dpaa2_fd *, struct dpaa2_eth_fq *);

struct dpaa2_eth_fq_stats {
	__u64 frames;
};

struct dpaa2_fd_simple {
	__le64 addr;
	__le32 len;
	__le16 bpid;
	__le16 format_offset;
	__le32 frc;
	__le32 ctrl;
	__le64 flc;
};

struct dpaa2_fd {
	union {
		u32 words[8];
		struct dpaa2_fd_simple simple;
	};
};

struct dpaa2_eth_xdp_fds {
	struct dpaa2_fd fds[16];
	ssize_t num;
};

struct dpaa2_eth_fq {
	u32 fqid;
	u32 tx_qdbin;
	u32 tx_fqid[8];
	u16 flowid;
	u8 tc;
	int target_cpu;
	u32 dq_frames;
	u32 dq_bytes;
	struct dpaa2_eth_channel *channel;
	enum dpaa2_eth_fq_type type;
	dpaa2_eth_consume_cb_t *consume;
	struct dpaa2_eth_fq_stats stats;
	struct dpaa2_eth_xdp_fds xdp_redirect_fds;
	struct dpaa2_eth_xdp_fds xdp_tx_fds;
};

struct dpni_attr {
	u32 options;
	u8 num_queues;
	u8 num_tcs;
	u8 mac_filter_entries;
	u8 vlan_filter_entries;
	u8 qos_entries;
	u16 fs_entries;
	u8 qos_key_size;
	u8 fs_key_size;
	u16 wriop_version;
};

struct dpni_link_state {
	u32 rate;
	u64 options;
	int up;
};

struct dpaa2_debugfs {
	struct dentry *dir;
};

struct dpaa2_eth_sgt_cache;

struct dpaa2_eth_bp;

struct dpaa2_eth_cls_rule;

struct dpaa2_mac;

struct dpaa2_eth_trap_data;

struct dpaa2_eth_fds;

struct dpaa2_eth_priv {
	struct net_device *net_dev;
	u8 num_fqs;
	struct dpaa2_eth_fq fq[145];
	int (*enqueue)(struct dpaa2_eth_priv *, struct dpaa2_eth_fq *, struct dpaa2_fd *, u8, u32, int *);
	u8 num_channels;
	struct dpaa2_eth_channel *channel[16];
	struct dpaa2_eth_sgt_cache __attribute__((btf_type_tag("percpu"))) *sgt_cache;
	unsigned long features;
	struct dpni_attr dpni_attrs;
	u16 dpni_ver_major;
	u16 dpni_ver_minor;
	u16 tx_data_offset;
	void *onestep_reg_base;
	u8 ptp_correction_off;
	void (*dpaa2_set_onestep_params_cb)(struct dpaa2_eth_priv *, u32, u8);
	u16 rx_buf_size;
	struct iommu_domain *iommu_domain;
	enum hwtstamp_tx_types tx_tstamp_type;
	bool rx_tstamp;
	struct dpaa2_eth_bp *bp[9];
	int num_bps;
	u16 tx_qdid;
	struct fsl_mc_io *mc_io;
	struct cpumask dpio_cpumask;
	struct rtnl_link_stats64 __attribute__((btf_type_tag("percpu"))) *percpu_stats;
	struct dpaa2_eth_drv_stats __attribute__((btf_type_tag("percpu"))) *percpu_extras;
	u16 mc_token;
	u8 rx_fqtd_enabled;
	u8 rx_cgtd_enabled;
	struct dpni_link_state link_state;
	bool do_link_poll;
	struct task_struct *poll_thread;
	u64 rx_hash_fields;
	u64 rx_cls_fields;
	struct dpaa2_eth_cls_rule *cls_rules;
	u8 rx_cls_enabled;
	u8 vlan_cls_enabled;
	u8 pfc_enabled;
	struct bpf_prog *xdp_prog;
	struct dpaa2_debugfs dbg;
	struct dpaa2_mac *mac;
	struct mutex mac_lock;
	struct workqueue_struct *dpaa2_ptp_wq;
	struct work_struct tx_onestep_tstamp;
	struct sk_buff_head tx_skbs;
	struct mutex onestep_tstamp_lock;
	struct devlink *devlink;
	struct dpaa2_eth_trap_data *trap_data;
	struct devlink_port devlink_port;
	u32 rx_copybreak;
	struct dpaa2_eth_fds __attribute__((btf_type_tag("percpu"))) *fd;
};

struct dpaa2_io_notification_ctx {
	void (*cb)(struct dpaa2_io_notification_ctx *);
	int is_cdan;
	u32 id;
	int desired_cpu;
	int dpio_id;
	u64 qman64;
	struct list_head node;
	void *dpio_private;
};

struct dpaa2_eth_ch_stats {
	__u64 dequeue_portal_busy;
	__u64 pull_err;
	__u64 cdan;
	__u64 xdp_drop;
	__u64 xdp_tx;
	__u64 xdp_tx_err;
	__u64 xdp_redirect;
	__u64 frames;
	__u64 frames_per_cdan;
	__u64 bytes_per_cdan;
};

struct dpaa2_eth_ch_xdp {
	struct bpf_prog *prog;
	unsigned int res;
};

struct dpaa2_io;

struct dpaa2_io_store;

struct dpaa2_eth_channel {
	struct dpaa2_io_notification_ctx nctx;
	struct fsl_mc_device *dpcon;
	int dpcon_id;
	int ch_id;
	struct napi_struct napi;
	struct dpaa2_io *dpio;
	struct dpaa2_io_store *store;
	struct dpaa2_eth_priv *priv;
	int buf_count;
	struct dpaa2_eth_ch_stats stats;
	struct dpaa2_eth_ch_xdp xdp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct list_head *rx_list;
	u64 recycled_bufs[7];
	int recycled_bufs_cnt;
	bool xsk_zc;
	int xsk_tx_pkts_sent;
	struct xsk_buff_pool *xsk_pool;
	struct dpaa2_eth_bp *bp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dpaa2_eth_bp {
	struct fsl_mc_device *dev;
	int bpid;
};

struct dpaa2_eth_sgt_cache {
	void *buf[256];
	u16 count;
};

struct dpaa2_eth_cls_rule {
	struct ethtool_rx_flow_spec fs;
	u8 in_use;
};

struct dpmac_link_state {
	u32 rate;
	u64 options;
	int up;
	int state_valid;
	u64 supported;
	u64 advertising;
};

struct dpmac_attr {
	u16 id;
	u32 max_rate;
	enum dpmac_eth_if eth_if;
	enum dpmac_link_type link_type;
};

struct phylink_link_state;

struct phylink_config {
	struct device *dev;
	enum phylink_op_type type;
	bool poll_fixed_state;
	bool mac_managed_pm;
	bool ovr_an_inband;
	void (*get_fixed_state)(struct phylink_config *, struct phylink_link_state *);
	unsigned long supported_interfaces[1];
	unsigned long mac_capabilities;
};

struct phylink_pcs;

struct dpaa2_mac {
	struct fsl_mc_device *mc_dev;
	struct dpmac_link_state state;
	struct net_device *net_dev;
	struct fsl_mc_io *mc_io;
	struct dpmac_attr attr;
	u16 ver_major;
	u16 ver_minor;
	unsigned long features;
	struct phylink_config phylink_config;
	struct phylink *phylink;
	phy_interface_t if_mode;
	enum dpmac_link_type if_link_type;
	struct phylink_pcs *pcs;
	struct fwnode_handle *fw_node;
	struct phy *serdes_phy;
};

struct phylink_link_state {
	unsigned long advertising[2];
	unsigned long lp_advertising[2];
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	int rate_matching;
	unsigned int link: 1;
	unsigned int an_complete: 1;
};

struct phylink_pcs_ops;

struct phylink_pcs {
	const struct phylink_pcs_ops *ops;
	struct phylink *phylink;
	bool neg_mode;
	bool poll;
};

struct phylink_pcs_ops {
	int (*pcs_validate)(struct phylink_pcs *, unsigned long *, const struct phylink_link_state *);
	int (*pcs_enable)(struct phylink_pcs *);
	void (*pcs_disable)(struct phylink_pcs *);
	void (*pcs_pre_config)(struct phylink_pcs *, phy_interface_t);
	int (*pcs_post_config)(struct phylink_pcs *, phy_interface_t);
	void (*pcs_get_state)(struct phylink_pcs *, struct phylink_link_state *);
	int (*pcs_config)(struct phylink_pcs *, unsigned int, phy_interface_t, const unsigned long *, bool);
	void (*pcs_an_restart)(struct phylink_pcs *);
	void (*pcs_link_up)(struct phylink_pcs *, unsigned int, phy_interface_t, int, int);
};

struct dpaa2_eth_trap_item;

struct dpaa2_eth_trap_data {
	struct dpaa2_eth_trap_item *trap_items_arr;
	struct dpaa2_eth_priv *priv;
};

struct dpaa2_eth_trap_item {
	void *trap_ctx;
};

struct dpaa2_eth_fds {
	struct dpaa2_fd array[256];
};

struct dpni_link_cfg {
	u32 rate;
	u64 options;
};

union dpni_statistics {
	struct {
		u64 ingress_all_frames;
		u64 ingress_all_bytes;
		u64 ingress_multicast_frames;
		u64 ingress_multicast_bytes;
		u64 ingress_broadcast_frames;
		u64 ingress_broadcast_bytes;
	} page_0;
	struct {
		u64 egress_all_frames;
		u64 egress_all_bytes;
		u64 egress_multicast_frames;
		u64 egress_multicast_bytes;
		u64 egress_broadcast_frames;
		u64 egress_broadcast_bytes;
	} page_1;
	struct {
		u64 ingress_filtered_frames;
		u64 ingress_discarded_frames;
		u64 ingress_nobuffer_discards;
		u64 egress_discarded_frames;
		u64 egress_confirmed_frames;
	} page_2;
	struct {
		u64 egress_dequeue_bytes;
		u64 egress_dequeue_frames;
		u64 egress_reject_bytes;
		u64 egress_reject_frames;
	} page_3;
	struct {
		u64 cgr_reject_frames;
		u64 cgr_reject_bytes;
	} page_4;
	struct {
		u64 policer_cnt_red;
		u64 policer_cnt_yellow;
		u64 policer_cnt_green;
		u64 policer_cnt_re_red;
		u64 policer_cnt_re_yellow;
	} page_5;
	struct {
		u64 tx_pending_frames;
	} page_6;
	struct {
		u64 counter[7];
	} raw;
};

struct dpni_rule_cfg {
	u64 key_iova;
	u64 mask_iova;
	u8 key_size;
};

struct dpni_fs_action_cfg {
	u64 flc;
	u16 flow_id;
	u16 options;
};

enum hnae_port_type {
	HNAE_PORT_SERVICE = 0,
	HNAE_PORT_DEBUG = 1,
};

enum hnae_media_type {
	HNAE_MEDIA_TYPE_UNKNOWN = 0,
	HNAE_MEDIA_TYPE_FIBER = 1,
	HNAE_MEDIA_TYPE_COPPER = 2,
	HNAE_MEDIA_TYPE_BACKPLANE = 3,
};

enum hnae_loop {
	MAC_INTERNALLOOP_MAC = 0,
	MAC_INTERNALLOOP_SERDES = 1,
	MAC_INTERNALLOOP_PHY = 2,
	MAC_LOOP_PHY_NONE = 3,
	MAC_LOOP_NONE = 4,
};

enum hnae_led_state {
	HNAE_LED_INACTIVE = 0,
	HNAE_LED_ACTIVE = 1,
	HNAE_LED_ON = 2,
	HNAE_LED_OFF = 3,
};

enum dsaf_mode {
	DSAF_MODE_INVALID = 0,
	DSAF_MODE_ENABLE_FIX = 1,
	DSAF_MODE_ENABLE_0VM = 2,
	DSAF_MODE_ENABLE_8VM = 3,
	DSAF_MODE_ENABLE_16VM = 4,
	DSAF_MODE_ENABLE_32VM = 5,
	DSAF_MODE_ENABLE_128VM = 6,
	DSAF_MODE_ENABLE = 7,
	DSAF_MODE_DISABLE_SP = 8,
	DSAF_MODE_DISABLE_FIX = 9,
	DSAF_MODE_DISABLE_2PORT_8VM = 10,
	DSAF_MODE_DISABLE_2PORT_16VM = 11,
	DSAF_MODE_DISABLE_2PORT_64VM = 12,
	DSAF_MODE_DISABLE_6PORT_0VM = 13,
	DSAF_MODE_DISABLE_6PORT_2VM = 14,
	DSAF_MODE_DISABLE_6PORT_4VM = 15,
	DSAF_MODE_DISABLE_6PORT_16VM = 16,
	DSAF_MODE_MAX = 17,
};

enum hal_dsaf_mode {
	HRD_DSAF_NO_DSAF_MODE = 0,
	HRD_DSAF_MODE = 1,
};

enum hal_dsaf_tc_mode {
	HRD_DSAF_4TC_MODE = 0,
	HRD_DSAF_8TC_MODE = 1,
};

enum ppe_common_mode {
	PPE_COMMON_MODE_DEBUG = 0,
	PPE_COMMON_MODE_SERVICE = 1,
	PPE_COMMON_MODE_MAX = 2,
};

enum ppe_qid_mode {
	PPE_QID_MODE0 = 0,
	PPE_QID_MODE1 = 1,
	PPE_QID_MODE2 = 2,
	PPE_QID_MODE3 = 3,
	PPE_QID_MODE4 = 4,
	PPE_QID_MODE5 = 5,
	PPE_QID_MODE6 = 6,
	PPE_QID_MODE7 = 7,
	PPE_QID_MODE8 = 8,
	PPE_QID_MODE9 = 9,
	PPE_QID_MODE10 = 10,
	PPE_QID_MODE11 = 11,
};

enum ppe_port_mode {
	PPE_MODE_GE = 0,
	PPE_MODE_XGE = 1,
};

struct hns_ppe_hw_stats {
	u64 rx_pkts_from_sw;
	u64 rx_pkts;
	u64 rx_drop_no_bd;
	u64 rx_alloc_buf_fail;
	u64 rx_alloc_buf_wait;
	u64 rx_drop_no_buf;
	u64 rx_err_fifo_full;
	u64 tx_bd_form_rcb;
	u64 tx_pkts_from_rcb;
	u64 tx_pkts;
	u64 tx_err_fifo_empty;
	u64 tx_err_checksum;
};

struct ppe_common_cb;

struct hns_ppe_cb {
	struct device *dev;
	struct hns_ppe_cb *next;
	struct ppe_common_cb *ppe_common_cb;
	struct hns_ppe_hw_stats hw_stats;
	u8 index;
	u8 *io_base;
	int virq;
	u32 rss_indir_table[256];
	u32 rss_key[10];
};

struct dsaf_device;

struct ppe_common_cb {
	struct device *dev;
	struct dsaf_device *dsaf_dev;
	u8 *io_base;
	enum ppe_common_mode ppe_mode;
	u8 comm_index;
	u32 ppe_num;
	struct hns_ppe_cb ppe_cb[0];
};

struct hnae_ae_ops;

struct hnae_ae_dev {
	struct device cls_dev;
	struct device *dev;
	struct hnae_ae_ops *ops;
	struct list_head node;
	struct module *owner;
	int id;
	char name[16];
	struct list_head handle_list;
	spinlock_t lock;
};

struct dsaf_hw_stats {
	u64 pad_drop;
	u64 man_pkts;
	u64 rx_pkts;
	u64 rx_pkt_id;
	u64 rx_pause_frame;
	u64 release_buf_num;
	u64 sbm_drop;
	u64 crc_false;
	u64 bp_drop;
	u64 rslt_drop;
	u64 local_addr_false;
	u64 vlan_drop;
	u64 stp_drop;
	u64 rx_pfc[8];
	u64 tx_pfc[8];
	u64 tx_pkts;
};

struct dsaf_int_xge_src {
	u32 xid_xge_ecc_err_int_src;
	u32 xid_xge_fsm_timout_int_src;
	u32 sbm_xge_lnk_fsm_timout_int_src;
	u32 sbm_xge_lnk_ecc_2bit_int_src;
	u32 sbm_xge_mib_req_failed_int_src;
	u32 sbm_xge_mib_req_fsm_timout_int_src;
	u32 sbm_xge_mib_rels_fsm_timout_int_src;
	u32 sbm_xge_sram_ecc_2bit_int_src;
	u32 sbm_xge_mib_buf_sum_err_int_src;
	u32 sbm_xge_mib_req_extra_int_src;
	u32 sbm_xge_mib_rels_extra_int_src;
	u32 voq_xge_start_to_over_0_int_src;
	u32 voq_xge_start_to_over_1_int_src;
	u32 voq_xge_ecc_err_int_src;
};

struct dsaf_int_ppe_src {
	u32 xid_ppe_fsm_timout_int_src;
	u32 sbm_ppe_lnk_fsm_timout_int_src;
	u32 sbm_ppe_lnk_ecc_2bit_int_src;
	u32 sbm_ppe_mib_req_failed_int_src;
	u32 sbm_ppe_mib_req_fsm_timout_int_src;
	u32 sbm_ppe_mib_rels_fsm_timout_int_src;
	u32 sbm_ppe_sram_ecc_2bit_int_src;
	u32 sbm_ppe_mib_buf_sum_err_int_src;
	u32 sbm_ppe_mib_req_extra_int_src;
	u32 sbm_ppe_mib_rels_extra_int_src;
	u32 voq_ppe_start_to_over_0_int_src;
	u32 voq_ppe_ecc_err_int_src;
	u32 xod_ppe_fifo_rd_empty_int_src;
	u32 xod_ppe_fifo_wr_full_int_src;
};

struct dsaf_int_rocee_src {
	u32 xid_rocee_fsm_timout_int_src;
	u32 sbm_rocee_lnk_fsm_timout_int_src;
	u32 sbm_rocee_lnk_ecc_2bit_int_src;
	u32 sbm_rocee_mib_req_failed_int_src;
	u32 sbm_rocee_mib_req_fsm_timout_int_src;
	u32 sbm_rocee_mib_rels_fsm_timout_int_src;
	u32 sbm_rocee_sram_ecc_2bit_int_src;
	u32 sbm_rocee_mib_buf_sum_err_int_src;
	u32 sbm_rocee_mib_req_extra_int_src;
	u32 sbm_rocee_mib_rels_extra_int_src;
	u32 voq_rocee_start_to_over_0_int_src;
	u32 voq_rocee_ecc_err_int_src;
};

struct dsaf_int_tbl_src {
	u32 tbl_da0_mis_src;
	u32 tbl_da1_mis_src;
	u32 tbl_da2_mis_src;
	u32 tbl_da3_mis_src;
	u32 tbl_da4_mis_src;
	u32 tbl_da5_mis_src;
	u32 tbl_da6_mis_src;
	u32 tbl_da7_mis_src;
	u32 tbl_sa_mis_src;
	u32 tbl_old_sech_end_src;
	u32 lram_ecc_err1_src;
	u32 lram_ecc_err2_src;
	u32 tram_ecc_err1_src;
	u32 tram_ecc_err2_src;
	u32 tbl_ucast_bcast_xge0_src;
	u32 tbl_ucast_bcast_xge1_src;
	u32 tbl_ucast_bcast_xge2_src;
	u32 tbl_ucast_bcast_xge3_src;
	u32 tbl_ucast_bcast_xge4_src;
	u32 tbl_ucast_bcast_xge5_src;
	u32 tbl_ucast_bcast_ppe_src;
	u32 tbl_ucast_bcast_rocee_src;
};

struct dsaf_int_stat {
	struct dsaf_int_xge_src dsaf_int_xge_stat[6];
	struct dsaf_int_ppe_src dsaf_int_ppe_stat[6];
	struct dsaf_int_rocee_src dsaf_int_rocee_stat[6];
	struct dsaf_int_tbl_src dsaf_int_tbl_stat[1];
};

struct rcb_common_cb;

struct hns_mac_cb;

struct dsaf_misc_op;

struct dsaf_device {
	struct device *dev;
	struct hnae_ae_dev ae_dev;
	u8 *sc_base;
	u8 *sds_base;
	u8 *ppe_base;
	u8 *io_base;
	struct regmap *sub_ctrl;
	phys_addr_t ppe_paddr;
	u32 desc_num;
	u32 buf_size;
	u32 reset_offset;
	int buf_size_type;
	enum dsaf_mode dsaf_mode;
	enum hal_dsaf_mode dsaf_en;
	enum hal_dsaf_tc_mode dsaf_tc_mode;
	u32 dsaf_ver;
	u16 tcam_max_num;
	struct ppe_common_cb *ppe_common[1];
	struct rcb_common_cb *rcb_common[1];
	struct hns_mac_cb *mac_cb[6];
	struct dsaf_misc_op *misc_op;
	struct dsaf_hw_stats hw_stats[18];
	struct dsaf_int_stat int_stat;
	spinlock_t tcam_lock;
};

struct hnae_handle;

struct hnae_queue;

struct hnae_ring;

struct hnae_ae_ops {
	struct hnae_handle * (*get_handle)(struct hnae_ae_dev *, u32);
	void (*put_handle)(struct hnae_handle *);
	void (*init_queue)(struct hnae_queue *);
	void (*fini_queue)(struct hnae_queue *);
	int (*start)(struct hnae_handle *);
	void (*stop)(struct hnae_handle *);
	void (*reset)(struct hnae_handle *);
	int (*set_opts)(struct hnae_handle *, int, void *);
	int (*get_opts)(struct hnae_handle *, int, void **);
	int (*get_status)(struct hnae_handle *);
	int (*get_info)(struct hnae_handle *, u8 *, u16 *, u8 *);
	void (*toggle_ring_irq)(struct hnae_ring *, u32);
	void (*adjust_link)(struct hnae_handle *, int, int);
	bool (*need_adjust_link)(struct hnae_handle *, int, int);
	int (*set_loopback)(struct hnae_handle *, enum hnae_loop, int);
	void (*get_ring_bdnum_limit)(struct hnae_queue *, u32 *);
	void (*get_pauseparam)(struct hnae_handle *, u32 *, u32 *, u32 *);
	int (*set_pauseparam)(struct hnae_handle *, u32, u32, u32);
	void (*get_coalesce_usecs)(struct hnae_handle *, u32 *, u32 *);
	void (*get_max_coalesced_frames)(struct hnae_handle *, u32 *, u32 *);
	int (*set_coalesce_usecs)(struct hnae_handle *, u32);
	int (*set_coalesce_frames)(struct hnae_handle *, u32, u32);
	void (*get_coalesce_range)(struct hnae_handle *, u32 *, u32 *, u32 *, u32 *, u32 *, u32 *, u32 *, u32 *);
	void (*set_promisc_mode)(struct hnae_handle *, u32);
	int (*get_mac_addr)(struct hnae_handle *, void **);
	int (*set_mac_addr)(struct hnae_handle *, const void *);
	int (*add_uc_addr)(struct hnae_handle *, const unsigned char *);
	int (*rm_uc_addr)(struct hnae_handle *, const unsigned char *);
	int (*clr_mc_addr)(struct hnae_handle *);
	int (*set_mc_addr)(struct hnae_handle *, void *);
	int (*set_mtu)(struct hnae_handle *, int);
	void (*set_tso_stats)(struct hnae_handle *, int);
	void (*update_stats)(struct hnae_handle *, struct net_device_stats *);
	void (*get_stats)(struct hnae_handle *, u64 *);
	void (*get_strings)(struct hnae_handle *, u32, u8 *);
	int (*get_sset_count)(struct hnae_handle *, int);
	void (*update_led_status)(struct hnae_handle *);
	int (*set_led_id)(struct hnae_handle *, enum hnae_led_state);
	void (*get_regs)(struct hnae_handle *, void *);
	int (*get_regs_len)(struct hnae_handle *);
	u32 (*get_rss_key_size)(struct hnae_handle *);
	u32 (*get_rss_indir_size)(struct hnae_handle *);
	int (*get_rss)(struct hnae_handle *, u32 *, u8 *, u8 *);
	int (*set_rss)(struct hnae_handle *, const u32 *, const u8 *, const u8);
};

struct hnae_buf_ops;

struct hnae_handle {
	struct device *owner_dev;
	struct hnae_ae_dev *dev;
	struct phy_device *phy_dev;
	phy_interface_t phy_if;
	u32 if_support;
	int q_num;
	int vf_id;
	unsigned long coal_last_jiffies;
	u32 coal_param;
	u32 coal_ring_idx;
	u32 eport_id;
	u32 dport_id;
	bool coal_adapt_en;
	enum hnae_port_type port_type;
	enum hnae_media_type media_type;
	struct list_head node;
	struct hnae_buf_ops *bops;
	struct hnae_queue *qs[0];
};

struct hnae_desc_cb;

struct hnae_buf_ops {
	int (*alloc_buffer)(struct hnae_ring *, struct hnae_desc_cb *);
	void (*free_buffer)(struct hnae_ring *, struct hnae_desc_cb *);
	int (*map_buffer)(struct hnae_ring *, struct hnae_desc_cb *);
	void (*unmap_buffer)(struct hnae_ring *, struct hnae_desc_cb *);
};

struct ring_stats {
	u64 io_err_cnt;
	u64 sw_err_cnt;
	u64 seg_pkt_cnt;
	union {
		struct {
			u64 tx_pkts;
			u64 tx_bytes;
			u64 tx_err_cnt;
			u64 restart_queue;
			u64 tx_busy;
		};
		struct {
			u64 rx_pkts;
			u64 rx_bytes;
			u64 rx_err_cnt;
			u64 reuse_pg_cnt;
			u64 err_pkt_len;
			u64 non_vld_descs;
			u64 err_bd_num;
			u64 l2_err;
			u64 l3l4_csum_err;
		};
	};
};

struct hnae_desc;

struct hnae_ring {
	u8 *io_base;
	struct hnae_desc *desc;
	struct hnae_desc_cb *desc_cb;
	struct hnae_queue *q;
	int irq;
	char ring_name[20];
	struct ring_stats stats;
	dma_addr_t desc_dma_addr;
	u32 buf_size;
	u16 desc_num;
	u16 max_desc_num_per_pkt;
	u16 max_raw_data_sz_per_desc;
	u16 max_pkt_size;
	int next_to_use;
	int next_to_clean;
	int flags;
	int irq_init_flag;
	u64 coal_last_rx_bytes;
	unsigned long coal_last_jiffies;
	u32 coal_param;
	u32 coal_rx_rate;
};

struct hnae_desc {
	__le64 addr;
	union {
		struct {
			union {
				__le16 asid_bufnum_pid;
				__le16 asid;
			};
			__le16 send_size;
			union {
				__le32 flag_ipoffset;
				struct {
					__u8 bn_pid;
					__u8 ra_ri_cs_fe_vld;
					__u8 ip_offset;
					__u8 tse_vlan_snap_v6_sctp_nth;
				};
			};
			__le16 mss;
			__u8 l4_len;
			__u8 reserved1;
			__le16 paylen;
			__u8 vmid;
			__u8 qid;
			__le32 reserved2[2];
		} tx;
		struct {
			__le32 ipoff_bnum_pid_flag;
			__le16 pkt_len;
			__le16 size;
			union {
				__le32 vlan_pri_asid;
				struct {
					__le16 asid;
					__le16 vlan_cfi_pri;
				};
			};
			__le32 rss_hash;
			__le32 reserved_1[2];
		} rx;
	};
};

struct hnae_desc_cb {
	dma_addr_t dma;
	void *buf;
	void *priv;
	u32 page_offset;
	u32 length;
	u16 reuse_flag;
	u16 type;
};

struct hnae_queue {
	u8 *io_base;
	phys_addr_t phy_base;
	struct hnae_ae_dev *dev;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hnae_ring rx_ring;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hnae_ring tx_ring;
	struct hnae_handle *handle;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct hns_ring_hw_stats {
	u64 tx_pkts;
	u64 ppe_tx_ok_pkts;
	u64 ppe_tx_drop_pkts;
	u64 rx_pkts;
	u64 ppe_rx_ok_pkts;
	u64 ppe_rx_drop_pkts;
};

struct ring_pair_cb {
	struct rcb_common_cb *rcb_common;
	struct device *dev;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hnae_queue q;
	u16 index;
	u16 buf_size;
	int virq[2];
	u8 port_id_in_comm;
	u8 used_by_vf;
	struct hns_ring_hw_stats hw_stats;
};

struct rcb_common_cb {
	u8 *io_base;
	phys_addr_t phy_base;
	struct dsaf_device *dsaf_dev;
	u16 max_vfn;
	u16 max_q_per_vf;
	u8 comm_index;
	u32 ring_num;
	u32 desc_num;
	long: 64;
	long: 64;
	long: 64;
	struct ring_pair_cb ring_pair_cb[0];
};

struct mac_priv {
	void *mac;
};

struct mac_entry_idx {
	u8 addr[6];
	u16 vlan_id: 12;
	u16 valid: 1;
	u16 qos: 3;
};

struct mac_hw_stats {
	u64 rx_good_pkts;
	u64 rx_good_bytes;
	u64 rx_total_pkts;
	u64 rx_total_bytes;
	u64 rx_bad_bytes;
	u64 rx_uc_pkts;
	u64 rx_mc_pkts;
	u64 rx_bc_pkts;
	u64 rx_fragment_err;
	u64 rx_undersize;
	u64 rx_under_min;
	u64 rx_minto64;
	u64 rx_64bytes;
	u64 rx_65to127;
	u64 rx_128to255;
	u64 rx_256to511;
	u64 rx_512to1023;
	u64 rx_1024to1518;
	u64 rx_1519tomax;
	u64 rx_1519tomax_good;
	u64 rx_oversize;
	u64 rx_jabber_err;
	u64 rx_fcs_err;
	u64 rx_vlan_pkts;
	u64 rx_data_err;
	u64 rx_align_err;
	u64 rx_long_err;
	u64 rx_pfc_tc0;
	u64 rx_pfc_tc1;
	u64 rx_pfc_tc2;
	u64 rx_pfc_tc3;
	u64 rx_pfc_tc4;
	u64 rx_pfc_tc5;
	u64 rx_pfc_tc6;
	u64 rx_pfc_tc7;
	u64 rx_unknown_ctrl;
	u64 rx_filter_pkts;
	u64 rx_filter_bytes;
	u64 rx_fifo_overrun_err;
	u64 rx_len_err;
	u64 rx_comma_err;
	u64 rx_symbol_err;
	u64 tx_good_to_sw;
	u64 tx_bad_to_sw;
	u64 rx_1731_pkts;
	u64 tx_good_bytes;
	u64 tx_good_pkts;
	u64 tx_total_bytes;
	u64 tx_total_pkts;
	u64 tx_bad_bytes;
	u64 tx_bad_pkts;
	u64 tx_uc_pkts;
	u64 tx_mc_pkts;
	u64 tx_bc_pkts;
	u64 tx_undersize;
	u64 tx_fragment_err;
	u64 tx_under_min_pkts;
	u64 tx_64bytes;
	u64 tx_65to127;
	u64 tx_128to255;
	u64 tx_256to511;
	u64 tx_512to1023;
	u64 tx_1024to1518;
	u64 tx_1519tomax;
	u64 tx_1519tomax_good;
	u64 tx_oversize;
	u64 tx_jabber_err;
	u64 tx_underrun_err;
	u64 tx_vlan;
	u64 tx_crc_err;
	u64 tx_pfc_tc0;
	u64 tx_pfc_tc1;
	u64 tx_pfc_tc2;
	u64 tx_pfc_tc3;
	u64 tx_pfc_tc4;
	u64 tx_pfc_tc5;
	u64 tx_pfc_tc6;
	u64 tx_pfc_tc7;
	u64 tx_ctrl;
	u64 tx_1731_pkts;
	u64 tx_1588_pkts;
	u64 rx_good_from_sw;
	u64 rx_bad_from_sw;
};

struct hns_mac_cb {
	struct device *dev;
	struct dsaf_device *dsaf_dev;
	struct mac_priv priv;
	struct fwnode_handle *fw_port;
	u8 *vaddr;
	u8 *sys_ctl_vaddr;
	u8 *serdes_vaddr;
	struct regmap *serdes_ctrl;
	struct regmap *cpld_ctrl;
	char mc_mask[6];
	u32 cpld_ctrl_reg;
	u32 port_rst_off;
	u32 port_mode_off;
	struct mac_entry_idx addr_entry_idx[128];
	u8 sfp_prsnt;
	u8 cpld_led_value;
	u8 mac_id;
	u8 link;
	u8 half_duplex;
	u16 speed;
	u16 max_speed;
	u16 max_frm;
	u16 tx_pause_frm_time;
	u32 if_support;
	u64 txpkt_for_led;
	u64 rxpkt_for_led;
	enum hnae_port_type mac_type;
	enum hnae_media_type media_type;
	phy_interface_t phy_if;
	enum hnae_loop loop_mode;
	struct phy_device *phy_dev;
	struct mac_hw_stats hw_stats;
};

struct dsaf_misc_op {
	void (*cpld_set_led)(struct hns_mac_cb *, int, u16, int);
	void (*cpld_reset_led)(struct hns_mac_cb *);
	int (*cpld_set_led_id)(struct hns_mac_cb *, enum hnae_led_state);
	void (*dsaf_reset)(struct dsaf_device *, bool);
	void (*xge_srst)(struct dsaf_device *, u32, bool);
	void (*ge_srst)(struct dsaf_device *, u32, bool);
	void (*ppe_srst)(struct dsaf_device *, u32, bool);
	void (*ppe_comm_srst)(struct dsaf_device *, bool);
	void (*hns_dsaf_srst_chns)(struct dsaf_device *, u32, bool);
	void (*hns_dsaf_roce_srst)(struct dsaf_device *, bool);
	phy_interface_t (*get_phy_if)(struct hns_mac_cb *);
	int (*get_sfp_prsnt)(struct hns_mac_cb *, int *);
	int (*cfg_serdes_loopback)(struct hns_mac_cb *, bool);
};

struct page_pool_params {
	unsigned int flags;
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	struct napi_struct *napi;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
	void (*init_callback)(struct page *, void *);
	void *init_arg;
};

struct page_pool_alloc_stats {
	u64 fast;
	u64 slow;
	u64 slow_high_order;
	u64 empty;
	u64 refill;
	u64 waive;
};

struct pp_alloc_cache {
	u32 count;
	struct page *cache[128];
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int size;
	int batch;
	void **queue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct page_pool_recycle_stats;

struct page_pool {
	struct page_pool_params p;
	long frag_users;
	struct page *frag_page;
	unsigned int frag_offset;
	u32 pages_state_hold_cnt;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	unsigned long defer_start;
	unsigned long defer_warn;
	struct page_pool_alloc_stats alloc_stats;
	u32 xdp_mem_id;
	struct pp_alloc_cache alloc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring ring;
	struct page_pool_recycle_stats __attribute__((btf_type_tag("percpu"))) *recycle_stats;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	u64 destroy_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct page_pool_recycle_stats {
	u64 cached;
	u64 cache_full;
	u64 ring;
	u64 ring_full;
	u64 released_refcnt;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, unsigned long, struct qdisc_walker *);
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	unsigned long cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

struct tc_action;

struct tcf_exts_miss_cookie_node;

struct tcf_exts {
	__u32 type;
	int nr_actions;
	struct tc_action **actions;
	struct net *net;
	netns_tracker ns_tracker;
	struct tcf_exts_miss_cookie_node *miss_cookie_node;
	int action;
	int police;
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct tc_action_ops;

struct tcf_idrinfo;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	struct tcf_t tcfa_tm;
	long: 64;
	struct gnet_stats_basic_sync tcfa_bstats;
	struct gnet_stats_basic_sync tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator __attribute__((btf_type_tag("rcu"))) *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_sync __attribute__((btf_type_tag("percpu"))) *cpu_bstats;
	struct gnet_stats_basic_sync __attribute__((btf_type_tag("percpu"))) *cpu_bstats_hw;
	struct gnet_stats_queue __attribute__((btf_type_tag("percpu"))) *cpu_qstats;
	struct tc_cookie __attribute__((btf_type_tag("rcu"))) *user_cookie;
	struct tcf_chain __attribute__((btf_type_tag("rcu"))) *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
	u32 in_hw_count;
};

enum tca_id {
	TCA_ID_UNSPEC = 0,
	TCA_ID_POLICE = 1,
	TCA_ID_GACT = 5,
	TCA_ID_IPT = 6,
	TCA_ID_PEDIT = 7,
	TCA_ID_MIRRED = 8,
	TCA_ID_NAT = 9,
	TCA_ID_XT = 10,
	TCA_ID_SKBEDIT = 11,
	TCA_ID_VLAN = 12,
	TCA_ID_BPF = 13,
	TCA_ID_CONNMARK = 14,
	TCA_ID_SKBMOD = 15,
	TCA_ID_CSUM = 16,
	TCA_ID_TUNNEL_KEY = 17,
	TCA_ID_SIMP = 22,
	TCA_ID_IFE = 25,
	TCA_ID_SAMPLE = 26,
	TCA_ID_CTINFO = 27,
	TCA_ID_MPLS = 28,
	TCA_ID_CT = 29,
	TCA_ID_GATE = 30,
	__TCA_ID_MAX = 255,
};

typedef void (*tc_action_priv_destructor)(void *);

struct psample_group;

struct tc_action_ops {
	struct list_head head;
	char kind[16];
	enum tca_id id;
	unsigned int net_id;
	size_t size;
	struct module *owner;
	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
	void (*cleanup)(struct tc_action *);
	int (*lookup)(struct net *, struct tc_action **, u32);
	int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, struct tcf_proto *, u32, struct netlink_ext_ack *);
	int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
	void (*stats_update)(struct tc_action *, u64, u64, u64, u64, bool);
	size_t (*get_fill_size)(const struct tc_action *);
	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
	int (*offload_act_setup)(struct tc_action *, void *, u32 *, bool, struct netlink_ext_ack *);
};

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct hns3_stats {
	char stats_string[32];
	int stats_offset;
};

struct hns3_pflag_desc {
	char name[32];
	void (*handler)(struct net_device *, bool);
};

enum ethtool_reset_flags {
	ETH_RESET_MGMT = 1,
	ETH_RESET_IRQ = 2,
	ETH_RESET_DMA = 4,
	ETH_RESET_FILTER = 8,
	ETH_RESET_OFFLOAD = 16,
	ETH_RESET_MAC = 32,
	ETH_RESET_PHY = 64,
	ETH_RESET_RAM = 128,
	ETH_RESET_AP = 256,
	ETH_RESET_DEDICATED = 65535,
	ETH_RESET_ALL = 4294967295,
};

enum hnae3_reset_type {
	HNAE3_VF_RESET = 0,
	HNAE3_VF_FUNC_RESET = 1,
	HNAE3_VF_PF_FUNC_RESET = 2,
	HNAE3_VF_FULL_RESET = 3,
	HNAE3_FLR_RESET = 4,
	HNAE3_FUNC_RESET = 5,
	HNAE3_GLOBAL_RESET = 6,
	HNAE3_IMP_RESET = 7,
	HNAE3_NONE_RESET = 8,
	HNAE3_VF_EXP_RESET = 9,
	HNAE3_MAX_RESET = 10,
};

struct hns3_reset_type_map {
	enum ethtool_reset_flags rst_flags;
	enum hnae3_reset_type rst_type;
};

struct hns3_ethtool_link_ext_state_mapping {
	u32 status_code;
	enum ethtool_link_ext_state link_ext_state;
	u8 link_ext_substate;
};

enum hnae3_client_type {
	HNAE3_CLIENT_KNIC = 0,
	HNAE3_CLIENT_ROCE = 1,
};

enum hnae3_reset_notify_type {
	HNAE3_UP_CLIENT = 0,
	HNAE3_DOWN_CLIENT = 1,
	HNAE3_INIT_CLIENT = 2,
	HNAE3_UNINIT_CLIENT = 3,
};

enum hnae3_hw_error_type {
	HNAE3_PPU_POISON_ERROR = 0,
	HNAE3_CMDQ_ECC_ERROR = 1,
	HNAE3_IMP_RD_POISON_ERROR = 2,
	HNAE3_ROCEE_AXI_RESP_ERROR = 3,
};

enum hnae3_loop {
	HNAE3_LOOP_EXTERNAL = 0,
	HNAE3_LOOP_APP = 1,
	HNAE3_LOOP_SERIAL_SERDES = 2,
	HNAE3_LOOP_PARALLEL_SERDES = 3,
	HNAE3_LOOP_PHY = 4,
	HNAE3_LOOP_NONE = 5,
};

enum hnae3_dbg_cmd {
	HNAE3_DBG_CMD_TM_NODES = 0,
	HNAE3_DBG_CMD_TM_PRI = 1,
	HNAE3_DBG_CMD_TM_QSET = 2,
	HNAE3_DBG_CMD_TM_MAP = 3,
	HNAE3_DBG_CMD_TM_PG = 4,
	HNAE3_DBG_CMD_TM_PORT = 5,
	HNAE3_DBG_CMD_TC_SCH_INFO = 6,
	HNAE3_DBG_CMD_QOS_PAUSE_CFG = 7,
	HNAE3_DBG_CMD_QOS_PRI_MAP = 8,
	HNAE3_DBG_CMD_QOS_DSCP_MAP = 9,
	HNAE3_DBG_CMD_QOS_BUF_CFG = 10,
	HNAE3_DBG_CMD_DEV_INFO = 11,
	HNAE3_DBG_CMD_TX_BD = 12,
	HNAE3_DBG_CMD_RX_BD = 13,
	HNAE3_DBG_CMD_MAC_UC = 14,
	HNAE3_DBG_CMD_MAC_MC = 15,
	HNAE3_DBG_CMD_MNG_TBL = 16,
	HNAE3_DBG_CMD_LOOPBACK = 17,
	HNAE3_DBG_CMD_PTP_INFO = 18,
	HNAE3_DBG_CMD_INTERRUPT_INFO = 19,
	HNAE3_DBG_CMD_RESET_INFO = 20,
	HNAE3_DBG_CMD_IMP_INFO = 21,
	HNAE3_DBG_CMD_NCL_CONFIG = 22,
	HNAE3_DBG_CMD_REG_BIOS_COMMON = 23,
	HNAE3_DBG_CMD_REG_SSU = 24,
	HNAE3_DBG_CMD_REG_IGU_EGU = 25,
	HNAE3_DBG_CMD_REG_RPU = 26,
	HNAE3_DBG_CMD_REG_NCSI = 27,
	HNAE3_DBG_CMD_REG_RTC = 28,
	HNAE3_DBG_CMD_REG_PPP = 29,
	HNAE3_DBG_CMD_REG_RCB = 30,
	HNAE3_DBG_CMD_REG_TQP = 31,
	HNAE3_DBG_CMD_REG_MAC = 32,
	HNAE3_DBG_CMD_REG_DCB = 33,
	HNAE3_DBG_CMD_VLAN_CONFIG = 34,
	HNAE3_DBG_CMD_QUEUE_MAP = 35,
	HNAE3_DBG_CMD_RX_QUEUE_INFO = 36,
	HNAE3_DBG_CMD_TX_QUEUE_INFO = 37,
	HNAE3_DBG_CMD_FD_TCAM = 38,
	HNAE3_DBG_CMD_FD_COUNTER = 39,
	HNAE3_DBG_CMD_MAC_TNL_STATUS = 40,
	HNAE3_DBG_CMD_SERV_INFO = 41,
	HNAE3_DBG_CMD_UMV_INFO = 42,
	HNAE3_DBG_CMD_PAGE_POOL_INFO = 43,
	HNAE3_DBG_CMD_COAL_INFO = 44,
	HNAE3_DBG_CMD_UNKNOWN = 45,
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_RX_QUEUE_MAPPING = 19,
	FLOW_ACTION_WAKE = 20,
	FLOW_ACTION_QUEUE = 21,
	FLOW_ACTION_SAMPLE = 22,
	FLOW_ACTION_POLICE = 23,
	FLOW_ACTION_CT = 24,
	FLOW_ACTION_CT_METADATA = 25,
	FLOW_ACTION_MPLS_PUSH = 26,
	FLOW_ACTION_MPLS_POP = 27,
	FLOW_ACTION_MPLS_MANGLE = 28,
	FLOW_ACTION_GATE = 29,
	FLOW_ACTION_PPPOE_PUSH = 30,
	FLOW_ACTION_JUMP = 31,
	FLOW_ACTION_PIPE = 32,
	FLOW_ACTION_VLAN_PUSH_ETH = 33,
	FLOW_ACTION_VLAN_POP_ETH = 34,
	FLOW_ACTION_CONTINUE = 35,
	NUM_FLOW_ACTIONS = 36,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

enum hnae3_port_base_vlan_state {
	HNAE3_PORT_BASE_VLAN_DISABLE = 0,
	HNAE3_PORT_BASE_VLAN_ENABLE = 1,
	HNAE3_PORT_BASE_VLAN_MODIFY = 2,
	HNAE3_PORT_BASE_VLAN_NOCHANGE = 3,
};

enum hns3_flow_level_range {
	HNS3_FLOW_LOW = 0,
	HNS3_FLOW_MID = 1,
	HNS3_FLOW_HIGH = 2,
	HNS3_FLOW_ULTRA = 3,
};

enum dim_cq_period_mode {
	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
	DIM_CQ_PERIOD_NUM_MODES = 2,
};

enum hns3_nic_state {
	HNS3_NIC_STATE_TESTING = 0,
	HNS3_NIC_STATE_RESETTING = 1,
	HNS3_NIC_STATE_INITED = 2,
	HNS3_NIC_STATE_DOWN = 3,
	HNS3_NIC_STATE_DISABLED = 4,
	HNS3_NIC_STATE_REMOVING = 5,
	HNS3_NIC_STATE_SERVICE_INITED = 6,
	HNS3_NIC_STATE_SERVICE_SCHED = 7,
	HNS3_NIC_STATE2_RESET_REQUESTED = 8,
	HNS3_NIC_STATE_HW_TX_CSUM_ENABLE = 9,
	HNS3_NIC_STATE_RXD_ADV_LAYOUT_ENABLE = 10,
	HNS3_NIC_STATE_TX_PUSH_ENABLE = 11,
	HNS3_NIC_STATE_MAX = 12,
};

enum HNAE3_DEV_CAP_BITS {
	HNAE3_DEV_SUPPORT_FD_B = 0,
	HNAE3_DEV_SUPPORT_GRO_B = 1,
	HNAE3_DEV_SUPPORT_FEC_B = 2,
	HNAE3_DEV_SUPPORT_UDP_GSO_B = 3,
	HNAE3_DEV_SUPPORT_QB_B = 4,
	HNAE3_DEV_SUPPORT_FD_FORWARD_TC_B = 5,
	HNAE3_DEV_SUPPORT_PTP_B = 6,
	HNAE3_DEV_SUPPORT_INT_QL_B = 7,
	HNAE3_DEV_SUPPORT_HW_TX_CSUM_B = 8,
	HNAE3_DEV_SUPPORT_TX_PUSH_B = 9,
	HNAE3_DEV_SUPPORT_PHY_IMP_B = 10,
	HNAE3_DEV_SUPPORT_TQP_TXRX_INDEP_B = 11,
	HNAE3_DEV_SUPPORT_HW_PAD_B = 12,
	HNAE3_DEV_SUPPORT_STASH_B = 13,
	HNAE3_DEV_SUPPORT_UDP_TUNNEL_CSUM_B = 14,
	HNAE3_DEV_SUPPORT_PAUSE_B = 15,
	HNAE3_DEV_SUPPORT_RAS_IMP_B = 16,
	HNAE3_DEV_SUPPORT_RXD_ADV_LAYOUT_B = 17,
	HNAE3_DEV_SUPPORT_PORT_VLAN_BYPASS_B = 18,
	HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B = 19,
	HNAE3_DEV_SUPPORT_MC_MAC_MNG_B = 20,
	HNAE3_DEV_SUPPORT_CQ_B = 21,
	HNAE3_DEV_SUPPORT_FEC_STATS_B = 22,
	HNAE3_DEV_SUPPORT_LANE_NUM_B = 23,
	HNAE3_DEV_SUPPORT_WOL_B = 24,
	HNAE3_DEV_SUPPORT_TM_FLUSH_B = 25,
	HNAE3_DEV_SUPPORT_VF_FAULT_B = 26,
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

enum hnae3_pflag {
	HNAE3_PFLAG_LIMIT_PROMISC = 0,
	HNAE3_PFLAG_MAX = 1,
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

enum hnae3_media_type {
	HNAE3_MEDIA_TYPE_UNKNOWN = 0,
	HNAE3_MEDIA_TYPE_FIBER = 1,
	HNAE3_MEDIA_TYPE_COPPER = 2,
	HNAE3_MEDIA_TYPE_BACKPLANE = 3,
	HNAE3_MEDIA_TYPE_NONE = 4,
};

enum hnae3_module_type {
	HNAE3_MODULE_TYPE_UNKNOWN = 0,
	HNAE3_MODULE_TYPE_FIBRE_LR = 1,
	HNAE3_MODULE_TYPE_FIBRE_SR = 2,
	HNAE3_MODULE_TYPE_AOC = 3,
	HNAE3_MODULE_TYPE_CR = 4,
	HNAE3_MODULE_TYPE_KR = 5,
	HNAE3_MODULE_TYPE_TP = 6,
};

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE = 1,
	ETH_TEST_FL_FAILED = 2,
	ETH_TEST_FL_EXTERNAL_LB = 4,
	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	NETIF_F_LLTX_BIT = 12,
	NETIF_F_NETNS_LOCAL_BIT = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	NETIF_F_FCOE_MTU_BIT = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETIF_F_GRO_UDP_FWD_BIT = 59,
	NETIF_F_HW_HSR_TAG_INS_BIT = 60,
	NETIF_F_HW_HSR_TAG_RM_BIT = 61,
	NETIF_F_HW_HSR_FWD_BIT = 62,
	NETIF_F_HW_HSR_DUP_BIT = 63,
	NETDEV_FEATURE_COUNT = 64,
};

enum {
	SFF8024_ID_UNK = 0,
	SFF8024_ID_SFF_8472 = 2,
	SFF8024_ID_SFP = 3,
	SFF8024_ID_DWDM_SFP = 11,
	SFF8024_ID_QSFP_8438 = 12,
	SFF8024_ID_QSFP_8436_8636 = 13,
	SFF8024_ID_QSFP28_8636 = 17,
	SFF8024_ENCODING_UNSPEC = 0,
	SFF8024_ENCODING_8B10B = 1,
	SFF8024_ENCODING_4B5B = 2,
	SFF8024_ENCODING_NRZ = 3,
	SFF8024_ENCODING_8472_MANCHESTER = 4,
	SFF8024_ENCODING_8472_SONET = 5,
	SFF8024_ENCODING_8472_64B66B = 6,
	SFF8024_ENCODING_8436_MANCHESTER = 6,
	SFF8024_ENCODING_8436_SONET = 4,
	SFF8024_ENCODING_8436_64B66B = 5,
	SFF8024_ENCODING_256B257B = 7,
	SFF8024_ENCODING_PAM4 = 8,
	SFF8024_CONNECTOR_UNSPEC = 0,
	SFF8024_CONNECTOR_SC = 1,
	SFF8024_CONNECTOR_FIBERJACK = 6,
	SFF8024_CONNECTOR_LC = 7,
	SFF8024_CONNECTOR_MT_RJ = 8,
	SFF8024_CONNECTOR_MU = 9,
	SFF8024_CONNECTOR_SG = 10,
	SFF8024_CONNECTOR_OPTICAL_PIGTAIL = 11,
	SFF8024_CONNECTOR_MPO_1X12 = 12,
	SFF8024_CONNECTOR_MPO_2X16 = 13,
	SFF8024_CONNECTOR_HSSDC_II = 32,
	SFF8024_CONNECTOR_COPPER_PIGTAIL = 33,
	SFF8024_CONNECTOR_RJ45 = 34,
	SFF8024_CONNECTOR_NOSEPARATE = 35,
	SFF8024_CONNECTOR_MXC_2X16 = 36,
	SFF8024_ECC_UNSPEC = 0,
	SFF8024_ECC_100G_25GAUI_C2M_AOC = 1,
	SFF8024_ECC_100GBASE_SR4_25GBASE_SR = 2,
	SFF8024_ECC_100GBASE_LR4_25GBASE_LR = 3,
	SFF8024_ECC_100GBASE_ER4_25GBASE_ER = 4,
	SFF8024_ECC_100GBASE_SR10 = 5,
	SFF8024_ECC_100GBASE_CR4 = 11,
	SFF8024_ECC_25GBASE_CR_S = 12,
	SFF8024_ECC_25GBASE_CR_N = 13,
	SFF8024_ECC_10GBASE_T_SFI = 22,
	SFF8024_ECC_10GBASE_T_SR = 28,
	SFF8024_ECC_5GBASE_T = 29,
	SFF8024_ECC_2_5GBASE_T = 30,
};

enum ethtool_fec_config_bits {
	ETHTOOL_FEC_NONE_BIT = 0,
	ETHTOOL_FEC_AUTO_BIT = 1,
	ETHTOOL_FEC_OFF_BIT = 2,
	ETHTOOL_FEC_RS_BIT = 3,
	ETHTOOL_FEC_BASER_BIT = 4,
	ETHTOOL_FEC_LLRS_BIT = 5,
};

enum hnae3_fec_mode {
	HNAE3_FEC_AUTO = 0,
	HNAE3_FEC_BASER = 1,
	HNAE3_FEC_RS = 2,
	HNAE3_FEC_LLRS = 3,
	HNAE3_FEC_NONE = 4,
	HNAE3_FEC_USER_DEF = 5,
};

struct hns3_enet_coalesce {
	u16 int_gl;
	u16 int_ql;
	u16 int_ql_max;
	u8 adapt_enable: 1;
	u8 ql_enable: 1;
	u8 unit_1us: 1;
	enum hns3_flow_level_range flow_level;
};

struct hnae3_handle;

struct hns3_enet_ring;

struct hns3_enet_tqp_vector;

struct hns3_nic_priv {
	struct hnae3_handle *ae_handle;
	struct net_device *netdev;
	struct device *dev;
	struct hns3_enet_ring *ring;
	struct hns3_enet_tqp_vector *tqp_vector;
	u16 vector_num;
	u8 max_non_tso_bd_num;
	u64 tx_timeout_count;
	unsigned long state;
	enum dim_cq_period_mode tx_cqe_mode;
	enum dim_cq_period_mode rx_cqe_mode;
	struct hns3_enet_coalesce tx_coal;
	struct hns3_enet_coalesce rx_coal;
	u32 tx_copybreak;
	u32 rx_copybreak;
};

struct hnae3_tc_info {
	u8 prio_tc[8];
	u16 tqp_count[8];
	u16 tqp_offset[8];
	u8 max_tc;
	u8 num_tc;
	bool mqprio_active;
	bool dcb_ets_active;
};

struct hnae3_queue;

struct hnae3_dcb_ops;

struct hnae3_knic_private_info {
	struct net_device *netdev;
	u16 rss_size;
	u16 req_rss_size;
	u16 rx_buf_len;
	u16 num_tx_desc;
	u16 num_rx_desc;
	u32 tx_spare_buf_size;
	struct hnae3_tc_info tc_info;
	u8 tc_map_mode;
	u8 dscp_app_cnt;
	u8 dscp_prio[64];
	u16 num_tqps;
	struct hnae3_queue **tqp;
	const struct hnae3_dcb_ops *dcb_ops;
	u16 int_rl_setting;
	void *io_base;
};

struct hnae3_roce_private_info {
	struct net_device *netdev;
	void *roce_io_base;
	void *roce_mem_base;
	int base_vector;
	int num_vectors;
	unsigned long reset_state;
	unsigned long instance_state;
	unsigned long state;
};

struct hnae3_client;

struct hnae3_ae_algo;

struct hnae3_handle {
	struct hnae3_client *client;
	struct pci_dev *pdev;
	void *priv;
	struct hnae3_ae_algo *ae_algo;
	u64 flags;
	union {
		struct net_device *netdev;
		struct hnae3_knic_private_info kinfo;
		struct hnae3_roce_private_info rinfo;
	};
	u32 numa_node_mask;
	enum hnae3_port_base_vlan_state port_base_vlan_state;
	u8 netdev_flags;
	struct dentry *hnae3_dbgfs;
	struct mutex dbgfs_lock;
	char **dbgfs_buf;
	u32 msg_enable;
	unsigned long supported_pflags;
	unsigned long priv_flags;
};

struct hnae3_client_ops;

struct hnae3_client {
	char name[16];
	unsigned long state;
	enum hnae3_client_type type;
	const struct hnae3_client_ops *ops;
	struct list_head node;
};

struct hnae3_client_ops {
	int (*init_instance)(struct hnae3_handle *);
	void (*uninit_instance)(struct hnae3_handle *, bool);
	void (*link_status_change)(struct hnae3_handle *, bool);
	int (*reset_notify)(struct hnae3_handle *, enum hnae3_reset_notify_type);
	void (*process_hw_error)(struct hnae3_handle *, enum hnae3_hw_error_type);
};

struct hnae3_ae_ops;

struct hnae3_ae_algo {
	const struct hnae3_ae_ops *ops;
	struct list_head node;
	const struct pci_device_id *pdev_id_table;
};

struct hnae3_ae_dev;

struct hns3_mac_stats;

struct hnae3_vector_info;

struct hnae3_ring_chain_node;

struct flow_keys;

struct flow_cls_offload;

struct hnae3_ae_ops {
	int (*init_ae_dev)(struct hnae3_ae_dev *);
	void (*uninit_ae_dev)(struct hnae3_ae_dev *);
	void (*reset_prepare)(struct hnae3_ae_dev *, enum hnae3_reset_type);
	void (*reset_done)(struct hnae3_ae_dev *);
	int (*init_client_instance)(struct hnae3_client *, struct hnae3_ae_dev *);
	void (*uninit_client_instance)(struct hnae3_client *, struct hnae3_ae_dev *);
	int (*start)(struct hnae3_handle *);
	void (*stop)(struct hnae3_handle *);
	int (*client_start)(struct hnae3_handle *);
	void (*client_stop)(struct hnae3_handle *);
	int (*get_status)(struct hnae3_handle *);
	void (*get_ksettings_an_result)(struct hnae3_handle *, u8 *, u32 *, u8 *, u32 *);
	int (*cfg_mac_speed_dup_h)(struct hnae3_handle *, int, u8, u8);
	void (*get_media_type)(struct hnae3_handle *, u8 *, u8 *);
	int (*check_port_speed)(struct hnae3_handle *, u32);
	void (*get_fec_stats)(struct hnae3_handle *, struct ethtool_fec_stats *);
	void (*get_fec)(struct hnae3_handle *, u8 *, u8 *);
	int (*set_fec)(struct hnae3_handle *, u32);
	void (*adjust_link)(struct hnae3_handle *, int, int);
	int (*set_loopback)(struct hnae3_handle *, enum hnae3_loop, bool);
	int (*set_promisc_mode)(struct hnae3_handle *, bool, bool);
	void (*request_update_promisc_mode)(struct hnae3_handle *);
	int (*set_mtu)(struct hnae3_handle *, int);
	void (*get_pauseparam)(struct hnae3_handle *, u32 *, u32 *, u32 *);
	int (*set_pauseparam)(struct hnae3_handle *, u32, u32, u32);
	int (*set_autoneg)(struct hnae3_handle *, bool);
	int (*get_autoneg)(struct hnae3_handle *);
	int (*restart_autoneg)(struct hnae3_handle *);
	int (*halt_autoneg)(struct hnae3_handle *, bool);
	void (*get_coalesce_usecs)(struct hnae3_handle *, u32 *, u32 *);
	void (*get_rx_max_coalesced_frames)(struct hnae3_handle *, u32 *, u32 *);
	int (*set_coalesce_usecs)(struct hnae3_handle *, u32);
	int (*set_coalesce_frames)(struct hnae3_handle *, u32);
	void (*get_coalesce_range)(struct hnae3_handle *, u32 *, u32 *, u32 *, u32 *, u32 *, u32 *, u32 *, u32 *);
	void (*get_mac_addr)(struct hnae3_handle *, u8 *);
	int (*set_mac_addr)(struct hnae3_handle *, const void *, bool);
	int (*do_ioctl)(struct hnae3_handle *, struct ifreq *, int);
	int (*add_uc_addr)(struct hnae3_handle *, const unsigned char *);
	int (*rm_uc_addr)(struct hnae3_handle *, const unsigned char *);
	int (*set_mc_addr)(struct hnae3_handle *, void *);
	int (*add_mc_addr)(struct hnae3_handle *, const unsigned char *);
	int (*rm_mc_addr)(struct hnae3_handle *, const unsigned char *);
	void (*set_tso_stats)(struct hnae3_handle *, int);
	void (*update_stats)(struct hnae3_handle *);
	void (*get_stats)(struct hnae3_handle *, u64 *);
	void (*get_mac_stats)(struct hnae3_handle *, struct hns3_mac_stats *);
	void (*get_strings)(struct hnae3_handle *, u32, u8 *);
	int (*get_sset_count)(struct hnae3_handle *, int);
	void (*get_regs)(struct hnae3_handle *, u32 *, void *);
	int (*get_regs_len)(struct hnae3_handle *);
	u32 (*get_rss_key_size)(struct hnae3_handle *);
	int (*get_rss)(struct hnae3_handle *, u32 *, u8 *, u8 *);
	int (*set_rss)(struct hnae3_handle *, const u32 *, const u8 *, const u8);
	int (*set_rss_tuple)(struct hnae3_handle *, struct ethtool_rxnfc *);
	int (*get_rss_tuple)(struct hnae3_handle *, struct ethtool_rxnfc *);
	int (*get_tc_size)(struct hnae3_handle *);
	int (*get_vector)(struct hnae3_handle *, u16, struct hnae3_vector_info *);
	int (*put_vector)(struct hnae3_handle *, int);
	int (*map_ring_to_vector)(struct hnae3_handle *, int, struct hnae3_ring_chain_node *);
	int (*unmap_ring_from_vector)(struct hnae3_handle *, int, struct hnae3_ring_chain_node *);
	int (*reset_queue)(struct hnae3_handle *);
	u32 (*get_fw_version)(struct hnae3_handle *);
	void (*get_mdix_mode)(struct hnae3_handle *, u8 *, u8 *);
	int (*enable_vlan_filter)(struct hnae3_handle *, bool);
	int (*set_vlan_filter)(struct hnae3_handle *, __be16, u16, bool);
	int (*set_vf_vlan_filter)(struct hnae3_handle *, int, u16, u8, __be16);
	int (*enable_hw_strip_rxvtag)(struct hnae3_handle *, bool);
	void (*reset_event)(struct pci_dev *, struct hnae3_handle *);
	enum hnae3_reset_type (*get_reset_level)(struct hnae3_ae_dev *, unsigned long *);
	void (*set_default_reset_request)(struct hnae3_ae_dev *, enum hnae3_reset_type);
	void (*get_channels)(struct hnae3_handle *, struct ethtool_channels *);
	void (*get_tqps_and_rss_info)(struct hnae3_handle *, u16 *, u16 *);
	int (*set_channels)(struct hnae3_handle *, u32, bool);
	void (*get_flowctrl_adv)(struct hnae3_handle *, u32 *);
	int (*set_led_id)(struct hnae3_handle *, enum ethtool_phys_id_state);
	void (*get_link_mode)(struct hnae3_handle *, unsigned long *, unsigned long *);
	int (*add_fd_entry)(struct hnae3_handle *, struct ethtool_rxnfc *);
	int (*del_fd_entry)(struct hnae3_handle *, struct ethtool_rxnfc *);
	int (*get_fd_rule_cnt)(struct hnae3_handle *, struct ethtool_rxnfc *);
	int (*get_fd_rule_info)(struct hnae3_handle *, struct ethtool_rxnfc *);
	int (*get_fd_all_rules)(struct hnae3_handle *, struct ethtool_rxnfc *, u32 *);
	void (*enable_fd)(struct hnae3_handle *, bool);
	int (*add_arfs_entry)(struct hnae3_handle *, u16, u16, struct flow_keys *);
	int (*dbg_read_cmd)(struct hnae3_handle *, enum hnae3_dbg_cmd, char *, int);
	pci_ers_result_t (*handle_hw_ras_error)(struct hnae3_ae_dev *);
	bool (*get_hw_reset_stat)(struct hnae3_handle *);
	bool (*ae_dev_resetting)(struct hnae3_handle *);
	unsigned long (*ae_dev_reset_cnt)(struct hnae3_handle *);
	int (*set_gro_en)(struct hnae3_handle *, bool);
	u16 (*get_global_queue_id)(struct hnae3_handle *, u16);
	void (*set_timer_task)(struct hnae3_handle *, bool);
	int (*mac_connect_phy)(struct hnae3_handle *);
	void (*mac_disconnect_phy)(struct hnae3_handle *);
	int (*get_vf_config)(struct hnae3_handle *, int, struct ifla_vf_info *);
	int (*set_vf_link_state)(struct hnae3_handle *, int, int);
	int (*set_vf_spoofchk)(struct hnae3_handle *, int, bool);
	int (*set_vf_trust)(struct hnae3_handle *, int, bool);
	int (*set_vf_rate)(struct hnae3_handle *, int, int, int, bool);
	int (*set_vf_mac)(struct hnae3_handle *, int, u8 *);
	int (*get_module_eeprom)(struct hnae3_handle *, u32, u32, u8 *);
	bool (*get_cmdq_stat)(struct hnae3_handle *);
	int (*add_cls_flower)(struct hnae3_handle *, struct flow_cls_offload *, int);
	int (*del_cls_flower)(struct hnae3_handle *, struct flow_cls_offload *);
	bool (*cls_flower_active)(struct hnae3_handle *);
	int (*get_phy_link_ksettings)(struct hnae3_handle *, struct ethtool_link_ksettings *);
	int (*set_phy_link_ksettings)(struct hnae3_handle *, const struct ethtool_link_ksettings *);
	bool (*set_tx_hwts_info)(struct hnae3_handle *, struct sk_buff *);
	void (*get_rx_hwts)(struct hnae3_handle *, struct sk_buff *, u32, u32);
	int (*get_ts_info)(struct hnae3_handle *, struct ethtool_ts_info *);
	int (*get_link_diagnosis_info)(struct hnae3_handle *, u32 *);
	void (*clean_vf_config)(struct hnae3_ae_dev *, int);
	int (*get_dscp_prio)(struct hnae3_handle *, u8, u8 *, u8 *);
	void (*get_wol)(struct hnae3_handle *, struct ethtool_wolinfo *);
	int (*set_wol)(struct hnae3_handle *, struct ethtool_wolinfo *);
};

struct hnae3_dev_specs {
	u32 mac_entry_num;
	u32 mng_entry_num;
	u32 max_tm_rate;
	u16 rss_ind_tbl_size;
	u16 rss_key_size;
	u16 int_ql_max;
	u16 max_int_gl;
	u8 max_non_tso_bd_num;
	u16 max_frm_size;
	u16 max_qset_num;
	u16 umv_size;
	u16 mc_mac_size;
	u32 mac_stats_num;
	u8 tnl_num;
};

struct hnae3_ae_dev {
	struct pci_dev *pdev;
	const struct hnae3_ae_ops *ops;
	struct list_head node;
	u32 flag;
	unsigned long hw_err_reset_req;
	struct hnae3_dev_specs dev_specs;
	u32 dev_version;
	unsigned long caps[2];
	void *priv;
};

struct hns3_mac_stats {
	u64 tx_pause_cnt;
	u64 rx_pause_cnt;
};

struct hnae3_vector_info {
	u8 *io_addr;
	int vector;
};

struct hnae3_ring_chain_node {
	struct hnae3_ring_chain_node *next;
	u32 tqp_index;
	u32 flag;
	u32 int_gl_idx;
};

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
	__be16 vlan_eth_type;
	u16 padding;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	long: 0;
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	struct netlink_ext_ack *extack;
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

struct flow_rule;

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	bool use_act_stats;
	unsigned long cookie;
	struct flow_rule *rule;
	struct flow_stats stats;
	u32 classid;
};

struct flow_dissector;

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

typedef void (*action_destr)(void *);

struct nf_flowtable;

struct ip_tunnel_info;

struct action_gate_entry;

struct flow_action_cookie;

struct flow_action_entry {
	enum flow_action_id id;
	u32 hw_index;
	unsigned long cookie;
	u64 miss_cookie;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			unsigned char dst[6];
			unsigned char src[6];
		} vlan_push_eth;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u16 rx_queue;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 burst;
			u64 rate_bytes_ps;
			u64 peakrate_bytes_ps;
			u32 avrate;
			u16 overhead;
			u64 burst_pkt;
			u64 rate_pkt_ps;
			u32 mtu;
			struct {
				enum flow_action_id act_id;
				u32 extval;
			} exceed;
			struct {
				enum flow_action_id act_id;
				u32 extval;
			} notexceed;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			unsigned long cookie;
			u32 mark;
			u32 labels[4];
			bool orig_dir;
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			s32 prio;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
		struct {
			u16 sid;
		} pppoe;
	};
	struct flow_action_cookie *user_cookie;
};

struct flow_action {
	unsigned int num_entries;
	struct flow_action_entry entries[0];
};

struct flow_rule {
	struct flow_match match;
	struct flow_action action;
};

struct flow_dissector {
	unsigned long long used_keys;
	unsigned short offset[33];
};

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct hnae3_queue {
	void *io_base;
	void *mem_base;
	struct hnae3_ae_algo *ae_algo;
	struct hnae3_handle *handle;
	int tqp_index;
	u32 buf_size;
	u16 tx_desc_num;
	u16 rx_desc_num;
};

struct ieee_ets;

struct ieee_pfc;

struct dcb_app;

struct tc_mqprio_qopt_offload;

struct hnae3_dcb_ops {
	int (*ieee_getets)(struct hnae3_handle *, struct ieee_ets *);
	int (*ieee_setets)(struct hnae3_handle *, struct ieee_ets *);
	int (*ieee_getpfc)(struct hnae3_handle *, struct ieee_pfc *);
	int (*ieee_setpfc)(struct hnae3_handle *, struct ieee_pfc *);
	int (*ieee_setapp)(struct hnae3_handle *, struct dcb_app *);
	int (*ieee_delapp)(struct hnae3_handle *, struct dcb_app *);
	u8 (*getdcbx)(struct hnae3_handle *);
	u8 (*setdcbx)(struct hnae3_handle *, u8);
	int (*setup_tc)(struct hnae3_handle *, struct tc_mqprio_qopt_offload *);
};

struct ieee_ets {
	__u8 willing;
	__u8 ets_cap;
	__u8 cbs;
	__u8 tc_tx_bw[8];
	__u8 tc_rx_bw[8];
	__u8 tc_tsa[8];
	__u8 prio_tc[8];
	__u8 tc_reco_bw[8];
	__u8 tc_reco_tsa[8];
	__u8 reco_prio_tc[8];
};

struct ieee_pfc {
	__u8 pfc_cap;
	__u8 pfc_en;
	__u8 mbc;
	__u16 delay;
	__u64 requests[8];
	__u64 indications[8];
};

struct dcb_app {
	__u8 selector;
	__u8 priority;
	__u16 protocol;
};

struct tc_mqprio_qopt {
	__u8 num_tc;
	__u8 prio_tc_map[16];
	__u8 hw;
	__u16 count[16];
	__u16 offset[16];
};

struct tc_mqprio_qopt_offload {
	struct tc_mqprio_qopt qopt;
	struct netlink_ext_ack *extack;
	u16 mode;
	u16 shaper;
	u32 flags;
	u64 min_rate[16];
	u64 max_rate[16];
	unsigned long preemptible_tcs;
};

struct ring_stats___2 {
	u64 sw_err_cnt;
	u64 seg_pkt_cnt;
	union {
		struct {
			u64 tx_pkts;
			u64 tx_bytes;
			u64 tx_more;
			u64 tx_push;
			u64 tx_mem_doorbell;
			u64 restart_queue;
			u64 tx_busy;
			u64 tx_copy;
			u64 tx_vlan_err;
			u64 tx_l4_proto_err;
			u64 tx_l2l3l4_err;
			u64 tx_tso_err;
			u64 over_max_recursion;
			u64 hw_limitation;
			u64 tx_bounce;
			u64 tx_spare_full;
			u64 copy_bits_err;
			u64 tx_sgl;
			u64 skb2sgl_err;
			u64 map_sg_err;
		};
		struct {
			u64 rx_pkts;
			u64 rx_bytes;
			u64 rx_err_cnt;
			u64 reuse_pg_cnt;
			u64 err_pkt_len;
			u64 err_bd_num;
			u64 l2_err;
			u64 l3l4_csum_err;
			u64 csum_complete;
			u64 rx_multicast;
			u64 non_reuse_pg;
			u64 frag_alloc_err;
			u64 frag_alloc;
		};
		__le16 csum;
	};
};

struct hns3_desc;

struct hns3_desc_cb;

struct hns3_tx_spare;

struct hns3_enet_ring {
	struct hns3_desc *desc;
	struct hns3_desc_cb *desc_cb;
	struct hns3_enet_ring *next;
	struct hns3_enet_tqp_vector *tqp_vector;
	struct hnae3_queue *tqp;
	int queue_index;
	struct device *dev;
	struct page_pool *page_pool;
	struct ring_stats___2 stats;
	struct u64_stats_sync syncp;
	dma_addr_t desc_dma_addr;
	u32 buf_size;
	u16 desc_num;
	int next_to_use;
	int next_to_clean;
	u32 flag;
	int pending_buf;
	union {
		struct {
			u32 fd_qb_tx_sample;
			int last_to_use;
			u32 tx_copybreak;
			struct hns3_tx_spare *tx_spare;
		};
		struct {
			u32 pull_len;
			u32 rx_copybreak;
			u32 frag_num;
			unsigned char *va;
			struct sk_buff *skb;
			struct sk_buff *tail_skb;
		};
	};
	long: 64;
};

struct hns3_desc {
	union {
		__le64 addr;
		__le16 csum;
		struct {
			__le32 ts_nsec;
			__le32 ts_sec;
		};
	};
	union {
		struct {
			__le16 vlan_tag;
			__le16 send_size;
			union {
				__le32 type_cs_vlan_tso_len;
				struct {
					__u8 type_cs_vlan_tso;
					__u8 l2_len;
					__u8 l3_len;
					__u8 l4_len;
				};
			};
			__le16 outer_vlan_tag;
			__le16 tv;
			union {
				__le32 ol_type_vlan_len_msec;
				struct {
					__u8 ol_type_vlan_msec;
					__u8 ol2_len;
					__u8 ol3_len;
					__u8 ol4_len;
				};
			};
			__le32 paylen_ol4cs;
			__le16 bdtp_fe_sc_vld_ra_ri;
			__le16 mss_hw_csum;
		} tx;
		struct {
			__le32 l234_info;
			__le16 pkt_len;
			__le16 size;
			__le32 rss_hash;
			__le16 fd_id;
			__le16 vlan_tag;
			union {
				__le32 ol_info;
				struct {
					__le16 o_dm_vlan_id_fb;
					__le16 ot_vlan_tag;
				};
			};
			__le32 bd_base_info;
		} rx;
	};
};

struct hns3_desc_cb {
	dma_addr_t dma;
	void *buf;
	void *priv;
	union {
		u32 page_offset;
		u32 send_bytes;
	};
	u32 length;
	u16 reuse_flag;
	u16 refill;
	u16 type;
	u16 pagecnt_bias;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
};

struct hns3_enet_ring_group {
	struct hns3_enet_ring *ring;
	u64 total_bytes;
	u64 total_packets;
	u16 count;
	struct hns3_enet_coalesce coal;
	struct dim dim;
};

struct hns3_enet_tqp_vector {
	struct hnae3_handle *handle;
	u8 *mask_addr;
	int vector_irq;
	int irq_init_flag;
	u16 idx;
	struct napi_struct napi;
	struct hns3_enet_ring_group rx_group;
	struct hns3_enet_ring_group tx_group;
	cpumask_t affinity_mask;
	u16 num_tqps;
	struct irq_affinity_notify affinity_notify;
	char name[32];
	u64 event_cnt;
	long: 64;
	long: 64;
};

struct hns3_tx_spare {
	dma_addr_t dma;
	void *buf;
	u32 next_to_use;
	u32 next_to_clean;
	u32 last_to_clean;
	u32 len;
};

struct hns3_ring_param {
	u32 tx_desc_num;
	u32 rx_desc_num;
	u32 rx_buf_len;
};

struct hns3_sfp_type {
	u8 type;
	u8 ext_type;
};

enum e1000_mac_type {
	e1000_82571 = 0,
	e1000_82572 = 1,
	e1000_82573 = 2,
	e1000_82574 = 3,
	e1000_82583 = 4,
	e1000_80003es2lan = 5,
	e1000_ich8lan = 6,
	e1000_ich9lan = 7,
	e1000_ich10lan = 8,
	e1000_pchlan = 9,
	e1000_pch2lan = 10,
	e1000_pch_lpt = 11,
	e1000_pch_spt = 12,
	e1000_pch_cnp = 13,
	e1000_pch_tgp = 14,
	e1000_pch_adp = 15,
	e1000_pch_mtp = 16,
	e1000_pch_lnp = 17,
	e1000_pch_ptp = 18,
	e1000_pch_nvp = 19,
};

enum e1000_phy_type {
	e1000_phy_unknown = 0,
	e1000_phy_none = 1,
	e1000_phy_m88 = 2,
	e1000_phy_igp = 3,
	e1000_phy_igp_2 = 4,
	e1000_phy_gg82563 = 5,
	e1000_phy_igp_3 = 6,
	e1000_phy_ife = 7,
	e1000_phy_bm = 8,
	e1000_phy_82578 = 9,
	e1000_phy_82577 = 10,
	e1000_phy_82579 = 11,
	e1000_phy_i217 = 12,
};

enum e1000_1000t_rx_status {
	e1000_1000t_rx_status_not_ok = 0,
	e1000_1000t_rx_status_ok = 1,
	e1000_1000t_rx_status_undefined = 255,
};

enum e1000_ms_type {
	e1000_ms_hw_default = 0,
	e1000_ms_force_master = 1,
	e1000_ms_force_slave = 2,
	e1000_ms_auto = 3,
};

enum e1000_rev_polarity {
	e1000_rev_polarity_normal = 0,
	e1000_rev_polarity_reversed = 1,
	e1000_rev_polarity_undefined = 255,
};

enum e1000_smart_speed {
	e1000_smart_speed_default = 0,
	e1000_smart_speed_on = 1,
	e1000_smart_speed_off = 2,
};

enum e1000_media_type {
	e1000_media_type_unknown = 0,
	e1000_media_type_copper = 1,
	e1000_media_type_fiber = 2,
	e1000_media_type_internal_serdes = 3,
	e1000_num_media_types = 4,
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

enum e1000_serdes_link_state {
	e1000_serdes_link_down = 0,
	e1000_serdes_link_autoneg_progress = 1,
	e1000_serdes_link_autoneg_complete = 2,
	e1000_serdes_link_forced_up = 3,
};

enum e1000_fc_mode {
	e1000_fc_none = 0,
	e1000_fc_rx_pause = 1,
	e1000_fc_tx_pause = 2,
	e1000_fc_full = 3,
	e1000_fc_default = 255,
};

enum e1000_nvm_type {
	e1000_nvm_unknown = 0,
	e1000_nvm_none = 1,
	e1000_nvm_eeprom_spi = 2,
	e1000_nvm_flash_hw = 3,
	e1000_nvm_flash_sw = 4,
};

enum e1000_nvm_override {
	e1000_nvm_override_none = 0,
	e1000_nvm_override_spi_small = 1,
	e1000_nvm_override_spi_large = 2,
};

enum e1000_bus_width {
	e1000_bus_width_unknown = 0,
	e1000_bus_width_pcie_x1 = 1,
	e1000_bus_width_pcie_x2 = 2,
	e1000_bus_width_pcie_x4 = 4,
	e1000_bus_width_pcie_x8 = 8,
	e1000_bus_width_32 = 9,
	e1000_bus_width_64 = 10,
	e1000_bus_width_reserved = 11,
};

enum e1000_ulp_state {
	e1000_ulp_state_unknown = 0,
	e1000_ulp_state_off = 1,
	e1000_ulp_state_on = 2,
};

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	ETHTOOL_LINK_MODE_10baseT1L_Full_BIT = 92,
	ETHTOOL_LINK_MODE_800000baseCR8_Full_BIT = 93,
	ETHTOOL_LINK_MODE_800000baseKR8_Full_BIT = 94,
	ETHTOOL_LINK_MODE_800000baseDR8_Full_BIT = 95,
	ETHTOOL_LINK_MODE_800000baseDR8_2_Full_BIT = 96,
	ETHTOOL_LINK_MODE_800000baseSR8_Full_BIT = 97,
	ETHTOOL_LINK_MODE_800000baseVR8_Full_BIT = 98,
	ETHTOOL_LINK_MODE_10baseT1S_Full_BIT = 99,
	ETHTOOL_LINK_MODE_10baseT1S_Half_BIT = 100,
	ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT = 101,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 102,
};

struct e1000_dev_spec_82571 {
	bool laa_is_present;
	u32 smb_counter;
};

struct e1000_dev_spec_80003es2lan {
	bool mdic_wa_enable;
};

struct e1000_shadow_ram {
	u16 value;
	bool modified;
};

struct e1000_dev_spec_ich8lan {
	bool kmrn_lock_loss_workaround_enabled;
	struct e1000_shadow_ram shadow_ram[2048];
	bool nvm_k1_enabled;
	bool eee_disable;
	u16 eee_lp_ability;
	enum e1000_ulp_state ulp_state;
};

struct e1000_hw;

struct e1000_mac_operations {
	s32 (*id_led_init)(struct e1000_hw *);
	s32 (*blink_led)(struct e1000_hw *);
	bool (*check_mng_mode)(struct e1000_hw *);
	s32 (*check_for_link)(struct e1000_hw *);
	s32 (*cleanup_led)(struct e1000_hw *);
	void (*clear_hw_cntrs)(struct e1000_hw *);
	void (*clear_vfta)(struct e1000_hw *);
	s32 (*get_bus_info)(struct e1000_hw *);
	void (*set_lan_id)(struct e1000_hw *);
	s32 (*get_link_up_info)(struct e1000_hw *, u16 *, u16 *);
	s32 (*led_on)(struct e1000_hw *);
	s32 (*led_off)(struct e1000_hw *);
	void (*update_mc_addr_list)(struct e1000_hw *, u8 *, u32);
	s32 (*reset_hw)(struct e1000_hw *);
	s32 (*init_hw)(struct e1000_hw *);
	s32 (*setup_link)(struct e1000_hw *);
	s32 (*setup_physical_interface)(struct e1000_hw *);
	s32 (*setup_led)(struct e1000_hw *);
	void (*write_vfta)(struct e1000_hw *, u32, u32);
	void (*config_collision_dist)(struct e1000_hw *);
	int (*rar_set)(struct e1000_hw *, u8 *, u32);
	s32 (*read_mac_addr)(struct e1000_hw *);
	u32 (*rar_get_count)(struct e1000_hw *);
};

struct e1000_mac_info {
	struct e1000_mac_operations ops;
	u8 addr[6];
	u8 perm_addr[6];
	enum e1000_mac_type type;
	u32 collision_delta;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	u32 mc_filter_type;
	u32 tx_packet_delta;
	u32 txcw;
	u16 current_ifs_val;
	u16 ifs_max_val;
	u16 ifs_min_val;
	u16 ifs_ratio;
	u16 ifs_step_size;
	u16 mta_reg_count;
	u32 mta_shadow[128];
	u16 rar_entry_count;
	u8 forced_speed_duplex;
	bool adaptive_ifs;
	bool has_fwsm;
	bool arc_subsystem_valid;
	bool autoneg;
	bool autoneg_failed;
	bool get_link_status;
	bool in_ifs_mode;
	bool serdes_has_link;
	bool tx_pkt_filtering;
	enum e1000_serdes_link_state serdes_link_state;
};

struct e1000_fc_info {
	u32 high_water;
	u32 low_water;
	u16 pause_time;
	u16 refresh_time;
	bool send_xon;
	bool strict_ieee;
	enum e1000_fc_mode current_mode;
	enum e1000_fc_mode requested_mode;
};

struct e1000_phy_operations {
	s32 (*acquire)(struct e1000_hw *);
	s32 (*cfg_on_link_up)(struct e1000_hw *);
	s32 (*check_polarity)(struct e1000_hw *);
	s32 (*check_reset_block)(struct e1000_hw *);
	s32 (*commit)(struct e1000_hw *);
	s32 (*force_speed_duplex)(struct e1000_hw *);
	s32 (*get_cfg_done)(struct e1000_hw *);
	s32 (*get_cable_length)(struct e1000_hw *);
	s32 (*get_info)(struct e1000_hw *);
	s32 (*set_page)(struct e1000_hw *, u16);
	s32 (*read_reg)(struct e1000_hw *, u32, u16 *);
	s32 (*read_reg_locked)(struct e1000_hw *, u32, u16 *);
	s32 (*read_reg_page)(struct e1000_hw *, u32, u16 *);
	void (*release)(struct e1000_hw *);
	s32 (*reset)(struct e1000_hw *);
	s32 (*set_d0_lplu_state)(struct e1000_hw *, bool);
	s32 (*set_d3_lplu_state)(struct e1000_hw *, bool);
	s32 (*write_reg)(struct e1000_hw *, u32, u16);
	s32 (*write_reg_locked)(struct e1000_hw *, u32, u16);
	s32 (*write_reg_page)(struct e1000_hw *, u32, u16);
	void (*power_up)(struct e1000_hw *);
	void (*power_down)(struct e1000_hw *);
};

struct e1000_phy_info {
	struct e1000_phy_operations ops;
	enum e1000_phy_type type;
	enum e1000_1000t_rx_status local_rx;
	enum e1000_1000t_rx_status remote_rx;
	enum e1000_ms_type ms_type;
	enum e1000_ms_type original_ms_type;
	enum e1000_rev_polarity cable_polarity;
	enum e1000_smart_speed smart_speed;
	u32 addr;
	u32 id;
	u32 reset_delay_us;
	u32 revision;
	enum e1000_media_type media_type;
	u16 autoneg_advertised;
	u16 autoneg_mask;
	u16 cable_length;
	u16 max_cable_length;
	u16 min_cable_length;
	u8 mdix;
	bool disable_polarity_correction;
	bool is_mdix;
	bool polarity_correction;
	bool speed_downgraded;
	bool autoneg_wait_to_complete;
};

struct e1000_nvm_operations {
	s32 (*acquire)(struct e1000_hw *);
	s32 (*read)(struct e1000_hw *, u16, u16, u16 *);
	void (*release)(struct e1000_hw *);
	void (*reload)(struct e1000_hw *);
	s32 (*update)(struct e1000_hw *);
	s32 (*valid_led_default)(struct e1000_hw *, u16 *);
	s32 (*validate)(struct e1000_hw *);
	s32 (*write)(struct e1000_hw *, u16, u16, u16 *);
};

struct e1000_nvm_info {
	struct e1000_nvm_operations ops;
	enum e1000_nvm_type type;
	enum e1000_nvm_override override;
	u32 flash_bank_size;
	u32 flash_base_addr;
	u16 word_size;
	u16 delay_usec;
	u16 address_bits;
	u16 opcode_bits;
	u16 page_size;
};

struct e1000_bus_info {
	enum e1000_bus_width width;
	u16 func;
};

struct e1000_host_mng_dhcp_cookie {
	u32 signature;
	u8 status;
	u8 reserved0;
	u16 vlan_id;
	u32 reserved1;
	u16 reserved2;
	u8 reserved3;
	u8 checksum;
};

struct e1000_adapter;

struct e1000_hw {
	struct e1000_adapter *adapter;
	void *hw_addr;
	void *flash_address;
	struct e1000_mac_info mac;
	struct e1000_fc_info fc;
	struct e1000_phy_info phy;
	struct e1000_nvm_info nvm;
	struct e1000_bus_info bus;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	union {
		struct e1000_dev_spec_82571 e82571;
		struct e1000_dev_spec_80003es2lan e80003es2lan;
		struct e1000_dev_spec_ich8lan ich8lan;
	} dev_spec;
};

struct e1000_hw_stats {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorc;
	u64 gotc;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 tor;
	u64 tot;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
};

struct e1000_phy_stats {
	u32 idle_errors;
	u32 receive_errors;
};

struct e1000_phy_regs {
	u16 bmcr;
	u16 bmsr;
	u16 advertise;
	u16 lpa;
	u16 expansion;
	u16 ctrl1000;
	u16 stat1000;
	u16 estatus;
};

struct e1000_buffer;

struct e1000_ring {
	struct e1000_adapter *adapter;
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	u16 next_to_use;
	u16 next_to_clean;
	void *head;
	void *tail;
	struct e1000_buffer *buffer_info;
	char name[21];
	u32 ims_val;
	u32 itr_val;
	void *itr_register;
	int set_itr;
	struct sk_buff *rx_skb_top;
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	u64 mask;
	u32 mult;
	u32 shift;
};

struct timecounter {
	const struct cyclecounter *cc;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

struct ptp_pin_desc;

struct system_device_crosststamp;

struct ptp_clock_info {
	struct module *owner;
	char name[32];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long);
	int (*adjphase)(struct ptp_clock_info *, s32);
	s32 (*getmaxphase)(struct ptp_clock_info *);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*getcycles64)(struct ptp_clock_info *, struct timespec64 *);
	int (*getcyclesx64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosscycles)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long (*do_aux_work)(struct ptp_clock_info *);
};

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

struct e1000_info;

struct msix_entry;

struct ptp_clock;

struct e1000_adapter {
	struct timer_list watchdog_timer;
	struct timer_list phy_info_timer;
	struct timer_list blink_timer;
	struct work_struct reset_task;
	struct work_struct watchdog_task;
	const struct e1000_info *ei;
	unsigned long active_vlans[64];
	u32 bd_number;
	u32 rx_buffer_len;
	u16 mng_vlan_id;
	u16 link_speed;
	u16 link_duplex;
	u16 eeprom_vers;
	unsigned long state;
	u32 itr;
	u32 itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	long: 64;
	long: 64;
	long: 64;
	struct e1000_ring *tx_ring;
	u32 tx_fifo_limit;
	struct napi_struct napi;
	unsigned int uncorr_errors;
	unsigned int corr_errors;
	unsigned int restart_queue;
	u32 txd_cmd;
	bool detect_tx_hung;
	bool tx_hang_recheck;
	u8 tx_timeout_factor;
	u32 tx_int_delay;
	u32 tx_abs_int_delay;
	unsigned int total_tx_bytes;
	unsigned int total_tx_packets;
	unsigned int total_rx_bytes;
	unsigned int total_rx_packets;
	u64 tpt_old;
	u64 colc_old;
	u32 gotc;
	u64 gotc_old;
	u32 tx_timeout_count;
	u32 tx_fifo_head;
	u32 tx_head_addr;
	u32 tx_fifo_size;
	u32 tx_dma_failed;
	u32 tx_hwtstamp_timeouts;
	u32 tx_hwtstamp_skipped;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	bool (*clean_rx)(struct e1000_ring *, int *, int);
	void (*alloc_rx_buf)(struct e1000_ring *, int, gfp_t);
	struct e1000_ring *rx_ring;
	u32 rx_int_delay;
	u32 rx_abs_int_delay;
	u64 hw_csum_err;
	u64 hw_csum_good;
	u64 rx_hdr_split;
	u32 gorc;
	u64 gorc_old;
	u32 alloc_rx_buff_failed;
	u32 rx_dma_failed;
	u32 rx_hwtstamp_cleared;
	unsigned int rx_ps_pages;
	u16 rx_ps_bsize0;
	u32 max_frame_size;
	u32 min_frame_size;
	struct net_device *netdev;
	struct pci_dev *pdev;
	struct e1000_hw hw;
	spinlock_t stats64_lock;
	struct e1000_hw_stats stats;
	struct e1000_phy_info phy_info;
	struct e1000_phy_stats phy_stats;
	struct e1000_phy_regs phy_regs;
	struct e1000_ring test_tx_ring;
	struct e1000_ring test_rx_ring;
	u32 test_icr;
	u32 msg_enable;
	unsigned int num_vectors;
	struct msix_entry *msix_entries;
	int int_mode;
	u32 eiac_mask;
	u32 eeprom_wol;
	u32 wol;
	u32 pba;
	u32 max_hw_frame_size;
	bool fc_autoneg;
	unsigned int flags;
	unsigned int flags2;
	struct work_struct downshift_task;
	struct work_struct update_phy_task;
	struct work_struct print_hang_task;
	int phy_hang_count;
	u16 tx_ring_count;
	u16 rx_ring_count;
	struct hwtstamp_config hwtstamp_config;
	struct delayed_work systim_overflow_work;
	struct sk_buff *tx_hwtstamp_skb;
	unsigned long tx_hwtstamp_start;
	struct work_struct tx_hwtstamp_work;
	spinlock_t systim_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct pm_qos_request pm_qos_req;
	long ptp_delta;
	u16 eee_advert;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct e1000_info {
	enum e1000_mac_type mac;
	unsigned int flags;
	unsigned int flags2;
	u32 pba;
	u32 max_hw_frame_size;
	s32 (*get_variants)(struct e1000_adapter *);
	const struct e1000_mac_operations *mac_ops;
	const struct e1000_phy_operations *phy_ops;
	const struct e1000_nvm_operations *nvm_ops;
};

struct e1000_ps_page;

struct e1000_buffer {
	dma_addr_t dma;
	struct sk_buff *skb;
	union {
		struct {
			unsigned long time_stamp;
			u16 length;
			u16 next_to_watch;
			unsigned int segs;
			unsigned int bytecount;
			u16 mapped_as_page;
		};
		struct {
			struct e1000_ps_page *ps_pages;
			struct page *page;
		};
	};
};

struct e1000_ps_page {
	struct page *page;
	u64 dma;
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct mdiobb_ctrl;

struct mdiobb_ops {
	struct module *owner;
	void (*set_mdc)(struct mdiobb_ctrl *, int);
	void (*set_mdio_dir)(struct mdiobb_ctrl *, int);
	void (*set_mdio_data)(struct mdiobb_ctrl *, int);
	int (*get_mdio_data)(struct mdiobb_ctrl *);
};

struct mdiobb_ctrl {
	const struct mdiobb_ops *ops;
	unsigned int override_op_c22;
	u8 op_c22_read;
	u8 op_c22_write;
};

struct ravb_hw_info {
	void (*rx_ring_free)(struct net_device *, int);
	void (*rx_ring_format)(struct net_device *, int);
	void * (*alloc_rx_desc)(struct net_device *, int);
	bool (*receive)(struct net_device *, int *, int);
	void (*set_rate)(struct net_device *);
	int (*set_feature)(struct net_device *, netdev_features_t);
	int (*dmac_init)(struct net_device *);
	void (*emac_init)(struct net_device *);
	const char (*gstrings_stats)[32];
	size_t gstrings_size;
	netdev_features_t net_hw_features;
	netdev_features_t net_features;
	int stats_len;
	size_t max_rx_len;
	u32 tccr_mask;
	u32 rx_max_buf_size;
	unsigned int aligned_tx: 1;
	unsigned int internal_delay: 1;
	unsigned int tx_counters: 1;
	unsigned int carrier_counters: 1;
	unsigned int multi_irqs: 1;
	unsigned int irq_en_dis: 1;
	unsigned int err_mgmt_irqs: 1;
	unsigned int gptp: 1;
	unsigned int ccc_gac: 1;
	unsigned int gptp_ref_clk: 1;
	unsigned int nc_queues: 1;
	unsigned int magic_pkt: 1;
	unsigned int half_duplex: 1;
};

enum ravb_reg {
	CCC = 0,
	DBAT = 4,
	DLR = 8,
	CSR = 12,
	CDAR0 = 16,
	CDAR1 = 20,
	CDAR2 = 24,
	CDAR3 = 28,
	CDAR4 = 32,
	CDAR5 = 36,
	CDAR6 = 40,
	CDAR7 = 44,
	CDAR8 = 48,
	CDAR9 = 52,
	CDAR10 = 56,
	CDAR11 = 60,
	CDAR12 = 64,
	CDAR13 = 68,
	CDAR14 = 72,
	CDAR15 = 76,
	CDAR16 = 80,
	CDAR17 = 84,
	CDAR18 = 88,
	CDAR19 = 92,
	CDAR20 = 96,
	CDAR21 = 100,
	ESR = 136,
	APSR = 140,
	RCR = 144,
	RQC0 = 148,
	RQC1 = 152,
	RQC2 = 156,
	RQC3 = 160,
	RQC4 = 164,
	RPC = 176,
	RTC = 180,
	UFCW = 188,
	UFCS = 192,
	UFCV0 = 196,
	UFCV1 = 200,
	UFCV2 = 204,
	UFCV3 = 208,
	UFCV4 = 212,
	UFCD0 = 224,
	UFCD1 = 228,
	UFCD2 = 232,
	UFCD3 = 236,
	UFCD4 = 240,
	SFO = 252,
	SFP0 = 256,
	SFP1 = 260,
	SFP2 = 264,
	SFP3 = 268,
	SFP4 = 272,
	SFP5 = 276,
	SFP6 = 280,
	SFP7 = 284,
	SFP8 = 288,
	SFP9 = 292,
	SFP10 = 296,
	SFP11 = 300,
	SFP12 = 304,
	SFP13 = 308,
	SFP14 = 312,
	SFP15 = 316,
	SFP16 = 320,
	SFP17 = 324,
	SFP18 = 328,
	SFP19 = 332,
	SFP20 = 336,
	SFP21 = 340,
	SFP22 = 344,
	SFP23 = 348,
	SFP24 = 352,
	SFP25 = 356,
	SFP26 = 360,
	SFP27 = 364,
	SFP28 = 368,
	SFP29 = 372,
	SFP30 = 376,
	SFP31 = 380,
	SFM0 = 448,
	SFM1 = 452,
	TGC = 768,
	TCCR = 772,
	TSR = 776,
	TFA0 = 784,
	TFA1 = 788,
	TFA2 = 792,
	CIVR0 = 800,
	CIVR1 = 804,
	CDVR0 = 808,
	CDVR1 = 812,
	CUL0 = 816,
	CUL1 = 820,
	CLL0 = 824,
	CLL1 = 828,
	DIC = 848,
	DIS = 852,
	EIC = 856,
	EIS = 860,
	RIC0 = 864,
	RIS0 = 868,
	RIC1 = 872,
	RIS1 = 876,
	RIC2 = 880,
	RIS2 = 884,
	TIC = 888,
	TIS = 892,
	ISS = 896,
	CIE = 900,
	GCCR = 912,
	GMTT = 916,
	GPTC = 920,
	GTI = 924,
	GTO0 = 928,
	GTO1 = 932,
	GTO2 = 936,
	GIC = 940,
	GIS = 944,
	GCPT = 948,
	GCT0 = 952,
	GCT1 = 956,
	GCT2 = 960,
	GIE = 972,
	GID = 976,
	DIL = 1088,
	RIE0 = 1120,
	RID0 = 1124,
	RIE2 = 1136,
	RID2 = 1140,
	TIE = 1144,
	TID = 1148,
	ECMR = 1280,
	RFLR = 1288,
	ECSR = 1296,
	ECSIPR = 1304,
	PIR = 1312,
	PSR = 1320,
	PIPR = 1324,
	CXR31 = 1328,
	CXR35 = 1344,
	MPR = 1368,
	PFTCR = 1372,
	PFRCR = 1376,
	GECMR = 1456,
	MAHR = 1472,
	MALR = 1480,
	TROCR = 1792,
	CXR41 = 1800,
	CXR42 = 1808,
	CEFCR = 1856,
	FRECR = 1864,
	TSFRCR = 1872,
	TLFRCR = 1880,
	RFCR = 1888,
	MAFCR = 1912,
	CSR0 = 2048,
};

enum RAVB_QUEUE {
	RAVB_BE = 0,
	RAVB_NC = 1,
};

enum GCCR_BIT {
	GCCR_TCR = 3,
	GCCR_TCR_NOREQ = 0,
	GCCR_TCR_RESET = 1,
	GCCR_TCR_CAPTURE = 3,
	GCCR_LTO = 4,
	GCCR_LTI = 8,
	GCCR_LPTC = 16,
	GCCR_LMTT = 32,
	GCCR_TCSS = 768,
	GCCR_TCSS_GPTP = 0,
	GCCR_TCSS_ADJGPTP = 256,
	GCCR_TCSS_AVTP = 512,
};

enum DIE_DT {
	DT_FMID = 64,
	DT_FSTART = 80,
	DT_FEND = 96,
	DT_FSINGLE = 112,
	DT_LINK = 128,
	DT_LINKFIX = 144,
	DT_EOS = 160,
	DT_FEMPTY = 192,
	DT_FEMPTY_IS = 208,
	DT_FEMPTY_IC = 224,
	DT_FEMPTY_ND = 240,
	DT_LEMPTY = 32,
	DT_EEMPTY = 48,
};

enum CSR_BIT {
	CSR_OPS = 15,
	CSR_OPS_RESET = 1,
	CSR_OPS_CONFIG = 2,
	CSR_OPS_OPERATION = 4,
	CSR_OPS_STANDBY = 8,
	CSR_DTS = 256,
	CSR_TPO0 = 65536,
	CSR_TPO1 = 131072,
	CSR_TPO2 = 262144,
	CSR_TPO3 = 524288,
	CSR_RPO = 1048576,
};

enum CCC_BIT {
	CCC_OPC = 3,
	CCC_OPC_RESET = 0,
	CCC_OPC_CONFIG = 1,
	CCC_OPC_OPERATION = 2,
	CCC_GAC = 128,
	CCC_DTSR = 256,
	CCC_CSEL = 196608,
	CCC_CSEL_HPB = 65536,
	CCC_CSEL_ETH_TX = 131072,
	CCC_CSEL_GMII_REF = 196608,
	CCC_LBME = 16777216,
};

enum ECMR_BIT {
	ECMR_PRM = 1,
	ECMR_DM = 2,
	ECMR_TE = 32,
	ECMR_RE = 64,
	ECMR_MPDE = 512,
	ECMR_TXF = 65536,
	ECMR_RXF = 131072,
	ECMR_PFR = 262144,
	ECMR_ZPF = 524288,
	ECMR_RZPF = 1048576,
	ECMR_DPAD = 2097152,
	ECMR_RCSC = 8388608,
	ECMR_RCPT = 33554432,
	ECMR_TRCCM = 67108864,
};

enum TX_DS_TAGL_BIT {
	TX_DS = 4095,
	TX_TAGL = 61440,
};

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

enum ISS_BIT {
	ISS_FRS = 1,
	ISS_FTS = 4,
	ISS_ES = 64,
	ISS_MS = 128,
	ISS_TFUS = 256,
	ISS_TFWS = 512,
	ISS_RFWS = 4096,
	ISS_CGIS = 8192,
	ISS_DPS1 = 131072,
	ISS_DPS2 = 262144,
	ISS_DPS3 = 524288,
	ISS_DPS4 = 1048576,
	ISS_DPS5 = 2097152,
	ISS_DPS6 = 4194304,
	ISS_DPS7 = 8388608,
	ISS_DPS8 = 16777216,
	ISS_DPS9 = 33554432,
	ISS_DPS10 = 67108864,
	ISS_DPS11 = 134217728,
	ISS_DPS12 = 268435456,
	ISS_DPS13 = 536870912,
	ISS_DPS14 = 1073741824,
	ISS_DPS15 = 2147483648,
};

enum TIS_BIT {
	TIS_FTF0 = 1,
	TIS_FTF1 = 2,
	TIS_TFUF = 256,
	TIS_TFWF = 512,
	TIS_RESERVED = 4293980400,
};

enum TSR_BIT {
	TSR_CCS0 = 3,
	TSR_CCS1 = 12,
	TSR_TFFL = 1792,
};

enum TFA2_BIT {
	TFA2_TSV = 65535,
	TFA2_TST = 67043328,
};

enum TCCR_BIT {
	TCCR_TSRQ0 = 1,
	TCCR_TSRQ1 = 2,
	TCCR_TSRQ2 = 4,
	TCCR_TSRQ3 = 8,
	TCCR_TFEN = 256,
	TCCR_TFR = 512,
};

enum ECSR_BIT {
	ECSR_ICD = 1,
	ECSR_MPD = 2,
	ECSR_LCHNG = 4,
	ECSR_PHYI = 8,
	ECSR_PFRI = 16,
};

enum PSR_BIT {
	PSR_LMON = 1,
};

enum EIS_BIT {
	EIS_MREF = 1,
	EIS_MTEF = 2,
	EIS_QEF = 4,
	EIS_SEF = 8,
	EIS_CLLF0 = 16,
	EIS_CLLF1 = 32,
	EIS_CULF0 = 64,
	EIS_CULF1 = 128,
	EIS_TFFF = 256,
	EIS_QFS = 65536,
	EIS_RESERVED = 4294899712,
};

enum RIS2_BIT {
	RIS2_QFF0 = 1,
	RIS2_QFF1 = 2,
	RIS2_QFF2 = 4,
	RIS2_QFF3 = 8,
	RIS2_QFF4 = 16,
	RIS2_QFF5 = 32,
	RIS2_QFF6 = 64,
	RIS2_QFF7 = 128,
	RIS2_QFF8 = 256,
	RIS2_QFF9 = 512,
	RIS2_QFF10 = 1024,
	RIS2_QFF11 = 2048,
	RIS2_QFF12 = 4096,
	RIS2_QFF13 = 8192,
	RIS2_QFF14 = 16384,
	RIS2_QFF15 = 32768,
	RIS2_QFF16 = 65536,
	RIS2_QFF17 = 131072,
	RIS2_RFFF = 2147483648,
	RIS2_RESERVED = 2147221504,
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_HW_TSTAMP_USE_CYCLES = 8,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_HW_TSTAMP_NETDEV = 32,
	SKBTX_SCHED_TSTAMP = 64,
};

enum TX_TAGH_TSR_BIT {
	TX_TAGH = 63,
	TX_TSR = 64,
};

enum GTI_BIT {
	GTI_TIV = 268435455,
};

enum APSR_BIT {
	APSR_MEMS = 2,
	APSR_CMSW = 16,
	APSR_RDM = 8192,
	APSR_TDM = 16384,
};

enum PIR_BIT {
	PIR_MDC = 1,
	PIR_MMD = 2,
	PIR_MDO = 4,
	PIR_MDI = 8,
};

enum RIS0_BIT {
	RIS0_FRF0 = 1,
	RIS0_FRF1 = 2,
	RIS0_FRF2 = 4,
	RIS0_FRF3 = 8,
	RIS0_FRF4 = 16,
	RIS0_FRF5 = 32,
	RIS0_FRF6 = 64,
	RIS0_FRF7 = 128,
	RIS0_FRF8 = 256,
	RIS0_FRF9 = 512,
	RIS0_FRF10 = 1024,
	RIS0_FRF11 = 2048,
	RIS0_FRF12 = 4096,
	RIS0_FRF13 = 8192,
	RIS0_FRF14 = 16384,
	RIS0_FRF15 = 32768,
	RIS0_FRF16 = 65536,
	RIS0_FRF17 = 131072,
	RIS0_RESERVED = 4294705152,
};

enum RX_DS_CC_BIT {
	RX_DS = 4095,
	RX_TR = 4096,
	RX_EI = 8192,
	RX_PS = 49152,
};

enum MSC_BIT {
	MSC_CRC = 1,
	MSC_RFE = 2,
	MSC_RTSF = 4,
	MSC_RTLF = 8,
	MSC_FRE = 16,
	MSC_CRL = 32,
	MSC_CEEF = 64,
	MSC_MC = 128,
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_CONSUMED = 4,
};

enum GECMR_BIT {
	GECMR_SPEED = 1,
	GECMR_SPEED_100 = 0,
	GECMR_SPEED_1000 = 1,
	GBETH_GECMR_SPEED = 48,
	GBETH_GECMR_SPEED_10 = 0,
	GBETH_GECMR_SPEED_100 = 16,
	GBETH_GECMR_SPEED_1000 = 32,
};

enum RCR_BIT {
	RCR_EFFS = 1,
	RCR_ENCF = 2,
	RCR_ESF = 12,
	RCR_ETS0 = 16,
	RCR_ETS2 = 32,
	RCR_RFCL = 536805376,
};

enum TGC_BIT {
	TGC_TSM0 = 1,
	TGC_TSM1 = 2,
	TGC_TSM2 = 4,
	TGC_TSM3 = 8,
	TGC_TQP = 48,
	TGC_TQP_NONAVB = 0,
	TGC_TQP_AVBMODE1 = 16,
	TGC_TQP_AVBMODE2 = 48,
	TGC_TBD0 = 768,
	TGC_TBD1 = 12288,
	TGC_TBD2 = 196608,
	TGC_TBD3 = 3145728,
};

enum CIE_BIT {
	CIE_CRIE = 1,
	CIE_CTIE = 256,
	CIE_RQFM = 65536,
	CIE_CL0M = 131072,
	CIE_RFWL = 262144,
	CIE_RFFL = 524288,
};

enum RIC0_BIT {
	RIC0_FRE0 = 1,
	RIC0_FRE1 = 2,
	RIC0_FRE2 = 4,
	RIC0_FRE3 = 8,
	RIC0_FRE4 = 16,
	RIC0_FRE5 = 32,
	RIC0_FRE6 = 64,
	RIC0_FRE7 = 128,
	RIC0_FRE8 = 256,
	RIC0_FRE9 = 512,
	RIC0_FRE10 = 1024,
	RIC0_FRE11 = 2048,
	RIC0_FRE12 = 4096,
	RIC0_FRE13 = 8192,
	RIC0_FRE14 = 16384,
	RIC0_FRE15 = 32768,
	RIC0_FRE16 = 65536,
	RIC0_FRE17 = 131072,
};

enum RIC2_BIT {
	RIC2_QFE0 = 1,
	RIC2_QFE1 = 2,
	RIC2_QFE2 = 4,
	RIC2_QFE3 = 8,
	RIC2_QFE4 = 16,
	RIC2_QFE5 = 32,
	RIC2_QFE6 = 64,
	RIC2_QFE7 = 128,
	RIC2_QFE8 = 256,
	RIC2_QFE9 = 512,
	RIC2_QFE10 = 1024,
	RIC2_QFE11 = 2048,
	RIC2_QFE12 = 4096,
	RIC2_QFE13 = 8192,
	RIC2_QFE14 = 16384,
	RIC2_QFE15 = 32768,
	RIC2_QFE16 = 65536,
	RIC2_QFE17 = 131072,
	RIC2_RFFE = 2147483648,
};

enum TIC_BIT {
	TIC_FTE0 = 1,
	TIC_FTE1 = 2,
	TIC_TFUE = 256,
	TIC_TFWE = 512,
};

enum ECSIPR_BIT {
	ECSIPR_ICDIP = 1,
	ECSIPR_MPDIP = 2,
	ECSIPR_LCHNGIP = 4,
};

enum CXR35_BIT {
	CXR35_SEL_XMII = 3,
	CXR35_SEL_XMII_RGMII = 0,
	CXR35_SEL_XMII_MII = 2,
	CXR35_HALFCYC_CLKSW = 4294901760,
};

enum CXR31_BIT {
	CXR31_SEL_LINK0 = 1,
	CXR31_SEL_LINK1 = 8,
};

enum CSR0_BIT {
	CSR0_TPE = 16,
	CSR0_RPE = 32,
};

struct ravb_ptp_perout {
	u32 target;
	u32 period;
};

struct ravb_ptp {
	struct ptp_clock *clock;
	struct ptp_clock_info info;
	u32 default_addend;
	u32 current_addend;
	int extts[1];
	struct ravb_ptp_perout perout[1];
};

struct ravb_desc;

struct ravb_rx_desc;

struct ravb_ex_rx_desc;

struct ravb_tx_desc;

struct ravb_private {
	struct net_device *ndev;
	struct platform_device *pdev;
	void *addr;
	struct clk *clk;
	struct clk *refclk;
	struct clk *gptp_clk;
	struct mdiobb_ctrl mdiobb;
	u32 num_rx_ring[2];
	u32 num_tx_ring[2];
	u32 desc_bat_size;
	dma_addr_t desc_bat_dma;
	struct ravb_desc *desc_bat;
	dma_addr_t rx_desc_dma[2];
	dma_addr_t tx_desc_dma[2];
	struct ravb_rx_desc *gbeth_rx_ring;
	struct ravb_ex_rx_desc *rx_ring[2];
	struct ravb_tx_desc *tx_ring[2];
	void *tx_align[2];
	struct sk_buff *rx_1st_skb;
	struct sk_buff **rx_skb[2];
	struct sk_buff **tx_skb[2];
	u32 rx_over_errors;
	u32 rx_fifo_errors;
	struct net_device_stats stats[2];
	u32 tstamp_tx_ctrl;
	u32 tstamp_rx_ctrl;
	struct list_head ts_skb_list;
	u32 ts_skb_tag;
	struct ravb_ptp ptp;
	spinlock_t lock;
	u32 cur_rx[2];
	u32 dirty_rx[2];
	u32 cur_tx[2];
	u32 dirty_tx[2];
	struct napi_struct napi[2];
	struct work_struct work;
	struct mii_bus *mii_bus;
	int link;
	phy_interface_t phy_interface;
	int msg_enable;
	int speed;
	int emac_irq;
	int erra_irq;
	int mgmta_irq;
	int rx_irqs[2];
	int tx_irqs[2];
	unsigned int no_avb_link: 1;
	unsigned int avb_link_active_low: 1;
	unsigned int wol_enabled: 1;
	unsigned int rxcidm: 1;
	unsigned int txcidm: 1;
	unsigned int rgmii_override: 1;
	unsigned int num_tx_desc;
	int duplex;
	const struct ravb_hw_info *info;
	struct reset_control *rstc;
};

struct ravb_desc {
	__le16 ds;
	u8 cc;
	u8 die_dt;
	__le32 dptr;
};

struct ravb_rx_desc {
	__le16 ds_cc;
	u8 msc;
	u8 die_dt;
	__le32 dptr;
};

struct ravb_ex_rx_desc {
	__le16 ds_cc;
	u8 msc;
	u8 die_dt;
	__le32 dptr;
	__le32 ts_n;
	__le32 ts_sl;
	__le16 ts_sh;
	__le16 res;
};

struct ravb_tx_desc {
	__le16 ds_tagl;
	u8 tagh_tsr;
	u8 die_dt;
	__le32 dptr;
};

struct ravb_tstamp_skb {
	struct list_head list;
	struct sk_buff *skb;
	u16 tag;
};

typedef __u16 __sum16;

typedef enum gro_result gro_result_t;

struct vfio_pci_core_device;

struct perm_bits {
	u8 *virt;
	u8 *write;
	int (*readfn)(struct vfio_pci_core_device *, int, int, struct perm_bits *, int, __le32 *);
	int (*writefn)(struct vfio_pci_core_device *, int, int, struct perm_bits *, int, __le32);
};

struct iommufd_access;

struct vfio_device_ops;

struct vfio_migration_ops;

struct vfio_log_ops;

struct vfio_group;

struct vfio_device_set;

struct vfio_device {
	struct device *dev;
	const struct vfio_device_ops *ops;
	const struct vfio_migration_ops *mig_ops;
	const struct vfio_log_ops *log_ops;
	struct vfio_group *group;
	struct list_head group_next;
	struct list_head iommu_entry;
	struct vfio_device_set *dev_set;
	struct list_head dev_set_list;
	unsigned int migration_flags;
	struct kvm___2 *kvm;
	unsigned int index;
	struct device device;
	refcount_t refcount;
	unsigned int open_count;
	struct completion comp;
	struct iommufd_access *iommufd_access;
	void (*put_kvm)(struct kvm___2 *);
	u8 cdev_opened: 1;
};

struct vfio_pci_region;

struct pci_saved_state;

struct vfio_pci_vf_token;

struct vfio_pci_core_device {
	struct vfio_device vdev;
	struct pci_dev *pdev;
	void *barmap[6];
	bool bar_mmap_supported[6];
	u8 *pci_config_map;
	u8 *vconfig;
	struct perm_bits *msi_perm;
	spinlock_t irqlock;
	struct mutex igate;
	struct xarray ctx;
	int irq_type;
	int num_regions;
	struct vfio_pci_region *region;
	u8 msi_qmax;
	u8 msix_bar;
	u16 msix_size;
	u32 msix_offset;
	u32 rbar[7];
	bool has_dyn_msix: 1;
	bool pci_2_3: 1;
	bool virq_disabled: 1;
	bool reset_works: 1;
	bool extended_caps: 1;
	bool bardirty: 1;
	bool has_vga: 1;
	bool needs_reset: 1;
	bool nointx: 1;
	bool needs_pm_restore: 1;
	bool pm_intx_masked: 1;
	bool pm_runtime_engaged: 1;
	struct pci_saved_state *pci_saved_state;
	struct pci_saved_state *pm_save;
	int ioeventfds_nr;
	struct eventfd_ctx *err_trigger;
	struct eventfd_ctx *req_trigger;
	struct eventfd_ctx *pm_wake_eventfd_ctx;
	struct list_head dummy_resources_list;
	struct mutex ioeventfds_lock;
	struct list_head ioeventfds_list;
	struct vfio_pci_vf_token *vf_token;
	struct list_head sriov_pfs_item;
	struct vfio_pci_core_device *sriov_pf_core_dev;
	struct notifier_block nb;
	struct mutex vma_lock;
	struct list_head vma_list;
	struct rw_semaphore memory_lock;
};

struct iommufd_ctx;

struct vfio_device_ops {
	char *name;
	int (*init)(struct vfio_device *);
	void (*release)(struct vfio_device *);
	int (*bind_iommufd)(struct vfio_device *, struct iommufd_ctx *, u32 *);
	void (*unbind_iommufd)(struct vfio_device *);
	int (*attach_ioas)(struct vfio_device *, u32 *);
	void (*detach_ioas)(struct vfio_device *);
	int (*open_device)(struct vfio_device *);
	void (*close_device)(struct vfio_device *);
	ssize_t (*read)(struct vfio_device *, char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	ssize_t (*write)(struct vfio_device *, const char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);
	long (*ioctl)(struct vfio_device *, unsigned int, unsigned long);
	int (*mmap)(struct vfio_device *, struct vm_area_struct *);
	void (*request)(struct vfio_device *, unsigned int);
	int (*match)(struct vfio_device *, char *);
	void (*dma_unmap)(struct vfio_device *, u64, u64);
	int (*device_feature)(struct vfio_device *, u32, void __attribute__((btf_type_tag("user"))) *, size_t);
};

enum vfio_device_mig_state {
	VFIO_DEVICE_STATE_ERROR = 0,
	VFIO_DEVICE_STATE_STOP = 1,
	VFIO_DEVICE_STATE_RUNNING = 2,
	VFIO_DEVICE_STATE_STOP_COPY = 3,
	VFIO_DEVICE_STATE_RESUMING = 4,
	VFIO_DEVICE_STATE_RUNNING_P2P = 5,
	VFIO_DEVICE_STATE_PRE_COPY = 6,
	VFIO_DEVICE_STATE_PRE_COPY_P2P = 7,
};

struct vfio_migration_ops {
	struct file * (*migration_set_state)(struct vfio_device *, enum vfio_device_mig_state);
	int (*migration_get_state)(struct vfio_device *, enum vfio_device_mig_state *);
	int (*migration_get_data_size)(struct vfio_device *, unsigned long *);
};

struct vfio_log_ops {
	int (*log_start)(struct vfio_device *, struct rb_root_cached *, u32, u64 *);
	int (*log_stop)(struct vfio_device *);
	int (*log_read_and_clear)(struct vfio_device *, unsigned long, unsigned long, struct iova_bitmap *);
};

struct vfio_device_set {
	void *set_id;
	struct mutex lock;
	struct list_head device_list;
	unsigned int device_count;
};

struct vfio_pci_regops;

struct vfio_pci_region {
	u32 type;
	u32 subtype;
	const struct vfio_pci_regops *ops;
	void *data;
	size_t size;
	u32 flags;
};

struct vfio_info_cap;

struct vfio_pci_regops {
	ssize_t (*rw)(struct vfio_pci_core_device *, char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *, bool);
	void (*release)(struct vfio_pci_core_device *, struct vfio_pci_region *);
	int (*mmap)(struct vfio_pci_core_device *, struct vfio_pci_region *, struct vm_area_struct *);
	int (*add_capability)(struct vfio_pci_core_device *, struct vfio_pci_region *, struct vfio_info_cap *);
};

struct vfio_info_cap_header;

struct vfio_info_cap {
	struct vfio_info_cap_header *buf;
	size_t size;
};

struct vfio_info_cap_header {
	__u16 id;
	__u16 version;
	__u32 next;
};

enum {
	VFIO_PCI_INTX_IRQ_INDEX = 0,
	VFIO_PCI_MSI_IRQ_INDEX = 1,
	VFIO_PCI_MSIX_IRQ_INDEX = 2,
	VFIO_PCI_ERR_IRQ_INDEX = 3,
	VFIO_PCI_REQ_IRQ_INDEX = 4,
	VFIO_PCI_NUM_IRQS = 5,
};

struct usbdrv_wrap {
	struct device_driver driver;
	int for_devices;
};

struct usb_device;

struct usb_device_id;

struct usb_device_driver {
	const char *name;
	bool (*match)(struct usb_device *);
	int (*probe)(struct usb_device *);
	void (*disconnect)(struct usb_device *);
	int (*suspend)(struct usb_device *, pm_message_t);
	int (*resume)(struct usb_device *, pm_message_t);
	const struct attribute_group **dev_groups;
	struct usbdrv_wrap drvwrap;
	const struct usb_device_id *id_table;
	unsigned int supports_autosuspend: 1;
	unsigned int generic_subclass: 1;
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_ssp_rate {
	USB_SSP_GEN_UNKNOWN = 0,
	USB_SSP_GEN_2x1 = 1,
	USB_SSP_GEN_1x2 = 2,
	USB_SSP_GEN_2x2 = 3,
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct ep_device;

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	long: 0;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
	long: 0;
} __attribute__((packed));

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_tt;

struct usb_bus;

struct usb_host_bos;

struct usb_host_config;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	enum usb_ssp_rate ssp_rate;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	unsigned short bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int reset_in_progress: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int lpm_capable: 1;
	unsigned int lpm_devinit_allow: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	unsigned long active_duration;
	unsigned long connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	int slot_id;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
	unsigned int use_generic_driver: 1;
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_devmap {
	unsigned long devicemap[2];
};

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	struct usb_devmap devmap;
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
};

struct usb_bos_descriptor;

struct usb_ext_cap_descriptor;

struct usb_ss_cap_descriptor;

struct usb_ssp_cap_descriptor;

struct usb_ss_container_id_descriptor;

struct usb_ptm_cap_descriptor;

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	union {
		__le32 legacy_padding;
		struct {
			struct {} __empty_bmSublinkSpeedAttr;
			__le32 bmSublinkSpeedAttr[0];
		};
	};
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_interface_assoc_descriptor;

struct usb_interface;

struct usb_interface_cache;

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

enum usb_wireless_status {
	USB_WIRELESS_STATUS_NA = 0,
	USB_WIRELESS_STATUS_DISCONNECTED = 1,
	USB_WIRELESS_STATUS_CONNECTED = 2,
};

struct usb_host_interface;

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	enum usb_wireless_status wireless_status;
	struct work_struct wireless_status_work;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
};

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_device_id {
	__u16 match_flags;
	__u16 idVendor;
	__u16 idProduct;
	__u16 bcdDevice_lo;
	__u16 bcdDevice_hi;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 bInterfaceNumber;
	kernel_ulong_t driver_info;
};

enum usb_phy_type {
	USB_PHY_TYPE_UNDEFINED = 0,
	USB_PHY_TYPE_USB2 = 1,
	USB_PHY_TYPE_USB3 = 2,
};

enum usb_phy_events {
	USB_EVENT_NONE = 0,
	USB_EVENT_VBUS = 1,
	USB_EVENT_ID = 2,
	USB_EVENT_CHARGER = 3,
	USB_EVENT_ENUMERATED = 4,
};

enum usb_charger_type {
	UNKNOWN_TYPE = 0,
	SDP_TYPE = 1,
	DCP_TYPE = 2,
	CDP_TYPE = 3,
	ACA_TYPE = 4,
};

enum usb_charger_state {
	USB_CHARGER_DEFAULT = 0,
	USB_CHARGER_PRESENT = 1,
	USB_CHARGER_ABSENT = 2,
};

enum usb_phy_interface {
	USBPHY_INTERFACE_MODE_UNKNOWN = 0,
	USBPHY_INTERFACE_MODE_UTMI = 1,
	USBPHY_INTERFACE_MODE_UTMIW = 2,
	USBPHY_INTERFACE_MODE_ULPI = 3,
	USBPHY_INTERFACE_MODE_SERIAL = 4,
	USBPHY_INTERFACE_MODE_HSIC = 5,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_HEALTH = 2,
	POWER_SUPPLY_PROP_PRESENT = 3,
	POWER_SUPPLY_PROP_ONLINE = 4,
	POWER_SUPPLY_PROP_AUTHENTIC = 5,
	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
	POWER_SUPPLY_PROP_POWER_NOW = 20,
	POWER_SUPPLY_PROP_POWER_AVG = 21,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
	POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR = 37,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 38,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 39,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 40,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 41,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 42,
	POWER_SUPPLY_PROP_ENERGY_FULL = 43,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 44,
	POWER_SUPPLY_PROP_ENERGY_NOW = 45,
	POWER_SUPPLY_PROP_ENERGY_AVG = 46,
	POWER_SUPPLY_PROP_CAPACITY = 47,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 48,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 49,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 50,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 51,
	POWER_SUPPLY_PROP_TEMP = 52,
	POWER_SUPPLY_PROP_TEMP_MAX = 53,
	POWER_SUPPLY_PROP_TEMP_MIN = 54,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 55,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 56,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 58,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 59,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 60,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 61,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 62,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 63,
	POWER_SUPPLY_PROP_TYPE = 64,
	POWER_SUPPLY_PROP_USB_TYPE = 65,
	POWER_SUPPLY_PROP_SCOPE = 66,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 67,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 68,
	POWER_SUPPLY_PROP_CALIBRATE = 69,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 71,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 72,
	POWER_SUPPLY_PROP_MODEL_NAME = 73,
	POWER_SUPPLY_PROP_MANUFACTURER = 74,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 75,
};

enum dwc3_ep0_next {
	DWC3_EP0_UNKNOWN = 0,
	DWC3_EP0_COMPLETE = 1,
	DWC3_EP0_NRDY_DATA = 2,
	DWC3_EP0_NRDY_STATUS = 3,
};

enum dwc3_ep0_state {
	EP0_UNCONNECTED = 0,
	EP0_SETUP_PHASE = 1,
	EP0_DATA_PHASE = 2,
	EP0_STATUS_PHASE = 3,
};

enum dwc3_link_state {
	DWC3_LINK_STATE_U0 = 0,
	DWC3_LINK_STATE_U1 = 1,
	DWC3_LINK_STATE_U2 = 2,
	DWC3_LINK_STATE_U3 = 3,
	DWC3_LINK_STATE_SS_DIS = 4,
	DWC3_LINK_STATE_RX_DET = 5,
	DWC3_LINK_STATE_SS_INACT = 6,
	DWC3_LINK_STATE_POLL = 7,
	DWC3_LINK_STATE_RECOV = 8,
	DWC3_LINK_STATE_HRESET = 9,
	DWC3_LINK_STATE_CMPLY = 10,
	DWC3_LINK_STATE_LPBK = 11,
	DWC3_LINK_STATE_RESET = 14,
	DWC3_LINK_STATE_RESUME = 15,
	DWC3_LINK_STATE_MASK = 15,
};

struct usb_ep;

struct usb_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	struct scatterlist *sg;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id: 16;
	unsigned int is_last: 1;
	unsigned int no_interrupt: 1;
	unsigned int zero: 1;
	unsigned int short_not_ok: 1;
	unsigned int dma_mapped: 1;
	void (*complete)(struct usb_ep *, struct usb_request *);
	void *context;
	struct list_head list;
	unsigned int frame_number;
	int status;
	unsigned int actual;
};

struct dwc3_ep;

struct dwc3_trb;

struct dwc3_request {
	struct usb_request request;
	struct list_head list;
	struct dwc3_ep *dep;
	struct scatterlist *sg;
	struct scatterlist *start_sg;
	unsigned int num_pending_sgs;
	unsigned int num_queued_sgs;
	unsigned int remaining;
	unsigned int status;
	u8 epnum;
	struct dwc3_trb *trb;
	dma_addr_t trb_dma;
	unsigned int num_trbs;
	unsigned int needs_extra_trb: 1;
	unsigned int direction: 1;
	unsigned int mapped: 1;
};

struct dwc3_hwparams {
	u32 hwparams0;
	u32 hwparams1;
	u32 hwparams2;
	u32 hwparams3;
	u32 hwparams4;
	u32 hwparams5;
	u32 hwparams6;
	u32 hwparams7;
	u32 hwparams8;
	u32 hwparams9;
};

struct dwc3_event_buffer;

struct usb_gadget;

struct usb_gadget_driver;

struct usb_phy;

struct ulpi;

struct usb_role_switch;

struct power_supply;

struct debugfs_regset32;

struct dwc3 {
	struct work_struct drd_work;
	struct dwc3_trb *ep0_trb;
	void *bounce;
	u8 *setup_buf;
	dma_addr_t ep0_trb_addr;
	dma_addr_t bounce_addr;
	struct dwc3_request ep0_usb_req;
	struct completion ep0_in_setup;
	spinlock_t lock;
	struct mutex mutex;
	struct device *dev;
	struct device *sysdev;
	struct platform_device *xhci;
	struct resource xhci_resources[2];
	struct dwc3_event_buffer *ev_buf;
	struct dwc3_ep *eps[32];
	struct usb_gadget *gadget;
	struct usb_gadget_driver *gadget_driver;
	struct clk *bus_clk;
	struct clk *ref_clk;
	struct clk *susp_clk;
	struct clk *utmi_clk;
	struct clk *pipe_clk;
	struct reset_control *reset;
	struct usb_phy *usb2_phy;
	struct usb_phy *usb3_phy;
	struct phy *usb2_generic_phy;
	struct phy *usb3_generic_phy;
	bool phys_ready;
	struct ulpi *ulpi;
	bool ulpi_ready;
	void *regs;
	size_t regs_size;
	enum usb_dr_mode dr_mode;
	u32 current_dr_role;
	u32 desired_dr_role;
	struct extcon_dev *edev;
	struct notifier_block edev_nb;
	enum usb_phy_interface hsphy_mode;
	struct usb_role_switch *role_sw;
	enum usb_dr_mode role_switch_default_mode;
	struct power_supply *usb_psy;
	u32 fladj;
	u32 ref_clk_per;
	u32 irq_gadget;
	u32 otg_irq;
	u32 current_otg_role;
	u32 desired_otg_role;
	bool otg_restart_host;
	u32 u1u2;
	u32 maximum_speed;
	u32 gadget_max_speed;
	enum usb_ssp_rate max_ssp_rate;
	enum usb_ssp_rate gadget_ssp_rate;
	u32 ip;
	u32 revision;
	u32 version_type;
	enum dwc3_ep0_next ep0_next_event;
	enum dwc3_ep0_state ep0state;
	enum dwc3_link_state link_state;
	u16 u2sel;
	u16 u2pel;
	u8 u1sel;
	u8 u1pel;
	u8 speed;
	u8 num_eps;
	struct dwc3_hwparams hwparams;
	struct debugfs_regset32 *regset;
	u32 dbg_lsp_select;
	u8 test_mode;
	u8 test_mode_nr;
	u8 lpm_nyet_threshold;
	u8 hird_threshold;
	u8 rx_thr_num_pkt;
	u8 rx_max_burst;
	u8 tx_thr_num_pkt;
	u8 tx_max_burst;
	u8 rx_thr_num_pkt_prd;
	u8 rx_max_burst_prd;
	u8 tx_thr_num_pkt_prd;
	u8 tx_max_burst_prd;
	u8 tx_fifo_resize_max_num;
	u8 clear_stall_protocol;
	const char *hsphy_interface;
	unsigned int connected: 1;
	unsigned int softconnect: 1;
	unsigned int delayed_status: 1;
	unsigned int ep0_bounced: 1;
	unsigned int ep0_expect_in: 1;
	unsigned int sysdev_is_parent: 1;
	unsigned int has_lpm_erratum: 1;
	unsigned int is_utmi_l1_suspend: 1;
	unsigned int is_fpga: 1;
	unsigned int pending_events: 1;
	unsigned int do_fifo_resize: 1;
	unsigned int pullups_connected: 1;
	unsigned int setup_packet_pending: 1;
	unsigned int three_stage_setup: 1;
	unsigned int dis_start_transfer_quirk: 1;
	unsigned int usb3_lpm_capable: 1;
	unsigned int usb2_lpm_disable: 1;
	unsigned int usb2_gadget_lpm_disable: 1;
	unsigned int disable_scramble_quirk: 1;
	unsigned int u2exit_lfps_quirk: 1;
	unsigned int u2ss_inp3_quirk: 1;
	unsigned int req_p1p2p3_quirk: 1;
	unsigned int del_p1p2p3_quirk: 1;
	unsigned int del_phy_power_chg_quirk: 1;
	unsigned int lfps_filter_quirk: 1;
	unsigned int rx_detect_poll_quirk: 1;
	unsigned int dis_u3_susphy_quirk: 1;
	unsigned int dis_u2_susphy_quirk: 1;
	unsigned int dis_enblslpm_quirk: 1;
	unsigned int dis_u1_entry_quirk: 1;
	unsigned int dis_u2_entry_quirk: 1;
	unsigned int dis_rxdet_inp3_quirk: 1;
	unsigned int dis_u2_freeclk_exists_quirk: 1;
	unsigned int dis_del_phy_power_chg_quirk: 1;
	unsigned int dis_tx_ipgap_linecheck_quirk: 1;
	unsigned int resume_hs_terminations: 1;
	unsigned int ulpi_ext_vbus_drv: 1;
	unsigned int parkmode_disable_ss_quirk: 1;
	unsigned int parkmode_disable_hs_quirk: 1;
	unsigned int gfladj_refclk_lpm_sel: 1;
	unsigned int tx_de_emphasis_quirk: 1;
	unsigned int tx_de_emphasis: 2;
	unsigned int dis_metastability_quirk: 1;
	unsigned int dis_split_quirk: 1;
	unsigned int async_callbacks: 1;
	unsigned int wakeup_configured: 1;
	unsigned int suspended: 1;
	u16 imod_interval;
	int max_cfg_eps;
	int last_fifo_depth;
	int num_ep_resized;
	struct dentry *debug_root;
};

struct dwc3_trb {
	u32 bpl;
	u32 bph;
	u32 size;
	u32 ctrl;
};

struct usb_ep_caps {
	unsigned int type_control: 1;
	unsigned int type_iso: 1;
	unsigned int type_bulk: 1;
	unsigned int type_int: 1;
	unsigned int dir_in: 1;
	unsigned int dir_out: 1;
};

struct usb_ep_ops;

struct usb_ep {
	void *driver_data;
	const char *name;
	const struct usb_ep_ops *ops;
	struct list_head ep_list;
	struct usb_ep_caps caps;
	bool claimed;
	bool enabled;
	unsigned int maxpacket: 16;
	unsigned int maxpacket_limit: 16;
	unsigned int max_streams: 16;
	unsigned int mult: 2;
	unsigned int maxburst: 5;
	u8 address;
	const struct usb_endpoint_descriptor *desc;
	const struct usb_ss_ep_comp_descriptor *comp_desc;
};

struct usb_ep_ops {
	int (*enable)(struct usb_ep *, const struct usb_endpoint_descriptor *);
	int (*disable)(struct usb_ep *);
	void (*dispose)(struct usb_ep *);
	struct usb_request * (*alloc_request)(struct usb_ep *, gfp_t);
	void (*free_request)(struct usb_ep *, struct usb_request *);
	int (*queue)(struct usb_ep *, struct usb_request *, gfp_t);
	int (*dequeue)(struct usb_ep *, struct usb_request *);
	int (*set_halt)(struct usb_ep *, int);
	int (*set_wedge)(struct usb_ep *);
	int (*fifo_status)(struct usb_ep *);
	void (*fifo_flush)(struct usb_ep *);
};

struct dwc3_ep {
	struct usb_ep endpoint;
	struct list_head cancelled_list;
	struct list_head pending_list;
	struct list_head started_list;
	void *regs;
	struct dwc3_trb *trb_pool;
	dma_addr_t trb_pool_dma;
	struct dwc3 *dwc;
	u32 saved_state;
	unsigned int flags;
	u8 trb_enqueue;
	u8 trb_dequeue;
	u8 number;
	u8 type;
	u8 resource_index;
	u32 frame_number;
	u32 interval;
	char name[20];
	unsigned int direction: 1;
	unsigned int stream_capable: 1;
	u8 combo_num;
	int start_cmd_status;
};

struct dwc3_event_buffer {
	void *buf;
	void *cache;
	unsigned int length;
	unsigned int lpos;
	unsigned int count;
	unsigned int flags;
	dma_addr_t dma;
	struct dwc3 *dwc;
};

struct usb_udc;

struct usb_gadget_ops;

struct usb_otg_caps;

struct usb_gadget {
	struct work_struct work;
	struct usb_udc *udc;
	const struct usb_gadget_ops *ops;
	struct usb_ep *ep0;
	struct list_head ep_list;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_ssp_rate ssp_rate;
	enum usb_ssp_rate max_ssp_rate;
	enum usb_device_state state;
	const char *name;
	struct device dev;
	unsigned int isoch_delay;
	unsigned int out_epnum;
	unsigned int in_epnum;
	unsigned int mA;
	struct usb_otg_caps *otg_caps;
	unsigned int sg_supported: 1;
	unsigned int is_otg: 1;
	unsigned int is_a_peripheral: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int a_hnp_support: 1;
	unsigned int a_alt_hnp_support: 1;
	unsigned int hnp_polling_support: 1;
	unsigned int host_request_flag: 1;
	unsigned int quirk_ep_out_aligned_size: 1;
	unsigned int quirk_altset_not_supp: 1;
	unsigned int quirk_stall_not_supp: 1;
	unsigned int quirk_zlp_not_supp: 1;
	unsigned int quirk_avoids_skb_reserve: 1;
	unsigned int is_selfpowered: 1;
	unsigned int deactivated: 1;
	unsigned int connected: 1;
	unsigned int lpm_capable: 1;
	unsigned int wakeup_capable: 1;
	unsigned int wakeup_armed: 1;
	int irq;
	int id_number;
};

struct usb_dcd_config_params;

struct usb_gadget_ops {
	int (*get_frame)(struct usb_gadget *);
	int (*wakeup)(struct usb_gadget *);
	int (*func_wakeup)(struct usb_gadget *, int);
	int (*set_remote_wakeup)(struct usb_gadget *, int);
	int (*set_selfpowered)(struct usb_gadget *, int);
	int (*vbus_session)(struct usb_gadget *, int);
	int (*vbus_draw)(struct usb_gadget *, unsigned int);
	int (*pullup)(struct usb_gadget *, int);
	int (*ioctl)(struct usb_gadget *, unsigned int, unsigned long);
	void (*get_config_params)(struct usb_gadget *, struct usb_dcd_config_params *);
	int (*udc_start)(struct usb_gadget *, struct usb_gadget_driver *);
	int (*udc_stop)(struct usb_gadget *);
	void (*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);
	void (*udc_set_ssp_rate)(struct usb_gadget *, enum usb_ssp_rate);
	void (*udc_async_callbacks)(struct usb_gadget *, bool);
	struct usb_ep * (*match_ep)(struct usb_gadget *, struct usb_endpoint_descriptor *, struct usb_ss_ep_comp_descriptor *);
	int (*check_config)(struct usb_gadget *);
};

struct usb_dcd_config_params {
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
	__u8 besl_baseline;
	__u8 besl_deep;
};

struct usb_ctrlrequest;

struct usb_gadget_driver {
	char *function;
	enum usb_device_speed max_speed;
	int (*bind)(struct usb_gadget *, struct usb_gadget_driver *);
	void (*unbind)(struct usb_gadget *);
	int (*setup)(struct usb_gadget *, const struct usb_ctrlrequest *);
	void (*disconnect)(struct usb_gadget *);
	void (*suspend)(struct usb_gadget *);
	void (*resume)(struct usb_gadget *);
	void (*reset)(struct usb_gadget *);
	struct device_driver driver;
	char *udc_name;
	unsigned int match_existing_only: 1;
	bool is_bound: 1;
};

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

struct usb_otg_caps {
	u16 otg_rev;
	bool hnp_support;
	bool srp_support;
	bool adp_support;
};

struct usb_charger_current {
	unsigned int sdp_min;
	unsigned int sdp_max;
	unsigned int dcp_min;
	unsigned int dcp_max;
	unsigned int cdp_min;
	unsigned int cdp_max;
	unsigned int aca_min;
	unsigned int aca_max;
};

struct usb_otg;

struct usb_phy_io_ops;

struct usb_phy {
	struct device *dev;
	const char *label;
	unsigned int flags;
	enum usb_phy_type type;
	enum usb_phy_events last_event;
	struct usb_otg *otg;
	struct device *io_dev;
	struct usb_phy_io_ops *io_ops;
	void *io_priv;
	struct extcon_dev *edev;
	struct extcon_dev *id_edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct notifier_block type_nb;
	enum usb_charger_type chg_type;
	enum usb_charger_state chg_state;
	struct usb_charger_current chg_cur;
	struct work_struct chg_work;
	struct atomic_notifier_head notifier;
	u16 port_status;
	u16 port_change;
	struct list_head head;
	int (*init)(struct usb_phy *);
	void (*shutdown)(struct usb_phy *);
	int (*set_vbus)(struct usb_phy *, int);
	int (*set_power)(struct usb_phy *, unsigned int);
	int (*set_suspend)(struct usb_phy *, int);
	int (*set_wakeup)(struct usb_phy *, bool);
	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
	enum usb_charger_type (*charger_detect)(struct usb_phy *);
};

struct usb_otg {
	u8 default_a;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_bus *host;
	struct usb_gadget *gadget;
	enum usb_otg_state state;
	int (*set_host)(struct usb_otg *, struct usb_bus *);
	int (*set_peripheral)(struct usb_otg *, struct usb_gadget *);
	int (*set_vbus)(struct usb_otg *, bool);
	int (*start_srp)(struct usb_otg *);
	int (*start_hnp)(struct usb_otg *);
};

struct usb_phy_io_ops {
	int (*read)(struct usb_phy *, u32);
	int (*write)(struct usb_phy *, u32, u32);
};

struct power_supply_desc;

struct power_supply_battery_info;

struct thermal_zone_device;

struct led_trigger;

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct power_supply_battery_info *battery_info;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
	struct led_trigger *charging_full_trig;
	char *charging_full_trig_name;
	struct led_trigger *charging_trig;
	char *charging_trig_name;
	struct led_trigger *full_trig;
	char *full_trig_name;
	struct led_trigger *online_trig;
	char *online_trig_name;
	struct led_trigger *charging_blink_full_solid_trig;
	char *charging_blink_full_solid_trig_name;
};

union power_supply_propval;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	const enum power_supply_usb_type *usb_types;
	size_t num_usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_maintenance_charge_table;

struct power_supply_battery_ocv_table;

struct power_supply_resistance_temp_table;

struct power_supply_vbat_ri_table;

struct power_supply_battery_info {
	unsigned int technology;
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	struct power_supply_maintenance_charge_table *maintenance_charge;
	int maintenance_charge_size;
	int alert_low_temp_charge_current_ua;
	int alert_low_temp_charge_voltage_uv;
	int alert_high_temp_charge_current_ua;
	int alert_high_temp_charge_voltage_uv;
	int factory_internal_resistance_uohm;
	int factory_internal_resistance_charging_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
	struct power_supply_vbat_ri_table *vbat2ri_discharging;
	int vbat2ri_discharging_size;
	struct power_supply_vbat_ri_table *vbat2ri_charging;
	int vbat2ri_charging_size;
	int bti_resistance_ohm;
	int bti_resistance_tolerance;
};

struct power_supply_maintenance_charge_table {
	int charge_current_max_ua;
	int charge_voltage_max_uv;
	int charge_safety_timer_minutes;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_vbat_ri_table {
	int vbat_uv;
	int ri_uohm;
};

struct led_classdev;

struct led_hw_trigger_type;

struct led_trigger {
	const char *name;
	int (*activate)(struct led_classdev *);
	void (*deactivate)(struct led_classdev *);
	struct led_hw_trigger_type *trigger_type;
	spinlock_t leddev_list_lock;
	struct list_head led_cdevs;
	struct list_head next_trig;
	const struct attribute_group **groups;
};

struct led_pattern;

struct led_classdev {
	const char *name;
	unsigned int brightness;
	unsigned int max_brightness;
	unsigned int color;
	int flags;
	unsigned long work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, unsigned long *, unsigned long *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	unsigned long blink_delay_on;
	unsigned long blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct work_struct set_brightness_work;
	int delayed_set_value;
	unsigned long delayed_delay_on;
	unsigned long delayed_delay_off;
	struct rw_semaphore trigger_lock;
	struct led_trigger *trigger;
	struct list_head trig_list;
	void *trigger_data;
	bool activated;
	struct led_hw_trigger_type *trigger_type;
	const char *hw_control_trigger;
	int (*hw_control_is_supported)(struct led_classdev *, unsigned long);
	int (*hw_control_set)(struct led_classdev *, unsigned long);
	int (*hw_control_get)(struct led_classdev *, unsigned long *);
	struct device * (*hw_control_get_device)(struct led_classdev *);
	struct mutex led_access;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct led_hw_trigger_type {
	int dummy;
};

struct debugfs_reg32;

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_reg32 {
	char *name;
	unsigned long offset;
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

enum xhci_ring_type {
	TYPE_CTRL = 0,
	TYPE_ISOC = 1,
	TYPE_BULK = 2,
	TYPE_INTR = 3,
	TYPE_STREAM = 4,
	TYPE_COMMAND = 5,
	TYPE_EVENT = 6,
};

enum xhci_cancelled_td_status {
	TD_DIRTY = 0,
	TD_HALTED = 1,
	TD_CLEARING_CACHE = 2,
	TD_CLEARED = 3,
};

struct xhci_input_control_ctx {
	__le32 drop_flags;
	__le32 add_flags;
	__le32 rsvd2[6];
};

struct xhci_slot_ctx {
	__le32 dev_info;
	__le32 dev_info2;
	__le32 tt_info;
	__le32 dev_state;
	__le32 reserved[4];
};

struct xhci_ep_ctx {
	__le32 ep_info;
	__le32 ep_info2;
	__le64 deq;
	__le32 tx_info;
	__le32 reserved[3];
};

struct xhci_interval_bw {
	unsigned int num_packets;
	struct list_head endpoints;
	unsigned int overhead[3];
};

struct xhci_interval_bw_table {
	unsigned int interval0_esit_payload;
	struct xhci_interval_bw interval_bw[16];
	unsigned int bw_used;
	unsigned int ss_bw_in;
	unsigned int ss_bw_out;
};

struct xhci_tt_bw_info {
	struct list_head tt_list;
	int slot_id;
	int ttport;
	struct xhci_interval_bw_table bw_table;
	int active_eps;
};

struct xhci_segment;

union xhci_trb;

struct xhci_ring {
	struct xhci_segment *first_seg;
	struct xhci_segment *last_seg;
	union xhci_trb *enqueue;
	struct xhci_segment *enq_seg;
	union xhci_trb *dequeue;
	struct xhci_segment *deq_seg;
	struct list_head td_list;
	u32 cycle_state;
	unsigned int stream_id;
	unsigned int num_segs;
	unsigned int num_trbs_free;
	unsigned int bounce_buf_len;
	enum xhci_ring_type type;
	bool last_td_was_short;
	struct xarray *trb_address_map;
};

struct xhci_segment {
	union xhci_trb *trbs;
	struct xhci_segment *next;
	unsigned int num;
	dma_addr_t dma;
	dma_addr_t bounce_dma;
	void *bounce_buf;
	unsigned int bounce_offs;
	unsigned int bounce_len;
};

struct xhci_link_trb {
	__le64 segment_ptr;
	__le32 intr_target;
	__le32 control;
};

struct xhci_transfer_event {
	__le64 buffer;
	__le32 transfer_len;
	__le32 flags;
};

struct xhci_event_cmd {
	__le64 cmd_trb;
	__le32 status;
	__le32 flags;
};

struct xhci_generic_trb {
	__le32 field[4];
};

union xhci_trb {
	struct xhci_link_trb link;
	struct xhci_transfer_event trans_event;
	struct xhci_event_cmd event_cmd;
	struct xhci_generic_trb generic;
};

struct s3_save {
	u32 command;
	u32 dev_nt;
	u64 dcbaa_ptr;
	u32 config_reg;
};

struct xhci_bus_state {
	unsigned long bus_suspended;
	unsigned long next_statechange;
	u32 port_c_suspend;
	u32 suspended_ports;
	u32 port_remote_wakeup;
	unsigned long resuming_ports;
};

struct xhci_port;

struct usb_hcd;

struct xhci_hub {
	struct xhci_port **ports;
	unsigned int num_ports;
	struct usb_hcd *hcd;
	struct xhci_bus_state bus_state;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_cap_regs;

struct xhci_op_regs;

struct xhci_run_regs;

struct xhci_doorbell_array;

struct xhci_device_context_array;

struct xhci_interrupter;

struct xhci_command;

struct xhci_scratchpad;

struct xhci_virt_device;

struct xhci_root_port_bw_info;

struct dma_pool;

struct xhci_port_cap;

struct xhci_hcd {
	struct usb_hcd *main_hcd;
	struct usb_hcd *shared_hcd;
	struct xhci_cap_regs *cap_regs;
	struct xhci_op_regs *op_regs;
	struct xhci_run_regs *run_regs;
	struct xhci_doorbell_array *dba;
	__u32 hcs_params1;
	__u32 hcs_params2;
	__u32 hcs_params3;
	__u32 hcc_params;
	__u32 hcc_params2;
	spinlock_t lock;
	u8 sbrn;
	u16 hci_version;
	u8 max_slots;
	u16 max_interrupters;
	u8 max_ports;
	u8 isoc_threshold;
	u32 imod_interval;
	u32 isoc_bei_interval;
	int event_ring_max;
	int page_size;
	int page_shift;
	int msix_count;
	struct clk *clk;
	struct clk *reg_clk;
	struct reset_control *reset;
	struct xhci_device_context_array *dcbaa;
	struct xhci_interrupter *interrupter;
	struct xhci_ring *cmd_ring;
	unsigned int cmd_ring_state;
	struct list_head cmd_list;
	unsigned int cmd_ring_reserved_trbs;
	struct delayed_work cmd_timer;
	struct completion cmd_ring_stop_completion;
	struct xhci_command *current_cmd;
	struct xhci_scratchpad *scratchpad;
	struct mutex mutex;
	struct xhci_virt_device *devs[256];
	struct xhci_root_port_bw_info *rh_bw;
	struct dma_pool *device_pool;
	struct dma_pool *segment_pool;
	struct dma_pool *small_streams_pool;
	struct dma_pool *medium_streams_pool;
	unsigned int xhc_state;
	unsigned long run_graceperiod;
	struct s3_save s3;
	unsigned long long quirks;
	unsigned int num_active_eps;
	unsigned int limit_active_eps;
	struct xhci_port *hw_ports;
	struct xhci_hub usb2_rhub;
	struct xhci_hub usb3_rhub;
	unsigned int hw_lpm_support: 1;
	unsigned int broken_suspend: 1;
	unsigned int allow_single_roothub: 1;
	u32 *ext_caps;
	unsigned int num_ext_caps;
	struct xhci_port_cap *port_caps;
	unsigned int num_port_caps;
	struct timer_list comp_mode_recovery_timer;
	u32 port_status_u0;
	u16 test_mode;
	struct dentry *debugfs_root;
	struct dentry *debugfs_slots;
	struct list_head regset_list;
	void *dbc;
	unsigned long priv[0];
};

struct giveback_urb_bh {
	bool running;
	bool high_prio;
	spinlock_t lock;
	struct list_head head;
	struct tasklet_struct bh;
	struct usb_host_endpoint *completing_ep;
};

struct urb;

struct hc_driver;

struct usb_phy_roothub;

struct gen_pool;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	unsigned long flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	unsigned long hcd_priv[0];
};

typedef void (*usb_complete_t)(struct urb *);

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor;

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, pm_message_t);
	int (*pci_poweroff_late)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	unsigned long (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
	int (*submit_single_step_set_feature)(struct usb_hcd *, struct urb *, int);
};

struct xhci_cap_regs {
	__le32 hc_capbase;
	__le32 hcs_params1;
	__le32 hcs_params2;
	__le32 hcs_params3;
	__le32 hcc_params;
	__le32 db_off;
	__le32 run_regs_off;
	__le32 hcc_params2;
};

struct xhci_op_regs {
	__le32 command;
	__le32 status;
	__le32 page_size;
	__le32 reserved1;
	__le32 reserved2;
	__le32 dev_notification;
	__le64 cmd_ring;
	__le32 reserved3[4];
	__le64 dcbaa_ptr;
	__le32 config_reg;
	__le32 reserved4[241];
	__le32 port_status_base;
	__le32 port_power_base;
	__le32 port_link_base;
	__le32 reserved5;
	__le32 reserved6[1016];
};

struct xhci_intr_reg {
	__le32 irq_pending;
	__le32 irq_control;
	__le32 erst_size;
	__le32 rsvd;
	__le64 erst_base;
	__le64 erst_dequeue;
};

struct xhci_run_regs {
	__le32 microframe_index;
	__le32 rsvd[7];
	struct xhci_intr_reg ir_set[128];
};

struct xhci_doorbell_array {
	__le32 doorbell[256];
};

struct xhci_device_context_array {
	__le64 dev_context_ptrs[256];
	dma_addr_t dma;
};

struct xhci_erst_entry;

struct xhci_erst {
	struct xhci_erst_entry *entries;
	unsigned int num_entries;
	dma_addr_t erst_dma_addr;
	unsigned int erst_size;
};

struct xhci_interrupter {
	struct xhci_ring *event_ring;
	struct xhci_erst erst;
	struct xhci_intr_reg *ir_set;
	unsigned int intr_num;
	u32 s3_irq_pending;
	u32 s3_irq_control;
	u32 s3_erst_size;
	u64 s3_erst_base;
	u64 s3_erst_dequeue;
};

struct xhci_erst_entry {
	__le64 seg_addr;
	__le32 seg_size;
	__le32 rsvd;
};

struct xhci_container_ctx;

struct xhci_command {
	struct xhci_container_ctx *in_ctx;
	u32 status;
	int slot_id;
	struct completion *completion;
	union xhci_trb *command_trb;
	struct list_head cmd_list;
};

struct xhci_container_ctx {
	unsigned int type;
	int size;
	u8 *bytes;
	dma_addr_t dma;
};

struct xhci_scratchpad {
	u64 *sp_array;
	dma_addr_t sp_dma;
	void **sp_buffers;
};

struct xhci_bw_info {
	unsigned int ep_interval;
	unsigned int mult;
	unsigned int num_packets;
	unsigned int max_packet_size;
	unsigned int max_esit_payload;
	unsigned int type;
};

struct xhci_stream_info;

struct xhci_virt_ep {
	struct xhci_virt_device *vdev;
	unsigned int ep_index;
	struct xhci_ring *ring;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *new_ring;
	unsigned int err_count;
	unsigned int ep_state;
	struct list_head cancelled_td_list;
	struct xhci_hcd *xhci;
	struct xhci_segment *queued_deq_seg;
	union xhci_trb *queued_deq_ptr;
	bool skip;
	struct xhci_bw_info bw_info;
	struct list_head bw_endpoint_list;
	int next_frame_id;
	bool use_extended_tbc;
};

struct xhci_virt_device {
	int slot_id;
	struct usb_device *udev;
	struct xhci_container_ctx *out_ctx;
	struct xhci_container_ctx *in_ctx;
	struct xhci_virt_ep eps[31];
	u8 fake_port;
	u8 real_port;
	struct xhci_interval_bw_table *bw_table;
	struct xhci_tt_bw_info *tt_info;
	unsigned long flags;
	u16 current_mel;
	void *debugfs_private;
};

struct xhci_stream_ctx;

struct xhci_stream_info {
	struct xhci_ring **stream_rings;
	unsigned int num_streams;
	struct xhci_stream_ctx *stream_ctx_array;
	unsigned int num_stream_ctxs;
	dma_addr_t ctx_array_dma;
	struct xarray trb_address_map;
	struct xhci_command *free_streams_command;
};

struct xhci_stream_ctx {
	__le64 stream_ring;
	__le32 reserved[2];
};

struct xhci_root_port_bw_info {
	struct list_head tts;
	unsigned int num_active_tts;
	struct xhci_interval_bw_table bw_table;
};

struct xhci_port {
	__le32 *addr;
	int hw_portnum;
	int hcd_portnum;
	struct xhci_hub *rhub;
	struct xhci_port_cap *port_cap;
	unsigned int lpm_incapable: 1;
	unsigned long resume_timestamp;
	bool rexit_active;
	struct completion rexit_done;
	struct completion u3exit_done;
};

struct xhci_port_cap {
	u32 *psi;
	u8 psi_count;
	u8 psi_uid_count;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_td {
	struct list_head td_list;
	struct list_head cancelled_td_list;
	int status;
	enum xhci_cancelled_td_status cancel_status;
	struct urb *urb;
	struct xhci_segment *start_seg;
	union xhci_trb *first_trb;
	union xhci_trb *last_trb;
	struct xhci_segment *last_trb_seg;
	struct xhci_segment *bounce_seg;
	bool urb_length_set;
	unsigned int num_trbs;
};

struct urb_priv {
	int num_tds;
	int num_tds_done;
	struct xhci_td td[0];
};

struct musb_register_map {
	char *name;
	unsigned int offset;
	unsigned int size;
};

enum dma_channel_status {
	MUSB_DMA_STATUS_UNKNOWN = 0,
	MUSB_DMA_STATUS_FREE = 1,
	MUSB_DMA_STATUS_BUSY = 2,
	MUSB_DMA_STATUS_BUS_ABORT = 3,
	MUSB_DMA_STATUS_CORE_ABORT = 4,
};

enum musb_vbus_id_status {
	MUSB_UNKNOWN = 0,
	MUSB_ID_GROUND = 1,
	MUSB_ID_FLOAT = 2,
	MUSB_VBUS_VALID = 3,
	MUSB_VBUS_OFF = 4,
};

enum musb_h_ep0_state {
	MUSB_EP0_IDLE = 0,
	MUSB_EP0_START = 1,
	MUSB_EP0_IN = 2,
	MUSB_EP0_OUT = 3,
	MUSB_EP0_STATUS = 4,
} __attribute__((mode(byte)));

enum musb_mode {
	MUSB_UNDEFINED = 0,
	MUSB_HOST = 1,
	MUSB_PERIPHERAL = 2,
	MUSB_OTG = 3,
};

enum musb_g_ep0_state {
	MUSB_EP0_STAGE_IDLE = 0,
	MUSB_EP0_STAGE_SETUP = 1,
	MUSB_EP0_STAGE_TX = 2,
	MUSB_EP0_STAGE_RX = 3,
	MUSB_EP0_STAGE_STATUSIN = 4,
	MUSB_EP0_STAGE_STATUSOUT = 5,
	MUSB_EP0_STAGE_ACKWAIT = 6,
} __attribute__((mode(byte)));

enum musb_fifo_style {
	FIFO_RXTX = 0,
	FIFO_TX = 1,
	FIFO_RX = 2,
} __attribute__((mode(byte)));

enum musb_buf_mode {
	BUF_SINGLE = 0,
	BUF_DOUBLE = 1,
} __attribute__((mode(byte)));

struct musb_hw_ep;

struct musb_qh;

struct musb_io {
	u32 (*ep_offset)(u8, u16);
	void (*ep_select)(void *, u8);
	u32 (*fifo_offset)(u8);
	void (*read_fifo)(struct musb_hw_ep *, u16, u8 *);
	void (*write_fifo)(struct musb_hw_ep *, u16, const u8 *);
	u32 (*busctl_offset)(u8, u16);
	u16 (*get_toggle)(struct musb_qh *, int);
	u16 (*set_toggle)(struct musb_qh *, int, struct urb *);
};

struct musb_csr_regs {
	u16 txmaxp;
	u16 txcsr;
	u16 rxmaxp;
	u16 rxcsr;
	u16 rxfifoadd;
	u16 txfifoadd;
	u8 txtype;
	u8 txinterval;
	u8 rxtype;
	u8 rxinterval;
	u8 rxfifosz;
	u8 txfifosz;
	u8 txfunaddr;
	u8 txhubaddr;
	u8 txhubport;
	u8 rxfunaddr;
	u8 rxhubaddr;
	u8 rxhubport;
};

struct musb_context_registers {
	u8 power;
	u8 intrusbe;
	u16 frame;
	u8 index;
	u8 testmode;
	u8 devctl;
	u8 busctl;
	u8 misc;
	u32 otg_interfsel;
	struct musb_csr_regs index_regs[16];
};

struct musb;

struct dma_channel;

struct musb_ep {
	struct usb_ep end_point;
	char name[12];
	struct musb_hw_ep *hw_ep;
	struct musb *musb;
	u8 current_epnum;
	u8 type;
	u8 is_in;
	u16 packet_sz;
	const struct usb_endpoint_descriptor *desc;
	struct dma_channel *dma;
	struct list_head req_list;
	u8 wedged;
	u8 busy;
	u8 hb_mult;
};

struct musb_hw_ep {
	struct musb *musb;
	void *fifo;
	void *regs;
	u8 epnum;
	bool is_shared_fifo;
	bool tx_double_buffered;
	bool rx_double_buffered;
	u16 max_packet_sz_tx;
	u16 max_packet_sz_rx;
	struct dma_channel *tx_channel;
	struct dma_channel *rx_channel;
	struct musb_qh *in_qh;
	struct musb_qh *out_qh;
	u8 rx_reinit;
	u8 tx_reinit;
	struct musb_ep ep_in;
	struct musb_ep ep_out;
};

struct musb_platform_ops;

struct dma_controller;

struct musb_hdrc_config;

struct musb {
	spinlock_t lock;
	spinlock_t list_lock;
	struct musb_io io;
	const struct musb_platform_ops *ops;
	struct musb_context_registers context;
	irqreturn_t (*isr)(int, void *);
	struct delayed_work irq_work;
	struct delayed_work deassert_reset_work;
	struct delayed_work finish_resume_work;
	struct delayed_work gadget_work;
	u16 hwvers;
	u16 intrrxe;
	u16 intrtxe;
	u32 port1_status;
	unsigned long rh_timer;
	enum musb_h_ep0_state ep0_stage;
	struct musb_hw_ep *bulk_ep;
	struct list_head control;
	struct list_head in_bulk;
	struct list_head out_bulk;
	struct list_head pending_list;
	struct timer_list otg_timer;
	struct timer_list dev_timer;
	struct notifier_block nb;
	struct dma_controller *dma_controller;
	struct device *controller;
	void *ctrl_base;
	void *mregs;
	u8 int_usb;
	u16 int_rx;
	u16 int_tx;
	struct usb_phy *xceiv;
	struct phy *phy;
	enum usb_otg_state otg_state;
	int nIrq;
	unsigned int irq_wake: 1;
	struct musb_hw_ep endpoints[16];
	u16 vbuserr_retry;
	u16 epmask;
	u8 nr_endpoints;
	u8 min_power;
	enum musb_mode port_mode;
	bool session;
	unsigned long quirk_retries;
	bool is_host;
	int a_wait_bcon;
	unsigned long idle_timeout;
	unsigned int is_initialized: 1;
	unsigned int is_runtime_suspended: 1;
	unsigned int is_active: 1;
	unsigned int is_multipoint: 1;
	unsigned int hb_iso_rx: 1;
	unsigned int hb_iso_tx: 1;
	unsigned int dyn_fifo: 1;
	unsigned int bulk_split: 1;
	unsigned int bulk_combine: 1;
	unsigned int is_suspended: 1;
	unsigned int may_wakeup: 1;
	unsigned int is_self_powered: 1;
	unsigned int is_bus_powered: 1;
	unsigned int set_address: 1;
	unsigned int test_mode: 1;
	unsigned int softconnect: 1;
	unsigned int flush_irq_work: 1;
	u8 address;
	u8 test_mode_nr;
	u16 ackpend;
	enum musb_g_ep0_state ep0_state;
	struct usb_gadget g;
	struct usb_gadget_driver *gadget_driver;
	struct usb_hcd *hcd;
	const struct musb_hdrc_config *config;
	int xceiv_old_state;
	struct dentry *debugfs_root;
};

struct dma_channel {
	void *private_data;
	size_t max_len;
	size_t actual_len;
	enum dma_channel_status status;
	bool desired_mode;
	bool rx_packet_done;
};

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

struct musb_qh {
	struct usb_host_endpoint *hep;
	struct usb_device *dev;
	struct musb_hw_ep *hw_ep;
	struct list_head ring;
	u8 mux;
	unsigned int offset;
	unsigned int segsize;
	u8 type_reg;
	u8 intv_reg;
	u8 addr_reg;
	u8 h_addr_reg;
	u8 h_port_reg;
	u8 is_ready;
	u8 type;
	u8 epnum;
	u8 hb_mult;
	u16 maxpacket;
	u16 frame;
	unsigned int iso_idx;
	struct sg_mapping_iter sg_miter;
	bool use_sg;
};

struct musb_platform_ops {
	u32 quirks;
	int (*init)(struct musb *);
	int (*exit)(struct musb *);
	void (*enable)(struct musb *);
	void (*disable)(struct musb *);
	u32 (*ep_offset)(u8, u16);
	void (*ep_select)(void *, u8);
	u16 fifo_mode;
	u32 (*fifo_offset)(u8);
	u32 (*busctl_offset)(u8, u16);
	u8 (*readb)(void *, u32);
	void (*writeb)(void *, u32, u8);
	u8 (*clearb)(void *, u32);
	u16 (*readw)(void *, u32);
	void (*writew)(void *, u32, u16);
	u16 (*clearw)(void *, u32);
	void (*read_fifo)(struct musb_hw_ep *, u16, u8 *);
	void (*write_fifo)(struct musb_hw_ep *, u16, const u8 *);
	u16 (*get_toggle)(struct musb_qh *, int);
	u16 (*set_toggle)(struct musb_qh *, int, struct urb *);
	struct dma_controller * (*dma_init)(struct musb *, void *);
	void (*dma_exit)(struct dma_controller *);
	int (*set_mode)(struct musb *, u8);
	void (*try_idle)(struct musb *, unsigned long);
	int (*recover)(struct musb *);
	int (*vbus_status)(struct musb *);
	void (*set_vbus)(struct musb *, int);
	void (*pre_root_reset_end)(struct musb *);
	void (*post_root_reset_end)(struct musb *);
	int (*phy_callback)(enum musb_vbus_id_status);
	void (*clear_ep_rxintr)(struct musb *, int);
};

struct dma_controller {
	struct musb *musb;
	struct dma_channel * (*channel_alloc)(struct dma_controller *, struct musb_hw_ep *, u8);
	void (*channel_release)(struct dma_channel *);
	int (*channel_program)(struct dma_channel *, u16, u8, dma_addr_t, u32);
	int (*channel_abort)(struct dma_channel *);
	int (*is_compatible)(struct dma_channel *, u16, void *, u32);
	void (*dma_callback)(struct dma_controller *);
};

struct musb_fifo_cfg;

struct musb_hdrc_config {
	struct musb_fifo_cfg *fifo_cfg;
	unsigned int fifo_cfg_size;
	unsigned int multipoint: 1;
	unsigned int dyn_fifo: 1;
	unsigned int host_port_deassert_reset_at_resume: 1;
	u8 num_eps;
	u8 ram_bits;
	u32 maximum_speed;
};

struct musb_fifo_cfg {
	u8 hw_ep_num;
	enum musb_fifo_style style;
	enum musb_buf_mode mode;
	u16 maxpacket;
};

struct rtc_device;

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
};

typedef __u64 timeu64_t;

struct rtc_class_ops;

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	unsigned long flags;
	unsigned long irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	unsigned long set_offset_nsec;
	unsigned long features[1];
	time64_t range_min;
	timeu64_t range_max;
	timeu64_t alarm_offset_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
};

struct rtc_time;

struct rtc_wkalrm;

struct rtc_param;

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, unsigned long);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long *);
	int (*set_offset)(struct device *, long);
	int (*param_get)(struct device *, struct rtc_param *);
	int (*param_set)(struct device *, struct rtc_param *);
};

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

struct rtc_param {
	__u64 param;
	union {
		__u64 uvalue;
		__s64 svalue;
		__u64 ptr;
	};
	__u32 index;
	__u32 __pad;
};

struct s5m_rtc_reg_config {
	unsigned int regs_count;
	unsigned int time;
	unsigned int ctrl;
	unsigned int alarm0;
	unsigned int alarm1;
	unsigned int udr_update;
	unsigned int autoclear_udr_mask;
	unsigned int read_time_udr_mask;
	unsigned int write_time_udr_mask;
	unsigned int write_alarm_udr_mask;
};

enum sec_device_type {
	S5M8767X = 0,
	S2MPA01 = 1,
	S2MPS11X = 2,
	S2MPS13X = 3,
	S2MPS14X = 4,
	S2MPS15X = 5,
	S2MPU02 = 6,
};

enum s2mps14_irq {
	S2MPS14_IRQ_PWRONF = 0,
	S2MPS14_IRQ_PWRONR = 1,
	S2MPS14_IRQ_JIGONBF = 2,
	S2MPS14_IRQ_JIGONBR = 3,
	S2MPS14_IRQ_ACOKBF = 4,
	S2MPS14_IRQ_ACOKBR = 5,
	S2MPS14_IRQ_PWRON1S = 6,
	S2MPS14_IRQ_MRB = 7,
	S2MPS14_IRQ_RTC60S = 8,
	S2MPS14_IRQ_RTCA1 = 9,
	S2MPS14_IRQ_RTCA0 = 10,
	S2MPS14_IRQ_SMPL = 11,
	S2MPS14_IRQ_RTC1S = 12,
	S2MPS14_IRQ_WTSR = 13,
	S2MPS14_IRQ_INT120C = 14,
	S2MPS14_IRQ_INT140C = 15,
	S2MPS14_IRQ_TSD = 16,
	S2MPS14_IRQ_NR = 17,
};

enum s5m8767_irq {
	S5M8767_IRQ_PWRR = 0,
	S5M8767_IRQ_PWRF = 1,
	S5M8767_IRQ_PWR1S = 2,
	S5M8767_IRQ_JIGR = 3,
	S5M8767_IRQ_JIGF = 4,
	S5M8767_IRQ_LOWBAT2 = 5,
	S5M8767_IRQ_LOWBAT1 = 6,
	S5M8767_IRQ_MRB = 7,
	S5M8767_IRQ_DVSOK2 = 8,
	S5M8767_IRQ_DVSOK3 = 9,
	S5M8767_IRQ_DVSOK4 = 10,
	S5M8767_IRQ_RTC60S = 11,
	S5M8767_IRQ_RTCA1 = 12,
	S5M8767_IRQ_RTCA2 = 13,
	S5M8767_IRQ_SMPL = 14,
	S5M8767_IRQ_RTC1S = 15,
	S5M8767_IRQ_WTSR = 16,
	S5M8767_IRQ_NR = 17,
};

enum s5m_rtc_reg {
	S5M_RTC_SEC = 0,
	S5M_RTC_MIN = 1,
	S5M_RTC_HOUR = 2,
	S5M_RTC_WEEKDAY = 3,
	S5M_RTC_DATE = 4,
	S5M_RTC_MONTH = 5,
	S5M_RTC_YEAR1 = 6,
	S5M_RTC_YEAR2 = 7,
	S5M_ALARM0_SEC = 8,
	S5M_ALARM0_MIN = 9,
	S5M_ALARM0_HOUR = 10,
	S5M_ALARM0_WEEKDAY = 11,
	S5M_ALARM0_DATE = 12,
	S5M_ALARM0_MONTH = 13,
	S5M_ALARM0_YEAR1 = 14,
	S5M_ALARM0_YEAR2 = 15,
	S5M_ALARM1_SEC = 16,
	S5M_ALARM1_MIN = 17,
	S5M_ALARM1_HOUR = 18,
	S5M_ALARM1_WEEKDAY = 19,
	S5M_ALARM1_DATE = 20,
	S5M_ALARM1_MONTH = 21,
	S5M_ALARM1_YEAR1 = 22,
	S5M_ALARM1_YEAR2 = 23,
	S5M_ALARM0_CONF = 24,
	S5M_ALARM1_CONF = 25,
	S5M_RTC_STATUS = 26,
	S5M_WTSR_SMPL_CNTL = 27,
	S5M_RTC_UDR_CON = 28,
	S5M_RTC_REG_MAX = 29,
};

enum {
	RTC_SEC = 0,
	RTC_MIN = 1,
	RTC_HOUR = 2,
	RTC_WEEKDAY = 3,
	RTC_DATE = 4,
	RTC_MONTH = 5,
	RTC_YEAR1 = 6,
	RTC_YEAR2 = 7,
	RTC_MAX_NUM_TIME_REGS = 8,
};

enum s2mps14_reg {
	S2MPS14_REG_ID = 0,
	S2MPS14_REG_INT1 = 1,
	S2MPS14_REG_INT2 = 2,
	S2MPS14_REG_INT3 = 3,
	S2MPS14_REG_INT1M = 4,
	S2MPS14_REG_INT2M = 5,
	S2MPS14_REG_INT3M = 6,
	S2MPS14_REG_ST1 = 7,
	S2MPS14_REG_ST2 = 8,
	S2MPS14_REG_PWRONSRC = 9,
	S2MPS14_REG_OFFSRC = 10,
	S2MPS14_REG_BU_CHG = 11,
	S2MPS14_REG_RTCCTRL = 12,
	S2MPS14_REG_CTRL1 = 13,
	S2MPS14_REG_CTRL2 = 14,
	S2MPS14_REG_RSVD1 = 15,
	S2MPS14_REG_RSVD2 = 16,
	S2MPS14_REG_RSVD3 = 17,
	S2MPS14_REG_RSVD4 = 18,
	S2MPS14_REG_RSVD5 = 19,
	S2MPS14_REG_RSVD6 = 20,
	S2MPS14_REG_CTRL3 = 21,
	S2MPS14_REG_RSVD7 = 22,
	S2MPS14_REG_RSVD8 = 23,
	S2MPS14_REG_WRSTBI = 24,
	S2MPS14_REG_B1CTRL1 = 25,
	S2MPS14_REG_B1CTRL2 = 26,
	S2MPS14_REG_B2CTRL1 = 27,
	S2MPS14_REG_B2CTRL2 = 28,
	S2MPS14_REG_B3CTRL1 = 29,
	S2MPS14_REG_B3CTRL2 = 30,
	S2MPS14_REG_B4CTRL1 = 31,
	S2MPS14_REG_B4CTRL2 = 32,
	S2MPS14_REG_B5CTRL1 = 33,
	S2MPS14_REG_B5CTRL2 = 34,
	S2MPS14_REG_L1CTRL = 35,
	S2MPS14_REG_L2CTRL = 36,
	S2MPS14_REG_L3CTRL = 37,
	S2MPS14_REG_L4CTRL = 38,
	S2MPS14_REG_L5CTRL = 39,
	S2MPS14_REG_L6CTRL = 40,
	S2MPS14_REG_L7CTRL = 41,
	S2MPS14_REG_L8CTRL = 42,
	S2MPS14_REG_L9CTRL = 43,
	S2MPS14_REG_L10CTRL = 44,
	S2MPS14_REG_L11CTRL = 45,
	S2MPS14_REG_L12CTRL = 46,
	S2MPS14_REG_L13CTRL = 47,
	S2MPS14_REG_L14CTRL = 48,
	S2MPS14_REG_L15CTRL = 49,
	S2MPS14_REG_L16CTRL = 50,
	S2MPS14_REG_L17CTRL = 51,
	S2MPS14_REG_L18CTRL = 52,
	S2MPS14_REG_L19CTRL = 53,
	S2MPS14_REG_L20CTRL = 54,
	S2MPS14_REG_L21CTRL = 55,
	S2MPS14_REG_L22CTRL = 56,
	S2MPS14_REG_L23CTRL = 57,
	S2MPS14_REG_L24CTRL = 58,
	S2MPS14_REG_L25CTRL = 59,
	S2MPS14_REG_LDODSCH1 = 60,
	S2MPS14_REG_LDODSCH2 = 61,
	S2MPS14_REG_LDODSCH3 = 62,
};

struct sec_pmic_dev;

struct s5m_rtc_info {
	struct device *dev;
	struct i2c_client *i2c;
	struct sec_pmic_dev *s5m87xx;
	struct regmap *regmap;
	struct rtc_device *rtc_dev;
	int irq;
	enum sec_device_type device_type;
	int rtc_24hr_mode;
	const struct s5m_rtc_reg_config *regs;
};

struct sec_platform_data;

struct regmap_irq_chip_data;

struct sec_pmic_dev {
	struct device *dev;
	struct sec_platform_data *pdata;
	struct regmap *regmap_pmic;
	struct i2c_client *i2c;
	unsigned long device_type;
	int irq;
	struct regmap_irq_chip_data *irq_data;
};

struct sec_regulator_data;

struct sec_opmode_data;

struct sec_platform_data {
	struct sec_regulator_data *regulators;
	struct sec_opmode_data *opmode;
	int num_regulators;
	int buck_gpios[3];
	int buck_ds[3];
	unsigned int buck2_voltage[8];
	bool buck2_gpiodvs;
	unsigned int buck3_voltage[8];
	bool buck3_gpiodvs;
	unsigned int buck4_voltage[8];
	bool buck4_gpiodvs;
	int buck_default_idx;
	int buck_ramp_delay;
	bool buck2_ramp_enable;
	bool buck3_ramp_enable;
	bool buck4_ramp_enable;
	int buck2_init;
	int buck3_init;
	int buck4_init;
	bool manual_poweroff;
	bool disable_wrstbi;
};

struct sec_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
	struct gpio_desc *ext_control_gpiod;
};

struct sec_opmode_data {
	int id;
	unsigned int mode;
};

struct owl_i2c_dev {
	struct i2c_adapter adap;
	struct i2c_msg *msg;
	struct completion msg_complete;
	struct clk *clk;
	spinlock_t lock;
	void *base;
	unsigned long clk_rate;
	u32 bus_freq;
	u32 msg_ptr;
	int err;
};

struct posix_clock;

struct __kernel_timex;

struct posix_clock_context;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long (*ioctl)(struct posix_clock_context *, unsigned int, unsigned long);
	int (*open)(struct posix_clock_context *, fmode_t);
	__poll_t (*poll)(struct posix_clock_context *, struct file *, poll_table *);
	int (*release)(struct posix_clock_context *);
	ssize_t (*read)(struct posix_clock_context *, uint, char __attribute__((btf_type_tag("user"))) *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

struct pps_device;

struct ptp_clock {
	struct posix_clock clock;
	struct device dev;
	struct ptp_clock_info *info;
	dev_t devid;
	int index;
	struct pps_device *pps_source;
	long dialed_frequency;
	struct list_head tsevqs;
	spinlock_t tsevqs_lock;
	struct mutex pincfg_mux;
	wait_queue_head_t tsev_wq;
	int defunct;
	struct device_attribute *pin_dev_attr;
	struct attribute **pin_attr;
	struct attribute_group pin_attr_group;
	const struct attribute_group *pin_attr_groups[2];
	struct kthread_worker *kworker;
	struct kthread_delayed_work aux_work;
	unsigned int max_vclocks;
	unsigned int n_vclocks;
	int *vclock_index;
	struct mutex n_vclocks_mux;
	bool is_virtual_clock;
	bool has_cycles;
	struct dentry *debugfs_root;
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	long long offset;
	long long freq;
	long long maxerror;
	long long esterror;
	int status;
	long long constant;
	long long precision;
	long long tolerance;
	struct __kernel_timex_timeval time;
	long long tick;
	long long ppsfreq;
	long long jitter;
	int shift;
	long long stabil;
	long long jitcnt;
	long long calcnt;
	long long errcnt;
	long long stbcnt;
	int tai;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct posix_clock_context {
	struct posix_clock *clk;
	void *private_clkdata;
};

struct pps_source_info {
	char name[32];
	char path[32];
	int mode;
	void (*echo)(struct pps_device *, int, void *);
	struct module *owner;
	struct device *dev;
};

struct pps_ktime {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kparams {
	int api_version;
	int mode;
	struct pps_ktime assert_off_tu;
	struct pps_ktime clear_off_tu;
};

struct pps_device {
	struct pps_source_info info;
	struct pps_kparams params;
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	unsigned int last_ev;
	wait_queue_head_t queue;
	unsigned int id;
	const void *lookup_cookie;
	struct cdev cdev;
	struct device *dev;
	struct fasync_struct *async_queue;
	spinlock_t lock;
};

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct ptp_extts_event {
	struct ptp_clock_time t;
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct timestamp_event_queue {
	struct ptp_extts_event buf[128];
	int head;
	int tail;
	spinlock_t lock;
	struct list_head qlist;
	unsigned long *mask;
	struct dentry *debugfs_instance;
	struct debugfs_u32_array dfs_bitmap;
};

struct ptp_sys_offset_precise {
	struct ptp_clock_time device;
	struct ptp_clock_time sys_realtime;
	struct ptp_clock_time sys_monoraw;
	unsigned int rsv[4];
};

struct ptp_clock_caps {
	int max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int pps;
	int n_pins;
	int cross_timestamping;
	int adjust_phase;
	int max_phase_adj;
	int rsv[11];
};

struct ptp_sys_offset_extended {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[75];
};

struct ptp_sys_offset {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[51];
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
};

struct thermal_trip;

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	const struct thermal_trip *trip;
	bool initialized;
	unsigned long upper;
	unsigned long lower;
	unsigned long target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head tz_node;
	struct list_head cdev_node;
	unsigned int weight;
	bool upper_no_limit;
};

struct thermal_attr;

struct thermal_zone_device_ops;

struct thermal_zone_params;

struct thermal_governor;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct attribute_group trips_attribute_group;
	struct thermal_attr *trip_temp_attrs;
	struct thermal_attr *trip_type_attrs;
	struct thermal_attr *trip_hyst_attrs;
	enum thermal_device_mode mode;
	void *devdata;
	struct thermal_trip *trips;
	int num_trips;
	unsigned long passive_delay_jiffies;
	unsigned long polling_delay_jiffies;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	atomic_t need_update;
	struct thermal_zone_device_ops *ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct list_head thermal_instances;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

struct thermal_trip {
	int temperature;
	int hysteresis;
	enum thermal_trip_type type;
	void *priv;
};

struct thermal_zone_device_ops {
	int (*bind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*unbind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*set_trip_temp)(struct thermal_zone_device *, int, int);
	int (*set_trip_hyst)(struct thermal_zone_device *, int, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, const struct thermal_trip *, enum thermal_trend *);
	void (*hot)(struct thermal_zone_device *);
	void (*critical)(struct thermal_zone_device *);
};

struct thermal_zone_params {
	char governor_name[20];
	bool no_hwmon;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thermal_governor {
	char name[20];
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	int (*throttle)(struct thermal_zone_device *, const struct thermal_trip *);
	struct list_head governor_list;
};

struct hisi_thermal_sensor;

struct hisi_thermal_data;

struct hisi_thermal_ops {
	int (*get_temp)(struct hisi_thermal_sensor *);
	int (*enable_sensor)(struct hisi_thermal_sensor *);
	int (*disable_sensor)(struct hisi_thermal_sensor *);
	int (*irq_handler)(struct hisi_thermal_sensor *);
	int (*probe)(struct hisi_thermal_data *);
};

struct hisi_thermal_sensor {
	struct hisi_thermal_data *data;
	struct thermal_zone_device *tzd;
	const char *irq_name;
	uint32_t id;
	uint32_t thres_temp;
};

struct hisi_thermal_data {
	const struct hisi_thermal_ops *ops;
	struct hisi_thermal_sensor *sensor;
	struct platform_device *pdev;
	struct clk *clk;
	void *regs;
	int nr_sensors;
};

struct dev_ch_attribute {
	struct device_attribute attr;
	unsigned int channel;
};

enum scrub_type {
	SCRUB_UNKNOWN = 0,
	SCRUB_NONE = 1,
	SCRUB_SW_PROG = 2,
	SCRUB_SW_SRC = 3,
	SCRUB_SW_PROG_SRC = 4,
	SCRUB_SW_TUNABLE = 5,
	SCRUB_HW_PROG = 6,
	SCRUB_HW_SRC = 7,
	SCRUB_HW_PROG_SRC = 8,
	SCRUB_HW_TUNABLE = 9,
};

enum dev_type {
	DEV_UNKNOWN = 0,
	DEV_X1 = 1,
	DEV_X2 = 2,
	DEV_X4 = 3,
	DEV_X8 = 4,
	DEV_X16 = 5,
	DEV_X32 = 6,
	DEV_X64 = 7,
};

enum mem_type {
	MEM_EMPTY = 0,
	MEM_RESERVED = 1,
	MEM_UNKNOWN = 2,
	MEM_FPM = 3,
	MEM_EDO = 4,
	MEM_BEDO = 5,
	MEM_SDR = 6,
	MEM_RDR = 7,
	MEM_DDR = 8,
	MEM_RDDR = 9,
	MEM_RMBS = 10,
	MEM_DDR2 = 11,
	MEM_FB_DDR2 = 12,
	MEM_RDDR2 = 13,
	MEM_XDR = 14,
	MEM_DDR3 = 15,
	MEM_RDDR3 = 16,
	MEM_LRDDR3 = 17,
	MEM_LPDDR3 = 18,
	MEM_DDR4 = 19,
	MEM_RDDR4 = 20,
	MEM_LRDDR4 = 21,
	MEM_LPDDR4 = 22,
	MEM_DDR5 = 23,
	MEM_RDDR5 = 24,
	MEM_LRDDR5 = 25,
	MEM_NVDIMM = 26,
	MEM_WIO2 = 27,
	MEM_HBM2 = 28,
};

enum edac_type {
	EDAC_UNKNOWN = 0,
	EDAC_NONE = 1,
	EDAC_RESERVED = 2,
	EDAC_PARITY = 3,
	EDAC_EC = 4,
	EDAC_SECDED = 5,
	EDAC_S2ECD2ED = 6,
	EDAC_S4ECD4ED = 7,
	EDAC_S8ECD8ED = 8,
	EDAC_S16ECD16ED = 9,
};

enum edac_mc_layer_type {
	EDAC_MC_LAYER_BRANCH = 0,
	EDAC_MC_LAYER_CHANNEL = 1,
	EDAC_MC_LAYER_SLOT = 2,
	EDAC_MC_LAYER_CHIP_SELECT = 3,
	EDAC_MC_LAYER_ALL_MEM = 4,
};

enum hw_event_mc_err_type {
	HW_EVENT_ERR_CORRECTED = 0,
	HW_EVENT_ERR_UNCORRECTED = 1,
	HW_EVENT_ERR_DEFERRED = 2,
	HW_EVENT_ERR_FATAL = 3,
	HW_EVENT_ERR_INFO = 4,
};

struct mcidev_sysfs_attribute;

struct edac_raw_error_desc {
	char location[256];
	char label[296];
	long grain;
	u16 error_count;
	enum hw_event_mc_err_type type;
	int top_layer;
	int mid_layer;
	int low_layer;
	unsigned long page_frame_number;
	unsigned long offset_in_page;
	unsigned long syndrome;
	const char *msg;
	const char *other_detail;
};

struct csrow_info;

struct edac_mc_layer;

struct dimm_info;

struct mem_ctl_info {
	struct device dev;
	struct bus_type *bus;
	struct list_head link;
	struct module *owner;
	unsigned long mtype_cap;
	unsigned long edac_ctl_cap;
	unsigned long edac_cap;
	unsigned long scrub_cap;
	enum scrub_type scrub_mode;
	int (*set_sdram_scrub_rate)(struct mem_ctl_info *, u32);
	int (*get_sdram_scrub_rate)(struct mem_ctl_info *);
	void (*edac_check)(struct mem_ctl_info *);
	unsigned long (*ctl_page_to_phys)(struct mem_ctl_info *, unsigned long);
	int mc_idx;
	struct csrow_info **csrows;
	unsigned int nr_csrows;
	unsigned int num_cschannel;
	unsigned int n_layers;
	struct edac_mc_layer *layers;
	bool csbased;
	unsigned int tot_dimms;
	struct dimm_info **dimms;
	struct device *pdev;
	const char *mod_name;
	const char *ctl_name;
	const char *dev_name;
	void *pvt_info;
	unsigned long start_time;
	u32 ce_noinfo_count;
	u32 ue_noinfo_count;
	u32 ue_mc;
	u32 ce_mc;
	struct completion complete;
	const struct mcidev_sysfs_attribute *mc_driver_sysfs_attributes;
	struct delayed_work work;
	struct edac_raw_error_desc error_desc;
	int op_state;
	struct dentry *debugfs;
	u8 fake_inject_layer[3];
	bool fake_inject_ue;
	u16 fake_inject_count;
};

struct rank_info;

struct csrow_info {
	struct device dev;
	unsigned long first_page;
	unsigned long last_page;
	unsigned long page_mask;
	int csrow_idx;
	u32 ue_count;
	u32 ce_count;
	struct mem_ctl_info *mci;
	u32 nr_channels;
	struct rank_info **channels;
};

struct rank_info {
	int chan_idx;
	struct csrow_info *csrow;
	struct dimm_info *dimm;
	u32 ce_count;
};

struct dimm_info {
	struct device dev;
	char label[32];
	unsigned int location[3];
	struct mem_ctl_info *mci;
	unsigned int idx;
	u32 grain;
	enum dev_type dtype;
	enum mem_type mtype;
	enum edac_type edac_mode;
	u32 nr_pages;
	unsigned int csrow;
	unsigned int cschannel;
	u16 smbios_handle;
	u32 ce_count;
	u32 ue_count;
};

struct edac_mc_layer {
	enum edac_mc_layer_type type;
	unsigned int size;
	bool is_virt_csrow;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct cpufreq_stats {
	unsigned int total_trans;
	unsigned long long last_time;
	unsigned int max_state;
	unsigned int state_num;
	unsigned int last_index;
	u64 *time_in_state;
	unsigned int *freq_table;
	unsigned int *trans_table;
	unsigned int reset_pending;
	unsigned long long reset_time;
};

struct tegra124_cpufreq_priv {
	struct clk *cpu_clk;
	struct clk *pllp_clk;
	struct clk *pllx_clk;
	struct clk *dfll_clk;
	struct platform_device *cpufreq_dt_pdev;
};

typedef unsigned int mmc_pm_flag_t;

struct mmc_ios {
	unsigned int clock;
	unsigned short vdd;
	unsigned int power_delay_ms;
	unsigned char bus_mode;
	unsigned char chip_select;
	unsigned char power_mode;
	unsigned char bus_width;
	unsigned char timing;
	unsigned char signal_voltage;
	unsigned char drv_type;
	bool enhanced_strobe;
};

struct mmc_ctx {
	struct task_struct *task;
};

struct mmc_slot {
	int cd_irq;
	bool cd_wake_enabled;
	void *handler_priv;
};

struct mmc_supply {
	struct regulator *vmmc;
	struct regulator *vqmmc;
};

struct mmc_host_ops;

struct mmc_pwrseq;

struct mmc_card;

struct mmc_bus_ops;

struct mmc_request;

struct mmc_cqe_ops;

struct mmc_host {
	struct device *parent;
	struct device class_dev;
	int index;
	const struct mmc_host_ops *ops;
	struct mmc_pwrseq *pwrseq;
	unsigned int f_min;
	unsigned int f_max;
	unsigned int f_init;
	u32 ocr_avail;
	u32 ocr_avail_sdio;
	u32 ocr_avail_sd;
	u32 ocr_avail_mmc;
	struct wakeup_source *ws;
	u32 max_current_330;
	u32 max_current_300;
	u32 max_current_180;
	u32 caps;
	u32 caps2;
	int fixed_drv_type;
	mmc_pm_flag_t pm_caps;
	unsigned int max_seg_size;
	unsigned short max_segs;
	unsigned short unused;
	unsigned int max_req_size;
	unsigned int max_blk_size;
	unsigned int max_blk_count;
	unsigned int max_busy_timeout;
	spinlock_t lock;
	struct mmc_ios ios;
	unsigned int use_spi_crc: 1;
	unsigned int claimed: 1;
	unsigned int doing_init_tune: 1;
	unsigned int can_retune: 1;
	unsigned int doing_retune: 1;
	unsigned int retune_now: 1;
	unsigned int retune_paused: 1;
	unsigned int retune_crc_disable: 1;
	unsigned int can_dma_map_merge: 1;
	unsigned int vqmmc_enabled: 1;
	int rescan_disable;
	int rescan_entered;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct timer_list retune_timer;
	bool trigger_card_event;
	struct mmc_card *card;
	wait_queue_head_t wq;
	struct mmc_ctx *claimer;
	int claim_cnt;
	struct mmc_ctx default_ctx;
	struct delayed_work detect;
	int detect_change;
	struct mmc_slot slot;
	const struct mmc_bus_ops *bus_ops;
	unsigned int sdio_irqs;
	struct task_struct *sdio_irq_thread;
	struct work_struct sdio_irq_work;
	bool sdio_irq_pending;
	atomic_t sdio_irq_thread_abort;
	mmc_pm_flag_t pm_flags;
	struct led_trigger *led;
	bool regulator_enabled;
	struct mmc_supply supply;
	struct dentry *debugfs_root;
	struct mmc_request *ongoing_mrq;
	unsigned int actual_clock;
	unsigned int slotno;
	int dsr_req;
	u32 dsr;
	const struct mmc_cqe_ops *cqe_ops;
	void *cqe_private;
	int cqe_qdepth;
	bool cqe_enabled;
	bool cqe_on;
	bool hsq_enabled;
	int hsq_depth;
	u32 err_stats[15];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned long private[0];
};

struct mmc_host_ops {
	void (*post_req)(struct mmc_host *, struct mmc_request *, int);
	void (*pre_req)(struct mmc_host *, struct mmc_request *);
	void (*request)(struct mmc_host *, struct mmc_request *);
	int (*request_atomic)(struct mmc_host *, struct mmc_request *);
	void (*set_ios)(struct mmc_host *, struct mmc_ios *);
	int (*get_ro)(struct mmc_host *);
	int (*get_cd)(struct mmc_host *);
	void (*enable_sdio_irq)(struct mmc_host *, int);
	void (*ack_sdio_irq)(struct mmc_host *);
	void (*init_card)(struct mmc_host *, struct mmc_card *);
	int (*start_signal_voltage_switch)(struct mmc_host *, struct mmc_ios *);
	int (*card_busy)(struct mmc_host *);
	int (*execute_tuning)(struct mmc_host *, u32);
	int (*prepare_hs400_tuning)(struct mmc_host *, struct mmc_ios *);
	int (*execute_hs400_tuning)(struct mmc_host *, struct mmc_card *);
	int (*prepare_sd_hs_tuning)(struct mmc_host *, struct mmc_card *);
	int (*execute_sd_hs_tuning)(struct mmc_host *, struct mmc_card *);
	int (*hs400_prepare_ddr)(struct mmc_host *);
	void (*hs400_downgrade)(struct mmc_host *);
	void (*hs400_complete)(struct mmc_host *);
	void (*hs400_enhanced_strobe)(struct mmc_host *, struct mmc_ios *);
	int (*select_drive_strength)(struct mmc_card *, unsigned int, int, int, int *);
	void (*card_hw_reset)(struct mmc_host *);
	void (*card_event)(struct mmc_host *);
	int (*multi_io_quirk)(struct mmc_card *, unsigned int, int);
	int (*init_sd_express)(struct mmc_host *, struct mmc_ios *);
};

struct mmc_command;

struct mmc_data;

struct mmc_request {
	struct mmc_command *sbc;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_command *stop;
	struct completion completion;
	struct completion cmd_completion;
	void (*done)(struct mmc_request *);
	void (*recovery_notifier)(struct mmc_request *);
	struct mmc_host *host;
	bool cap_cmd_during_tfr;
	int tag;
};

struct mmc_command {
	u32 opcode;
	u32 arg;
	u32 resp[4];
	unsigned int flags;
	unsigned int retries;
	int error;
	unsigned int busy_timeout;
	struct mmc_data *data;
	struct mmc_request *mrq;
};

struct mmc_data {
	unsigned int timeout_ns;
	unsigned int timeout_clks;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int blk_addr;
	int error;
	unsigned int flags;
	unsigned int bytes_xfered;
	struct mmc_command *stop;
	struct mmc_request *mrq;
	unsigned int sg_len;
	int sg_count;
	struct scatterlist *sg;
	s32 host_cookie;
};

struct mmc_cid {
	unsigned int manfid;
	char prod_name[8];
	unsigned char prv;
	unsigned int serial;
	unsigned short oemid;
	unsigned short year;
	unsigned char hwrev;
	unsigned char fwrev;
	unsigned char month;
};

struct mmc_csd {
	unsigned char structure;
	unsigned char mmca_vsn;
	unsigned short cmdclass;
	unsigned short taac_clks;
	unsigned int taac_ns;
	unsigned int c_size;
	unsigned int r2w_factor;
	unsigned int max_dtr;
	unsigned int erase_size;
	unsigned int read_blkbits;
	unsigned int write_blkbits;
	unsigned int capacity;
	unsigned int read_partial: 1;
	unsigned int read_misalign: 1;
	unsigned int write_partial: 1;
	unsigned int write_misalign: 1;
	unsigned int dsr_imp: 1;
};

struct mmc_ext_csd {
	u8 rev;
	u8 erase_group_def;
	u8 sec_feature_support;
	u8 rel_sectors;
	u8 rel_param;
	bool enhanced_rpmb_supported;
	u8 part_config;
	u8 cache_ctrl;
	u8 rst_n_function;
	u8 max_packed_writes;
	u8 max_packed_reads;
	u8 packed_event_en;
	unsigned int part_time;
	unsigned int sa_timeout;
	unsigned int generic_cmd6_time;
	unsigned int power_off_longtime;
	u8 power_off_notification;
	unsigned int hs_max_dtr;
	unsigned int hs200_max_dtr;
	unsigned int sectors;
	unsigned int hc_erase_size;
	unsigned int hc_erase_timeout;
	unsigned int sec_trim_mult;
	unsigned int sec_erase_mult;
	unsigned int trim_timeout;
	bool partition_setting_completed;
	unsigned long long enhanced_area_offset;
	unsigned int enhanced_area_size;
	unsigned int cache_size;
	bool hpi_en;
	bool hpi;
	unsigned int hpi_cmd;
	bool bkops;
	bool man_bkops_en;
	bool auto_bkops_en;
	unsigned int data_sector_size;
	unsigned int data_tag_unit_size;
	unsigned int boot_ro_lock;
	bool boot_ro_lockable;
	bool ffu_capable;
	bool cmdq_en;
	bool cmdq_support;
	unsigned int cmdq_depth;
	u8 fwrev[8];
	u8 raw_exception_status;
	u8 raw_partition_support;
	u8 raw_rpmb_size_mult;
	u8 raw_erased_mem_count;
	u8 strobe_support;
	u8 raw_ext_csd_structure;
	u8 raw_card_type;
	u8 raw_driver_strength;
	u8 out_of_int_time;
	u8 raw_pwr_cl_52_195;
	u8 raw_pwr_cl_26_195;
	u8 raw_pwr_cl_52_360;
	u8 raw_pwr_cl_26_360;
	u8 raw_s_a_timeout;
	u8 raw_hc_erase_gap_size;
	u8 raw_erase_timeout_mult;
	u8 raw_hc_erase_grp_size;
	u8 raw_boot_mult;
	u8 raw_sec_trim_mult;
	u8 raw_sec_erase_mult;
	u8 raw_sec_feature_support;
	u8 raw_trim_mult;
	u8 raw_pwr_cl_200_195;
	u8 raw_pwr_cl_200_360;
	u8 raw_pwr_cl_ddr_52_195;
	u8 raw_pwr_cl_ddr_52_360;
	u8 raw_pwr_cl_ddr_200_360;
	u8 raw_bkops_status;
	u8 raw_sectors[4];
	u8 pre_eol_info;
	u8 device_life_time_est_typ_a;
	u8 device_life_time_est_typ_b;
	unsigned int feature_support;
};

struct sd_scr {
	unsigned char sda_vsn;
	unsigned char sda_spec3;
	unsigned char sda_spec4;
	unsigned char sda_specx;
	unsigned char bus_widths;
	unsigned char cmds;
};

struct sd_ssr {
	unsigned int au;
	unsigned int erase_timeout;
	unsigned int erase_offset;
};

struct sd_switch_caps {
	unsigned int hs_max_dtr;
	unsigned int uhs_max_dtr;
	unsigned int sd3_bus_mode;
	unsigned int sd3_drv_type;
	unsigned int sd3_curr_limit;
};

struct sd_ext_reg {
	u8 fno;
	u8 page;
	u16 offset;
	u8 rev;
	u8 feature_enabled;
	u8 feature_support;
};

struct sdio_cccr {
	unsigned int sdio_vsn;
	unsigned int sd_vsn;
	unsigned int multi_block: 1;
	unsigned int low_speed: 1;
	unsigned int wide_bus: 1;
	unsigned int high_power: 1;
	unsigned int high_speed: 1;
	unsigned int disable_cd: 1;
	unsigned int enable_async_irq: 1;
};

struct sdio_cis {
	unsigned short vendor;
	unsigned short device;
	unsigned short blksize;
	unsigned int max_dtr;
};

struct mmc_part {
	u64 size;
	unsigned int part_cfg;
	char name[20];
	bool force_ro;
	unsigned int area_type;
};

struct sdio_func;

struct sdio_func_tuple;

struct mmc_card {
	struct mmc_host *host;
	struct device dev;
	u32 ocr;
	unsigned int rca;
	unsigned int type;
	unsigned int state;
	unsigned int quirks;
	unsigned int quirk_max_rate;
	bool written_flag;
	bool reenable_cmdq;
	unsigned int erase_size;
	unsigned int erase_shift;
	unsigned int pref_erase;
	unsigned int eg_boundary;
	unsigned int erase_arg;
	u8 erased_byte;
	u32 raw_cid[4];
	u32 raw_csd[4];
	u32 raw_scr[2];
	u32 raw_ssr[16];
	struct mmc_cid cid;
	struct mmc_csd csd;
	struct mmc_ext_csd ext_csd;
	struct sd_scr scr;
	struct sd_ssr ssr;
	struct sd_switch_caps sw_caps;
	struct sd_ext_reg ext_power;
	struct sd_ext_reg ext_perf;
	unsigned int sdio_funcs;
	atomic_t sdio_funcs_probed;
	struct sdio_cccr cccr;
	struct sdio_cis cis;
	struct sdio_func *sdio_func[7];
	struct sdio_func *sdio_single_irq;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
	unsigned int sd_bus_speed;
	unsigned int mmc_avail_type;
	unsigned int drive_strength;
	struct dentry *debugfs_root;
	struct mmc_part part[7];
	unsigned int nr_parts;
	struct workqueue_struct *complete_wq;
};

struct mmc_bus_ops {
	void (*remove)(struct mmc_host *);
	void (*detect)(struct mmc_host *);
	int (*pre_suspend)(struct mmc_host *);
	int (*suspend)(struct mmc_host *);
	int (*resume)(struct mmc_host *);
	int (*runtime_suspend)(struct mmc_host *);
	int (*runtime_resume)(struct mmc_host *);
	int (*alive)(struct mmc_host *);
	int (*shutdown)(struct mmc_host *);
	int (*hw_reset)(struct mmc_host *);
	int (*sw_reset)(struct mmc_host *);
	bool (*cache_enabled)(struct mmc_host *);
	int (*flush_cache)(struct mmc_host *);
};

struct mmc_cqe_ops {
	int (*cqe_enable)(struct mmc_host *, struct mmc_card *);
	void (*cqe_disable)(struct mmc_host *);
	int (*cqe_request)(struct mmc_host *, struct mmc_request *);
	void (*cqe_post_req)(struct mmc_host *, struct mmc_request *);
	void (*cqe_off)(struct mmc_host *);
	int (*cqe_wait_for_idle)(struct mmc_host *);
	bool (*cqe_timeout)(struct mmc_host *, struct mmc_request *, bool *);
	void (*cqe_recovery_start)(struct mmc_host *);
	void (*cqe_recovery_finish)(struct mmc_host *);
};

struct sdhci_pltfm_data;

struct sdhci_am654_driver_data {
	const struct sdhci_pltfm_data *pdata;
	u32 flags;
};

struct sdhci_ops;

struct sdhci_pltfm_data {
	const struct sdhci_ops *ops;
	unsigned int quirks;
	unsigned int quirks2;
};

struct sdhci_host;

struct sdhci_ops {
	u32 (*read_l)(struct sdhci_host *, int);
	u16 (*read_w)(struct sdhci_host *, int);
	u8 (*read_b)(struct sdhci_host *, int);
	void (*write_l)(struct sdhci_host *, u32, int);
	void (*write_w)(struct sdhci_host *, u16, int);
	void (*write_b)(struct sdhci_host *, u8, int);
	void (*set_clock)(struct sdhci_host *, unsigned int);
	void (*set_power)(struct sdhci_host *, unsigned char, unsigned short);
	u32 (*irq)(struct sdhci_host *, u32);
	int (*set_dma_mask)(struct sdhci_host *);
	int (*enable_dma)(struct sdhci_host *);
	unsigned int (*get_max_clock)(struct sdhci_host *);
	unsigned int (*get_min_clock)(struct sdhci_host *);
	unsigned int (*get_timeout_clock)(struct sdhci_host *);
	unsigned int (*get_max_timeout_count)(struct sdhci_host *);
	void (*set_timeout)(struct sdhci_host *, struct mmc_command *);
	void (*set_bus_width)(struct sdhci_host *, int);
	void (*platform_send_init_74_clocks)(struct sdhci_host *, u8);
	unsigned int (*get_ro)(struct sdhci_host *);
	void (*reset)(struct sdhci_host *, u8);
	int (*platform_execute_tuning)(struct sdhci_host *, u32);
	void (*set_uhs_signaling)(struct sdhci_host *, unsigned int);
	void (*hw_reset)(struct sdhci_host *);
	void (*adma_workaround)(struct sdhci_host *, u32);
	void (*card_event)(struct sdhci_host *);
	void (*voltage_switch)(struct sdhci_host *);
	void (*adma_write_desc)(struct sdhci_host *, void **, dma_addr_t, int, unsigned int);
	void (*copy_to_bounce_buffer)(struct sdhci_host *, struct mmc_data *, unsigned int);
	void (*request_done)(struct sdhci_host *, struct mmc_request *);
	void (*dump_vendor_regs)(struct sdhci_host *);
};

struct sdhci_host {
	const char *hw_name;
	unsigned int quirks;
	unsigned int quirks2;
	int irq;
	void *ioaddr;
	phys_addr_t mapbase;
	char *bounce_buffer;
	dma_addr_t bounce_addr;
	unsigned int bounce_buffer_size;
	const struct sdhci_ops *ops;
	struct mmc_host *mmc;
	struct mmc_host_ops mmc_host_ops;
	u64 dma_mask;
	struct led_classdev led;
	char led_name[32];
	spinlock_t lock;
	int flags;
	unsigned int version;
	unsigned int max_clk;
	unsigned int timeout_clk;
	u8 max_timeout_count;
	unsigned int clk_mul;
	unsigned int clock;
	u8 pwr;
	u8 drv_type;
	bool reinit_uhs;
	bool runtime_suspended;
	bool bus_on;
	bool preset_enabled;
	bool pending_reset;
	bool irq_wake_enabled;
	bool v4_mode;
	bool use_external_dma;
	bool always_defer_done;
	struct mmc_request *mrqs_done[2];
	struct mmc_command *cmd;
	struct mmc_command *data_cmd;
	struct mmc_command *deferred_cmd;
	struct mmc_data *data;
	unsigned int data_early: 1;
	struct sg_mapping_iter sg_miter;
	unsigned int blocks;
	int sg_count;
	int max_adma;
	void *adma_table;
	void *align_buffer;
	size_t adma_table_sz;
	size_t align_buffer_sz;
	dma_addr_t adma_addr;
	dma_addr_t align_addr;
	unsigned int desc_sz;
	unsigned int alloc_desc_sz;
	struct workqueue_struct *complete_wq;
	struct work_struct complete_work;
	struct timer_list timer;
	struct timer_list data_timer;
	u32 caps;
	u32 caps1;
	bool read_caps;
	bool sdhci_core_to_disable_vqmmc;
	unsigned int ocr_avail_sdio;
	unsigned int ocr_avail_sd;
	unsigned int ocr_avail_mmc;
	u32 ocr_mask;
	unsigned int timing;
	u32 thread_isr;
	u32 ier;
	bool cqe_on;
	u32 cqe_ier;
	u32 cqe_err_ier;
	wait_queue_head_t buf_ready_int;
	unsigned int tuning_done;
	unsigned int tuning_count;
	unsigned int tuning_mode;
	unsigned int tuning_err;
	int tuning_delay;
	int tuning_loop_count;
	u32 sdma_boundary;
	u32 adma_table_cnt;
	u64 data_timeout;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned long private[0];
};

struct cqhci_host;

struct cqhci_host_ops {
	void (*dumpregs)(struct mmc_host *);
	void (*write_l)(struct cqhci_host *, u32, int);
	u32 (*read_l)(struct cqhci_host *, int);
	void (*enable)(struct mmc_host *);
	void (*disable)(struct mmc_host *, bool);
	void (*update_dcmd_desc)(struct mmc_host *, struct mmc_request *, u64 *);
	void (*pre_enable)(struct mmc_host *);
	void (*post_disable)(struct mmc_host *);
};

struct cqhci_slot;

struct cqhci_host {
	const struct cqhci_host_ops *ops;
	void *mmio;
	struct mmc_host *mmc;
	spinlock_t lock;
	unsigned int rca;
	bool dma64;
	int num_slots;
	int qcnt;
	u32 dcmd_slot;
	u32 caps;
	u32 quirks;
	bool enabled;
	bool halted;
	bool init_done;
	bool activated;
	bool waiting_for_idle;
	bool recovery_halt;
	size_t desc_size;
	size_t data_size;
	u8 *desc_base;
	u8 slot_sz;
	u8 task_desc_len;
	u8 link_desc_len;
	u8 *trans_desc_base;
	u8 trans_desc_len;
	dma_addr_t desc_dma_base;
	dma_addr_t trans_desc_dma_base;
	struct completion halt_comp;
	wait_queue_head_t wait_queue;
	struct cqhci_slot *slot;
};

struct timing_data {
	const char *otap_binding;
	const char *itap_binding;
	u32 capability;
};

struct sdhci_am654_data {
	struct regmap *base;
	bool legacy_otapdly;
	int otap_del_sel[11];
	int itap_del_sel[11];
	int clkbuf_sel;
	int trm_icp;
	int drv_strength;
	int strb_sel;
	u32 flags;
	u32 quirks;
};

struct sdhci_pltfm_host {
	struct clk *clk;
	unsigned int clock;
	u16 xfer_mode_shadow;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned long private[0];
};

struct sdhci_sparx5_data {
	struct sdhci_host *host;
	struct regmap *cpu_ctrl;
	int delay_clock;
};

struct led_trigger_cpu {
	bool is_active;
	char name[8];
	struct led_trigger *_trig;
};

enum cpu_led_event {
	CPU_LED_IDLE_START = 0,
	CPU_LED_IDLE_END = 1,
	CPU_LED_START = 2,
	CPU_LED_STOP = 3,
	CPU_LED_HALTED = 4,
};

struct tegra_bpmp;

struct tegra_bpmp_channel;

struct tegra_bpmp_ops {
	int (*init)(struct tegra_bpmp *);
	void (*deinit)(struct tegra_bpmp *);
	bool (*is_response_ready)(struct tegra_bpmp_channel *);
	bool (*is_request_ready)(struct tegra_bpmp_channel *);
	int (*ack_response)(struct tegra_bpmp_channel *);
	int (*ack_request)(struct tegra_bpmp_channel *);
	bool (*is_response_channel_free)(struct tegra_bpmp_channel *);
	bool (*is_request_channel_free)(struct tegra_bpmp_channel *);
	int (*post_response)(struct tegra_bpmp_channel *);
	int (*post_request)(struct tegra_bpmp_channel *);
	int (*ring_doorbell)(struct tegra_bpmp *);
	int (*resume)(struct tegra_bpmp *);
};

struct mbox_client {
	struct device *dev;
	bool tx_block;
	unsigned long tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct tegra_bpmp_soc;

struct mbox_chan;

struct tegra_bpmp_clk;

struct tegra_bpmp {
	const struct tegra_bpmp_soc *soc;
	struct device *dev;
	void *priv;
	struct {
		struct mbox_client client;
		struct mbox_chan *channel;
	} mbox;
	spinlock_t atomic_tx_lock;
	struct tegra_bpmp_channel *tx_channel;
	struct tegra_bpmp_channel *rx_channel;
	struct tegra_bpmp_channel *threaded_channels;
	struct {
		unsigned long *allocated;
		unsigned long *busy;
		unsigned int count;
		struct semaphore lock;
	} threaded;
	struct list_head mrqs;
	spinlock_t lock;
	struct tegra_bpmp_clk **clocks;
	unsigned int num_clocks;
	struct reset_controller_dev rstc;
	struct genpd_onecell_data genpd;
	struct dentry *debugfs_mirror;
	bool suspended;
};

struct tegra_bpmp_soc {
	struct {
		struct {
			unsigned int offset;
			unsigned int count;
			unsigned int timeout;
		} cpu_tx;
		struct {
			unsigned int offset;
			unsigned int count;
			unsigned int timeout;
		} thread;
		struct {
			unsigned int offset;
			unsigned int count;
			unsigned int timeout;
		} cpu_rx;
	} channels;
	const struct tegra_bpmp_ops *ops;
	unsigned int num_resets;
};

struct iosys_map {
	union {
		void *vaddr_iomem;
		void *vaddr;
	};
	bool is_iomem;
};

struct tegra_ivc;

struct tegra_bpmp_channel {
	struct tegra_bpmp *bpmp;
	struct iosys_map ib;
	struct iosys_map ob;
	struct completion completion;
	struct tegra_ivc *ivc;
	unsigned int index;
};

struct tegra210_bpmp {
	void *atomics;
	void *arb_sema;
	struct irq_data *tx_irq_data;
};

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(unsigned long, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	unsigned long retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	unsigned long min_delta_ticks;
	unsigned long max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct of_timer_base {
	void *base;
	const char *name;
	int index;
};

struct of_timer_irq {
	int irq;
	int index;
	int percpu;
	const char *name;
	unsigned long flags;
	irq_handler_t handler;
};

struct of_timer_clk {
	struct clk *clk;
	const char *name;
	int index;
	unsigned long rate;
	unsigned long period;
};

struct timer_of {
	unsigned int flags;
	struct device_node *np;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device clkevt;
	struct of_timer_base of_base;
	struct of_timer_irq of_irq;
	struct of_timer_clk of_clk;
	void *private_data;
	long: 64;
	long: 64;
};

struct usage_priority {
	__u32 usage;
	bool global;
	unsigned int slot_overwrite;
};

enum hid_report_type {
	HID_INPUT_REPORT = 0,
	HID_OUTPUT_REPORT = 1,
	HID_FEATURE_REPORT = 2,
	HID_REPORT_TYPES = 3,
};

enum hid_type {
	HID_TYPE_OTHER = 0,
	HID_TYPE_USBMOUSE = 1,
	HID_TYPE_USBNONE = 2,
};

enum hid_class_request {
	HID_REQ_GET_REPORT = 1,
	HID_REQ_GET_IDLE = 2,
	HID_REQ_GET_PROTOCOL = 3,
	HID_REQ_SET_REPORT = 9,
	HID_REQ_SET_IDLE = 10,
	HID_REQ_SET_PROTOCOL = 11,
};

struct hid_report;

struct input_dev;

struct hid_input {
	struct list_head list;
	struct hid_report *report;
	struct input_dev *input;
	const char *name;
	struct list_head reports;
	unsigned int application;
	bool registered;
};

struct hid_field;

struct hid_field_entry;

struct hid_device;

struct hid_report {
	struct list_head list;
	struct list_head hidinput_list;
	struct list_head field_entry_list;
	unsigned int id;
	enum hid_report_type type;
	unsigned int application;
	struct hid_field *field[256];
	struct hid_field_entry *field_entries;
	unsigned int maxfield;
	unsigned int size;
	struct hid_device *device;
	bool tool_active;
	unsigned int tool;
};

struct hid_usage;

struct hid_field {
	unsigned int physical;
	unsigned int logical;
	unsigned int application;
	struct hid_usage *usage;
	unsigned int maxusage;
	unsigned int flags;
	unsigned int report_offset;
	unsigned int report_size;
	unsigned int report_count;
	unsigned int report_type;
	__s32 *value;
	__s32 *new_value;
	__s32 *usages_priorities;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	bool ignored;
	struct hid_report *report;
	unsigned int index;
	struct hid_input *hidinput;
	__u16 dpad;
	unsigned int slot_idx;
};

struct hid_usage {
	unsigned int hid;
	unsigned int collection_index;
	unsigned int usage_index;
	__s8 resolution_multiplier;
	__s8 wheel_factor;
	__u16 code;
	__u8 type;
	__s8 hat_min;
	__s8 hat_max;
	__s8 hat_dir;
	__s16 wheel_accumulated;
};

struct hid_field_entry {
	struct list_head list;
	struct hid_field *field;
	unsigned int index;
	__s32 priority;
};

struct hid_report_enum {
	unsigned int numbered;
	struct list_head report_list;
	struct hid_report *report_id_hash[256];
};

struct hid_bpf_prog_list;

struct hid_bpf {
	u8 *device_data;
	u32 allocated_data;
	struct hid_bpf_prog_list __attribute__((btf_type_tag("rcu"))) *progs[2];
	bool destroyed;
	spinlock_t progs_lock;
};

struct hid_collection;

struct hid_driver;

struct hid_ll_driver;

struct hid_device {
	__u8 *dev_rdesc;
	unsigned int dev_rsize;
	__u8 *rdesc;
	unsigned int rsize;
	struct hid_collection *collection;
	unsigned int collection_size;
	unsigned int maxcollection;
	unsigned int maxapplication;
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	__u32 version;
	enum hid_type type;
	unsigned int country;
	struct hid_report_enum report_enum[3];
	struct work_struct led_work;
	struct semaphore driver_input_lock;
	struct device dev;
	struct hid_driver *driver;
	void *devres_group_id;
	const struct hid_ll_driver *ll_driver;
	struct mutex ll_open_lock;
	unsigned int ll_open_count;
	unsigned long status;
	unsigned int claimed;
	unsigned int quirks;
	unsigned int initial_quirks;
	bool io_started;
	struct list_head inputs;
	void *hiddev;
	void *hidraw;
	char name[128];
	char phys[64];
	char uniq[64];
	void *driver_data;
	int (*ff_init)(struct hid_device *);
	int (*hiddev_connect)(struct hid_device *, unsigned int);
	void (*hiddev_disconnect)(struct hid_device *);
	void (*hiddev_hid_event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*hiddev_report_event)(struct hid_device *, struct hid_report *);
	unsigned short debug;
	struct dentry *debug_dir;
	struct dentry *debug_rdesc;
	struct dentry *debug_events;
	struct list_head debug_list;
	spinlock_t debug_list_lock;
	wait_queue_head_t debug_wait;
	struct kref ref;
	unsigned int id;
	struct hid_bpf bpf;
};

struct hid_collection {
	int parent_idx;
	unsigned int type;
	unsigned int usage;
	unsigned int level;
};

struct hid_device_id;

struct hid_report_id;

struct hid_usage_id;

struct hid_driver {
	char *name;
	const struct hid_device_id *id_table;
	struct list_head dyn_list;
	spinlock_t dyn_lock;
	bool (*match)(struct hid_device *, bool);
	int (*probe)(struct hid_device *, const struct hid_device_id *);
	void (*remove)(struct hid_device *);
	const struct hid_report_id *report_table;
	int (*raw_event)(struct hid_device *, struct hid_report *, u8 *, int);
	const struct hid_usage_id *usage_table;
	int (*event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*report)(struct hid_device *, struct hid_report *);
	__u8 * (*report_fixup)(struct hid_device *, __u8 *, unsigned int *);
	int (*input_mapping)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, unsigned long **, int *);
	int (*input_mapped)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, unsigned long **, int *);
	int (*input_configured)(struct hid_device *, struct hid_input *);
	void (*feature_mapping)(struct hid_device *, struct hid_field *, struct hid_usage *);
	int (*suspend)(struct hid_device *, pm_message_t);
	int (*resume)(struct hid_device *);
	int (*reset_resume)(struct hid_device *);
	struct device_driver driver;
};

struct hid_device_id {
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	kernel_ulong_t driver_data;
};

struct hid_report_id {
	__u32 report_type;
};

struct hid_usage_id {
	__u32 usage_hid;
	__u32 usage_type;
	__u32 usage_code;
};

struct hid_ll_driver {
	int (*start)(struct hid_device *);
	void (*stop)(struct hid_device *);
	int (*open)(struct hid_device *);
	void (*close)(struct hid_device *);
	int (*power)(struct hid_device *, int);
	int (*parse)(struct hid_device *);
	void (*request)(struct hid_device *, struct hid_report *, int);
	int (*wait)(struct hid_device *);
	int (*raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, unsigned char, int);
	int (*output_report)(struct hid_device *, __u8 *, size_t);
	int (*idle)(struct hid_device *, int, int, int);
	bool (*may_wakeup)(struct hid_device *);
	unsigned int max_buffer_size;
};

struct hid_bpf_prog_list {
	u16 prog_idx[64];
	u8 prog_cnt;
};

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_keymap_entry;

struct ff_device;

struct input_dev_poller;

struct input_mt;

struct input_absinfo;

struct input_handle;

struct input_value;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	unsigned long propbit[1];
	unsigned long evbit[1];
	unsigned long keybit[12];
	unsigned long relbit[1];
	unsigned long absbit[1];
	unsigned long mscbit[1];
	unsigned long ledbit[1];
	unsigned long sndbit[1];
	unsigned long ffbit[2];
	unsigned long swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	unsigned long key[12];
	unsigned long led[1];
	unsigned long snd[1];
	unsigned long sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle __attribute__((btf_type_tag("rcu"))) *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
	bool inhibited;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct ff_effect;

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	unsigned long ffbit[2];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 __attribute__((btf_type_tag("user"))) *custom_data;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_handler;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	struct list_head d_node;
	struct list_head h_node;
};

struct input_device_id;

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	void (*events)(struct input_handle *, const struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[12];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[1];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[2];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

typedef bool (*hid_usage_cmp_t)(struct hid_usage *, unsigned int, unsigned int);

struct cros_ec_command;

typedef void (*btf_trace_cros_ec_request_start)(void *, struct cros_ec_command *);

struct cros_ec_command {
	uint32_t version;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	uint32_t result;
	uint8_t data[0];
};

typedef void (*btf_trace_cros_ec_request_done)(void *, struct cros_ec_command *, int);

struct trace_event_raw_cros_ec_request_start {
	struct trace_entry ent;
	uint32_t version;
	uint32_t offset;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	char __data[0];
};

struct trace_event_raw_cros_ec_request_done {
	struct trace_entry ent;
	uint32_t version;
	uint32_t offset;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	uint32_t result;
	int retval;
	char __data[0];
};

struct trace_event_data_offsets_cros_ec_request_start {};

struct trace_event_data_offsets_cros_ec_request_done {};

struct rpmsg_device_id;

struct rpmsg_device;

struct rpmsg_driver {
	struct device_driver drv;
	const struct rpmsg_device_id *id_table;
	int (*probe)(struct rpmsg_device *);
	void (*remove)(struct rpmsg_device *);
	int (*callback)(struct rpmsg_device *, void *, int, void *, u32);
	int (*flowcontrol)(struct rpmsg_device *, void *, bool);
};

struct rpmsg_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct rpmsg_endpoint;

struct rpmsg_device_ops;

struct rpmsg_device {
	struct device dev;
	struct rpmsg_device_id id;
	const char *driver_override;
	u32 src;
	u32 dst;
	struct rpmsg_endpoint *ept;
	bool announce;
	bool little_endian;
	const struct rpmsg_device_ops *ops;
};

typedef int (*rpmsg_rx_cb_t)(struct rpmsg_device *, void *, int, void *, u32);

typedef int (*rpmsg_flowcontrol_cb_t)(struct rpmsg_device *, void *, bool);

struct rpmsg_endpoint_ops;

struct rpmsg_endpoint {
	struct rpmsg_device *rpdev;
	struct kref refcount;
	rpmsg_rx_cb_t cb;
	rpmsg_flowcontrol_cb_t flow_cb;
	struct mutex cb_lock;
	u32 addr;
	void *priv;
	const struct rpmsg_endpoint_ops *ops;
};

struct rpmsg_endpoint_ops {
	void (*destroy_ept)(struct rpmsg_endpoint *);
	int (*send)(struct rpmsg_endpoint *, void *, int);
	int (*sendto)(struct rpmsg_endpoint *, void *, int, u32);
	int (*send_offchannel)(struct rpmsg_endpoint *, u32, u32, void *, int);
	int (*trysend)(struct rpmsg_endpoint *, void *, int);
	int (*trysendto)(struct rpmsg_endpoint *, void *, int, u32);
	int (*trysend_offchannel)(struct rpmsg_endpoint *, u32, u32, void *, int);
	__poll_t (*poll)(struct rpmsg_endpoint *, struct file *, poll_table *);
	int (*set_flow_control)(struct rpmsg_endpoint *, bool, u32);
	ssize_t (*get_mtu)(struct rpmsg_endpoint *);
};

struct rpmsg_channel_info;

struct rpmsg_device_ops {
	struct rpmsg_device * (*create_channel)(struct rpmsg_device *, struct rpmsg_channel_info *);
	int (*release_channel)(struct rpmsg_device *, struct rpmsg_channel_info *);
	struct rpmsg_endpoint * (*create_ept)(struct rpmsg_device *, rpmsg_rx_cb_t, void *, struct rpmsg_channel_info);
	int (*announce_create)(struct rpmsg_device *);
	int (*announce_destroy)(struct rpmsg_device *);
};

struct glink_ssr {
	struct device *dev;
	struct rpmsg_endpoint *ept;
	struct notifier_block nb;
	u32 seq_num;
	struct completion completion;
};

struct cleanup_done_msg {
	__le32 version;
	__le32 response;
	__le32 seq_num;
};

struct do_cleanup_msg {
	__le32 version;
	__le32 command;
	__le32 seq_num;
	__le32 name_len;
	char name[32];
};

enum iio_chan_type {
	IIO_VOLTAGE = 0,
	IIO_CURRENT = 1,
	IIO_POWER = 2,
	IIO_ACCEL = 3,
	IIO_ANGL_VEL = 4,
	IIO_MAGN = 5,
	IIO_LIGHT = 6,
	IIO_INTENSITY = 7,
	IIO_PROXIMITY = 8,
	IIO_TEMP = 9,
	IIO_INCLI = 10,
	IIO_ROT = 11,
	IIO_ANGL = 12,
	IIO_TIMESTAMP = 13,
	IIO_CAPACITANCE = 14,
	IIO_ALTVOLTAGE = 15,
	IIO_CCT = 16,
	IIO_PRESSURE = 17,
	IIO_HUMIDITYRELATIVE = 18,
	IIO_ACTIVITY = 19,
	IIO_STEPS = 20,
	IIO_ENERGY = 21,
	IIO_DISTANCE = 22,
	IIO_VELOCITY = 23,
	IIO_CONCENTRATION = 24,
	IIO_RESISTANCE = 25,
	IIO_PH = 26,
	IIO_UVINDEX = 27,
	IIO_ELECTRICALCONDUCTIVITY = 28,
	IIO_COUNT = 29,
	IIO_INDEX = 30,
	IIO_GRAVITY = 31,
	IIO_POSITIONRELATIVE = 32,
	IIO_PHASE = 33,
	IIO_MASSCONCENTRATION = 34,
	IIO_DELTA_ANGL = 35,
	IIO_DELTA_VELOCITY = 36,
	IIO_COLORTEMP = 37,
	IIO_CHROMATICITY = 38,
};

enum iio_endian {
	IIO_CPU = 0,
	IIO_BE = 1,
	IIO_LE = 2,
};

enum iio_event_type {
	IIO_EV_TYPE_THRESH = 0,
	IIO_EV_TYPE_MAG = 1,
	IIO_EV_TYPE_ROC = 2,
	IIO_EV_TYPE_THRESH_ADAPTIVE = 3,
	IIO_EV_TYPE_MAG_ADAPTIVE = 4,
	IIO_EV_TYPE_CHANGE = 5,
	IIO_EV_TYPE_MAG_REFERENCED = 6,
	IIO_EV_TYPE_GESTURE = 7,
};

enum iio_event_direction {
	IIO_EV_DIR_EITHER = 0,
	IIO_EV_DIR_RISING = 1,
	IIO_EV_DIR_FALLING = 2,
	IIO_EV_DIR_NONE = 3,
	IIO_EV_DIR_SINGLETAP = 4,
	IIO_EV_DIR_DOUBLETAP = 5,
};

enum iio_shared_by {
	IIO_SEPARATE = 0,
	IIO_SHARED_BY_TYPE = 1,
	IIO_SHARED_BY_DIR = 2,
	IIO_SHARED_BY_ALL = 3,
};

enum iio_event_info {
	IIO_EV_INFO_ENABLE = 0,
	IIO_EV_INFO_VALUE = 1,
	IIO_EV_INFO_HYSTERESIS = 2,
	IIO_EV_INFO_PERIOD = 3,
	IIO_EV_INFO_HIGH_PASS_FILTER_3DB = 4,
	IIO_EV_INFO_LOW_PASS_FILTER_3DB = 5,
	IIO_EV_INFO_TIMEOUT = 6,
	IIO_EV_INFO_RESET_TIMEOUT = 7,
	IIO_EV_INFO_TAP2_MIN_DELAY = 8,
	IIO_EV_INFO_RUNNING_PERIOD = 9,
	IIO_EV_INFO_RUNNING_COUNT = 10,
};

struct iio_buffer;

struct iio_trigger;

struct iio_poll_func;

struct iio_chan_spec;

struct iio_info;

struct iio_buffer_setup_ops;

struct iio_dev {
	int modes;
	struct device dev;
	struct iio_buffer *buffer;
	int scan_bytes;
	const unsigned long *available_scan_masks;
	unsigned int masklength;
	const unsigned long *active_scan_mask;
	bool scan_timestamp;
	struct iio_trigger *trig;
	struct iio_poll_func *pollfunc;
	struct iio_poll_func *pollfunc_event;
	const struct iio_chan_spec *channels;
	int num_channels;
	const char *name;
	const char *label;
	const struct iio_info *info;
	const struct iio_buffer_setup_ops *setup_ops;
	void *priv;
};

struct iio_event_interface;

struct iio_ioctl_handler;

struct iio_dev_opaque {
	struct iio_dev indio_dev;
	int currentmode;
	int id;
	struct module *driver_module;
	struct mutex mlock;
	struct lock_class_key mlock_key;
	struct mutex info_exist_lock;
	bool trig_readonly;
	struct iio_event_interface *event_interface;
	struct iio_buffer **attached_buffers;
	unsigned int attached_buffers_cnt;
	struct iio_ioctl_handler *buffer_ioctl_handler;
	struct list_head buffer_list;
	struct list_head channel_attr_list;
	struct attribute_group chan_attr_group;
	struct list_head ioctl_handlers;
	const struct attribute_group **groups;
	int groupcounter;
	struct attribute_group legacy_scan_el_group;
	struct attribute_group legacy_buffer_group;
	void *bounce_buffer;
	size_t bounce_buffer_size;
	unsigned int scan_index_timestamp;
	clockid_t clock_id;
	struct cdev chrdev;
	unsigned long flags;
	struct dentry *debugfs_dentry;
	unsigned int cached_reg_addr;
	char read_buf[20];
	unsigned int read_buf_len;
};

struct iio_event_spec;

struct iio_chan_spec_ext_info;

struct iio_chan_spec {
	enum iio_chan_type type;
	int channel;
	int channel2;
	unsigned long address;
	int scan_index;
	struct {
		char sign;
		u8 realbits;
		u8 storagebits;
		u8 shift;
		u8 repeat;
		enum iio_endian endianness;
	} scan_type;
	long info_mask_separate;
	long info_mask_separate_available;
	long info_mask_shared_by_type;
	long info_mask_shared_by_type_available;
	long info_mask_shared_by_dir;
	long info_mask_shared_by_dir_available;
	long info_mask_shared_by_all;
	long info_mask_shared_by_all_available;
	const struct iio_event_spec *event_spec;
	unsigned int num_event_specs;
	const struct iio_chan_spec_ext_info *ext_info;
	const char *extend_name;
	const char *datasheet_name;
	unsigned int modified: 1;
	unsigned int indexed: 1;
	unsigned int output: 1;
	unsigned int differential: 1;
};

struct iio_event_spec {
	enum iio_event_type type;
	enum iio_event_direction dir;
	unsigned long mask_separate;
	unsigned long mask_shared_by_type;
	unsigned long mask_shared_by_dir;
	unsigned long mask_shared_by_all;
};

struct iio_chan_spec_ext_info {
	const char *name;
	enum iio_shared_by shared;
	ssize_t (*read)(struct iio_dev *, uintptr_t, const struct iio_chan_spec *, char *);
	ssize_t (*write)(struct iio_dev *, uintptr_t, const struct iio_chan_spec *, const char *, size_t);
	uintptr_t private;
};

struct iio_info {
	const struct attribute_group *event_attrs;
	const struct attribute_group *attrs;
	int (*read_raw)(struct iio_dev *, const struct iio_chan_spec *, int *, int *, long);
	int (*read_raw_multi)(struct iio_dev *, const struct iio_chan_spec *, int, int *, int *, long);
	int (*read_avail)(struct iio_dev *, const struct iio_chan_spec *, const int **, int *, int *, long);
	int (*write_raw)(struct iio_dev *, const struct iio_chan_spec *, int, int, long);
	int (*read_label)(struct iio_dev *, const struct iio_chan_spec *, char *);
	int (*write_raw_get_fmt)(struct iio_dev *, const struct iio_chan_spec *, long);
	int (*read_event_config)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction);
	int (*write_event_config)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, int);
	int (*read_event_value)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, enum iio_event_info, int *, int *);
	int (*write_event_value)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, enum iio_event_info, int, int);
	int (*read_event_label)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, char *);
	int (*validate_trigger)(struct iio_dev *, struct iio_trigger *);
	int (*update_scan_mode)(struct iio_dev *, const unsigned long *);
	int (*debugfs_reg_access)(struct iio_dev *, unsigned int, unsigned int, unsigned int *);
	int (*fwnode_xlate)(struct iio_dev *, const struct fwnode_reference_args *);
	int (*hwfifo_set_watermark)(struct iio_dev *, unsigned int);
	int (*hwfifo_flush_to_buffer)(struct iio_dev *, unsigned int);
};

struct iio_buffer_setup_ops {
	int (*preenable)(struct iio_dev *);
	int (*postenable)(struct iio_dev *);
	int (*predisable)(struct iio_dev *);
	int (*postdisable)(struct iio_dev *);
	bool (*validate_scan_mask)(struct iio_dev *, const unsigned long *);
};

struct iio_event_data {
	__u64 id;
	__s64 timestamp;
};

struct iio_ioctl_handler {
	struct list_head entry;
	long (*ioctl)(struct iio_dev *, struct file *, unsigned int, unsigned long);
};

struct iio_event_interface {
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct iio_event_data *type;
			const struct iio_event_data *const_type;
			char (*rectype)[0];
			struct iio_event_data *ptr;
			const struct iio_event_data *ptr_const;
		};
		struct iio_event_data buf[16];
	} det_events;
	struct list_head dev_attr_list;
	unsigned long flags;
	struct attribute_group group;
	struct mutex read_lock;
	struct iio_ioctl_handler ioctl_handler;
};

struct iio_dev_attr {
	struct device_attribute dev_attr;
	u64 address;
	struct list_head l;
	const struct iio_chan_spec *c;
	struct iio_buffer *buffer;
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
	NVMEM_LAYOUT_ADD = 5,
	NVMEM_LAYOUT_REMOVE = 6,
};

struct nvmem_device {
	struct module *owner;
	struct device dev;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	struct gpio_desc *wp_gpio;
	struct nvmem_layout *layout;
	void *priv;
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

struct nvmem_cell_entry {
	const char *name;
	int offset;
	size_t raw_len;
	int bytes;
	int bit_offset;
	int nbits;
	nvmem_cell_post_process_t read_post_process;
	void *priv;
	struct device_node *np;
	struct nvmem_device *nvmem;
	struct list_head node;
};

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

struct nvmem_cell {
	struct nvmem_cell_entry *entry;
	const char *id;
	int index;
};

typedef void (*dr_release_t)(struct device *, void *);

typedef int (*dr_match_t)(struct device *, void *, void *);

struct icc_path;

struct icc_bulk_data {
	struct icc_path *path;
	const char *name;
	u32 avg_bw;
	u32 peak_bw;
};

struct icc_bulk_devres {
	struct icc_bulk_data *paths;
	int num_paths;
};

struct hte_chip;

struct hte_ts_desc;

struct hte_clk_info;

struct hte_ops {
	int (*request)(struct hte_chip *, struct hte_ts_desc *, u32);
	int (*release)(struct hte_chip *, struct hte_ts_desc *, u32);
	int (*enable)(struct hte_chip *, u32);
	int (*disable)(struct hte_chip *, u32);
	int (*get_clk_src_info)(struct hte_chip *, struct hte_clk_info *);
};

struct hte_device;

struct hte_chip {
	const char *name;
	struct device *dev;
	const struct hte_ops *ops;
	u32 nlines;
	int (*xlate_of)(struct hte_chip *, const struct of_phandle_args *, struct hte_ts_desc *, u32 *);
	int (*xlate_plat)(struct hte_chip *, struct hte_ts_desc *, u32 *);
	bool (*match_from_linedata)(const struct hte_chip *, const struct hte_ts_desc *);
	u8 of_hte_n_cells;
	struct hte_device *gdev;
	void *data;
};

struct hte_line_attr {
	u32 line_id;
	void *line_data;
	unsigned long edge_flags;
	const char *name;
};

struct hte_ts_desc {
	struct hte_line_attr attr;
	void *hte_data;
};

struct hte_clk_info {
	u64 hz;
	clockid_t type;
};

enum tegra_hte_type {
	HTE_TEGRA_TYPE_GPIO = 1,
	HTE_TEGRA_TYPE_LIC = 2,
};

struct tegra_hte_line_mapped;

struct tegra_hte_data {
	enum tegra_hte_type type;
	u32 slices;
	u32 map_sz;
	u32 sec_map_sz;
	const struct tegra_hte_line_mapped *map;
	const struct tegra_hte_line_mapped *sec_map;
};

struct tegra_hte_line_mapped {
	int slice;
	u32 bit_index;
};

struct hte_slices;

struct tegra_hte_line_data;

struct tegra_hte_soc {
	int hte_irq;
	u32 itr_thrshld;
	u32 conf_rval;
	struct hte_slices *sl;
	const struct tegra_hte_data *prov_data;
	struct tegra_hte_line_data *line_data;
	struct hte_chip *chip;
	struct gpio_device *gdev;
	void *regs;
};

struct hte_slices {
	u32 r_val;
	unsigned long flags;
	spinlock_t s_lock;
};

struct tegra_hte_line_data {
	unsigned long flags;
	void *data;
};

struct hte_ts_data {
	u64 tsc;
	u64 seq;
	int raw_level;
};

struct gpio_desc {
	struct gpio_device *gdev;
	unsigned long flags;
	const char *label;
	const char *name;
	unsigned int debounce_period_us;
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	unsigned int *id;
	size_t size;
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
};

struct rps_sock_flow_table {
	u32 mask;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 ents[0];
};

struct __call_single_data {
	struct __call_single_node node;
	smp_call_func_t func;
	void *info;
};

typedef struct __call_single_data call_single_data_t;

struct sd_flow_limit;

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	unsigned int processed;
	unsigned int time_squeeze;
	struct softnet_data *rps_ipi_list;
	bool in_net_rx_action;
	bool in_napi_threaded_poll;
	struct sd_flow_limit __attribute__((btf_type_tag("rcu"))) *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct {
		u16 recursion;
		u8 more;
		u8 skip_txqueue;
	} xmit;
	long: 64;
	long: 64;
	long: 64;
	unsigned int input_queue_head;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	unsigned int received_rps;
	unsigned int dropped;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t defer_lock;
	int defer_count;
	int defer_ipi_scheduled;
	struct sk_buff *defer_list;
	long: 64;
	call_single_data_t defer_csd;
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct inet_ehash_bucket;

struct inet_bind_hashbucket;

struct inet_listen_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	struct kmem_cache *bind2_bucket_cachep;
	struct inet_bind_hashbucket *bhash2;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	bool pernet;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	struct hlist_nulls_head nulls_head;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	u32 prior_delivered_ce;
	s32 delivered;
	s32 delivered_ce;
	long interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	u32 last_end_seq;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	netdevice_tracker nhc_dev_tracker;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable __attribute__((btf_type_tag("rcu"))) * __attribute__((btf_type_tag("percpu"))) *nhc_pcpu_rth_output;
	struct rtable __attribute__((btf_type_tag("rcu"))) *nhc_rth_input;
	struct fnhe_hash_bucket __attribute__((btf_type_tag("rcu"))) *nhc_exceptions;
};

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	struct rt6_info * __attribute__((btf_type_tag("percpu"))) *rt6i_pcpu;
	struct rt6_exception_bucket __attribute__((btf_type_tag("rcu"))) *rt6i_exception_bucket;
};

struct fib6_node;

struct dst_metrics;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info __attribute__((btf_type_tag("rcu"))) *fib6_next;
	struct fib6_node __attribute__((btf_type_tag("rcu"))) *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	unsigned long expires;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 unused: 4;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct fib6_node {
	struct fib6_node __attribute__((btf_type_tag("rcu"))) *parent;
	struct fib6_node __attribute__((btf_type_tag("rcu"))) *left;
	struct fib6_node __attribute__((btf_type_tag("rcu"))) *right;
	struct fib6_node __attribute__((btf_type_tag("rcu"))) *subtree;
	struct fib6_info __attribute__((btf_type_tag("rcu"))) *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info __attribute__((btf_type_tag("rcu"))) *rr_ptr;
	struct callback_head rcu;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
};

struct fib_nh_exception;

struct fnhe_hash_bucket {
	struct fib_nh_exception __attribute__((btf_type_tag("rcu"))) *chain;
};

struct fib_nh_exception {
	struct fib_nh_exception __attribute__((btf_type_tag("rcu"))) *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	unsigned long fnhe_expires;
	struct rtable __attribute__((btf_type_tag("rcu"))) *fnhe_rth_input;
	struct rtable __attribute__((btf_type_tag("rcu"))) *fnhe_rth_output;
	unsigned long fnhe_stamp;
	struct callback_head rcu;
};

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info __attribute__((btf_type_tag("rcu"))) *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	unsigned short rt6i_nfheader_len;
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
};

struct in_ifaddr {
	struct hlist_node hash;
	struct in_ifaddr __attribute__((btf_type_tag("rcu"))) *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	unsigned char ifa_proto;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	unsigned long ifa_cstamp;
	unsigned long ifa_tstamp;
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	unsigned long sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list __attribute__((btf_type_tag("rcu"))) *next_rcu;
	};
	struct ip_mc_list __attribute__((btf_type_tag("rcu"))) *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	struct callback_head rcu;
};

struct bpf_cgroup_storage_key {
	__u64 cgroup_inode_id;
	__u32 attach_type;
};

struct bpf_storage_buffer;

struct bpf_cgroup_storage_map;

struct bpf_cgroup_storage {
	union {
		struct bpf_storage_buffer *buf;
		void __attribute__((btf_type_tag("percpu"))) *percpu_buf;
	};
	struct bpf_cgroup_storage_map *map;
	struct bpf_cgroup_storage_key key;
	struct list_head list_map;
	struct list_head list_cg;
	struct rb_node node;
	struct callback_head rcu;
};

struct bpf_storage_buffer {
	struct callback_head rcu;
	char data[0];
};

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *, enum skb_drop_reason);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *, void *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long, int);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

typedef void (*btf_trace_inet_sk_error_report)(void *, const struct sock *);

typedef void (*btf_trace_sk_data_ready)(void *, const struct sock *);

typedef void (*btf_trace_sock_send_length)(void *, struct sock *, int, int);

typedef void (*btf_trace_sock_recv_length)(void *, struct sock *, int, int);

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *);

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_tcp_bad_csum)(void *, const struct sk_buff *);

typedef void (*btf_trace_tcp_cong_state_set)(void *, struct sock *, const u8);

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_enqueue)(void *, struct Qdisc *, const struct netdev_queue *, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);

struct net_bridge;

struct net_bridge_port;

typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);

struct bridge_id {
	unsigned char prio[2];
	unsigned char addr[6];
};

typedef struct bridge_id bridge_id;

struct bridge_mcast_other_query {
	struct timer_list timer;
	unsigned long delay_time;
};

struct bridge_mcast_own_query {
	struct timer_list timer;
	u32 startup_sent;
};

struct br_ip {
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} src;
	union {
		__be32 ip4;
		struct in6_addr ip6;
		unsigned char mac_addr[6];
	} dst;
	__be16 proto;
	__u16 vid;
};

struct bridge_mcast_querier {
	struct br_ip addr;
	int port_ifidx;
	seqcount_spinlock_t seq;
};

struct net_bridge_vlan;

struct net_bridge_mcast {
	struct net_bridge *br;
	struct net_bridge_vlan *vlan;
	u32 multicast_last_member_count;
	u32 multicast_startup_query_count;
	u8 multicast_querier;
	u8 multicast_igmp_version;
	u8 multicast_router;
	u8 multicast_mld_version;
	unsigned long multicast_last_member_interval;
	unsigned long multicast_membership_interval;
	unsigned long multicast_querier_interval;
	unsigned long multicast_query_interval;
	unsigned long multicast_query_response_interval;
	unsigned long multicast_startup_query_interval;
	struct hlist_head ip4_mc_router_list;
	struct timer_list ip4_mc_router_timer;
	struct bridge_mcast_other_query ip4_other_query;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_querier ip4_querier;
	struct hlist_head ip6_mc_router_list;
	struct timer_list ip6_mc_router_timer;
	struct bridge_mcast_other_query ip6_other_query;
	struct bridge_mcast_own_query ip6_own_query;
	struct bridge_mcast_querier ip6_querier;
};

struct net_bridge_vlan_group;

struct bridge_mcast_stats;

struct net_bridge {
	spinlock_t lock;
	spinlock_t hash_lock;
	struct hlist_head frame_type_list;
	struct net_device *dev;
	unsigned long options;
	__be16 vlan_proto;
	u16 default_pvid;
	struct net_bridge_vlan_group __attribute__((btf_type_tag("rcu"))) *vlgrp;
	struct rhashtable fdb_hash_tbl;
	struct list_head port_list;
	union {
		struct rtable fake_rtable;
		struct rt6_info fake_rt6_info;
	};
	u16 group_fwd_mask;
	u16 group_fwd_mask_required;
	bridge_id designated_root;
	bridge_id bridge_id;
	unsigned char topology_change;
	unsigned char topology_change_detected;
	u16 root_port;
	unsigned long max_age;
	unsigned long hello_time;
	unsigned long forward_delay;
	unsigned long ageing_time;
	unsigned long bridge_max_age;
	unsigned long bridge_hello_time;
	unsigned long bridge_forward_delay;
	unsigned long bridge_ageing_time;
	u32 root_path_cost;
	u8 group_addr[6];
	enum {
		BR_NO_STP = 0,
		BR_KERNEL_STP = 1,
		BR_USER_STP = 2,
	} stp_enabled;
	struct net_bridge_mcast multicast_ctx;
	struct bridge_mcast_stats __attribute__((btf_type_tag("percpu"))) *mcast_stats;
	u32 hash_max;
	spinlock_t multicast_lock;
	struct rhashtable mdb_hash_tbl;
	struct rhashtable sg_port_tbl;
	struct hlist_head mcast_gc_list;
	struct hlist_head mdb_list;
	struct work_struct mcast_gc_work;
	struct timer_list hello_timer;
	struct timer_list tcn_timer;
	struct timer_list topology_change_timer;
	struct delayed_work gc_work;
	struct kobject *ifobj;
	u32 auto_cnt;
	atomic_t fdb_n_learned;
	u32 fdb_max_learned;
	int last_hwdom;
	unsigned long busy_hwdoms;
	struct hlist_head fdb_list;
};

struct net_bridge_vlan_group {
	struct rhashtable vlan_hash;
	struct rhashtable tunnel_hash;
	struct list_head vlan_list;
	u16 num_vlans;
	u16 pvid;
	u8 pvid_state;
};

struct net_bridge_mcast_port {
	struct net_bridge_port *port;
	struct net_bridge_vlan *vlan;
	struct bridge_mcast_own_query ip4_own_query;
	struct timer_list ip4_mc_router_timer;
	struct hlist_node ip4_rlist;
	struct bridge_mcast_own_query ip6_own_query;
	struct timer_list ip6_mc_router_timer;
	struct hlist_node ip6_rlist;
	unsigned char multicast_router;
	u32 mdb_n_entries;
	u32 mdb_max_entries;
};

struct metadata_dst;

struct br_tunnel_info {
	__be64 tunnel_id;
	struct metadata_dst __attribute__((btf_type_tag("rcu"))) *tunnel_dst;
};

struct net_bridge_vlan {
	struct rhash_head vnode;
	struct rhash_head tnode;
	u16 vid;
	u16 flags;
	u16 priv_flags;
	u8 state;
	struct pcpu_sw_netstats __attribute__((btf_type_tag("percpu"))) *stats;
	union {
		struct net_bridge *br;
		struct net_bridge_port *port;
	};
	union {
		refcount_t refcnt;
		struct net_bridge_vlan *brvlan;
	};
	struct br_tunnel_info tinfo;
	union {
		struct net_bridge_mcast br_mcast_ctx;
		struct net_bridge_mcast_port port_mcast_ctx;
	};
	u16 msti;
	struct list_head vlist;
	struct callback_head rcu;
};

typedef __u16 port_id;

struct bridge_stp_xstats {
	__u64 transition_blk;
	__u64 transition_fwd;
	__u64 rx_bpdu;
	__u64 tx_bpdu;
	__u64 rx_tcn;
	__u64 tx_tcn;
};

struct net_bridge_port {
	struct net_bridge *br;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head list;
	unsigned long flags;
	struct net_bridge_vlan_group __attribute__((btf_type_tag("rcu"))) *vlgrp;
	struct net_bridge_port __attribute__((btf_type_tag("rcu"))) *backup_port;
	u32 backup_nhid;
	u8 priority;
	u8 state;
	u16 port_no;
	unsigned char topology_change_ack;
	unsigned char config_pending;
	port_id port_id;
	port_id designated_port;
	bridge_id designated_root;
	bridge_id designated_bridge;
	u32 path_cost;
	u32 designated_cost;
	unsigned long designated_age;
	struct timer_list forward_delay_timer;
	struct timer_list hold_timer;
	struct timer_list message_age_timer;
	struct kobject kobj;
	struct callback_head rcu;
	struct net_bridge_mcast_port multicast_ctx;
	struct bridge_mcast_stats __attribute__((btf_type_tag("percpu"))) *mcast_stats;
	u32 multicast_eht_hosts_limit;
	u32 multicast_eht_hosts_cnt;
	struct hlist_head mglist;
	char sysfs_name[16];
	int hwdom;
	int offload_count;
	struct netdev_phys_item_id ppid;
	u16 group_fwd_mask;
	u16 backup_redirected_cnt;
	struct bridge_stp_xstats stp_xstats;
};

struct br_mcast_stats {
	__u64 igmp_v1queries[2];
	__u64 igmp_v2queries[2];
	__u64 igmp_v3queries[2];
	__u64 igmp_leaves[2];
	__u64 igmp_v1reports[2];
	__u64 igmp_v2reports[2];
	__u64 igmp_v3reports[2];
	__u64 igmp_parse_errors;
	__u64 mld_v1queries[2];
	__u64 mld_v2queries[2];
	__u64 mld_leaves[2];
	__u64 mld_v1reports[2];
	__u64 mld_v2reports[2];
	__u64 mld_parse_errors;
	__u64 mcast_bytes[2];
	__u64 mcast_packets[2];
};

struct bridge_mcast_stats {
	struct br_mcast_stats mstats;
	struct u64_stats_sync syncp;
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
	METADATA_MACSEC = 2,
	METADATA_XFRM = 3,
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	__be16 tun_flags;
	u8 tos;
	u8 ttl;
	__be32 label;
	u32 nhid;
	__be16 tp_src;
	__be16 tp_dst;
	__u8 flow_flags;
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu __attribute__((btf_type_tag("percpu"))) *cache;
	unsigned long reset_ts;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct ip_tunnel_encap encap;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

typedef u64 sci_t;

struct macsec_info {
	sci_t sci;
};

struct xfrm_md_info {
	u32 if_id;
	int link;
	struct dst_entry *dst_orig;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
		struct macsec_info macsec_info;
		struct xfrm_md_info xfrm_info;
	} u;
};

struct net_bridge_fdb_entry;

typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);

struct mac_addr {
	unsigned char addr[6];
};

typedef struct mac_addr mac_addr;

struct net_bridge_fdb_key {
	mac_addr addr;
	u16 vlan_id;
};

struct net_bridge_fdb_entry {
	struct rhash_head rhnode;
	struct net_bridge_port *dst;
	struct net_bridge_fdb_key key;
	struct hlist_node fdb_node;
	unsigned long flags;
	long: 64;
	long: 64;
	unsigned long updated;
	unsigned long used;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, unsigned long);

typedef void (*btf_trace_br_mdb_full)(void *, const struct net_device *, const struct br_ip *);

typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
};

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	unsigned short protocol;
	enum skb_drop_reason reason;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long sysctl_mem[3];
	long allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct ip_options;

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	u64 transmit_time;
	u32 mark;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_options_rcu;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	unsigned long inet_flags;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__be16 inet_sport;
	struct ip_options_rcu __attribute__((btf_type_tag("rcu"))) *inet_opt;
	atomic_t inet_id;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	struct {
		__u16 lo;
		__u16 hi;
	} local_port_range;
	struct ip_mc_socklist __attribute__((btf_type_tag("rcu"))) *mc_list;
	struct inet_cork_full cork;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct ipv6_txoptions;

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	const struct in6_addr *saddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	s16 hop_limit;
	u8 mcast_hops;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u8 srcprefs;
	__u8 pmtudisc;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	struct ipv6_mc_socklist __attribute__((btf_type_tag("rcu"))) *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist __attribute__((btf_type_tag("rcu"))) *ipv6_fl_list;
	struct ipv6_txoptions __attribute__((btf_type_tag("rcu"))) *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct ip6_sf_socklist;

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist __attribute__((btf_type_tag("rcu"))) *next;
	struct ip6_sf_socklist __attribute__((btf_type_tag("rcu"))) *sflist;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	struct in6_addr sl_addr[0];
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct ip6_flowlabel;

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist __attribute__((btf_type_tag("rcu"))) *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ip6_flowlabel {
	struct ip6_flowlabel __attribute__((btf_type_tag("rcu"))) *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	unsigned long linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	unsigned long lastuse;
	unsigned long expires;
	struct net *fl_net;
};

struct ipv6_opt_hdr;

struct ipv6_rt_hdr;

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct in_addr {
	__be32 s_addr;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct ip_sf_socklist;

struct ip_mc_socklist {
	struct ip_mc_socklist __attribute__((btf_type_tag("rcu"))) *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist __attribute__((btf_type_tag("rcu"))) *sflist;
	struct callback_head rcu;
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_inet_sk_error_report {
	struct trace_entry ent;
	int error;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_sk_data_ready {
	struct trace_entry ent;
	const void *skaddr;
	__u16 family;
	__u16 protocol;
	unsigned long ip;
	char __data[0];
};

struct trace_event_raw_sock_msg_length {
	struct trace_entry ent;
	void *sk;
	__u16 family;
	__u16 protocol;
	int ret;
	int flags;
	char __data[0];
};

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 lport;
	char __data[0];
};

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu __attribute__((btf_type_tag("rcu"))) *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context __attribute__((btf_type_tag("rcu"))) *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct inet_bind_bucket;

struct inet_bind2_bucket;

struct inet_connection_sock_af_ops;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	struct inet_bind2_bucket *icsk_bind2_hash;
	unsigned long icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void __attribute__((btf_type_tag("rcu"))) *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato: 8;
		__u32 lrcv_flowlabel: 20;
		__u32 unused: 4;
		unsigned long timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int search_high;
		int search_low;
		u32 probe_size: 31;
		u32 enabled: 1;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	u64 icsk_ca_priv[13];
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	u16 tcp_header_len;
	u16 gso_segs;
	__be32 pred_flags;
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_nxt;
	u32 copied_seq;
	u32 rcv_wup;
	u32 snd_nxt;
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u64 bytes_acked;
	u32 dsack_dups;
	u32 snd_una;
	u32 snd_sml;
	u32 rcv_tstamp;
	u32 lsndtime;
	u32 last_oow_ack_time;
	u32 compressed_ack_rcv_nxt;
	u32 tsoffset;
	struct list_head tsq_node;
	struct list_head tsorted_sent_queue;
	u32 snd_wl1;
	u32 snd_wnd;
	u32 max_window;
	u32 mss_cache;
	u32 window_clamp;
	u32 rcv_ssthresh;
	u8 scaling_ratio;
	struct tcp_rack rack;
	u16 advmss;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 tcp_usec_ts: 1;
	u8 unused: 4;
	u32 chrono_start;
	u32 chrono_stat[3];
	u8 chrono_type: 2;
	u8 rate_app_limited: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 is_sack_reneg: 1;
	u8 fastopen_client_fail: 2;
	u8 nonagle: 4;
	u8 thin_lto: 1;
	u8 recvmsg_inq: 1;
	u8 repair: 1;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 is_cwnd_limited: 1;
	u32 tlp_high_seq;
	u32 tcp_tx_delay;
	u64 tcp_wstamp_ns;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 srtt_us;
	u32 mdev_us;
	u32 mdev_max_us;
	u32 rttvar_us;
	u32 rtt_seq;
	struct minmax rtt_min;
	u32 packets_out;
	u32 retrans_out;
	u32 max_packets_out;
	u32 cwnd_usage_seq;
	u16 urg_data;
	u8 ecn_flags;
	u8 keepalive_probes;
	u32 reordering;
	u32 reord_seen;
	u32 snd_up;
	struct tcp_options_received rx_opt;
	u32 snd_ssthresh;
	u32 snd_cwnd;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 prr_out;
	u32 delivered;
	u32 delivered_ce;
	u32 lost;
	u32 app_limited;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_wnd;
	u32 write_seq;
	u32 notsent_lowat;
	u32 pushed_seq;
	u32 lost_out;
	u32 sacked_out;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	struct rb_root out_of_order_queue;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	struct sk_buff *highest_sack;
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 rto_stamp;
	u16 total_rto;
	u16 total_rto_recoveries;
	u32 total_rto_time;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u8 bpf_chg_cc_inprogress: 1;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	u32 rcv_rtt_last_tsecr;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 plb_rehash;
	u32 mtu_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock __attribute__((btf_type_tag("rcu"))) *fastopen_rsk;
	struct saved_syn *saved_syn;
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	unsigned short port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	unsigned short fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head owners;
};

struct inet_bind2_bucket {
	possible_net_t ib_net;
	int l3mdev;
	unsigned short port;
	unsigned short family;
	union {
		struct in6_addr v6_rcv_saddr;
		__be32 rcv_saddr;
	};
	struct hlist_node node;
	struct hlist_head owners;
	struct hlist_head deathrow;
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char __attribute__((btf_type_tag("user"))) *, int __attribute__((btf_type_tag("user"))) *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(const struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	char __data[0];
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
		};
		struct {
			__be32 saddr;
			__be32 daddr;
		} addrs;
	};
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	union {
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		};
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		} addrs;
	};
};

struct trace_event_raw_tcp_event_skb {
	struct trace_entry ent;
	const void *skbaddr;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_tcp_cong_state_set {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u8 cong_state;
	char __data[0];
};

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	char name[16];
	char __data[0];
};

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	unsigned long txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_enqueue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_raw_br_fdb_add {
	struct trace_entry ent;
	u8 ndm_flags;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	u16 nlh_flags;
	char __data[0];
};

struct trace_event_raw_br_fdb_external_learn_add {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_fdb_delete {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_br_fdb_update {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	unsigned long flags;
	char __data[0];
};

struct trace_event_raw_br_mdb_full {
	struct trace_entry ent;
	u32 __data_loc_dev;
	int af;
	u16 vid;
	__u8 src[16];
	__u8 grp[16];
	__u8 grpmac[6];
	char __data[0];
};

struct trace_event_raw_page_pool_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	u64 cnt;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 release;
	unsigned long pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 hold;
	unsigned long pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_update_nid {
	struct trace_entry ent;
	const struct page_pool *pool;
	int pool_nid;
	int new_nid;
	char __data[0];
};

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	unsigned long confirmed;
	unsigned long updated;
	unsigned long used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	unsigned long confirmed;
	unsigned long updated;
	unsigned long used;
	u32 err;
	char __data[0];
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	u32 driver;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_br_fdb_add {
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_external_learn_add {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_fdb_delete {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_update {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_br_mdb_full {
	u32 dev;
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_inet_sock_set_state {};

struct trace_event_data_offsets_inet_sk_error_report {};

struct trace_event_data_offsets_sk_data_ready {};

struct trace_event_data_offsets_sock_msg_length {};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct sockaddr_in6 {
	unsigned short sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct trace_event_data_offsets_tcp_probe {};

struct trace_event_data_offsets_tcp_event_skb {};

struct trace_event_data_offsets_tcp_cong_state_set {};

struct trace_event_data_offsets_fib_table_lookup {};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_enqueue {};

struct trace_event_data_offsets_page_pool_release {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

struct trace_event_data_offsets_page_pool_update_nid {};

struct ethnl_req_info;

struct ethnl_reply_data;

struct genl_info;

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	u8 set_ntf_cmd;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, const struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
	int (*set_validate)(struct ethnl_req_info *, struct genl_info *);
	int (*set)(struct ethnl_req_info *, struct genl_info *);
};

struct ethnl_req_info {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 flags;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct genl_family;

struct genlmsghdr;

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	const struct genl_family *family;
	const struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	void *user_ptr[2];
	struct netlink_ext_ack *extack;
};

struct genl_split_ops;

struct genl_ops;

struct genl_small_ops;

struct genl_multicast_group;

struct genl_family {
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_split_ops;
	u8 n_mcgrps;
	u8 resv_start_op;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_split_ops *split_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
	int id;
	unsigned int mcgrp_offset;
};

struct genl_split_ops {
	union {
		struct {
			int (*pre_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
			int (*doit)(struct sk_buff *, struct genl_info *);
			void (*post_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
		};
		struct {
			int (*start)(struct netlink_callback *);
			int (*dumpit)(struct sk_buff *, struct netlink_callback *);
			int (*done)(struct netlink_callback *);
		};
	};
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_multicast_group {
	char name[16];
	u8 flags;
	u8 cap_sys_admin: 1;
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

enum {
	ETHTOOL_A_MODULE_EEPROM_UNSPEC = 0,
	ETHTOOL_A_MODULE_EEPROM_HEADER = 1,
	ETHTOOL_A_MODULE_EEPROM_OFFSET = 2,
	ETHTOOL_A_MODULE_EEPROM_LENGTH = 3,
	ETHTOOL_A_MODULE_EEPROM_PAGE = 4,
	ETHTOOL_A_MODULE_EEPROM_BANK = 5,
	ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS = 6,
	ETHTOOL_A_MODULE_EEPROM_DATA = 7,
	__ETHTOOL_A_MODULE_EEPROM_CNT = 8,
	ETHTOOL_A_MODULE_EEPROM_MAX = 7,
};

struct eeprom_req_info {
	struct ethnl_req_info base;
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
};

struct eeprom_reply_data {
	struct ethnl_reply_data base;
	u32 length;
	u8 *data;
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_MAX_STATES = 13,
};

enum {
	INET_FLAGS_PKTINFO = 0,
	INET_FLAGS_TTL = 1,
	INET_FLAGS_TOS = 2,
	INET_FLAGS_RECVOPTS = 3,
	INET_FLAGS_RETOPTS = 4,
	INET_FLAGS_PASSSEC = 5,
	INET_FLAGS_ORIGDSTADDR = 6,
	INET_FLAGS_CHECKSUM = 7,
	INET_FLAGS_RECVFRAGSIZE = 8,
	INET_FLAGS_RECVERR = 9,
	INET_FLAGS_RECVERR_RFC4884 = 10,
	INET_FLAGS_FREEBIND = 11,
	INET_FLAGS_HDRINCL = 12,
	INET_FLAGS_MC_LOOP = 13,
	INET_FLAGS_MC_ALL = 14,
	INET_FLAGS_TRANSPARENT = 15,
	INET_FLAGS_IS_ICSK = 16,
	INET_FLAGS_NODEFRAG = 17,
	INET_FLAGS_BIND_ADDRESS_NO_PORT = 18,
	INET_FLAGS_DEFER_CONNECT = 19,
	INET_FLAGS_MC6_LOOP = 20,
	INET_FLAGS_RECVERR6_RFC4884 = 21,
	INET_FLAGS_MC6_ALL = 22,
	INET_FLAGS_AUTOFLOWLABEL_SET = 23,
	INET_FLAGS_AUTOFLOWLABEL = 24,
	INET_FLAGS_DONTFRAG = 25,
	INET_FLAGS_RECVERR6 = 26,
	INET_FLAGS_REPFLOW = 27,
	INET_FLAGS_RTALERT_ISOLATE = 28,
	INET_FLAGS_SNDFLOW = 29,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_DELAYEDACKS = 16,
	LINUX_MIB_DELAYEDACKLOCKED = 17,
	LINUX_MIB_DELAYEDACKLOST = 18,
	LINUX_MIB_LISTENOVERFLOWS = 19,
	LINUX_MIB_LISTENDROPS = 20,
	LINUX_MIB_TCPHPHITS = 21,
	LINUX_MIB_TCPPUREACKS = 22,
	LINUX_MIB_TCPHPACKS = 23,
	LINUX_MIB_TCPRENORECOVERY = 24,
	LINUX_MIB_TCPSACKRECOVERY = 25,
	LINUX_MIB_TCPSACKRENEGING = 26,
	LINUX_MIB_TCPSACKREORDER = 27,
	LINUX_MIB_TCPRENOREORDER = 28,
	LINUX_MIB_TCPTSREORDER = 29,
	LINUX_MIB_TCPFULLUNDO = 30,
	LINUX_MIB_TCPPARTIALUNDO = 31,
	LINUX_MIB_TCPDSACKUNDO = 32,
	LINUX_MIB_TCPLOSSUNDO = 33,
	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
	LINUX_MIB_TCPRENOFAILURES = 35,
	LINUX_MIB_TCPSACKFAILURES = 36,
	LINUX_MIB_TCPLOSSFAILURES = 37,
	LINUX_MIB_TCPFASTRETRANS = 38,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
	LINUX_MIB_TCPTIMEOUTS = 40,
	LINUX_MIB_TCPLOSSPROBES = 41,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
	LINUX_MIB_TCPRCVCOLLAPSED = 45,
	LINUX_MIB_TCPDSACKOLDSENT = 46,
	LINUX_MIB_TCPDSACKOFOSENT = 47,
	LINUX_MIB_TCPDSACKRECV = 48,
	LINUX_MIB_TCPDSACKOFORECV = 49,
	LINUX_MIB_TCPABORTONDATA = 50,
	LINUX_MIB_TCPABORTONCLOSE = 51,
	LINUX_MIB_TCPABORTONMEMORY = 52,
	LINUX_MIB_TCPABORTONTIMEOUT = 53,
	LINUX_MIB_TCPABORTONLINGER = 54,
	LINUX_MIB_TCPABORTFAILED = 55,
	LINUX_MIB_TCPMEMORYPRESSURES = 56,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
	LINUX_MIB_TCPSACKDISCARD = 58,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
	LINUX_MIB_TCPSPURIOUSRTOS = 61,
	LINUX_MIB_TCPMD5NOTFOUND = 62,
	LINUX_MIB_TCPMD5UNEXPECTED = 63,
	LINUX_MIB_TCPMD5FAILURE = 64,
	LINUX_MIB_SACKSHIFTED = 65,
	LINUX_MIB_SACKMERGED = 66,
	LINUX_MIB_SACKSHIFTFALLBACK = 67,
	LINUX_MIB_TCPBACKLOGDROP = 68,
	LINUX_MIB_PFMEMALLOCDROP = 69,
	LINUX_MIB_TCPMINTTLDROP = 70,
	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
	LINUX_MIB_IPRPFILTER = 72,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
	LINUX_MIB_TCPREQQFULLDROP = 75,
	LINUX_MIB_TCPRETRANSFAIL = 76,
	LINUX_MIB_TCPRCVCOALESCE = 77,
	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
	LINUX_MIB_TCPOFOQUEUE = 79,
	LINUX_MIB_TCPOFODROP = 80,
	LINUX_MIB_TCPOFOMERGE = 81,
	LINUX_MIB_TCPCHALLENGEACK = 82,
	LINUX_MIB_TCPSYNCHALLENGE = 83,
	LINUX_MIB_TCPFASTOPENACTIVE = 84,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
	LINUX_MIB_TCPAUTOCORKING = 93,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
	LINUX_MIB_TCPSYNRETRANS = 97,
	LINUX_MIB_TCPORIGDATASENT = 98,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
	LINUX_MIB_TCPWINPROBE = 109,
	LINUX_MIB_TCPKEEPALIVE = 110,
	LINUX_MIB_TCPMTUPFAIL = 111,
	LINUX_MIB_TCPMTUPSUCCESS = 112,
	LINUX_MIB_TCPDELIVERED = 113,
	LINUX_MIB_TCPDELIVEREDCE = 114,
	LINUX_MIB_TCPACKCOMPRESSED = 115,
	LINUX_MIB_TCPZEROWINDOWDROP = 116,
	LINUX_MIB_TCPRCVQDROP = 117,
	LINUX_MIB_TCPWQUEUETOOBIG = 118,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
	LINUX_MIB_TCPTIMEOUTREHASH = 120,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 121,
	LINUX_MIB_TCPDSACKRECVSEGS = 122,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,
	LINUX_MIB_TCPMIGRATEREQSUCCESS = 124,
	LINUX_MIB_TCPMIGRATEREQFAILURE = 125,
	LINUX_MIB_TCPPLBREHASH = 126,
	LINUX_MIB_TCPAOREQUIRED = 127,
	LINUX_MIB_TCPAOBAD = 128,
	LINUX_MIB_TCPAOKEYNOTFOUND = 129,
	LINUX_MIB_TCPAOGOOD = 130,
	LINUX_MIB_TCPAODROPPEDICMPS = 131,
	__LINUX_MIB_MAX = 132,
};

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	volatile unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_usec_ts: 1;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
	struct inet_bind2_bucket *tw_tb2;
	struct hlist_node tw_bind2_node;
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info __attribute__((btf_type_tag("rcu"))) *nh_info;
		struct nh_group __attribute__((btf_type_tag("rcu"))) *nh_grp;
	};
};

struct fib_info;

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	refcount_t fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	bool pfsrc_removed;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct nh_grp_entry {
	struct nexthop *nh;
	u8 weight;
	union {
		struct {
			atomic_t upper_bound;
		} hthr;
		struct {
			struct list_head uw_nh_entry;
			u16 count_buckets;
			u16 wants_buckets;
		} res;
	};
	struct list_head nh_list;
	struct nexthop *nh_parent;
};

struct nh_res_table;

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool is_multipath;
	bool hash_threshold;
	bool resilient;
	bool fdb_nh;
	bool has_v4;
	struct nh_res_table __attribute__((btf_type_tag("rcu"))) *res_table;
	struct nh_grp_entry nh_entries[0];
};

struct nh_res_bucket {
	struct nh_grp_entry __attribute__((btf_type_tag("rcu"))) *nh_entry;
	atomic_long_t used_time;
	unsigned long migrated_time;
	bool occupied;
	u8 nh_flags;
};

struct nh_res_table {
	struct net *net;
	u32 nhg_id;
	struct delayed_work upkeep_dw;
	struct list_head uw_nh_entries;
	unsigned long unbalanced_since;
	u32 idle_timer;
	u32 unbalanced_timer;
	u16 num_nh_buckets;
	struct nh_res_bucket nh_buckets[0];
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	unsigned long sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct udp_tunnel_info {
	unsigned short type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

struct udp_hslot;

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot *hash2;
	unsigned int mask;
	unsigned int log;
};

struct udp_hslot {
	struct hlist_head head;
	int count;
	spinlock_t lock;
};

struct static_key_true {
	struct static_key key;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

union bpf_iter_link_info;

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

struct bpf_link_info;

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	BPF_FUNC_sock_from_file = 162,
	BPF_FUNC_check_mtu = 163,
	BPF_FUNC_for_each_map_elem = 164,
	BPF_FUNC_snprintf = 165,
	BPF_FUNC_sys_bpf = 166,
	BPF_FUNC_btf_find_by_name_kind = 167,
	BPF_FUNC_sys_close = 168,
	BPF_FUNC_timer_init = 169,
	BPF_FUNC_timer_set_callback = 170,
	BPF_FUNC_timer_start = 171,
	BPF_FUNC_timer_cancel = 172,
	BPF_FUNC_get_func_ip = 173,
	BPF_FUNC_get_attach_cookie = 174,
	BPF_FUNC_task_pt_regs = 175,
	BPF_FUNC_get_branch_snapshot = 176,
	BPF_FUNC_trace_vprintk = 177,
	BPF_FUNC_skc_to_unix_sock = 178,
	BPF_FUNC_kallsyms_lookup_name = 179,
	BPF_FUNC_find_vma = 180,
	BPF_FUNC_loop = 181,
	BPF_FUNC_strncmp = 182,
	BPF_FUNC_get_func_arg = 183,
	BPF_FUNC_get_func_ret = 184,
	BPF_FUNC_get_func_arg_cnt = 185,
	BPF_FUNC_get_retval = 186,
	BPF_FUNC_set_retval = 187,
	BPF_FUNC_xdp_get_buff_len = 188,
	BPF_FUNC_xdp_load_bytes = 189,
	BPF_FUNC_xdp_store_bytes = 190,
	BPF_FUNC_copy_from_user_task = 191,
	BPF_FUNC_skb_set_tstamp = 192,
	BPF_FUNC_ima_file_hash = 193,
	BPF_FUNC_kptr_xchg = 194,
	BPF_FUNC_map_lookup_percpu_elem = 195,
	BPF_FUNC_skc_to_mptcp_sock = 196,
	BPF_FUNC_dynptr_from_mem = 197,
	BPF_FUNC_ringbuf_reserve_dynptr = 198,
	BPF_FUNC_ringbuf_submit_dynptr = 199,
	BPF_FUNC_ringbuf_discard_dynptr = 200,
	BPF_FUNC_dynptr_read = 201,
	BPF_FUNC_dynptr_write = 202,
	BPF_FUNC_dynptr_data = 203,
	BPF_FUNC_tcp_raw_gen_syncookie_ipv4 = 204,
	BPF_FUNC_tcp_raw_gen_syncookie_ipv6 = 205,
	BPF_FUNC_tcp_raw_check_syncookie_ipv4 = 206,
	BPF_FUNC_tcp_raw_check_syncookie_ipv6 = 207,
	BPF_FUNC_ktime_get_tai_ns = 208,
	BPF_FUNC_user_ringbuf_drain = 209,
	BPF_FUNC_cgrp_storage_get = 210,
	BPF_FUNC_cgrp_storage_delete = 211,
	__BPF_FUNC_MAX_ID = 212,
};

struct bpf_func_proto;

typedef const struct bpf_func_proto * (*bpf_iter_get_func_proto_t)(enum bpf_func_id, const struct bpf_prog *);

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	bpf_iter_get_func_proto_t get_func_proto;
	u32 ctx_arg_info_size;
	u32 feature;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
	struct {
		enum bpf_cgroup_iter_order order;
		__u32 cgroup_fd;
		__u64 cgroup_id;
	} cgroup;
	struct {
		__u32 tid;
		__u32 pid;
		__u32 pid_fd;
	} task;
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
			__u32 target_obj_id;
			__u32 target_btf_id;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
			union {
				struct {
					__u64 cgroup_id;
					__u32 order;
				} cgroup;
				struct {
					__u32 tid;
					__u32 pid;
				} task;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
		struct {
			__u32 map_id;
		} struct_ops;
		struct {
			__u32 pf;
			__u32 hooknum;
			__s32 priority;
			__u32 flags;
		} netfilter;
		struct {
			__u64 addrs;
			__u32 count;
			__u32 flags;
			__u64 missed;
		} kprobe_multi;
		struct {
			__u32 type;
			union {
				struct {
					__u64 file_name;
					__u32 name_len;
					__u32 offset;
				} uprobe;
				struct {
					__u64 func_name;
					__u32 name_len;
					__u32 offset;
					__u64 addr;
					__u64 missed;
				} kprobe;
				struct {
					__u64 tp_name;
					__u32 name_len;
				} tracepoint;
				struct {
					__u64 config;
					__u32 type;
				} event;
			};
		} perf_event;
		struct {
			__u32 ifindex;
			__u32 attach_type;
		} tcx;
		struct {
			__u32 ifindex;
			__u32 attach_type;
		} netkit;
	};
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_SOCKET = 3,
	RET_PTR_TO_TCP_SOCK = 4,
	RET_PTR_TO_SOCK_COMMON = 5,
	RET_PTR_TO_MEM = 6,
	RET_PTR_TO_MEM_OR_BTF_ID = 7,
	RET_PTR_TO_BTF_ID = 8,
	__BPF_RET_TYPE_MAX = 9,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 258,
	RET_PTR_TO_SOCKET_OR_NULL = 259,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 260,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 261,
	RET_PTR_TO_RINGBUF_MEM_OR_NULL = 1286,
	RET_PTR_TO_DYNPTR_MEM_OR_NULL = 262,
	RET_PTR_TO_BTF_ID_OR_NULL = 264,
	RET_PTR_TO_BTF_ID_TRUSTED = 1048584,
	__BPF_RET_TYPE_LIMIT = 33554431,
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_MEM = 4,
	ARG_CONST_SIZE = 5,
	ARG_CONST_SIZE_OR_ZERO = 6,
	ARG_PTR_TO_CTX = 7,
	ARG_ANYTHING = 8,
	ARG_PTR_TO_SPIN_LOCK = 9,
	ARG_PTR_TO_SOCK_COMMON = 10,
	ARG_PTR_TO_INT = 11,
	ARG_PTR_TO_LONG = 12,
	ARG_PTR_TO_SOCKET = 13,
	ARG_PTR_TO_BTF_ID = 14,
	ARG_PTR_TO_RINGBUF_MEM = 15,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 16,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 17,
	ARG_PTR_TO_PERCPU_BTF_ID = 18,
	ARG_PTR_TO_FUNC = 19,
	ARG_PTR_TO_STACK = 20,
	ARG_PTR_TO_CONST_STR = 21,
	ARG_PTR_TO_TIMER = 22,
	ARG_PTR_TO_KPTR = 23,
	ARG_PTR_TO_DYNPTR = 24,
	__BPF_ARG_TYPE_MAX = 25,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 259,
	ARG_PTR_TO_MEM_OR_NULL = 260,
	ARG_PTR_TO_CTX_OR_NULL = 263,
	ARG_PTR_TO_SOCKET_OR_NULL = 269,
	ARG_PTR_TO_STACK_OR_NULL = 276,
	ARG_PTR_TO_BTF_ID_OR_NULL = 270,
	ARG_PTR_TO_UNINIT_MEM = 32772,
	ARG_PTR_TO_FIXED_SIZE_MEM = 262148,
	__BPF_ARG_TYPE_LIMIT = 33554431,
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	bool might_sleep;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
		struct {
			size_t arg1_size;
			size_t arg2_size;
			size_t arg3_size;
			size_t arg4_size;
			size_t arg5_size;
		};
		size_t arg_size[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
	SOCK_RCVMARK = 27,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	ICMP_MIB_RATELIMITGLOBAL = 28,
	ICMP_MIB_RATELIMITHOST = 29,
	__ICMP_MIB_MAX = 30,
};

enum {
	UDP_FLAGS_CORK = 0,
	UDP_FLAGS_NO_CHECK6_TX = 1,
	UDP_FLAGS_NO_CHECK6_RX = 2,
	UDP_FLAGS_GRO_ENABLED = 3,
	UDP_FLAGS_ACCEPT_FRAGLIST = 4,
	UDP_FLAGS_ACCEPT_L4 = 5,
	UDP_FLAGS_ENCAP_ENABLED = 6,
	UDP_FLAGS_UDPLITE_SEND_CC = 7,
	UDP_FLAGS_UDPLITE_RECV_CC = 8,
};

enum cgroup_bpf_attach_type {
	CGROUP_BPF_ATTACH_TYPE_INVALID = -1,
	CGROUP_INET_INGRESS = 0,
	CGROUP_INET_EGRESS = 1,
	CGROUP_INET_SOCK_CREATE = 2,
	CGROUP_SOCK_OPS = 3,
	CGROUP_DEVICE = 4,
	CGROUP_INET4_BIND = 5,
	CGROUP_INET6_BIND = 6,
	CGROUP_INET4_CONNECT = 7,
	CGROUP_INET6_CONNECT = 8,
	CGROUP_UNIX_CONNECT = 9,
	CGROUP_INET4_POST_BIND = 10,
	CGROUP_INET6_POST_BIND = 11,
	CGROUP_UDP4_SENDMSG = 12,
	CGROUP_UDP6_SENDMSG = 13,
	CGROUP_UNIX_SENDMSG = 14,
	CGROUP_SYSCTL = 15,
	CGROUP_UDP4_RECVMSG = 16,
	CGROUP_UDP6_RECVMSG = 17,
	CGROUP_UNIX_RECVMSG = 18,
	CGROUP_GETSOCKOPT = 19,
	CGROUP_SETSOCKOPT = 20,
	CGROUP_INET4_GETPEERNAME = 21,
	CGROUP_INET6_GETPEERNAME = 22,
	CGROUP_UNIX_GETPEERNAME = 23,
	CGROUP_INET4_GETSOCKNAME = 24,
	CGROUP_INET6_GETSOCKNAME = 25,
	CGROUP_UNIX_GETSOCKNAME = 26,
	CGROUP_INET_SOCK_RELEASE = 27,
	CGROUP_LSM_START = 28,
	CGROUP_LSM_END = 37,
	MAX_CGROUP_BPF_ATTACH_TYPE = 38,
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTREQUESTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	IPSTATS_MIB_OUTPKTS = 37,
	__IPSTATS_MIB_MAX = 38,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

enum xfrm_replay_mode {
	XFRM_REPLAY_MODE_LEGACY = 0,
	XFRM_REPLAY_MODE_BMP = 1,
	XFRM_REPLAY_MODE_ESN = 2,
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	BTF_SOCK_TYPE_UNIX = 13,
	BTF_SOCK_TYPE_MPTCP = 14,
	BTF_SOCK_TYPE_SOCKET = 15,
	MAX_BTF_SOCK_TYPE = 16,
};

struct udp_sock {
	struct inet_sock inet;
	unsigned long udp_flags;
	int pending;
	__u8 encap_type;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	void (*encap_err_rcv)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head reader_queue;
	int forward_deficit;
	int forward_threshold;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 frag_max_size;
	__u16 srhoff;
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct udp_dev_scratch {
	u32 _tsize_state;
	u16 len;
	bool is_linear;
	bool csum_unnecessary;
};

struct sock_skb_cb {
	u32 dropcount;
};

struct seq_net_private {
	struct net *net;
	netns_tracker ns_tracker;
};

typedef u32 inet_ehashfn_t(const struct net *, const __be32, const __u16, const __be32, const __be16);

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u32 tsflags;
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 protocol;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
};

struct nf_conntrack {
	refcount_t use;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	long: 0;
	int bucket;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct bpf_udp_iter_state {
	struct udp_iter_state state;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	int offset;
	struct sock **batch;
	bool st_bucket_done;
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

struct ic_device {
	struct ic_device *next;
	struct net_device *dev;
	unsigned short flags;
	short able;
	__be32 xid;
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	struct net *af_packet_net;
	void *af_packet_priv;
	struct list_head list;
};

struct bootp_pkt {
	struct iphdr iph;
	struct udphdr udph;
	u8 op;
	u8 htype;
	u8 hlen;
	u8 hops;
	__be32 xid;
	__be16 secs;
	__be16 flags;
	__be32 client_ip;
	__be32 your_ip;
	__be32 server_ip;
	__be32 relay_ip;
	u8 hw_addr[16];
	u8 serv_name[64];
	u8 boot_file[128];
	u8 exten[312];
};

struct rtentry {
	unsigned long rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	unsigned short rt_flags;
	short rt_pad2;
	unsigned long rt_pad3;
	void *rt_pad4;
	short rt_metric;
	char __attribute__((btf_type_tag("user"))) *rt_dev;
	unsigned long rt_mtu;
	unsigned long rt_window;
	unsigned short rt_irtt;
};

struct devlink_dev_stats {
	u32 reload_stats[6];
	u32 remote_reload_stats[6];
};

struct devlink_dpipe_headers;

struct devlink_ops;

struct devlink_rel;

struct devlink {
	u32 index;
	struct xarray ports;
	struct list_head rate_list;
	struct list_head sb_list;
	struct list_head dpipe_table_list;
	struct list_head resource_list;
	struct xarray params;
	struct list_head region_list;
	struct list_head reporter_list;
	struct devlink_dpipe_headers *dpipe_headers;
	struct list_head trap_list;
	struct list_head trap_group_list;
	struct list_head trap_policer_list;
	struct list_head linecard_list;
	const struct devlink_ops *ops;
	struct xarray snapshot_ids;
	struct devlink_dev_stats stats;
	struct device *dev;
	possible_net_t _net;
	struct mutex lock;
	struct lock_class_key lock_key;
	u8 reload_failed: 1;
	refcount_t refcount;
	struct rcu_work rwork;
	struct devlink_rel *rel;
	struct xarray nested_rels;
	char priv[0];
};

struct devlink_dpipe_header;

struct devlink_dpipe_headers {
	struct devlink_dpipe_header **headers;
	unsigned int headers_count;
};

struct devlink_dpipe_field;

struct devlink_dpipe_header {
	const char *name;
	unsigned int id;
	struct devlink_dpipe_field *fields;
	unsigned int fields_count;
	bool global;
};

enum devlink_dpipe_field_mapping_type {
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
};

struct devlink_dpipe_field {
	const char *name;
	unsigned int id;
	unsigned int bitwidth;
	enum devlink_dpipe_field_mapping_type mapping_type;
};

enum devlink_reload_action {
	DEVLINK_RELOAD_ACTION_UNSPEC = 0,
	DEVLINK_RELOAD_ACTION_DRIVER_REINIT = 1,
	DEVLINK_RELOAD_ACTION_FW_ACTIVATE = 2,
	__DEVLINK_RELOAD_ACTION_MAX = 3,
	DEVLINK_RELOAD_ACTION_MAX = 2,
};

enum devlink_reload_limit {
	DEVLINK_RELOAD_LIMIT_UNSPEC = 0,
	DEVLINK_RELOAD_LIMIT_NO_RESET = 1,
	__DEVLINK_RELOAD_LIMIT_MAX = 2,
	DEVLINK_RELOAD_LIMIT_MAX = 1,
};

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
};

enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP = 0,
	DEVLINK_TRAP_ACTION_TRAP = 1,
	DEVLINK_TRAP_ACTION_MIRROR = 2,
};

enum devlink_selftest_status {
	DEVLINK_SELFTEST_STATUS_SKIP = 0,
	DEVLINK_SELFTEST_STATUS_PASS = 1,
	DEVLINK_SELFTEST_STATUS_FAIL = 2,
};

struct devlink_sb_pool_info;

struct devlink_info_req;

struct devlink_flash_update_params;

struct devlink_trap;

struct devlink_trap_group;

struct devlink_trap_policer;

struct devlink_port_new_attrs;

struct devlink_ops {
	u32 supported_flash_update_params;
	unsigned long reload_actions;
	unsigned long reload_limits;
	int (*reload_down)(struct devlink *, bool, enum devlink_reload_action, enum devlink_reload_limit, struct netlink_ext_ack *);
	int (*reload_up)(struct devlink *, enum devlink_reload_action, enum devlink_reload_limit, u32 *, struct netlink_ext_ack *);
	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*eswitch_mode_get)(struct devlink *, u16 *);
	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*flash_update)(struct devlink *, struct devlink_flash_update_params *, struct netlink_ext_ack *);
	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
	int (*trap_group_set)(struct devlink *, const struct devlink_trap_group *, const struct devlink_trap_policer *, struct netlink_ext_ack *);
	int (*trap_group_action_set)(struct devlink *, const struct devlink_trap_group *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_drop_counter_get)(struct devlink *, const struct devlink_trap *, u64 *);
	int (*trap_policer_init)(struct devlink *, const struct devlink_trap_policer *);
	void (*trap_policer_fini)(struct devlink *, const struct devlink_trap_policer *);
	int (*trap_policer_set)(struct devlink *, const struct devlink_trap_policer *, u64, u64, struct netlink_ext_ack *);
	int (*trap_policer_counter_get)(struct devlink *, const struct devlink_trap_policer *, u64 *);
	int (*port_new)(struct devlink *, const struct devlink_port_new_attrs *, struct netlink_ext_ack *, struct devlink_port **);
	int (*rate_leaf_tx_share_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_leaf_tx_max_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_leaf_tx_priority_set)(struct devlink_rate *, void *, u32, struct netlink_ext_ack *);
	int (*rate_leaf_tx_weight_set)(struct devlink_rate *, void *, u32, struct netlink_ext_ack *);
	int (*rate_node_tx_share_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_node_tx_max_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_node_tx_priority_set)(struct devlink_rate *, void *, u32, struct netlink_ext_ack *);
	int (*rate_node_tx_weight_set)(struct devlink_rate *, void *, u32, struct netlink_ext_ack *);
	int (*rate_node_new)(struct devlink_rate *, void **, struct netlink_ext_ack *);
	int (*rate_node_del)(struct devlink_rate *, void *, struct netlink_ext_ack *);
	int (*rate_leaf_parent_set)(struct devlink_rate *, struct devlink_rate *, void *, void *, struct netlink_ext_ack *);
	int (*rate_node_parent_set)(struct devlink_rate *, struct devlink_rate *, void *, void *, struct netlink_ext_ack *);
	bool (*selftest_check)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	enum devlink_selftest_status (*selftest_run)(struct devlink *, unsigned int, struct netlink_ext_ack *);
};

struct devlink_sb_pool_info {
	enum devlink_sb_pool_type pool_type;
	u32 size;
	enum devlink_sb_threshold_type threshold_type;
	u32 cell_size;
};

struct devlink_flash_update_params {
	const struct firmware *fw;
	const char *component;
	u32 overwrite_mask;
};

enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP = 0,
	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
	DEVLINK_TRAP_TYPE_CONTROL = 2,
};

struct devlink_trap {
	enum devlink_trap_type type;
	enum devlink_trap_action init_action;
	bool generic;
	u16 id;
	const char *name;
	u16 init_group_id;
	u32 metadata_cap;
};

struct devlink_trap_group {
	const char *name;
	u16 id;
	bool generic;
	u32 init_policer_id;
};

struct devlink_trap_policer {
	u32 id;
	u64 init_rate;
	u64 init_burst;
	u64 max_rate;
	u64 min_rate;
	u64 max_burst;
	u64 min_burst;
};

struct devlink_port_new_attrs {
	enum devlink_port_flavour flavour;
	unsigned int port_index;
	u32 controller;
	u32 sfnum;
	u16 pfnum;
	u8 port_index_valid: 1;
	u8 controller_valid: 1;
	u8 sfnum_valid: 1;
};

struct ib_core_device {
	struct device dev;
	possible_net_t rdma_net;
	struct kobject *ports_kobj;
	struct list_head port_list;
	struct ib_device *owner;
};

enum rdma_driver_id {
	RDMA_DRIVER_UNKNOWN = 0,
	RDMA_DRIVER_MLX5 = 1,
	RDMA_DRIVER_MLX4 = 2,
	RDMA_DRIVER_CXGB3 = 3,
	RDMA_DRIVER_CXGB4 = 4,
	RDMA_DRIVER_MTHCA = 5,
	RDMA_DRIVER_BNXT_RE = 6,
	RDMA_DRIVER_OCRDMA = 7,
	RDMA_DRIVER_NES = 8,
	RDMA_DRIVER_I40IW = 9,
	RDMA_DRIVER_IRDMA = 9,
	RDMA_DRIVER_VMW_PVRDMA = 10,
	RDMA_DRIVER_QEDR = 11,
	RDMA_DRIVER_HNS = 12,
	RDMA_DRIVER_USNIC = 13,
	RDMA_DRIVER_RXE = 14,
	RDMA_DRIVER_HFI1 = 15,
	RDMA_DRIVER_QIB = 16,
	RDMA_DRIVER_EFA = 17,
	RDMA_DRIVER_SIW = 18,
	RDMA_DRIVER_ERDMA = 19,
	RDMA_DRIVER_MANA = 20,
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED = 1,
	IB_CQ_NEXT_COMP = 2,
	IB_CQ_SOLICITED_MASK = 3,
	IB_CQ_REPORT_MISSED_EVENTS = 4,
};

struct ib_mad;

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED = 0,
	IB_LINK_LAYER_INFINIBAND = 1,
	IB_LINK_LAYER_ETHERNET = 2,
};

enum rdma_netdev_t {
	RDMA_NETDEV_OPA_VNIC = 0,
	RDMA_NETDEV_IPOIB = 1,
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR = 1,
	IB_SRQ_LIMIT = 2,
};

enum ib_mr_type {
	IB_MR_TYPE_MEM_REG = 0,
	IB_MR_TYPE_SG_GAPS = 1,
	IB_MR_TYPE_DM = 2,
	IB_MR_TYPE_USER = 3,
	IB_MR_TYPE_DMA = 4,
	IB_MR_TYPE_INTEGRITY = 5,
};

enum ib_uverbs_advise_mr_advice {
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2,
};

struct uverbs_attr_bundle;

struct rdma_cm_id;

struct iw_cm_id;

struct iw_cm_conn_param;

struct ib_qp;

struct ib_send_wr;

struct ib_recv_wr;

struct ib_cq;

struct ib_wc;

struct ib_srq;

struct ib_grh;

struct ib_device_attr;

struct ib_udata;

struct ib_device_modify;

struct ib_port_attr;

struct ib_port_modify;

struct ib_port_immutable;

struct rdma_netdev_alloc_params;

union ib_gid;

struct ib_gid_attr;

struct ib_ucontext;

struct rdma_user_mmap_entry;

struct ib_pd;

struct ib_ah;

struct rdma_ah_init_attr;

struct rdma_ah_attr;

struct ib_srq_init_attr;

struct ib_srq_attr;

struct ib_qp_init_attr;

struct ib_qp_attr;

struct ib_cq_init_attr;

struct ib_mr;

struct ib_sge;

struct ib_mr_status;

struct ib_mw;

struct ib_xrcd;

struct ib_flow;

struct ib_flow_attr;

struct ib_flow_action;

struct ib_wq;

struct ib_wq_init_attr;

struct ib_wq_attr;

struct ib_rwq_ind_table;

struct ib_rwq_ind_table_init_attr;

struct ib_dm;

struct ib_dm_alloc_attr;

struct ib_dm_mr_attr;

struct ib_counters;

struct ib_counters_read_attr;

struct rdma_hw_stats;

struct rdma_counter;

struct ib_device_ops {
	struct module *owner;
	enum rdma_driver_id driver_id;
	u32 uverbs_abi_ver;
	unsigned int uverbs_no_driver_id_binding: 1;
	const struct attribute_group *device_group;
	const struct attribute_group **port_groups;
	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	void (*drain_rq)(struct ib_qp *);
	void (*drain_sq)(struct ib_qp *);
	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
	int (*peek_cq)(struct ib_cq *, int);
	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	int (*process_mad)(struct ib_device *, int, u32, const struct ib_wc *, const struct ib_grh *, const struct ib_mad *, struct ib_mad *, size_t *, u16 *);
	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
	void (*get_dev_fw_str)(struct ib_device *, char *);
	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
	int (*query_port)(struct ib_device *, u32, struct ib_port_attr *);
	int (*modify_port)(struct ib_device *, u32, int, struct ib_port_modify *);
	int (*get_port_immutable)(struct ib_device *, u32, struct ib_port_immutable *);
	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u32);
	struct net_device * (*get_netdev)(struct ib_device *, u32);
	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u32, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
	int (*rdma_netdev_get_params)(struct ib_device *, u32, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
	int (*query_gid)(struct ib_device *, u32, int, union ib_gid *);
	int (*add_gid)(const struct ib_gid_attr *, void **);
	int (*del_gid)(const struct ib_gid_attr *, void **);
	int (*query_pkey)(struct ib_device *, u32, u16, u16 *);
	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
	void (*dealloc_ucontext)(struct ib_ucontext *);
	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
	void (*mmap_free)(struct rdma_user_mmap_entry *);
	void (*disassociate_ucontext)(struct ib_ucontext *);
	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*create_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*create_user_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*destroy_ah)(struct ib_ah *, u32);
	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
	int (*destroy_srq)(struct ib_srq *, struct ib_udata *);
	int (*create_qp)(struct ib_qp *, struct ib_qp_init_attr *, struct ib_udata *);
	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct ib_udata *);
	int (*modify_cq)(struct ib_cq *, u16, u16);
	int (*destroy_cq)(struct ib_cq *, struct ib_udata *);
	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
	struct ib_mr * (*reg_user_mr_dmabuf)(struct ib_pd *, u64, u64, u64, int, int, struct ib_udata *);
	struct ib_mr * (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32);
	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
	int (*alloc_mw)(struct ib_mw *, struct ib_udata *);
	int (*dealloc_mw)(struct ib_mw *);
	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*alloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, struct ib_udata *);
	int (*destroy_flow)(struct ib_flow *);
	int (*destroy_flow_action)(struct ib_flow_action *);
	int (*set_vf_link_state)(struct ib_device *, int, u32, int);
	int (*get_vf_config)(struct ib_device *, int, u32, struct ifla_vf_info *);
	int (*get_vf_stats)(struct ib_device *, int, u32, struct ifla_vf_stats *);
	int (*get_vf_guid)(struct ib_device *, int, u32, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*set_vf_guid)(struct ib_device *, int, u32, u64, int);
	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
	int (*destroy_wq)(struct ib_wq *, struct ib_udata *);
	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
	int (*create_rwq_ind_table)(struct ib_rwq_ind_table *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
	int (*create_counters)(struct ib_counters *, struct uverbs_attr_bundle *);
	int (*destroy_counters)(struct ib_counters *);
	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
	struct rdma_hw_stats * (*alloc_hw_device_stats)(struct ib_device *);
	struct rdma_hw_stats * (*alloc_hw_port_stats)(struct ib_device *, u32);
	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u32, int);
	int (*modify_hw_stat)(struct ib_device *, u32, unsigned int, bool);
	int (*fill_res_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_mr_entry_raw)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_cq_entry)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_cq_entry_raw)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_qp_entry)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_qp_entry_raw)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_cm_id_entry)(struct sk_buff *, struct rdma_cm_id *);
	int (*fill_res_srq_entry)(struct sk_buff *, struct ib_srq *);
	int (*fill_res_srq_entry_raw)(struct sk_buff *, struct ib_srq *);
	int (*enable_driver)(struct ib_device *);
	void (*dealloc_driver)(struct ib_device *);
	void (*iw_add_ref)(struct ib_qp *);
	void (*iw_rem_ref)(struct ib_qp *);
	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
	int (*iw_create_listen)(struct iw_cm_id *, int);
	int (*iw_destroy_listen)(struct iw_cm_id *);
	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
	int (*counter_unbind_qp)(struct ib_qp *);
	int (*counter_dealloc)(struct rdma_counter *);
	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
	int (*counter_update_stats)(struct rdma_counter *);
	int (*fill_stat_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*query_ucontext)(struct ib_ucontext *, struct uverbs_attr_bundle *);
	int (*get_numa_node)(struct ib_device *);
	size_t size_ib_ah;
	size_t size_ib_counters;
	size_t size_ib_cq;
	size_t size_ib_mw;
	size_t size_ib_pd;
	size_t size_ib_qp;
	size_t size_ib_rwq_ind_table;
	size_t size_ib_srq;
	size_t size_ib_ucontext;
	size_t size_ib_xrcd;
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE = 0,
	IB_ATOMIC_HCA = 1,
	IB_ATOMIC_GLOB = 2,
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t rc_odp_caps;
		uint32_t uc_odp_caps;
		uint32_t ud_odp_caps;
		uint32_t xrc_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

struct ib_tm_caps {
	u32 max_rndv_hdr_size;
	u32 max_num_tags;
	u32 flags;
	u32 max_ops;
	u32 max_sge;
};

struct ib_cq_caps {
	u16 max_cq_moderation_count;
	u16 max_cq_moderation_period;
};

struct ib_device_attr {
	u64 fw_ver;
	__be64 sys_image_guid;
	u64 max_mr_size;
	u64 page_size_cap;
	u32 vendor_id;
	u32 vendor_part_id;
	u32 hw_ver;
	int max_qp;
	int max_qp_wr;
	u64 device_cap_flags;
	u64 kernel_cap_flags;
	int max_send_sge;
	int max_recv_sge;
	int max_sge_rd;
	int max_cq;
	int max_cqe;
	int max_mr;
	int max_pd;
	int max_qp_rd_atom;
	int max_ee_rd_atom;
	int max_res_rd_atom;
	int max_qp_init_rd_atom;
	int max_ee_init_rd_atom;
	enum ib_atomic_cap atomic_cap;
	enum ib_atomic_cap masked_atomic_cap;
	int max_ee;
	int max_rdd;
	int max_mw;
	int max_raw_ipv6_qp;
	int max_raw_ethy_qp;
	int max_mcast_grp;
	int max_mcast_qp_attach;
	int max_total_mcast_qp_attach;
	int max_ah;
	int max_srq;
	int max_srq_wr;
	int max_srq_sge;
	unsigned int max_fast_reg_page_list_len;
	unsigned int max_pi_fast_reg_page_list_len;
	u16 max_pkeys;
	u8 local_ca_ack_delay;
	int sig_prot_cap;
	int sig_guard_cap;
	struct ib_odp_caps odp_caps;
	uint64_t timestamp_mask;
	uint64_t hca_core_clock;
	struct ib_rss_caps rss_caps;
	u32 max_wq_type_rq;
	u32 raw_packet_caps;
	struct ib_tm_caps tm_caps;
	struct ib_cq_caps cq_caps;
	u64 max_dm_size;
	u32 max_sgl_rd;
};

struct hw_stats_device_data;

struct rdmacg_device {
	struct list_head dev_node;
	struct list_head rpools;
	char *name;
};

struct rdma_restrack_root;

struct uapi_definition;

struct ib_port_data;

struct rdma_link_ops;

struct ib_device {
	struct device *dma_device;
	struct ib_device_ops ops;
	char name[64];
	struct callback_head callback_head;
	struct list_head event_handler_list;
	struct rw_semaphore event_handler_rwsem;
	spinlock_t qp_open_list_lock;
	struct rw_semaphore client_data_rwsem;
	struct xarray client_data;
	struct mutex unregistration_lock;
	rwlock_t cache_lock;
	struct ib_port_data *port_data;
	int num_comp_vectors;
	union {
		struct device dev;
		struct ib_core_device coredev;
	};
	const struct attribute_group *groups[4];
	u64 uverbs_cmd_mask;
	char node_desc[64];
	__be64 node_guid;
	u32 local_dma_lkey;
	u16 is_switch: 1;
	u16 kverbs_provider: 1;
	u16 use_cq_dim: 1;
	u8 node_type;
	u32 phys_port_cnt;
	struct ib_device_attr attrs;
	struct hw_stats_device_data *hw_stats_data;
	struct rdmacg_device cg_device;
	u32 index;
	spinlock_t cq_pools_lock;
	struct list_head cq_pools[3];
	struct rdma_restrack_root *res;
	const struct uapi_definition *driver_def;
	refcount_t refcount;
	struct completion unreg_completion;
	struct work_struct unregistration_work;
	const struct rdma_link_ops *link_ops;
	struct mutex compat_devs_mutex;
	struct xarray compat_devs;
	char iw_ifname[16];
	u32 iw_driver_flags;
	u32 lag_flags;
};

struct ib_uqp_object;

enum ib_qp_type {
	IB_QPT_SMI = 0,
	IB_QPT_GSI = 1,
	IB_QPT_RC = 2,
	IB_QPT_UC = 3,
	IB_QPT_UD = 4,
	IB_QPT_RAW_IPV6 = 5,
	IB_QPT_RAW_ETHERTYPE = 6,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT = 10,
	IB_QPT_MAX = 11,
	IB_QPT_DRIVER = 255,
	IB_QPT_RESERVED1 = 4096,
	IB_QPT_RESERVED2 = 4097,
	IB_QPT_RESERVED3 = 4098,
	IB_QPT_RESERVED4 = 4099,
	IB_QPT_RESERVED5 = 4100,
	IB_QPT_RESERVED6 = 4101,
	IB_QPT_RESERVED7 = 4102,
	IB_QPT_RESERVED8 = 4103,
	IB_QPT_RESERVED9 = 4104,
	IB_QPT_RESERVED10 = 4105,
};

enum rdma_restrack_type {
	RDMA_RESTRACK_PD = 0,
	RDMA_RESTRACK_CQ = 1,
	RDMA_RESTRACK_QP = 2,
	RDMA_RESTRACK_CM_ID = 3,
	RDMA_RESTRACK_MR = 4,
	RDMA_RESTRACK_CTX = 5,
	RDMA_RESTRACK_COUNTER = 6,
	RDMA_RESTRACK_SRQ = 7,
	RDMA_RESTRACK_MAX = 8,
};

struct rdma_restrack_entry {
	bool valid;
	u8 no_track: 1;
	struct kref kref;
	struct completion comp;
	struct task_struct *task;
	const char *kern_name;
	enum rdma_restrack_type type;
	bool user;
	u32 id;
};

struct ib_event;

struct ib_qp_security;

struct ib_qp {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	spinlock_t mr_lock;
	int mrs_used;
	struct list_head rdma_mrs;
	struct list_head sig_mrs;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct list_head xrcd_list;
	atomic_t usecnt;
	struct list_head open_list;
	struct ib_qp *real_qp;
	struct ib_uqp_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	const struct ib_gid_attr *av_sgid_attr;
	const struct ib_gid_attr *alt_path_sgid_attr;
	u32 qp_num;
	u32 max_write_sge;
	u32 max_read_sge;
	enum ib_qp_type qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	struct ib_qp_security *qp_sec;
	u32 port;
	bool integrity_en;
	struct rdma_restrack_entry res;
	struct rdma_counter *counter;
};

struct ib_uobject;

struct ib_pd {
	u32 local_dma_lkey;
	u32 flags;
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 unsafe_global_rkey;
	struct ib_mr *__internal_mr;
	struct rdma_restrack_entry res;
};

struct ib_uverbs_file;

struct rdma_cgroup;

struct ib_rdmacg_object {
	struct rdma_cgroup *cg;
};

struct uverbs_api_object;

struct ib_uobject {
	u64 user_handle;
	struct ib_uverbs_file *ufile;
	struct ib_ucontext *context;
	void *object;
	struct list_head list;
	struct ib_rdmacg_object cg_obj;
	int id;
	struct kref ref;
	atomic_t usecnt;
	struct callback_head rcu;
	const struct uverbs_api_object *uapi_object;
};

struct ib_ucontext {
	struct ib_device *device;
	struct ib_uverbs_file *ufile;
	struct ib_rdmacg_object cg_obj;
	struct rdma_restrack_entry res;
	struct xarray mmap_xa;
};

struct rdma_cgroup {
	struct cgroup_subsys_state css;
	struct list_head rpools;
};

struct ib_sig_attrs;

struct ib_mr {
	struct ib_device *device;
	struct ib_pd *pd;
	u32 lkey;
	u32 rkey;
	u64 iova;
	u64 length;
	unsigned int page_size;
	enum ib_mr_type type;
	bool need_inval;
	union {
		struct ib_uobject *uobject;
		struct list_head qp_entry;
	};
	struct ib_dm *dm;
	struct ib_sig_attrs *sig_attrs;
	struct rdma_restrack_entry res;
};

struct ib_dm {
	struct ib_device *device;
	u32 length;
	u32 flags;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

enum ib_signature_type {
	IB_SIG_TYPE_NONE = 0,
	IB_SIG_TYPE_T10_DIF = 1,
};

enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC = 0,
	IB_T10DIF_CSUM = 1,
};

struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16 pi_interval;
	u16 bg;
	u16 app_tag;
	u32 ref_tag;
	bool ref_remap;
	bool app_escape;
	bool ref_escape;
	u16 apptag_check_mask;
};

struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

struct ib_sig_attrs {
	u8 check_mask;
	struct ib_sig_domain mem;
	struct ib_sig_domain wire;
	int meta_length;
};

struct irq_poll;

typedef int irq_poll_fn(struct irq_poll *, int);

struct irq_poll {
	struct list_head list;
	unsigned long state;
	int weight;
	irq_poll_fn *poll;
};

struct ib_ucq_object;

typedef void (*ib_comp_handler)(struct ib_cq *, void *);

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

struct ib_cq {
	struct ib_device *device;
	struct ib_ucq_object *uobject;
	ib_comp_handler comp_handler;
	void (*event_handler)(struct ib_event *, void *);
	void *cq_context;
	int cqe;
	unsigned int cqe_used;
	atomic_t usecnt;
	enum ib_poll_context poll_ctx;
	struct ib_wc *wc;
	struct list_head pool_entry;
	union {
		struct irq_poll iop;
		struct work_struct work;
	};
	struct workqueue_struct *comp_wq;
	struct dim *dim;
	ktime_t timestamp;
	u8 interrupt: 1;
	u8 shared: 1;
	unsigned int comp_vector;
	struct rdma_restrack_entry res;
};

enum ib_event_type {
	IB_EVENT_CQ_ERR = 0,
	IB_EVENT_QP_FATAL = 1,
	IB_EVENT_QP_REQ_ERR = 2,
	IB_EVENT_QP_ACCESS_ERR = 3,
	IB_EVENT_COMM_EST = 4,
	IB_EVENT_SQ_DRAINED = 5,
	IB_EVENT_PATH_MIG = 6,
	IB_EVENT_PATH_MIG_ERR = 7,
	IB_EVENT_DEVICE_FATAL = 8,
	IB_EVENT_PORT_ACTIVE = 9,
	IB_EVENT_PORT_ERR = 10,
	IB_EVENT_LID_CHANGE = 11,
	IB_EVENT_PKEY_CHANGE = 12,
	IB_EVENT_SM_CHANGE = 13,
	IB_EVENT_SRQ_ERR = 14,
	IB_EVENT_SRQ_LIMIT_REACHED = 15,
	IB_EVENT_QP_LAST_WQE_REACHED = 16,
	IB_EVENT_CLIENT_REREGISTER = 17,
	IB_EVENT_GID_CHANGE = 18,
	IB_EVENT_WQ_FATAL = 19,
};

struct ib_event {
	struct ib_device *device;
	union {
		struct ib_cq *cq;
		struct ib_qp *qp;
		struct ib_srq *srq;
		struct ib_wq *wq;
		u32 port_num;
	} element;
	enum ib_event_type event;
};

struct ib_usrq_object;

enum ib_srq_type {
	IB_SRQT_BASIC = 0,
	IB_SRQT_XRC = 1,
	IB_SRQT_TM = 2,
};

struct ib_srq {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_usrq_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	enum ib_srq_type srq_type;
	atomic_t usecnt;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
				u32 srq_num;
			} xrc;
		};
	} ext;
	struct rdma_restrack_entry res;
};

struct ib_xrcd {
	struct ib_device *device;
	atomic_t usecnt;
	struct inode *inode;
	struct rw_semaphore tgt_qps_rwsem;
	struct xarray tgt_qps;
};

struct ib_uwq_object;

enum ib_wq_state {
	IB_WQS_RESET = 0,
	IB_WQS_RDY = 1,
	IB_WQS_ERR = 2,
};

enum ib_wq_type {
	IB_WQT_RQ = 0,
};

struct ib_wq {
	struct ib_device *device;
	struct ib_uwq_object *uobject;
	void *wq_context;
	void (*event_handler)(struct ib_event *, void *);
	struct ib_pd *pd;
	struct ib_cq *cq;
	u32 wq_num;
	enum ib_wq_state state;
	enum ib_wq_type wq_type;
	atomic_t usecnt;
};

enum ib_wc_status {
	IB_WC_SUCCESS = 0,
	IB_WC_LOC_LEN_ERR = 1,
	IB_WC_LOC_QP_OP_ERR = 2,
	IB_WC_LOC_EEC_OP_ERR = 3,
	IB_WC_LOC_PROT_ERR = 4,
	IB_WC_WR_FLUSH_ERR = 5,
	IB_WC_MW_BIND_ERR = 6,
	IB_WC_BAD_RESP_ERR = 7,
	IB_WC_LOC_ACCESS_ERR = 8,
	IB_WC_REM_INV_REQ_ERR = 9,
	IB_WC_REM_ACCESS_ERR = 10,
	IB_WC_REM_OP_ERR = 11,
	IB_WC_RETRY_EXC_ERR = 12,
	IB_WC_RNR_RETRY_EXC_ERR = 13,
	IB_WC_LOC_RDD_VIOL_ERR = 14,
	IB_WC_REM_INV_RD_REQ_ERR = 15,
	IB_WC_REM_ABORT_ERR = 16,
	IB_WC_INV_EECN_ERR = 17,
	IB_WC_INV_EEC_STATE_ERR = 18,
	IB_WC_FATAL_ERR = 19,
	IB_WC_RESP_TIMEOUT_ERR = 20,
	IB_WC_GENERAL_ERR = 21,
};

enum ib_wc_opcode {
	IB_WC_SEND = 0,
	IB_WC_RDMA_WRITE = 1,
	IB_WC_RDMA_READ = 2,
	IB_WC_COMP_SWAP = 3,
	IB_WC_FETCH_ADD = 4,
	IB_WC_BIND_MW = 5,
	IB_WC_LOCAL_INV = 6,
	IB_WC_LSO = 7,
	IB_WC_ATOMIC_WRITE = 9,
	IB_WC_REG_MR = 10,
	IB_WC_MASKED_COMP_SWAP = 11,
	IB_WC_MASKED_FETCH_ADD = 12,
	IB_WC_FLUSH = 8,
	IB_WC_RECV = 128,
	IB_WC_RECV_RDMA_WITH_IMM = 129,
};

struct ib_cqe;

struct ib_wc {
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	enum ib_wc_status status;
	enum ib_wc_opcode opcode;
	u32 vendor_err;
	u32 byte_len;
	struct ib_qp *qp;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	u32 src_qp;
	u32 slid;
	int wc_flags;
	u16 pkey_index;
	u8 sl;
	u8 dlid_path_bits;
	u32 port_num;
	u8 smac[6];
	u16 vlan_id;
	u8 network_hdr_type;
};

struct ib_cqe {
	void (*done)(struct ib_cq *, struct ib_wc *);
};

union ib_gid {
	u8 raw[16];
	struct {
		__be64 subnet_prefix;
		__be64 interface_id;
	} global;
};

enum ib_gid_type {
	IB_GID_TYPE_IB = 0,
	IB_GID_TYPE_ROCE = 1,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 2,
	IB_GID_TYPE_SIZE = 3,
};

struct ib_gid_attr {
	struct net_device __attribute__((btf_type_tag("rcu"))) *ndev;
	struct ib_device *device;
	union ib_gid gid;
	enum ib_gid_type gid_type;
	u16 index;
	u32 port_num;
};

struct ib_rwq_ind_table {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 ind_tbl_num;
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

struct ib_ports_pkeys;

struct ib_qp_security {
	struct ib_qp *qp;
	struct ib_device *dev;
	struct mutex mutex;
	struct ib_ports_pkeys *ports_pkeys;
	struct list_head shared_qp_list;
	void *security;
	bool destroying;
	atomic_t error_list_count;
	struct completion error_complete;
	int error_comps_pending;
};

enum port_pkey_state {
	IB_PORT_PKEY_NOT_VALID = 0,
	IB_PORT_PKEY_VALID = 1,
	IB_PORT_PKEY_LISTED = 2,
};

struct ib_port_pkey {
	enum port_pkey_state state;
	u16 pkey_index;
	u32 port_num;
	struct list_head qp_list;
	struct list_head to_error_list;
	struct ib_qp_security *sec;
};

struct ib_ports_pkeys {
	struct ib_port_pkey main;
	struct ib_port_pkey alt;
};

enum rdma_nl_counter_mode {
	RDMA_COUNTER_MODE_NONE = 0,
	RDMA_COUNTER_MODE_AUTO = 1,
	RDMA_COUNTER_MODE_MANUAL = 2,
	RDMA_COUNTER_MODE_MAX = 3,
};

enum rdma_nl_counter_mask {
	RDMA_COUNTER_MASK_QP_TYPE = 1,
	RDMA_COUNTER_MASK_PID = 2,
};

struct auto_mode_param {
	int qp_type;
};

struct rdma_counter_mode {
	enum rdma_nl_counter_mode mode;
	enum rdma_nl_counter_mask mask;
	struct auto_mode_param param;
};

struct rdma_counter {
	struct rdma_restrack_entry res;
	struct ib_device *device;
	uint32_t id;
	struct kref kref;
	struct rdma_counter_mode mode;
	struct mutex lock;
	struct rdma_hw_stats *stats;
	u32 port;
};

struct rdma_stat_desc;

struct rdma_hw_stats {
	struct mutex lock;
	unsigned long timestamp;
	unsigned long lifespan;
	const struct rdma_stat_desc *descs;
	unsigned long *is_disabled;
	int num_counters;
	u64 value[0];
};

struct rdma_stat_desc {
	const char *name;
	unsigned int flags;
	const void *priv;
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE = 0,
	IB_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_WR_SEND = 2,
	IB_WR_SEND_WITH_IMM = 3,
	IB_WR_RDMA_READ = 4,
	IB_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_WR_BIND_MW = 8,
	IB_WR_LSO = 10,
	IB_WR_SEND_WITH_INV = 9,
	IB_WR_RDMA_READ_WITH_INV = 11,
	IB_WR_LOCAL_INV = 7,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_WR_FLUSH = 14,
	IB_WR_ATOMIC_WRITE = 15,
	IB_WR_REG_MR = 32,
	IB_WR_REG_MR_INTEGRITY = 33,
	IB_WR_RESERVED1 = 240,
	IB_WR_RESERVED2 = 241,
	IB_WR_RESERVED3 = 242,
	IB_WR_RESERVED4 = 243,
	IB_WR_RESERVED5 = 244,
	IB_WR_RESERVED6 = 245,
	IB_WR_RESERVED7 = 246,
	IB_WR_RESERVED8 = 247,
	IB_WR_RESERVED9 = 248,
	IB_WR_RESERVED10 = 249,
};

struct ib_send_wr {
	struct ib_send_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
	enum ib_wr_opcode opcode;
	int send_flags;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
};

struct ib_sge {
	u64 addr;
	u32 length;
	u32 lkey;
};

struct ib_recv_wr {
	struct ib_recv_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
};

struct ib_grh {
	__be32 version_tclass_flow;
	__be16 paylen;
	u8 next_hdr;
	u8 hop_limit;
	union ib_gid sgid;
	union ib_gid dgid;
};

struct ib_udata {
	const void __attribute__((btf_type_tag("user"))) *inbuf;
	void __attribute__((btf_type_tag("user"))) *outbuf;
	size_t inlen;
	size_t outlen;
};

struct ib_device_modify {
	u64 sys_image_guid;
	char node_desc[64];
};

enum ib_port_state {
	IB_PORT_NOP = 0,
	IB_PORT_DOWN = 1,
	IB_PORT_INIT = 2,
	IB_PORT_ARMED = 3,
	IB_PORT_ACTIVE = 4,
	IB_PORT_ACTIVE_DEFER = 5,
};

enum ib_mtu {
	IB_MTU_256 = 1,
	IB_MTU_512 = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5,
};

struct ib_port_attr {
	u64 subnet_prefix;
	enum ib_port_state state;
	enum ib_mtu max_mtu;
	enum ib_mtu active_mtu;
	u32 phys_mtu;
	int gid_tbl_len;
	unsigned int ip_gids: 1;
	u32 port_cap_flags;
	u32 max_msg_sz;
	u32 bad_pkey_cntr;
	u32 qkey_viol_cntr;
	u16 pkey_tbl_len;
	u32 sm_lid;
	u32 lid;
	u8 lmc;
	u8 max_vl_num;
	u8 sm_sl;
	u8 subnet_timeout;
	u8 init_type_reply;
	u8 active_width;
	u16 active_speed;
	u8 phys_state;
	u16 port_cap_flags2;
};

struct ib_port_modify {
	u32 set_port_cap_mask;
	u32 clr_port_cap_mask;
	u8 init_type;
};

struct ib_port_immutable {
	int pkey_tbl_len;
	int gid_tbl_len;
	u32 core_cap_flags;
	u32 max_mad_size;
};

struct rdma_netdev_alloc_params {
	size_t sizeof_priv;
	unsigned int txqs;
	unsigned int rxqs;
	void *param;
	int (*initialize_rdma_netdev)(struct ib_device *, u32, struct net_device *, void *);
};

struct rdma_user_mmap_entry {
	struct kref ref;
	struct ib_ucontext *ucontext;
	unsigned long start_pgoff;
	size_t npages;
	bool driver_removed;
};

enum rdma_ah_attr_type {
	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
	RDMA_AH_ATTR_TYPE_IB = 1,
	RDMA_AH_ATTR_TYPE_ROCE = 2,
	RDMA_AH_ATTR_TYPE_OPA = 3,
};

struct ib_ah {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_ah_attr_type type;
};

struct rdma_ah_init_attr {
	struct rdma_ah_attr *ah_attr;
	u32 flags;
	struct net_device *xmit_slave;
};

struct ib_ah_attr {
	u16 dlid;
	u8 src_path_bits;
};

struct roce_ah_attr {
	u8 dmac[6];
};

struct opa_ah_attr {
	u32 dlid;
	u8 src_path_bits;
	bool make_grd;
};

struct ib_global_route {
	const struct ib_gid_attr *sgid_attr;
	union ib_gid dgid;
	u32 flow_label;
	u8 sgid_index;
	u8 hop_limit;
	u8 traffic_class;
};

struct rdma_ah_attr {
	struct ib_global_route grh;
	u8 sl;
	u8 static_rate;
	u32 port_num;
	u8 ah_flags;
	enum rdma_ah_attr_type type;
	union {
		struct ib_ah_attr ib;
		struct roce_ah_attr roce;
		struct opa_ah_attr opa;
	};
};

struct ib_srq_attr {
	u32 max_wr;
	u32 max_sge;
	u32 srq_limit;
};

struct ib_srq_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	struct ib_srq_attr attr;
	enum ib_srq_type srq_type;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
			} xrc;
			struct {
				u32 max_num_tags;
			} tag_matching;
		};
	} ext;
};

struct ib_qp_cap {
	u32 max_send_wr;
	u32 max_recv_wr;
	u32 max_send_sge;
	u32 max_recv_sge;
	u32 max_inline_data;
	u32 max_rdma_ctxs;
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR = 0,
	IB_SIGNAL_REQ_WR = 1,
};

struct ib_qp_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct ib_qp_cap cap;
	enum ib_sig_type sq_sig_type;
	enum ib_qp_type qp_type;
	u32 create_flags;
	u32 port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	u32 source_qpn;
};

enum ib_qp_state {
	IB_QPS_RESET = 0,
	IB_QPS_INIT = 1,
	IB_QPS_RTR = 2,
	IB_QPS_RTS = 3,
	IB_QPS_SQD = 4,
	IB_QPS_SQE = 5,
	IB_QPS_ERR = 6,
};

enum ib_mig_state {
	IB_MIG_MIGRATED = 0,
	IB_MIG_REARM = 1,
	IB_MIG_ARMED = 2,
};

struct ib_qp_attr {
	enum ib_qp_state qp_state;
	enum ib_qp_state cur_qp_state;
	enum ib_mtu path_mtu;
	enum ib_mig_state path_mig_state;
	u32 qkey;
	u32 rq_psn;
	u32 sq_psn;
	u32 dest_qp_num;
	int qp_access_flags;
	struct ib_qp_cap cap;
	struct rdma_ah_attr ah_attr;
	struct rdma_ah_attr alt_ah_attr;
	u16 pkey_index;
	u16 alt_pkey_index;
	u8 en_sqd_async_notify;
	u8 sq_draining;
	u8 max_rd_atomic;
	u8 max_dest_rd_atomic;
	u8 min_rnr_timer;
	u32 port_num;
	u8 timeout;
	u8 retry_cnt;
	u8 rnr_retry;
	u32 alt_port_num;
	u8 alt_timeout;
	u32 rate_limit;
	struct net_device *xmit_slave;
};

struct ib_cq_init_attr {
	unsigned int cqe;
	u32 comp_vector;
	u32 flags;
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD = 0,
	IB_SIG_BAD_REFTAG = 1,
	IB_SIG_BAD_APPTAG = 2,
};

struct ib_sig_err {
	enum ib_sig_err_type err_type;
	u32 expected;
	u32 actual;
	u64 sig_err_offset;
	u32 key;
};

struct ib_mr_status {
	u32 fail_status;
	struct ib_sig_err sig_err;
};

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2,
};

struct ib_mw {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	u32 rkey;
	enum ib_mw_type type;
};

struct ib_flow {
	struct ib_qp *qp;
	struct ib_device *device;
	struct ib_uobject *uobject;
};

enum ib_flow_attr_type {
	IB_FLOW_ATTR_NORMAL = 0,
	IB_FLOW_ATTR_ALL_DEFAULT = 1,
	IB_FLOW_ATTR_MC_DEFAULT = 2,
	IB_FLOW_ATTR_SNIFFER = 3,
};

struct ib_flow_eth_filter {
	u8 dst_mac[6];
	u8 src_mac[6];
	__be16 ether_type;
	__be16 vlan_tag;
	u8 real_sz[0];
};

struct ib_flow_spec_eth {
	u32 type;
	u16 size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8 sl;
	u8 real_sz[0];
};

struct ib_flow_spec_ib {
	u32 type;
	u16 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

struct ib_flow_ipv4_filter {
	__be32 src_ip;
	__be32 dst_ip;
	u8 proto;
	u8 tos;
	u8 ttl;
	u8 flags;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv4 {
	u32 type;
	u16 size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16 dst_port;
	__be16 src_port;
	u8 real_sz[0];
};

struct ib_flow_spec_tcp_udp {
	u32 type;
	u16 size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

struct ib_flow_ipv6_filter {
	u8 src_ip[16];
	u8 dst_ip[16];
	__be32 flow_label;
	u8 next_hdr;
	u8 traffic_class;
	u8 hop_limit;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv6 {
	u32 type;
	u16 size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tunnel_filter {
	__be32 tunnel_id;
	u8 real_sz[0];
};

struct ib_flow_spec_tunnel {
	u32 type;
	u16 size;
	struct ib_flow_tunnel_filter val;
	struct ib_flow_tunnel_filter mask;
};

struct ib_flow_esp_filter {
	__be32 spi;
	__be32 seq;
	u8 real_sz[0];
};

struct ib_flow_spec_esp {
	u32 type;
	u16 size;
	struct ib_flow_esp_filter val;
	struct ib_flow_esp_filter mask;
};

struct ib_flow_gre_filter {
	__be16 c_ks_res0_ver;
	__be16 protocol;
	__be32 key;
	u8 real_sz[0];
};

struct ib_flow_spec_gre {
	u32 type;
	u16 size;
	struct ib_flow_gre_filter val;
	struct ib_flow_gre_filter mask;
};

struct ib_flow_mpls_filter {
	__be32 tag;
	u8 real_sz[0];
};

struct ib_flow_spec_mpls {
	u32 type;
	u16 size;
	struct ib_flow_mpls_filter val;
	struct ib_flow_mpls_filter mask;
};

enum ib_flow_spec_type {
	IB_FLOW_SPEC_ETH = 32,
	IB_FLOW_SPEC_IB = 34,
	IB_FLOW_SPEC_IPV4 = 48,
	IB_FLOW_SPEC_IPV6 = 49,
	IB_FLOW_SPEC_ESP = 52,
	IB_FLOW_SPEC_TCP = 64,
	IB_FLOW_SPEC_UDP = 65,
	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
	IB_FLOW_SPEC_GRE = 81,
	IB_FLOW_SPEC_MPLS = 96,
	IB_FLOW_SPEC_INNER = 256,
	IB_FLOW_SPEC_ACTION_TAG = 4096,
	IB_FLOW_SPEC_ACTION_DROP = 4097,
	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
	IB_FLOW_SPEC_ACTION_COUNT = 4099,
};

struct ib_flow_spec_action_tag {
	enum ib_flow_spec_type type;
	u16 size;
	u32 tag_id;
};

struct ib_flow_spec_action_drop {
	enum ib_flow_spec_type type;
	u16 size;
};

struct ib_flow_spec_action_handle {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_flow_action *act;
};

struct ib_flow_spec_action_count {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_counters *counters;
};

union ib_flow_spec {
	struct {
		u32 type;
		u16 size;
	};
	struct ib_flow_spec_eth eth;
	struct ib_flow_spec_ib ib;
	struct ib_flow_spec_ipv4 ipv4;
	struct ib_flow_spec_tcp_udp tcp_udp;
	struct ib_flow_spec_ipv6 ipv6;
	struct ib_flow_spec_tunnel tunnel;
	struct ib_flow_spec_esp esp;
	struct ib_flow_spec_gre gre;
	struct ib_flow_spec_mpls mpls;
	struct ib_flow_spec_action_tag flow_tag;
	struct ib_flow_spec_action_drop drop;
	struct ib_flow_spec_action_handle action;
	struct ib_flow_spec_action_count flow_count;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16 size;
	u16 priority;
	u32 flags;
	u8 num_of_specs;
	u32 port;
	union ib_flow_spec flows[0];
};

enum ib_flow_action_type {
	IB_FLOW_ACTION_UNSPECIFIED = 0,
	IB_FLOW_ACTION_ESP = 1,
};

struct ib_flow_action {
	struct ib_device *device;
	struct ib_uobject *uobject;
	enum ib_flow_action_type type;
	atomic_t usecnt;
};

struct ib_counters {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_wq_init_attr {
	void *wq_context;
	enum ib_wq_type wq_type;
	u32 max_wr;
	u32 max_sge;
	struct ib_cq *cq;
	void (*event_handler)(struct ib_event *, void *);
	u32 create_flags;
};

struct ib_wq_attr {
	enum ib_wq_state wq_state;
	enum ib_wq_state curr_wq_state;
	u32 flags;
	u32 flags_mask;
};

struct ib_rwq_ind_table_init_attr {
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

struct ib_dm_alloc_attr {
	u64 length;
	u32 alignment;
	u32 flags;
};

struct ib_dm_mr_attr {
	u64 length;
	u64 offset;
	u32 access_flags;
};

struct ib_counters_read_attr {
	u64 *counters_buff;
	u32 ncounters;
	u32 flags;
};

struct ib_pkey_cache;

struct ib_gid_table;

struct ib_port_cache {
	u64 subnet_prefix;
	struct ib_pkey_cache *pkey;
	struct ib_gid_table *gid;
	u8 lmc;
	enum ib_port_state port_state;
};

struct rdma_port_counter {
	struct rdma_counter_mode mode;
	struct rdma_hw_stats *hstats;
	unsigned int num_counters;
	struct mutex lock;
};

struct ib_port;

struct ib_port_data {
	struct ib_device *ib_dev;
	struct ib_port_immutable immutable;
	spinlock_t pkey_list_lock;
	spinlock_t netdev_lock;
	struct list_head pkey_list;
	struct ib_port_cache cache;
	struct net_device __attribute__((btf_type_tag("rcu"))) *netdev;
	netdevice_tracker netdev_tracker;
	struct hlist_node ndev_hash_link;
	struct rdma_port_counter port_counter;
	struct ib_port *sysfs;
};

struct rdma_link_ops {
	struct list_head list;
	const char *type;
	int (*newlink)(const char *, struct net_device *);
};

enum devlink_command {
	DEVLINK_CMD_UNSPEC = 0,
	DEVLINK_CMD_GET = 1,
	DEVLINK_CMD_SET = 2,
	DEVLINK_CMD_NEW = 3,
	DEVLINK_CMD_DEL = 4,
	DEVLINK_CMD_PORT_GET = 5,
	DEVLINK_CMD_PORT_SET = 6,
	DEVLINK_CMD_PORT_NEW = 7,
	DEVLINK_CMD_PORT_DEL = 8,
	DEVLINK_CMD_PORT_SPLIT = 9,
	DEVLINK_CMD_PORT_UNSPLIT = 10,
	DEVLINK_CMD_SB_GET = 11,
	DEVLINK_CMD_SB_SET = 12,
	DEVLINK_CMD_SB_NEW = 13,
	DEVLINK_CMD_SB_DEL = 14,
	DEVLINK_CMD_SB_POOL_GET = 15,
	DEVLINK_CMD_SB_POOL_SET = 16,
	DEVLINK_CMD_SB_POOL_NEW = 17,
	DEVLINK_CMD_SB_POOL_DEL = 18,
	DEVLINK_CMD_SB_PORT_POOL_GET = 19,
	DEVLINK_CMD_SB_PORT_POOL_SET = 20,
	DEVLINK_CMD_SB_PORT_POOL_NEW = 21,
	DEVLINK_CMD_SB_PORT_POOL_DEL = 22,
	DEVLINK_CMD_SB_TC_POOL_BIND_GET = 23,
	DEVLINK_CMD_SB_TC_POOL_BIND_SET = 24,
	DEVLINK_CMD_SB_TC_POOL_BIND_NEW = 25,
	DEVLINK_CMD_SB_TC_POOL_BIND_DEL = 26,
	DEVLINK_CMD_SB_OCC_SNAPSHOT = 27,
	DEVLINK_CMD_SB_OCC_MAX_CLEAR = 28,
	DEVLINK_CMD_ESWITCH_GET = 29,
	DEVLINK_CMD_ESWITCH_SET = 30,
	DEVLINK_CMD_DPIPE_TABLE_GET = 31,
	DEVLINK_CMD_DPIPE_ENTRIES_GET = 32,
	DEVLINK_CMD_DPIPE_HEADERS_GET = 33,
	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET = 34,
	DEVLINK_CMD_RESOURCE_SET = 35,
	DEVLINK_CMD_RESOURCE_DUMP = 36,
	DEVLINK_CMD_RELOAD = 37,
	DEVLINK_CMD_PARAM_GET = 38,
	DEVLINK_CMD_PARAM_SET = 39,
	DEVLINK_CMD_PARAM_NEW = 40,
	DEVLINK_CMD_PARAM_DEL = 41,
	DEVLINK_CMD_REGION_GET = 42,
	DEVLINK_CMD_REGION_SET = 43,
	DEVLINK_CMD_REGION_NEW = 44,
	DEVLINK_CMD_REGION_DEL = 45,
	DEVLINK_CMD_REGION_READ = 46,
	DEVLINK_CMD_PORT_PARAM_GET = 47,
	DEVLINK_CMD_PORT_PARAM_SET = 48,
	DEVLINK_CMD_PORT_PARAM_NEW = 49,
	DEVLINK_CMD_PORT_PARAM_DEL = 50,
	DEVLINK_CMD_INFO_GET = 51,
	DEVLINK_CMD_HEALTH_REPORTER_GET = 52,
	DEVLINK_CMD_HEALTH_REPORTER_SET = 53,
	DEVLINK_CMD_HEALTH_REPORTER_RECOVER = 54,
	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE = 55,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET = 56,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR = 57,
	DEVLINK_CMD_FLASH_UPDATE = 58,
	DEVLINK_CMD_FLASH_UPDATE_END = 59,
	DEVLINK_CMD_FLASH_UPDATE_STATUS = 60,
	DEVLINK_CMD_TRAP_GET = 61,
	DEVLINK_CMD_TRAP_SET = 62,
	DEVLINK_CMD_TRAP_NEW = 63,
	DEVLINK_CMD_TRAP_DEL = 64,
	DEVLINK_CMD_TRAP_GROUP_GET = 65,
	DEVLINK_CMD_TRAP_GROUP_SET = 66,
	DEVLINK_CMD_TRAP_GROUP_NEW = 67,
	DEVLINK_CMD_TRAP_GROUP_DEL = 68,
	DEVLINK_CMD_TRAP_POLICER_GET = 69,
	DEVLINK_CMD_TRAP_POLICER_SET = 70,
	DEVLINK_CMD_TRAP_POLICER_NEW = 71,
	DEVLINK_CMD_TRAP_POLICER_DEL = 72,
	DEVLINK_CMD_HEALTH_REPORTER_TEST = 73,
	DEVLINK_CMD_RATE_GET = 74,
	DEVLINK_CMD_RATE_SET = 75,
	DEVLINK_CMD_RATE_NEW = 76,
	DEVLINK_CMD_RATE_DEL = 77,
	DEVLINK_CMD_LINECARD_GET = 78,
	DEVLINK_CMD_LINECARD_SET = 79,
	DEVLINK_CMD_LINECARD_NEW = 80,
	DEVLINK_CMD_LINECARD_DEL = 81,
	DEVLINK_CMD_SELFTESTS_GET = 82,
	DEVLINK_CMD_SELFTESTS_RUN = 83,
	__DEVLINK_CMD_MAX = 84,
	DEVLINK_CMD_MAX = 83,
};

enum devlink_attr {
	DEVLINK_ATTR_UNSPEC = 0,
	DEVLINK_ATTR_BUS_NAME = 1,
	DEVLINK_ATTR_DEV_NAME = 2,
	DEVLINK_ATTR_PORT_INDEX = 3,
	DEVLINK_ATTR_PORT_TYPE = 4,
	DEVLINK_ATTR_PORT_DESIRED_TYPE = 5,
	DEVLINK_ATTR_PORT_NETDEV_IFINDEX = 6,
	DEVLINK_ATTR_PORT_NETDEV_NAME = 7,
	DEVLINK_ATTR_PORT_IBDEV_NAME = 8,
	DEVLINK_ATTR_PORT_SPLIT_COUNT = 9,
	DEVLINK_ATTR_PORT_SPLIT_GROUP = 10,
	DEVLINK_ATTR_SB_INDEX = 11,
	DEVLINK_ATTR_SB_SIZE = 12,
	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT = 13,
	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT = 14,
	DEVLINK_ATTR_SB_INGRESS_TC_COUNT = 15,
	DEVLINK_ATTR_SB_EGRESS_TC_COUNT = 16,
	DEVLINK_ATTR_SB_POOL_INDEX = 17,
	DEVLINK_ATTR_SB_POOL_TYPE = 18,
	DEVLINK_ATTR_SB_POOL_SIZE = 19,
	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE = 20,
	DEVLINK_ATTR_SB_THRESHOLD = 21,
	DEVLINK_ATTR_SB_TC_INDEX = 22,
	DEVLINK_ATTR_SB_OCC_CUR = 23,
	DEVLINK_ATTR_SB_OCC_MAX = 24,
	DEVLINK_ATTR_ESWITCH_MODE = 25,
	DEVLINK_ATTR_ESWITCH_INLINE_MODE = 26,
	DEVLINK_ATTR_DPIPE_TABLES = 27,
	DEVLINK_ATTR_DPIPE_TABLE = 28,
	DEVLINK_ATTR_DPIPE_TABLE_NAME = 29,
	DEVLINK_ATTR_DPIPE_TABLE_SIZE = 30,
	DEVLINK_ATTR_DPIPE_TABLE_MATCHES = 31,
	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS = 32,
	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED = 33,
	DEVLINK_ATTR_DPIPE_ENTRIES = 34,
	DEVLINK_ATTR_DPIPE_ENTRY = 35,
	DEVLINK_ATTR_DPIPE_ENTRY_INDEX = 36,
	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES = 37,
	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES = 38,
	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER = 39,
	DEVLINK_ATTR_DPIPE_MATCH = 40,
	DEVLINK_ATTR_DPIPE_MATCH_VALUE = 41,
	DEVLINK_ATTR_DPIPE_MATCH_TYPE = 42,
	DEVLINK_ATTR_DPIPE_ACTION = 43,
	DEVLINK_ATTR_DPIPE_ACTION_VALUE = 44,
	DEVLINK_ATTR_DPIPE_ACTION_TYPE = 45,
	DEVLINK_ATTR_DPIPE_VALUE = 46,
	DEVLINK_ATTR_DPIPE_VALUE_MASK = 47,
	DEVLINK_ATTR_DPIPE_VALUE_MAPPING = 48,
	DEVLINK_ATTR_DPIPE_HEADERS = 49,
	DEVLINK_ATTR_DPIPE_HEADER = 50,
	DEVLINK_ATTR_DPIPE_HEADER_NAME = 51,
	DEVLINK_ATTR_DPIPE_HEADER_ID = 52,
	DEVLINK_ATTR_DPIPE_HEADER_FIELDS = 53,
	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL = 54,
	DEVLINK_ATTR_DPIPE_HEADER_INDEX = 55,
	DEVLINK_ATTR_DPIPE_FIELD = 56,
	DEVLINK_ATTR_DPIPE_FIELD_NAME = 57,
	DEVLINK_ATTR_DPIPE_FIELD_ID = 58,
	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH = 59,
	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE = 60,
	DEVLINK_ATTR_PAD = 61,
	DEVLINK_ATTR_ESWITCH_ENCAP_MODE = 62,
	DEVLINK_ATTR_RESOURCE_LIST = 63,
	DEVLINK_ATTR_RESOURCE = 64,
	DEVLINK_ATTR_RESOURCE_NAME = 65,
	DEVLINK_ATTR_RESOURCE_ID = 66,
	DEVLINK_ATTR_RESOURCE_SIZE = 67,
	DEVLINK_ATTR_RESOURCE_SIZE_NEW = 68,
	DEVLINK_ATTR_RESOURCE_SIZE_VALID = 69,
	DEVLINK_ATTR_RESOURCE_SIZE_MIN = 70,
	DEVLINK_ATTR_RESOURCE_SIZE_MAX = 71,
	DEVLINK_ATTR_RESOURCE_SIZE_GRAN = 72,
	DEVLINK_ATTR_RESOURCE_UNIT = 73,
	DEVLINK_ATTR_RESOURCE_OCC = 74,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID = 75,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS = 76,
	DEVLINK_ATTR_PORT_FLAVOUR = 77,
	DEVLINK_ATTR_PORT_NUMBER = 78,
	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER = 79,
	DEVLINK_ATTR_PARAM = 80,
	DEVLINK_ATTR_PARAM_NAME = 81,
	DEVLINK_ATTR_PARAM_GENERIC = 82,
	DEVLINK_ATTR_PARAM_TYPE = 83,
	DEVLINK_ATTR_PARAM_VALUES_LIST = 84,
	DEVLINK_ATTR_PARAM_VALUE = 85,
	DEVLINK_ATTR_PARAM_VALUE_DATA = 86,
	DEVLINK_ATTR_PARAM_VALUE_CMODE = 87,
	DEVLINK_ATTR_REGION_NAME = 88,
	DEVLINK_ATTR_REGION_SIZE = 89,
	DEVLINK_ATTR_REGION_SNAPSHOTS = 90,
	DEVLINK_ATTR_REGION_SNAPSHOT = 91,
	DEVLINK_ATTR_REGION_SNAPSHOT_ID = 92,
	DEVLINK_ATTR_REGION_CHUNKS = 93,
	DEVLINK_ATTR_REGION_CHUNK = 94,
	DEVLINK_ATTR_REGION_CHUNK_DATA = 95,
	DEVLINK_ATTR_REGION_CHUNK_ADDR = 96,
	DEVLINK_ATTR_REGION_CHUNK_LEN = 97,
	DEVLINK_ATTR_INFO_DRIVER_NAME = 98,
	DEVLINK_ATTR_INFO_SERIAL_NUMBER = 99,
	DEVLINK_ATTR_INFO_VERSION_FIXED = 100,
	DEVLINK_ATTR_INFO_VERSION_RUNNING = 101,
	DEVLINK_ATTR_INFO_VERSION_STORED = 102,
	DEVLINK_ATTR_INFO_VERSION_NAME = 103,
	DEVLINK_ATTR_INFO_VERSION_VALUE = 104,
	DEVLINK_ATTR_SB_POOL_CELL_SIZE = 105,
	DEVLINK_ATTR_FMSG = 106,
	DEVLINK_ATTR_FMSG_OBJ_NEST_START = 107,
	DEVLINK_ATTR_FMSG_PAIR_NEST_START = 108,
	DEVLINK_ATTR_FMSG_ARR_NEST_START = 109,
	DEVLINK_ATTR_FMSG_NEST_END = 110,
	DEVLINK_ATTR_FMSG_OBJ_NAME = 111,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE = 112,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA = 113,
	DEVLINK_ATTR_HEALTH_REPORTER = 114,
	DEVLINK_ATTR_HEALTH_REPORTER_NAME = 115,
	DEVLINK_ATTR_HEALTH_REPORTER_STATE = 116,
	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT = 117,
	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT = 118,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS = 119,
	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD = 120,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER = 121,
	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME = 122,
	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT = 123,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG = 124,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE = 125,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL = 126,
	DEVLINK_ATTR_PORT_PCI_PF_NUMBER = 127,
	DEVLINK_ATTR_PORT_PCI_VF_NUMBER = 128,
	DEVLINK_ATTR_STATS = 129,
	DEVLINK_ATTR_TRAP_NAME = 130,
	DEVLINK_ATTR_TRAP_ACTION = 131,
	DEVLINK_ATTR_TRAP_TYPE = 132,
	DEVLINK_ATTR_TRAP_GENERIC = 133,
	DEVLINK_ATTR_TRAP_METADATA = 134,
	DEVLINK_ATTR_TRAP_GROUP_NAME = 135,
	DEVLINK_ATTR_RELOAD_FAILED = 136,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS = 137,
	DEVLINK_ATTR_NETNS_FD = 138,
	DEVLINK_ATTR_NETNS_PID = 139,
	DEVLINK_ATTR_NETNS_ID = 140,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_DUMP = 141,
	DEVLINK_ATTR_TRAP_POLICER_ID = 142,
	DEVLINK_ATTR_TRAP_POLICER_RATE = 143,
	DEVLINK_ATTR_TRAP_POLICER_BURST = 144,
	DEVLINK_ATTR_PORT_FUNCTION = 145,
	DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER = 146,
	DEVLINK_ATTR_PORT_LANES = 147,
	DEVLINK_ATTR_PORT_SPLITTABLE = 148,
	DEVLINK_ATTR_PORT_EXTERNAL = 149,
	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER = 150,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT = 151,
	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK = 152,
	DEVLINK_ATTR_RELOAD_ACTION = 153,
	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED = 154,
	DEVLINK_ATTR_RELOAD_LIMITS = 155,
	DEVLINK_ATTR_DEV_STATS = 156,
	DEVLINK_ATTR_RELOAD_STATS = 157,
	DEVLINK_ATTR_RELOAD_STATS_ENTRY = 158,
	DEVLINK_ATTR_RELOAD_STATS_LIMIT = 159,
	DEVLINK_ATTR_RELOAD_STATS_VALUE = 160,
	DEVLINK_ATTR_REMOTE_RELOAD_STATS = 161,
	DEVLINK_ATTR_RELOAD_ACTION_INFO = 162,
	DEVLINK_ATTR_RELOAD_ACTION_STATS = 163,
	DEVLINK_ATTR_PORT_PCI_SF_NUMBER = 164,
	DEVLINK_ATTR_RATE_TYPE = 165,
	DEVLINK_ATTR_RATE_TX_SHARE = 166,
	DEVLINK_ATTR_RATE_TX_MAX = 167,
	DEVLINK_ATTR_RATE_NODE_NAME = 168,
	DEVLINK_ATTR_RATE_PARENT_NODE_NAME = 169,
	DEVLINK_ATTR_REGION_MAX_SNAPSHOTS = 170,
	DEVLINK_ATTR_LINECARD_INDEX = 171,
	DEVLINK_ATTR_LINECARD_STATE = 172,
	DEVLINK_ATTR_LINECARD_TYPE = 173,
	DEVLINK_ATTR_LINECARD_SUPPORTED_TYPES = 174,
	DEVLINK_ATTR_NESTED_DEVLINK = 175,
	DEVLINK_ATTR_SELFTESTS = 176,
	DEVLINK_ATTR_RATE_TX_PRIORITY = 177,
	DEVLINK_ATTR_RATE_TX_WEIGHT = 178,
	DEVLINK_ATTR_REGION_DIRECT = 179,
	__DEVLINK_ATTR_MAX = 180,
	DEVLINK_ATTR_MAX = 179,
};

struct devlink_sb {
	struct list_head list;
	unsigned int index;
	u32 size;
	u16 ingress_pools_count;
	u16 egress_pools_count;
	u16 ingress_tc_count;
	u16 egress_tc_count;
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct devlink_nl_dump_state {
	unsigned long instance;
	int idx;
	union {
		struct {
			u64 start_offset;
		};
		struct {
			u64 dump_ts;
		};
	};
};

typedef int devlink_nl_dump_one_func_t(struct sk_buff *, struct devlink *, struct netlink_callback *, int);

enum rpc_auth_flavors {
	RPC_AUTH_NULL = 0,
	RPC_AUTH_UNIX = 1,
	RPC_AUTH_SHORT = 2,
	RPC_AUTH_DES = 3,
	RPC_AUTH_KRB = 4,
	RPC_AUTH_GSS = 6,
	RPC_AUTH_TLS = 7,
	RPC_AUTH_MAXFLAVOR = 8,
	RPC_AUTH_GSS_KRB5 = 390003,
	RPC_AUTH_GSS_KRB5I = 390004,
	RPC_AUTH_GSS_KRB5P = 390005,
	RPC_AUTH_GSS_LKEY = 390006,
	RPC_AUTH_GSS_LKEYI = 390007,
	RPC_AUTH_GSS_LKEYP = 390008,
	RPC_AUTH_GSS_SPKM = 390009,
	RPC_AUTH_GSS_SPKMI = 390010,
	RPC_AUTH_GSS_SPKMP = 390011,
};

struct svc_xprt_class;

struct svc_xprt_ops;

struct svc_xprt {
	struct svc_xprt_class *xpt_class;
	const struct svc_xprt_ops *xpt_ops;
	struct kref xpt_ref;
	struct list_head xpt_list;
	struct lwq_node xpt_ready;
	unsigned long xpt_flags;
	struct svc_serv *xpt_server;
	atomic_t xpt_reserved;
	atomic_t xpt_nr_rqsts;
	struct mutex xpt_mutex;
	spinlock_t xpt_lock;
	void *xpt_auth_cache;
	struct list_head xpt_deferred;
	struct __kernel_sockaddr_storage xpt_local;
	size_t xpt_locallen;
	struct __kernel_sockaddr_storage xpt_remote;
	size_t xpt_remotelen;
	char xpt_remotebuf[58];
	struct list_head xpt_users;
	struct net *xpt_net;
	netns_tracker ns_tracker;
	const struct cred *xpt_cred;
	struct rpc_xprt *xpt_bc_xprt;
	struct rpc_xprt_switch *xpt_bc_xps;
};

struct svc_xprt_class {
	const char *xcl_name;
	struct module *xcl_owner;
	const struct svc_xprt_ops *xcl_ops;
	struct list_head xcl_list;
	u32 xcl_max_payload;
	int xcl_ident;
};

struct svc_xprt_ops {
	struct svc_xprt * (*xpo_create)(struct svc_serv *, struct net *, struct sockaddr *, int, int);
	struct svc_xprt * (*xpo_accept)(struct svc_xprt *);
	int (*xpo_has_wspace)(struct svc_xprt *);
	int (*xpo_recvfrom)(struct svc_rqst *);
	int (*xpo_sendto)(struct svc_rqst *);
	int (*xpo_result_payload)(struct svc_rqst *, unsigned int, unsigned int);
	void (*xpo_release_ctxt)(struct svc_xprt *, void *);
	void (*xpo_detach)(struct svc_xprt *);
	void (*xpo_free)(struct svc_xprt *);
	void (*xpo_kill_temp_xprt)(struct svc_xprt *);
	void (*xpo_handshake)(struct svc_xprt *);
};

struct cache_detail {
	struct module *owner;
	int hash_size;
	struct hlist_head *hash_table;
	spinlock_t hash_lock;
	char *name;
	void (*cache_put)(struct kref *);
	int (*cache_upcall)(struct cache_detail *, struct cache_head *);
	void (*cache_request)(struct cache_detail *, struct cache_head *, char **, int *);
	int (*cache_parse)(struct cache_detail *, char *, int);
	int (*cache_show)(struct seq_file *, struct cache_detail *, struct cache_head *);
	void (*warn_no_listener)(struct cache_detail *, int);
	struct cache_head * (*alloc)();
	void (*flush)();
	int (*match)(struct cache_head *, struct cache_head *);
	void (*init)(struct cache_head *, struct cache_head *);
	void (*update)(struct cache_head *, struct cache_head *);
	time64_t flush_time;
	struct list_head others;
	time64_t nextcheck;
	int entries;
	struct list_head queue;
	atomic_t writers;
	time64_t last_close;
	time64_t last_warn;
	union {
		struct proc_dir_entry *procfs;
		struct dentry *pipefs;
	};
	struct net *net;
};

enum rpc_auth_stat {
	RPC_AUTH_OK = 0,
	RPC_AUTH_BADCRED = 1,
	RPC_AUTH_REJECTEDCRED = 2,
	RPC_AUTH_BADVERF = 3,
	RPC_AUTH_REJECTEDVERF = 4,
	RPC_AUTH_TOOWEAK = 5,
	RPCSEC_GSS_CREDPROBLEM = 13,
	RPCSEC_GSS_CTXPROBLEM = 14,
};

enum rpc_gss_proc {
	RPC_GSS_PROC_DATA = 0,
	RPC_GSS_PROC_INIT = 1,
	RPC_GSS_PROC_CONTINUE_INIT = 2,
	RPC_GSS_PROC_DESTROY = 3,
};

enum rpc_gss_svc {
	RPC_GSS_SVC_NONE = 1,
	RPC_GSS_SVC_INTEGRITY = 2,
	RPC_GSS_SVC_PRIVACY = 3,
};

enum rpc_accept_stat {
	RPC_SUCCESS = 0,
	RPC_PROG_UNAVAIL = 1,
	RPC_PROG_MISMATCH = 2,
	RPC_PROC_UNAVAIL = 3,
	RPC_GARBAGE_ARGS = 4,
	RPC_SYSTEM_ERR = 5,
	RPC_DROP_REPLY = 60000,
};

enum {
	RQ_SECURE = 0,
	RQ_LOCAL = 1,
	RQ_USEDEFERRAL = 2,
	RQ_DROPME = 3,
	RQ_SPLICE_OK = 4,
	RQ_VICTIM = 5,
	RQ_DATA = 6,
};

enum {
	CACHE_VALID = 0,
	CACHE_NEGATIVE = 1,
	CACHE_PENDING = 2,
	CACHE_CLEANED = 3,
};

struct gss_domain {
	struct auth_domain h;
	u32 pseudoflavor;
};

struct rsi {
	struct cache_head h;
	struct xdr_netobj in_handle;
	struct xdr_netobj in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	int major_status;
	int minor_status;
	struct callback_head callback_head;
};

typedef unsigned int OM_uint32;

struct gss_svc_seq_data {
	u32 sd_max;
	unsigned long sd_win[2];
	spinlock_t sd_lock;
};

struct rsc {
	struct cache_head h;
	struct xdr_netobj handle;
	struct svc_cred cred;
	struct gss_svc_seq_data seqdata;
	struct gss_ctx *mechctx;
	struct callback_head callback_head;
};

struct rpc_pipe;

struct sunrpc_net {
	struct proc_dir_entry *proc_net_rpc;
	struct cache_detail *ip_map_cache;
	struct cache_detail *unix_gid_cache;
	struct cache_detail *rsc_cache;
	struct cache_detail *rsi_cache;
	struct super_block *pipefs_sb;
	struct rpc_pipe *gssd_dummy;
	struct mutex pipefs_sb_lock;
	struct list_head all_clients;
	spinlock_t rpc_client_lock;
	struct rpc_clnt *rpcb_local_clnt;
	struct rpc_clnt *rpcb_local_clnt4;
	spinlock_t rpcb_clnt_lock;
	unsigned int rpcb_users;
	unsigned int rpcb_is_af_local: 1;
	struct mutex gssp_lock;
	struct rpc_clnt *gssp_clnt;
	int use_gss_proxy;
	int pipe_version;
	atomic_t pipe_users;
	struct proc_dir_entry *use_gssp_proc;
	struct proc_dir_entry *gss_krb5_enctypes;
};

struct rpc_pipe_ops;

struct rpc_pipe {
	struct list_head pipe;
	struct list_head in_upcall;
	struct list_head in_downcall;
	int pipelen;
	int nreaders;
	int nwriters;
	int flags;
	struct delayed_work queue_timeout;
	const struct rpc_pipe_ops *ops;
	spinlock_t lock;
	struct dentry *dentry;
};

struct rpc_pipe_msg;

struct rpc_pipe_ops {
	ssize_t (*upcall)(struct file *, struct rpc_pipe_msg *, char __attribute__((btf_type_tag("user"))) *, size_t);
	ssize_t (*downcall)(struct file *, const char __attribute__((btf_type_tag("user"))) *, size_t);
	void (*release_pipe)(struct inode *);
	int (*open_pipe)(struct inode *);
	void (*destroy_msg)(struct rpc_pipe_msg *);
};

struct rpc_pipe_msg {
	struct list_head list;
	void *data;
	size_t len;
	size_t copied;
	int errno;
};

struct rpc_gss_wire_cred {
	u32 gc_v;
	u32 gc_proc;
	u32 gc_seq;
	u32 gc_svc;
	struct xdr_netobj gc_ctx;
};

struct gss_svc_data {
	struct rpc_gss_wire_cred clcred;
	u32 gsd_databody_offset;
	struct rsc *rsci;
	__be32 gsd_seq_num;
	u8 gsd_scratch[40];
};

struct gssp_in_token {
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
};

struct gssp_upcall_data {
	struct xdr_netobj in_handle;
	struct gssp_in_token in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	struct rpcsec_gss_oid mech_oid;
	struct svc_cred creds;
	int found_creds;
	int major_status;
	int minor_status;
};

enum aarch64_insn_condition {
	AARCH64_INSN_COND_EQ = 0,
	AARCH64_INSN_COND_NE = 1,
	AARCH64_INSN_COND_CS = 2,
	AARCH64_INSN_COND_CC = 3,
	AARCH64_INSN_COND_MI = 4,
	AARCH64_INSN_COND_PL = 5,
	AARCH64_INSN_COND_VS = 6,
	AARCH64_INSN_COND_VC = 7,
	AARCH64_INSN_COND_HI = 8,
	AARCH64_INSN_COND_LS = 9,
	AARCH64_INSN_COND_GE = 10,
	AARCH64_INSN_COND_LT = 11,
	AARCH64_INSN_COND_GT = 12,
	AARCH64_INSN_COND_LE = 13,
	AARCH64_INSN_COND_AL = 14,
};

enum aarch64_insn_size_type {
	AARCH64_INSN_SIZE_8 = 0,
	AARCH64_INSN_SIZE_16 = 1,
	AARCH64_INSN_SIZE_32 = 2,
	AARCH64_INSN_SIZE_64 = 3,
};

enum aarch64_insn_ldst_type {
	AARCH64_INSN_LDST_LOAD_REG_OFFSET = 0,
	AARCH64_INSN_LDST_STORE_REG_OFFSET = 1,
	AARCH64_INSN_LDST_LOAD_IMM_OFFSET = 2,
	AARCH64_INSN_LDST_STORE_IMM_OFFSET = 3,
	AARCH64_INSN_LDST_LOAD_PAIR_PRE_INDEX = 4,
	AARCH64_INSN_LDST_STORE_PAIR_PRE_INDEX = 5,
	AARCH64_INSN_LDST_LOAD_PAIR_POST_INDEX = 6,
	AARCH64_INSN_LDST_STORE_PAIR_POST_INDEX = 7,
	AARCH64_INSN_LDST_LOAD_EX = 8,
	AARCH64_INSN_LDST_LOAD_ACQ_EX = 9,
	AARCH64_INSN_LDST_STORE_EX = 10,
	AARCH64_INSN_LDST_STORE_REL_EX = 11,
	AARCH64_INSN_LDST_SIGNED_LOAD_IMM_OFFSET = 12,
	AARCH64_INSN_LDST_SIGNED_LOAD_REG_OFFSET = 13,
};

enum aarch64_insn_mem_atomic_op {
	AARCH64_INSN_MEM_ATOMIC_ADD = 0,
	AARCH64_INSN_MEM_ATOMIC_CLR = 1,
	AARCH64_INSN_MEM_ATOMIC_EOR = 2,
	AARCH64_INSN_MEM_ATOMIC_SET = 3,
	AARCH64_INSN_MEM_ATOMIC_SWP = 4,
};

enum aarch64_insn_mem_order_type {
	AARCH64_INSN_MEM_ORDER_NONE = 0,
	AARCH64_INSN_MEM_ORDER_ACQ = 1,
	AARCH64_INSN_MEM_ORDER_REL = 2,
	AARCH64_INSN_MEM_ORDER_ACQREL = 3,
};

enum aarch64_insn_adsb_type {
	AARCH64_INSN_ADSB_ADD = 0,
	AARCH64_INSN_ADSB_SUB = 1,
	AARCH64_INSN_ADSB_ADD_SETFLAGS = 2,
	AARCH64_INSN_ADSB_SUB_SETFLAGS = 3,
};

enum aarch64_insn_bitfield_type {
	AARCH64_INSN_BITFIELD_MOVE = 0,
	AARCH64_INSN_BITFIELD_MOVE_UNSIGNED = 1,
	AARCH64_INSN_BITFIELD_MOVE_SIGNED = 2,
};

enum aarch64_insn_data1_type {
	AARCH64_INSN_DATA1_REVERSE_16 = 0,
	AARCH64_INSN_DATA1_REVERSE_32 = 1,
	AARCH64_INSN_DATA1_REVERSE_64 = 2,
};

enum aarch64_insn_data2_type {
	AARCH64_INSN_DATA2_UDIV = 0,
	AARCH64_INSN_DATA2_SDIV = 1,
	AARCH64_INSN_DATA2_LSLV = 2,
	AARCH64_INSN_DATA2_LSRV = 3,
	AARCH64_INSN_DATA2_ASRV = 4,
	AARCH64_INSN_DATA2_RORV = 5,
};

enum aarch64_insn_data3_type {
	AARCH64_INSN_DATA3_MADD = 0,
	AARCH64_INSN_DATA3_MSUB = 1,
};

enum aarch64_insn_adr_type {
	AARCH64_INSN_ADR_TYPE_ADRP = 0,
	AARCH64_INSN_ADR_TYPE_ADR = 1,
};

enum aarch64_insn_mb_type {
	AARCH64_INSN_MB_SY = 0,
	AARCH64_INSN_MB_ST = 1,
	AARCH64_INSN_MB_LD = 2,
	AARCH64_INSN_MB_ISH = 3,
	AARCH64_INSN_MB_ISHST = 4,
	AARCH64_INSN_MB_ISHLD = 5,
	AARCH64_INSN_MB_NSH = 6,
	AARCH64_INSN_MB_NSHST = 7,
	AARCH64_INSN_MB_NSHLD = 8,
	AARCH64_INSN_MB_OSH = 9,
	AARCH64_INSN_MB_OSHST = 10,
	AARCH64_INSN_MB_OSHLD = 11,
};

typedef __u16 Elf32_Half;

typedef __u32 Elf32_Word;

typedef __u32 Elf32_Addr;

typedef __u32 Elf32_Off;

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

typedef struct elf32_hdr Elf32_Ehdr;

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

typedef struct elf32_phdr Elf32_Phdr;

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

typedef struct elf64_phdr Elf64_Phdr;

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

typedef struct elf32_note Elf32_Nhdr;

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

struct logic_pio_host_ops;

struct logic_pio_hwaddr {
	struct list_head list;
	struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	unsigned long flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, unsigned long, size_t);
	void (*out)(void *, unsigned long, u32, size_t);
	u32 (*ins)(void *, unsigned long, void *, size_t, unsigned int);
	void (*outs)(void *, unsigned long, const void *, size_t, unsigned int);
};

typedef struct {
	u64 signature;
	u32 revision;
	u32 headersize;
	u32 crc32;
	u32 reserved;
} efi_table_hdr_t;

typedef struct {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 minute;
	u8 second;
	u8 pad1;
	u32 nanosecond;
	s16 timezone;
	u8 daylight;
	u8 pad2;
} efi_time_t;

typedef struct {
	u32 resolution;
	u32 accuracy;
	u8 sets_to_zero;
} efi_time_cap_t;

typedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);

typedef efi_status_t efi_set_time_t(efi_time_t *);

typedef u8 efi_bool_t;

typedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);

typedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);

typedef efi_status_t efi_set_virtual_address_map_t(unsigned long, unsigned long, u32, efi_memory_desc_t *);

typedef u16 efi_char16_t;

typedef struct {
	__u8 b[16];
} guid_t;

typedef guid_t efi_guid_t;

typedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, unsigned long *, void *);

typedef efi_status_t efi_get_next_variable_t(unsigned long *, efi_char16_t *, efi_guid_t *);

typedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, unsigned long, void *);

typedef efi_status_t efi_get_next_high_mono_count_t(u32 *);

typedef void efi_reset_system_t(int, efi_status_t, unsigned long, efi_char16_t *);

typedef struct {
	efi_guid_t guid;
	u32 headersize;
	u32 flags;
	u32 imagesize;
} efi_capsule_header_t;

typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, unsigned long, unsigned long);

typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, unsigned long, u64 *, int *);

typedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);

typedef struct {
	efi_table_hdr_t hdr;
	u32 get_time;
	u32 set_time;
	u32 get_wakeup_time;
	u32 set_wakeup_time;
	u32 set_virtual_address_map;
	u32 convert_pointer;
	u32 get_variable;
	u32 get_next_variable;
	u32 set_variable;
	u32 get_next_high_mono_count;
	u32 reset_system;
	u32 update_capsule;
	u32 query_capsule_caps;
	u32 query_variable_info;
} efi_runtime_services_32_t;

typedef union {
	struct {
		efi_table_hdr_t hdr;
		efi_get_time_t *get_time;
		efi_set_time_t *set_time;
		efi_get_wakeup_time_t *get_wakeup_time;
		efi_set_wakeup_time_t *set_wakeup_time;
		efi_set_virtual_address_map_t *set_virtual_address_map;
		void *convert_pointer;
		efi_get_variable_t *get_variable;
		efi_get_next_variable_t *get_next_variable;
		efi_set_variable_t *set_variable;
		efi_get_next_high_mono_count_t *get_next_high_mono_count;
		efi_reset_system_t *reset_system;
		efi_update_capsule_t *update_capsule;
		efi_query_capsule_caps_t *query_capsule_caps;
		efi_query_variable_info_t *query_variable_info;
	};
	efi_runtime_services_32_t mixed_mode;
} efi_runtime_services_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 fw_vendor;
	u32 fw_revision;
	u32 con_in_handle;
	u32 con_in;
	u32 con_out_handle;
	u32 con_out;
	u32 stderr_handle;
	u32 stderr;
	u32 runtime;
	u32 boottime;
	u32 nr_tables;
	u32 tables;
} efi_system_table_32_t;

union efi_simple_text_input_protocol;

typedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;

union efi_simple_text_output_protocol;

typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;

union efi_boot_services;

typedef union efi_boot_services efi_boot_services_t;

typedef union {
	struct {
		efi_table_hdr_t hdr;
		unsigned long fw_vendor;
		u32 fw_revision;
		unsigned long con_in_handle;
		efi_simple_text_input_protocol_t *con_in;
		unsigned long con_out_handle;
		efi_simple_text_output_protocol_t *con_out;
		unsigned long stderr_handle;
		unsigned long stderr;
		efi_runtime_services_t *runtime;
		efi_boot_services_t *boottime;
		unsigned long nr_tables;
		unsigned long tables;
	};
	efi_system_table_32_t mixed_mode;
} efi_system_table_t;

typedef struct {
	u16 scan_code;
	efi_char16_t unicode_char;
} efi_input_key_t;

typedef void *efi_event_t;

union efi_simple_text_input_protocol {
	struct {
		void *reset;
		efi_status_t (*read_keystroke)(efi_simple_text_input_protocol_t *, efi_input_key_t *);
		efi_event_t wait_for_key;
	};
	struct {
		u32 reset;
		u32 read_keystroke;
		u32 wait_for_key;
	} mixed_mode;
};

union efi_simple_text_output_protocol {
	struct {
		void *reset;
		efi_status_t (*output_string)(efi_simple_text_output_protocol_t *, efi_char16_t *);
		void *test_string;
	};
	struct {
		u32 reset;
		u32 output_string;
		u32 test_string;
	} mixed_mode;
};

typedef u64 efi_physical_addr_t;

typedef void (*efi_event_notify_t)(efi_event_t, void *);

typedef enum {
	EfiTimerCancel = 0,
	EfiTimerPeriodic = 1,
	EfiTimerRelative = 2,
} EFI_TIMER_DELAY;

typedef void *efi_handle_t;

struct efi_generic_dev_path;

typedef struct efi_generic_dev_path efi_device_path_protocol_t;

union efi_boot_services {
	struct {
		efi_table_hdr_t hdr;
		void *raise_tpl;
		void *restore_tpl;
		efi_status_t (*allocate_pages)(int, int, unsigned long, efi_physical_addr_t *);
		efi_status_t (*free_pages)(efi_physical_addr_t, unsigned long);
		efi_status_t (*get_memory_map)(unsigned long *, void *, unsigned long *, unsigned long *, u32 *);
		efi_status_t (*allocate_pool)(int, unsigned long, void **);
		efi_status_t (*free_pool)(void *);
		efi_status_t (*create_event)(u32, unsigned long, efi_event_notify_t, void *, efi_event_t *);
		efi_status_t (*set_timer)(efi_event_t, EFI_TIMER_DELAY, u64);
		efi_status_t (*wait_for_event)(unsigned long, efi_event_t *, unsigned long *);
		void *signal_event;
		efi_status_t (*close_event)(efi_event_t);
		void *check_event;
		void *install_protocol_interface;
		void *reinstall_protocol_interface;
		void *uninstall_protocol_interface;
		efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
		void *__reserved;
		void *register_protocol_notify;
		efi_status_t (*locate_handle)(int, efi_guid_t *, void *, unsigned long *, efi_handle_t *);
		efi_status_t (*locate_device_path)(efi_guid_t *, efi_device_path_protocol_t **, efi_handle_t *);
		efi_status_t (*install_configuration_table)(efi_guid_t *, void *);
		efi_status_t (*load_image)(bool, efi_handle_t, efi_device_path_protocol_t *, void *, unsigned long, efi_handle_t *);
		efi_status_t (*start_image)(efi_handle_t, unsigned long *, efi_char16_t **);
		efi_status_t (*exit)(efi_handle_t, efi_status_t, unsigned long, efi_char16_t *);
		efi_status_t (*unload_image)(efi_handle_t);
		efi_status_t (*exit_boot_services)(efi_handle_t, unsigned long);
		void *get_next_monotonic_count;
		efi_status_t (*stall)(unsigned long);
		void *set_watchdog_timer;
		void *connect_controller;
		efi_status_t (*disconnect_controller)(efi_handle_t, efi_handle_t, efi_handle_t);
		void *open_protocol;
		void *close_protocol;
		void *open_protocol_information;
		void *protocols_per_handle;
		void *locate_handle_buffer;
		efi_status_t (*locate_protocol)(efi_guid_t *, void *, void **);
		efi_status_t (*install_multiple_protocol_interfaces)(efi_handle_t *, ...);
		efi_status_t (*uninstall_multiple_protocol_interfaces)(efi_handle_t, ...);
		void *calculate_crc32;
		void (*copy_mem)(void *, const void *, unsigned long);
		void (*set_mem)(void *, unsigned long, unsigned char);
		void *create_event_ex;
	};
	struct {
		efi_table_hdr_t hdr;
		u32 raise_tpl;
		u32 restore_tpl;
		u32 allocate_pages;
		u32 free_pages;
		u32 get_memory_map;
		u32 allocate_pool;
		u32 free_pool;
		u32 create_event;
		u32 set_timer;
		u32 wait_for_event;
		u32 signal_event;
		u32 close_event;
		u32 check_event;
		u32 install_protocol_interface;
		u32 reinstall_protocol_interface;
		u32 uninstall_protocol_interface;
		u32 handle_protocol;
		u32 __reserved;
		u32 register_protocol_notify;
		u32 locate_handle;
		u32 locate_device_path;
		u32 install_configuration_table;
		u32 load_image;
		u32 start_image;
		u32 exit;
		u32 unload_image;
		u32 exit_boot_services;
		u32 get_next_monotonic_count;
		u32 stall;
		u32 set_watchdog_timer;
		u32 connect_controller;
		u32 disconnect_controller;
		u32 open_protocol;
		u32 close_protocol;
		u32 open_protocol_information;
		u32 protocols_per_handle;
		u32 locate_handle_buffer;
		u32 locate_protocol;
		u32 install_multiple_protocol_interfaces;
		u32 uninstall_multiple_protocol_interfaces;
		u32 calculate_crc32;
		u32 copy_mem;
		u32 set_mem;
		u32 create_event_ex;
	} mixed_mode;
};

struct efi_generic_dev_path {
	u8 type;
	u8 sub_type;
	u16 length;
};

typedef union {
	struct {
		u32 revision;
		efi_handle_t parent_handle;
		efi_system_table_t *system_table;
		efi_handle_t device_handle;
		void *file_path;
		void *reserved;
		u32 load_options_size;
		void *load_options;
		void *image_base;
		__u64 image_size;
		unsigned int image_code_type;
		unsigned int image_data_type;
		efi_status_t (*unload)(efi_handle_t);
	};
	struct {
		u32 revision;
		u32 parent_handle;
		u32 system_table;
		u32 device_handle;
		u32 file_path;
		u32 reserved;
		u32 load_options_size;
		u32 load_options;
		u32 image_base;
		__u64 image_size;
		u32 image_code_type;
		u32 image_data_type;
		u32 unload;
	} mixed_mode;
} efi_loaded_image_t;

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

enum efi_secureboot_mode {
	efi_secureboot_mode_unset = 0,
	efi_secureboot_mode_unknown = 1,
	efi_secureboot_mode_disabled = 2,
	efi_secureboot_mode_enabled = 3,
};

struct efi_boot_memmap;

struct exit_boot_struct {
	struct efi_boot_memmap *boot_memmap;
	efi_memory_desc_t *runtime_map;
	int runtime_entry_count;
	void *new_fdt_addr;
};

struct efi_boot_memmap {
	unsigned long map_size;
	unsigned long desc_size;
	u32 desc_ver;
	unsigned long map_key;
	unsigned long buff_size;
	efi_memory_desc_t map[0];
};

typedef efi_status_t (*efi_exit_boot_map_processing)(struct efi_boot_memmap *, void *);

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef int (*initcall_t)();

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

typedef int initcall_entry_t;

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

struct trace_event_data_offsets_initcall_level {
	u32 level;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_initcall_finish {};

struct kvm_s390_adapter_int {
	u64 ind_addr;
	u64 summary_addr;
	u64 ind_offset;
	u32 summary_offset;
	u32 adapter_id;
};

struct kvm_hv_sint {
	u32 vcpu;
	u32 sint;
};

struct kvm_xen_evtchn {
	u32 port;
	u32 vcpu_id;
	int vcpu_idx;
	u32 priority;
};

struct kvm_kernel_irq_routing_entry {
	u32 gsi;
	u32 type;
	int (*set)(struct kvm_kernel_irq_routing_entry *, struct kvm *, int, int, bool);
	union {
		struct {
			unsigned int irqchip;
			unsigned int pin;
		} irqchip;
		struct {
			u32 address_lo;
			u32 address_hi;
			u32 data;
			u32 flags;
			u32 devid;
		} msi;
		struct kvm_s390_adapter_int adapter;
		struct kvm_hv_sint hv_sint;
		struct kvm_xen_evtchn xen_evtchn;
	};
	struct hlist_node link;
};

struct kvm_msi {
	__u32 address_lo;
	__u32 address_hi;
	__u32 data;
	__u32 flags;
	__u32 devid;
	__u8 pad[12];
};

struct its_vlpi_map {
	struct its_vm *vm;
	struct its_vpe *vpe;
	u32 vintid;
	u8 properties;
	bool db_enabled;
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_running;
	unsigned int h_nr_running;
	unsigned int idle_nr_running;
	unsigned int idle_h_nr_running;
	s64 avg_vruntime;
	u64 avg_load;
	u64 exec_clock;
	u64 min_vruntime;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
	struct {
		raw_spinlock_t lock;
		int nr;
		unsigned long load_avg;
		unsigned long util_avg;
		unsigned long runnable_avg;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	} removed;
	u64 last_update_tg_load_avg;
	unsigned long tg_load_avg_contrib;
	long propagate;
	long prop_runnable_sum;
	unsigned long h_load;
	u64 last_h_load_update;
	struct sched_entity *h_load_next;
	struct rq *rq;
	int on_list;
	struct list_head leaf_cfs_rq_list;
	struct task_group *tg;
	int idle;
	long: 64;
	long: 64;
	long: 64;
};

struct rt_prio_array {
	unsigned long bitmap[2];
	struct list_head queue[100];
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	int overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
	int rt_throttled;
	u64 rt_time;
	u64 rt_runtime;
	raw_spinlock_t rt_runtime_lock;
};

struct dl_rq {
	struct rb_root_cached root;
	unsigned int dl_nr_running;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	int overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 max_bw;
	u64 bw_ratio;
};

struct cpu_stop_done;

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	unsigned long caller;
	void *arg;
	struct cpu_stop_done *done;
};

struct root_domain;

struct sched_domain;

struct balance_callback;

struct cpuidle_state;

struct rq {
	raw_spinlock_t __lock;
	unsigned int nr_running;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
	unsigned int numa_migrate_on;
	unsigned long last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	u64 nr_switches;
	long: 64;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	struct list_head leaf_cfs_rq_list;
	struct list_head *tmp_alone_branch;
	unsigned int nr_uninterruptible;
	struct task_struct __attribute__((btf_type_tag("rcu"))) *curr;
	struct task_struct *idle;
	struct task_struct *stop;
	unsigned long next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	u64 clock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u64 clock_task;
	u64 clock_pelt;
	unsigned long lost_idle_time;
	u64 clock_pelt_idle;
	u64 clock_idle;
	atomic_t nr_iowait;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain __attribute__((btf_type_tag("rcu"))) *sd;
	unsigned long cpu_capacity;
	struct balance_callback *balance_callback;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	unsigned long misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	long: 64;
	long: 64;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	struct sched_avg avg_irq;
	struct sched_avg avg_thermal;
	u64 idle_stamp;
	u64 avg_idle;
	u64 max_idle_balance_cost;
	struct rcuwait hotplug_wait;
	u64 prev_irq_time;
	u64 prev_steal_time;
	unsigned long calc_load_update;
	long calc_load_active;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	ktime_t hrtick_time;
	struct cpuidle_state *idle_state;
	unsigned int nr_pinned;
	unsigned int push_busy;
	struct cpu_stop_work push_work;
	cpumask_var_t scratch_mask;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cfs_bandwidth {};

struct task_group {
	struct cgroup_subsys_state css;
	struct sched_entity **se;
	struct cfs_rq **cfs_rq;
	unsigned long shares;
	int idle;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t load_avg;
	struct callback_head rcu;
	struct list_head list;
	struct task_group *parent;
	struct list_head siblings;
	struct list_head children;
	struct autogroup *autogroup;
	struct cfs_bandwidth cfs_bandwidth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct autogroup {
	struct kref kref;
	struct task_group *tg;
	struct rw_semaphore lock;
	unsigned long id;
	int nice;
};

struct dl_bw {
	raw_spinlock_t lock;
	u64 bw;
	u64 total_bw;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[101];
	int *cpu_to_pri;
};

struct perf_domain;

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	int overload;
	int overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	u64 visit_gen;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	unsigned long max_cpu_capacity;
	struct perf_domain __attribute__((btf_type_tag("rcu"))) *pd;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct sched_group;

struct sched_domain_shared;

struct sched_domain {
	struct sched_domain __attribute__((btf_type_tag("rcu"))) *parent;
	struct sched_domain __attribute__((btf_type_tag("rcu"))) *child;
	struct sched_group *groups;
	unsigned long min_interval;
	unsigned long max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	unsigned int imb_numa_nr;
	int nohz_idle;
	int flags;
	int level;
	unsigned long last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	unsigned long last_decay_max_lb_cost;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	unsigned long span[0];
};

struct sched_group_capacity;

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	unsigned int cores;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	int flags;
	unsigned long cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	unsigned long capacity;
	unsigned long min_capacity;
	unsigned long max_capacity;
	unsigned long next_update;
	int imbalance;
	unsigned long cpumask[0];
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
	int nr_idle_scan;
};

struct balance_callback {
	struct balance_callback *next;
	void (*func)(struct rq *);
};

struct cpuidle_device;

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	s64 exit_latency_ns;
	s64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
};

struct cpuidle_state_usage {
	unsigned long long disable;
	unsigned long long usage;
	u64 time_ns;
	unsigned long long above;
	unsigned long long below;
	unsigned long long rejected;
	unsigned long long s2idle_usage;
	unsigned long long s2idle_time;
};

struct cpuidle_state_kobj;

struct cpuidle_driver_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

struct pin_cookie {};

struct rq_flags {
	unsigned long flags;
	struct pin_cookie cookie;
};

struct affinity_context {
	const struct cpumask *new_mask;
	struct cpumask *user_mask;
	unsigned int flags;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

enum numa_faults_stats {
	NUMA_MEM = 0,
	NUMA_CPU = 1,
	NUMA_MEMBUF = 2,
	NUMA_CPUBUF = 3,
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_ASYM_CPUCAPACITY_FULL = 64,
	SD_SHARE_CPUCAPACITY = 128,
	SD_CLUSTER = 256,
	SD_SHARE_PKG_RESOURCES = 512,
	SD_SERIALIZE = 1024,
	SD_ASYM_PACKING = 2048,
	SD_PREFER_SIBLING = 4096,
	SD_OVERLAP = 8192,
	SD_NUMA = 16384,
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum numa_topology_type {
	NUMA_DIRECT = 0,
	NUMA_GLUELESS_MESH = 1,
	NUMA_BACKPLANE = 2,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

enum numa_type {
	node_has_spare = 0,
	node_fully_busy = 1,
	node_overloaded = 2,
};

enum numa_vmaskip_reason {
	NUMAB_SKIP_UNSUITABLE = 0,
	NUMAB_SKIP_SHARED_RO = 1,
	NUMAB_SKIP_INACCESSIBLE = 2,
	NUMAB_SKIP_SCAN_DELAY = 3,
	NUMAB_SKIP_PID_INACTIVE = 4,
	NUMAB_SKIP_IGNORE_PID = 5,
	NUMAB_SKIP_SEQ_COMPLETED = 6,
};

enum uclamp_id {
	UCLAMP_MIN = 0,
	UCLAMP_MAX = 1,
	UCLAMP_CNT = 2,
};

enum cpu_idle_type {
	CPU_IDLE = 0,
	CPU_NOT_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_smt_balance = 3,
	group_asym_packing = 4,
	group_imbalanced = 5,
	group_overloaded = 6,
};

enum cpu_util_type {
	FREQUENCY_UTIL = 0,
	ENERGY_UTIL = 1,
};

struct maple_enode;

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

struct numa_stats {
	unsigned long load;
	unsigned long runnable;
	unsigned long util;
	unsigned long compute_capacity;
	unsigned int nr_running;
	unsigned int weight;
	enum numa_type node_type;
	int idle_cpu;
};

struct task_numa_env {
	struct task_struct *p;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	int imb_numa_nr;
	struct numa_stats src_stats;
	struct numa_stats dst_stats;
	int imbalance_pct;
	int dist;
	struct task_struct *best_task;
	long best_imp;
	int best_cpu;
};

struct maple_alloc;

struct ma_state {
	struct maple_tree *tree;
	unsigned long index;
	unsigned long last;
	struct maple_enode *node;
	unsigned long min;
	unsigned long max;
	struct maple_alloc *alloc;
	unsigned char depth;
	unsigned char offset;
	unsigned char mas_flags;
};

struct vma_iterator {
	struct ma_state mas;
};

struct maple_alloc {
	unsigned long total;
	unsigned char node_count;
	unsigned int request_count;
	struct maple_alloc *slot[30];
};

struct energy_env {
	unsigned long task_busy_time;
	unsigned long pd_busy_time;
	unsigned long cpu_cap;
	unsigned long pd_cap;
};

struct softirq_action {
	void (*action)(struct softirq_action *);
};

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
};

struct sg_lb_stats {
	unsigned long avg_load;
	unsigned long group_load;
	unsigned long group_capacity;
	unsigned long group_util;
	unsigned long group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	unsigned int group_smt_balance;
	unsigned long group_misfit_task_load;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	unsigned long total_load;
	unsigned long total_capacity;
	unsigned long avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

typedef int (*btf_kfunc_filter_t)(const struct bpf_prog *, u32);

struct btf_id_set8;

struct btf_kfunc_id_set {
	struct module *owner;
	struct btf_id_set8 *set;
	btf_kfunc_filter_t filter;
};

struct btf_id_set8 {
	u32 cnt;
	u32 flags;
	struct {
		u32 id;
		u32 flags;
	} pairs[0];
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter_seq_map_info {
	u32 map_id;
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_DATA_PAGE_SIZE = 4194304,
	PERF_SAMPLE_CODE_PAGE_SIZE = 8388608,
	PERF_SAMPLE_WEIGHT_STRUCT = 16777216,
	PERF_SAMPLE_MAX = 33554432,
};

enum perf_callchain_context {
	PERF_CONTEXT_HV = 18446744073709551584ULL,
	PERF_CONTEXT_KERNEL = 18446744073709551488ULL,
	PERF_CONTEXT_USER = 18446744073709551104ULL,
	PERF_CONTEXT_GUEST = 18446744073709549568ULL,
	PERF_CONTEXT_GUEST_KERNEL = 18446744073709549440ULL,
	PERF_CONTEXT_GUEST_USER = 18446744073709549056ULL,
	PERF_CONTEXT_MAX = 18446744073709547521ULL,
};

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

struct bpf_perf_event_data_kern;

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef struct user_pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

struct stack_map_bucket;

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
	long: 64;
	long: 64;
	long: 64;
};

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	u64 data[0];
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

struct mmap_unlock_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

typedef void (*btf_trace_rseq_update)(void *, struct task_struct *);

typedef void (*btf_trace_rseq_ip_fixup)(void *, unsigned long, unsigned long, unsigned long, unsigned long);

enum rseq_cs_flags {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 2,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 4,
};

enum rseq_flags {
	RSEQ_FLAG_UNREGISTER = 1,
};

enum rseq_cpu_id_state {
	RSEQ_CPU_ID_UNINITIALIZED = -1,
	RSEQ_CPU_ID_REGISTRATION_FAILED = -2,
};

struct trace_event_raw_rseq_update {
	struct trace_entry ent;
	s32 cpu_id;
	s32 node_id;
	s32 mm_cid;
	char __data[0];
};

struct trace_event_raw_rseq_ip_fixup {
	struct trace_entry ent;
	unsigned long regs_ip;
	unsigned long start_ip;
	unsigned long post_commit_offset;
	unsigned long abort_ip;
	char __data[0];
};

struct rseq_cs {
	__u32 version;
	__u32 flags;
	__u64 start_ip;
	__u64 post_commit_offset;
	__u64 abort_ip;
};

struct trace_event_data_offsets_rseq_update {};

struct trace_event_data_offsets_rseq_ip_fixup {};

struct mminit_pfnnid_cache {
	unsigned long last_start;
	unsigned long last_end;
	int last_nid;
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

enum {
	SECTION_MARKED_PRESENT_BIT = 0,
	SECTION_HAS_MEM_MAP_BIT = 1,
	SECTION_IS_ONLINE_BIT = 2,
	SECTION_IS_EARLY_BIT = 3,
	SECTION_MAP_LAST_BIT = 4,
};

struct mem_section_usage;

struct mem_section {
	unsigned long section_mem_map;
	struct mem_section_usage *usage;
};

struct mem_section_usage {
	unsigned long subsection_map[1];
	unsigned long pageblock_flags[0];
};

struct mlock_fbatch {
	local_lock_t lock;
	struct folio_batch fbatch;
};

enum rlimit_type {
	UCOUNT_RLIMIT_NPROC = 0,
	UCOUNT_RLIMIT_MSGQUEUE = 1,
	UCOUNT_RLIMIT_SIGPENDING = 2,
	UCOUNT_RLIMIT_MEMLOCK = 3,
	UCOUNT_RLIMIT_COUNTS = 4,
};

struct encoded_page;

typedef union {
	struct page **pages;
	struct folio **folios;
	struct encoded_page **encoded_pages;
} release_pages_arg;

struct anon_vma_name {
	struct kref kref;
	char name[0];
};

typedef unsigned int isolate_mode_t;

struct movable_operations {
	bool (*isolate_page)(struct page *, isolate_mode_t);
	int (*migrate_page)(struct page *, struct page *, enum migrate_mode);
	void (*putback_page)(struct page *);
};

struct balloon_dev_info {
	unsigned long isolated_pages;
	spinlock_t pages_lock;
	struct list_head pages;
	int (*migratepage)(struct balloon_dev_info *, struct page *, struct page *, enum migrate_mode);
};

struct linux_dirent {
	unsigned long d_ino;
	unsigned long d_off;
	unsigned short d_reclen;
	char d_name[0];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent __attribute__((btf_type_tag("user"))) *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	unsigned short d_reclen;
	unsigned char d_type;
	char d_name[0];
};

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 __attribute__((btf_type_tag("user"))) *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct compat_old_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_offset;
	unsigned short d_namlen;
	char d_name[0];
};

struct compat_readdir_callback {
	struct dir_context ctx;
	struct compat_old_linux_dirent __attribute__((btf_type_tag("user"))) *dirent;
	int result;
};

struct compat_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_off;
	unsigned short d_reclen;
	char d_name[0];
};

struct compat_getdents_callback {
	struct dir_context ctx;
	struct compat_linux_dirent __attribute__((btf_type_tag("user"))) *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct xattr_name {
	char name[256];
};

struct xattr_ctx {
	union {
		const void __attribute__((btf_type_tag("user"))) *cvalue;
		void __attribute__((btf_type_tag("user"))) *value;
	};
	void *kvalue;
	size_t size;
	struct xattr_name *kname;
	unsigned int flags;
};

struct iomap_folio_ops;

struct iomap {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_folio_ops *folio_ops;
	u64 validity_cookie;
};

struct iomap_iter {
	struct inode *inode;
	loff_t pos;
	u64 len;
	s64 processed;
	unsigned int flags;
	struct iomap iomap;
	struct iomap srcmap;
	void *private;
};

struct iomap_folio_ops {
	struct folio * (*get_folio)(struct iomap_iter *, loff_t, unsigned int);
	void (*put_folio)(struct inode *, loff_t, unsigned int, struct folio *);
	bool (*iomap_valid)(struct inode *, const struct iomap *);
};

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap *, struct iomap *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap *);
};

typedef int (*proc_write_t)(struct file *, char *, size_t);

typedef u32 nlink_t;

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
};

enum netfs_read_from_hole {
	NETFS_READ_HOLE_IGNORE = 0,
	NETFS_READ_HOLE_CLEAR = 1,
	NETFS_READ_HOLE_FAIL = 2,
};

enum netfs_io_source {
	NETFS_FILL_WITH_ZEROES = 0,
	NETFS_DOWNLOAD_FROM_SERVER = 1,
	NETFS_READ_FROM_CACHE = 2,
	NETFS_INVALID_READ = 3,
} __attribute__((mode(byte)));

enum netfs_io_origin {
	NETFS_READAHEAD = 0,
	NETFS_READPAGE = 1,
	NETFS_READ_FOR_WRITE = 2,
} __attribute__((mode(byte)));

enum netfs_failure {
	netfs_fail_check_write_begin = 0,
	netfs_fail_copy_to_cache = 1,
	netfs_fail_read = 2,
	netfs_fail_short_read = 3,
	netfs_fail_prepare_write = 4,
} __attribute__((mode(byte)));

enum netfs_sreq_trace {
	netfs_sreq_trace_download_instead = 0,
	netfs_sreq_trace_free = 1,
	netfs_sreq_trace_prepare = 2,
	netfs_sreq_trace_resubmit_short = 3,
	netfs_sreq_trace_submit = 4,
	netfs_sreq_trace_terminated = 5,
	netfs_sreq_trace_write = 6,
	netfs_sreq_trace_write_skip = 7,
	netfs_sreq_trace_write_term = 8,
} __attribute__((mode(byte)));

enum netfs_sreq_ref_trace {
	netfs_sreq_trace_get_copy_to_cache = 0,
	netfs_sreq_trace_get_resubmit = 1,
	netfs_sreq_trace_get_short_read = 2,
	netfs_sreq_trace_new = 3,
	netfs_sreq_trace_put_clear = 4,
	netfs_sreq_trace_put_failed = 5,
	netfs_sreq_trace_put_merged = 6,
	netfs_sreq_trace_put_no_copy = 7,
	netfs_sreq_trace_put_terminated = 8,
} __attribute__((mode(byte)));

enum netfs_rreq_ref_trace {
	netfs_rreq_trace_get_hold = 0,
	netfs_rreq_trace_get_subreq = 1,
	netfs_rreq_trace_put_complete = 2,
	netfs_rreq_trace_put_discard = 3,
	netfs_rreq_trace_put_failed = 4,
	netfs_rreq_trace_put_hold = 5,
	netfs_rreq_trace_put_subreq = 6,
	netfs_rreq_trace_put_zero_len = 7,
	netfs_rreq_trace_new = 8,
} __attribute__((mode(byte)));

enum netfs_rreq_trace {
	netfs_rreq_trace_assess = 0,
	netfs_rreq_trace_copy = 1,
	netfs_rreq_trace_done = 2,
	netfs_rreq_trace_free = 3,
	netfs_rreq_trace_resubmit = 4,
	netfs_rreq_trace_unlock = 5,
	netfs_rreq_trace_unmark = 6,
} __attribute__((mode(byte)));

struct netfs_cache_ops;

struct netfs_cache_resources {
	const struct netfs_cache_ops *ops;
	void *cache_priv;
	void *cache_priv2;
	unsigned int debug_id;
	unsigned int inval_counter;
};

struct netfs_request_ops;

struct netfs_io_request {
	struct work_struct work;
	struct inode *inode;
	struct address_space *mapping;
	struct netfs_cache_resources cache_resources;
	struct list_head subrequests;
	void *netfs_priv;
	unsigned int debug_id;
	atomic_t nr_outstanding;
	atomic_t nr_copy_ops;
	size_t submitted;
	size_t len;
	short error;
	enum netfs_io_origin origin;
	loff_t i_size;
	loff_t start;
	unsigned long no_unlock_folio;
	refcount_t ref;
	unsigned long flags;
	const struct netfs_request_ops *netfs_ops;
};

typedef void (*netfs_io_terminated_t)(void *, ssize_t, bool);

struct netfs_io_subrequest;

struct netfs_cache_ops {
	void (*end_operation)(struct netfs_cache_resources *);
	int (*read)(struct netfs_cache_resources *, loff_t, struct iov_iter *, enum netfs_read_from_hole, netfs_io_terminated_t, void *);
	int (*write)(struct netfs_cache_resources *, loff_t, struct iov_iter *, netfs_io_terminated_t, void *);
	void (*expand_readahead)(struct netfs_cache_resources *, loff_t *, size_t *, loff_t);
	enum netfs_io_source (*prepare_read)(struct netfs_io_subrequest *, loff_t);
	int (*prepare_write)(struct netfs_cache_resources *, loff_t *, size_t *, loff_t, bool);
	enum netfs_io_source (*prepare_ondemand_read)(struct netfs_cache_resources *, loff_t, size_t *, loff_t, unsigned long *, ino_t);
	int (*query_occupancy)(struct netfs_cache_resources *, loff_t, size_t, size_t, loff_t *, size_t *);
};

struct netfs_io_subrequest {
	struct netfs_io_request *rreq;
	struct list_head rreq_link;
	loff_t start;
	size_t len;
	size_t transferred;
	refcount_t ref;
	short error;
	unsigned short debug_index;
	enum netfs_io_source source;
	unsigned long flags;
};

struct netfs_request_ops {
	int (*init_request)(struct netfs_io_request *, struct file *);
	void (*free_request)(struct netfs_io_request *);
	int (*begin_cache_operation)(struct netfs_io_request *);
	void (*expand_readahead)(struct netfs_io_request *);
	bool (*clamp_length)(struct netfs_io_subrequest *);
	void (*issue_read)(struct netfs_io_subrequest *);
	bool (*is_still_valid)(struct netfs_io_request *);
	int (*check_write_begin)(struct file *, loff_t, unsigned int, struct folio **, void **);
	void (*done)(struct netfs_io_request *);
};

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node __attribute__((btf_type_tag("rcu"))) *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void __attribute__((btf_type_tag("rcu"))) *slots[64];
	union {
		unsigned long tags[3];
		unsigned long marks[3];
	};
};

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	unsigned long xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
	struct list_lru *xa_lru;
};

enum {
	EXT4_STATE_NEW = 0,
	EXT4_STATE_XATTR = 1,
	EXT4_STATE_NO_EXPAND = 2,
	EXT4_STATE_DA_ALLOC_CLOSE = 3,
	EXT4_STATE_EXT_MIGRATE = 4,
	EXT4_STATE_NEWENTRY = 5,
	EXT4_STATE_MAY_INLINE_DATA = 6,
	EXT4_STATE_EXT_PRECACHED = 7,
	EXT4_STATE_LUSTRE_EA_INODE = 8,
	EXT4_STATE_VERITY_IN_PROGRESS = 9,
	EXT4_STATE_FC_COMMITTING = 10,
	EXT4_STATE_ORPHAN_FILE = 11,
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct rsvd_count {
	int ndelonly;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

enum {
	EXT4_FC_STATUS_OK = 0,
	EXT4_FC_STATUS_INELIGIBLE = 1,
	EXT4_FC_STATUS_SKIPPED = 2,
	EXT4_FC_STATUS_FAILED = 3,
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	struct qstr fcd_name;
	unsigned char fcd_iname[32];
	struct list_head fcd_list;
	struct list_head fcd_dilist;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

struct ext4_fc_tl_mem {
	u16 fc_tag;
	u16 fc_len;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_extent_idx;

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	__u8 fc_dname[0];
};

struct ext4_iloc {
	struct buffer_head *bh;
	unsigned long offset;
	ext4_group_t block_group;
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct squashfs_sb_info;

struct squashfs_page_actor;

struct squashfs_decompressor {
	void * (*init)(struct squashfs_sb_info *, void *);
	void * (*comp_opts)(struct squashfs_sb_info *, void *, int);
	void (*free)(void *);
	int (*decompress)(struct squashfs_sb_info *, void *, struct bio *, int, int, struct squashfs_page_actor *);
	int id;
	char *name;
	int alloc_buffer;
	int supported;
};

struct squashfs_cache;

struct meta_index;

struct squashfs_decompressor_thread_ops;

struct squashfs_sb_info {
	const struct squashfs_decompressor *decompressor;
	int devblksize;
	int devblksize_log2;
	struct squashfs_cache *block_cache;
	struct squashfs_cache *fragment_cache;
	struct squashfs_cache *read_page;
	struct address_space *cache_mapping;
	int next_meta_index;
	__le64 *id_table;
	__le64 *fragment_index;
	__le64 *xattr_id_table;
	struct mutex meta_index_mutex;
	struct meta_index *meta_index;
	void *stream;
	__le64 *inode_lookup_table;
	u64 inode_table;
	u64 directory_table;
	u64 xattr_table;
	unsigned int block_size;
	unsigned short block_log;
	long long bytes_used;
	unsigned int inodes;
	unsigned int fragments;
	unsigned int xattr_ids;
	unsigned int ids;
	bool panic_on_errors;
	const struct squashfs_decompressor_thread_ops *thread_ops;
	int max_thread_num;
};

struct squashfs_cache_entry;

struct squashfs_cache {
	char *name;
	int entries;
	int curr_blk;
	int next_blk;
	int num_waiters;
	int unused;
	int block_size;
	int pages;
	spinlock_t lock;
	wait_queue_head_t wait_queue;
	struct squashfs_cache_entry *entry;
};

struct squashfs_cache_entry {
	u64 block;
	int length;
	int refcount;
	u64 next_index;
	int pending;
	int error;
	int num_waiters;
	wait_queue_head_t wait_queue;
	struct squashfs_cache *cache;
	void **data;
	struct squashfs_page_actor *actor;
};

struct squashfs_page_actor {
	union {
		void **buffer;
		struct page **page;
	};
	void *pageaddr;
	void *tmp_buffer;
	void * (*squashfs_first_page)(struct squashfs_page_actor *);
	void * (*squashfs_next_page)(struct squashfs_page_actor *);
	void (*squashfs_finish_page)(struct squashfs_page_actor *);
	struct page *last_page;
	int pages;
	int length;
	int next_page;
	int alloc_buffer;
	int returned_pages;
	unsigned long next_index;
};

struct meta_entry {
	u64 data_block;
	unsigned int index_block;
	unsigned short offset;
	unsigned short pad;
};

struct meta_index {
	unsigned int inode_number;
	unsigned int offset;
	unsigned short entries;
	unsigned short skip;
	unsigned short locked;
	unsigned short pad;
	struct meta_entry meta_entry[127];
};

struct squashfs_decompressor_thread_ops {
	void * (*create)(struct squashfs_sb_info *, void *);
	void (*destroy)(struct squashfs_sb_info *);
	int (*decompress)(struct squashfs_sb_info *, struct bio *, int, int, struct squashfs_page_actor *);
	int (*max_decompressors)();
};

struct rpc_iostats {
	spinlock_t om_lock;
	unsigned long om_ops;
	unsigned long om_ntrans;
	unsigned long om_timeouts;
	unsigned long long om_bytes_sent;
	unsigned long long om_bytes_recv;
	ktime_t om_queue;
	ktime_t om_rtt;
	ktime_t om_execute;
	unsigned long om_error_status;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nfs_subversion {
	struct module *owner;
	struct file_system_type *nfs_fs;
	const struct rpc_version *rpc_vers;
	const struct nfs_rpc_ops *rpc_ops;
	const struct super_operations *sops;
	const struct xattr_handler * const *xattr;
	struct list_head list;
};

enum nfs_stat_eventcounters {
	NFSIOS_INODEREVALIDATE = 0,
	NFSIOS_DENTRYREVALIDATE = 1,
	NFSIOS_DATAINVALIDATE = 2,
	NFSIOS_ATTRINVALIDATE = 3,
	NFSIOS_VFSOPEN = 4,
	NFSIOS_VFSLOOKUP = 5,
	NFSIOS_VFSACCESS = 6,
	NFSIOS_VFSUPDATEPAGE = 7,
	NFSIOS_VFSREADPAGE = 8,
	NFSIOS_VFSREADPAGES = 9,
	NFSIOS_VFSWRITEPAGE = 10,
	NFSIOS_VFSWRITEPAGES = 11,
	NFSIOS_VFSGETDENTS = 12,
	NFSIOS_VFSSETATTR = 13,
	NFSIOS_VFSFLUSH = 14,
	NFSIOS_VFSFSYNC = 15,
	NFSIOS_VFSLOCK = 16,
	NFSIOS_VFSRELEASE = 17,
	NFSIOS_CONGESTIONWAIT = 18,
	NFSIOS_SETATTRTRUNC = 19,
	NFSIOS_EXTENDWRITE = 20,
	NFSIOS_SILLYRENAME = 21,
	NFSIOS_SHORTREAD = 22,
	NFSIOS_SHORTWRITE = 23,
	NFSIOS_DELAY = 24,
	NFSIOS_PNFS_READ = 25,
	NFSIOS_PNFS_WRITE = 26,
	__NFSIOS_COUNTSMAX = 27,
};

typedef int wait_bit_action_f(struct wait_bit_key *, int);

struct nfs_find_desc {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_referral_count {
	struct list_head list;
	const struct task_struct *task;
	unsigned int referral_count;
};

struct nfs_clone_mount {
	struct super_block *sb;
	struct dentry *dentry;
	struct nfs_fattr *fattr;
	unsigned int inherited_bsize;
};

struct nfs_fs_context {
	bool internal;
	bool skip_reconfig_option_check;
	bool need_mount;
	bool sloppy;
	unsigned int flags;
	unsigned int rsize;
	unsigned int wsize;
	unsigned int timeo;
	unsigned int retrans;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namlen;
	unsigned int options;
	unsigned int bsize;
	struct nfs_auth_info auth_info;
	rpc_authflavor_t selected_flavor;
	struct xprtsec_parms xprtsec;
	char *client_address;
	unsigned int version;
	unsigned int minorversion;
	char *fscache_uniq;
	unsigned short protofamily;
	unsigned short mountfamily;
	bool has_sec_mnt_opts;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		u32 version;
		int port;
		unsigned short protocol;
	} mount_server;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		char *export_path;
		int port;
		unsigned short protocol;
		unsigned short nconnect;
		unsigned short max_connect;
		unsigned short export_path_len;
	} nfs_server;
	struct nfs_fh *mntfh;
	struct nfs_server *server;
	struct nfs_subversion *nfs_mod;
	struct nfs_clone_mount clone_data;
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum {
	NFS_LSEG_VALID = 0,
	NFS_LSEG_ROC = 1,
	NFS_LSEG_LAYOUTCOMMIT = 2,
	NFS_LSEG_LAYOUTRETURN = 3,
	NFS_LSEG_UNAVAILABLE = 4,
};

enum nfsstat4 {
	NFS4_OK = 0,
	NFS4ERR_PERM = 1,
	NFS4ERR_NOENT = 2,
	NFS4ERR_IO = 5,
	NFS4ERR_NXIO = 6,
	NFS4ERR_ACCESS = 13,
	NFS4ERR_EXIST = 17,
	NFS4ERR_XDEV = 18,
	NFS4ERR_NOTDIR = 20,
	NFS4ERR_ISDIR = 21,
	NFS4ERR_INVAL = 22,
	NFS4ERR_FBIG = 27,
	NFS4ERR_NOSPC = 28,
	NFS4ERR_ROFS = 30,
	NFS4ERR_MLINK = 31,
	NFS4ERR_NAMETOOLONG = 63,
	NFS4ERR_NOTEMPTY = 66,
	NFS4ERR_DQUOT = 69,
	NFS4ERR_STALE = 70,
	NFS4ERR_BADHANDLE = 10001,
	NFS4ERR_BAD_COOKIE = 10003,
	NFS4ERR_NOTSUPP = 10004,
	NFS4ERR_TOOSMALL = 10005,
	NFS4ERR_SERVERFAULT = 10006,
	NFS4ERR_BADTYPE = 10007,
	NFS4ERR_DELAY = 10008,
	NFS4ERR_SAME = 10009,
	NFS4ERR_DENIED = 10010,
	NFS4ERR_EXPIRED = 10011,
	NFS4ERR_LOCKED = 10012,
	NFS4ERR_GRACE = 10013,
	NFS4ERR_FHEXPIRED = 10014,
	NFS4ERR_SHARE_DENIED = 10015,
	NFS4ERR_WRONGSEC = 10016,
	NFS4ERR_CLID_INUSE = 10017,
	NFS4ERR_RESOURCE = 10018,
	NFS4ERR_MOVED = 10019,
	NFS4ERR_NOFILEHANDLE = 10020,
	NFS4ERR_MINOR_VERS_MISMATCH = 10021,
	NFS4ERR_STALE_CLIENTID = 10022,
	NFS4ERR_STALE_STATEID = 10023,
	NFS4ERR_OLD_STATEID = 10024,
	NFS4ERR_BAD_STATEID = 10025,
	NFS4ERR_BAD_SEQID = 10026,
	NFS4ERR_NOT_SAME = 10027,
	NFS4ERR_LOCK_RANGE = 10028,
	NFS4ERR_SYMLINK = 10029,
	NFS4ERR_RESTOREFH = 10030,
	NFS4ERR_LEASE_MOVED = 10031,
	NFS4ERR_ATTRNOTSUPP = 10032,
	NFS4ERR_NO_GRACE = 10033,
	NFS4ERR_RECLAIM_BAD = 10034,
	NFS4ERR_RECLAIM_CONFLICT = 10035,
	NFS4ERR_BADXDR = 10036,
	NFS4ERR_LOCKS_HELD = 10037,
	NFS4ERR_OPENMODE = 10038,
	NFS4ERR_BADOWNER = 10039,
	NFS4ERR_BADCHAR = 10040,
	NFS4ERR_BADNAME = 10041,
	NFS4ERR_BAD_RANGE = 10042,
	NFS4ERR_LOCK_NOTSUPP = 10043,
	NFS4ERR_OP_ILLEGAL = 10044,
	NFS4ERR_DEADLOCK = 10045,
	NFS4ERR_FILE_OPEN = 10046,
	NFS4ERR_ADMIN_REVOKED = 10047,
	NFS4ERR_CB_PATH_DOWN = 10048,
	NFS4ERR_BADIOMODE = 10049,
	NFS4ERR_BADLAYOUT = 10050,
	NFS4ERR_BAD_SESSION_DIGEST = 10051,
	NFS4ERR_BADSESSION = 10052,
	NFS4ERR_BADSLOT = 10053,
	NFS4ERR_COMPLETE_ALREADY = 10054,
	NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055,
	NFS4ERR_DELEG_ALREADY_WANTED = 10056,
	NFS4ERR_BACK_CHAN_BUSY = 10057,
	NFS4ERR_LAYOUTTRYLATER = 10058,
	NFS4ERR_LAYOUTUNAVAILABLE = 10059,
	NFS4ERR_NOMATCHING_LAYOUT = 10060,
	NFS4ERR_RECALLCONFLICT = 10061,
	NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062,
	NFS4ERR_SEQ_MISORDERED = 10063,
	NFS4ERR_SEQUENCE_POS = 10064,
	NFS4ERR_REQ_TOO_BIG = 10065,
	NFS4ERR_REP_TOO_BIG = 10066,
	NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067,
	NFS4ERR_RETRY_UNCACHED_REP = 10068,
	NFS4ERR_UNSAFE_COMPOUND = 10069,
	NFS4ERR_TOO_MANY_OPS = 10070,
	NFS4ERR_OP_NOT_IN_SESSION = 10071,
	NFS4ERR_HASH_ALG_UNSUPP = 10072,
	NFS4ERR_CLIENTID_BUSY = 10074,
	NFS4ERR_PNFS_IO_HOLE = 10075,
	NFS4ERR_SEQ_FALSE_RETRY = 10076,
	NFS4ERR_BAD_HIGH_SLOT = 10077,
	NFS4ERR_DEADSESSION = 10078,
	NFS4ERR_ENCR_ALG_UNSUPP = 10079,
	NFS4ERR_PNFS_NO_LAYOUT = 10080,
	NFS4ERR_NOT_ONLY_OP = 10081,
	NFS4ERR_WRONG_CRED = 10082,
	NFS4ERR_WRONG_TYPE = 10083,
	NFS4ERR_DIRDELEG_UNAVAIL = 10084,
	NFS4ERR_REJECT_DELEG = 10085,
	NFS4ERR_RETURNCONFLICT = 10086,
	NFS4ERR_DELEG_REVOKED = 10087,
	NFS4ERR_PARTNER_NOTSUPP = 10088,
	NFS4ERR_PARTNER_NO_AUTH = 10089,
	NFS4ERR_UNION_NOTSUPP = 10090,
	NFS4ERR_OFFLOAD_DENIED = 10091,
	NFS4ERR_WRONG_LFS = 10092,
	NFS4ERR_BADLABEL = 10093,
	NFS4ERR_OFFLOAD_NO_REQS = 10094,
	NFS4ERR_NOXATTR = 10095,
	NFS4ERR_XATTR2BIG = 10096,
};

enum {
	NFS_IOHDR_ERROR = 0,
	NFS_IOHDR_EOF = 1,
	NFS_IOHDR_REDO = 2,
	NFS_IOHDR_STAT = 3,
	NFS_IOHDR_RESEND_PNFS = 4,
	NFS_IOHDR_RESEND_MDS = 5,
	NFS_IOHDR_UNSTABLE_WRITES = 6,
};

enum {
	NFSPROC4_CLNT_NULL = 0,
	NFSPROC4_CLNT_READ = 1,
	NFSPROC4_CLNT_WRITE = 2,
	NFSPROC4_CLNT_COMMIT = 3,
	NFSPROC4_CLNT_OPEN = 4,
	NFSPROC4_CLNT_OPEN_CONFIRM = 5,
	NFSPROC4_CLNT_OPEN_NOATTR = 6,
	NFSPROC4_CLNT_OPEN_DOWNGRADE = 7,
	NFSPROC4_CLNT_CLOSE = 8,
	NFSPROC4_CLNT_SETATTR = 9,
	NFSPROC4_CLNT_FSINFO = 10,
	NFSPROC4_CLNT_RENEW = 11,
	NFSPROC4_CLNT_SETCLIENTID = 12,
	NFSPROC4_CLNT_SETCLIENTID_CONFIRM = 13,
	NFSPROC4_CLNT_LOCK = 14,
	NFSPROC4_CLNT_LOCKT = 15,
	NFSPROC4_CLNT_LOCKU = 16,
	NFSPROC4_CLNT_ACCESS = 17,
	NFSPROC4_CLNT_GETATTR = 18,
	NFSPROC4_CLNT_LOOKUP = 19,
	NFSPROC4_CLNT_LOOKUP_ROOT = 20,
	NFSPROC4_CLNT_REMOVE = 21,
	NFSPROC4_CLNT_RENAME = 22,
	NFSPROC4_CLNT_LINK = 23,
	NFSPROC4_CLNT_SYMLINK = 24,
	NFSPROC4_CLNT_CREATE = 25,
	NFSPROC4_CLNT_PATHCONF = 26,
	NFSPROC4_CLNT_STATFS = 27,
	NFSPROC4_CLNT_READLINK = 28,
	NFSPROC4_CLNT_READDIR = 29,
	NFSPROC4_CLNT_SERVER_CAPS = 30,
	NFSPROC4_CLNT_DELEGRETURN = 31,
	NFSPROC4_CLNT_GETACL = 32,
	NFSPROC4_CLNT_SETACL = 33,
	NFSPROC4_CLNT_FS_LOCATIONS = 34,
	NFSPROC4_CLNT_RELEASE_LOCKOWNER = 35,
	NFSPROC4_CLNT_SECINFO = 36,
	NFSPROC4_CLNT_FSID_PRESENT = 37,
	NFSPROC4_CLNT_EXCHANGE_ID = 38,
	NFSPROC4_CLNT_CREATE_SESSION = 39,
	NFSPROC4_CLNT_DESTROY_SESSION = 40,
	NFSPROC4_CLNT_SEQUENCE = 41,
	NFSPROC4_CLNT_GET_LEASE_TIME = 42,
	NFSPROC4_CLNT_RECLAIM_COMPLETE = 43,
	NFSPROC4_CLNT_LAYOUTGET = 44,
	NFSPROC4_CLNT_GETDEVICEINFO = 45,
	NFSPROC4_CLNT_LAYOUTCOMMIT = 46,
	NFSPROC4_CLNT_LAYOUTRETURN = 47,
	NFSPROC4_CLNT_SECINFO_NO_NAME = 48,
	NFSPROC4_CLNT_TEST_STATEID = 49,
	NFSPROC4_CLNT_FREE_STATEID = 50,
	NFSPROC4_CLNT_GETDEVICELIST = 51,
	NFSPROC4_CLNT_BIND_CONN_TO_SESSION = 52,
	NFSPROC4_CLNT_DESTROY_CLIENTID = 53,
	NFSPROC4_CLNT_SEEK = 54,
	NFSPROC4_CLNT_ALLOCATE = 55,
	NFSPROC4_CLNT_DEALLOCATE = 56,
	NFSPROC4_CLNT_LAYOUTSTATS = 57,
	NFSPROC4_CLNT_CLONE = 58,
	NFSPROC4_CLNT_COPY = 59,
	NFSPROC4_CLNT_OFFLOAD_CANCEL = 60,
	NFSPROC4_CLNT_LOOKUPP = 61,
	NFSPROC4_CLNT_LAYOUTERROR = 62,
	NFSPROC4_CLNT_COPY_NOTIFY = 63,
	NFSPROC4_CLNT_GETXATTR = 64,
	NFSPROC4_CLNT_SETXATTR = 65,
	NFSPROC4_CLNT_LISTXATTRS = 66,
	NFSPROC4_CLNT_REMOVEXATTR = 67,
	NFSPROC4_CLNT_READ_PLUS = 68,
};

enum nfs4_ff_op_type {
	NFS4_FF_OP_LAYOUTSTATS = 0,
	NFS4_FF_OP_LAYOUTRETURN = 1,
};

enum pnfs_layouttype {
	LAYOUT_NFSV4_1_FILES = 1,
	LAYOUT_OSD2_OBJECTS = 2,
	LAYOUT_BLOCK_VOLUME = 3,
	LAYOUT_FLEX_FILES = 4,
	LAYOUT_SCSI = 5,
	LAYOUT_TYPE_MAX = 6,
};

struct nfs4_ff_layout_ds_err {
	struct list_head list;
	u64 offset;
	u64 length;
	int status;
	enum nfs_opnum4 opnum;
	nfs4_stateid stateid;
	struct nfs4_deviceid deviceid;
};

struct nfs4_ff_layout_mirror;

struct nfs4_ff_layout_segment {
	struct pnfs_layout_segment generic_hdr;
	u64 stripe_unit;
	u32 flags;
	u32 mirror_array_cnt;
	struct nfs4_ff_layout_mirror *mirror_array[0];
};

struct nfs4_ff_io_stat {
	__u64 ops_requested;
	__u64 bytes_requested;
	__u64 ops_completed;
	__u64 bytes_completed;
	__u64 bytes_not_delivered;
	ktime_t total_busy_time;
	ktime_t aggregate_completion_time;
};

struct nfs4_ff_busy_timer {
	ktime_t start_time;
	atomic_t n_ops;
};

struct nfs4_ff_layoutstat {
	struct nfs4_ff_io_stat io_stat;
	struct nfs4_ff_busy_timer busy_timer;
};

struct nfs4_ff_layout_ds;

struct nfs4_ff_layout_mirror {
	struct pnfs_layout_hdr *layout;
	struct list_head mirrors;
	u32 ds_count;
	u32 efficiency;
	struct nfs4_deviceid devid;
	struct nfs4_ff_layout_ds *mirror_ds;
	u32 fh_versions_cnt;
	struct nfs_fh *fh_versions;
	nfs4_stateid stateid;
	const struct cred __attribute__((btf_type_tag("rcu"))) *ro_cred;
	const struct cred __attribute__((btf_type_tag("rcu"))) *rw_cred;
	refcount_t ref;
	spinlock_t lock;
	unsigned long flags;
	struct nfs4_ff_layoutstat read_stat;
	struct nfs4_ff_layoutstat write_stat;
	ktime_t start_time;
	u32 report_interval;
};

struct nfs4_ff_ds_version;

struct nfs4_pnfs_ds;

struct nfs4_ff_layout_ds {
	struct nfs4_deviceid_node id_node;
	u32 ds_versions_cnt;
	struct nfs4_ff_ds_version *ds_versions;
	struct nfs4_pnfs_ds *ds;
};

struct nfs4_ff_ds_version {
	u32 version;
	u32 minor_version;
	u32 rsize;
	u32 wsize;
	bool tightly_coupled;
};

struct nfs4_pnfs_ds {
	struct list_head ds_node;
	char *ds_remotestr;
	struct list_head ds_addrs;
	struct nfs_client *ds_clp;
	refcount_t ds_count;
	unsigned long ds_state;
};

struct nfs4_flexfile_layout {
	struct pnfs_layout_hdr generic_hdr;
	struct pnfs_ds_commit_info commit_info;
	struct list_head mirrors;
	struct list_head error_list;
	ktime_t last_report_time;
};

struct nfs4_pnfs_ds_addr {
	struct __kernel_sockaddr_storage da_addr;
	size_t da_addrlen;
	struct list_head da_node;
	char *da_remotestr;
	const char *da_netid;
	int da_transport;
};

struct nfs42_device_error {
	struct nfs4_deviceid dev_id;
	int status;
	enum nfs_opnum4 opnum;
};

struct nfs42_layout_error {
	__u64 offset;
	__u64 length;
	nfs4_stateid stateid;
	struct nfs42_device_error errors[1];
};

struct pnfs_commit_bucket {
	struct list_head written;
	struct list_head committing;
	struct pnfs_layout_segment *lseg;
	struct nfs_writeverf direct_verf;
};

struct pnfs_commit_array {
	struct list_head cinfo_list;
	struct list_head lseg_list;
	struct pnfs_layout_segment *lseg;
	struct callback_head rcu;
	refcount_t refcount;
	unsigned int nbuckets;
	struct pnfs_commit_bucket buckets[0];
};

struct nfs4_flexfile_layoutreturn_args {
	struct list_head errors;
	struct nfs42_layoutstat_devinfo devinfo[4];
	unsigned int num_errors;
	unsigned int num_dev;
	struct page *pages[1];
};

enum {
	TRACEFS_EVENT_INODE = 2,
	TRACEFS_EVENT_TOP_INODE = 4,
};

enum {
	EVENTFS_SAVE_MODE = 65536,
	EVENTFS_SAVE_UID = 131072,
	EVENTFS_SAVE_GID = 262144,
};

struct eventfs_attr {
	int mode;
	kuid_t uid;
	kgid_t gid;
};

struct eventfs_entry;

struct eventfs_inode {
	struct list_head list;
	const struct eventfs_entry *entries;
	const char *name;
	struct list_head children;
	struct dentry *dentry;
	struct dentry *d_parent;
	struct dentry **d_children;
	struct eventfs_attr *entry_attrs;
	struct eventfs_attr attr;
	void *data;
	union {
		struct llist_node llist;
		struct callback_head rcu;
	};
	unsigned int is_freed: 1;
	unsigned int is_events: 1;
	unsigned int nr_entries: 30;
};

typedef int (*eventfs_callback)(const char *, umode_t *, void **, const struct file_operations **);

struct eventfs_entry {
	const char *name;
	eventfs_callback callback;
};

struct tracefs_inode {
	unsigned long flags;
	void *private;
	struct inode vfs_inode;
};

struct dentry_list {
	void *cursor;
	struct dentry **dentries;
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct posix_msg_tree_node;

struct mqueue_inode_info {
	spinlock_t lock;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct ucounts *ucounts;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	unsigned long qsize;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct compat_mq_attr {
	compat_long_t mq_flags;
	compat_long_t mq_maxmsg;
	compat_long_t mq_msgsize;
	compat_long_t mq_curmsgs;
	compat_long_t __reserved[4];
};

typedef s32 compat_int_t;

union compat_sigval {
	compat_int_t sival_int;
	compat_uptr_t sival_ptr;
};

typedef union compat_sigval compat_sigval_t;

struct compat_sigevent {
	compat_sigval_t sigev_value;
	compat_int_t sigev_signo;
	compat_int_t sigev_notify;
	union {
		compat_int_t _pad[13];
		compat_int_t _tid;
		struct {
			compat_uptr_t _function;
			compat_uptr_t _attribute;
		} _sigev_thread;
	} _sigev_un;
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
	bool newns;
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	struct crypto_alg base;
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	int (*clone_tfm)(struct crypto_shash *, struct crypto_shash *);
	unsigned int descsize;
	union {
		struct {
			unsigned int digestsize;
			unsigned int statesize;
			struct crypto_alg base;
		};
		struct hash_alg_common halg;
	};
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	union {
		struct {
			char head[104];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct hmac_ctx {
	struct crypto_shash *hash;
	u8 pads[0];
};

struct elevator_type;

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	unsigned long flags;
	struct hlist_head hash[64];
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

typedef unsigned int blk_insert_t;

struct blk_mq_alloc_data;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(blk_opf_t, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, blk_insert_t);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elv_fs_entry;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	const unsigned int elevator_features;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx __attribute__((btf_type_tag("percpu"))) *queue_ctx;
};

typedef __u32 blk_mq_req_flags_t;

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	blk_opf_t cmd_flags;
	req_flags_t rq_flags;
	unsigned int nr_tags;
	struct request **cached_rq;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct blk_integrity_iter {
	void *prot_buf;
	void *data_buf;
	sector_t seed;
	unsigned int data_size;
	unsigned short interval;
	unsigned char tuple_size;
	const char *disk_name;
};

struct blkg_iostat {
	u64 bytes[3];
	u64 ios[3];
};

struct blkg_iostat_set {
	struct u64_stats_sync sync;
	struct blkcg_gq *blkg;
	struct llist_node lnode;
	int lqueued;
	struct blkg_iostat cur;
	struct blkg_iostat last;
};

struct blkcg;

struct blkg_policy_data;

struct blkcg_gq {
	struct request_queue *q;
	struct list_head q_node;
	struct hlist_node blkcg_node;
	struct blkcg *blkcg;
	struct blkcg_gq *parent;
	struct percpu_ref refcnt;
	bool online;
	struct blkg_iostat_set __attribute__((btf_type_tag("percpu"))) *iostat_cpu;
	struct blkg_iostat_set iostat;
	struct blkg_policy_data *pd[6];
	spinlock_t async_bio_lock;
	struct bio_list async_bios;
	union {
		struct work_struct async_bio_work;
		struct work_struct free_work;
	};
	atomic_t use_delay;
	atomic64_t delay_nsec;
	atomic64_t delay_start;
	u64 last_delay;
	int last_use;
	struct callback_head callback_head;
};

struct blkcg_policy_data;

struct blkcg {
	struct cgroup_subsys_state css;
	spinlock_t lock;
	refcount_t online_pin;
	struct xarray blkg_tree;
	struct blkcg_gq __attribute__((btf_type_tag("rcu"))) *blkg_hint;
	struct hlist_head blkg_list;
	struct blkcg_policy_data *cpd[6];
	struct list_head all_blkcgs_node;
	struct llist_head __attribute__((btf_type_tag("percpu"))) *lhead;
	struct list_head cgwb_list;
};

struct blkcg_policy_data {
	struct blkcg *blkcg;
	int plid;
};

struct blkg_policy_data {
	struct blkcg_gq *blkg;
	int plid;
	bool online;
};

struct rchan_callbacks;

struct rchan_buf;

struct rchan {
	u32 version;
	size_t subbuf_size;
	size_t n_subbufs;
	size_t alloc_size;
	const struct rchan_callbacks *cb;
	struct kref kref;
	void *private_data;
	size_t last_toobig;
	struct rchan_buf * __attribute__((btf_type_tag("percpu"))) *buf;
	int is_global;
	struct list_head list;
	struct dentry *parent;
	int has_base_filename;
	char base_filename[255];
};

struct rchan_callbacks {
	int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t);
	struct dentry * (*create_buf_file)(const char *, struct dentry *, umode_t, struct rchan_buf *, int *);
	int (*remove_buf_file)(struct dentry *);
};

struct rchan_buf {
	void *start;
	void *data;
	size_t offset;
	size_t subbufs_produced;
	size_t subbufs_consumed;
	struct rchan *chan;
	wait_queue_head_t read_wait;
	struct irq_work wakeup_work;
	struct dentry *dentry;
	struct kref kref;
	struct page **page_array;
	unsigned int page_count;
	unsigned int finalized;
	size_t *padding;
	size_t prev_padding;
	size_t bytes_consumed;
	size_t early_bytes;
	unsigned int cpu;
	long: 64;
	long: 64;
};

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, blk_status_t, unsigned int);

typedef void (*btf_trace_block_rq_error)(void *, struct request *, blk_status_t, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request *);

typedef void (*btf_trace_block_io_start)(void *, struct request *);

typedef void (*btf_trace_block_io_done)(void *, struct request *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct bio *);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct bio *);

typedef void (*btf_trace_block_getrq)(void *, struct bio *);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_block_split)(void *, struct bio *, unsigned int);

typedef void (*btf_trace_block_bio_remap)(void *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_remap)(void *, struct request *, dev_t, sector_t);

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PM = 4,
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

enum {
	BIO_PAGE_PINNED = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_QUIET = 3,
	BIO_CHAIN = 4,
	BIO_REFFED = 5,
	BIO_BPS_THROTTLED = 6,
	BIO_TRACE_COMPLETION = 7,
	BIO_CGROUP_ACCT = 8,
	BIO_QOS_THROTTLED = 9,
	BIO_QOS_MERGED = 10,
	BIO_REMAPPED = 11,
	BIO_ZONE_WRITE_LOCKED = 12,
	BIO_FLAG_LAST = 13,
};

enum {
	sysctl_hung_task_timeout_secs = 0,
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	size_t size;
	char __data[0];
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_completion {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq_completion {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_rq_remap {};

enum {
	IOU_PBUF_RING_MMAP = 1,
};

struct io_provide_buf {
	struct file *file;
	__u64 addr;
	__u32 len;
	__u32 bgid;
	__u32 nbufs;
	__u16 bid;
};

struct io_buf_free {
	struct hlist_node list;
	void *mem;
	size_t size;
	int inuse;
};

struct io_uring_buf_reg {
	__u64 ring_addr;
	__u32 ring_entries;
	__u16 bgid;
	__u16 flags;
	__u64 resv[3];
};

struct tegra_ictlr_soc {
	unsigned int num_ictlrs;
};

struct tegra_ictlr_info {
	void *base[6];
	u32 cop_ier[6];
	u32 cop_iep[6];
	u32 cpu_ier[6];
	u32 cpu_iep[6];
	u32 ictlr_wake_mask[6];
};

struct brcmstb_intc_init_params {
	irq_flow_handler_t handler;
	int cpu_status;
	int cpu_clear;
	int cpu_mask_status;
	int cpu_mask_set;
	int cpu_mask_clear;
};

struct brcmstb_l2_intc_data {
	struct irq_domain *domain;
	struct irq_chip_generic *gc;
	int status_offset;
	int mask_offset;
	bool can_wake;
	u32 saved_mask;
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_ACTIVATE_EARLY = 4,
	MSI_FLAG_MUST_REACTIVATE = 8,
	MSI_FLAG_DEV_SYSFS = 16,
	MSI_FLAG_ALLOC_SIMPLE_MSI_DESCS = 32,
	MSI_FLAG_FREE_MSI_DESCS = 64,
	MSI_GENERIC_FLAGS_MASK = 65535,
	MSI_DOMAIN_FLAGS_MASK = 4294901760,
	MSI_FLAG_MULTI_PCI_MSI = 65536,
	MSI_FLAG_PCI_MSIX = 131072,
	MSI_FLAG_LEVEL_CAPABLE = 262144,
	MSI_FLAG_MSIX_CONTIGUOUS = 524288,
	MSI_FLAG_PCI_MSIX_ALLOC_DYN = 1048576,
	MSI_FLAG_PCI_IMS = 2097152,
};

enum msi_domain_ids {
	MSI_DEFAULT_DOMAIN = 0,
	MSI_SECONDARY_DOMAIN = 1,
	MSI_MAX_DEVICE_IRQDOMAINS = 2,
};

struct dprc_irq_cfg {
	phys_addr_t paddr;
	u32 val;
	int irq_num;
};

enum brcm_sata_phy_version {
	BRCM_SATA_PHY_STB_16NM = 0,
	BRCM_SATA_PHY_STB_28NM = 1,
	BRCM_SATA_PHY_STB_40NM = 2,
	BRCM_SATA_PHY_IPROC_NS2 = 3,
	BRCM_SATA_PHY_IPROC_NSP = 4,
	BRCM_SATA_PHY_IPROC_SR = 5,
	BRCM_SATA_PHY_DSL_28NM = 6,
};

enum brcm_sata_phy_rxaeq_mode {
	RXAEQ_MODE_OFF = 0,
	RXAEQ_MODE_AUTO = 1,
	RXAEQ_MODE_MANUAL = 2,
};

enum sata_phy_regs {
	BLOCK0_REG_BANK = 0,
	BLOCK0_XGXSSTATUS = 129,
	BLOCK0_XGXSSTATUS_PLL_LOCK = 4096,
	BLOCK0_SPARE = 141,
	BLOCK0_SPARE_OOB_CLK_SEL_MASK = 3,
	BLOCK0_SPARE_OOB_CLK_SEL_REFBY2 = 1,
	BLOCK1_REG_BANK = 16,
	BLOCK1_TEST_TX = 131,
	BLOCK1_TEST_TX_AMP_SHIFT = 12,
	PLL_REG_BANK_0 = 80,
	PLL_REG_BANK_0_PLLCONTROL_0 = 129,
	PLLCONTROL_0_FREQ_DET_RESTART = 8192,
	PLLCONTROL_0_FREQ_MONITOR = 4096,
	PLLCONTROL_0_SEQ_START = 32768,
	PLL_CAP_CHARGE_TIME = 131,
	PLL_VCO_CAL_THRESH = 132,
	PLL_CAP_CONTROL = 133,
	PLL_FREQ_DET_TIME = 134,
	PLL_ACTRL2 = 139,
	PLL_ACTRL2_SELDIV_MASK = 31,
	PLL_ACTRL2_SELDIV_SHIFT = 9,
	PLL_ACTRL6 = 134,
	PLL1_REG_BANK = 96,
	PLL1_ACTRL2 = 130,
	PLL1_ACTRL3 = 131,
	PLL1_ACTRL4 = 132,
	PLL1_ACTRL5 = 133,
	PLL1_ACTRL6 = 134,
	PLL1_ACTRL7 = 135,
	PLL1_ACTRL8 = 136,
	TX_REG_BANK = 112,
	TX_ACTRL0 = 128,
	TX_ACTRL0_TXPOL_FLIP = 64,
	TX_ACTRL5 = 133,
	TX_ACTRL5_SSC_EN = 2048,
	AEQRX_REG_BANK_0 = 208,
	AEQ_CONTROL1 = 129,
	AEQ_CONTROL1_ENABLE = 4,
	AEQ_CONTROL1_FREEZE = 8,
	AEQ_FRC_EQ = 131,
	AEQ_FRC_EQ_FORCE = 1,
	AEQ_FRC_EQ_FORCE_VAL = 2,
	AEQ_RFZ_FRC_VAL = 256,
	AEQRX_REG_BANK_1 = 224,
	AEQRX_SLCAL0_CTRL0 = 130,
	AEQRX_SLCAL1_CTRL0 = 134,
	OOB_REG_BANK = 336,
	OOB1_REG_BANK = 352,
	OOB_CTRL1 = 128,
	OOB_CTRL1_BURST_MAX_MASK = 15,
	OOB_CTRL1_BURST_MAX_SHIFT = 12,
	OOB_CTRL1_BURST_MIN_MASK = 15,
	OOB_CTRL1_BURST_MIN_SHIFT = 8,
	OOB_CTRL1_WAKE_IDLE_MAX_MASK = 15,
	OOB_CTRL1_WAKE_IDLE_MAX_SHIFT = 4,
	OOB_CTRL1_WAKE_IDLE_MIN_MASK = 15,
	OOB_CTRL1_WAKE_IDLE_MIN_SHIFT = 0,
	OOB_CTRL2 = 129,
	OOB_CTRL2_SEL_ENA_SHIFT = 15,
	OOB_CTRL2_SEL_ENA_RC_SHIFT = 14,
	OOB_CTRL2_RESET_IDLE_MAX_MASK = 63,
	OOB_CTRL2_RESET_IDLE_MAX_SHIFT = 8,
	OOB_CTRL2_BURST_CNT_MASK = 3,
	OOB_CTRL2_BURST_CNT_SHIFT = 6,
	OOB_CTRL2_RESET_IDLE_MIN_MASK = 63,
	OOB_CTRL2_RESET_IDLE_MIN_SHIFT = 0,
	TXPMD_REG_BANK = 416,
	TXPMD_CONTROL1 = 129,
	TXPMD_CONTROL1_TX_SSC_EN_FRC = 1,
	TXPMD_CONTROL1_TX_SSC_EN_FRC_VAL = 2,
	TXPMD_TX_FREQ_CTRL_CONTROL1 = 130,
	TXPMD_TX_FREQ_CTRL_CONTROL2 = 131,
	TXPMD_TX_FREQ_CTRL_CONTROL2_FMIN_MASK = 1023,
	TXPMD_TX_FREQ_CTRL_CONTROL3 = 132,
	TXPMD_TX_FREQ_CTRL_CONTROL3_FMAX_MASK = 1023,
	RXPMD_REG_BANK = 448,
	RXPMD_RX_CDR_CONTROL1 = 129,
	RXPMD_RX_PPM_VAL_MASK = 511,
	RXPMD_RXPMD_EN_FRC = 4096,
	RXPMD_RXPMD_EN_FRC_VAL = 8192,
	RXPMD_RX_CDR_CDR_PROP_BW = 130,
	RXPMD_G_CDR_PROP_BW_MASK = 7,
	RXPMD_G1_CDR_PROP_BW_SHIFT = 0,
	RXPMD_G2_CDR_PROP_BW_SHIFT = 3,
	RXPMD_G3_CDR_PROB_BW_SHIFT = 6,
	RXPMD_RX_CDR_CDR_ACQ_INTEG_BW = 131,
	RXPMD_G_CDR_ACQ_INT_BW_MASK = 7,
	RXPMD_G1_CDR_ACQ_INT_BW_SHIFT = 0,
	RXPMD_G2_CDR_ACQ_INT_BW_SHIFT = 3,
	RXPMD_G3_CDR_ACQ_INT_BW_SHIFT = 6,
	RXPMD_RX_CDR_CDR_LOCK_INTEG_BW = 132,
	RXPMD_G_CDR_LOCK_INT_BW_MASK = 7,
	RXPMD_G1_CDR_LOCK_INT_BW_SHIFT = 0,
	RXPMD_G2_CDR_LOCK_INT_BW_SHIFT = 3,
	RXPMD_G3_CDR_LOCK_INT_BW_SHIFT = 6,
	RXPMD_RX_FREQ_MON_CONTROL1 = 135,
	RXPMD_MON_CORRECT_EN = 256,
	RXPMD_MON_MARGIN_VAL_MASK = 255,
};

enum sata_phy_ctrl_regs {
	PHY_CTRL_1 = 0,
	PHY_CTRL_1_RESET = 1,
};

struct brcm_sata_phy;

struct brcm_sata_port {
	int portnum;
	struct phy *phy;
	struct brcm_sata_phy *phy_priv;
	bool ssc_en;
	enum brcm_sata_phy_rxaeq_mode rxaeq_mode;
	u32 rxaeq_val;
	u32 tx_amplitude_val;
};

struct brcm_sata_phy {
	struct device *dev;
	void *phy_base;
	void *ctrl_base;
	enum brcm_sata_phy_version version;
	struct brcm_sata_port phys[2];
};

struct samsung_ufs_phy_pmu_isol {
	u32 offset;
	u32 mask;
	u32 en;
};

struct samsung_ufs_phy_cfg;

struct samsung_ufs_phy_drvdata {
	const struct samsung_ufs_phy_cfg **cfgs;
	struct samsung_ufs_phy_pmu_isol isol;
	const char * const *clk_list;
	int num_clks;
	u32 cdr_lock_status_offset;
};

struct samsung_ufs_phy_cfg {
	u32 off_0;
	u32 off_1;
	u32 val;
	u8 desc;
	u8 id;
};

struct exynos5_usbdrd_phy_config;

struct exynos5_usbdrd_phy_drvdata {
	const struct exynos5_usbdrd_phy_config *phy_cfg;
	const struct phy_ops *phy_ops;
	u32 pmu_offset_usbdrd0_phy;
	u32 pmu_offset_usbdrd1_phy;
	bool has_common_clk_gate;
};

struct phy_usb_instance;

struct exynos5_usbdrd_phy;

struct exynos5_usbdrd_phy_config {
	u32 id;
	void (*phy_isol)(struct phy_usb_instance *, u32);
	void (*phy_init)(struct exynos5_usbdrd_phy *);
	unsigned int (*set_refclk)(struct phy_usb_instance *);
};

struct phy_usb_instance {
	struct phy *phy;
	u32 index;
	struct regmap *reg_pmu;
	u32 pmu_offset;
	const struct exynos5_usbdrd_phy_config *phy_cfg;
};

struct exynos5_usbdrd_phy {
	struct device *dev;
	void *reg_phy;
	struct clk *clk;
	struct clk *pipeclk;
	struct clk *utmiclk;
	struct clk *itpclk;
	const struct exynos5_usbdrd_phy_drvdata *drv_data;
	struct phy_usb_instance phys[2];
	u32 extrefclk;
	struct clk *ref_clk;
	struct regulator *vbus;
	struct regulator *vbus_boost;
};

enum exynos5_usbdrd_phy_id {
	EXYNOS5_DRDPHY_UTMI = 0,
	EXYNOS5_DRDPHY_PIPE3 = 1,
	EXYNOS5_DRDPHYS_NUM = 2,
};

enum s700_pinconf_pull {
	OWL_PINCONF_PULL_DOWN = 0,
	OWL_PINCONF_PULL_UP = 1,
};

struct mtk_pin_reg_calc;

struct mtk_pin_desc;

struct group_desc;

struct function_desc;

struct mtk_eint_regs;

struct mtk_eint_hw;

struct mtk_pin_rsel;

struct mtk_pinctrl;

struct mtk_pin_soc {
	const struct mtk_pin_reg_calc *reg_cal;
	const struct mtk_pin_desc *pins;
	unsigned int npins;
	const struct group_desc *grps;
	unsigned int ngrps;
	const struct function_desc *funcs;
	unsigned int nfuncs;
	const struct mtk_eint_regs *eint_regs;
	const struct mtk_eint_hw *eint_hw;
	u8 gpio_m;
	bool ies_present;
	const char * const *base_names;
	unsigned int nbase_names;
	const unsigned int *pull_type;
	const struct mtk_pin_rsel *pin_rsel;
	unsigned int npin_rsel;
	int (*bias_disable_set)(struct mtk_pinctrl *, const struct mtk_pin_desc *);
	int (*bias_disable_get)(struct mtk_pinctrl *, const struct mtk_pin_desc *, int *);
	int (*bias_set)(struct mtk_pinctrl *, const struct mtk_pin_desc *, bool);
	int (*bias_get)(struct mtk_pinctrl *, const struct mtk_pin_desc *, bool, int *);
	int (*bias_set_combo)(struct mtk_pinctrl *, const struct mtk_pin_desc *, u32, u32);
	int (*bias_get_combo)(struct mtk_pinctrl *, const struct mtk_pin_desc *, u32 *, u32 *);
	int (*drive_set)(struct mtk_pinctrl *, const struct mtk_pin_desc *, u32);
	int (*drive_get)(struct mtk_pinctrl *, const struct mtk_pin_desc *, int *);
	int (*adv_pull_set)(struct mtk_pinctrl *, const struct mtk_pin_desc *, bool, u32);
	int (*adv_pull_get)(struct mtk_pinctrl *, const struct mtk_pin_desc *, bool, u32 *);
	int (*adv_drive_set)(struct mtk_pinctrl *, const struct mtk_pin_desc *, u32);
	int (*adv_drive_get)(struct mtk_pinctrl *, const struct mtk_pin_desc *, u32 *);
	void *driver_data;
};

struct mtk_pin_field_calc;

struct mtk_pin_reg_calc {
	const struct mtk_pin_field_calc *range;
	unsigned int nranges;
};

struct mtk_pin_field_calc {
	u16 s_pin;
	u16 e_pin;
	u8 i_base;
	u32 s_addr;
	u8 x_addrs;
	u8 s_bit;
	u8 x_bits;
	u8 sz_reg;
	u8 fixed;
};

struct mtk_eint_desc {
	u16 eint_m;
	u16 eint_n;
};

struct mtk_func_desc;

struct mtk_pin_desc {
	unsigned int number;
	const char *name;
	struct mtk_eint_desc eint;
	u8 drv_n;
	struct mtk_func_desc *funcs;
};

struct mtk_func_desc {
	const char *name;
	u8 muxval;
};

struct group_desc {
	const char *name;
	int *pins;
	int num_pins;
	void *data;
};

struct function_desc {
	const char *name;
	const char * const *group_names;
	int num_group_names;
	void *data;
};

struct mtk_eint_regs {
	unsigned int stat;
	unsigned int ack;
	unsigned int mask;
	unsigned int mask_set;
	unsigned int mask_clr;
	unsigned int sens;
	unsigned int sens_set;
	unsigned int sens_clr;
	unsigned int soft;
	unsigned int soft_set;
	unsigned int soft_clr;
	unsigned int pol;
	unsigned int pol_set;
	unsigned int pol_clr;
	unsigned int dom_en;
	unsigned int dbnc_ctrl;
	unsigned int dbnc_set;
	unsigned int dbnc_clr;
};

struct mtk_eint_hw {
	u8 port_mask;
	u8 ports;
	unsigned int ap_num;
	unsigned int db_cnt;
	const unsigned int *db_time;
};

struct mtk_pin_rsel {
	u16 s_pin;
	u16 e_pin;
	u16 rsel_index;
	u32 up_rsel;
	u32 down_rsel;
};

struct mtk_eint;

struct mtk_pinctrl_group;

struct mtk_pinctrl {
	struct pinctrl_dev *pctrl;
	void **base;
	u8 nbase;
	struct device *dev;
	struct gpio_chip chip;
	const struct mtk_pin_soc *soc;
	struct mtk_eint *eint;
	struct mtk_pinctrl_group *groups;
	const char **grp_names;
	spinlock_t lock;
	bool rsel_si_unit;
};

struct mtk_eint_xt;

struct mtk_eint {
	struct device *dev;
	void *base;
	struct irq_domain *domain;
	int irq;
	int *dual_edge;
	u32 *wake_mask;
	u32 *cur_mask;
	const struct mtk_eint_hw *hw;
	const struct mtk_eint_regs *regs;
	u16 num_db_time;
	void *pctl;
	const struct mtk_eint_xt *gpio_xlate;
};

struct mtk_eint_xt {
	int (*get_gpio_n)(void *, unsigned long, unsigned int *, struct gpio_chip **);
	int (*get_gpio_state)(void *, unsigned long);
	int (*set_gpio_as_eint)(void *, unsigned long);
};

struct mtk_pinctrl_group {
	const char *name;
	unsigned long config;
	unsigned int pin;
};

struct pinmux_range {
	u16 begin;
	u16 end;
	u16 force;
};

struct sh_pfc_soc_operations;

struct sh_pfc_pin;

struct sh_pfc_pin_group;

struct sh_pfc_function;

struct pinmux_cfg_reg;

struct pinmux_drive_reg;

struct pinmux_bias_reg;

struct pinmux_ioctrl_reg;

struct pinmux_data_reg;

struct sh_pfc_soc_info {
	const char *name;
	const struct sh_pfc_soc_operations *ops;
	struct pinmux_range function;
	const struct sh_pfc_pin *pins;
	unsigned int nr_pins;
	const struct sh_pfc_pin_group *groups;
	unsigned int nr_groups;
	const struct sh_pfc_function *functions;
	unsigned int nr_functions;
	const struct pinmux_cfg_reg *cfg_regs;
	const struct pinmux_drive_reg *drive_regs;
	const struct pinmux_bias_reg *bias_regs;
	const struct pinmux_ioctrl_reg *ioctrl_regs;
	const struct pinmux_data_reg *data_regs;
	const u16 *pinmux_data;
	unsigned int pinmux_data_size;
	u32 unlock_reg;
};

struct sh_pfc;

struct sh_pfc_soc_operations {
	int (*init)(struct sh_pfc *);
	unsigned int (*get_bias)(struct sh_pfc *, unsigned int);
	void (*set_bias)(struct sh_pfc *, unsigned int, unsigned int);
	int (*pin_to_pocctrl)(unsigned int, u32 *);
	int (*pin_to_portcr)(unsigned int);
};

struct sh_pfc_chip;

struct sh_pfc_window;

struct sh_pfc_pin_range;

struct sh_pfc {
	struct device *dev;
	const struct sh_pfc_soc_info *info;
	spinlock_t lock;
	unsigned int num_windows;
	struct sh_pfc_window *windows;
	unsigned int num_irqs;
	unsigned int *irqs;
	struct sh_pfc_pin_range *ranges;
	unsigned int nr_ranges;
	unsigned int nr_gpio_pins;
	struct sh_pfc_chip *gpio;
	u32 *saved_regs;
};

struct sh_pfc_window {
	phys_addr_t phys;
	void *virt;
	unsigned long size;
};

struct sh_pfc_pin {
	const char *name;
	unsigned int configs;
	u16 pin;
	u16 enum_id;
};

struct sh_pfc_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int *mux;
	unsigned int nr_pins;
};

struct sh_pfc_function {
	const char *name;
	const char * const *groups;
	unsigned int nr_groups;
};

struct pinmux_cfg_reg {
	u32 reg;
	u8 reg_width;
	u8 field_width;
	const u16 *enum_ids;
	const s8 *var_field_width;
};

struct pinmux_drive_reg_field {
	u16 pin;
	u8 offset;
	u8 size;
};

struct pinmux_drive_reg {
	u32 reg;
	const struct pinmux_drive_reg_field fields[10];
};

struct pinmux_bias_reg {
	u32 puen;
	u32 pud;
	const u16 pins[32];
};

struct pinmux_ioctrl_reg {
	u32 reg;
};

struct pinmux_data_reg {
	u32 reg;
	u8 reg_width;
	const u16 *enum_ids;
};

enum ioctrl_regs {
	POCCTRL0 = 0,
	POCCTRL1 = 1,
	POCCTRL2 = 2,
	TDSELCTRL = 3,
};

enum {
	GP_LAST = 174,
	PIN_DU_DOTCLKIN = 175,
	PIN_EXTALR = 176,
	PIN_FSCLKST_N = 177,
	PIN_PRESETOUT_N = 178,
	PIN_TCK = 179,
	PIN_TDI = 180,
	PIN_TMS = 181,
	PIN_TRST_N = 182,
	PIN_VDDQ_AVB0 = 183,
};

struct rzg2l_dedicated_configs;

struct rzg2l_hwcfg;

struct rzg2l_pinctrl_data {
	const char * const *port_pins;
	const u32 *port_pin_configs;
	unsigned int n_ports;
	const struct rzg2l_dedicated_configs *dedicated_pins;
	unsigned int n_port_pins;
	unsigned int n_dedicated_pins;
	const struct rzg2l_hwcfg *hwcfg;
};

struct rzg2l_dedicated_configs {
	const char *name;
	u32 config;
};

struct rzg2l_register_offsets {
	u16 pwpr;
	u16 sd_ch;
};

struct rzg2l_hwcfg {
	const struct rzg2l_register_offsets regs;
	u16 iolh_groupa_ua[12];
	u16 iolh_groupb_ua[12];
	u16 iolh_groupc_ua[12];
	u16 iolh_groupb_oi[4];
	bool drive_strength_ua;
	u8 func_base;
};

enum rzg2l_iolh_index {
	RZG2L_IOLH_IDX_1V8 = 0,
	RZG2L_IOLH_IDX_2V5 = 4,
	RZG2L_IOLH_IDX_3V3 = 8,
	RZG2L_IOLH_IDX_MAX = 12,
};

struct rzg2l_pinctrl_pin_settings;

struct rzg2l_pinctrl {
	struct pinctrl_dev *pctl;
	struct pinctrl_desc desc;
	struct pinctrl_pin_desc *pins;
	const struct rzg2l_pinctrl_data *data;
	void *base;
	struct device *dev;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range gpio_range;
	unsigned long tint_slot[1];
	spinlock_t bitmap_lock;
	unsigned int hwirq[32];
	spinlock_t lock;
	struct mutex mutex;
	struct rzg2l_pinctrl_pin_settings *settings;
};

struct rzg2l_pinctrl_pin_settings {
	u16 power_source;
	u16 drive_strength_ua;
};

struct visconti_desc_pin;

struct visconti_pin_group;

struct visconti_pin_function;

struct visconti_mux;

struct visconti_pinctrl_devdata {
	const struct visconti_desc_pin *pins;
	unsigned int nr_pins;
	const struct visconti_pin_group *groups;
	unsigned int nr_groups;
	const struct visconti_pin_function *functions;
	unsigned int nr_functions;
	const struct visconti_mux *gpio_mux;
	void (*unlock)(void *);
};

struct visconti_desc_pin {
	struct pinctrl_pin_desc pin;
	unsigned int dsel_offset;
	unsigned int dsel_shift;
	unsigned int pude_offset;
	unsigned int pudsel_offset;
	unsigned int pud_shift;
};

struct visconti_mux {
	unsigned int offset;
	unsigned int mask;
	unsigned int val;
};

struct visconti_pin_group {
	const char *name;
	const unsigned int *pins;
	unsigned int nr_pins;
	struct visconti_mux mux;
};

struct visconti_pin_function {
	const char *name;
	const char * const *groups;
	unsigned int nr_groups;
};

struct visconti_pinctrl {
	void *base;
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctl_desc;
	const struct visconti_pinctrl_devdata *devdata;
	spinlock_t lock;
};

struct amba_device;

struct amba_id;

struct amba_driver {
	struct device_driver drv;
	int (*probe)(struct amba_device *, const struct amba_id *);
	void (*remove)(struct amba_device *);
	void (*shutdown)(struct amba_device *);
	const struct amba_id *id_table;
	bool driver_managed_dma;
};

struct amba_cs_uci_id {
	unsigned int devarch;
	unsigned int devarch_mask;
	unsigned int devtype;
	void *data;
};

struct amba_device {
	struct device dev;
	struct resource res;
	struct clk *pclk;
	struct device_dma_parameters dma_parms;
	unsigned int periphid;
	struct mutex periphid_lock;
	unsigned int cid;
	struct amba_cs_uci_id uci;
	unsigned int irq[9];
	const char *driver_override;
};

struct amba_id {
	unsigned int id;
	unsigned int mask;
	void *data;
};

struct pl061_context_save_regs {
	u8 gpio_data;
	u8 gpio_dir;
	u8 gpio_is;
	u8 gpio_ibe;
	u8 gpio_iev;
	u8 gpio_ie;
};

struct pl061 {
	raw_spinlock_t lock;
	void *base;
	struct gpio_chip gc;
	int parent_irq;
	struct pl061_context_save_regs csave_regs;
};

struct tegra_gpio_soc_config {
	bool debounce_supported;
	u32 bank_stride;
	u32 upper_offset;
};

struct tegra_gpio_bank;

struct tegra_gpio_info {
	struct device *dev;
	void *regs;
	struct tegra_gpio_bank *bank_info;
	const struct tegra_gpio_soc_config *soc;
	struct gpio_chip gc;
	u32 bank_count;
	unsigned int *irqs;
};

struct tegra_gpio_bank {
	unsigned int bank;
	raw_spinlock_t lvl_lock[4];
	spinlock_t dbc_lock[4];
	u32 cnf[4];
	u32 out[4];
	u32 oe[4];
	u32 int_enb[4];
	u32 int_lvl[4];
	u32 wake_enb[4];
	u32 dbc_enb[4];
	u32 dbc_cnt[4];
};

enum msi_desc_filter {
	MSI_DESC_ALL = 0,
	MSI_DESC_NOTASSOCIATED = 1,
	MSI_DESC_ASSOCIATED = 2,
};

enum support_mode {
	ALLOW_LEGACY = 0,
	DENY_LEGACY = 1,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_epc_interface_type {
	UNKNOWN_INTERFACE = -1,
	PRIMARY_INTERFACE = 0,
	SECONDARY_INTERFACE = 1,
};

struct pci_epf_driver;

struct pci_epf_device_id;

struct pci_epc_event_ops;

struct pci_epf {
	struct device dev;
	const char *name;
	struct pci_epf_header *header;
	struct pci_epf_bar bar[6];
	u8 msi_interrupts;
	u16 msix_interrupts;
	u8 func_no;
	u8 vfunc_no;
	struct pci_epc *epc;
	struct pci_epf *epf_pf;
	struct pci_epf_driver *driver;
	const struct pci_epf_device_id *id;
	struct list_head list;
	struct mutex lock;
	struct pci_epc *sec_epc;
	struct list_head sec_epc_list;
	struct pci_epf_bar sec_epc_bar[6];
	u8 sec_epc_func_no;
	struct config_group *group;
	unsigned int is_bound;
	unsigned int is_vf;
	unsigned long vfunction_num_map;
	struct list_head pci_vepf;
	const struct pci_epc_event_ops *event_ops;
};

struct pci_epf_ops;

struct pci_epf_driver {
	int (*probe)(struct pci_epf *, const struct pci_epf_device_id *);
	void (*remove)(struct pci_epf *);
	struct device_driver driver;
	struct pci_epf_ops *ops;
	struct module *owner;
	struct list_head epf_group;
	const struct pci_epf_device_id *id_table;
};

struct pci_epf_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct pci_epf_ops {
	int (*bind)(struct pci_epf *);
	void (*unbind)(struct pci_epf *);
	struct config_group * (*add_cfs)(struct pci_epf *, struct config_group *);
};

struct pci_epc_event_ops {
	int (*core_init)(struct pci_epf *);
	int (*link_up)(struct pci_epf *);
	int (*link_down)(struct pci_epf *);
	int (*bme)(struct pci_epf *);
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct subsys_private;

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
	struct subsys_private *sp;
};

struct qcom_pcie_ops;

struct qcom_pcie_cfg {
	const struct qcom_pcie_ops *ops;
};

struct qcom_pcie;

struct qcom_pcie_ops {
	int (*get_resources)(struct qcom_pcie *);
	int (*init)(struct qcom_pcie *);
	int (*post_init)(struct qcom_pcie *);
	void (*host_post_init)(struct qcom_pcie *);
	void (*deinit)(struct qcom_pcie *);
	void (*ltssm_enable)(struct qcom_pcie *);
	int (*config_sid)(struct qcom_pcie *);
};

struct qcom_pcie_resources_1_0_0 {
	struct clk_bulk_data clks[4];
	struct reset_control *core;
	struct regulator *vdda;
};

struct regulator_bulk_data {
	const char *supply;
	int init_load_uA;
	struct regulator *consumer;
	int ret;
};

struct qcom_pcie_resources_2_1_0 {
	struct clk_bulk_data clks[5];
	struct reset_control_bulk_data resets[6];
	int num_resets;
	struct regulator_bulk_data supplies[3];
};

struct qcom_pcie_resources_2_3_2 {
	struct clk_bulk_data clks[4];
	struct regulator_bulk_data supplies[2];
};

struct qcom_pcie_resources_2_3_3 {
	struct clk_bulk_data clks[5];
	struct reset_control_bulk_data rst[7];
};

struct qcom_pcie_resources_2_4_0 {
	struct clk_bulk_data clks[4];
	int num_clks;
	struct reset_control_bulk_data resets[12];
	int num_resets;
};

struct qcom_pcie_resources_2_7_0 {
	struct clk_bulk_data clks[15];
	int num_clks;
	struct regulator_bulk_data supplies[2];
	struct reset_control *rst;
};

struct qcom_pcie_resources_2_9_0 {
	struct clk_bulk_data clks[5];
	struct reset_control *rst;
};

union qcom_pcie_resources {
	struct qcom_pcie_resources_1_0_0 v1_0_0;
	struct qcom_pcie_resources_2_1_0 v2_1_0;
	struct qcom_pcie_resources_2_3_2 v2_3_2;
	struct qcom_pcie_resources_2_3_3 v2_3_3;
	struct qcom_pcie_resources_2_4_0 v2_4_0;
	struct qcom_pcie_resources_2_7_0 v2_7_0;
	struct qcom_pcie_resources_2_9_0 v2_9_0;
};

struct qcom_pcie {
	struct dw_pcie *pci;
	void *parf;
	void *elbi;
	void *mhi;
	union qcom_pcie_resources res;
	struct phy *phy;
	struct gpio_desc *reset;
	struct icc_path *icc_mem;
	const struct qcom_pcie_cfg *cfg;
	struct dentry *debugfs;
	bool suspended;
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCIE_SPEED_64_0GT = 25,
	PCI_SPEED_UNKNOWN = 255,
};

enum acpi_ec_event_state {
	EC_EVENT_READY = 0,
	EC_EVENT_IN_PROGRESS = 1,
	EC_EVENT_COMPLETE = 2,
};

struct transaction;

struct acpi_ec {
	acpi_handle handle;
	acpi_handle address_space_handler_holder;
	int gpe;
	int irq;
	unsigned long command_addr;
	unsigned long data_addr;
	bool global_lock;
	unsigned long flags;
	unsigned long reference_count;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct list_head list;
	struct transaction *curr;
	spinlock_t lock;
	struct work_struct work;
	unsigned long timestamp;
	enum acpi_ec_event_state event_state;
	unsigned int events_to_process;
	unsigned int events_in_progress;
	unsigned int queries_in_progress;
	bool busy_polling;
	unsigned int polling_guard;
};

struct transaction {
	const u8 *wdata;
	u8 *rdata;
	unsigned short irq_count;
	u8 command;
	u8 wi;
	u8 ri;
	u8 wlen;
	u8 rlen;
	u8 flags;
};

typedef int (*acpi_op_add)(struct acpi_device *);

typedef void (*acpi_op_remove)(struct acpi_device *);

typedef void (*acpi_op_notify)(struct acpi_device *, u32);

struct acpi_device_ops {
	acpi_op_add add;
	acpi_op_remove remove;
	acpi_op_notify notify;
};

struct acpi_driver {
	char name[80];
	char class[80];
	const struct acpi_device_id *ids;
	unsigned int flags;
	struct acpi_device_ops ops;
	struct device_driver drv;
	struct module *owner;
};

enum ec_command {
	ACPI_EC_COMMAND_READ = 128,
	ACPI_EC_COMMAND_WRITE = 129,
	ACPI_EC_BURST_ENABLE = 130,
	ACPI_EC_BURST_DISABLE = 131,
	ACPI_EC_COMMAND_QUERY = 132,
};

enum {
	EC_FLAGS_QUERY_ENABLED = 0,
	EC_FLAGS_EVENT_HANDLER_INSTALLED = 1,
	EC_FLAGS_EC_HANDLER_INSTALLED = 2,
	EC_FLAGS_EC_REG_CALLED = 3,
	EC_FLAGS_QUERY_METHODS_INSTALLED = 4,
	EC_FLAGS_STARTED = 5,
	EC_FLAGS_STOPPED = 6,
	EC_FLAGS_EVENTS_MASKED = 7,
};

enum acpi_bus_device_type {
	ACPI_BUS_TYPE_DEVICE = 0,
	ACPI_BUS_TYPE_POWER = 1,
	ACPI_BUS_TYPE_PROCESSOR = 2,
	ACPI_BUS_TYPE_THERMAL = 3,
	ACPI_BUS_TYPE_POWER_BUTTON = 4,
	ACPI_BUS_TYPE_SLEEP_BUTTON = 5,
	ACPI_BUS_TYPE_ECDT_EC = 6,
	ACPI_BUS_DEVICE_TYPE_COUNT = 7,
};

typedef int (*acpi_ec_query_func)(void *);

struct acpi_ec_query_handler {
	struct list_head node;
	acpi_ec_query_func func;
	acpi_handle handle;
	void *data;
	u8 query_bit;
	struct kref kref;
};

struct acpi_ec_query {
	struct transaction transaction;
	struct work_struct work;
	struct acpi_ec_query_handler *handler;
	struct acpi_ec *ec;
};

typedef u32 acpi_event_status;

struct acpi_generic_address {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct acpi_table_ecdt {
	struct acpi_table_header header;
	struct acpi_generic_address control;
	struct acpi_generic_address data;
	u32 uid;
	u8 gpe;
	u8 id[0];
} __attribute__((packed));

struct acpi_table_desc {
	acpi_physical_address address;
	struct acpi_table_header *pointer;
	u32 length;
	union acpi_name_union signature;
	acpi_owner_id owner_id;
	u8 flags;
	u16 validation_count;
};

typedef acpi_status (*acpi_table_handler)(u32, void *, void *);

struct pnp_dev;

struct pnp_fixup {
	char id[7];
	void (*quirk_function)(struct pnp_dev *);
};

struct pnp_protocol;

struct pnp_card;

struct pnp_driver;

struct pnp_card_link;

struct pnp_id;

struct pnp_dev {
	struct device dev;
	u64 dma_mask;
	unsigned int number;
	int status;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head card_list;
	struct list_head rdev_list;
	struct pnp_protocol *protocol;
	struct pnp_card *card;
	struct pnp_driver *driver;
	struct pnp_card_link *card_link;
	struct pnp_id *id;
	int active;
	int capabilities;
	unsigned int num_dependent_sets;
	struct list_head resources;
	struct list_head options;
	char name[50];
	int flags;
	struct proc_dir_entry *procent;
	void *data;
};

struct pnp_protocol {
	struct list_head protocol_list;
	char *name;
	int (*get)(struct pnp_dev *);
	int (*set)(struct pnp_dev *);
	int (*disable)(struct pnp_dev *);
	bool (*can_wakeup)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	unsigned char number;
	struct device dev;
	struct list_head cards;
	struct list_head devices;
};

struct pnp_card {
	struct device dev;
	unsigned char number;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head devices;
	struct pnp_protocol *protocol;
	struct pnp_id *id;
	char name[50];
	unsigned char pnpver;
	unsigned char productver;
	unsigned int serial;
	unsigned char checksum;
	struct proc_dir_entry *procdir;
};

struct pnp_id {
	char id[8];
	struct pnp_id *next;
};

struct pnp_device_id;

struct pnp_driver {
	const char *name;
	const struct pnp_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_dev *, const struct pnp_device_id *);
	void (*remove)(struct pnp_dev *);
	void (*shutdown)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	struct device_driver driver;
};

struct pnp_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
};

struct pnp_card_driver;

struct pnp_card_link {
	struct pnp_card *card;
	struct pnp_card_driver *driver;
	void *driver_data;
	pm_message_t pm_state;
};

struct pnp_card_device_id;

struct pnp_card_driver {
	struct list_head global_list;
	char *name;
	const struct pnp_card_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_card_link *, const struct pnp_card_device_id *);
	void (*remove)(struct pnp_card_link *);
	int (*suspend)(struct pnp_card_link *, pm_message_t);
	int (*resume)(struct pnp_card_link *);
	struct pnp_driver link;
};

struct pnp_card_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
	struct {
		__u8 id[8];
	} devs[8];
};

struct pnp_port {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

typedef struct {
	unsigned long bits[4];
} pnp_irq_mask_t;

struct pnp_irq {
	pnp_irq_mask_t map;
	unsigned char flags;
};

struct pnp_dma {
	unsigned char map;
	unsigned char flags;
};

struct pnp_mem {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

struct pnp_option {
	struct list_head list;
	unsigned int flags;
	unsigned long type;
	union {
		struct pnp_port port;
		struct pnp_irq irq;
		struct pnp_dma dma;
		struct pnp_mem mem;
	} u;
};

struct pnp_resource {
	struct list_head list;
	struct resource res;
};

typedef u64 pci_bus_addr_t;

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

struct clockgen_muxinfo;

struct clockgen;

struct clockgen_chipinfo {
	const char *compat;
	const char *guts_compat;
	const struct clockgen_muxinfo *cmux_groups[2];
	const struct clockgen_muxinfo *hwaccel[5];
	void (*init_periph)(struct clockgen *);
	int cmux_to_group[9];
	u32 pll_mask;
	u32 flags;
};

struct clockgen_pll_div {
	struct clk *clk;
	char name[32];
};

struct clockgen_pll {
	struct clockgen_pll_div div[32];
};

struct ccsr_guts;

struct clockgen {
	struct device_node *node;
	void *regs;
	struct clockgen_chipinfo info;
	struct clk *sysclk;
	struct clk *coreclk;
	struct clockgen_pll pll[6];
	struct clk *cmux[8];
	struct clk *hwaccel[5];
	struct clk *fman[2];
	struct ccsr_guts *guts;
};

struct clockgen_sourceinfo {
	u32 flags;
	int pll;
	int div;
};

struct clockgen_muxinfo {
	struct clockgen_sourceinfo clksel[16];
};

struct ccsr_guts {
	u32 porpllsr;
	u32 porbmsr;
	u32 porimpscr;
	u32 pordevsr;
	u32 pordbgmsr;
	u32 pordevsr2;
	u8 res018[8];
	u32 porcir;
	u8 res024[12];
	u32 gpiocr;
	u8 res034[12];
	u32 gpoutdr;
	u8 res044[12];
	u32 gpindr;
	u8 res054[12];
	u32 pmuxcr;
	u32 pmuxcr2;
	u32 dmuxcr;
	u8 res06c[4];
	u32 devdisr;
	u32 devdisr2;
	u8 res078[4];
	u32 pmjcr;
	u32 powmgtcsr;
	u32 pmrccr;
	u32 pmpdccr;
	u32 pmcdr;
	u32 mcpsumr;
	u32 rstrscr;
	u32 ectrstcr;
	u32 autorstsr;
	u32 pvr;
	u32 svr;
	u8 res0a8[8];
	u32 rstcr;
	u8 res0b4[12];
	u32 iovselsr;
	u8 res0c4[60];
	u32 rcwsr[16];
	u8 res140[228];
	u32 iodelay1;
	u32 iodelay2;
	u8 res22c[984];
	u32 pamubypenr;
	u8 res608[504];
	u32 clkdvdr;
	u8 res804[252];
	u32 ircr;
	u8 res904[4];
	u32 dmacr;
	u8 res90c[8];
	u32 elbccr;
	u8 res918[520];
	u32 ddr1clkdr;
	u32 ddr2clkdr;
	u32 ddrclkdr;
	u8 resb2c[724];
	u32 clkocr;
	u8 rese04[12];
	u32 ddrdllcr;
	u8 rese14[12];
	u32 lbcdllcr;
	u32 cpfor;
	u8 rese28[220];
	u32 srds1cr0;
	u32 srds1cr1;
	u8 resf0c[32];
	u32 itcr;
	u8 resf30[16];
	u32 srds2cr0;
	u32 srds2cr1;
};

struct mux_hwclock {
	struct clk_hw hw;
	struct clockgen *cg;
	const struct clockgen_muxinfo *info;
	u32 *reg;
	u8 parent_to_clksel[16];
	s8 clksel_to_parent[16];
	int num_parents;
};

struct mtk_pll_div_table;

struct mtk_pll_data {
	int id;
	const char *name;
	u32 reg;
	u32 pwr_reg;
	u32 en_mask;
	u32 pd_reg;
	u32 tuner_reg;
	u32 tuner_en_reg;
	u8 tuner_en_bit;
	int pd_shift;
	unsigned int flags;
	const struct clk_ops *ops;
	u32 rst_bar_mask;
	unsigned long fmin;
	unsigned long fmax;
	int pcwbits;
	int pcwibits;
	u32 pcw_reg;
	int pcw_shift;
	u32 pcw_chg_reg;
	const struct mtk_pll_div_table *div_table;
	const char *parent_name;
	u32 en_reg;
	u8 pll_en_bit;
};

struct mtk_pll_div_table {
	u32 div;
	unsigned long freq;
};

struct qcom_reset_map;

struct gdsc;

struct qcom_cc_desc {
	const struct regmap_config *config;
	struct clk_regmap **clks;
	size_t num_clks;
	const struct qcom_reset_map *resets;
	size_t num_resets;
	struct gdsc **gdscs;
	size_t num_gdscs;
	struct clk_hw **clk_hws;
	size_t num_clk_hws;
};

struct qcom_reset_map {
	unsigned int reg;
	u8 bit;
	u8 udelay;
	u32 bitmask;
};

struct gdsc {
	struct generic_pm_domain pd;
	struct generic_pm_domain *parent;
	struct regmap *regmap;
	unsigned int gdscr;
	unsigned int collapse_ctrl;
	unsigned int collapse_mask;
	unsigned int gds_hw_ctrl;
	unsigned int clamp_io_ctrl;
	unsigned int *cxcs;
	unsigned int cxc_count;
	unsigned int en_rest_wait_val;
	unsigned int en_few_wait_val;
	unsigned int clk_dis_wait_val;
	const u8 pwrsts;
	const u16 flags;
	struct reset_controller_dev *rcdev;
	unsigned int *resets;
	unsigned int reset_count;
	const char *supply;
	struct regulator *rsupply;
};

struct pll_vco;

struct clk_alpha_pll {
	u32 offset;
	const u8 *regs;
	const struct pll_vco *vco_table;
	size_t num_vco;
	u8 flags;
	struct clk_regmap clkr;
};

struct pll_vco {
	unsigned long min_freq;
	unsigned long max_freq;
	u32 val;
};

struct clk_alpha_pll_postdiv {
	u32 offset;
	u8 width;
	const u8 *regs;
	struct clk_regmap clkr;
	int post_div_shift;
	const struct clk_div_table *post_div_table;
	size_t num_post_div;
};

struct parent_map;

struct freq_tbl;

struct clk_rcg2 {
	u32 cmd_rcgr;
	u8 mnd_width;
	u8 hid_width;
	u8 safe_src_index;
	const struct parent_map *parent_map;
	const struct freq_tbl *freq_tbl;
	struct clk_regmap clkr;
	u8 cfg_off;
	u32 parked_cfg;
	bool hw_clk_ctrl;
};

struct parent_map {
	u8 src;
	u8 cfg;
};

struct freq_tbl {
	unsigned long freq;
	u8 src;
	u8 pre_div;
	u16 m;
	u16 n;
};

struct clk_fixed_factor {
	struct clk_hw hw;
	unsigned int mult;
	unsigned int div;
};

struct clk_branch {
	u32 hwcg_reg;
	u32 halt_reg;
	u8 hwcg_bit;
	u8 halt_bit;
	u8 halt_check;
	struct clk_regmap clkr;
};

struct alpha_pll_config {
	u32 l;
	u32 alpha;
	u32 alpha_hi;
	u32 config_ctl_val;
	u32 config_ctl_hi_val;
	u32 config_ctl_hi1_val;
	u32 user_ctl_val;
	u32 user_ctl_hi_val;
	u32 user_ctl_hi1_val;
	u32 test_ctl_val;
	u32 test_ctl_mask;
	u32 test_ctl_hi_val;
	u32 test_ctl_hi_mask;
	u32 test_ctl_hi1_val;
	u32 test_ctl_hi2_val;
	u32 main_output_mask;
	u32 aux_output_mask;
	u32 aux2_output_mask;
	u32 early_output_mask;
	u32 alpha_en_mask;
	u32 alpha_mode_mask;
	u32 pre_div_val;
	u32 pre_div_mask;
	u32 post_div_val;
	u32 post_div_mask;
	u32 vco_val;
	u32 vco_mask;
	u32 status_val;
	u32 status_mask;
	u32 lock_det;
};

enum rockchip_pll_type {
	pll_rk3036 = 0,
	pll_rk3066 = 1,
	pll_rk3328 = 2,
	pll_rk3399 = 3,
	pll_rk3588 = 4,
	pll_rk3588_core = 5,
};

struct clk_mux {
	struct clk_hw hw;
	void *reg;
	const u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct rockchip_pll_rate_table;

struct rockchip_clk_provider;

struct rockchip_clk_pll {
	struct clk_hw hw;
	struct clk_mux pll_mux;
	const struct clk_ops *pll_mux_ops;
	struct notifier_block clk_nb;
	void *reg_base;
	int lock_offset;
	unsigned int lock_shift;
	enum rockchip_pll_type type;
	u8 flags;
	const struct rockchip_pll_rate_table *rate_table;
	unsigned int rate_count;
	spinlock_t *lock;
	struct rockchip_clk_provider *ctx;
};

struct rockchip_pll_rate_table {
	unsigned long rate;
	union {
		struct {
			unsigned int nr;
			unsigned int nf;
			unsigned int no;
			unsigned int nb;
		};
		struct {
			unsigned int fbdiv;
			unsigned int postdiv1;
			unsigned int refdiv;
			unsigned int postdiv2;
			unsigned int dsmpd;
			unsigned int frac;
		};
		struct {
			unsigned int m;
			unsigned int p;
			unsigned int s;
			unsigned int k;
		};
	};
};

struct rockchip_clk_provider {
	void *reg_base;
	struct clk_onecell_data clk_data;
	struct device_node *cru_node;
	struct regmap *grf;
	spinlock_t lock;
};

struct exynos_audss_clk_drvdata {
	unsigned int has_adma_clk: 1;
	unsigned int has_mst_clk: 1;
	unsigned int enable_epll: 1;
	unsigned int num_clks;
};

struct ccu_gate {
	u32 enable;
	struct ccu_common common;
};

struct ccu_mult_internal {
	u8 offset;
	u8 shift;
	u8 width;
	u8 min;
	u8 max;
};

struct ccu_div_internal {
	u8 shift;
	u8 width;
	u32 max;
	u32 offset;
	u32 flags;
	struct clk_div_table *table;
};

struct ccu_mux_fixed_prediv;

struct ccu_mux_var_prediv;

struct ccu_mux_internal {
	u8 shift;
	u8 width;
	const u8 *table;
	const struct ccu_mux_fixed_prediv *fixed_predivs;
	u8 n_predivs;
	const struct ccu_mux_var_prediv *var_predivs;
	u8 n_var_predivs;
};

struct ccu_nkm {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	struct ccu_div_internal m;
	struct ccu_mux_internal mux;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct ccu_mux_fixed_prediv {
	u8 index;
	u16 div;
};

struct ccu_mux_var_prediv {
	u8 index;
	u8 shift;
	u8 width;
};

struct _ccu_nkm {
	unsigned long n;
	unsigned long min_n;
	unsigned long max_n;
	unsigned long k;
	unsigned long min_k;
	unsigned long max_k;
	unsigned long m;
	unsigned long min_m;
	unsigned long max_m;
};

struct ccu_frac_internal {
	u32 enable;
	u32 select;
	unsigned long rates[2];
};

struct ccu_mult {
	u32 enable;
	u32 lock;
	struct ccu_frac_internal frac;
	struct ccu_mult_internal mult;
	struct ccu_mux_internal mux;
	struct ccu_common common;
};

struct ccu_nkmp {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	struct ccu_div_internal m;
	struct ccu_div_internal p;
	unsigned int fixed_post_div;
	unsigned int max_rate;
	struct ccu_common common;
};

struct ccu_sdm_setting;

struct ccu_sdm_internal {
	struct ccu_sdm_setting *table;
	u32 table_size;
	u32 enable;
	u32 tuning_enable;
	u16 tuning_reg;
};

struct ccu_nm {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_div_internal m;
	struct ccu_frac_internal frac;
	struct ccu_sdm_internal sdm;
	unsigned int fixed_post_div;
	unsigned int min_rate;
	unsigned int max_rate;
	struct ccu_common common;
};

struct ccu_sdm_setting {
	unsigned long rate;
	u32 pattern;
	u32 m;
	u32 n;
};

struct ccu_mux {
	u32 enable;
	struct ccu_mux_internal mux;
	struct ccu_common common;
};

struct ccu_div {
	u32 enable;
	struct ccu_div_internal div;
	struct ccu_mux_internal mux;
	struct ccu_common common;
	unsigned int fixed_post_div;
};

struct ccu_mp {
	u32 enable;
	struct ccu_div_internal m;
	struct ccu_div_internal p;
	struct ccu_mux_internal mux;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct visconti_reset_data {
	u32 rson_offset;
	u32 rsoff_offset;
	u8 rs_idx;
};

struct visconti_fixed_clk {
	unsigned int id;
	const char *name;
	const char *parent;
	unsigned long flag;
	unsigned int mult;
	unsigned int div;
};

struct visconti_clk_gate_table {
	unsigned int id;
	const char *name;
	const struct clk_parent_data *parent_data;
	u8 num_parents;
	u8 flags;
	u32 ckon_offset;
	u32 ckoff_offset;
	u8 ck_idx;
	unsigned int div;
	u8 rs_id;
};

struct visconti_clk_provider {
	struct device *dev;
	struct regmap *regmap;
	struct clk_hw_onecell_data clk_data;
};

typedef void (*btf_trace_tegra_dma_tx_status)(void *, struct dma_chan *, dma_cookie_t, struct dma_tx_state *);

typedef void (*btf_trace_tegra_dma_complete_cb)(void *, struct dma_chan *, int, void *);

typedef void (*btf_trace_tegra_dma_isr)(void *, struct dma_chan *, int);

struct tegra_dma_chip_data {
	unsigned int nr_channels;
	unsigned int channel_reg_size;
	unsigned int max_dma_count;
	bool support_channel_pause;
	bool support_separate_wcount_reg;
};

struct trace_event_raw_tegra_dma_tx_status {
	struct trace_entry ent;
	u32 __data_loc_chan;
	dma_cookie_t cookie;
	__u32 residue;
	char __data[0];
};

struct trace_event_raw_tegra_dma_complete_cb {
	struct trace_entry ent;
	u32 __data_loc_chan;
	int count;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_tegra_dma_isr {
	struct trace_entry ent;
	u32 __data_loc_chan;
	int irq;
	char __data[0];
};

struct tegra_dma_channel;

typedef void (*dma_isr_handler)(struct tegra_dma_channel *, bool);

struct tegra_dma_channel_regs {
	u32 csr;
	u32 ahb_ptr;
	u32 apb_ptr;
	u32 ahb_seq;
	u32 apb_seq;
	u32 wcount;
};

struct tegra_dma;

struct tegra_dma_channel {
	struct dma_chan dma_chan;
	char name[12];
	bool config_init;
	unsigned int id;
	void *chan_addr;
	spinlock_t lock;
	bool busy;
	struct tegra_dma *tdma;
	bool cyclic;
	struct list_head free_sg_req;
	struct list_head pending_sg_req;
	struct list_head free_dma_desc;
	struct list_head cb_desc;
	dma_isr_handler isr_handler;
	struct tasklet_struct tasklet;
	unsigned int slave_id;
	struct dma_slave_config dma_sconfig;
	struct tegra_dma_channel_regs channel_reg;
	struct wait_queue_head wq;
};

struct tegra_dma {
	struct dma_device dma_dev;
	struct device *dev;
	struct clk *dma_clk;
	struct reset_control *rst;
	spinlock_t global_lock;
	void *base_addr;
	const struct tegra_dma_chip_data *chip_data;
	u32 global_pause_count;
	struct tegra_dma_channel channels[0];
};

struct tegra_dma_desc {
	struct dma_async_tx_descriptor txd;
	unsigned int bytes_requested;
	unsigned int bytes_transferred;
	enum dma_status dma_status;
	struct list_head node;
	struct list_head tx_list;
	struct list_head cb_node;
	unsigned int cb_count;
};

struct tegra_dma_sg_req {
	struct tegra_dma_channel_regs ch_regs;
	unsigned int req_len;
	bool configured;
	bool last_sg;
	struct list_head node;
	struct tegra_dma_desc *dma_desc;
	unsigned int words_xferred;
};

struct trace_event_data_offsets_tegra_dma_tx_status {
	u32 chan;
};

struct trace_event_data_offsets_tegra_dma_complete_cb {
	u32 chan;
};

struct trace_event_data_offsets_tegra_dma_isr {
	u32 chan;
};

struct tegra_cbb_ops;

struct tegra_cbb {
	struct device *dev;
	const struct tegra_cbb_ops *ops;
	struct list_head node;
};

struct tegra_cbb_ops {
	int (*debugfs_show)(struct tegra_cbb *, struct seq_file *, void *);
	int (*interrupt_enable)(struct tegra_cbb *);
	void (*error_enable)(struct tegra_cbb *);
	void (*fault_enable)(struct tegra_cbb *);
	void (*stall_enable)(struct tegra_cbb *);
	void (*error_clear)(struct tegra_cbb *);
	u32 (*get_status)(struct tegra_cbb *);
};

struct bcm_pmb_pd_data {
	const char * const name;
	int id;
	u8 bus;
	u8 device;
};

struct bcm_pmb;

struct bcm_pmb_pm_domain {
	struct bcm_pmb *pmb;
	const struct bcm_pmb_pd_data *data;
	struct generic_pm_domain genpd;
};

struct bcm_pmb {
	struct device *dev;
	void *base;
	spinlock_t lock;
	bool little_endian;
	struct genpd_onecell_data genpd_onecell_data;
};

struct exynos_pm_domain_config {
	u32 local_pwr_cfg;
};

struct exynos_pm_domain {
	void *base;
	struct generic_pm_domain pd;
	u32 local_pwr_cfg;
};

typedef uint32_t evtchn_port_t;

struct evtchn_loop_ctrl;

struct evtchn_ops {
	unsigned int (*max_channels)();
	unsigned int (*nr_channels)();
	int (*setup)(evtchn_port_t);
	void (*remove)(evtchn_port_t, unsigned int);
	void (*bind_to_cpu)(evtchn_port_t, unsigned int, unsigned int);
	void (*clear_pending)(evtchn_port_t);
	void (*set_pending)(evtchn_port_t);
	bool (*is_pending)(evtchn_port_t);
	void (*mask)(evtchn_port_t);
	void (*unmask)(evtchn_port_t);
	void (*handle_events)(unsigned int, struct evtchn_loop_ctrl *);
	void (*resume)();
	int (*percpu_init)(unsigned int);
	int (*percpu_deinit)(unsigned int);
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

struct arch_vcpu_info {};

struct pvclock_vcpu_time_info {
	u32 version;
	u32 pad0;
	u64 tsc_timestamp;
	u64 system_time;
	u32 tsc_to_system_mul;
	s8 tsc_shift;
	u8 flags;
	u8 pad[2];
};

struct vcpu_info {
	uint8_t evtchn_upcall_pending;
	uint8_t evtchn_upcall_mask;
	xen_ulong_t evtchn_pending_sel;
	struct arch_vcpu_info arch;
	struct pvclock_vcpu_time_info time;
};

struct pvclock_wall_clock {
	u32 version;
	u32 sec;
	u32 nsec;
	u32 sec_hi;
};

struct arch_shared_info {};

struct shared_info {
	struct vcpu_info vcpu_info[1];
	xen_ulong_t evtchn_pending[64];
	xen_ulong_t evtchn_mask[64];
	struct pvclock_wall_clock wc;
	uint32_t wc_sec_hi;
	struct arch_shared_info arch;
};

struct evtchn_unmask {
	evtchn_port_t port;
};

struct regulator_consumer_supply {
	const char *dev_name;
	const char *supply;
};

struct cros_ec_device;

struct cros_ec_regulator_data {
	struct regulator_desc desc;
	struct regulator_dev *dev;
	struct cros_ec_device *ec_dev;
	u32 index;
	u16 *voltages_mV;
	u16 num_voltages;
};

struct ec_response_motion_sense_fifo_info {
	uint16_t size;
	uint16_t count;
	uint32_t timestamp;
	uint16_t total_lost;
	uint16_t lost[0];
} __attribute__((packed));

union ec_response_get_next_data_v1 {
	uint8_t key_matrix[16];
	uint32_t host_event;
	uint64_t host_event64;
	struct {
		uint8_t reserved[3];
		struct ec_response_motion_sense_fifo_info info;
	} sensor_fifo;
	uint32_t buttons;
	uint32_t switches;
	uint32_t fp_events;
	uint32_t sysrq;
	uint32_t cec_events;
	uint8_t cec_message[16];
};

struct ec_response_get_next_event_v1 {
	uint8_t event_type;
	union ec_response_get_next_data_v1 data;
} __attribute__((packed));

struct cros_ec_device {
	const char *phys_name;
	struct device *dev;
	struct class *cros_class;
	int (*cmd_readmem)(struct cros_ec_device *, unsigned int, unsigned int, void *);
	u16 max_request;
	u16 max_response;
	u16 max_passthru;
	u16 proto_version;
	void *priv;
	int irq;
	u8 *din;
	u8 *dout;
	int din_size;
	int dout_size;
	bool wake_enabled;
	bool suspended;
	int (*cmd_xfer)(struct cros_ec_device *, struct cros_ec_command *);
	int (*pkt_xfer)(struct cros_ec_device *, struct cros_ec_command *);
	struct lock_class_key lockdep_key;
	struct mutex lock;
	u8 mkbp_event_supported;
	bool host_sleep_v1;
	struct blocking_notifier_head event_notifier;
	struct ec_response_get_next_event_v1 event_data;
	int event_size;
	u32 host_event_wake_mask;
	u32 last_resume_result;
	u16 suspend_timeout_ms;
	ktime_t last_event_time;
	struct notifier_block notifier_ready;
	struct platform_device *ec;
	struct platform_device *pd;
	struct blocking_notifier_head panic_notifier;
};

struct ec_params_regulator_get_info {
	uint32_t index;
};

struct ec_response_regulator_get_info {
	char name[16];
	uint16_t num_voltages;
	uint16_t voltages_mv[16];
};

struct ec_params_regulator_set_voltage {
	uint32_t index;
	uint32_t min_mv;
	uint32_t max_mv;
};

struct ec_params_regulator_get_voltage {
	uint32_t index;
};

struct ec_response_regulator_get_voltage {
	uint32_t voltage_mv;
};

struct ec_params_regulator_enable {
	uint32_t index;
	uint8_t enable;
} __attribute__((packed));

struct ec_params_regulator_is_enabled {
	uint32_t index;
};

struct ec_response_regulator_is_enabled {
	uint8_t enabled;
};

struct mt6358_regulator_info {
	struct regulator_desc desc;
	u32 status_reg;
	u32 qi;
	u32 da_vsel_reg;
	u32 da_vsel_mask;
	u32 modeset_reg;
	u32 modeset_mask;
};

enum chip_id {
	MT6323_CHIP_ID = 35,
	MT6331_CHIP_ID = 32,
	MT6332_CHIP_ID = 32,
	MT6357_CHIP_ID = 87,
	MT6358_CHIP_ID = 88,
	MT6359_CHIP_ID = 89,
	MT6366_CHIP_ID = 102,
	MT6391_CHIP_ID = 145,
	MT6397_CHIP_ID = 151,
};

enum {
	MT6358_ID_VDRAM1 = 0,
	MT6358_ID_VCORE = 1,
	MT6358_ID_VPA = 2,
	MT6358_ID_VPROC11 = 3,
	MT6358_ID_VPROC12 = 4,
	MT6358_ID_VGPU = 5,
	MT6358_ID_VS2 = 6,
	MT6358_ID_VMODEM = 7,
	MT6358_ID_VS1 = 8,
	MT6358_ID_VDRAM2 = 9,
	MT6358_ID_VSIM1 = 10,
	MT6358_ID_VIBR = 11,
	MT6358_ID_VRF12 = 12,
	MT6358_ID_VIO18 = 13,
	MT6358_ID_VUSB = 14,
	MT6358_ID_VCAMIO = 15,
	MT6358_ID_VCAMD = 16,
	MT6358_ID_VCN18 = 17,
	MT6358_ID_VFE28 = 18,
	MT6358_ID_VSRAM_PROC11 = 19,
	MT6358_ID_VCN28 = 20,
	MT6358_ID_VSRAM_OTHERS = 21,
	MT6358_ID_VSRAM_GPU = 22,
	MT6358_ID_VXO22 = 23,
	MT6358_ID_VEFUSE = 24,
	MT6358_ID_VAUX18 = 25,
	MT6358_ID_VMCH = 26,
	MT6358_ID_VBIF28 = 27,
	MT6358_ID_VSRAM_PROC12 = 28,
	MT6358_ID_VCAMA1 = 29,
	MT6358_ID_VEMC = 30,
	MT6358_ID_VIO28 = 31,
	MT6358_ID_VA12 = 32,
	MT6358_ID_VRF18 = 33,
	MT6358_ID_VCN33 = 34,
	MT6358_ID_VCAMA2 = 35,
	MT6358_ID_VMC = 36,
	MT6358_ID_VLDO28 = 37,
	MT6358_ID_VAUD28 = 38,
	MT6358_ID_VSIM2 = 39,
	MT6358_ID_RG_MAX = 40,
};

enum {
	MT6366_ID_VDRAM1 = 0,
	MT6366_ID_VCORE = 1,
	MT6366_ID_VPA = 2,
	MT6366_ID_VPROC11 = 3,
	MT6366_ID_VPROC12 = 4,
	MT6366_ID_VGPU = 5,
	MT6366_ID_VS2 = 6,
	MT6366_ID_VMODEM = 7,
	MT6366_ID_VS1 = 8,
	MT6366_ID_VDRAM2 = 9,
	MT6366_ID_VSIM1 = 10,
	MT6366_ID_VIBR = 11,
	MT6366_ID_VRF12 = 12,
	MT6366_ID_VIO18 = 13,
	MT6366_ID_VUSB = 14,
	MT6366_ID_VCN18 = 15,
	MT6366_ID_VFE28 = 16,
	MT6366_ID_VSRAM_PROC11 = 17,
	MT6366_ID_VCN28 = 18,
	MT6366_ID_VSRAM_OTHERS = 19,
	MT6366_ID_VSRAM_GPU = 20,
	MT6366_ID_VXO22 = 21,
	MT6366_ID_VEFUSE = 22,
	MT6366_ID_VAUX18 = 23,
	MT6366_ID_VMCH = 24,
	MT6366_ID_VBIF28 = 25,
	MT6366_ID_VSRAM_PROC12 = 26,
	MT6366_ID_VEMC = 27,
	MT6366_ID_VIO28 = 28,
	MT6366_ID_VA12 = 29,
	MT6366_ID_VRF18 = 30,
	MT6366_ID_VCN33 = 31,
	MT6366_ID_VMC = 32,
	MT6366_ID_VAUD28 = 33,
	MT6366_ID_VSIM2 = 34,
	MT6366_ID_VM18 = 35,
	MT6366_ID_VMDDR = 36,
	MT6366_ID_VSRAM_CORE = 37,
	MT6366_ID_RG_MAX = 38,
};

enum regulator_status {
	REGULATOR_STATUS_OFF = 0,
	REGULATOR_STATUS_ON = 1,
	REGULATOR_STATUS_ERROR = 2,
	REGULATOR_STATUS_FAST = 3,
	REGULATOR_STATUS_NORMAL = 4,
	REGULATOR_STATUS_IDLE = 5,
	REGULATOR_STATUS_STANDBY = 6,
	REGULATOR_STATUS_BYPASS = 7,
	REGULATOR_STATUS_UNDEFINED = 8,
};

struct mt6397_chip {
	struct device *dev;
	struct regmap *regmap;
	struct notifier_block pm_nb;
	int irq;
	struct irq_domain *irq_domain;
	struct mutex irqlock;
	u16 wake_mask[2];
	u16 irq_masks_cur[2];
	u16 irq_masks_cache[2];
	u16 int_con[2];
	u16 int_status[2];
	u16 chip_id;
	void *irq_data;
};

struct tps65219_regulator_irq_type {
	const char *irq_name;
	const char *regulator_name;
	const char *event_name;
	unsigned long event;
};

struct tps65219 {
	struct device *dev;
	struct regmap *regmap;
	struct regmap_irq_chip_data *irq_data;
	struct notifier_block nb;
};

struct tps65219_regulator_irq_data {
	struct device *dev;
	struct tps65219_regulator_irq_type *type;
	struct regulator_dev *rdev;
};

enum translation_map {
	LAT1_MAP = 0,
	GRAF_MAP = 1,
	IBMPC_MAP = 2,
	USER_MAP = 3,
	FIRST_MAP = 0,
	LAST_MAP = 3,
};

struct uni_pagedict {
	u16 **uni_pgdir[32];
	unsigned long refcount;
	unsigned long sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

typedef unsigned short ushort;

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_mode {
	char mode;
	char waitv;
	short relsig;
	short acqsig;
	short frsig;
};

struct consw;

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	unsigned short vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	unsigned int vc_cell_height;
	unsigned long vc_origin;
	unsigned long vc_scr_end;
	unsigned long vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	unsigned short *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	unsigned short vc_complement_mask;
	unsigned short vc_s_complement_mask;
	unsigned long vc_pos;
	unsigned short vc_hi_font_mask;
	struct console_font vc_font;
	unsigned short vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	unsigned long vc_tab_stop[4];
	unsigned char vc_palette[48];
	unsigned short *vc_translate;
	unsigned int vc_resize_user;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	unsigned short vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedict *uni_pagedict;
	struct uni_pagedict **uni_pagedict_loc;
	u32 **vc_uni_lines;
};

struct consw {
	struct module *owner;
	const char * (*con_startup)();
	void (*con_init)(struct vc_data *, int);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, int, int, int, int);
	void (*con_putc)(struct vc_data *, int, int, int);
	void (*con_putcs)(struct vc_data *, const unsigned short *, int, int, int);
	void (*con_cursor)(struct vc_data *, int);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	int (*con_switch)(struct vc_data *);
	int (*con_blank)(struct vc_data *, int, int);
	int (*con_font_set)(struct vc_data *, struct console_font *, unsigned int, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_default)(struct vc_data *, struct console_font *, char *);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	int (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	u16 * (*con_screen_pos)(const struct vc_data *, int);
	unsigned long (*con_getxy)(struct vc_data *, unsigned long, int *, int *);
	void (*con_flush_scrollback)(struct vc_data *);
	int (*con_debug_enter)(struct vc_data *);
	int (*con_debug_leave)(struct vc_data *);
};

typedef unsigned short u_short;

struct unipair {
	unsigned short unicode;
	unsigned short fontpos;
};

struct mctrl_gpios;

struct uart_8250_dma;

struct uart_8250_ops;

struct uart_8250_em485;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	u16 bugs;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	u16 lsr_saved_flags;
	u16 lsr_save_mask;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	u32 (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, u32);
	struct uart_8250_em485 *em485;
	void (*rs485_start_tx)(struct uart_8250_port *);
	void (*rs485_stop_tx)(struct uart_8250_port *);
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	void (*prepare_tx_dma)(struct uart_8250_port *);
	void (*prepare_rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan *rxchan;
	struct dma_chan *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
	void (*setup_timer)(struct uart_8250_port *);
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
	unsigned int tx_stopped: 1;
};

struct serial8250_em_priv {
	int line;
};

struct earlycon_device;

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[32];
	unsigned int baud;
};

struct sci_port_params;

struct plat_sci_port;

struct sci_port {
	struct uart_port port;
	const struct sci_port_params *params;
	const struct plat_sci_port *cfg;
	unsigned int sampling_rate_mask;
	resource_size_t reg_size;
	struct mctrl_gpios *gpios;
	struct clk *clks[4];
	unsigned long clk_rates[4];
	int irqs[6];
	char *irqstr[6];
	struct dma_chan *chan_tx;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_tx_saved;
	struct dma_chan *chan_rx_saved;
	dma_cookie_t cookie_tx;
	dma_cookie_t cookie_rx[2];
	dma_cookie_t active_rx;
	dma_addr_t tx_dma_addr;
	unsigned int tx_dma_len;
	struct scatterlist sg_rx[2];
	void *rx_buf[2];
	size_t buf_len_rx;
	struct work_struct work_tx;
	struct hrtimer rx_timer;
	unsigned int rx_timeout;
	unsigned int rx_frame;
	int rx_trigger;
	struct timer_list rx_fifo_timer;
	int rx_fifo_timeout;
	u16 hscif_tot;
	bool has_rtscts;
	bool autorts;
};

struct plat_sci_reg {
	u8 offset;
	u8 size;
};

struct sci_port_params {
	const struct plat_sci_reg regs[20];
	unsigned int fifosize;
	unsigned int overrun_reg;
	unsigned int overrun_mask;
	unsigned int sampling_rate_mask;
	unsigned int error_mask;
	unsigned int error_clear;
};

struct plat_sci_port_ops;

struct plat_sci_port {
	unsigned int type;
	upf_t flags;
	unsigned int sampling_rate;
	unsigned int scscr;
	unsigned char regtype;
	struct plat_sci_port_ops *ops;
};

struct plat_sci_port_ops {
	void (*init_pins)(struct uart_port *, unsigned int);
};

struct sci_irq_desc {
	const char *desc;
	irq_handler_t handler;
};

enum mctrl_gpio_idx {
	UART_GPIO_CTS = 0,
	UART_GPIO_DSR = 1,
	UART_GPIO_DCD = 2,
	UART_GPIO_RNG = 3,
	UART_GPIO_RI = 3,
	UART_GPIO_RTS = 4,
	UART_GPIO_DTR = 5,
	UART_GPIO_MAX = 6,
};

enum {
	SCIx_ERI_IRQ = 0,
	SCIx_RXI_IRQ = 1,
	SCIx_TXI_IRQ = 2,
	SCIx_BRI_IRQ = 3,
	SCIx_DRI_IRQ = 4,
	SCIx_TEI_IRQ = 5,
	SCIx_NR_IRQS = 6,
	SCIx_MUX_IRQ = 6,
};

enum {
	SCIx_PROBE_REGTYPE = 0,
	SCIx_SCI_REGTYPE = 1,
	SCIx_IRDA_REGTYPE = 2,
	SCIx_SCIFA_REGTYPE = 3,
	SCIx_SCIFB_REGTYPE = 4,
	SCIx_SH2_SCIF_FIFODATA_REGTYPE = 5,
	SCIx_SH3_SCIF_REGTYPE = 6,
	SCIx_SH4_SCIF_REGTYPE = 7,
	SCIx_SH4_SCIF_BRG_REGTYPE = 8,
	SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE = 9,
	SCIx_SH4_SCIF_FIFODATA_REGTYPE = 10,
	SCIx_SH7705_SCIF_REGTYPE = 11,
	SCIx_HSCIF_REGTYPE = 12,
	SCIx_RZ_SCIFA_REGTYPE = 13,
	SCIx_NR_REGTYPES = 14,
};

enum {
	SCSMR = 0,
	SCBRR = 1,
	SCSCR = 2,
	SCxSR = 3,
	SCFCR = 4,
	SCFDR = 5,
	SCxTDR = 6,
	SCxRDR = 7,
	SCLSR = 8,
	SCTFDR = 9,
	SCRFDR = 10,
	SCSPTR = 11,
	HSSRR = 12,
	SCPCR = 13,
	SCPDR = 14,
	SCDL = 15,
	SCCKS = 16,
	HSRTRGR = 17,
	HSTTRGR = 18,
	SEMR = 19,
	SCIx_NR_REGS = 20,
};

enum SCI_CLKS {
	SCI_FCK = 0,
	SCI_SCK = 1,
	SCI_BRG_INT = 2,
	SCI_SCIF_CLK = 3,
	SCI_NUM_CLKS = 4,
};

enum tpm_chip_flags {
	TPM_CHIP_FLAG_BOOTSTRAPPED = 1,
	TPM_CHIP_FLAG_TPM2 = 2,
	TPM_CHIP_FLAG_IRQ = 4,
	TPM_CHIP_FLAG_VIRTUAL = 8,
	TPM_CHIP_FLAG_HAVE_TIMEOUTS = 16,
	TPM_CHIP_FLAG_ALWAYS_POWERED = 32,
	TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED = 64,
	TPM_CHIP_FLAG_FIRMWARE_UPGRADE = 128,
	TPM_CHIP_FLAG_SUSPENDED = 256,
	TPM_CHIP_FLAG_HWRNG_DISABLED = 512,
};

enum tpm2_timeouts {
	TPM2_TIMEOUT_A = 750,
	TPM2_TIMEOUT_B = 2000,
	TPM2_TIMEOUT_C = 200,
	TPM2_TIMEOUT_D = 30,
	TPM2_DURATION_SHORT = 20,
	TPM2_DURATION_MEDIUM = 750,
	TPM2_DURATION_LONG = 2000,
	TPM2_DURATION_LONG_LONG = 300000,
	TPM2_DURATION_DEFAULT = 120000,
};

enum TPM_OPS_FLAGS {
	TPM_OPS_AUTO_STARTUP = 1,
};

enum tpm2_startup_types {
	TPM2_SU_CLEAR = 0,
	TPM2_SU_STATE = 1,
};

enum tpm_timeout {
	TPM_TIMEOUT = 5,
	TPM_TIMEOUT_RETRY = 100,
	TPM_TIMEOUT_RANGE_US = 300,
	TPM_TIMEOUT_POLL = 1,
	TPM_TIMEOUT_USECS_MIN = 100,
	TPM_TIMEOUT_USECS_MAX = 500,
};

struct tpm_digest {
	u16 alg_id;
	u8 digest[64];
};

typedef u32 arm_v7s_iopte;

struct arm_v7s_io_pgtable {
	struct io_pgtable iop;
	arm_v7s_iopte *pgd;
	struct kmem_cache *l2_tables;
	spinlock_t split_lock;
};

struct regmap_irq_sub_irq_map;

struct regmap_irq;

struct regmap_irq_chip {
	const char *name;
	unsigned int main_status;
	unsigned int num_main_status_bits;
	struct regmap_irq_sub_irq_map *sub_reg_offsets;
	int num_main_regs;
	unsigned int status_base;
	unsigned int mask_base;
	unsigned int unmask_base;
	unsigned int ack_base;
	unsigned int wake_base;
	const unsigned int *config_base;
	unsigned int irq_reg_stride;
	unsigned int init_ack_masked: 1;
	unsigned int mask_unmask_non_inverted: 1;
	unsigned int use_ack: 1;
	unsigned int ack_invert: 1;
	unsigned int clear_ack: 1;
	unsigned int status_invert: 1;
	unsigned int wake_invert: 1;
	unsigned int type_in_mask: 1;
	unsigned int clear_on_unmask: 1;
	unsigned int runtime_pm: 1;
	unsigned int no_status: 1;
	int num_regs;
	const struct regmap_irq *irqs;
	int num_irqs;
	int num_config_bases;
	int num_config_regs;
	int (*handle_pre_irq)(void *);
	int (*handle_post_irq)(void *);
	int (*handle_mask_sync)(int, unsigned int, unsigned int, void *);
	int (*set_type_config)(unsigned int **, unsigned int, const struct regmap_irq *, int, void *);
	unsigned int (*get_irq_reg)(struct regmap_irq_chip_data *, unsigned int, int);
	void *irq_drv_data;
};

struct regmap_irq_sub_irq_map {
	unsigned int num_regs;
	unsigned int *offset;
};

struct regmap_irq_type {
	unsigned int type_reg_offset;
	unsigned int type_reg_mask;
	unsigned int type_rising_val;
	unsigned int type_falling_val;
	unsigned int type_level_low_val;
	unsigned int type_level_high_val;
	unsigned int types_supported;
};

struct regmap_irq {
	unsigned int reg_offset;
	unsigned int mask;
	struct regmap_irq_type type;
};

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

enum scsi_vpd_parameters {
	SCSI_VPD_HEADER_SIZE = 4,
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct scsi_driver {
	struct device_driver gendrv;
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
};

struct scsi_exec_args {
	unsigned char *sense;
	unsigned int sense_len;
	struct scsi_sense_hdr *sshdr;
	blk_mq_req_flags_t req_flags;
	int scmd_flags;
	int *resid;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

enum MR_ADAPTER_TYPE {
	MFI_SERIES = 1,
	THUNDERBOLT_SERIES = 2,
	INVADER_SERIES = 3,
	VENTURA_SERIES = 4,
	AERO_SERIES = 5,
};

enum REGION_TYPE {
	REGION_TYPE_UNUSED = 0,
	REGION_TYPE_SHARED_READ = 1,
	REGION_TYPE_SHARED_WRITE = 2,
	REGION_TYPE_EXCLUSIVE = 3,
};

enum MR_RAID_MAP_DESC_TYPE {
	RAID_MAP_DESC_TYPE_DEVHDL_INFO = 0,
	RAID_MAP_DESC_TYPE_TGTID_INFO = 1,
	RAID_MAP_DESC_TYPE_ARRAY_INFO = 2,
	RAID_MAP_DESC_TYPE_SPAN_INFO = 3,
	RAID_MAP_DESC_TYPE_COUNT = 4,
};

enum MR_RAID_FLAGS_IO_SUB_TYPE {
	MR_RAID_FLAGS_IO_SUB_TYPE_NONE = 0,
	MR_RAID_FLAGS_IO_SUB_TYPE_SYSTEM_PD = 1,
	MR_RAID_FLAGS_IO_SUB_TYPE_RMW_DATA = 2,
	MR_RAID_FLAGS_IO_SUB_TYPE_RMW_P = 3,
	MR_RAID_FLAGS_IO_SUB_TYPE_RMW_Q = 4,
	MR_RAID_FLAGS_IO_SUB_TYPE_CACHE_BYPASS = 6,
	MR_RAID_FLAGS_IO_SUB_TYPE_LDIO_BW_LIMIT = 7,
	MR_RAID_FLAGS_IO_SUB_TYPE_R56_DIV_OFFLOAD = 8,
};

struct RAID_CONTEXT_G35 {
	u16 nseg_type;
	u16 timeout_value;
	u16 routing_flags;
	u16 virtual_disk_tgt_id;
	__le64 reg_lock_row_lba;
	u32 reg_lock_length;
	union {
		u16 rmw_op_index;
		u16 peer_smid;
		u16 r56_arm_map;
	} flow_specific;
	u8 ex_status;
	u8 status;
	u8 raid_flags;
	u8 span_arm;
	u16 config_seq_num;
	union {
		struct {
			u16 num_sge: 12;
			u16 reserved: 3;
			u16 stream_detected: 1;
		} bits;
		u8 bytes[2];
	} u;
	u8 resvd2[2];
};

struct MR_RAID_MAP_DESC_TABLE {
	u32 raid_map_desc_type;
	u32 raid_map_desc_offset;
	u32 raid_map_desc_buffer_size;
	u32 raid_map_desc_elements;
};

struct MR_DEV_HANDLE_INFO {
	__le16 curDevHdl;
	u8 validHandles;
	u8 interfaceType;
	__le16 devHandle[2];
};

struct MR_ARRAY_INFO {
	__le16 pd[32];
};

struct MR_CPU_AFFINITY_MASK {
	union {
		struct {
			u8 hw_path: 1;
			u8 cpu0: 1;
			u8 cpu1: 1;
			u8 cpu2: 1;
			u8 cpu3: 1;
			u8 reserved: 3;
		};
		u8 core_mask;
	};
};

struct MR_IO_AFFINITY {
	union {
		struct {
			struct MR_CPU_AFFINITY_MASK pdRead;
			struct MR_CPU_AFFINITY_MASK pdWrite;
			struct MR_CPU_AFFINITY_MASK ldRead;
			struct MR_CPU_AFFINITY_MASK ldWrite;
		};
		u32 word;
	};
	u8 maxCores;
	u8 reserved[3];
};

struct MR_LD_RAID {
	struct {
		u32 fpCapable: 1;
		u32 ra_capable: 1;
		u32 reserved5: 2;
		u32 ldPiMode: 4;
		u32 pdPiMode: 4;
		u32 encryptionType: 8;
		u32 fpWriteCapable: 1;
		u32 fpReadCapable: 1;
		u32 fpWriteAcrossStripe: 1;
		u32 fpReadAcrossStripe: 1;
		u32 fpNonRWCapable: 1;
		u32 tmCapable: 1;
		u32 fpBypassRegionLock: 1;
		u32 disable_coalescing: 1;
		u32 fp_rmw_capable: 1;
		u32 fp_cache_bypass_capable: 1;
		u32 reserved4: 2;
	} capability;
	__le32 reserved6;
	__le64 size;
	u8 spanDepth;
	u8 level;
	u8 stripeShift;
	u8 rowSize;
	u8 rowDataSize;
	u8 writeMode;
	u8 PRL;
	u8 SRL;
	__le16 targetId;
	u8 ldState;
	u8 regTypeReqOnWrite;
	u8 modFactor;
	u8 regTypeReqOnRead;
	__le16 seqNum;
	struct {
		u32 ldSyncRequired: 1;
		u32 regTypeReqOnReadIsValid: 1;
		u32 isEPD: 1;
		u32 enableSLDOnAllRWIOs: 1;
		u32 reserved: 28;
	} flags;
	u8 LUN[8];
	u8 fpIoTimeoutForLd;
	u8 ld_accept_priority_type;
	u8 reserved2[2];
	u32 logical_block_length;
	struct {
		u32 ld_pi_exp: 4;
		u32 ld_logical_block_exp: 4;
		u32 reserved1: 24;
	};
	struct MR_IO_AFFINITY cpuAffinity;
	u8 reserved3[64];
};

struct MR_LD_SPAN {
	__le64 startBlk;
	__le64 numBlks;
	__le16 arrayRef;
	u8 spanRowSize;
	u8 spanRowDataSize;
	u8 reserved[4];
};

struct MR_QUAD_ELEMENT {
	__le64 logStart;
	__le64 logEnd;
	__le64 offsetInSpan;
	__le32 diff;
	__le32 reserved1;
};

struct MR_SPAN_INFO {
	__le32 noElements;
	__le32 reserved1;
	struct MR_QUAD_ELEMENT quad[8];
};

struct MR_SPAN_BLOCK_INFO {
	__le64 num_rows;
	struct MR_LD_SPAN span;
	struct MR_SPAN_INFO block_span_info;
};

struct MR_LD_SPAN_MAP {
	struct MR_LD_RAID ldRaid;
	u8 dataArmMap[32];
	struct MR_SPAN_BLOCK_INFO spanBlock[8];
};

struct MR_FW_RAID_MAP_EXT {
	u32 reserved;
	union {
		struct {
			u32 maxLd;
			u32 maxSpanDepth;
			u32 maxRowSize;
			u32 maxPdCount;
			u32 maxArrays;
		} validationInfo;
		u32 version[5];
	};
	u8 fpPdIoTimeoutSec;
	u8 reserved2[7];
	__le16 ldCount;
	__le16 arCount;
	__le16 spanCount;
	__le16 reserve3;
	struct MR_DEV_HANDLE_INFO devHndlInfo[256];
	u8 ldTgtIdToLd[256];
	struct MR_ARRAY_INFO arMapInfo[256];
	struct MR_LD_SPAN_MAP ldSpanMap[256];
};

struct MR_FW_RAID_MAP {
	__le32 totalSize;
	union {
		struct {
			__le32 maxLd;
			__le32 maxSpanDepth;
			__le32 maxRowSize;
			__le32 maxPdCount;
			__le32 maxArrays;
		} validationInfo;
		__le32 version[5];
	};
	__le32 ldCount;
	__le32 Reserved1;
	u8 ldTgtIdToLd[128];
	u8 fpPdIoTimeoutSec;
	u8 reserved2[7];
	struct MR_ARRAY_INFO arMapInfo[128];
	struct MR_DEV_HANDLE_INFO devHndlInfo[256];
	struct MR_LD_SPAN_MAP ldSpanMap[0];
};

struct MR_FW_RAID_MAP_ALL {
	struct MR_FW_RAID_MAP raidMap;
	struct MR_LD_SPAN_MAP ldSpanMap[64];
};

struct megasas_pd_list {
	u16 tid;
	u8 driveType;
	u8 driveState;
};

struct megasas_instance;

struct megasas_irq_context {
	char name[32];
	struct megasas_instance *instance;
	u32 MSIxIndex;
	u32 os_irq;
	struct irq_poll irqpoll;
	bool irq_poll_scheduled;
	bool irq_line_enable;
	atomic_t in_used;
};

struct MR_DRV_SYSTEM_INFO;

struct MR_LD_VF_AFFILIATION;

struct MR_LD_VF_AFFILIATION_111;

struct MR_CTRL_HB_HOST_MEM;

struct MR_PD_INFO;

struct MR_TARGET_PROPERTIES;

struct MR_PD_LIST;

struct megasas_ctrl_info;

struct MR_LD_LIST;

struct MR_LD_TARGETID_LIST;

struct MR_HOST_DEVICE_LIST;

struct MR_SNAPDUMP_PROPERTIES;

struct megasas_register_set;

struct megasas_aen_event;

struct megasas_cmd;

struct megasas_evt_detail;

struct megasas_instance_template;

struct megasas_instance {
	unsigned int *reply_map;
	__le32 *producer;
	dma_addr_t producer_h;
	__le32 *consumer;
	dma_addr_t consumer_h;
	struct MR_DRV_SYSTEM_INFO *system_info_buf;
	dma_addr_t system_info_h;
	struct MR_LD_VF_AFFILIATION *vf_affiliation;
	dma_addr_t vf_affiliation_h;
	struct MR_LD_VF_AFFILIATION_111 *vf_affiliation_111;
	dma_addr_t vf_affiliation_111_h;
	struct MR_CTRL_HB_HOST_MEM *hb_host_mem;
	dma_addr_t hb_host_mem_h;
	struct MR_PD_INFO *pd_info;
	dma_addr_t pd_info_h;
	struct MR_TARGET_PROPERTIES *tgt_prop;
	dma_addr_t tgt_prop_h;
	__le32 *reply_queue;
	dma_addr_t reply_queue_h;
	u32 *crash_dump_buf;
	dma_addr_t crash_dump_h;
	struct MR_PD_LIST *pd_list_buf;
	dma_addr_t pd_list_buf_h;
	struct megasas_ctrl_info *ctrl_info_buf;
	dma_addr_t ctrl_info_buf_h;
	struct MR_LD_LIST *ld_list_buf;
	dma_addr_t ld_list_buf_h;
	struct MR_LD_TARGETID_LIST *ld_targetid_list_buf;
	dma_addr_t ld_targetid_list_buf_h;
	struct MR_HOST_DEVICE_LIST *host_device_list_buf;
	dma_addr_t host_device_list_buf_h;
	struct MR_SNAPDUMP_PROPERTIES *snapdump_prop;
	dma_addr_t snapdump_prop_h;
	void *crash_buf[512];
	unsigned int fw_crash_buffer_size;
	unsigned int fw_crash_state;
	unsigned int fw_crash_buffer_offset;
	u32 drv_buf_index;
	u32 drv_buf_alloc;
	u32 crash_dump_fw_support;
	u32 crash_dump_drv_support;
	u32 crash_dump_app_support;
	u32 secure_jbod_support;
	u32 support_morethan256jbod;
	bool use_seqnum_jbod_fp;
	bool smp_affinity_enable;
	struct mutex crashdump_lock;
	struct megasas_register_set *reg_set;
	u32 *reply_post_host_index_addr[16];
	struct megasas_pd_list pd_list[256];
	struct megasas_pd_list local_pd_list[256];
	u8 ld_ids[256];
	u8 ld_tgtid_status[256];
	u8 ld_ids_prev[256];
	u8 ld_ids_from_raidmap[256];
	s8 init_id;
	u16 max_num_sge;
	u16 max_fw_cmds;
	u16 max_mpt_cmds;
	u16 max_mfi_cmds;
	u16 max_scsi_cmds;
	u16 ldio_threshold;
	u16 cur_can_queue;
	u32 max_sectors_per_req;
	bool msix_load_balance;
	struct megasas_aen_event *ev;
	struct megasas_cmd **cmd_list;
	struct list_head cmd_pool;
	spinlock_t mfi_pool_lock;
	spinlock_t hba_lock;
	spinlock_t stream_lock;
	spinlock_t completion_lock;
	struct dma_pool *frame_dma_pool;
	struct dma_pool *sense_dma_pool;
	struct megasas_evt_detail *evt_detail;
	dma_addr_t evt_detail_h;
	struct megasas_cmd *aen_cmd;
	struct semaphore ioctl_sem;
	struct Scsi_Host *host;
	wait_queue_head_t int_cmd_wait_q;
	wait_queue_head_t abort_cmd_wait_q;
	struct pci_dev *pdev;
	u32 unique_id;
	u32 fw_support_ieee;
	u32 threshold_reply_count;
	atomic_t fw_outstanding;
	atomic_t ldio_outstanding;
	atomic_t fw_reset_no_pci_access;
	atomic64_t total_io_count;
	atomic64_t high_iops_outstanding;
	struct megasas_instance_template *instancet;
	struct tasklet_struct isr_tasklet;
	struct work_struct work_init;
	struct delayed_work fw_fault_work;
	struct workqueue_struct *fw_fault_work_q;
	char fault_handler_work_q_name[48];
	u8 flag;
	u8 unload;
	u8 flag_ieee;
	u8 issuepend_done;
	u8 disableOnlineCtrlReset;
	u8 UnevenSpanSupport;
	u8 supportmax256vd;
	u8 pd_list_not_supported;
	u16 fw_supported_vd_count;
	u16 fw_supported_pd_count;
	u16 drv_supported_vd_count;
	u16 drv_supported_pd_count;
	atomic_t adprecovery;
	unsigned long last_time;
	u32 mfiStatus;
	u32 last_seq_num;
	struct list_head internal_reset_pending_q;
	void *ctrl_context;
	unsigned int msix_vectors;
	struct megasas_irq_context irq_context[128];
	u64 map_id;
	u64 pd_seq_map_id;
	struct megasas_cmd *map_update_cmd;
	struct megasas_cmd *jbod_seq_cmd;
	unsigned long bar;
	long reset_flags;
	struct mutex reset_mutex;
	struct timer_list sriov_heartbeat_timer;
	char skip_heartbeat_timer_del;
	u8 requestorId;
	char PlasmaFW111;
	char clusterId[16];
	u8 peerIsPresent;
	u8 passive;
	u16 throttlequeuedepth;
	u8 mask_interrupts;
	u16 max_chain_frame_sz;
	u8 is_imr;
	u8 is_rdpq;
	bool dev_handle;
	bool fw_sync_cache_support;
	u32 mfi_frame_size;
	bool msix_combined;
	u16 max_raid_mapsize;
	u8 r1_ldio_hint_default;
	u32 nvme_page_size;
	u8 adapter_type;
	bool consistent_mask_64bit;
	bool support_nvme_passthru;
	bool enable_sdev_max_qd;
	u8 task_abort_tmo;
	u8 max_reset_tmo;
	u8 snapdump_wait_time;
	struct dentry *debugfs_root;
	struct dentry *raidmap_dump;
	u8 enable_fw_dev_list;
	bool atomic_desc_support;
	bool support_seqnum_jbod_fp;
	bool support_pci_lane_margining;
	u8 low_latency_index_start;
	int perf_mode;
	int iopoll_q_count;
};

struct MR_DRV_SYSTEM_INFO {
	u8 infoVersion;
	u8 systemIdLength;
	u16 reserved0;
	u8 systemId[64];
	u8 reserved[1980];
};

union MR_LD_REF {
	struct {
		u8 targetId;
		u8 reserved;
		__le16 seqNum;
	};
	__le32 ref;
};

struct MR_LD_VF_MAP {
	u32 size;
	union MR_LD_REF ref;
	u8 ldVfCount;
	u8 reserved[6];
	u8 policy[1];
};

struct MR_LD_VF_AFFILIATION {
	u32 size;
	u8 ldCount;
	u8 vfCount;
	u8 thisVf;
	u8 reserved[9];
	struct MR_LD_VF_MAP map[1];
};

struct MR_LD_VF_MAP_111 {
	u8 targetId;
	u8 reserved[3];
	u8 policy[8];
};

struct MR_LD_VF_AFFILIATION_111 {
	u8 vdCount;
	u8 vfCount;
	u8 thisVf;
	u8 reserved[5];
	struct MR_LD_VF_MAP_111 map[64];
};

struct MR_CTRL_HB_HOST_MEM {
	struct {
		u32 fwCounter;
		struct {
			u32 debugmode: 1;
			u32 reserved: 31;
		} debug;
		u32 reserved_fw[6];
		u32 driverCounter;
		u32 reserved_driver[7];
	} HB;
	u8 pad[960];
};

union MR_PD_REF {
	struct {
		u16 deviceId;
		u16 seqNum;
	} mrPdRef;
	u32 ref;
};

union MR_PD_DDF_TYPE {
	struct {
		union {
			struct {
				u16 forcedPDGUID: 1;
				u16 inVD: 1;
				u16 isGlobalSpare: 1;
				u16 isSpare: 1;
				u16 isForeign: 1;
				u16 reserved: 7;
				u16 intf: 4;
			} pdType;
			u16 type;
		};
		u16 reserved;
	} ddf;
	struct {
		u32 reserved;
	} nonDisk;
	u32 type;
};

union MR_PROGRESS {
	struct {
		u16 progress;
		union {
			u16 elapsedSecs;
			u16 elapsedSecsForLastPercent;
		};
	} mrProgress;
	u32 w;
};

struct MR_PD_PROGRESS {
	struct {
		u32 rbld: 1;
		u32 patrol: 1;
		u32 clear: 1;
		u32 copyBack: 1;
		u32 erase: 1;
		u32 locate: 1;
		u32 reserved: 26;
	} active;
	union MR_PROGRESS rbld;
	union MR_PROGRESS patrol;
	union {
		union MR_PROGRESS clear;
		union MR_PROGRESS erase;
	};
	struct {
		u32 rbld: 1;
		u32 patrol: 1;
		u32 clear: 1;
		u32 copyBack: 1;
		u32 erase: 1;
		u32 reserved: 27;
	} pause;
	union MR_PROGRESS reserved[3];
};

struct MR_PD_INFO {
	union MR_PD_REF ref;
	u8 inquiryData[96];
	u8 vpdPage83[64];
	u8 notSupported;
	u8 scsiDevType;
	union {
		u8 connectedPortBitmap;
		u8 connectedPortNumbers;
	};
	u8 deviceSpeed;
	u32 mediaErrCount;
	u32 otherErrCount;
	u32 predFailCount;
	u32 lastPredFailEventSeqNum;
	u16 fwState;
	u8 disabledForRemoval;
	u8 linkSpeed;
	union MR_PD_DDF_TYPE state;
	struct {
		u8 count;
		u8 isPathBroken: 4;
		u8 reserved3: 3;
		u8 widePortCapable: 1;
		u8 connectorIndex[2];
		u8 reserved[4];
		u64 sasAddr[2];
		u8 reserved2[16];
	} pathInfo;
	u64 rawSize;
	u64 nonCoercedSize;
	u64 coercedSize;
	u16 enclDeviceId;
	u8 enclIndex;
	union {
		u8 slotNumber;
		u8 enclConnectorIndex;
	};
	struct MR_PD_PROGRESS progInfo;
	u8 badBlockTableFull;
	u8 unusableInCurrentConfig;
	u8 vpdPage83Ext[64];
	u8 powerState;
	u8 enclPosition;
	u32 allowedOps;
	u16 copyBackPartnerId;
	u16 enclPartnerDeviceId;
	struct {
		u16 fdeCapable: 1;
		u16 fdeEnabled: 1;
		u16 secured: 1;
		u16 locked: 1;
		u16 foreign: 1;
		u16 needsEKM: 1;
		u16 reserved: 10;
	} security;
	u8 mediaType;
	u8 notCertified;
	u8 bridgeVendor[8];
	u8 bridgeProductIdentification[16];
	u8 bridgeProductRevisionLevel[4];
	u8 satBridgeExists;
	u8 interfaceType;
	u8 temperature;
	u8 emulatedBlockSize;
	u16 userDataBlockSize;
	u16 reserved2;
	struct {
		u32 piType: 3;
		u32 piFormatted: 1;
		u32 piEligible: 1;
		u32 NCQ: 1;
		u32 WCE: 1;
		u32 commissionedSpare: 1;
		u32 emergencySpare: 1;
		u32 ineligibleForSSCD: 1;
		u32 ineligibleForLd: 1;
		u32 useSSEraseType: 1;
		u32 wceUnchanged: 1;
		u32 supportScsiUnmap: 1;
		u32 reserved: 18;
	} properties;
	u64 shieldDiagCompletionTime;
	u8 shieldCounter;
	u8 linkSpeedOther;
	u8 reserved4[2];
	struct {
		u32 bbmErrCountSupported: 1;
		u32 bbmErrCount: 31;
	} bbmErr;
	u8 reserved1[84];
} __attribute__((packed));

struct MR_TARGET_PROPERTIES {
	u32 max_io_size_kb;
	u32 device_qdepth;
	u32 sector_size;
	u8 reset_tmo;
	u8 reserved[499];
};

struct MR_PD_ADDRESS {
	__le16 deviceId;
	u16 enclDeviceId;
	union {
		struct {
			u8 enclIndex;
			u8 slotNumber;
		} mrPdAddress;
		struct {
			u8 enclPosition;
			u8 enclConnectorIndex;
		} mrEnclAddress;
	};
	u8 scsiDevType;
	union {
		u8 connectedPortBitmap;
		u8 connectedPortNumbers;
	};
	u64 sasAddr[2];
};

struct MR_PD_LIST {
	__le32 size;
	__le32 count;
	struct MR_PD_ADDRESS addr[1];
};

struct megasas_ctrl_prop {
	u16 seq_num;
	u16 pred_fail_poll_interval;
	u16 intr_throttle_count;
	u16 intr_throttle_timeouts;
	u8 rebuild_rate;
	u8 patrol_read_rate;
	u8 bgi_rate;
	u8 cc_rate;
	u8 recon_rate;
	u8 cache_flush_interval;
	u8 spinup_drv_count;
	u8 spinup_delay;
	u8 cluster_enable;
	u8 coercion_mode;
	u8 alarm_enable;
	u8 disable_auto_rebuild;
	u8 disable_battery_warn;
	u8 ecc_bucket_size;
	u16 ecc_bucket_leak_rate;
	u8 restore_hotspare_on_insertion;
	u8 expose_encl_devices;
	u8 maintainPdFailHistory;
	u8 disallowHostRequestReordering;
	u8 abortCCOnError;
	u8 loadBalanceMode;
	u8 disableAutoDetectBackplane;
	u8 snapVDSpace;
	struct {
		u32 copyBackDisabled: 1;
		u32 SMARTerEnabled: 1;
		u32 prCorrectUnconfiguredAreas: 1;
		u32 useFdeOnly: 1;
		u32 disableNCQ: 1;
		u32 SSDSMARTerEnabled: 1;
		u32 SSDPatrolReadEnabled: 1;
		u32 enableSpinDownUnconfigured: 1;
		u32 autoEnhancedImport: 1;
		u32 enableSecretKeyControl: 1;
		u32 disableOnlineCtrlReset: 1;
		u32 allowBootWithPinnedCache: 1;
		u32 disableSpinDownHS: 1;
		u32 enableJBOD: 1;
		u32 reserved: 18;
	} OnOffProperties;
	union {
		u8 autoSnapVDSpace;
		u8 viewSpace;
		struct {
			u16 reserved1: 4;
			u16 enable_snap_dump: 1;
			u16 reserved2: 1;
			u16 enable_fw_dev_list: 1;
			u16 reserved3: 9;
		} on_off_properties2;
	};
	__le16 spinDownTime;
	u8 reserved[24];
};

struct megasas_ctrl_info {
	struct {
		__le16 vendor_id;
		__le16 device_id;
		__le16 sub_vendor_id;
		__le16 sub_device_id;
		u8 reserved[24];
	} pci;
	struct {
		u8 PCIX: 1;
		u8 PCIE: 1;
		u8 iSCSI: 1;
		u8 SAS_3G: 1;
		u8 SRIOV: 1;
		u8 reserved_0: 3;
		u8 reserved_1[6];
		u8 port_count;
		u64 port_addr[8];
	} host_interface;
	struct {
		u8 SPI: 1;
		u8 SAS_3G: 1;
		u8 SATA_1_5G: 1;
		u8 SATA_3G: 1;
		u8 reserved_0: 4;
		u8 reserved_1[6];
		u8 port_count;
		u64 port_addr[8];
	} device_interface;
	__le32 image_check_word;
	__le32 image_component_count;
	struct {
		char name[8];
		char version[32];
		char build_date[16];
		char built_time[16];
	} image_component[8];
	__le32 pending_image_component_count;
	struct {
		char name[8];
		char version[32];
		char build_date[16];
		char build_time[16];
	} pending_image_component[8];
	u8 max_arms;
	u8 max_spans;
	u8 max_arrays;
	u8 max_lds;
	char product_name[80];
	char serial_no[32];
	struct {
		u32 bbu: 1;
		u32 alarm: 1;
		u32 nvram: 1;
		u32 uart: 1;
		u32 reserved: 28;
	} hw_present;
	__le32 current_fw_time;
	__le16 max_concurrent_cmds;
	__le16 max_sge_count;
	__le32 max_request_size;
	__le16 ld_present_count;
	__le16 ld_degraded_count;
	__le16 ld_offline_count;
	__le16 pd_present_count;
	__le16 pd_disk_present_count;
	__le16 pd_disk_pred_failure_count;
	__le16 pd_disk_failed_count;
	__le16 nvram_size;
	__le16 memory_size;
	__le16 flash_size;
	__le16 mem_correctable_error_count;
	__le16 mem_uncorrectable_error_count;
	u8 cluster_permitted;
	u8 cluster_active;
	__le16 max_strips_per_io;
	struct {
		u32 raid_level_0: 1;
		u32 raid_level_1: 1;
		u32 raid_level_5: 1;
		u32 raid_level_1E: 1;
		u32 raid_level_6: 1;
		u32 reserved: 27;
	} raid_levels;
	struct {
		u32 rbld_rate: 1;
		u32 cc_rate: 1;
		u32 bgi_rate: 1;
		u32 recon_rate: 1;
		u32 patrol_rate: 1;
		u32 alarm_control: 1;
		u32 cluster_supported: 1;
		u32 bbu: 1;
		u32 spanning_allowed: 1;
		u32 dedicated_hotspares: 1;
		u32 revertible_hotspares: 1;
		u32 foreign_config_import: 1;
		u32 self_diagnostic: 1;
		u32 mixed_redundancy_arr: 1;
		u32 global_hot_spares: 1;
		u32 reserved: 17;
	} adapter_operations;
	struct {
		u32 read_policy: 1;
		u32 write_policy: 1;
		u32 io_policy: 1;
		u32 access_policy: 1;
		u32 disk_cache_policy: 1;
		u32 reserved: 27;
	} ld_operations;
	struct {
		u8 min;
		u8 max;
		u8 reserved[2];
	} stripe_sz_ops;
	struct {
		u32 force_online: 1;
		u32 force_offline: 1;
		u32 force_rebuild: 1;
		u32 reserved: 29;
	} pd_operations;
	struct {
		u32 ctrl_supports_sas: 1;
		u32 ctrl_supports_sata: 1;
		u32 allow_mix_in_encl: 1;
		u32 allow_mix_in_ld: 1;
		u32 allow_sata_in_cluster: 1;
		u32 reserved: 27;
	} pd_mix_support;
	u8 ecc_bucket_count;
	u8 reserved_2[11];
	struct megasas_ctrl_prop properties;
	char package_version[96];
	__le64 deviceInterfacePortAddr2[8];
	u8 reserved3[128];
	struct {
		u16 minPdRaidLevel_0: 4;
		u16 maxPdRaidLevel_0: 12;
		u16 minPdRaidLevel_1: 4;
		u16 maxPdRaidLevel_1: 12;
		u16 minPdRaidLevel_5: 4;
		u16 maxPdRaidLevel_5: 12;
		u16 minPdRaidLevel_1E: 4;
		u16 maxPdRaidLevel_1E: 12;
		u16 minPdRaidLevel_6: 4;
		u16 maxPdRaidLevel_6: 12;
		u16 minPdRaidLevel_10: 4;
		u16 maxPdRaidLevel_10: 12;
		u16 minPdRaidLevel_50: 4;
		u16 maxPdRaidLevel_50: 12;
		u16 minPdRaidLevel_60: 4;
		u16 maxPdRaidLevel_60: 12;
		u16 minPdRaidLevel_1E_RLQ0: 4;
		u16 maxPdRaidLevel_1E_RLQ0: 12;
		u16 minPdRaidLevel_1E0_RLQ0: 4;
		u16 maxPdRaidLevel_1E0_RLQ0: 12;
		u16 reserved[6];
	} pdsForRaidLevels;
	__le16 maxPds;
	__le16 maxDedHSPs;
	__le16 maxGlobalHSP;
	__le16 ddfSize;
	u8 maxLdsPerArray;
	u8 partitionsInDDF;
	u8 lockKeyBinding;
	u8 maxPITsPerLd;
	u8 maxViewsPerLd;
	u8 maxTargetId;
	__le16 maxBvlVdSize;
	__le16 maxConfigurableSSCSize;
	__le16 currentSSCsize;
	char expanderFwVersion[12];
	__le16 PFKTrialTimeRemaining;
	__le16 cacheMemorySize;
	struct {
		u32 supportPIcontroller: 1;
		u32 supportLdPIType1: 1;
		u32 supportLdPIType2: 1;
		u32 supportLdPIType3: 1;
		u32 supportLdBBMInfo: 1;
		u32 supportShieldState: 1;
		u32 blockSSDWriteCacheChange: 1;
		u32 supportSuspendResumeBGops: 1;
		u32 supportEmergencySpares: 1;
		u32 supportSetLinkSpeed: 1;
		u32 supportBootTimePFKChange: 1;
		u32 supportJBOD: 1;
		u32 disableOnlinePFKChange: 1;
		u32 supportPerfTuning: 1;
		u32 supportSSDPatrolRead: 1;
		u32 realTimeScheduler: 1;
		u32 supportResetNow: 1;
		u32 supportEmulatedDrives: 1;
		u32 headlessMode: 1;
		u32 dedicatedHotSparesLimited: 1;
		u32 supportUnevenSpans: 1;
		u32 supportPointInTimeProgress: 1;
		u32 supportDataLDonSSCArray: 1;
		u32 mpio: 1;
		u32 supportConfigAutoBalance: 1;
		u32 activePassive: 2;
		u32 reserved: 5;
	} adapterOperations2;
	u8 driverVersion[32];
	u8 maxDAPdCountSpinup60;
	u8 temperatureROC;
	u8 temperatureCtrl;
	u8 reserved4;
	__le16 maxConfigurablePds;
	u8 reserved5[2];
	struct {
		u32 peerIsPresent: 1;
		u32 peerIsIncompatible: 1;
		u32 hwIncompatible: 1;
		u32 fwVersionMismatch: 1;
		u32 ctrlPropIncompatible: 1;
		u32 premiumFeatureMismatch: 1;
		u32 passive: 1;
		u32 reserved: 25;
	} cluster;
	char clusterId[16];
	struct {
		u8 maxVFsSupported;
		u8 numVFsEnabled;
		u8 requestorId;
		u8 reserved;
	} iov;
	struct {
		u32 supportPersonalityChange: 2;
		u32 supportThermalPollInterval: 1;
		u32 supportDisableImmediateIO: 1;
		u32 supportT10RebuildAssist: 1;
		u32 supportMaxExtLDs: 1;
		u32 supportCrashDump: 1;
		u32 supportSwZone: 1;
		u32 supportDebugQueue: 1;
		u32 supportNVCacheErase: 1;
		u32 supportForceTo512e: 1;
		u32 supportHOQRebuild: 1;
		u32 supportAllowedOpsforDrvRemoval: 1;
		u32 supportDrvActivityLEDSetting: 1;
		u32 supportNVDRAM: 1;
		u32 supportForceFlash: 1;
		u32 supportDisableSESMonitoring: 1;
		u32 supportCacheBypassModes: 1;
		u32 supportSecurityonJBOD: 1;
		u32 discardCacheDuringLDDelete: 1;
		u32 supportTTYLogCompression: 1;
		u32 supportCPLDUpdate: 1;
		u32 supportDiskCacheSettingForSysPDs: 1;
		u32 supportExtendedSSCSize: 1;
		u32 useSeqNumJbodFP: 1;
		u32 reserved: 7;
	} adapterOperations3;
	struct {
		u8 cpld_in_flash: 1;
		u8 reserved: 7;
		u8 reserved1[3];
		u8 userCodeDefinition[12];
	} cpld;
	struct {
		u16 ctrl_info_ext_supported: 1;
		u16 support_ibutton_less: 1;
		u16 supported_enc_algo: 1;
		u16 support_encrypted_mfc: 1;
		u16 image_upload_supported: 1;
		u16 support_ses_ctrl_in_multipathcfg: 1;
		u16 support_pd_map_target_id: 1;
		u16 fw_swaps_bbu_vpd_info: 1;
		u16 support_ssc_rev3: 1;
		u16 support_dual_fw_update: 1;
		u16 support_host_info: 1;
		u16 support_flash_comp_info: 1;
		u16 support_pl_debug_info: 1;
		u16 support_nvme_passthru: 1;
		u16 reserved: 2;
	} adapter_operations4;
	u8 pad[2];
	u32 size;
	u32 pad1;
	u8 reserved6[64];
	struct {
		u32 mr_config_ext2_supported: 1;
		u32 support_profile_change: 2;
		u32 support_cvhealth_info: 1;
		u32 support_pcie: 1;
		u32 support_ext_mfg_vpd: 1;
		u32 support_oce_only: 1;
		u32 support_nvme_tm: 1;
		u32 support_snap_dump: 1;
		u32 support_fde_type_mix: 1;
		u32 support_force_personality_change: 1;
		u32 support_psoc_update: 1;
		u32 support_pci_lane_margining: 1;
		u32 reserved: 19;
	} adapter_operations5;
	u32 rsvdForAdptOp[63];
	u8 reserved7[3];
	u8 TaskAbortTO;
	u8 MaxResetTO;
	u8 reserved8[3];
};

struct MR_LD_LIST {
	__le32 ldCount;
	__le32 reserved;
	struct {
		union MR_LD_REF ref;
		u8 state;
		u8 reserved[3];
		__le64 size;
	} ldList[256];
};

struct MR_LD_TARGETID_LIST {
	__le32 size;
	__le32 count;
	u8 pad[3];
	u8 targetId[256];
};

struct MR_HOST_DEVICE_LIST_ENTRY {
	struct {
		union {
			struct {
				u8 is_sys_pd: 1;
				u8 reserved: 7;
			} bits;
			u8 byte;
		} u;
	} flags;
	u8 scsi_type;
	__le16 target_id;
	u8 reserved[4];
	__le64 sas_addr[2];
};

struct MR_HOST_DEVICE_LIST {
	__le32 size;
	__le32 count;
	__le32 reserved[2];
	struct MR_HOST_DEVICE_LIST_ENTRY host_device_list[1];
};

struct MR_SNAPDUMP_PROPERTIES {
	u8 offload_num;
	u8 max_num_supported;
	u8 cur_num_supported;
	u8 trigger_min_num_sec_before_ocr;
	u8 reserved[12];
};

struct megasas_register_set {
	u32 doorbell;
	u32 fusion_seq_offset;
	u32 fusion_host_diag;
	u32 reserved_01;
	u32 inbound_msg_0;
	u32 inbound_msg_1;
	u32 outbound_msg_0;
	u32 outbound_msg_1;
	u32 inbound_doorbell;
	u32 inbound_intr_status;
	u32 inbound_intr_mask;
	u32 outbound_doorbell;
	u32 outbound_intr_status;
	u32 outbound_intr_mask;
	u32 reserved_1[2];
	u32 inbound_queue_port;
	u32 outbound_queue_port;
	u32 reserved_2[9];
	u32 reply_post_host_index;
	u32 reserved_2_2[12];
	u32 outbound_doorbell_clear;
	u32 reserved_3[3];
	u32 outbound_scratch_pad_0;
	u32 outbound_scratch_pad_1;
	u32 outbound_scratch_pad_2;
	u32 outbound_scratch_pad_3;
	u32 inbound_low_queue_port;
	u32 inbound_high_queue_port;
	u32 inbound_single_queue_port;
	u32 res_6[11];
	u32 host_diag;
	u32 seq_offset;
	u32 index_registers[807];
};

struct megasas_aen_event {
	struct delayed_work hotplug_work;
	struct megasas_instance *instance;
};

union megasas_frame;

struct megasas_cmd {
	union megasas_frame *frame;
	dma_addr_t frame_phys_addr;
	u8 *sense;
	dma_addr_t sense_phys_addr;
	u32 index;
	u8 sync_cmd;
	u8 cmd_status_drv;
	u8 abort_aen;
	u8 retry_for_fw_reset;
	struct list_head list;
	struct scsi_cmnd *scmd;
	u8 flags;
	struct megasas_instance *instance;
	union {
		struct {
			u16 smid;
			u16 resvd;
		} context;
		u32 frame_count;
	};
};

struct megasas_header {
	u8 cmd;
	u8 sense_len;
	u8 cmd_status;
	u8 scsi_status;
	u8 target_id;
	u8 lun;
	u8 cdb_len;
	u8 sge_count;
	__le32 context;
	__le32 pad_0;
	__le16 flags;
	__le16 timeout;
	__le32 data_xferlen;
};

union _MFI_CAPABILITIES {
	struct {
		u32 support_fp_remote_lun: 1;
		u32 support_additional_msix: 1;
		u32 support_fastpath_wb: 1;
		u32 support_max_255lds: 1;
		u32 support_ndrive_r1_lb: 1;
		u32 support_core_affinity: 1;
		u32 security_protocol_cmds_fw: 1;
		u32 support_ext_queue_depth: 1;
		u32 support_ext_io_size: 1;
		u32 support_vfid_in_ioframe: 1;
		u32 support_fp_rlbypass: 1;
		u32 support_qd_throttling: 1;
		u32 support_pd_map_target_id: 1;
		u32 support_64bit_mode: 1;
		u32 support_nvme_passthru: 1;
		u32 support_fw_exposed_dev_list: 1;
		u32 support_memdump: 1;
		u32 reserved: 15;
	} mfi_capabilities;
	__le32 reg;
};

typedef union _MFI_CAPABILITIES MFI_CAPABILITIES;

struct megasas_init_frame {
	u8 cmd;
	u8 reserved_0;
	u8 cmd_status;
	u8 reserved_1;
	MFI_CAPABILITIES driver_operations;
	__le32 context;
	__le32 pad_0;
	__le16 flags;
	__le16 replyqueue_mask;
	__le32 data_xfer_len;
	__le32 queue_info_new_phys_addr_lo;
	__le32 queue_info_new_phys_addr_hi;
	__le32 queue_info_old_phys_addr_lo;
	__le32 queue_info_old_phys_addr_hi;
	__le32 reserved_4[2];
	__le32 system_info_lo;
	__le32 system_info_hi;
	__le32 reserved_5[2];
};

struct megasas_sge32 {
	__le32 phys_addr;
	__le32 length;
};

struct megasas_sge64 {
	__le64 phys_addr;
	__le32 length;
} __attribute__((packed));

struct megasas_sge_skinny {
	__le64 phys_addr;
	__le32 length;
	__le32 flag;
};

union megasas_sgl {
	struct {
		struct {} __empty_sge32;
		struct megasas_sge32 sge32[0];
	};
	struct {
		struct {} __empty_sge64;
		struct megasas_sge64 sge64[0];
	};
	struct {
		struct {} __empty_sge_skinny;
		struct megasas_sge_skinny sge_skinny[0];
	};
};

struct megasas_io_frame {
	u8 cmd;
	u8 sense_len;
	u8 cmd_status;
	u8 scsi_status;
	u8 target_id;
	u8 access_byte;
	u8 reserved_0;
	u8 sge_count;
	__le32 context;
	__le32 pad_0;
	__le16 flags;
	__le16 timeout;
	__le32 lba_count;
	__le32 sense_buf_phys_addr_lo;
	__le32 sense_buf_phys_addr_hi;
	__le32 start_lba_lo;
	__le32 start_lba_hi;
	union megasas_sgl sgl;
};

struct megasas_pthru_frame {
	u8 cmd;
	u8 sense_len;
	u8 cmd_status;
	u8 scsi_status;
	u8 target_id;
	u8 lun;
	u8 cdb_len;
	u8 sge_count;
	__le32 context;
	__le32 pad_0;
	__le16 flags;
	__le16 timeout;
	__le32 data_xfer_len;
	__le32 sense_buf_phys_addr_lo;
	__le32 sense_buf_phys_addr_hi;
	u8 cdb[16];
	union megasas_sgl sgl;
};

struct megasas_dcmd_frame {
	u8 cmd;
	u8 reserved_0;
	u8 cmd_status;
	u8 reserved_1[4];
	u8 sge_count;
	__le32 context;
	__le32 pad_0;
	__le16 flags;
	__le16 timeout;
	__le32 data_xfer_len;
	__le32 opcode;
	union {
		u8 b[12];
		__le16 s[6];
		__le32 w[3];
	} mbox;
	union megasas_sgl sgl;
};

struct megasas_abort_frame {
	u8 cmd;
	u8 reserved_0;
	u8 cmd_status;
	u8 reserved_1;
	__le32 reserved_2;
	__le32 context;
	__le32 pad_0;
	__le16 flags;
	__le16 reserved_3;
	__le32 reserved_4;
	__le32 abort_context;
	__le32 pad_1;
	__le32 abort_mfi_phys_addr_lo;
	__le32 abort_mfi_phys_addr_hi;
	__le32 reserved_5[6];
};

struct megasas_smp_frame {
	u8 cmd;
	u8 reserved_1;
	u8 cmd_status;
	u8 connection_status;
	u8 reserved_2[3];
	u8 sge_count;
	__le32 context;
	__le32 pad_0;
	__le16 flags;
	__le16 timeout;
	__le32 data_xfer_len;
	__le64 sas_addr;
	union {
		struct megasas_sge32 sge32[2];
		struct megasas_sge64 sge64[2];
	} sgl;
};

struct megasas_stp_frame {
	u8 cmd;
	u8 reserved_1;
	u8 cmd_status;
	u8 reserved_2;
	u8 target_id;
	u8 reserved_3[2];
	u8 sge_count;
	__le32 context;
	__le32 pad_0;
	__le16 flags;
	__le16 timeout;
	__le32 data_xfer_len;
	__le16 fis[10];
	__le32 stp_flags;
	union {
		struct megasas_sge32 sge32[2];
		struct megasas_sge64 sge64[2];
	} sgl;
};

union megasas_frame {
	struct megasas_header hdr;
	struct megasas_init_frame init;
	struct megasas_io_frame io;
	struct megasas_pthru_frame pthru;
	struct megasas_dcmd_frame dcmd;
	struct megasas_abort_frame abort;
	struct megasas_smp_frame smp;
	struct megasas_stp_frame stp;
	u8 raw_bytes[64];
};

struct megasas_evtarg_pd {
	u16 device_id;
	u8 encl_index;
	u8 slot_number;
};

struct megasas_evtarg_ld {
	u16 target_id;
	u8 ld_index;
	u8 reserved;
};

struct megasas_progress {
	__le16 progress;
	__le16 elapsed_seconds;
};

union megasas_evt_class_locale {
	struct {
		u16 locale;
		u8 reserved;
		s8 class;
	} members;
	u32 word;
};

struct megasas_evt_detail {
	__le32 seq_num;
	__le32 time_stamp;
	__le32 code;
	union megasas_evt_class_locale cl;
	u8 arg_type;
	u8 reserved1[15];
	union {
		struct {
			struct megasas_evtarg_pd pd;
			u8 cdb_length;
			u8 sense_length;
			u8 reserved[2];
			u8 cdb[16];
			u8 sense[64];
		} cdbSense;
		struct megasas_evtarg_ld ld;
		struct {
			struct megasas_evtarg_ld ld;
			__le64 count;
		} __attribute__((packed)) ld_count;
		struct {
			__le64 lba;
			struct megasas_evtarg_ld ld;
		} __attribute__((packed)) ld_lba;
		struct {
			struct megasas_evtarg_ld ld;
			__le32 prevOwner;
			__le32 newOwner;
		} ld_owner;
		struct {
			u64 ld_lba;
			u64 pd_lba;
			struct megasas_evtarg_ld ld;
			struct megasas_evtarg_pd pd;
		} ld_lba_pd_lba;
		struct {
			struct megasas_evtarg_ld ld;
			struct megasas_progress prog;
		} ld_prog;
		struct {
			struct megasas_evtarg_ld ld;
			u32 prev_state;
			u32 new_state;
		} ld_state;
		struct {
			u64 strip;
			struct megasas_evtarg_ld ld;
		} __attribute__((packed)) ld_strip;
		struct megasas_evtarg_pd pd;
		struct {
			struct megasas_evtarg_pd pd;
			u32 err;
		} pd_err;
		struct {
			u64 lba;
			struct megasas_evtarg_pd pd;
		} __attribute__((packed)) pd_lba;
		struct {
			u64 lba;
			struct megasas_evtarg_pd pd;
			struct megasas_evtarg_ld ld;
		} pd_lba_ld;
		struct {
			struct megasas_evtarg_pd pd;
			struct megasas_progress prog;
		} pd_prog;
		struct {
			struct megasas_evtarg_pd pd;
			u32 prevState;
			u32 newState;
		} pd_state;
		struct {
			u16 vendorId;
			__le16 deviceId;
			u16 subVendorId;
			u16 subDeviceId;
		} pci;
		u32 rate;
		char str[96];
		struct {
			u32 rtc;
			u32 elapsedSeconds;
		} time;
		struct {
			u32 ecar;
			u32 elog;
			char str[64];
		} ecc;
		u8 b[96];
		__le16 s[48];
		__le32 w[24];
		__le64 d[12];
	} args;
	char description[128];
};

struct megasas_instance_template {
	void (*fire_cmd)(struct megasas_instance *, dma_addr_t, u32, struct megasas_register_set *);
	void (*enable_intr)(struct megasas_instance *);
	void (*disable_intr)(struct megasas_instance *);
	int (*clear_intr)(struct megasas_instance *);
	u32 (*read_fw_status_reg)(struct megasas_instance *);
	int (*adp_reset)(struct megasas_instance *, struct megasas_register_set *);
	int (*check_reset)(struct megasas_instance *, struct megasas_register_set *);
	irqreturn_t (*service_isr)(int, void *);
	void (*tasklet)(unsigned long);
	u32 (*init_adapter)(struct megasas_instance *);
	u32 (*build_and_issue_cmd)(struct megasas_instance *, struct scsi_cmnd *);
	void (*issue_dcmd)(struct megasas_instance *, struct megasas_cmd *);
};

struct MR_DRV_RAID_MAP {
	__le32 totalSize;
	union {
		struct {
			__le32 maxLd;
			__le32 maxSpanDepth;
			__le32 maxRowSize;
			__le32 maxPdCount;
			__le32 maxArrays;
		} validationInfo;
		__le32 version[5];
	};
	u8 fpPdIoTimeoutSec;
	u8 reserved2[7];
	__le16 ldCount;
	__le16 arCount;
	__le16 spanCount;
	__le16 reserve3;
	struct MR_DEV_HANDLE_INFO devHndlInfo[512];
	u16 ldTgtIdToLd[512];
	struct MR_ARRAY_INFO arMapInfo[512];
	struct MR_LD_SPAN_MAP ldSpanMap[0];
};

struct MR_DRV_RAID_MAP_ALL {
	struct MR_DRV_RAID_MAP raidMap;
	struct MR_LD_SPAN_MAP ldSpanMap[512];
};

struct MR_FW_RAID_MAP_DYNAMIC {
	u32 raid_map_size;
	u32 desc_table_offset;
	u32 desc_table_size;
	u32 desc_table_num_elements;
	u64 reserved1;
	u32 reserved2[3];
	u8 fp_pd_io_timeout_sec;
	u8 reserved3[3];
	u32 rmw_fp_seq_num;
	u16 ld_count;
	u16 ar_count;
	u16 span_count;
	u16 reserved4[3];
	union {
		struct {
			struct MR_DEV_HANDLE_INFO *dev_hndl_info;
			u16 *ld_tgt_id_to_ld;
			struct MR_ARRAY_INFO *ar_map_info;
			struct MR_LD_SPAN_MAP *ld_span_map;
		};
		u64 ptr_structure_size[4];
	};
	struct MR_RAID_MAP_DESC_TABLE raid_map_desc_table[4];
	u32 raid_map_desc_data[0];
};

union MPI2_REPLY_DESCRIPTORS_UNION;

struct rdpq_alloc_detail {
	struct dma_pool *dma_pool_ptr;
	dma_addr_t pool_entry_phys;
	union MPI2_REPLY_DESCRIPTORS_UNION *pool_entry_virt;
};

struct megasas_cmd_fusion;

struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY;

struct MR_PD_CFG_SEQ_NUM_SYNC;

struct LD_LOAD_BALANCE_INFO;

struct LOG_BLOCK_SPAN_INFO;

typedef struct LOG_BLOCK_SPAN_INFO LD_SPAN_INFO;

struct LD_STREAM_DETECT;

struct MPI2_IOC_INIT_REQUEST;

struct fusion_context {
	struct megasas_cmd_fusion **cmd_list;
	dma_addr_t req_frames_desc_phys;
	u8 *req_frames_desc;
	struct dma_pool *io_request_frames_pool;
	dma_addr_t io_request_frames_phys;
	u8 *io_request_frames;
	struct dma_pool *sg_dma_pool;
	struct dma_pool *sense_dma_pool;
	u8 *sense;
	dma_addr_t sense_phys_addr;
	atomic_t busy_mq_poll[128];
	dma_addr_t reply_frames_desc_phys[128];
	union MPI2_REPLY_DESCRIPTORS_UNION *reply_frames_desc[128];
	struct rdpq_alloc_detail rdpq_tracker[8];
	struct dma_pool *reply_frames_desc_pool;
	struct dma_pool *reply_frames_desc_pool_align;
	u16 last_reply_idx[128];
	u32 reply_q_depth;
	u32 request_alloc_sz;
	u32 reply_alloc_sz;
	u32 io_frames_alloc_sz;
	struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY *rdpq_virt;
	dma_addr_t rdpq_phys;
	u16 max_sge_in_main_msg;
	u16 max_sge_in_chain;
	u8 chain_offset_io_request;
	u8 chain_offset_mfi_pthru;
	struct MR_FW_RAID_MAP_DYNAMIC *ld_map[2];
	dma_addr_t ld_map_phys[2];
	struct MR_DRV_RAID_MAP_ALL *ld_drv_map[2];
	u32 max_map_sz;
	u32 current_map_sz;
	u32 old_map_sz;
	u32 new_map_sz;
	u32 drv_map_sz;
	u32 drv_map_pages;
	struct MR_PD_CFG_SEQ_NUM_SYNC *pd_seq_sync[2];
	dma_addr_t pd_seq_phys[2];
	u8 fast_path_io;
	struct LD_LOAD_BALANCE_INFO *load_balance_info;
	u32 load_balance_info_pages;
	LD_SPAN_INFO *log_to_span;
	u32 log_to_span_pages;
	struct LD_STREAM_DETECT **stream_detect_by_ld;
	dma_addr_t ioc_init_request_phys;
	struct MPI2_IOC_INIT_REQUEST *ioc_init_request;
	struct megasas_cmd *ioc_init_cmd;
	bool pcie_bw_limitation;
	bool r56_div_offload;
};

struct MPI2_RAID_SCSI_IO_REQUEST;

union MPI2_SGE_IO_UNION;

union MEGASAS_REQUEST_DESCRIPTOR_UNION;

struct megasas_cmd_fusion {
	struct MPI2_RAID_SCSI_IO_REQUEST *io_request;
	dma_addr_t io_request_phys_addr;
	union MPI2_SGE_IO_UNION *sg_frame;
	dma_addr_t sg_frame_phys_addr;
	u8 *sense;
	dma_addr_t sense_phys_addr;
	struct list_head list;
	struct scsi_cmnd *scmd;
	struct megasas_instance *instance;
	u8 retry_for_fw_reset;
	union MEGASAS_REQUEST_DESCRIPTOR_UNION *request_desc;
	u32 sync_cmd_idx;
	u32 index;
	u8 pd_r1_lb;
	struct completion done;
	u8 pd_interface;
	u16 r1_alt_dev_handle;
	bool cmd_completed;
};

struct MPI2_SGE_SIMPLE_UNION {
	__le32 FlagsLength;
	union {
		__le32 Address32;
		__le64 Address64;
	} u;
};

struct MPI2_SGE_CHAIN_UNION {
	__le16 Length;
	u8 NextChainOffset;
	u8 Flags;
	union {
		__le32 Address32;
		__le64 Address64;
	} u;
};

struct MPI2_IEEE_SGE_SIMPLE32 {
	__le32 Address;
	__le32 FlagsLength;
};

struct MPI2_IEEE_SGE_SIMPLE64 {
	__le64 Address;
	__le32 Length;
	__le16 Reserved1;
	u8 Reserved2;
	u8 Flags;
};

union MPI2_IEEE_SGE_SIMPLE_UNION {
	struct MPI2_IEEE_SGE_SIMPLE32 Simple32;
	struct MPI2_IEEE_SGE_SIMPLE64 Simple64;
};

struct MPI2_IEEE_SGE_CHAIN32 {
	__le32 Address;
	__le32 FlagsLength;
};

struct MPI2_IEEE_SGE_CHAIN64 {
	__le64 Address;
	__le32 Length;
	__le16 Reserved1;
	u8 Reserved2;
	u8 Flags;
};

union MPI2_IEEE_SGE_CHAIN_UNION {
	struct MPI2_IEEE_SGE_CHAIN32 Chain32;
	struct MPI2_IEEE_SGE_CHAIN64 Chain64;
};

union MPI2_SGE_IO_UNION {
	struct MPI2_SGE_SIMPLE_UNION MpiSimple;
	struct MPI2_SGE_CHAIN_UNION MpiChain;
	union MPI2_IEEE_SGE_SIMPLE_UNION IeeeSimple;
	union MPI2_IEEE_SGE_CHAIN_UNION IeeeChain;
};

struct MPI2_SCSI_IO_CDB_EEDP32 {
	u8 CDB[20];
	__be32 PrimaryReferenceTag;
	__be16 PrimaryApplicationTag;
	__be16 PrimaryApplicationTagMask;
	__le32 TransferLength;
};

union MPI2_SCSI_IO_CDB_UNION {
	u8 CDB32[32];
	struct MPI2_SCSI_IO_CDB_EEDP32 EEDP32;
	struct MPI2_SGE_SIMPLE_UNION SGE;
};

struct RAID_CONTEXT {
	u8 type: 4;
	u8 nseg: 4;
	u8 resvd0;
	__le16 timeout_value;
	u8 reg_lock_flags;
	u8 resvd1;
	__le16 virtual_disk_tgt_id;
	__le64 reg_lock_row_lba;
	__le32 reg_lock_length;
	__le16 next_lmid;
	u8 ex_status;
	u8 status;
	u8 raid_flags;
	u8 num_sge;
	__le16 config_seq_num;
	u8 span_arm;
	u8 priority;
	u8 num_sge_ext;
	u8 resvd2;
};

union RAID_CONTEXT_UNION {
	struct RAID_CONTEXT raid_context;
	struct RAID_CONTEXT_G35 raid_context_g35;
};

struct MPI2_RAID_SCSI_IO_REQUEST {
	__le16 DevHandle;
	u8 ChainOffset;
	u8 Function;
	__le16 Reserved1;
	u8 Reserved2;
	u8 MsgFlags;
	u8 VP_ID;
	u8 VF_ID;
	__le16 Reserved3;
	__le32 SenseBufferLowAddress;
	__le16 SGLFlags;
	u8 SenseBufferLength;
	u8 Reserved4;
	u8 SGLOffset0;
	u8 SGLOffset1;
	u8 SGLOffset2;
	u8 SGLOffset3;
	__le32 SkipCount;
	__le32 DataLength;
	__le32 BidirectionalDataLength;
	__le16 IoFlags;
	__le16 EEDPFlags;
	__le32 EEDPBlockSize;
	__le32 SecondaryReferenceTag;
	__le16 SecondaryApplicationTag;
	__le16 ApplicationTagTranslationMask;
	u8 LUN[8];
	__le32 Control;
	union MPI2_SCSI_IO_CDB_UNION CDB;
	union RAID_CONTEXT_UNION RaidContext;
	union {
		union MPI2_SGE_IO_UNION SGL;
		struct {
			struct {} __empty_SGLs;
			union MPI2_SGE_IO_UNION SGLs[0];
		};
	};
};

struct MPI2_DEFAULT_REQUEST_DESCRIPTOR {
	u8 RequestFlags;
	u8 MSIxIndex;
	__le16 SMID;
	__le16 LMID;
	__le16 DescriptorTypeDependent;
};

struct MPI2_HIGH_PRIORITY_REQUEST_DESCRIPTOR {
	u8 RequestFlags;
	u8 MSIxIndex;
	__le16 SMID;
	__le16 LMID;
	__le16 Reserved1;
};

struct MPI2_SCSI_IO_REQUEST_DESCRIPTOR {
	u8 RequestFlags;
	u8 MSIxIndex;
	__le16 SMID;
	__le16 LMID;
	__le16 DevHandle;
};

struct MPI2_SCSI_TARGET_REQUEST_DESCRIPTOR {
	u8 RequestFlags;
	u8 MSIxIndex;
	__le16 SMID;
	__le16 LMID;
	__le16 IoIndex;
};

struct MPI2_RAID_ACCEL_REQUEST_DESCRIPTOR {
	u8 RequestFlags;
	u8 MSIxIndex;
	__le16 SMID;
	__le16 LMID;
	__le16 Reserved;
};

struct MEGASAS_RAID_MFA_IO_REQUEST_DESCRIPTOR {
	u32 RequestFlags: 8;
	u32 MessageAddress1: 24;
	u32 MessageAddress2;
};

union MEGASAS_REQUEST_DESCRIPTOR_UNION {
	struct MPI2_DEFAULT_REQUEST_DESCRIPTOR Default;
	struct MPI2_HIGH_PRIORITY_REQUEST_DESCRIPTOR HighPriority;
	struct MPI2_SCSI_IO_REQUEST_DESCRIPTOR SCSIIO;
	struct MPI2_SCSI_TARGET_REQUEST_DESCRIPTOR SCSITarget;
	struct MPI2_RAID_ACCEL_REQUEST_DESCRIPTOR RAIDAccelerator;
	struct MEGASAS_RAID_MFA_IO_REQUEST_DESCRIPTOR MFAIo;
	union {
		struct {
			__le32 low;
			__le32 high;
		} u;
		__le64 Words;
	};
};

struct MPI2_DEFAULT_REPLY_DESCRIPTOR {
	u8 ReplyFlags;
	u8 MSIxIndex;
	__le16 DescriptorTypeDependent1;
	__le32 DescriptorTypeDependent2;
};

struct MPI2_ADDRESS_REPLY_DESCRIPTOR {
	u8 ReplyFlags;
	u8 MSIxIndex;
	__le16 SMID;
	__le32 ReplyFrameAddress;
};

struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR {
	u8 ReplyFlags;
	u8 MSIxIndex;
	__le16 SMID;
	__le16 TaskTag;
	__le16 Reserved1;
};

struct MPI2_TARGETASSIST_SUCCESS_REPLY_DESCRIPTOR {
	u8 ReplyFlags;
	u8 MSIxIndex;
	__le16 SMID;
	u8 SequenceNumber;
	u8 Reserved1;
	__le16 IoIndex;
};

struct MPI2_TARGET_COMMAND_BUFFER_REPLY_DESCRIPTOR {
	u8 ReplyFlags;
	u8 MSIxIndex;
	u8 VP_ID;
	u8 Flags;
	__le16 InitiatorDevHandle;
	__le16 IoIndex;
};

struct MPI2_RAID_ACCELERATOR_SUCCESS_REPLY_DESCRIPTOR {
	u8 ReplyFlags;
	u8 MSIxIndex;
	__le16 SMID;
	__le32 Reserved;
};

union MPI2_REPLY_DESCRIPTORS_UNION {
	struct MPI2_DEFAULT_REPLY_DESCRIPTOR Default;
	struct MPI2_ADDRESS_REPLY_DESCRIPTOR AddressReply;
	struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR SCSIIOSuccess;
	struct MPI2_TARGETASSIST_SUCCESS_REPLY_DESCRIPTOR TargetAssistSuccess;
	struct MPI2_TARGET_COMMAND_BUFFER_REPLY_DESCRIPTOR TargetCommandBuffer;
	struct MPI2_RAID_ACCELERATOR_SUCCESS_REPLY_DESCRIPTOR RAIDAcceleratorSuccess;
	__le64 Words;
};

struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY {
	u64 RDPQBaseAddress;
	u32 Reserved1;
	u32 Reserved2;
};

struct MR_PD_CFG_SEQ {
	u16 seqNum;
	u16 devHandle;
	struct {
		u8 tmCapable: 1;
		u8 reserved: 7;
	} capability;
	u8 reserved;
	u16 pd_target_id;
};

struct MR_PD_CFG_SEQ_NUM_SYNC {
	__le32 size;
	__le32 count;
	struct MR_PD_CFG_SEQ seq[0];
};

struct LD_LOAD_BALANCE_INFO {
	u8 loadBalanceFlag;
	u8 reserved1;
	atomic_t scsi_pending_cmds[256];
	u64 last_accessed_block[256];
};

struct _LD_SPAN_SET {
	u64 log_start_lba;
	u64 log_end_lba;
	u64 span_row_start;
	u64 span_row_end;
	u64 data_strip_start;
	u64 data_strip_end;
	u64 data_row_start;
	u64 data_row_end;
	u8 strip_offset[8];
	u32 span_row_data_width;
	u32 diff;
	u32 reserved[2];
};

typedef struct _LD_SPAN_SET LD_SPAN_SET;

struct LOG_BLOCK_SPAN_INFO {
	LD_SPAN_SET span_set[8];
};

struct STREAM_DETECT {
	u64 next_seq_lba;
	struct megasas_cmd_fusion *first_cmd_fusion;
	struct megasas_cmd_fusion *last_cmd_fusion;
	u32 count_cmds_in_stream;
	u16 num_sges_in_group;
	u8 is_read;
	u8 group_depth;
	bool group_flush;
	u8 reserved[7];
};

struct LD_STREAM_DETECT {
	bool write_back;
	bool fp_write_enabled;
	bool members_ssds;
	bool fp_cache_bypass_capable;
	u32 mru_bit_map;
	struct STREAM_DETECT stream_track[8];
};

struct MPI2_IOC_INIT_REQUEST {
	u8 WhoInit;
	u8 Reserved1;
	u8 ChainOffset;
	u8 Function;
	__le16 Reserved2;
	u8 Reserved3;
	u8 MsgFlags;
	u8 VP_ID;
	u8 VF_ID;
	__le16 Reserved4;
	__le16 MsgVersion;
	__le16 HeaderVersion;
	u32 Reserved5;
	__le16 Reserved6;
	u8 HostPageSize;
	u8 HostMSIxVectors;
	__le16 Reserved8;
	__le16 SystemRequestFrameSize;
	__le16 ReplyDescriptorPostQueueDepth;
	__le16 ReplyFreeQueueDepth;
	__le32 SenseBufferAddressHigh;
	__le32 SystemReplyAddressHigh;
	__le64 SystemRequestFrameBaseAddress;
	__le64 ReplyDescriptorPostQueueAddress;
	__le64 ReplyFreeQueueAddress;
	__le64 TimeStamp;
};

typedef struct LOG_BLOCK_SPAN_INFO *PLD_SPAN_INFO;

struct IO_REQUEST_INFO {
	u64 ldStartBlock;
	u32 numBlocks;
	u16 ldTgtId;
	u8 isRead;
	__le16 devHandle;
	u8 pd_interface;
	u64 pdBlock;
	u8 fpOkForIo;
	u8 IoforUnevenSpan;
	u8 start_span;
	u8 do_fp_rlbypass;
	u64 start_row;
	u8 span_arm;
	u8 pd_after_lb;
	u16 r1_alt_dev_handle;
	bool ra_capable;
	u8 data_arms;
};

struct onfi_ext_ecc_info {
	u8 ecc_bits;
	u8 codeword_size;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 reserved[2];
};

struct onfi_ext_section {
	u8 type;
	u8 length;
};

struct onfi_ext_param_page {
	__le16 crc;
	u8 sig[4];
	u8 reserved0[10];
	struct onfi_ext_section sections[8];
};

enum pmic_arb_channel {
	PMIC_ARB_CHANNEL_RW = 0,
	PMIC_ARB_CHANNEL_OBS = 1,
};

struct spmi_pmic_arb;

struct spmi_controller;

struct pmic_arb_ver_ops {
	const char *ver_str;
	int (*ppid_to_apid)(struct spmi_pmic_arb *, u16);
	int (*offset)(struct spmi_pmic_arb *, u8, u16, enum pmic_arb_channel);
	u32 (*fmt_cmd)(u8, u8, u16, u8);
	int (*non_data_cmd)(struct spmi_controller *, u8, u8);
	void * (*owner_acc_status)(struct spmi_pmic_arb *, u8, u16);
	void * (*acc_enable)(struct spmi_pmic_arb *, u16);
	void * (*irq_status)(struct spmi_pmic_arb *, u16);
	void * (*irq_clear)(struct spmi_pmic_arb *, u16);
	u32 (*apid_map_offset)(u16);
	void * (*apid_owner)(struct spmi_pmic_arb *, u16);
};

struct apid_data;

struct spmi_pmic_arb {
	void *rd_base;
	void *wr_base;
	void *intr;
	void *cnfg;
	void *core;
	resource_size_t core_size;
	raw_spinlock_t lock;
	u8 channel;
	int irq;
	u8 ee;
	u32 bus_instance;
	u16 min_apid;
	u16 max_apid;
	u16 base_apid;
	int apid_count;
	u32 *mapping_table;
	unsigned long mapping_table_valid[8];
	struct irq_domain *domain;
	struct spmi_controller *spmic;
	const struct pmic_arb_ver_ops *ver_ops;
	u16 *ppid_to_apid;
	u16 last_apid;
	struct apid_data *apid_data;
	int max_periphs;
};

struct spmi_controller {
	struct device dev;
	unsigned int nr;
	int (*cmd)(struct spmi_controller *, u8, u8);
	int (*read_cmd)(struct spmi_controller *, u8, u8, u16, u8 *, size_t);
	int (*write_cmd)(struct spmi_controller *, u8, u8, u16, const u8 *, size_t);
};

struct apid_data {
	u16 ppid;
	u8 write_ee;
	u8 irq_ee;
};

enum pmic_arb_chnl_status {
	PMIC_ARB_STATUS_DONE = 1,
	PMIC_ARB_STATUS_FAILURE = 2,
	PMIC_ARB_STATUS_DENIED = 4,
	PMIC_ARB_STATUS_DROPPED = 8,
};

enum pmic_arb_cmd_op_code {
	PMIC_ARB_OP_EXT_WRITEL = 0,
	PMIC_ARB_OP_EXT_READL = 1,
	PMIC_ARB_OP_EXT_WRITE = 2,
	PMIC_ARB_OP_RESET = 3,
	PMIC_ARB_OP_SLEEP = 4,
	PMIC_ARB_OP_SHUTDOWN = 5,
	PMIC_ARB_OP_WAKEUP = 6,
	PMIC_ARB_OP_AUTHENTICATE = 7,
	PMIC_ARB_OP_MSTR_READ = 8,
	PMIC_ARB_OP_MSTR_WRITE = 9,
	PMIC_ARB_OP_EXT_READ = 13,
	PMIC_ARB_OP_WRITE = 14,
	PMIC_ARB_OP_READ = 15,
	PMIC_ARB_OP_ZERO_WRITE = 16,
};

enum qpnpint_regs {
	QPNPINT_REG_RT_STS = 16,
	QPNPINT_REG_SET_TYPE = 17,
	QPNPINT_REG_POLARITY_HIGH = 18,
	QPNPINT_REG_POLARITY_LOW = 19,
	QPNPINT_REG_LATCHED_CLR = 20,
	QPNPINT_REG_EN_SET = 21,
	QPNPINT_REG_EN_CLR = 22,
	QPNPINT_REG_LATCHED_STS = 24,
};

struct spmi_pmic_arb_qpnpint_type {
	u8 type;
	u8 polarity_high;
	u8 polarity_low;
};

struct reg_val {
	u16 reg;
	u32 val;
};

struct vsc8531_edge_rate_table {
	u32 vddmac;
	u32 slowdown[8];
};

struct vsc85xx_hw_stat {
	const char *string;
	u8 reg;
	u16 page;
	u16 mask;
};

enum csr_target {
	MACRO_CTRL = 7,
};

enum rgmii_clock_delay {
	RGMII_CLK_DELAY_0_2_NS = 0,
	RGMII_CLK_DELAY_0_8_NS = 1,
	RGMII_CLK_DELAY_1_1_NS = 2,
	RGMII_CLK_DELAY_1_7_NS = 3,
	RGMII_CLK_DELAY_2_0_NS = 4,
	RGMII_CLK_DELAY_2_3_NS = 5,
	RGMII_CLK_DELAY_2_6_NS = 6,
	RGMII_CLK_DELAY_3_4_NS = 7,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

struct vsc85xx_ptp;

struct vsc8531_private {
	int rate_magic;
	u16 supp_led_modes;
	u32 leds_mode[4];
	u8 nleds;
	const struct vsc85xx_hw_stat *hw_stats;
	u64 *stats;
	int nstats;
	u8 addr;
	unsigned int base_addr;
	struct mii_timestamper mii_ts;
	bool input_clk_init;
	struct vsc85xx_ptp *ptp;
	struct gpio_desc *load_save;
	unsigned int ts_base_addr;
	u8 ts_base_phy;
	struct mutex ts_lock;
	struct mutex phc_lock;
};

struct xgene_enet_pdata;

struct xgene_mac_ops {
	void (*init)(struct xgene_enet_pdata *);
	void (*reset)(struct xgene_enet_pdata *);
	void (*tx_enable)(struct xgene_enet_pdata *);
	void (*rx_enable)(struct xgene_enet_pdata *);
	void (*tx_disable)(struct xgene_enet_pdata *);
	void (*rx_disable)(struct xgene_enet_pdata *);
	void (*get_drop_cnt)(struct xgene_enet_pdata *, u32 *, u32 *);
	void (*set_speed)(struct xgene_enet_pdata *);
	void (*set_mac_addr)(struct xgene_enet_pdata *);
	void (*set_framesize)(struct xgene_enet_pdata *, int);
	void (*set_mss)(struct xgene_enet_pdata *, u16, u8);
	void (*link_state)(struct work_struct *);
	void (*enable_tx_pause)(struct xgene_enet_pdata *, bool);
	void (*flowctl_rx)(struct xgene_enet_pdata *, bool);
	void (*flowctl_tx)(struct xgene_enet_pdata *, bool);
};

enum xgene_enet_id {
	XGENE_ENET1 = 1,
	XGENE_ENET2 = 2,
};

enum xgene_enet_rm {
	RM0 = 0,
	RM1 = 1,
	RM3 = 3,
};

struct xgene_cle_ptree_kn;

struct xgene_cle_dbptr;

struct xgene_cle_ptree {
	struct xgene_cle_ptree_kn *kn;
	struct xgene_cle_dbptr *dbptr;
	u32 num_kn;
	u32 num_dbptr;
	u32 start_node;
	u32 start_pkt;
	u32 start_dbptr;
};

enum xgene_cle_parser {
	PARSER0 = 0,
	PARSER1 = 1,
	PARSER2 = 2,
	PARSER_ALL = 3,
};

struct xgene_enet_cle {
	void *base;
	struct xgene_cle_ptree ptree;
	enum xgene_cle_parser active_parser;
	u32 parsers;
	u32 max_nodes;
	u32 max_dbptrs;
	u32 jump_bytes;
};

struct xgene_enet_desc_ring;

struct xgene_port_ops;

struct xgene_ring_ops;

struct xgene_cle_ops;

struct xgene_enet_pdata {
	struct net_device *ndev;
	struct mii_bus *mdio_bus;
	int phy_speed;
	struct clk *clk;
	struct platform_device *pdev;
	enum xgene_enet_id enet_id;
	struct xgene_enet_desc_ring *tx_ring[8];
	struct xgene_enet_desc_ring *rx_ring[8];
	u16 tx_level[8];
	u16 txc_level[8];
	char *dev_name;
	u32 rx_buff_cnt;
	u32 tx_qcnt_hi;
	u32 irqs[16];
	u8 rxq_cnt;
	u8 txq_cnt;
	u8 cq_cnt;
	void *eth_csr_addr;
	void *eth_ring_if_addr;
	void *eth_diag_csr_addr;
	void *mcx_mac_addr;
	void *mcx_mac_csr_addr;
	void *mcx_stats_addr;
	void *base_addr;
	void *pcs_addr;
	void *ring_csr_addr;
	void *ring_cmd_addr;
	int phy_mode;
	enum xgene_enet_rm rm;
	struct xgene_enet_cle cle;
	u64 *extd_stats;
	u64 false_rflr;
	u64 vlan_rjbr;
	spinlock_t stats_lock;
	const struct xgene_mac_ops *mac_ops;
	spinlock_t mac_lock;
	const struct xgene_port_ops *port_ops;
	struct xgene_ring_ops *ring_ops;
	const struct xgene_cle_ops *cle_ops;
	struct delayed_work link_work;
	u32 port_id;
	u8 cpu_bufnum;
	u8 eth_bufnum;
	u8 bp_bufnum;
	u16 ring_num;
	u32 mss[4];
	u32 mss_refcnt[4];
	spinlock_t mss_lock;
	u8 tx_delay;
	u8 rx_delay;
	bool mdio_driver;
	struct gpio_desc *sfp_rdy;
	bool sfp_gpio_en;
	u32 pause_autoneg;
	bool tx_pause;
	bool rx_pause;
};

enum xgene_enet_ring_cfgsize {
	RING_CFGSIZE_512B = 0,
	RING_CFGSIZE_2KB = 1,
	RING_CFGSIZE_16KB = 2,
	RING_CFGSIZE_64KB = 3,
	RING_CFGSIZE_512KB = 4,
	RING_CFGSIZE_INVALID = 5,
};

struct xgene_enet_raw_desc;

struct xgene_enet_raw_desc16;

struct xgene_enet_desc_ring {
	struct net_device *ndev;
	u16 id;
	u16 num;
	u16 head;
	u16 tail;
	u16 exp_buf_tail;
	u16 slots;
	u16 irq;
	char irq_name[16];
	u32 size;
	u32 state[6];
	void *cmd_base;
	void *cmd;
	dma_addr_t dma;
	dma_addr_t irq_mbox_dma;
	void *irq_mbox_addr;
	u16 dst_ring_num;
	u16 nbufpool;
	int npagepool;
	u8 index;
	u32 flags;
	struct sk_buff **rx_skb;
	struct sk_buff **cp_skb;
	dma_addr_t *frag_dma_addr;
	struct page **frag_page;
	enum xgene_enet_ring_cfgsize cfgsize;
	struct xgene_enet_desc_ring *cp_ring;
	struct xgene_enet_desc_ring *buf_pool;
	struct xgene_enet_desc_ring *page_pool;
	struct napi_struct napi;
	union {
		void *desc_addr;
		struct xgene_enet_raw_desc *raw_desc;
		struct xgene_enet_raw_desc16 *raw_desc16;
	};
	__le64 *exp_bufs;
	u64 tx_packets;
	u64 tx_bytes;
	u64 tx_dropped;
	u64 tx_errors;
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_dropped;
	u64 rx_errors;
	u64 rx_length_errors;
	u64 rx_crc_errors;
	u64 rx_frame_errors;
	u64 rx_fifo_errors;
};

struct xgene_enet_raw_desc {
	__le64 m0;
	__le64 m1;
	__le64 m2;
	__le64 m3;
};

struct xgene_enet_raw_desc16 {
	__le64 m0;
	__le64 m1;
};

struct xgene_cle_ptree_key {
	u8 priority;
	u16 result_pointer;
};

struct xgene_cle_ptree_kn {
	u8 node_type;
	u8 num_keys;
	struct xgene_cle_ptree_key key[32];
};

struct xgene_cle_dbptr {
	u8 split_boundary;
	u8 mirror_nxtfpsel;
	u8 mirror_fpsel;
	u16 mirror_dstqid;
	u8 drop;
	u8 mirror;
	u8 hdr_data_split;
	u64 hopinfomsbs;
	u8 DR;
	u8 HR;
	u64 hopinfomlsbs;
	u16 h0enq_num;
	u8 h0fpsel;
	u8 nxtfpsel;
	u8 fpsel;
	u16 dstqid;
	u8 cle_priority;
	u8 cle_flowgroup;
	u8 cle_perflow;
	u8 cle_insert_timestamp;
	u8 stash;
	u8 in;
	u8 perprioen;
	u8 perflowgroupen;
	u8 perflowen;
	u8 selhash;
	u8 selhdrext;
	u8 mirror_nxtfpsel_msb;
	u8 mirror_fpsel_msb;
	u8 hfpsel_msb;
	u8 nxtfpsel_msb;
	u8 fpsel_msb;
};

struct xgene_port_ops {
	int (*reset)(struct xgene_enet_pdata *);
	void (*clear)(struct xgene_enet_pdata *, struct xgene_enet_desc_ring *);
	void (*cle_bypass)(struct xgene_enet_pdata *, u32, u16, u16);
	void (*shutdown)(struct xgene_enet_pdata *);
};

struct xgene_ring_ops {
	u8 num_ring_config;
	u8 num_ring_id_shift;
	struct xgene_enet_desc_ring * (*setup)(struct xgene_enet_desc_ring *);
	void (*clear)(struct xgene_enet_desc_ring *);
	void (*wr_cmd)(struct xgene_enet_desc_ring *, int);
	u32 (*len)(struct xgene_enet_desc_ring *);
	void (*coalesce)(struct xgene_enet_desc_ring *);
};

struct xgene_cle_ops {
	int (*cle_init)(struct xgene_enet_pdata *);
};

enum xgene_enet_err_code {
	HBF_READ_DATA = 3,
	HBF_LL_READ = 4,
	BAD_WORK_MSG = 6,
	BUFPOOL_TIMEOUT = 15,
	INGRESS_CRC = 16,
	INGRESS_CHECKSUM = 17,
	INGRESS_TRUNC_FRAME = 18,
	INGRESS_PKT_LEN = 19,
	INGRESS_PKT_UNDER = 20,
	INGRESS_FIFO_OVERRUN = 21,
	INGRESS_CHECKSUM_COMPUTE = 26,
	ERR_CODE_INVALID = 27,
};

enum xgene_enet_cmd {
	XGENE_ENET_WR_CMD = 2147483648,
	XGENE_ENET_RD_CMD = 1073741824,
};

enum xgene_enet_ring_bufnum {
	RING_BUFNUM_REGULAR = 0,
	RING_BUFNUM_BUFPOOL = 32,
	RING_BUFNUM_INVALID = 33,
};

enum xgene_ring_owner {
	RING_OWNER_ETH0 = 0,
	RING_OWNER_ETH1 = 1,
	RING_OWNER_CPU = 15,
	RING_OWNER_INVALID = 16,
};

enum xgene_enet_ring_type {
	RING_DISABLED = 0,
	RING_REGULAR = 1,
	RING_BUFPOOL = 2,
};

struct xgene_mdio_pdata {
	struct clk *clk;
	struct device *dev;
	void *mac_csr_addr;
	void *diag_csr_addr;
	void *mdio_csr_addr;
	struct mii_bus *mdio_bus;
	int mdio_id;
	spinlock_t mac_lock;
};

enum fman_mac_exceptions {
	FM_MAC_EX_10G_MDIO_SCAN_EVENT = 0,
	FM_MAC_EX_10G_MDIO_CMD_CMPL = 1,
	FM_MAC_EX_10G_REM_FAULT = 2,
	FM_MAC_EX_10G_LOC_FAULT = 3,
	FM_MAC_EX_10G_TX_ECC_ER = 4,
	FM_MAC_EX_10G_TX_FIFO_UNFL = 5,
	FM_MAC_EX_10G_TX_FIFO_OVFL = 6,
	FM_MAC_EX_10G_TX_ER = 7,
	FM_MAC_EX_10G_RX_FIFO_OVFL = 8,
	FM_MAC_EX_10G_RX_ECC_ER = 9,
	FM_MAC_EX_10G_RX_JAB_FRM = 10,
	FM_MAC_EX_10G_RX_OVRSZ_FRM = 11,
	FM_MAC_EX_10G_RX_RUNT_FRM = 12,
	FM_MAC_EX_10G_RX_FRAG_FRM = 13,
	FM_MAC_EX_10G_RX_LEN_ER = 14,
	FM_MAC_EX_10G_RX_CRC_ER = 15,
	FM_MAC_EX_10G_RX_ALIGN_ER = 16,
	FM_MAC_EX_1G_BAB_RX = 17,
	FM_MAC_EX_1G_RX_CTL = 18,
	FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET = 19,
	FM_MAC_EX_1G_BAB_TX = 20,
	FM_MAC_EX_1G_TX_CTL = 21,
	FM_MAC_EX_1G_TX_ERR = 22,
	FM_MAC_EX_1G_LATE_COL = 23,
	FM_MAC_EX_1G_COL_RET_LMT = 24,
	FM_MAC_EX_1G_TX_FIFO_UNDRN = 25,
	FM_MAC_EX_1G_MAG_PCKT = 26,
	FM_MAC_EX_1G_MII_MNG_RD_COMPLET = 27,
	FM_MAC_EX_1G_MII_MNG_WR_COMPLET = 28,
	FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET = 29,
	FM_MAC_EX_1G_DATA_ERR = 30,
	FM_MAC_1G_RX_DATA_ERR = 31,
	FM_MAC_EX_1G_1588_TS_RX_ERR = 32,
	FM_MAC_EX_1G_RX_MIB_CNT_OVFL = 33,
	FM_MAC_EX_TS_FIFO_ECC_ERR = 34,
	FM_MAC_EX_MAGIC_PACKET_INDICATION = 26,
};

enum fman_exceptions {
	FMAN_EX_DMA_BUS_ERROR = 0,
	FMAN_EX_DMA_READ_ECC = 1,
	FMAN_EX_DMA_SYSTEM_WRITE_ECC = 2,
	FMAN_EX_DMA_FM_WRITE_ECC = 3,
	FMAN_EX_DMA_SINGLE_PORT_ECC = 4,
	FMAN_EX_FPM_STALL_ON_TASKS = 5,
	FMAN_EX_FPM_SINGLE_ECC = 6,
	FMAN_EX_FPM_DOUBLE_ECC = 7,
	FMAN_EX_QMI_SINGLE_ECC = 8,
	FMAN_EX_QMI_DOUBLE_ECC = 9,
	FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID = 10,
	FMAN_EX_BMI_LIST_RAM_ECC = 11,
	FMAN_EX_BMI_STORAGE_PROFILE_ECC = 12,
	FMAN_EX_BMI_STATISTICS_RAM_ECC = 13,
	FMAN_EX_BMI_DISPATCH_RAM_ECC = 14,
	FMAN_EX_IRAM_ECC = 15,
	FMAN_EX_MURAM_ECC = 16,
};

struct mac_address {
	u8 addr[6];
	struct list_head list;
};

typedef u8 enet_addr_t[6];

struct netdev_hw_addr {
	struct list_head list;
	struct rb_node node;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

struct fman_port;

struct phylink_mac_ops;

struct fman_mac;

struct mac_priv_s;

struct mac_device {
	void *vaddr;
	struct device *dev;
	struct resource *res;
	u8 addr[6];
	struct fman_port *port[2];
	struct phylink *phylink;
	struct phylink_config phylink_config;
	phy_interface_t phy_if;
	bool promisc;
	bool allmulti;
	const struct phylink_mac_ops *phylink_ops;
	int (*enable)(struct fman_mac *);
	void (*disable)(struct fman_mac *);
	int (*set_promisc)(struct fman_mac *, bool);
	int (*change_addr)(struct fman_mac *, const enet_addr_t *);
	int (*set_allmulti)(struct fman_mac *, bool);
	int (*set_tstamp)(struct fman_mac *, bool);
	int (*set_multi)(struct net_device *, struct mac_device *);
	int (*set_exception)(struct fman_mac *, enum fman_mac_exceptions, bool);
	int (*add_hash_mac_addr)(struct fman_mac *, enet_addr_t *);
	int (*remove_hash_mac_addr)(struct fman_mac *, enet_addr_t *);
	void (*update_speed)(struct mac_device *, int);
	struct fman_mac *fman_mac;
	struct mac_priv_s *priv;
};

struct phylink_mac_ops {
	unsigned long (*mac_get_caps)(struct phylink_config *, phy_interface_t);
	struct phylink_pcs * (*mac_select_pcs)(struct phylink_config *, phy_interface_t);
	int (*mac_prepare)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_config)(struct phylink_config *, unsigned int, const struct phylink_link_state *);
	int (*mac_finish)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_link_down)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_link_up)(struct phylink_config *, struct phy_device *, unsigned int, phy_interface_t, int, int, bool, bool);
};

struct fman;

struct mac_priv_s {
	u8 cell_index;
	struct fman *fman;
	struct list_head mc_addr_list;
	struct platform_device *eth_dev;
	u16 speed;
};

struct fman_intr_src {
	void (*isr_cb)(void *);
	void *src_handle;
};

typedef irqreturn_t fman_exceptions_cb(struct fman *, enum fman_exceptions);

typedef irqreturn_t fman_bus_error_cb(struct fman *, u8, u64, u8, u16);

struct fman_dts_params {
	void *base_addr;
	struct resource *res;
	u8 id;
	int err_irq;
	u16 clk_freq;
	u32 qman_channel_base;
	u32 num_of_qman_channels;
	struct resource muram_res;
};

struct fman_fpm_regs;

struct fman_bmi_regs;

struct fman_qmi_regs;

struct fman_dma_regs;

struct fman_hwp_regs;

struct fman_kg_regs;

struct fman_state_struct;

struct fman_cfg;

struct muram_info;

struct fman_keygen;

struct fman {
	struct device *dev;
	void *base_addr;
	struct fman_intr_src intr_mng[24];
	struct fman_fpm_regs *fpm_regs;
	struct fman_bmi_regs *bmi_regs;
	struct fman_qmi_regs *qmi_regs;
	struct fman_dma_regs *dma_regs;
	struct fman_hwp_regs *hwp_regs;
	struct fman_kg_regs *kg_regs;
	fman_exceptions_cb *exception_cb;
	fman_bus_error_cb *bus_error_cb;
	spinlock_t spinlock;
	struct fman_state_struct *state;
	struct fman_cfg *cfg;
	struct muram_info *muram;
	struct fman_keygen *keygen;
	unsigned long cam_offset;
	size_t cam_size;
	unsigned long fifo_offset;
	size_t fifo_size;
	u32 liodn_base[64];
	u32 liodn_offset[64];
	struct fman_dts_params dts_params;
};

struct dpaa_eth_data {
	struct mac_device *mac_dev;
	int mac_hw_id;
	int fman_hw_id;
};

typedef void fman_mac_exception_cb(struct mac_device *, enum fman_mac_exceptions);

struct fman_mac_params {
	u8 mac_id;
	void *fm;
	fman_mac_exception_cb *event_cb;
	fman_mac_exception_cb *exception_cb;
};

enum enetc_errata {
	ENETC_ERR_VLAN_ISOL = 1,
	ENETC_ERR_UCMCSWP = 2,
};

struct tgs_gcl_conf {
	u8 atc;
	u8 res[7];
	struct {
		u8 res1[4];
		__le16 acl_len;
		u8 res2[2];
	};
};

struct streamid_conf {
	__le32 stream_handle;
	__le32 iports;
	u8 id_type;
	u8 oui[3];
	u8 res[3];
	u8 en;
};

struct sgcl_conf {
	u8 aipv;
	u8 res[2];
	u8 agtst;
	u8 res1[4];
	union {
		struct {
			u8 res2[4];
			u8 acl_len;
			u8 res3[3];
		};
		u8 cct[8];
	};
};

struct sfi_conf {
	__le32 stream_handle;
	u8 multi;
	u8 res[2];
	u8 sthm;
	__le16 fm_inst_table_index;
	__le16 msdu;
	__le16 sg_inst_table_index;
	u8 res1[2];
	__le32 input_ports;
	u8 res2[3];
	u8 en;
};

struct sgi_table {
	u8 res[8];
	u8 oipv;
	u8 res0[2];
	u8 ocgtst;
	u8 res1[7];
	u8 gset;
	u8 oacl_len;
	u8 res2[2];
	u8 en;
};

struct fmi_conf {
	__le32 cir;
	__le32 cbs;
	__le32 eir;
	__le32 ebs;
	u8 conf;
	u8 res1;
	u8 ir_fpp;
	u8 res2[4];
	u8 en;
};

struct enetc_cbd {
	union {
		struct sfi_conf sfi_conf;
		struct sgi_table sgi_table;
		struct fmi_conf fmi_conf;
		struct {
			__le32 addr[2];
			union {
				__le32 opt[4];
				struct tgs_gcl_conf gcl_conf;
				struct streamid_conf sid_set;
				struct sgcl_conf sgcl_conf;
			};
		};
		__le32 data[6];
	};
	__le16 index;
	__le16 length;
	u8 cmd;
	u8 cls;
	u8 _res;
	u8 status_flags;
};

struct enetc_cbdr {
	void *bd_base;
	void *pir;
	void *cir;
	void *mr;
	int bd_count;
	int next_to_use;
	int next_to_clean;
	dma_addr_t bd_dma_base;
	struct device *dma_dev;
};

struct enetc_hw {
	void *reg;
	void *port;
	void *global;
};

struct enetc_si {
	struct pci_dev *pdev;
	struct enetc_hw hw;
	enum enetc_errata errata;
	struct net_device *ndev;
	struct enetc_cbdr cbd_ring;
	int num_rx_rings;
	int num_tx_rings;
	int num_fs_entries;
	int num_rss;
	unsigned short pad;
	int hw_features;
};

struct enetc_cmd_rfse {
	u8 smac_h[6];
	u8 smac_m[6];
	u8 dmac_h[6];
	u8 dmac_m[6];
	__be32 sip_h[4];
	__be32 sip_m[4];
	__be32 dip_h[4];
	__be32 dip_m[4];
	u16 ethtype_h;
	u16 ethtype_m;
	u16 ethtype4_h;
	u16 ethtype4_m;
	u16 sport_h;
	u16 sport_m;
	u16 dport_h;
	u16 dport_m;
	u16 vlan_h;
	u16 vlan_m;
	u8 proto_h;
	u8 proto_m;
	u16 flags;
	u16 result;
	u16 mode;
};

enum mvpp2_tx_buf_type {
	MVPP2_TYPE_SKB = 0,
	MVPP2_TYPE_XDP_TX = 1,
	MVPP2_TYPE_XDP_NDO = 2,
};

struct mvpp2_port;

struct mvpp2_queue_vector {
	int irq;
	struct napi_struct napi;
	enum {
		MVPP2_QUEUE_VECTOR_SHARED = 0,
		MVPP2_QUEUE_VECTOR_PRIVATE = 1,
	} type;
	int sw_thread_id;
	u16 sw_thread_mask;
	int first_rxq;
	int nrxqs;
	u32 pending_cause_rx;
	struct mvpp2_port *port;
	struct cpumask *mask;
};

struct mvpp2_hwtstamp_queue {
	struct sk_buff *skb[32];
	u8 next;
};

struct mvpp2;

struct mvpp2_rx_queue;

struct mvpp2_tx_queue;

struct mvpp2_port_pcpu;

struct mvpp2_pcpu_stats;

struct mvpp2_bm_pool;

struct mvpp2_ethtool_fs;

struct mvpp2_port {
	u8 id;
	int gop_id;
	int port_irq;
	struct mvpp2 *priv;
	struct fwnode_handle *fwnode;
	void *base;
	void *stats_base;
	struct mvpp2_rx_queue **rxqs;
	unsigned int nrxqs;
	struct mvpp2_tx_queue **txqs;
	unsigned int ntxqs;
	struct net_device *dev;
	struct bpf_prog *xdp_prog;
	int pkt_size;
	struct mvpp2_port_pcpu __attribute__((btf_type_tag("percpu"))) *pcpu;
	spinlock_t bm_lock[9];
	spinlock_t tx_lock[9];
	unsigned long flags;
	u16 tx_ring_size;
	u16 rx_ring_size;
	struct mvpp2_pcpu_stats __attribute__((btf_type_tag("percpu"))) *stats;
	u64 *ethtool_stats;
	unsigned long state;
	struct mutex gather_stats_lock;
	struct delayed_work stats_work;
	struct device_node *of_node;
	phy_interface_t phy_interface;
	struct phylink *phylink;
	struct phylink_config phylink_config;
	struct phylink_pcs pcs_gmac;
	struct phylink_pcs pcs_xlg;
	struct phy *comphy;
	struct mvpp2_bm_pool *pool_long;
	struct mvpp2_bm_pool *pool_short;
	u8 first_rxq;
	struct mvpp2_queue_vector qvecs[9];
	unsigned int nqvecs;
	bool has_tx_irqs;
	u32 tx_time_coal;
	struct mvpp2_ethtool_fs *rfs_rules[4];
	int n_rfs_rules;
	int rss_ctx[8];
	bool hwtstamp;
	bool rx_hwtstamp;
	enum hwtstamp_tx_types tx_hwtstamp_type;
	struct mvpp2_hwtstamp_queue tx_hwtstamp_queue[2];
	bool tx_fc;
};

struct mvpp2_tai;

struct mvpp2_prs_shadow;

struct mvpp2_dbgfs_entries;

struct mvpp2_rss_table;

struct mvpp2 {
	void *lms_base;
	void *iface_base;
	void *cm3_base;
	void *swth_base[9];
	struct regmap *sysctrl_base;
	struct clk *pp_clk;
	struct clk *gop_clk;
	struct clk *mg_clk;
	struct clk *mg_core_clk;
	struct clk *axi_clk;
	int port_count;
	struct mvpp2_port *port_list[4];
	unsigned long port_map;
	struct mvpp2_tai *tai;
	unsigned int nthreads;
	unsigned long lock_map;
	struct mvpp2_tx_queue *aggr_txqs;
	int percpu_pools;
	struct mvpp2_bm_pool *bm_pools;
	struct mvpp2_prs_shadow *prs_shadow;
	bool *prs_double_vlans;
	u32 tclk;
	enum {
		MVPP21 = 0,
		MVPP22 = 1,
		MVPP23 = 2,
	} hw_version;
	unsigned int max_port_rxqs;
	char queue_name[30];
	struct workqueue_struct *stats_queue;
	struct dentry *dbgfs_dir;
	struct mvpp2_dbgfs_entries *dbgfs_entries;
	struct mvpp2_rss_table *rss_tables[8];
	struct page_pool *page_pool[32];
	bool global_tx_fc;
	spinlock_t mss_spinlock;
};

struct mvpp2_txq_pcpu;

struct mvpp2_tx_desc;

struct mvpp2_tx_queue {
	u8 id;
	u8 log_id;
	int size;
	int count;
	struct mvpp2_txq_pcpu __attribute__((btf_type_tag("percpu"))) *pcpu;
	u32 done_pkts_coal;
	struct mvpp2_tx_desc *descs;
	dma_addr_t descs_dma;
	int last_desc;
	int next_desc_to_proc;
};

struct mvpp2_txq_pcpu_buf;

struct mvpp2_txq_pcpu {
	unsigned int thread;
	int size;
	int count;
	int wake_threshold;
	int stop_threshold;
	int reserved_num;
	struct mvpp2_txq_pcpu_buf *buffs;
	int txq_put_index;
	int txq_get_index;
	char *tso_headers;
	dma_addr_t tso_headers_dma;
};

struct mvpp2_txq_pcpu_buf {
	enum mvpp2_tx_buf_type type;
	union {
		struct xdp_frame *xdpf;
		struct sk_buff *skb;
	};
	dma_addr_t dma;
	size_t size;
};

struct mvpp21_tx_desc {
	__le32 command;
	u8 packet_offset;
	u8 phys_txq;
	__le16 data_size;
	__le32 buf_dma_addr;
	__le32 buf_cookie;
	__le32 reserved1[3];
	__le32 reserved2;
};

struct mvpp22_tx_desc {
	__le32 command;
	u8 packet_offset;
	u8 phys_txq;
	__le16 data_size;
	__le32 ptp_descriptor;
	__le32 reserved2;
	__le64 buf_dma_addr_ptp;
	__le64 buf_cookie_misc;
};

struct mvpp2_tx_desc {
	union {
		struct mvpp21_tx_desc pp21;
		struct mvpp22_tx_desc pp22;
	};
};

struct mvpp2_bm_pool {
	int id;
	int size;
	int size_bytes;
	int buf_num;
	int buf_size;
	int pkt_size;
	int frag_size;
	u32 *virt_addr;
	dma_addr_t dma_addr;
	u32 port_map;
};

struct mvpp2_prs_shadow {
	bool valid;
	bool finish;
	int lu;
	int udf;
	u32 ri;
	u32 ri_mask;
};

struct mvpp2_rss_table {
	u32 indir[32];
};

struct mvpp2_rx_desc;

struct mvpp2_rx_queue {
	u8 id;
	int size;
	u32 pkts_coal;
	u32 time_coal;
	struct mvpp2_rx_desc *descs;
	dma_addr_t descs_dma;
	int last_desc;
	int next_desc_to_proc;
	int port;
	int logic_rxq;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq_short;
	struct xdp_rxq_info xdp_rxq_long;
};

struct mvpp21_rx_desc {
	__le32 status;
	__le16 reserved1;
	__le16 data_size;
	__le32 buf_dma_addr;
	__le32 buf_cookie;
	__le16 reserved2;
	__le16 reserved3;
	u8 reserved4;
	u8 reserved5;
	__le16 reserved6;
	__le32 reserved7;
	__le32 reserved8;
};

struct mvpp22_rx_desc {
	__le32 status;
	__le16 reserved1;
	__le16 data_size;
	__le32 reserved2;
	__le32 timestamp;
	__le64 buf_dma_addr_key_hash;
	__le64 buf_cookie_misc;
};

struct mvpp2_rx_desc {
	union {
		struct mvpp21_rx_desc pp21;
		struct mvpp22_rx_desc pp22;
	};
};

struct mvpp2_port_pcpu {
	struct hrtimer tx_done_timer;
	struct net_device *dev;
	bool timer_scheduled;
};

struct mvpp2_pcpu_stats {
	struct u64_stats_sync syncp;
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	u64 xdp_redirect;
	u64 xdp_pass;
	u64 xdp_drop;
	u64 xdp_xmit;
	u64 xdp_xmit_err;
	u64 xdp_tx;
	u64 xdp_tx_err;
};

struct mvpp2_rfs_rule {
	int loc;
	int flow_type;
	int c2_index;
	u16 hek_fields;
	u8 engine;
	u64 c2_tcam;
	u64 c2_tcam_mask;
	struct flow_rule *flow;
};

struct mvpp2_ethtool_fs {
	struct mvpp2_rfs_rule rule;
	struct ethtool_rxnfc rxnfc;
};

enum mvpp2_prs_l2_cast {
	MVPP2_PRS_L2_UNI_CAST = 0,
	MVPP2_PRS_L2_MULTI_CAST = 1,
};

enum mvpp2_prs_lookup {
	MVPP2_PRS_LU_MH = 0,
	MVPP2_PRS_LU_MAC = 1,
	MVPP2_PRS_LU_DSA = 2,
	MVPP2_PRS_LU_VLAN = 3,
	MVPP2_PRS_LU_VID = 4,
	MVPP2_PRS_LU_L2 = 5,
	MVPP2_PRS_LU_PPPOE = 6,
	MVPP2_PRS_LU_IP4 = 7,
	MVPP2_PRS_LU_IP6 = 8,
	MVPP2_PRS_LU_FLOWS = 9,
	MVPP2_PRS_LU_LAST = 10,
};

enum mvpp2_prs_udf {
	MVPP2_PRS_UDF_MAC_DEF = 0,
	MVPP2_PRS_UDF_MAC_RANGE = 1,
	MVPP2_PRS_UDF_L2_DEF = 2,
	MVPP2_PRS_UDF_L2_DEF_COPY = 3,
	MVPP2_PRS_UDF_L2_USER = 4,
};

enum mvpp2_tag_type {
	MVPP2_TAG_TYPE_NONE = 0,
	MVPP2_TAG_TYPE_MH = 1,
	MVPP2_TAG_TYPE_DSA = 2,
	MVPP2_TAG_TYPE_EDSA = 3,
	MVPP2_TAG_TYPE_VLAN = 4,
	MVPP2_TAG_TYPE_LAST = 5,
};

enum mvpp2_prs_l3_cast {
	MVPP2_PRS_L3_UNI_CAST = 0,
	MVPP2_PRS_L3_MULTI_CAST = 1,
	MVPP2_PRS_L3_BROAD_CAST = 2,
};

struct mvpp2_prs_entry {
	u32 index;
	u32 tcam[6];
	u32 sram[4];
};

enum xenbus_state {
	XenbusStateUnknown = 0,
	XenbusStateInitialising = 1,
	XenbusStateInitWait = 2,
	XenbusStateInitialised = 3,
	XenbusStateConnected = 4,
	XenbusStateClosing = 5,
	XenbusStateClosed = 6,
	XenbusStateReconfiguring = 7,
	XenbusStateReconfigured = 8,
};

struct xenbus_device_id;

struct xenbus_device;

struct xenbus_driver {
	const char *name;
	const struct xenbus_device_id *ids;
	bool allow_rebind;
	bool not_essential;
	int (*probe)(struct xenbus_device *, const struct xenbus_device_id *);
	void (*otherend_changed)(struct xenbus_device *, enum xenbus_state);
	void (*remove)(struct xenbus_device *);
	int (*suspend)(struct xenbus_device *);
	int (*resume)(struct xenbus_device *);
	int (*uevent)(const struct xenbus_device *, struct kobj_uevent_env *);
	struct device_driver driver;
	int (*read_otherend_details)(struct xenbus_device *);
	int (*is_ready)(struct xenbus_device *);
	void (*reclaim_memory)(struct xenbus_device *);
};

struct xenbus_device_id {
	char devicetype[32];
};

struct xenbus_watch {
	struct list_head list;
	const char *node;
	unsigned int nr_pending;
	bool (*will_handle)(struct xenbus_watch *, const char *, const char *);
	void (*callback)(struct xenbus_watch *, const char *, const char *);
};

struct xenbus_device {
	const char *devicetype;
	const char *nodename;
	const char *otherend;
	int otherend_id;
	struct xenbus_watch otherend_watch;
	struct device dev;
	enum xenbus_state state;
	struct completion down;
	struct work_struct work;
	struct semaphore reclaim_sem;
	atomic_t event_channels;
	atomic_t events;
	atomic_t spurious_events;
	atomic_t jiffies_eoi_delayed;
	unsigned int spurious_threshold;
};

struct xennet_stat {
	char name[32];
	u16 offset;
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
	NAPI_STATE_PREFER_BUSY_POLL = 7,
	NAPI_STATE_THREADED = 8,
	NAPI_STATE_SCHED_THREADED = 9,
};

struct netfront_stats {
	u64 packets;
	u64 bytes;
	struct u64_stats_sync syncp;
};

typedef unsigned int RING_IDX;

struct xen_netif_extra_info {
	uint8_t type;
	uint8_t flags;
	union {
		struct {
			uint16_t size;
			uint8_t type;
			uint8_t pad;
			uint16_t features;
		} gso;
		struct {
			uint8_t addr[6];
		} mcast;
		struct {
			uint8_t type;
			uint8_t algorithm;
			uint8_t value[4];
		} hash;
		struct {
			uint16_t headroom;
			uint16_t pad[2];
		} xdp;
		uint16_t pad[3];
	} u;
};

typedef s16 int16_t;

struct xen_netif_tx_response {
	uint16_t id;
	int16_t status;
};

typedef uint32_t grant_ref_t;

struct xen_netif_tx_sring;

struct xen_netif_tx_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct xen_netif_tx_sring *sring;
};

struct xen_netif_rx_sring;

struct xen_netif_rx_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct xen_netif_rx_sring *sring;
};

struct netfront_info;

struct netfront_queue {
	unsigned int id;
	char name[22];
	struct netfront_info *info;
	struct bpf_prog __attribute__((btf_type_tag("rcu"))) *xdp_prog;
	struct napi_struct napi;
	unsigned int tx_evtchn;
	unsigned int rx_evtchn;
	unsigned int tx_irq;
	unsigned int rx_irq;
	char tx_irq_name[25];
	char rx_irq_name[25];
	spinlock_t tx_lock;
	struct xen_netif_tx_front_ring tx;
	int tx_ring_ref;
	struct sk_buff *tx_skbs[256];
	unsigned short tx_link[256];
	grant_ref_t gref_tx_head;
	grant_ref_t grant_tx_ref[256];
	struct page *grant_tx_page[256];
	unsigned int tx_skb_freelist;
	unsigned int tx_pend_queue;
	long: 64;
	long: 64;
	spinlock_t rx_lock;
	struct xen_netif_rx_front_ring rx;
	int rx_ring_ref;
	struct timer_list rx_refill_timer;
	struct sk_buff *rx_skbs[256];
	grant_ref_t gref_rx_head;
	grant_ref_t grant_rx_ref[256];
	unsigned int rx_rsp_unconsumed;
	spinlock_t rx_cons_lock;
	struct page_pool *page_pool;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct netfront_info {
	struct list_head list;
	struct net_device *netdev;
	struct xenbus_device *xbdev;
	struct netfront_queue *queues;
	struct netfront_stats __attribute__((btf_type_tag("percpu"))) *rx_stats;
	struct netfront_stats __attribute__((btf_type_tag("percpu"))) *tx_stats;
	bool netback_has_xdp_headroom;
	bool netfront_xdp_enabled;
	bool broken;
	bool bounce;
	atomic_t rx_gso_checksum_fixup;
};

struct xen_netif_tx_request {
	grant_ref_t gref;
	uint16_t offset;
	uint16_t flags;
	uint16_t id;
	uint16_t size;
};

union xen_netif_tx_sring_entry {
	struct xen_netif_tx_request req;
	struct xen_netif_tx_response rsp;
};

struct xen_netif_tx_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union xen_netif_tx_sring_entry ring[1];
};

struct xen_netif_rx_request {
	uint16_t id;
	uint16_t pad;
	grant_ref_t gref;
};

struct xen_netif_rx_response {
	uint16_t id;
	uint16_t offset;
	uint16_t flags;
	int16_t status;
};

union xen_netif_rx_sring_entry {
	struct xen_netif_rx_request req;
	struct xen_netif_rx_response rsp;
};

struct xen_netif_rx_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union xen_netif_rx_sring_entry ring[1];
};

struct netfront_cb {
	int pull_to;
};

struct xenbus_transaction {
	u32 id;
};

typedef void (*xen_grant_fn_t)(unsigned long, unsigned int, unsigned int, void *);

struct xennet_gnttab_make_txreq {
	struct netfront_queue *queue;
	struct sk_buff *skb;
	struct page *page;
	struct xen_netif_tx_request *tx;
	struct xen_netif_tx_request tx_local;
	unsigned int size;
};

struct netfront_rx_info {
	struct xen_netif_rx_response rx;
	struct xen_netif_extra_info extras[5];
};

enum dwc2_lx_state {
	DWC2_L0 = 0,
	DWC2_L1 = 1,
	DWC2_L2 = 2,
	DWC2_L3 = 3,
};

enum dwc2_ep0_state {
	DWC2_EP0_SETUP = 0,
	DWC2_EP0_DATA_IN = 1,
	DWC2_EP0_DATA_OUT = 2,
	DWC2_EP0_STATUS_IN = 3,
	DWC2_EP0_STATUS_OUT = 4,
};

struct dwc2_hsotg;

typedef void (*set_params_cb)(struct dwc2_hsotg *);

struct dwc2_hw_params {
	unsigned int op_mode: 3;
	unsigned int arch: 2;
	unsigned int dma_desc_enable: 1;
	unsigned int enable_dynamic_fifo: 1;
	unsigned int en_multiple_tx_fifo: 1;
	unsigned int rx_fifo_size: 16;
	int: 8;
	unsigned int host_nperio_tx_fifo_size: 16;
	unsigned int dev_nperio_tx_fifo_size: 16;
	unsigned int host_perio_tx_fifo_size: 16;
	unsigned int nperio_tx_q_depth: 3;
	unsigned int host_perio_tx_q_depth: 3;
	unsigned int dev_token_q_depth: 5;
	int: 5;
	unsigned int max_transfer_size: 26;
	long: 6;
	unsigned int max_packet_count: 11;
	unsigned int host_channels: 5;
	unsigned int hs_phy_type: 2;
	unsigned int fs_phy_type: 2;
	unsigned int i2c_enable: 1;
	unsigned int acg_enable: 1;
	unsigned int num_dev_ep: 4;
	unsigned int num_dev_in_eps: 4;
	int: 2;
	unsigned int num_dev_perio_in_ep: 4;
	unsigned int total_fifo_size: 16;
	unsigned int power_optimized: 1;
	unsigned int hibernation: 1;
	unsigned int utmi_phy_data_width: 2;
	unsigned int lpm_mode: 1;
	unsigned int ipg_isoc_en: 1;
	unsigned int service_interval_mode: 1;
	u32 snpsid;
	u32 dev_ep_dirs;
	u32 g_tx_fifo_size[16];
};

struct dwc2_core_params {
	struct usb_otg_caps otg_caps;
	u8 phy_type;
	u8 speed;
	u8 phy_utmi_width;
	bool phy_ulpi_ddr;
	bool phy_ulpi_ext_vbus;
	bool enable_dynamic_fifo;
	bool en_multiple_tx_fifo;
	bool i2c_enable;
	bool acg_enable;
	bool ulpi_fs_ls;
	bool ts_dline;
	bool reload_ctl;
	bool uframe_sched;
	bool external_id_pin_ctl;
	int power_down;
	bool no_clock_gating;
	bool lpm;
	bool lpm_clock_gating;
	bool besl;
	bool hird_threshold_en;
	bool service_interval;
	u8 hird_threshold;
	bool activate_stm_fs_transceiver;
	bool activate_stm_id_vb_detection;
	bool activate_ingenic_overcurrent_detection;
	bool ipg_isoc_en;
	u16 max_packet_count;
	u32 max_transfer_size;
	u32 ahbcfg;
	u32 ref_clk_per;
	u16 sof_cnt_wkup_alert;
	bool host_dma;
	bool dma_desc_enable;
	bool dma_desc_fs_enable;
	bool host_support_fs_ls_low_power;
	bool host_ls_low_power_phy_clk;
	bool oc_disable;
	u8 host_channels;
	u16 host_rx_fifo_size;
	u16 host_nperio_tx_fifo_size;
	u16 host_perio_tx_fifo_size;
	bool g_dma;
	bool g_dma_desc;
	u32 g_rx_fifo_size;
	u32 g_np_tx_fifo_size;
	u32 g_tx_fifo_size[16];
	bool change_speed_quirk;
};

struct dwc2_gregs_backup {
	u32 gotgctl;
	u32 gintmsk;
	u32 gahbcfg;
	u32 gusbcfg;
	u32 grxfsiz;
	u32 gnptxfsiz;
	u32 gi2cctl;
	u32 glpmcfg;
	u32 pcgcctl;
	u32 pcgcctl1;
	u32 gdfifocfg;
	u32 gpwrdn;
	bool valid;
};

struct dwc2_dregs_backup {
	u32 dcfg;
	u32 dctl;
	u32 daintmsk;
	u32 diepmsk;
	u32 doepmsk;
	u32 diepctl[16];
	u32 dieptsiz[16];
	u32 diepdma[16];
	u32 doepctl[16];
	u32 doeptsiz[16];
	u32 doepdma[16];
	u32 dtxfsiz[16];
	bool valid;
};

struct dwc2_hregs_backup {
	u32 hcfg;
	u32 haintmsk;
	u32 hcintmsk[16];
	u32 hprt0;
	u32 hfir;
	u32 hptxfsiz;
	bool valid;
};

union dwc2_hcd_internal_flags {
	u32 d32;
	struct {
		unsigned int port_connect_status_change: 1;
		unsigned int port_connect_status: 1;
		unsigned int port_reset_change: 1;
		unsigned int port_enable_change: 1;
		unsigned int port_suspend_change: 1;
		unsigned int port_over_current_change: 1;
		unsigned int port_l1_change: 1;
		unsigned int reserved: 25;
	} b;
};

struct dwc2_hsotg_plat;

struct dwc2_host_chan;

struct dwc2_dma_desc;

struct dwc2_hsotg_ep;

struct dwc2_hsotg {
	struct device *dev;
	void *regs;
	struct dwc2_hw_params hw_params;
	struct dwc2_core_params params;
	enum usb_otg_state op_state;
	enum usb_dr_mode dr_mode;
	struct usb_role_switch *role_sw;
	enum usb_dr_mode role_sw_default_mode;
	unsigned int hcd_enabled: 1;
	unsigned int gadget_enabled: 1;
	unsigned int ll_hw_enabled: 1;
	unsigned int hibernated: 1;
	unsigned int in_ppd: 1;
	bool bus_suspended;
	unsigned int reset_phy_on_wake: 1;
	unsigned int need_phy_for_wake: 1;
	unsigned int phy_off_for_suspend: 1;
	u16 frame_number;
	struct phy *phy;
	struct usb_phy *uphy;
	struct dwc2_hsotg_plat *plat;
	struct regulator_bulk_data supplies[2];
	struct regulator *vbus_supply;
	struct regulator *usb33d;
	spinlock_t lock;
	void *priv;
	int irq;
	struct clk *clk;
	struct clk *utmi_clk;
	struct reset_control *reset;
	struct reset_control *reset_ecc;
	unsigned int queuing_high_bandwidth: 1;
	unsigned int srp_success: 1;
	struct workqueue_struct *wq_otg;
	struct work_struct wf_otg;
	struct timer_list wkp_timer;
	enum dwc2_lx_state lx_state;
	struct dwc2_gregs_backup gr_backup;
	struct dwc2_dregs_backup dr_backup;
	struct dwc2_hregs_backup hr_backup;
	struct dentry *debug_root;
	struct debugfs_regset32 *regset;
	bool needs_byte_swap;
	union dwc2_hcd_internal_flags flags;
	struct list_head non_periodic_sched_inactive;
	struct list_head non_periodic_sched_waiting;
	struct list_head non_periodic_sched_active;
	struct list_head *non_periodic_qh_ptr;
	struct list_head periodic_sched_inactive;
	struct list_head periodic_sched_ready;
	struct list_head periodic_sched_assigned;
	struct list_head periodic_sched_queued;
	struct list_head split_order;
	u16 periodic_usecs;
	unsigned long hs_periodic_bitmap[13];
	u16 periodic_qh_count;
	bool new_connection;
	u16 last_frame_num;
	struct list_head free_hc_list;
	int periodic_channels;
	int non_periodic_channels;
	int available_host_channels;
	struct dwc2_host_chan *hc_ptr_array[16];
	u8 *status_buf;
	dma_addr_t status_buf_dma;
	struct delayed_work start_work;
	struct delayed_work reset_work;
	struct work_struct phy_reset_work;
	u8 otg_port;
	u32 *frame_list;
	dma_addr_t frame_list_dma;
	u32 frame_list_sz;
	struct kmem_cache *desc_gen_cache;
	struct kmem_cache *desc_hsisoc_cache;
	struct kmem_cache *unaligned_cache;
	struct usb_gadget_driver *driver;
	int fifo_mem;
	unsigned int dedicated_fifos: 1;
	unsigned char num_of_eps;
	u32 fifo_map;
	struct usb_request *ep0_reply;
	struct usb_request *ctrl_req;
	void *ep0_buff;
	void *ctrl_buff;
	enum dwc2_ep0_state ep0_state;
	unsigned int delayed_status: 1;
	u8 test_mode;
	dma_addr_t setup_desc_dma[2];
	struct dwc2_dma_desc *setup_desc[2];
	dma_addr_t ctrl_in_desc_dma;
	struct dwc2_dma_desc *ctrl_in_desc;
	dma_addr_t ctrl_out_desc_dma;
	struct dwc2_dma_desc *ctrl_out_desc;
	struct usb_gadget gadget;
	unsigned int enabled: 1;
	unsigned int connected: 1;
	unsigned int remote_wakeup_allowed: 1;
	struct dwc2_hsotg_ep *eps_in[16];
	struct dwc2_hsotg_ep *eps_out[16];
};

struct dwc2_dma_desc {
	u32 status;
	u32 buf;
};

struct dwc2_hsotg_req;

struct dwc2_hsotg_ep {
	struct usb_ep ep;
	struct list_head queue;
	struct dwc2_hsotg *parent;
	struct dwc2_hsotg_req *req;
	struct dentry *debugfs;
	unsigned long total_data;
	unsigned int size_loaded;
	unsigned int last_load;
	unsigned int fifo_load;
	unsigned short fifo_size;
	unsigned short fifo_index;
	unsigned char dir_in;
	unsigned char map_dir;
	unsigned char index;
	unsigned char mc;
	u16 interval;
	unsigned int halted: 1;
	unsigned int periodic: 1;
	unsigned int isochronous: 1;
	unsigned int send_zlp: 1;
	unsigned int wedged: 1;
	unsigned int target_frame;
	bool frame_overrun;
	dma_addr_t desc_list_dma;
	struct dwc2_dma_desc *desc_list;
	u8 desc_count;
	unsigned int next_desc;
	unsigned int compl_desc;
	char name[10];
};

struct dwc2_hsotg_req {
	struct usb_request req;
	struct list_head queue;
	void *saved_req_buf;
};

struct ehci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*port_power)(struct usb_hcd *, int, bool);
};

enum orion_ehci_phy_ver {
	EHCI_PHY_ORION = 0,
	EHCI_PHY_DD = 1,
	EHCI_PHY_KW = 2,
	EHCI_PHY_NA = 3,
};

enum ehci_hrtimer_event {
	EHCI_HRTIMER_POLL_ASS = 0,
	EHCI_HRTIMER_POLL_PSS = 1,
	EHCI_HRTIMER_POLL_DEAD = 2,
	EHCI_HRTIMER_UNLINK_INTR = 3,
	EHCI_HRTIMER_FREE_ITDS = 4,
	EHCI_HRTIMER_ACTIVE_UNLINK = 5,
	EHCI_HRTIMER_START_UNLINK_INTR = 6,
	EHCI_HRTIMER_ASYNC_UNLINKS = 7,
	EHCI_HRTIMER_IAA_WATCHDOG = 8,
	EHCI_HRTIMER_DISABLE_PERIODIC = 9,
	EHCI_HRTIMER_DISABLE_ASYNC = 10,
	EHCI_HRTIMER_IO_WATCHDOG = 11,
	EHCI_HRTIMER_NUM_EVENTS = 12,
};

enum ehci_rh_state {
	EHCI_RH_HALTED = 0,
	EHCI_RH_SUSPENDED = 1,
	EHCI_RH_RUNNING = 2,
	EHCI_RH_STOPPING = 3,
};

struct orion_ehci_hcd {
	struct clk *clk;
	struct phy *phy;
};

struct ehci_caps;

struct ehci_regs;

struct ehci_dbg_port;

struct ehci_qh;

union ehci_shadow;

struct ehci_itd;

struct ehci_sitd;

struct ehci_hcd {
	enum ehci_hrtimer_event next_hrtimer_event;
	unsigned int enabled_hrtimer_events;
	ktime_t hr_timeouts[12];
	struct hrtimer hrtimer;
	int PSS_poll_count;
	int ASS_poll_count;
	int died_poll_count;
	struct ehci_caps *caps;
	struct ehci_regs *regs;
	struct ehci_dbg_port *debug;
	__u32 hcs_params;
	spinlock_t lock;
	enum ehci_rh_state rh_state;
	bool scanning: 1;
	bool need_rescan: 1;
	bool intr_unlinking: 1;
	bool iaa_in_progress: 1;
	bool async_unlinking: 1;
	bool shutdown: 1;
	struct ehci_qh *qh_scan_next;
	struct ehci_qh *async;
	struct ehci_qh *dummy;
	struct list_head async_unlink;
	struct list_head async_idle;
	unsigned int async_unlink_cycle;
	unsigned int async_count;
	__le32 old_current;
	__le32 old_token;
	unsigned int periodic_size;
	__le32 *periodic;
	dma_addr_t periodic_dma;
	struct list_head intr_qh_list;
	unsigned int i_thresh;
	union ehci_shadow *pshadow;
	struct list_head intr_unlink_wait;
	struct list_head intr_unlink;
	unsigned int intr_unlink_wait_cycle;
	unsigned int intr_unlink_cycle;
	unsigned int now_frame;
	unsigned int last_iso_frame;
	unsigned int intr_count;
	unsigned int isoc_count;
	unsigned int periodic_count;
	unsigned int uframe_periodic_max;
	struct list_head cached_itd_list;
	struct ehci_itd *last_itd_to_free;
	struct list_head cached_sitd_list;
	struct ehci_sitd *last_sitd_to_free;
	unsigned long reset_done[15];
	unsigned long bus_suspended;
	unsigned long companion_ports;
	unsigned long owned_ports;
	unsigned long port_c_suspend;
	unsigned long suspended_ports;
	unsigned long resuming_ports;
	struct dma_pool *qh_pool;
	struct dma_pool *qtd_pool;
	struct dma_pool *itd_pool;
	struct dma_pool *sitd_pool;
	unsigned int random_frame;
	unsigned long next_statechange;
	ktime_t last_periodic_enable;
	u32 command;
	unsigned int no_selective_suspend: 1;
	unsigned int has_fsl_port_bug: 1;
	unsigned int has_fsl_hs_errata: 1;
	unsigned int has_fsl_susp_errata: 1;
	unsigned int has_ci_pec_bug: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_capbase: 1;
	unsigned int has_amcc_usb23: 1;
	unsigned int need_io_watchdog: 1;
	unsigned int amd_pll_fix: 1;
	unsigned int use_dummy_qh: 1;
	unsigned int has_synopsys_hc_bug: 1;
	unsigned int frame_index_bug: 1;
	unsigned int need_oc_pp_cycle: 1;
	unsigned int imx28_write_fix: 1;
	unsigned int spurious_oc: 1;
	unsigned int is_aspeed: 1;
	unsigned int zx_wakeup_clear_needed: 1;
	__le32 *ohci_hcctrl_reg;
	unsigned int has_hostpc: 1;
	unsigned int has_tdi_phy_lpm: 1;
	unsigned int has_ppcd: 1;
	u8 sbrn;
	u8 bandwidth[64];
	u8 tt_budget[64];
	struct list_head tt_list;
	unsigned long priv[0];
};

struct ehci_caps {
	u32 hc_capbase;
	u32 hcs_params;
	u32 hcc_params;
	u8 portroute[8];
};

struct ehci_regs {
	u32 command;
	u32 status;
	u32 intr_enable;
	u32 frame_index;
	u32 segment;
	u32 frame_list;
	u32 async_next;
	u32 reserved1[2];
	u32 txfill_tuning;
	u32 reserved2[6];
	u32 configured_flag;
	union {
		u32 port_status[15];
		struct {
			u32 reserved3[9];
			u32 usbmode;
		};
	};
	union {
		struct {
			u32 reserved4;
			u32 hostpc[15];
		};
		u32 brcm_insnreg[4];
	};
	u32 reserved5[2];
	u32 usbmode_ex;
};

struct ehci_dbg_port {
	u32 control;
	u32 pids;
	u32 data03;
	u32 data47;
	u32 address;
};

struct ehci_fstn;

union ehci_shadow {
	struct ehci_qh *qh;
	struct ehci_itd *itd;
	struct ehci_sitd *sitd;
	struct ehci_fstn *fstn;
	__le32 *hw_next;
	void *ptr;
};

struct ehci_per_sched {
	struct usb_device *udev;
	struct usb_host_endpoint *ep;
	struct list_head ps_list;
	u16 tt_usecs;
	u16 cs_mask;
	u16 period;
	u16 phase;
	u8 bw_phase;
	u8 phase_uf;
	u8 usecs;
	u8 c_usecs;
	u8 bw_uperiod;
	u8 bw_period;
};

struct ehci_qh_hw;

struct ehci_qtd;

struct ehci_qh {
	struct ehci_qh_hw *hw;
	dma_addr_t qh_dma;
	union ehci_shadow qh_next;
	struct list_head qtd_list;
	struct list_head intr_node;
	struct ehci_qtd *dummy;
	struct list_head unlink_node;
	struct ehci_per_sched ps;
	unsigned int unlink_cycle;
	u8 qh_state;
	u8 xacterrs;
	u8 unlink_reason;
	u8 gap_uf;
	unsigned int is_out: 1;
	unsigned int clearing_tt: 1;
	unsigned int dequeue_during_giveback: 1;
	unsigned int should_be_inactive: 1;
};

struct ehci_qh_hw {
	__le32 hw_next;
	__le32 hw_info1;
	__le32 hw_info2;
	__le32 hw_current;
	__le32 hw_qtd_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	long: 64;
	long: 64;
	long: 64;
};

struct ehci_iso_stream;

struct ehci_itd {
	__le32 hw_next;
	__le32 hw_transaction[8];
	__le32 hw_bufp[7];
	__le32 hw_bufp_hi[7];
	dma_addr_t itd_dma;
	union ehci_shadow itd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head itd_list;
	unsigned int frame;
	unsigned int pg;
	unsigned int index[8];
	long: 64;
};

struct ehci_iso_stream {
	struct ehci_qh_hw *hw;
	u8 bEndpointAddress;
	u8 highspeed;
	struct list_head td_list;
	struct list_head free_list;
	struct ehci_per_sched ps;
	unsigned int next_uframe;
	__le32 splits;
	u16 uperiod;
	u16 maxp;
	unsigned int bandwidth;
	__le32 buf0;
	__le32 buf1;
	__le32 buf2;
	__le32 address;
};

struct ehci_sitd {
	__le32 hw_next;
	__le32 hw_fullspeed_ep;
	__le32 hw_uframe;
	__le32 hw_results;
	__le32 hw_buf[2];
	__le32 hw_backpointer;
	__le32 hw_buf_hi[2];
	dma_addr_t sitd_dma;
	union ehci_shadow sitd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head sitd_list;
	unsigned int frame;
	unsigned int index;
};

struct ehci_fstn {
	__le32 hw_next;
	__le32 hw_prev;
	dma_addr_t fstn_dma;
	union ehci_shadow fstn_next;
	long: 64;
};

struct ehci_qtd {
	__le32 hw_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	dma_addr_t qtd_dma;
	struct list_head qtd_list;
	struct urb *urb;
	size_t length;
};

struct orion_ehci_data {
	enum orion_ehci_phy_ver phy_version;
};

struct mbus_dram_window {
	u8 cs_index;
	u8 mbus_attr;
	u64 base;
	u64 size;
};

struct mbus_dram_target_info {
	u8 mbus_dram_target_id;
	int num_cs;
	struct mbus_dram_window cs[4];
};

typedef void (*btf_trace_xhci_dbg_address)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_context_change)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_quirks)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_reset_ep)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_cancel_urb)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_init)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_ring_expansion)(void *, struct va_format *);

typedef void (*btf_trace_xhci_address_ctx)(void *, struct xhci_hcd *, struct xhci_container_ctx *, unsigned int);

typedef void (*btf_trace_xhci_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_command)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_queue_trb)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_gadget_ep_queue)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_free_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_alloc_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_addressable_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_stop_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_urb_enqueue)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_giveback)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_dequeue)(void *, struct urb *);

typedef void (*btf_trace_xhci_handle_cmd_stop_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_config_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_add_endpoint)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_alloc_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_free_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_disable_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_discover_or_reset_device)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_setup_device_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_addr_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_address_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_ring_alloc)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_free)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_expansion)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_enq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_deq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_handle_port_status)(void *, struct xhci_port *, u32);

typedef void (*btf_trace_xhci_get_port_status)(void *, struct xhci_port *, u32);

typedef void (*btf_trace_xhci_hub_status_data)(void *, struct xhci_port *, u32);

typedef void (*btf_trace_xhci_ring_ep_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_host_doorbell)(void *, u32, u32);

struct dbc_request;

typedef void (*btf_trace_xhci_dbc_alloc_request)(void *, struct dbc_request *);

struct xhci_dbc;

struct dbc_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	void (*complete)(struct xhci_dbc *, struct dbc_request *);
	struct list_head list_pool;
	int status;
	unsigned int actual;
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	dma_addr_t trb_dma;
	union xhci_trb *trb;
	unsigned int direction: 1;
};

enum dbc_state {
	DS_DISABLED = 0,
	DS_INITIALIZED = 1,
	DS_ENABLED = 2,
	DS_CONNECTED = 3,
	DS_CONFIGURED = 4,
	DS_STALLED = 5,
};

struct dbc_ep {
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	struct xhci_ring *ring;
	unsigned int direction: 1;
};

struct dbc_regs;

struct dbc_str_descs;

struct dbc_driver;

struct xhci_dbc {
	spinlock_t lock;
	struct device *dev;
	struct xhci_hcd *xhci;
	struct dbc_regs *regs;
	struct xhci_ring *ring_evt;
	struct xhci_ring *ring_in;
	struct xhci_ring *ring_out;
	struct xhci_erst erst;
	struct xhci_container_ctx *ctx;
	struct dbc_str_descs *string;
	dma_addr_t string_dma;
	size_t string_size;
	u16 idVendor;
	u16 idProduct;
	u16 bcdDevice;
	u8 bInterfaceProtocol;
	enum dbc_state state;
	struct delayed_work event_work;
	unsigned int resume_required: 1;
	struct dbc_ep eps[2];
	const struct dbc_driver *driver;
	void *priv;
};

struct dbc_regs {
	__le32 capability;
	__le32 doorbell;
	__le32 ersts;
	__le32 __reserved_0;
	__le64 erstba;
	__le64 erdp;
	__le32 control;
	__le32 status;
	__le32 portsc;
	__le32 __reserved_1;
	__le64 dccp;
	__le32 devinfo1;
	__le32 devinfo2;
};

struct dbc_str_descs {
	char string0[64];
	char manufacturer[64];
	char product[64];
	char serial[64];
};

struct dbc_driver {
	int (*configure)(struct xhci_dbc *);
	void (*disconnect)(struct xhci_dbc *);
};

typedef void (*btf_trace_xhci_dbc_free_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_queue_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_giveback_request)(void *, struct dbc_request *);

struct trace_event_raw_xhci_log_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctx {
	struct trace_entry ent;
	int ctx_64;
	unsigned int ctx_type;
	dma_addr_t ctx_dma;
	u8 *ctx_va;
	unsigned int ctx_ep_num;
	u32 __data_loc_ctx_data;
	char __data[0];
};

struct trace_event_raw_xhci_log_trb {
	struct trace_entry ent;
	u32 type;
	u32 field0;
	u32 field1;
	u32 field2;
	u32 field3;
	char __data[0];
};

struct trace_event_raw_xhci_log_free_virt_dev {
	struct trace_entry ent;
	void *vdev;
	unsigned long long out_ctx;
	unsigned long long in_ctx;
	u8 fake_port;
	u8 real_port;
	u16 current_mel;
	char __data[0];
};

struct trace_event_raw_xhci_log_virt_dev {
	struct trace_entry ent;
	void *vdev;
	unsigned long long out_ctx;
	unsigned long long in_ctx;
	int devnum;
	int state;
	int speed;
	u8 portnum;
	u8 level;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_urb {
	struct trace_entry ent;
	void *urb;
	unsigned int pipe;
	unsigned int stream;
	int status;
	unsigned int flags;
	int num_mapped_sgs;
	int num_sgs;
	int length;
	int actual;
	int epnum;
	int dir_in;
	int type;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_ep_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u64 deq;
	u32 tx_info;
	char __data[0];
};

struct trace_event_raw_xhci_log_slot_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u32 tt_info;
	u32 state;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctrl_ctx {
	struct trace_entry ent;
	u32 drop;
	u32 add;
	char __data[0];
};

struct trace_event_raw_xhci_log_ring {
	struct trace_entry ent;
	u32 type;
	void *ring;
	dma_addr_t enq;
	dma_addr_t deq;
	dma_addr_t enq_seg;
	dma_addr_t deq_seg;
	unsigned int num_segs;
	unsigned int stream_id;
	unsigned int cycle_state;
	unsigned int bounce_buf_len;
	char __data[0];
};

struct trace_event_raw_xhci_log_portsc {
	struct trace_entry ent;
	u32 busnum;
	u32 portnum;
	u32 portsc;
	char __data[0];
};

struct trace_event_raw_xhci_log_doorbell {
	struct trace_entry ent;
	u32 slot;
	u32 doorbell;
	char __data[0];
};

struct trace_event_raw_xhci_dbc_log_request {
	struct trace_entry ent;
	struct dbc_request *req;
	bool dir;
	unsigned int actual;
	unsigned int length;
	int status;
	char __data[0];
};

struct trace_event_data_offsets_xhci_log_msg {
	u32 msg;
};

struct trace_event_data_offsets_xhci_log_ctx {
	u32 ctx_data;
};

struct trace_event_data_offsets_xhci_log_trb {};

struct trace_event_data_offsets_xhci_log_free_virt_dev {};

struct trace_event_data_offsets_xhci_log_virt_dev {};

struct trace_event_data_offsets_xhci_log_urb {};

struct trace_event_data_offsets_xhci_log_ep_ctx {};

struct trace_event_data_offsets_xhci_log_slot_ctx {};

struct trace_event_data_offsets_xhci_log_ctrl_ctx {};

struct trace_event_data_offsets_xhci_log_ring {};

struct trace_event_data_offsets_xhci_log_portsc {};

struct trace_event_data_offsets_xhci_log_doorbell {};

struct trace_event_data_offsets_xhci_dbc_log_request {};

enum usb_role {
	USB_ROLE_NONE = 0,
	USB_ROLE_HOST = 1,
	USB_ROLE_DEVICE = 2,
};

typedef int (*usb_role_switch_set_t)(struct usb_role_switch *, enum usb_role);

typedef enum usb_role (*usb_role_switch_get_t)(struct usb_role_switch *);

struct usb_role_switch_desc {
	struct fwnode_handle *fwnode;
	struct device *usb2_port;
	struct device *usb3_port;
	struct device *udc;
	usb_role_switch_set_t set;
	usb_role_switch_get_t get;
	bool allow_userspace_control;
	void *driver_data;
	const char *name;
};

enum ci_role {
	CI_ROLE_HOST = 0,
	CI_ROLE_GADGET = 1,
	CI_ROLE_END = 2,
};

enum otg_fsm_timer {
	A_WAIT_VRISE = 0,
	A_WAIT_VFALL = 1,
	A_WAIT_BCON = 2,
	A_AIDL_BDIS = 3,
	B_ASE0_BRST = 4,
	A_BIDL_ADIS = 5,
	B_AIDL_BDIS = 6,
	B_SE0_SRP = 7,
	B_SRP_FAIL = 8,
	A_WAIT_ENUM = 9,
	B_DATA_PLS = 10,
	B_SSEND_SRP = 11,
	NUM_OTG_FSM_TIMERS = 12,
};

enum ci_revision {
	CI_REVISION_1X = 10,
	CI_REVISION_20 = 20,
	CI_REVISION_21 = 21,
	CI_REVISION_22 = 22,
	CI_REVISION_23 = 23,
	CI_REVISION_24 = 24,
	CI_REVISION_25 = 25,
	CI_REVISION_25_PLUS = 26,
	CI_REVISION_UNKNOWN = 99,
};

enum ci_hw_regs {
	CAP_CAPLENGTH = 0,
	CAP_HCCPARAMS = 1,
	CAP_DCCPARAMS = 2,
	CAP_TESTMODE = 3,
	CAP_LAST = 3,
	OP_USBCMD = 4,
	OP_USBSTS = 5,
	OP_USBINTR = 6,
	OP_FRINDEX = 7,
	OP_DEVICEADDR = 8,
	OP_ENDPTLISTADDR = 9,
	OP_TTCTRL = 10,
	OP_BURSTSIZE = 11,
	OP_ULPI_VIEWPORT = 12,
	OP_PORTSC = 13,
	OP_DEVLC = 14,
	OP_OTGSC = 15,
	OP_USBMODE = 16,
	OP_ENDPTSETUPSTAT = 17,
	OP_ENDPTPRIME = 18,
	OP_ENDPTFLUSH = 19,
	OP_ENDPTSTAT = 20,
	OP_ENDPTCOMPLETE = 21,
	OP_ENDPTCTRL = 22,
	OP_LAST = 38,
};

struct ci_hdrc;

struct ci_hdrc_cable {
	bool connected;
	bool changed;
	bool enabled;
	struct extcon_dev *edev;
	struct ci_hdrc *ci;
	struct notifier_block nb;
};

struct hw_bank {
	unsigned int lpm;
	resource_size_t phys;
	void *abs;
	void *cap;
	void *op;
	size_t size;
	void *regmap[39];
};

struct otg_fsm_ops;

struct otg_fsm {
	int id;
	int adp_change;
	int power_up;
	int a_srp_det;
	int a_vbus_vld;
	int b_conn;
	int a_bus_resume;
	int a_bus_suspend;
	int a_conn;
	int b_se0_srp;
	int b_ssend_srp;
	int b_sess_vld;
	int test_device;
	int a_bus_drop;
	int a_bus_req;
	int b_bus_req;
	int a_sess_vld;
	int b_bus_resume;
	int b_bus_suspend;
	int drv_vbus;
	int loc_conn;
	int loc_sof;
	int adp_prb;
	int adp_sns;
	int data_pulse;
	int a_set_b_hnp_en;
	int b_srp_done;
	int b_hnp_enable;
	int a_clr_err;
	int a_bus_drop_inf;
	int a_bus_req_inf;
	int a_clr_err_inf;
	int b_bus_req_inf;
	int a_suspend_req_inf;
	int a_wait_vrise_tmout;
	int a_wait_vfall_tmout;
	int a_wait_bcon_tmout;
	int a_aidl_bdis_tmout;
	int b_ase0_brst_tmout;
	int a_bidl_adis_tmout;
	struct otg_fsm_ops *ops;
	struct usb_otg *otg;
	int protocol;
	struct mutex lock;
	u8 *host_req_flag;
	struct delayed_work hnp_polling_work;
	bool hnp_work_inited;
	bool state_changed;
};

struct ci_hw_qh;

struct td_node;

struct ci_hw_ep {
	struct usb_ep ep;
	u8 dir;
	u8 num;
	u8 type;
	char name[16];
	struct {
		struct list_head queue;
		struct ci_hw_qh *ptr;
		dma_addr_t dma;
	} qh;
	int wedge;
	struct ci_hdrc *ci;
	spinlock_t *lock;
	struct dma_pool *td_pool;
	struct td_node *pending_td;
};

struct ulpi_ops {
	int (*read)(struct device *, u8);
	int (*write)(struct device *, u8, u8);
};

struct ci_role_driver;

struct ci_hdrc_platform_data;

struct ci_hdrc {
	struct device *dev;
	spinlock_t lock;
	struct hw_bank hw_bank;
	int irq;
	struct ci_role_driver *roles[2];
	enum ci_role role;
	bool is_otg;
	struct usb_otg otg;
	struct otg_fsm fsm;
	struct hrtimer otg_fsm_hrtimer;
	ktime_t hr_timeouts[12];
	unsigned int enabled_otg_timer_bits;
	enum otg_fsm_timer next_otg_timer;
	struct usb_role_switch *role_switch;
	struct work_struct work;
	struct workqueue_struct *wq;
	struct dma_pool *qh_pool;
	struct dma_pool *td_pool;
	struct usb_gadget gadget;
	struct usb_gadget_driver *driver;
	enum usb_device_state resume_state;
	unsigned int hw_ep_max;
	struct ci_hw_ep ci_hw_ep[32];
	u32 ep0_dir;
	struct ci_hw_ep *ep0out;
	struct ci_hw_ep *ep0in;
	struct usb_request *status;
	bool setaddr;
	u8 address;
	u8 remote_wakeup;
	u8 suspended;
	u8 test_mode;
	struct ci_hdrc_platform_data *platdata;
	int vbus_active;
	struct ulpi *ulpi;
	struct ulpi_ops ulpi_ops;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_hcd *hcd;
	bool id_event;
	bool b_sess_valid_event;
	bool imx28_write_fix;
	bool has_portsc_pec_bug;
	bool supports_runtime_pm;
	bool in_lpm;
	bool wakeup_int;
	enum ci_revision rev;
	struct mutex mutex;
};

struct ci_role_driver {
	int (*start)(struct ci_hdrc *);
	void (*stop)(struct ci_hdrc *);
	void (*suspend)(struct ci_hdrc *);
	void (*resume)(struct ci_hdrc *, bool);
	irqreturn_t (*irq)(struct ci_hdrc *);
	const char *name;
};

struct otg_fsm_ops {
	void (*chrg_vbus)(struct otg_fsm *, int);
	void (*drv_vbus)(struct otg_fsm *, int);
	void (*loc_conn)(struct otg_fsm *, int);
	void (*loc_sof)(struct otg_fsm *, int);
	void (*start_pulse)(struct otg_fsm *);
	void (*start_adp_prb)(struct otg_fsm *);
	void (*start_adp_sns)(struct otg_fsm *);
	void (*add_timer)(struct otg_fsm *, enum otg_fsm_timer);
	void (*del_timer)(struct otg_fsm *, enum otg_fsm_timer);
	int (*start_host)(struct otg_fsm *, int);
	int (*start_gadget)(struct otg_fsm *, int);
};

struct ci_hw_td {
	__le32 next;
	__le32 token;
	__le32 page[5];
};

struct ci_hw_qh {
	__le32 cap;
	__le32 curr;
	struct ci_hw_td td;
	__le32 RESERVED;
	struct usb_ctrlrequest setup;
};

struct td_node {
	struct list_head td;
	dma_addr_t dma;
	struct ci_hw_td *ptr;
	int td_remaining_size;
};

struct ci_hdrc_platform_data {
	const char *name;
	uintptr_t capoffset;
	unsigned int power_budget;
	struct phy *phy;
	struct usb_phy *usb_phy;
	enum usb_phy_interface phy_mode;
	unsigned long flags;
	enum usb_dr_mode dr_mode;
	int (*notify_event)(struct ci_hdrc *, unsigned int);
	struct regulator *reg_vbus;
	struct usb_otg_caps ci_otg_caps;
	bool tpl_support;
	u32 itc_setting;
	u32 ahb_burst_config;
	u32 tx_burst_size;
	u32 rx_burst_size;
	struct ci_hdrc_cable vbus_extcon;
	struct ci_hdrc_cable id_extcon;
	u32 phy_clkgate_delay_us;
	struct pinctrl *pctl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_host;
	struct pinctrl_state *pins_device;
	int (*hub_control)(struct ci_hdrc *, u16, u16, u16, char *, u16, bool *, unsigned long *);
	void (*enter_lpm)(struct ci_hdrc *, bool);
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

struct touchscreen_properties {
	unsigned int max_x;
	unsigned int max_y;
	bool invert_x;
	bool invert_y;
	bool swap_x_y;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct pm8941_data {
	unsigned int pull_up_bit;
	unsigned int status_bit;
	bool supports_ps_hold_poff_config;
	bool supports_debounce_config;
	bool has_pon_pbs;
	const char *name;
	const char *phys;
};

struct pm8941_pwrkey {
	struct device *dev;
	int irq;
	u32 baseaddr;
	u32 pon_pbs_baseaddr;
	struct regmap *regmap;
	struct input_dev *input;
	unsigned int revision;
	unsigned int subtype;
	struct notifier_block reboot_notifier;
	u32 code;
	u32 sw_debounce_time_us;
	ktime_t sw_debounce_end_time;
	bool last_status;
	const struct pm8941_data *data;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct pasemi_smbus {
	struct device *dev;
	struct i2c_adapter adapter;
	void *ioaddr;
	unsigned int clk_div;
	int hw_rev;
	int use_irq;
	struct completion irq_completion;
};

struct pasemi_platform_i2c_data {
	struct pasemi_smbus smbus;
	struct clk *clk_ref;
};

struct mode_info {
	const char *mode;
	u32 magic;
	struct list_head list;
};

struct reboot_mode_driver {
	struct device *dev;
	struct list_head head;
	int (*write)(struct reboot_mode_driver *, unsigned int);
	struct notifier_block reboot_notifier;
};

struct sr_thermal;

struct sr_tmon {
	unsigned int crit_temp;
	unsigned int tmon_id;
	struct sr_thermal *priv;
};

struct sr_thermal {
	void *regs;
	unsigned int max_crit_temp;
	struct sr_tmon tmon[6];
};

struct watchdog_info {
	__u32 options;
	__u32 firmware_version;
	__u8 identity[32];
};

struct watchdog_device;

struct watchdog_ops {
	struct module *owner;
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *, unsigned long, void *);
	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
};

struct watchdog_governor;

struct watchdog_core_data;

struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	struct notifier_block pm_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	unsigned long status;
	struct list_head deferred;
};

struct watchdog_governor {
	const char name[20];
	void (*pretimeout)(struct watchdog_device *);
};

struct imx2_wdt_data {
	bool wdw_supported;
};

struct imx2_wdt_device {
	struct clk *clk;
	struct regmap *regmap;
	struct watchdog_device wdog;
	const struct imx2_wdt_data *data;
	bool ext_reset;
	bool clk_is_on;
	bool no_ping;
	bool sleep_wait;
};

struct dev_pm_opp_supply {
	unsigned long u_volt;
	unsigned long u_volt_min;
	unsigned long u_volt_max;
	unsigned long u_amp;
	unsigned long u_watt;
};

struct ti_opp_supply_optimum_voltage_table;

struct ti_opp_supply_data {
	struct ti_opp_supply_optimum_voltage_table *vdd_table;
	u32 num_vdd_table;
	u32 vdd_absolute_max_voltage_uv;
	struct dev_pm_opp_supply old_supplies[2];
	struct dev_pm_opp_supply new_supplies[2];
};

struct ti_opp_supply_optimum_voltage_table {
	unsigned int reference_uv;
	unsigned int optimized_uv;
};

struct ti_opp_supply_of_data {
	const u8 flags;
	const u32 efuse_voltage_mask;
	const bool efuse_voltage_uv;
};

typedef int (*config_regulators_t)(struct device *, struct dev_pm_opp *, struct dev_pm_opp *, struct regulator **, unsigned int);

typedef int (*config_clks_t)(struct device *, struct opp_table *, struct dev_pm_opp *, void *, bool);

struct dev_pm_opp_config {
	const char * const *clk_names;
	config_clks_t config_clks;
	const char *prop_name;
	config_regulators_t config_regulators;
	const unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char * const *regulator_names;
	const char * const *genpd_names;
	struct device ***virt_devs;
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuidle_driver_kobj {
	struct cpuidle_driver *drv;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_driver_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_driver *, char *);
	ssize_t (*store)(struct cpuidle_driver *, const char *, size_t);
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct mmc_pwrseq_ops {
	void (*pre_power_on)(struct mmc_host *);
	void (*post_power_on)(struct mmc_host *);
	void (*power_off)(struct mmc_host *);
	void (*reset)(struct mmc_host *);
};

struct mmc_pwrseq {
	const struct mmc_pwrseq_ops *ops;
	struct device *dev;
	struct list_head pwrseq_node;
	struct module *owner;
};

struct gpio_descs;

struct mmc_pwrseq_simple {
	struct mmc_pwrseq pwrseq;
	bool clk_enabled;
	u32 post_power_on_delay_ms;
	u32 power_off_delay_us;
	struct clk *ext_clk;
	struct gpio_descs *reset_gpios;
};

struct gpio_array;

struct gpio_descs {
	struct gpio_array *info;
	unsigned int ndescs;
	struct gpio_desc *desc[0];
};

struct dw_mci;

struct dw_mci_slot;

struct dw_mci_drv_data {
	unsigned long *caps;
	u32 num_caps;
	u32 common_caps;
	int (*init)(struct dw_mci *);
	void (*set_ios)(struct dw_mci *, struct mmc_ios *);
	int (*parse_dt)(struct dw_mci *);
	int (*execute_tuning)(struct dw_mci_slot *, u32);
	int (*prepare_hs400_tuning)(struct dw_mci *, struct mmc_ios *);
	int (*switch_voltage)(struct mmc_host *, struct mmc_ios *);
	void (*set_data_timeout)(struct dw_mci *, unsigned int);
	u32 (*get_drto_clks)(struct dw_mci *);
};

enum dw_mci_state {
	STATE_IDLE = 0,
	STATE_SENDING_CMD = 1,
	STATE_SENDING_DATA = 2,
	STATE_DATA_BUSY = 3,
	STATE_SENDING_STOP = 4,
	STATE_DATA_ERROR = 5,
	STATE_SENDING_CMD11 = 6,
	STATE_WAITING_CMD11_DONE = 7,
};

struct dw_mci_dma_ops;

struct dw_mci_dma_slave;

struct dw_mci_board;

struct dw_mci {
	spinlock_t lock;
	spinlock_t irq_lock;
	void *regs;
	void *fifo_reg;
	u32 data_addr_override;
	bool wm_aligned;
	struct scatterlist *sg;
	struct sg_mapping_iter sg_miter;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_command stop_abort;
	unsigned int prev_blksz;
	unsigned char timing;
	int use_dma;
	int using_dma;
	int dma_64bit_address;
	dma_addr_t sg_dma;
	void *sg_cpu;
	const struct dw_mci_dma_ops *dma_ops;
	unsigned int ring_size;
	struct dw_mci_dma_slave *dms;
	resource_size_t phy_regs;
	u32 cmd_status;
	u32 data_status;
	u32 stop_cmdr;
	u32 dir_status;
	struct tasklet_struct tasklet;
	unsigned long pending_events;
	unsigned long completed_events;
	enum dw_mci_state state;
	struct list_head queue;
	u32 bus_hz;
	u32 current_speed;
	u32 minimum_speed;
	u32 fifoth_val;
	u16 verid;
	struct device *dev;
	struct dw_mci_board *pdata;
	const struct dw_mci_drv_data *drv_data;
	void *priv;
	struct clk *biu_clk;
	struct clk *ciu_clk;
	struct dw_mci_slot *slot;
	int fifo_depth;
	int data_shift;
	u8 part_buf_start;
	u8 part_buf_count;
	union {
		u16 part_buf16;
		u32 part_buf32;
		u64 part_buf;
	};
	void (*push_data)(struct dw_mci *, void *, int);
	void (*pull_data)(struct dw_mci *, void *, int);
	u32 quirks;
	bool vqmmc_enabled;
	unsigned long irq_flags;
	int irq;
	int sdio_id0;
	struct timer_list cmd11_timer;
	struct timer_list cto_timer;
	struct timer_list dto_timer;
};

struct dw_mci_dma_ops {
	int (*init)(struct dw_mci *);
	int (*start)(struct dw_mci *, unsigned int);
	void (*complete)(void *);
	void (*stop)(struct dw_mci *);
	void (*cleanup)(struct dw_mci *);
	void (*exit)(struct dw_mci *);
};

struct dw_mci_dma_slave {
	struct dma_chan *ch;
	enum dma_transfer_direction direction;
};

struct dma_pdata;

struct dw_mci_board {
	unsigned int bus_hz;
	u32 caps;
	u32 caps2;
	u32 pm_caps;
	unsigned int fifo_depth;
	u32 detect_delay_ms;
	struct reset_control *rstc;
	struct dw_mci_dma_ops *dma_ops;
	struct dma_pdata *data;
};

struct dw_mci_slot {
	struct mmc_host *mmc;
	struct dw_mci *host;
	u32 ctype;
	struct mmc_request *mrq;
	struct list_head queue_node;
	unsigned int clock;
	unsigned int __clk_old;
	unsigned long flags;
	int id;
	int sdio_id;
};

struct range_t {
	int start;
	int end;
};

struct dw_mci_rockchip_priv_data {
	struct clk *drv_clk;
	struct clk *sample_clk;
	int default_sample_phase;
	int num_phases;
};

struct led_lookup_data {
	struct list_head list;
	const char *provider;
	const char *dev_id;
	const char *con_id;
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

typedef void (*btf_trace_scmi_fc_call)(void *, u8, u8, u32, u32, u32);

typedef void (*btf_trace_scmi_xfer_begin)(void *, int, u8, u8, u16, bool);

typedef void (*btf_trace_scmi_xfer_response_wait)(void *, int, u8, u8, u16, u32, bool);

typedef void (*btf_trace_scmi_xfer_end)(void *, int, u8, u8, u16, int);

typedef void (*btf_trace_scmi_rx_done)(void *, int, u8, u8, u16, u8);

typedef void (*btf_trace_scmi_msg_dump)(void *, int, u8, u8, u8, unsigned char *, u16, int, void *, size_t);

struct scmi_xfer;

struct scmi_xfer_ops {
	int (*version_get)(const struct scmi_protocol_handle *, u32 *);
	int (*xfer_get_init)(const struct scmi_protocol_handle *, u8, size_t, size_t, struct scmi_xfer **);
	void (*reset_rx_to_maxsz)(const struct scmi_protocol_handle *, struct scmi_xfer *);
	int (*do_xfer)(const struct scmi_protocol_handle *, struct scmi_xfer *);
	int (*do_xfer_with_response)(const struct scmi_protocol_handle *, struct scmi_xfer *);
	void (*xfer_put)(const struct scmi_protocol_handle *, struct scmi_xfer *);
};

struct scmi_iterator_ops;

struct scmi_fc_db_info;

struct scmi_proto_helpers_ops {
	int (*extended_name_get)(const struct scmi_protocol_handle *, u8, u32, char *, size_t);
	void * (*iter_response_init)(const struct scmi_protocol_handle *, struct scmi_iterator_ops *, unsigned int, u8, size_t, void *);
	int (*iter_response_run)(void *);
	void (*fastchannel_init)(const struct scmi_protocol_handle *, u8, u32, u32, u32, void **, struct scmi_fc_db_info **);
	void (*fastchannel_db_ring)(struct scmi_fc_db_info *);
};

struct scmi_iterator_state;

struct scmi_iterator_ops {
	void (*prepare_message)(void *, unsigned int, const void *);
	int (*update_state)(struct scmi_iterator_state *, const void *, void *);
	int (*process_response)(const struct scmi_protocol_handle *, const void *, struct scmi_iterator_state *, void *);
};

struct scmi_iterator_state {
	unsigned int desc_index;
	unsigned int num_returned;
	unsigned int num_remaining;
	unsigned int max_resources;
	unsigned int loop_idx;
	size_t rx_len;
	void *priv;
};

struct scmi_fc_db_info {
	int width;
	u64 set;
	u64 mask;
	void *addr;
};

struct scmi_msg_hdr {
	u8 id;
	u8 protocol_id;
	u8 type;
	u16 seq;
	u32 status;
	bool poll_completion;
};

struct scmi_msg {
	void *buf;
	size_t len;
};

struct scmi_xfer {
	int transfer_id;
	struct scmi_msg_hdr hdr;
	struct scmi_msg tx;
	struct scmi_msg rx;
	struct completion done;
	struct completion *async_done;
	bool pending;
	struct hlist_node node;
	refcount_t users;
	atomic_t busy;
	int state;
	int flags;
	spinlock_t lock;
	void *priv;
};

enum scmi_error_codes {
	SCMI_SUCCESS = 0,
	SCMI_ERR_SUPPORT = -1,
	SCMI_ERR_PARAMS = -2,
	SCMI_ERR_ACCESS = -3,
	SCMI_ERR_ENTRY = -4,
	SCMI_ERR_RANGE = -5,
	SCMI_ERR_BUSY = -6,
	SCMI_ERR_COMMS = -7,
	SCMI_ERR_GENERIC = -8,
	SCMI_ERR_HARDWARE = -9,
	SCMI_ERR_PROTOCOL = -10,
};

enum scmi_common_cmd {
	PROTOCOL_VERSION = 0,
	PROTOCOL_ATTRIBUTES = 1,
	PROTOCOL_MESSAGE_ATTRIBUTES = 2,
};

struct scmi_xfers_info {
	unsigned long *xfer_alloc_table;
	spinlock_t xfer_lock;
	int max_msg;
	struct hlist_head free_xfers;
	struct hlist_head pending_xfers[512];
};

struct scmi_desc;

struct scmi_debug_info;

struct scmi_info {
	int id;
	struct device *dev;
	const struct scmi_desc *desc;
	struct scmi_revision_info version;
	struct scmi_handle handle;
	struct scmi_xfers_info tx_minfo;
	struct scmi_xfers_info rx_minfo;
	struct idr tx_idr;
	struct idr rx_idr;
	struct idr protocols;
	struct mutex protocols_mtx;
	u8 *protocols_imp;
	struct idr active_protocols;
	unsigned int atomic_threshold;
	void *notify_priv;
	struct list_head node;
	int users;
	struct notifier_block bus_nb;
	struct notifier_block dev_req_nb;
	struct mutex devreq_mtx;
	struct scmi_debug_info *dbg;
	void *raw;
};

struct scmi_transport_ops;

struct scmi_desc {
	int (*transport_init)();
	void (*transport_exit)();
	const struct scmi_transport_ops *ops;
	int max_rx_timeout_ms;
	int max_msg;
	int max_msg_size;
	const bool force_polling;
	const bool sync_cmds_completed_on_ret;
	const bool atomic_enabled;
};

struct scmi_chan_info;

struct scmi_transport_ops {
	int (*link_supplier)(struct device *);
	bool (*chan_available)(struct device_node *, int);
	int (*chan_setup)(struct scmi_chan_info *, struct device *, bool);
	int (*chan_free)(int, void *, void *);
	unsigned int (*get_max_msg)(struct scmi_chan_info *);
	int (*send_message)(struct scmi_chan_info *, struct scmi_xfer *);
	void (*mark_txdone)(struct scmi_chan_info *, int, struct scmi_xfer *);
	void (*fetch_response)(struct scmi_chan_info *, struct scmi_xfer *);
	void (*fetch_notification)(struct scmi_chan_info *, size_t, struct scmi_xfer *);
	void (*clear_channel)(struct scmi_chan_info *);
	bool (*poll_done)(struct scmi_chan_info *, struct scmi_xfer *);
};

struct scmi_chan_info {
	int id;
	struct device *dev;
	unsigned int rx_timeout_ms;
	struct scmi_handle *handle;
	bool no_completion_irq;
	void *transport_info;
};

struct scmi_debug_info {
	struct dentry *top_dentry;
	const char *name;
	const char *type;
	bool is_atomic;
};

struct scmi_protocol;

struct scmi_protocol_instance {
	const struct scmi_handle *handle;
	const struct scmi_protocol *proto;
	void *gid;
	refcount_t users;
	void *priv;
	struct scmi_protocol_handle ph;
};

typedef int (*scmi_prot_init_ph_fn_t)(const struct scmi_protocol_handle *);

struct scmi_protocol_events;

struct scmi_protocol {
	const u8 id;
	struct module *owner;
	const scmi_prot_init_ph_fn_t instance_init;
	const scmi_prot_init_ph_fn_t instance_deinit;
	const void *ops;
	const struct scmi_protocol_events *events;
};

struct scmi_event_ops;

struct scmi_event;

struct scmi_protocol_events {
	size_t queue_sz;
	const struct scmi_event_ops *ops;
	const struct scmi_event *evts;
	unsigned int num_events;
	unsigned int num_sources;
};

struct scmi_event_ops {
	int (*get_num_sources)(const struct scmi_protocol_handle *);
	int (*set_notify_enabled)(const struct scmi_protocol_handle *, u8, u32, bool);
	void * (*fill_custom_report)(const struct scmi_protocol_handle *, u8, ktime_t, const void *, size_t, void *, u32 *);
};

struct scmi_event {
	u8 id;
	size_t max_payld_sz;
	size_t max_report_sz;
};

struct trace_event_raw_scmi_fc_call {
	struct trace_entry ent;
	u8 protocol_id;
	u8 msg_id;
	u32 res_id;
	u32 val1;
	u32 val2;
	char __data[0];
};

struct trace_event_raw_scmi_xfer_begin {
	struct trace_entry ent;
	int transfer_id;
	u8 msg_id;
	u8 protocol_id;
	u16 seq;
	bool poll;
	char __data[0];
};

struct trace_event_raw_scmi_xfer_response_wait {
	struct trace_entry ent;
	int transfer_id;
	u8 msg_id;
	u8 protocol_id;
	u16 seq;
	u32 timeout;
	bool poll;
	char __data[0];
};

struct trace_event_raw_scmi_xfer_end {
	struct trace_entry ent;
	int transfer_id;
	u8 msg_id;
	u8 protocol_id;
	u16 seq;
	int status;
	char __data[0];
};

struct trace_event_raw_scmi_rx_done {
	struct trace_entry ent;
	int transfer_id;
	u8 msg_id;
	u8 protocol_id;
	u16 seq;
	u8 msg_type;
	char __data[0];
};

struct trace_event_raw_scmi_msg_dump {
	struct trace_entry ent;
	int id;
	u8 channel_id;
	u8 protocol_id;
	u8 msg_id;
	char tag[5];
	u16 seq;
	int status;
	size_t len;
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_data_offsets_scmi_msg_dump {
	u32 cmd;
};

struct scmi_protocol_devres {
	const struct scmi_handle *handle;
	u8 protocol_id;
};

struct trace_event_data_offsets_scmi_fc_call {};

struct trace_event_data_offsets_scmi_xfer_begin {};

struct trace_event_data_offsets_scmi_xfer_response_wait {};

struct trace_event_data_offsets_scmi_xfer_end {};

struct trace_event_data_offsets_scmi_rx_done {};

struct scmi_msg_resp_domain_name_get {
	__le32 flags;
	u8 name[64];
};

struct scmi_iterator {
	void *msg;
	void *resp;
	struct scmi_xfer *t;
	const struct scmi_protocol_handle *ph;
	struct scmi_iterator_ops *ops;
	struct scmi_iterator_state state;
	void *priv;
};

struct scmi_msg_resp_desc_fc {
	__le32 attr;
	__le32 rate_limit;
	__le32 chan_addr_low;
	__le32 chan_addr_high;
	__le32 chan_size;
	__le32 db_addr_low;
	__le32 db_addr_high;
	__le32 db_set_lmask;
	__le32 db_set_hmask;
	__le32 db_preserve_lmask;
	__le32 db_preserve_hmask;
};

struct scmi_msg_get_fc_info {
	__le32 domain;
	__le32 message_id;
};

struct scmi_msg_payld {
	__le32 msg_header;
	__le32 msg_payload[0];
};

struct tee_context;

struct scmi_optee_agent {
	struct device *dev;
	struct tee_context *tee_ctx;
	u32 caps;
	struct mutex mu;
	struct list_head channel_list;
};

struct tee_device;

struct tee_context {
	struct tee_device *teedev;
	void *data;
	struct kref refcount;
	bool releasing;
	bool supp_nowait;
	bool cap_memref_null;
};

struct tee_client_device_id;

struct tee_client_driver {
	const struct tee_client_device_id *id_table;
	struct device_driver driver;
};

struct tee_client_device_id {
	uuid_t uuid;
};

enum scmi_optee_pta_cmd {
	PTA_SCMI_CMD_CAPABILITIES = 0,
	PTA_SCMI_CMD_PROCESS_SMT_CHANNEL = 1,
	PTA_SCMI_CMD_PROCESS_SMT_CHANNEL_MESSAGE = 2,
	PTA_SCMI_CMD_GET_CHANNEL = 3,
	PTA_SCMI_CMD_PROCESS_MSG_CHANNEL = 4,
};

struct tee_client_device {
	struct tee_client_device_id id;
	struct device dev;
};

struct tee_ioctl_param {
	__u64 attr;
	__u64 a;
	__u64 b;
	__u64 c;
};

struct tee_ioctl_open_session_arg {
	__u8 uuid[16];
	__u8 clnt_uuid[16];
	__u32 clnt_login;
	__u32 cancel_id;
	__u32 session;
	__u32 ret;
	__u32 ret_origin;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_ioctl_invoke_arg {
	__u32 func;
	__u32 session;
	__u32 cancel_id;
	__u32 ret;
	__u32 ret_origin;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_shm;

struct tee_param_memref {
	size_t shm_offs;
	size_t size;
	struct tee_shm *shm;
};

struct tee_param_value {
	u64 a;
	u64 b;
	u64 c;
};

struct tee_param {
	u64 attr;
	union {
		struct tee_param_memref memref;
		struct tee_param_value value;
	} u;
};

struct tee_shm {
	struct tee_context *ctx;
	phys_addr_t paddr;
	void *kaddr;
	size_t size;
	unsigned int offset;
	struct page **pages;
	size_t num_pages;
	refcount_t refcount;
	u32 flags;
	int id;
	u64 sec_world_id;
};

struct tee_ioctl_version_data {
	__u32 impl_id;
	__u32 impl_caps;
	__u32 gen_caps;
};

struct scmi_shared_mem;

struct scmi_optee_channel {
	u32 channel_id;
	u32 tee_session;
	u32 caps;
	u32 rx_len;
	struct mutex mu;
	struct scmi_chan_info *cinfo;
	union {
		struct scmi_shared_mem *shmem;
		struct scmi_msg_payld *msg;
	} req;
	struct tee_shm *tee_shm;
	struct list_head link;
};

enum {
	RCD = 0,
	RCH_DP = 1,
	DEVICE = 2,
	LD = 3,
	FMLD = 4,
	RP = 5,
	DSP = 6,
	USP = 7,
};

struct cxl_ras_capability_regs {
	u32 uncor_status;
	u32 uncor_mask;
	u32 uncor_severity;
	u32 cor_status;
	u32 cor_mask;
	u32 cap_control;
	u32 header_log[16];
};

struct cper_sec_prot_err {
	u64 valid_bits;
	u8 agent_type;
	u8 reserved[7];
	union {
		u64 rcrb_base_addr;
		struct {
			u8 function;
			u8 device;
			u8 bus;
			u16 segment;
			u8 reserved_1[3];
		} __attribute__((packed));
	} agent_addr;
	struct {
		u16 vendor_id;
		u16 device_id;
		u16 subsystem_vendor_id;
		u16 subsystem_id;
		u8 class_code[2];
		u16 slot;
		u8 reserved_1[4];
	} device_id;
	struct {
		u32 lower_dw;
		u32 upper_dw;
	} dev_serial_num;
	u8 capability[60];
	u16 dvsec_len;
	u16 err_len;
	u8 reserved_2[4];
} __attribute__((packed));

enum efi_rts_ids {
	EFI_NONE = 0,
	EFI_GET_TIME = 1,
	EFI_SET_TIME = 2,
	EFI_GET_WAKEUP_TIME = 3,
	EFI_SET_WAKEUP_TIME = 4,
	EFI_GET_VARIABLE = 5,
	EFI_GET_NEXT_VARIABLE = 6,
	EFI_SET_VARIABLE = 7,
	EFI_QUERY_VARIABLE_INFO = 8,
	EFI_GET_NEXT_HIGH_MONO_COUNT = 9,
	EFI_RESET_SYSTEM = 10,
	EFI_UPDATE_CAPSULE = 11,
	EFI_QUERY_CAPSULE_CAPS = 12,
	EFI_ACPI_PRM_HANDLER = 13,
};

union efi_rts_args;

struct efi_runtime_work {
	union efi_rts_args *args;
	efi_status_t status;
	struct work_struct work;
	enum efi_rts_ids efi_rts_id;
	struct completion efi_rts_comp;
	const void *caller;
};

union efi_rts_args {
	struct {
		efi_time_t *time;
		efi_time_cap_t *capabilities;
	} GET_TIME;
	struct {
		efi_time_t *time;
	} SET_TIME;
	struct {
		efi_bool_t *enabled;
		efi_bool_t *pending;
		efi_time_t *time;
	} GET_WAKEUP_TIME;
	struct {
		efi_bool_t enable;
		efi_time_t *time;
	} SET_WAKEUP_TIME;
	struct {
		efi_char16_t *name;
		efi_guid_t *vendor;
		u32 *attr;
		unsigned long *data_size;
		void *data;
	} GET_VARIABLE;
	struct {
		unsigned long *name_size;
		efi_char16_t *name;
		efi_guid_t *vendor;
	} GET_NEXT_VARIABLE;
	struct {
		efi_char16_t *name;
		efi_guid_t *vendor;
		u32 attr;
		unsigned long data_size;
		void *data;
	} SET_VARIABLE;
	struct {
		u32 attr;
		u64 *storage_space;
		u64 *remaining_space;
		u64 *max_variable_size;
	} QUERY_VARIABLE_INFO;
	struct {
		u32 *high_count;
	} GET_NEXT_HIGH_MONO_COUNT;
	struct {
		efi_capsule_header_t **capsules;
		unsigned long count;
		unsigned long sg_list;
	} UPDATE_CAPSULE;
	struct {
		efi_capsule_header_t **capsules;
		unsigned long count;
		u64 *max_size;
		int *reset_type;
	} QUERY_CAPSULE_CAPS;
	struct {
		efi_status_t (*acpi_prm_handler)(u64, void *);
		u64 param_buffer_addr;
		void *context;
	} ACPI_PRM_HANDLER;
};

struct imx_sc_ipc;

struct imx_sc_chan {
	struct imx_sc_ipc *sc_ipc;
	struct mbox_client cl;
	struct mbox_chan *ch;
	int idx;
	struct completion tx_done;
};

struct imx_sc_ipc {
	struct imx_sc_chan chans[8];
	struct device *dev;
	struct mutex lock;
	struct completion done;
	bool fast_ipc;
	u32 *msg;
	u8 rx_size;
	u8 count;
};

enum imx_sc_rpc_svc {
	IMX_SC_RPC_SVC_UNKNOWN = 0,
	IMX_SC_RPC_SVC_RETURN = 1,
	IMX_SC_RPC_SVC_PM = 2,
	IMX_SC_RPC_SVC_RM = 3,
	IMX_SC_RPC_SVC_TIMER = 5,
	IMX_SC_RPC_SVC_PAD = 6,
	IMX_SC_RPC_SVC_MISC = 7,
	IMX_SC_RPC_SVC_IRQ = 8,
};

enum imx_misc_func {
	IMX_SC_MISC_FUNC_UNKNOWN = 0,
	IMX_SC_MISC_FUNC_SET_CONTROL = 1,
	IMX_SC_MISC_FUNC_GET_CONTROL = 2,
	IMX_SC_MISC_FUNC_SET_MAX_DMA_GROUP = 4,
	IMX_SC_MISC_FUNC_SET_DMA_GROUP = 5,
	IMX_SC_MISC_FUNC_SECO_IMAGE_LOAD = 8,
	IMX_SC_MISC_FUNC_SECO_AUTHENTICATE = 9,
	IMX_SC_MISC_FUNC_DEBUG_OUT = 10,
	IMX_SC_MISC_FUNC_WAVEFORM_CAPTURE = 6,
	IMX_SC_MISC_FUNC_BUILD_INFO = 15,
	IMX_SC_MISC_FUNC_UNIQUE_ID = 19,
	IMX_SC_MISC_FUNC_SET_ARI = 3,
	IMX_SC_MISC_FUNC_BOOT_STATUS = 7,
	IMX_SC_MISC_FUNC_BOOT_DONE = 14,
	IMX_SC_MISC_FUNC_OTP_FUSE_READ = 11,
	IMX_SC_MISC_FUNC_OTP_FUSE_WRITE = 17,
	IMX_SC_MISC_FUNC_SET_TEMP = 12,
	IMX_SC_MISC_FUNC_GET_TEMP = 13,
	IMX_SC_MISC_FUNC_GET_BOOT_DEV = 16,
	IMX_SC_MISC_FUNC_GET_BUTTON_STATUS = 18,
};

enum imx_sc_error_codes {
	IMX_SC_ERR_NONE = 0,
	IMX_SC_ERR_VERSION = 1,
	IMX_SC_ERR_CONFIG = 2,
	IMX_SC_ERR_PARM = 3,
	IMX_SC_ERR_NOACCESS = 4,
	IMX_SC_ERR_LOCKED = 5,
	IMX_SC_ERR_UNAVAILABLE = 6,
	IMX_SC_ERR_NOTFOUND = 7,
	IMX_SC_ERR_NOPOWER = 8,
	IMX_SC_ERR_IPC = 9,
	IMX_SC_ERR_BUSY = 10,
	IMX_SC_ERR_FAIL = 11,
	IMX_SC_ERR_LAST = 12,
};

struct imx_sc_rpc_msg {
	uint8_t ver;
	uint8_t size;
	uint8_t svc;
	uint8_t func;
};

struct tegra186_timer_soc {
	unsigned int num_timers;
	unsigned int num_wdts;
};

struct tegra186_tmr;

struct tegra186_wdt {
	struct watchdog_device base;
	void *regs;
	unsigned int index;
	bool locked;
	struct tegra186_tmr *tmr;
};

struct tegra186_timer;

struct tegra186_tmr {
	struct tegra186_timer *parent;
	void *regs;
	unsigned int index;
	unsigned int hwirq;
};

struct tegra186_timer {
	const struct tegra186_timer_soc *soc;
	struct device *dev;
	void *regs;
	struct tegra186_wdt *wdt;
	struct clocksource usec;
	struct clocksource tsc;
	struct clocksource osc;
};

struct memblock_type {
	unsigned long cnt;
	unsigned long max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

enum rproc_dump_mechanism {
	RPROC_COREDUMP_DISABLED = 0,
	RPROC_COREDUMP_ENABLED = 1,
	RPROC_COREDUMP_INLINE = 2,
};

enum rproc_crash_type {
	RPROC_MMUFAULT = 0,
	RPROC_WATCHDOG = 1,
	RPROC_FATAL_ERROR = 2,
};

enum fw_resource_type {
	RSC_CARVEOUT = 0,
	RSC_DEVMEM = 1,
	RSC_TRACE = 2,
	RSC_VDEV = 3,
	RSC_LAST = 4,
	RSC_VENDOR_START = 128,
	RSC_VENDOR_END = 512,
};

enum rproc_state {
	RPROC_OFFLINE = 0,
	RPROC_SUSPENDED = 1,
	RPROC_RUNNING = 2,
	RPROC_CRASHED = 3,
	RPROC_DELETED = 4,
	RPROC_ATTACHED = 5,
	RPROC_DETACHED = 6,
	RPROC_LAST = 7,
};

struct rproc;

struct rproc_mem_entry {
	void *va;
	bool is_iomem;
	dma_addr_t dma;
	size_t len;
	u32 da;
	void *priv;
	char name[32];
	struct list_head node;
	u32 rsc_offset;
	u32 flags;
	u32 of_resm_idx;
	int (*alloc)(struct rproc *, struct rproc_mem_entry *);
	int (*release)(struct rproc *, struct rproc_mem_entry *);
};

struct rproc_ops;

struct resource_table;

struct rproc {
	struct list_head node;
	struct iommu_domain *domain;
	const char *name;
	const char *firmware;
	void *priv;
	struct rproc_ops *ops;
	struct device dev;
	atomic_t power;
	unsigned int state;
	enum rproc_dump_mechanism dump_conf;
	struct mutex lock;
	struct dentry *dbg_dir;
	struct list_head traces;
	int num_traces;
	struct list_head carveouts;
	struct list_head mappings;
	u64 bootaddr;
	struct list_head rvdevs;
	struct list_head subdevs;
	struct idr notifyids;
	int index;
	struct work_struct crash_handler;
	unsigned int crash_cnt;
	bool recovery_disabled;
	int max_notifyid;
	struct resource_table *table_ptr;
	struct resource_table *clean_table;
	struct resource_table *cached_table;
	size_t table_sz;
	bool has_iommu;
	bool auto_boot;
	bool sysfs_read_only;
	struct list_head dump_segments;
	int nb_vdev;
	u8 elf_class;
	u16 elf_machine;
	struct cdev cdev;
	bool cdev_put_on_release;
	unsigned long features[1];
};

struct rproc_ops {
	int (*prepare)(struct rproc *);
	int (*unprepare)(struct rproc *);
	int (*start)(struct rproc *);
	int (*stop)(struct rproc *);
	int (*attach)(struct rproc *);
	int (*detach)(struct rproc *);
	void (*kick)(struct rproc *, int);
	void * (*da_to_va)(struct rproc *, u64, size_t, bool *);
	int (*parse_fw)(struct rproc *, const struct firmware *);
	int (*handle_rsc)(struct rproc *, u32, void *, int, int);
	struct resource_table * (*find_loaded_rsc_table)(struct rproc *, const struct firmware *);
	struct resource_table * (*get_loaded_rsc_table)(struct rproc *, size_t *);
	int (*load)(struct rproc *, const struct firmware *);
	int (*sanity_check)(struct rproc *, const struct firmware *);
	u64 (*get_boot_addr)(struct rproc *, const struct firmware *);
	unsigned long (*panic)(struct rproc *);
	void (*coredump)(struct rproc *);
};

struct resource_table {
	u32 ver;
	u32 num;
	u32 reserved[2];
	u32 offset[0];
};

struct rproc_debug_trace {
	struct rproc *rproc;
	struct dentry *tfile;
	struct list_head node;
	struct rproc_mem_entry trace_mem;
};

struct fw_rsc_vdev_vring {
	u32 da;
	u32 align;
	u32 num;
	u32 notifyid;
	u32 pa;
};

struct fw_rsc_vdev {
	u32 id;
	u32 notifyid;
	u32 dfeatures;
	u32 gfeatures;
	u32 config_len;
	u8 status;
	u8 num_of_vrings;
	u8 reserved[2];
	struct fw_rsc_vdev_vring vring[0];
};

struct fw_rsc_trace {
	u32 da;
	u32 len;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_devmem {
	u32 da;
	u32 pa;
	u32 len;
	u32 flags;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_carveout {
	u32 da;
	u32 pa;
	u32 len;
	u32 flags;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_hdr {
	u32 type;
	u8 data[0];
};

struct dpfe_api {
	int version;
	const char *fw_name;
	const struct attribute_group **sysfs_attrs;
	u32 command[48];
};

enum dpfe_commands {
	DPFE_CMD_GET_INFO = 0,
	DPFE_CMD_GET_REFRESH = 1,
	DPFE_CMD_GET_VENDOR = 2,
	DPFE_CMD_MAX = 3,
};

enum dpfe_msg_fields {
	MSG_HEADER = 0,
	MSG_COMMAND = 1,
	MSG_ARG_COUNT = 2,
	MSG_ARG0 = 3,
	MSG_FIELD_MAX = 16,
};

struct dpfe_firmware_header {
	u32 magic;
	u32 sequence;
	u32 version;
	u32 imem_size;
	u32 dmem_size;
};

struct brcmstb_dpfe_priv {
	void *regs;
	void *dmem;
	void *imem;
	struct device *dev;
	const struct dpfe_api *dpfe_api;
	struct mutex lock;
};

struct init_data {
	unsigned int dmem_len;
	unsigned int imem_len;
	unsigned int chksum;
	bool is_big_endian;
};

struct hisi_pmu;

struct hisi_uncore_ops {
	int (*check_filter)(struct perf_event *);
	void (*write_evtype)(struct hisi_pmu *, int, u32);
	int (*get_event_idx)(struct perf_event *);
	u64 (*read_counter)(struct hisi_pmu *, struct hw_perf_event *);
	void (*write_counter)(struct hisi_pmu *, struct hw_perf_event *, u64);
	void (*enable_counter)(struct hisi_pmu *, struct hw_perf_event *);
	void (*disable_counter)(struct hisi_pmu *, struct hw_perf_event *);
	void (*enable_counter_int)(struct hisi_pmu *, struct hw_perf_event *);
	void (*disable_counter_int)(struct hisi_pmu *, struct hw_perf_event *);
	void (*start_counters)(struct hisi_pmu *);
	void (*stop_counters)(struct hisi_pmu *);
	u32 (*get_int_status)(struct hisi_pmu *);
	void (*clear_int_status)(struct hisi_pmu *, int);
	void (*enable_filter)(struct perf_event *);
	void (*disable_filter)(struct perf_event *);
};

struct hisi_pmu_hwevents {
	struct perf_event *hw_events[16];
	unsigned long used_mask[1];
	const struct attribute_group **attr_groups;
};

struct hisi_pmu_dev_info;

struct hisi_pmu {
	struct pmu pmu;
	const struct hisi_uncore_ops *ops;
	const struct hisi_pmu_dev_info *dev_info;
	struct hisi_pmu_hwevents pmu_events;
	cpumask_t associated_cpus;
	int on_cpu;
	int irq;
	struct device *dev;
	struct hlist_node node;
	int sccl_id;
	int sicl_id;
	int ccl_id;
	void *base;
	u32 index_id;
	u32 sub_id;
	int num_counters;
	int counter_bits;
	int check_event;
	u32 identifier;
};

struct hisi_pmu_dev_info {
	const char *name;
	const struct attribute_group **attr_groups;
	void *private;
};

struct qfprom_soc_data {
	u32 accel_value;
	u32 qfprom_blow_timer_value;
	u32 qfprom_blow_set_freq;
	int qfprom_blow_uV;
};

struct qfprom_soc_compatible_data {
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
};

struct qfprom_priv {
	void *qfpraw;
	void *qfpconf;
	void *qfpcorrected;
	void *qfpsecurity;
	struct device *dev;
	struct clk *secclk;
	struct regulator *vcc;
	const struct qfprom_soc_data *soc_data;
};

struct qfprom_touched_values {
	unsigned long clk_rate;
	u32 accel_val;
	u32 timer_val;
};

struct qcom_icc_node;

struct qcom_icc_bcm;

struct qcom_icc_desc {
	struct qcom_icc_node * const *nodes;
	size_t num_nodes;
	struct qcom_icc_bcm * const *bcms;
	size_t num_bcms;
};

struct qcom_icc_node {
	const char *name;
	u16 links[128];
	u16 id;
	u16 num_links;
	u16 channels;
	u16 buswidth;
	u64 sum_avg[3];
	u64 max_peak[3];
	struct qcom_icc_bcm *bcms[3];
	size_t num_bcms;
};

struct bcm_db {
	__le32 unit;
	__le16 width;
	u8 vcd;
	u8 reserved;
};

struct qcom_icc_bcm {
	const char *name;
	u32 type;
	u32 addr;
	u64 vote_x[3];
	u64 vote_y[3];
	u64 vote_scale;
	u32 enable_mask;
	bool dirty;
	bool keepalive;
	struct bcm_db aux_data;
	struct list_head list;
	struct list_head ws_list;
	size_t num_nodes;
	struct qcom_icc_node *nodes[0];
};

struct snd_info_entry;

struct snd_info_buffer;

struct snd_info_entry_text {
	void (*read)(struct snd_info_entry *, struct snd_info_buffer *);
	void (*write)(struct snd_info_entry *, struct snd_info_buffer *);
};

struct snd_info_entry_ops;

struct snd_info_entry {
	const char *name;
	umode_t mode;
	long size;
	unsigned short content;
	union {
		struct snd_info_entry_text text;
		const struct snd_info_entry_ops *ops;
	} c;
	struct snd_info_entry *parent;
	struct module *module;
	void *private_data;
	void (*private_free)(struct snd_info_entry *);
	struct proc_dir_entry *p;
	struct mutex access;
	struct list_head children;
	struct list_head list;
};

struct snd_info_buffer {
	char *buffer;
	unsigned int curr;
	unsigned int size;
	unsigned int len;
	int stop;
	int error;
};

struct snd_info_entry_ops {
	int (*open)(struct snd_info_entry *, unsigned short, void **);
	int (*release)(struct snd_info_entry *, unsigned short, void *);
	ssize_t (*read)(struct snd_info_entry *, void *, struct file *, char __attribute__((btf_type_tag("user"))) *, size_t, loff_t);
	ssize_t (*write)(struct snd_info_entry *, void *, struct file *, const char __attribute__((btf_type_tag("user"))) *, size_t, loff_t);
	loff_t (*llseek)(struct snd_info_entry *, void *, struct file *, loff_t, int);
	__poll_t (*poll)(struct snd_info_entry *, void *, struct file *, poll_table *);
	int (*ioctl)(struct snd_info_entry *, void *, struct file *, unsigned int, unsigned long);
	int (*mmap)(struct snd_info_entry *, void *, struct inode *, struct file *, struct vm_area_struct *);
};

struct snd_shutdown_f_ops;

struct snd_card {
	int number;
	char id[16];
	char driver[16];
	char shortname[32];
	char longname[80];
	char irq_descr[32];
	char mixername[80];
	char components[128];
	struct module *module;
	void *private_data;
	void (*private_free)(struct snd_card *);
	struct list_head devices;
	struct device *ctl_dev;
	unsigned int last_numid;
	struct rw_semaphore controls_rwsem;
	rwlock_t ctl_files_rwlock;
	int controls_count;
	size_t user_ctl_alloc_size;
	struct list_head controls;
	struct list_head ctl_files;
	struct xarray ctl_numids;
	struct xarray ctl_hash;
	bool ctl_hash_collision;
	struct snd_info_entry *proc_root;
	struct proc_dir_entry *proc_root_link;
	struct list_head files_list;
	struct snd_shutdown_f_ops *s_f_ops;
	spinlock_t files_lock;
	int shutdown;
	struct completion *release_completion;
	struct device *dev;
	struct device card_dev;
	const struct attribute_group *dev_groups[4];
	bool registered;
	bool managed;
	bool releasing;
	int sync_irq;
	wait_queue_head_t remove_sleep;
	size_t total_pcm_alloc_bytes;
	struct mutex memory_mutex;
	unsigned int power_state;
	atomic_t power_ref;
	wait_queue_head_t power_sleep;
	wait_queue_head_t power_ref_sleep;
};

struct snd_info_private_data {
	struct snd_info_buffer *rbuffer;
	struct snd_info_buffer *wbuffer;
	struct snd_info_entry *entry;
	void *file_private_data;
};

enum snd_dma_sync_mode {
	SNDRV_DMA_SYNC_CPU = 0,
	SNDRV_DMA_SYNC_DEVICE = 1,
};

struct snd_dma_buffer;

struct snd_malloc_ops {
	void * (*alloc)(struct snd_dma_buffer *, size_t);
	void (*free)(struct snd_dma_buffer *);
	dma_addr_t (*get_addr)(struct snd_dma_buffer *, size_t);
	struct page * (*get_page)(struct snd_dma_buffer *, size_t);
	unsigned int (*get_chunk_size)(struct snd_dma_buffer *, unsigned int, unsigned int);
	int (*mmap)(struct snd_dma_buffer *, struct vm_area_struct *);
	void (*sync)(struct snd_dma_buffer *, enum snd_dma_sync_mode);
};

struct snd_dma_device {
	int type;
	enum dma_data_direction dir;
	bool need_sync;
	struct device *dev;
};

struct snd_dma_buffer {
	struct snd_dma_device dev;
	unsigned char *area;
	dma_addr_t addr;
	size_t bytes;
	void *private_data;
};

typedef unsigned long (*genpool_algo_t)(unsigned long *, unsigned long, unsigned long, unsigned int, void *, struct gen_pool *, unsigned long);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct snd_soc_card;

typedef void (*btf_trace_snd_soc_bias_level_start)(void *, struct snd_soc_card *, int);

enum snd_soc_pcm_subclass {
	SND_SOC_PCM_CLASS_PCM = 0,
	SND_SOC_PCM_CLASS_BE = 1,
};

enum snd_soc_bias_level {
	SND_SOC_BIAS_OFF = 0,
	SND_SOC_BIAS_STANDBY = 1,
	SND_SOC_BIAS_PREPARE = 2,
	SND_SOC_BIAS_ON = 3,
};

struct snd_soc_component;

struct snd_soc_dapm_widget;

struct snd_soc_dapm_context {
	enum snd_soc_bias_level bias_level;
	unsigned int idle_bias_off: 1;
	unsigned int suspend_bias_off: 1;
	struct device *dev;
	struct snd_soc_component *component;
	struct snd_soc_card *card;
	enum snd_soc_bias_level target_bias_level;
	struct list_head list;
	struct snd_soc_dapm_widget *wcache_sink;
	struct snd_soc_dapm_widget *wcache_source;
	struct dentry *debugfs_dapm;
};

struct snd_soc_dapm_stats {
	int power_checks;
	int path_checks;
	int neighbour_checks;
};

struct snd_soc_dai_link;

struct snd_soc_codec_conf;

struct snd_soc_aux_dev;

struct snd_kcontrol_new;

struct snd_soc_dapm_route;

struct snd_soc_dapm_update;

struct snd_soc_card {
	const char *name;
	const char *long_name;
	const char *driver_name;
	const char *components;
	char dmi_longname[80];
	unsigned short pci_subsystem_vendor;
	unsigned short pci_subsystem_device;
	bool pci_subsystem_set;
	char topology_shortname[32];
	struct device *dev;
	struct snd_card *snd_card;
	struct module *owner;
	struct mutex mutex;
	struct mutex dapm_mutex;
	struct mutex pcm_mutex;
	enum snd_soc_pcm_subclass pcm_subclass;
	int (*probe)(struct snd_soc_card *);
	int (*late_probe)(struct snd_soc_card *);
	void (*fixup_controls)(struct snd_soc_card *);
	int (*remove)(struct snd_soc_card *);
	int (*suspend_pre)(struct snd_soc_card *);
	int (*suspend_post)(struct snd_soc_card *);
	int (*resume_pre)(struct snd_soc_card *);
	int (*resume_post)(struct snd_soc_card *);
	int (*set_bias_level)(struct snd_soc_card *, struct snd_soc_dapm_context *, enum snd_soc_bias_level);
	int (*set_bias_level_post)(struct snd_soc_card *, struct snd_soc_dapm_context *, enum snd_soc_bias_level);
	int (*add_dai_link)(struct snd_soc_card *, struct snd_soc_dai_link *);
	void (*remove_dai_link)(struct snd_soc_card *, struct snd_soc_dai_link *);
	long pmdown_time;
	struct snd_soc_dai_link *dai_link;
	int num_links;
	struct list_head rtd_list;
	int num_rtd;
	struct snd_soc_codec_conf *codec_conf;
	int num_configs;
	struct snd_soc_aux_dev *aux_dev;
	int num_aux_devs;
	struct list_head aux_comp_list;
	const struct snd_kcontrol_new *controls;
	int num_controls;
	const struct snd_soc_dapm_widget *dapm_widgets;
	int num_dapm_widgets;
	const struct snd_soc_dapm_route *dapm_routes;
	int num_dapm_routes;
	const struct snd_soc_dapm_widget *of_dapm_widgets;
	int num_of_dapm_widgets;
	const struct snd_soc_dapm_route *of_dapm_routes;
	int num_of_dapm_routes;
	struct list_head component_dev_list;
	struct list_head list;
	struct list_head widgets;
	struct list_head paths;
	struct list_head dapm_list;
	struct list_head dapm_dirty;
	struct list_head dobj_list;
	struct snd_soc_dapm_context dapm;
	struct snd_soc_dapm_stats dapm_stats;
	struct snd_soc_dapm_update *update;
	struct dentry *debugfs_card_root;
	struct work_struct deferred_resume_work;
	u32 pop_time;
	unsigned int instantiated: 1;
	unsigned int topology_shortname_created: 1;
	unsigned int fully_routed: 1;
	unsigned int disable_route_checks: 1;
	unsigned int probed: 1;
	unsigned int component_chaining: 1;
	void *drvdata;
};

struct snd_soc_component_driver;

struct snd_pcm_substream;

struct snd_compr_stream;

struct snd_soc_component {
	const char *name;
	int id;
	const char *name_prefix;
	struct device *dev;
	struct snd_soc_card *card;
	unsigned int active;
	unsigned int suspended: 1;
	struct list_head list;
	struct list_head card_aux_list;
	struct list_head card_list;
	const struct snd_soc_component_driver *driver;
	struct list_head dai_list;
	int num_dai;
	struct regmap *regmap;
	int val_bytes;
	struct mutex io_mutex;
	struct list_head dobj_list;
	struct snd_soc_dapm_context dapm;
	int (*init)(struct snd_soc_component *);
	void *mark_module;
	struct snd_pcm_substream *mark_open;
	struct snd_pcm_substream *mark_hw_params;
	struct snd_pcm_substream *mark_trigger;
	struct snd_compr_stream *mark_compr_open;
	void *mark_pm;
	struct dentry *debugfs_root;
	const char *debugfs_prefix;
};

enum snd_soc_dapm_type {
	snd_soc_dapm_input = 0,
	snd_soc_dapm_output = 1,
	snd_soc_dapm_mux = 2,
	snd_soc_dapm_demux = 3,
	snd_soc_dapm_mixer = 4,
	snd_soc_dapm_mixer_named_ctl = 5,
	snd_soc_dapm_pga = 6,
	snd_soc_dapm_out_drv = 7,
	snd_soc_dapm_adc = 8,
	snd_soc_dapm_dac = 9,
	snd_soc_dapm_micbias = 10,
	snd_soc_dapm_mic = 11,
	snd_soc_dapm_hp = 12,
	snd_soc_dapm_spk = 13,
	snd_soc_dapm_line = 14,
	snd_soc_dapm_switch = 15,
	snd_soc_dapm_vmid = 16,
	snd_soc_dapm_pre = 17,
	snd_soc_dapm_post = 18,
	snd_soc_dapm_supply = 19,
	snd_soc_dapm_pinctrl = 20,
	snd_soc_dapm_regulator_supply = 21,
	snd_soc_dapm_clock_supply = 22,
	snd_soc_dapm_aif_in = 23,
	snd_soc_dapm_aif_out = 24,
	snd_soc_dapm_siggen = 25,
	snd_soc_dapm_sink = 26,
	snd_soc_dapm_dai_in = 27,
	snd_soc_dapm_dai_out = 28,
	snd_soc_dapm_dai_link = 29,
	snd_soc_dapm_kcontrol = 30,
	snd_soc_dapm_buffer = 31,
	snd_soc_dapm_scheduler = 32,
	snd_soc_dapm_effect = 33,
	snd_soc_dapm_src = 34,
	snd_soc_dapm_asrc = 35,
	snd_soc_dapm_encoder = 36,
	snd_soc_dapm_decoder = 37,
	SND_SOC_DAPM_TYPE_COUNT = 38,
};

typedef unsigned long snd_pcm_uframes_t;

typedef long snd_pcm_sframes_t;

enum snd_soc_trigger_order {
	SND_SOC_TRIGGER_ORDER_DEFAULT = 0,
	SND_SOC_TRIGGER_ORDER_LDC = 1,
	SND_SOC_TRIGGER_ORDER_MAX = 2,
};

struct snd_soc_pcm_runtime;

struct snd_pcm;

struct snd_soc_jack;

struct snd_pcm_hw_params;

struct snd_pcm_audio_tstamp_config;

struct snd_pcm_audio_tstamp_report;

struct snd_compress_ops;

struct snd_soc_component_driver {
	const char *name;
	const struct snd_kcontrol_new *controls;
	unsigned int num_controls;
	const struct snd_soc_dapm_widget *dapm_widgets;
	unsigned int num_dapm_widgets;
	const struct snd_soc_dapm_route *dapm_routes;
	unsigned int num_dapm_routes;
	int (*probe)(struct snd_soc_component *);
	void (*remove)(struct snd_soc_component *);
	int (*suspend)(struct snd_soc_component *);
	int (*resume)(struct snd_soc_component *);
	unsigned int (*read)(struct snd_soc_component *, unsigned int);
	int (*write)(struct snd_soc_component *, unsigned int, unsigned int);
	int (*pcm_construct)(struct snd_soc_component *, struct snd_soc_pcm_runtime *);
	void (*pcm_destruct)(struct snd_soc_component *, struct snd_pcm *);
	int (*set_sysclk)(struct snd_soc_component *, int, int, unsigned int, int);
	int (*set_pll)(struct snd_soc_component *, int, int, unsigned int, unsigned int);
	int (*set_jack)(struct snd_soc_component *, struct snd_soc_jack *, void *);
	int (*get_jack_type)(struct snd_soc_component *);
	int (*of_xlate_dai_name)(struct snd_soc_component *, const struct of_phandle_args *, const char **);
	int (*of_xlate_dai_id)(struct snd_soc_component *, struct device_node *);
	void (*seq_notifier)(struct snd_soc_component *, enum snd_soc_dapm_type, int);
	int (*stream_event)(struct snd_soc_component *, int);
	int (*set_bias_level)(struct snd_soc_component *, enum snd_soc_bias_level);
	int (*open)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*close)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*ioctl)(struct snd_soc_component *, struct snd_pcm_substream *, unsigned int, void *);
	int (*hw_params)(struct snd_soc_component *, struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*prepare)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*trigger)(struct snd_soc_component *, struct snd_pcm_substream *, int);
	int (*sync_stop)(struct snd_soc_component *, struct snd_pcm_substream *);
	snd_pcm_uframes_t (*pointer)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*get_time_info)(struct snd_soc_component *, struct snd_pcm_substream *, struct timespec64 *, struct timespec64 *, struct snd_pcm_audio_tstamp_config *, struct snd_pcm_audio_tstamp_report *);
	int (*copy)(struct snd_soc_component *, struct snd_pcm_substream *, int, unsigned long, struct iov_iter *, unsigned long);
	struct page * (*page)(struct snd_soc_component *, struct snd_pcm_substream *, unsigned long);
	int (*mmap)(struct snd_soc_component *, struct snd_pcm_substream *, struct vm_area_struct *);
	int (*ack)(struct snd_soc_component *, struct snd_pcm_substream *);
	snd_pcm_sframes_t (*delay)(struct snd_soc_component *, struct snd_pcm_substream *);
	const struct snd_compress_ops *compress_ops;
	int probe_order;
	int remove_order;
	enum snd_soc_trigger_order trigger_start;
	enum snd_soc_trigger_order trigger_stop;
	unsigned int module_get_upon_open: 1;
	unsigned int idle_bias_on: 1;
	unsigned int suspend_bias_off: 1;
	unsigned int use_pmdown_time: 1;
	unsigned int endianness: 1;
	unsigned int legacy_dai_naming: 1;
	const char *ignore_machine;
	const char *topology_name_prefix;
	int (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *, struct snd_pcm_hw_params *);
	bool use_dai_pcm_id;
	int be_pcm_base;
	const char *debugfs_prefix;
};

typedef int snd_ctl_elem_iface_t;

struct snd_kcontrol;

struct snd_ctl_elem_info;

typedef int snd_kcontrol_info_t(struct snd_kcontrol *, struct snd_ctl_elem_info *);

struct snd_ctl_elem_value;

typedef int snd_kcontrol_get_t(struct snd_kcontrol *, struct snd_ctl_elem_value *);

typedef int snd_kcontrol_put_t(struct snd_kcontrol *, struct snd_ctl_elem_value *);

typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol *, int, unsigned int, unsigned int __attribute__((btf_type_tag("user"))) *);

struct snd_kcontrol_new {
	snd_ctl_elem_iface_t iface;
	unsigned int device;
	unsigned int subdevice;
	const char *name;
	unsigned int index;
	unsigned int access;
	unsigned int count;
	snd_kcontrol_info_t *info;
	snd_kcontrol_get_t *get;
	snd_kcontrol_put_t *put;
	union {
		snd_kcontrol_tlv_rw_t *c;
		const unsigned int *p;
	} tlv;
	unsigned long private_value;
};

struct snd_ctl_elem_id {
	unsigned int numid;
	snd_ctl_elem_iface_t iface;
	unsigned int device;
	unsigned int subdevice;
	unsigned char name[44];
	unsigned int index;
};

struct snd_ctl_file;

struct snd_kcontrol_volatile {
	struct snd_ctl_file *owner;
	unsigned int access;
};

struct snd_kcontrol {
	struct list_head list;
	struct snd_ctl_elem_id id;
	unsigned int count;
	snd_kcontrol_info_t *info;
	snd_kcontrol_get_t *get;
	snd_kcontrol_put_t *put;
	union {
		snd_kcontrol_tlv_rw_t *c;
		const unsigned int *p;
	} tlv;
	unsigned long private_value;
	void *private_data;
	void (*private_free)(struct snd_kcontrol *);
	struct snd_kcontrol_volatile vd[0];
};

struct snd_aes_iec958 {
	unsigned char status[24];
	unsigned char subcode[147];
	unsigned char pad;
	unsigned char dig_subframe[4];
};

struct snd_ctl_elem_value {
	struct snd_ctl_elem_id id;
	unsigned int indirect: 1;
	union {
		union {
			long value[128];
			long *value_ptr;
		} integer;
		union {
			long long value[64];
			long long *value_ptr;
		} integer64;
		union {
			unsigned int item[128];
			unsigned int *item_ptr;
		} enumerated;
		union {
			unsigned char data[512];
			unsigned char *data_ptr;
		} bytes;
		struct snd_aes_iec958 iec958;
	} value;
	unsigned char reserved[128];
};

struct snd_fasync;

struct snd_ctl_file {
	struct list_head list;
	struct snd_card *card;
	struct pid *pid;
	int preferred_subdevice[2];
	wait_queue_head_t change_sleep;
	spinlock_t read_lock;
	struct snd_fasync *fasync;
	int subscribed;
	struct list_head events;
};

typedef int snd_ctl_elem_type_t;

struct snd_ctl_elem_info {
	struct snd_ctl_elem_id id;
	snd_ctl_elem_type_t type;
	unsigned int access;
	unsigned int count;
	__kernel_pid_t owner;
	union {
		struct {
			long min;
			long max;
			long step;
		} integer;
		struct {
			long long min;
			long long max;
			long long step;
		} integer64;
		struct {
			unsigned int items;
			unsigned int item;
			char name[64];
			__u64 names_ptr;
			unsigned int names_length;
		} enumerated;
		unsigned char reserved[128];
	} value;
	unsigned char reserved[64];
};

enum snd_soc_dobj_type {
	SND_SOC_DOBJ_NONE = 0,
	SND_SOC_DOBJ_MIXER = 1,
	SND_SOC_DOBJ_BYTES = 2,
	SND_SOC_DOBJ_ENUM = 3,
	SND_SOC_DOBJ_GRAPH = 4,
	SND_SOC_DOBJ_WIDGET = 5,
	SND_SOC_DOBJ_DAI_LINK = 6,
	SND_SOC_DOBJ_PCM = 7,
	SND_SOC_DOBJ_CODEC_LINK = 8,
	SND_SOC_DOBJ_BACKEND_LINK = 9,
};

struct snd_soc_dobj_control {
	struct snd_kcontrol *kcontrol;
	char **dtexts;
	unsigned long *dvalues;
};

struct snd_soc_dobj_widget {
	unsigned int *kcontrol_type;
};

struct snd_soc_dobj {
	enum snd_soc_dobj_type type;
	unsigned int index;
	struct list_head list;
	int (*unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	union {
		struct snd_soc_dobj_control control;
		struct snd_soc_dobj_widget widget;
	};
	void *private;
};

struct snd_soc_dapm_widget {
	enum snd_soc_dapm_type id;
	const char *name;
	const char *sname;
	struct list_head list;
	struct snd_soc_dapm_context *dapm;
	void *priv;
	struct regulator *regulator;
	struct pinctrl *pinctrl;
	int reg;
	unsigned char shift;
	unsigned int mask;
	unsigned int on_val;
	unsigned int off_val;
	unsigned char power: 1;
	unsigned char active: 1;
	unsigned char connected: 1;
	unsigned char new: 1;
	unsigned char force: 1;
	unsigned char ignore_suspend: 1;
	unsigned char new_power: 1;
	unsigned char power_checked: 1;
	unsigned char is_supply: 1;
	unsigned char is_ep: 2;
	unsigned char no_wname_in_kcontrol_name: 1;
	int subseq;
	int (*power_check)(struct snd_soc_dapm_widget *);
	unsigned short event_flags;
	int (*event)(struct snd_soc_dapm_widget *, struct snd_kcontrol *, int);
	int num_kcontrols;
	const struct snd_kcontrol_new *kcontrol_news;
	struct snd_kcontrol **kcontrols;
	struct snd_soc_dobj dobj;
	struct list_head edges[2];
	struct list_head work_list;
	struct list_head power_list;
	struct list_head dirty;
	int endpoints[2];
	struct clk *clk;
	int channel;
};

struct snd_soc_dapm_route {
	const char *sink;
	const char *control;
	const char *source;
	int (*connected)(struct snd_soc_dapm_widget *, struct snd_soc_dapm_widget *);
	struct snd_soc_dobj dobj;
};

struct snd_pcm_ops {
	int (*open)(struct snd_pcm_substream *);
	int (*close)(struct snd_pcm_substream *);
	int (*ioctl)(struct snd_pcm_substream *, unsigned int, void *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_pcm_substream *);
	int (*prepare)(struct snd_pcm_substream *);
	int (*trigger)(struct snd_pcm_substream *, int);
	int (*sync_stop)(struct snd_pcm_substream *);
	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
	int (*get_time_info)(struct snd_pcm_substream *, struct timespec64 *, struct timespec64 *, struct snd_pcm_audio_tstamp_config *, struct snd_pcm_audio_tstamp_report *);
	int (*fill_silence)(struct snd_pcm_substream *, int, unsigned long, unsigned long);
	int (*copy)(struct snd_pcm_substream *, int, unsigned long, struct iov_iter *, unsigned long);
	struct page * (*page)(struct snd_pcm_substream *, unsigned long);
	int (*mmap)(struct snd_pcm_substream *, struct vm_area_struct *);
	int (*ack)(struct snd_pcm_substream *);
};

struct snd_mask {
	__u32 bits[8];
};

struct snd_interval {
	unsigned int min;
	unsigned int max;
	unsigned int openmin: 1;
	unsigned int openmax: 1;
	unsigned int integer: 1;
	unsigned int empty: 1;
};

struct snd_pcm_hw_params {
	unsigned int flags;
	struct snd_mask masks[3];
	struct snd_mask mres[5];
	struct snd_interval intervals[12];
	struct snd_interval ires[9];
	unsigned int rmask;
	unsigned int cmask;
	unsigned int info;
	unsigned int msbits;
	unsigned int rate_num;
	unsigned int rate_den;
	snd_pcm_uframes_t fifo_size;
	unsigned char reserved[64];
};

enum snd_soc_dpcm_update {
	SND_SOC_DPCM_UPDATE_NO = 0,
	SND_SOC_DPCM_UPDATE_BE = 1,
	SND_SOC_DPCM_UPDATE_FE = 2,
};

enum snd_soc_dpcm_state {
	SND_SOC_DPCM_STATE_NEW = 0,
	SND_SOC_DPCM_STATE_OPEN = 1,
	SND_SOC_DPCM_STATE_HW_PARAMS = 2,
	SND_SOC_DPCM_STATE_PREPARE = 3,
	SND_SOC_DPCM_STATE_START = 4,
	SND_SOC_DPCM_STATE_STOP = 5,
	SND_SOC_DPCM_STATE_PAUSED = 6,
	SND_SOC_DPCM_STATE_SUSPEND = 7,
	SND_SOC_DPCM_STATE_HW_FREE = 8,
	SND_SOC_DPCM_STATE_CLOSE = 9,
};

struct snd_soc_dpcm_runtime {
	struct list_head be_clients;
	struct list_head fe_clients;
	int users;
	struct snd_pcm_hw_params hw_params;
	enum snd_soc_dpcm_update runtime_update;
	enum snd_soc_dpcm_state state;
	int trigger_pending;
	int be_start;
	int be_pause;
	bool fe_pause;
};

struct snd_compr;

struct snd_soc_dai;

struct snd_soc_pcm_runtime {
	struct device *dev;
	struct snd_soc_card *card;
	struct snd_soc_dai_link *dai_link;
	struct snd_pcm_ops ops;
	unsigned int c2c_params_select;
	struct snd_soc_dpcm_runtime dpcm[2];
	struct snd_soc_dapm_widget *c2c_widget[2];
	long pmdown_time;
	struct snd_pcm *pcm;
	struct snd_compr *compr;
	struct snd_soc_dai **dais;
	struct delayed_work delayed_work;
	void (*close_delayed_work_func)(struct snd_soc_pcm_runtime *);
	struct dentry *debugfs_dpcm_root;
	unsigned int num;
	struct list_head list;
	struct snd_pcm_substream *mark_startup;
	struct snd_pcm_substream *mark_hw_params;
	struct snd_pcm_substream *mark_trigger;
	struct snd_compr_stream *mark_compr_startup;
	unsigned int pop_wait: 1;
	unsigned int fe_compr: 1;
	bool initialized;
	int num_components;
	struct snd_soc_component *components[0];
};

enum snd_soc_dpcm_trigger {
	SND_SOC_DPCM_TRIGGER_PRE = 0,
	SND_SOC_DPCM_TRIGGER_POST = 1,
	SND_SOC_DPCM_TRIGGER_BESPOKE = 2,
};

struct snd_soc_dai_link_component;

struct snd_soc_dai_link_codec_ch_map;

struct snd_soc_pcm_stream;

struct snd_soc_ops;

struct snd_soc_compr_ops;

struct snd_soc_dai_link {
	const char *name;
	const char *stream_name;
	struct snd_soc_dai_link_component *cpus;
	unsigned int num_cpus;
	struct snd_soc_dai_link_component *codecs;
	unsigned int num_codecs;
	struct snd_soc_dai_link_codec_ch_map *codec_ch_maps;
	struct snd_soc_dai_link_component *platforms;
	unsigned int num_platforms;
	int id;
	const struct snd_soc_pcm_stream *c2c_params;
	unsigned int num_c2c_params;
	unsigned int dai_fmt;
	enum snd_soc_dpcm_trigger trigger[2];
	int (*init)(struct snd_soc_pcm_runtime *);
	void (*exit)(struct snd_soc_pcm_runtime *);
	int (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *, struct snd_pcm_hw_params *);
	const struct snd_soc_ops *ops;
	const struct snd_soc_compr_ops *compr_ops;
	enum snd_soc_trigger_order trigger_start;
	enum snd_soc_trigger_order trigger_stop;
	unsigned int nonatomic: 1;
	unsigned int playback_only: 1;
	unsigned int capture_only: 1;
	unsigned int ignore_suspend: 1;
	unsigned int symmetric_rate: 1;
	unsigned int symmetric_channels: 1;
	unsigned int symmetric_sample_bits: 1;
	unsigned int no_pcm: 1;
	unsigned int dynamic: 1;
	unsigned int dpcm_capture: 1;
	unsigned int dpcm_playback: 1;
	unsigned int dpcm_merged_format: 1;
	unsigned int dpcm_merged_chan: 1;
	unsigned int dpcm_merged_rate: 1;
	unsigned int ignore_pmdown_time: 1;
	unsigned int ignore: 1;
	struct snd_soc_dobj dobj;
};

struct snd_soc_dai_link_component {
	const char *name;
	struct device_node *of_node;
	const char *dai_name;
	struct of_phandle_args *dai_args;
};

struct snd_soc_dai_link_codec_ch_map {
	unsigned int connected_cpu_id;
	unsigned int ch_mask;
};

struct snd_soc_pcm_stream {
	const char *stream_name;
	u64 formats;
	unsigned int rates;
	unsigned int rate_min;
	unsigned int rate_max;
	unsigned int channels_min;
	unsigned int channels_max;
	unsigned int sig_bits;
};

struct snd_soc_ops {
	int (*startup)(struct snd_pcm_substream *);
	void (*shutdown)(struct snd_pcm_substream *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_pcm_substream *);
	int (*prepare)(struct snd_pcm_substream *);
	int (*trigger)(struct snd_pcm_substream *, int);
};

struct snd_pcm_group {
	spinlock_t lock;
	struct mutex mutex;
	struct list_head substreams;
	refcount_t refs;
};

struct snd_pcm_str;

struct snd_pcm_runtime;

struct snd_timer;

struct snd_pcm_substream {
	struct snd_pcm *pcm;
	struct snd_pcm_str *pstr;
	void *private_data;
	int number;
	char name[32];
	int stream;
	struct pm_qos_request latency_pm_qos_req;
	size_t buffer_bytes_max;
	struct snd_dma_buffer dma_buffer;
	size_t dma_max;
	const struct snd_pcm_ops *ops;
	struct snd_pcm_runtime *runtime;
	struct snd_timer *timer;
	unsigned int timer_running: 1;
	long wait_time;
	struct snd_pcm_substream *next;
	struct list_head link_list;
	struct snd_pcm_group self_group;
	struct snd_pcm_group *group;
	int ref_count;
	atomic_t mmap_count;
	unsigned int f_flags;
	void (*pcm_release)(struct snd_pcm_substream *);
	struct pid *pid;
	struct snd_info_entry *proc_root;
	unsigned int hw_opened: 1;
	unsigned int managed_buffer_alloc: 1;
};

struct snd_pcm_str {
	int stream;
	struct snd_pcm *pcm;
	unsigned int substream_count;
	unsigned int substream_opened;
	struct snd_pcm_substream *substream;
	struct snd_info_entry *proc_root;
	struct snd_kcontrol *chmap_kctl;
	struct device *dev;
};

struct snd_pcm {
	struct snd_card *card;
	struct list_head list;
	int device;
	unsigned int info_flags;
	unsigned short dev_class;
	unsigned short dev_subclass;
	char id[64];
	char name[80];
	struct snd_pcm_str streams[2];
	struct mutex open_mutex;
	wait_queue_head_t open_wait;
	void *private_data;
	void (*private_free)(struct snd_pcm *);
	bool internal;
	bool nonatomic;
	bool no_device_suspend;
};

struct snd_pcm_audio_tstamp_config {
	u32 type_requested: 4;
	u32 report_delay: 1;
};

struct snd_pcm_audio_tstamp_report {
	u32 valid: 1;
	u32 actual_type: 4;
	u32 accuracy_report: 1;
	u32 accuracy;
};

typedef int snd_pcm_state_t;

typedef int snd_pcm_access_t;

typedef int snd_pcm_format_t;

typedef int snd_pcm_subformat_t;

union snd_pcm_sync_id {
	unsigned char id[16];
	unsigned short id16[8];
	unsigned int id32[4];
};

struct snd_pcm_hardware {
	unsigned int info;
	u64 formats;
	unsigned int rates;
	unsigned int rate_min;
	unsigned int rate_max;
	unsigned int channels_min;
	unsigned int channels_max;
	size_t buffer_bytes_max;
	size_t period_bytes_min;
	size_t period_bytes_max;
	unsigned int periods_min;
	unsigned int periods_max;
	size_t fifo_size;
};

struct snd_pcm_hw_rule;

struct snd_pcm_hw_constraints {
	struct snd_mask masks[3];
	struct snd_interval intervals[12];
	unsigned int rules_num;
	unsigned int rules_all;
	struct snd_pcm_hw_rule *rules;
};

struct snd_pcm_mmap_status;

struct snd_pcm_mmap_control;

struct snd_pcm_runtime {
	snd_pcm_state_t state;
	snd_pcm_state_t suspended_state;
	struct snd_pcm_substream *trigger_master;
	struct timespec64 trigger_tstamp;
	bool trigger_tstamp_latched;
	int overrange;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t hw_ptr_base;
	snd_pcm_uframes_t hw_ptr_interrupt;
	unsigned long hw_ptr_jiffies;
	unsigned long hw_ptr_buffer_jiffies;
	snd_pcm_sframes_t delay;
	u64 hw_ptr_wrap;
	snd_pcm_access_t access;
	snd_pcm_format_t format;
	snd_pcm_subformat_t subformat;
	unsigned int rate;
	unsigned int channels;
	snd_pcm_uframes_t period_size;
	unsigned int periods;
	snd_pcm_uframes_t buffer_size;
	snd_pcm_uframes_t min_align;
	size_t byte_align;
	unsigned int frame_bits;
	unsigned int sample_bits;
	unsigned int info;
	unsigned int rate_num;
	unsigned int rate_den;
	unsigned int no_period_wakeup: 1;
	int tstamp_mode;
	unsigned int period_step;
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold;
	snd_pcm_uframes_t silence_size;
	snd_pcm_uframes_t boundary;
	snd_pcm_uframes_t silence_start;
	snd_pcm_uframes_t silence_filled;
	union snd_pcm_sync_id sync;
	struct snd_pcm_mmap_status *status;
	struct snd_pcm_mmap_control *control;
	snd_pcm_uframes_t twake;
	wait_queue_head_t sleep;
	wait_queue_head_t tsleep;
	struct snd_fasync *fasync;
	bool stop_operating;
	struct mutex buffer_mutex;
	atomic_t buffer_accessing;
	void *private_data;
	void (*private_free)(struct snd_pcm_runtime *);
	struct snd_pcm_hardware hw;
	struct snd_pcm_hw_constraints hw_constraints;
	unsigned int timer_resolution;
	int tstamp_type;
	unsigned char *dma_area;
	dma_addr_t dma_addr;
	size_t dma_bytes;
	struct snd_dma_buffer *dma_buffer_p;
	unsigned int buffer_changed: 1;
	struct snd_pcm_audio_tstamp_config audio_tstamp_config;
	struct snd_pcm_audio_tstamp_report audio_tstamp_report;
	struct timespec64 driver_tstamp;
};

typedef char __pad_before_uframe[0];

typedef char __pad_after_uframe[0];

struct snd_pcm_mmap_status {
	snd_pcm_state_t state;
	__u32 pad1;
	__pad_before_uframe __pad1;
	snd_pcm_uframes_t hw_ptr;
	__pad_after_uframe __pad2;
	struct __kernel_timespec tstamp;
	snd_pcm_state_t suspended_state;
	__u32 pad3;
	struct __kernel_timespec audio_tstamp;
};

struct snd_pcm_mmap_control {
	__pad_before_uframe __pad1;
	snd_pcm_uframes_t appl_ptr;
	__pad_before_uframe __pad2;
	__pad_before_uframe __pad3;
	snd_pcm_uframes_t avail_min;
	__pad_after_uframe __pad4;
};

typedef int (*snd_pcm_hw_rule_func_t)(struct snd_pcm_hw_params *, struct snd_pcm_hw_rule *);

struct snd_pcm_hw_rule {
	unsigned int cond;
	int var;
	int deps[5];
	snd_pcm_hw_rule_func_t func;
	void *private;
};

struct snd_soc_compr_ops {
	int (*startup)(struct snd_compr_stream *);
	void (*shutdown)(struct snd_compr_stream *);
	int (*set_params)(struct snd_compr_stream *);
};

enum snd_compr_direction {
	SND_COMPRESS_PLAYBACK = 0,
	SND_COMPRESS_CAPTURE = 1,
};

struct snd_compr_ops;

struct snd_compr_runtime;

struct snd_compr_stream {
	const char *name;
	struct snd_compr_ops *ops;
	struct snd_compr_runtime *runtime;
	struct snd_compr *device;
	struct delayed_work error_work;
	enum snd_compr_direction direction;
	bool metadata_set;
	bool next_track;
	bool partial_drain;
	bool pause_in_draining;
	void *private_data;
	struct snd_dma_buffer dma_buffer;
};

struct snd_compr_params;

struct snd_codec;

struct snd_compr_metadata;

struct snd_compr_tstamp;

struct snd_compr_caps;

struct snd_compr_codec_caps;

struct snd_compr_ops {
	int (*open)(struct snd_compr_stream *);
	int (*free)(struct snd_compr_stream *);
	int (*set_params)(struct snd_compr_stream *, struct snd_compr_params *);
	int (*get_params)(struct snd_compr_stream *, struct snd_codec *);
	int (*set_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*get_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*trigger)(struct snd_compr_stream *, int);
	int (*pointer)(struct snd_compr_stream *, struct snd_compr_tstamp *);
	int (*copy)(struct snd_compr_stream *, char __attribute__((btf_type_tag("user"))) *, size_t);
	int (*mmap)(struct snd_compr_stream *, struct vm_area_struct *);
	int (*ack)(struct snd_compr_stream *, size_t);
	int (*get_caps)(struct snd_compr_stream *, struct snd_compr_caps *);
	int (*get_codec_caps)(struct snd_compr_stream *, struct snd_compr_codec_caps *);
};

struct snd_compressed_buffer {
	__u32 fragment_size;
	__u32 fragments;
};

struct snd_enc_wma {
	__u32 super_block_align;
};

struct snd_enc_vorbis {
	__s32 quality;
	__u32 managed;
	__u32 max_bit_rate;
	__u32 min_bit_rate;
	__u32 downmix;
};

struct snd_enc_real {
	__u32 quant_bits;
	__u32 start_region;
	__u32 num_regions;
};

struct snd_enc_flac {
	__u32 num;
	__u32 gain;
};

struct snd_enc_generic {
	__u32 bw;
	__s32 reserved[15];
};

struct snd_dec_flac {
	__u16 sample_size;
	__u16 min_blk_size;
	__u16 max_blk_size;
	__u16 min_frame_size;
	__u16 max_frame_size;
	__u16 reserved;
};

struct snd_dec_wma {
	__u32 encoder_option;
	__u32 adv_encoder_option;
	__u32 adv_encoder_option2;
	__u32 reserved;
};

struct snd_dec_alac {
	__u32 frame_length;
	__u8 compatible_version;
	__u8 pb;
	__u8 mb;
	__u8 kb;
	__u32 max_run;
	__u32 max_frame_bytes;
};

struct snd_dec_ape {
	__u16 compatible_version;
	__u16 compression_level;
	__u32 format_flags;
	__u32 blocks_per_frame;
	__u32 final_frame_blocks;
	__u32 total_frames;
	__u32 seek_table_present;
};

union snd_codec_options {
	struct snd_enc_wma wma;
	struct snd_enc_vorbis vorbis;
	struct snd_enc_real real;
	struct snd_enc_flac flac;
	struct snd_enc_generic generic;
	struct snd_dec_flac flac_d;
	struct snd_dec_wma wma_d;
	struct snd_dec_alac alac_d;
	struct snd_dec_ape ape_d;
};

struct snd_codec {
	__u32 id;
	__u32 ch_in;
	__u32 ch_out;
	__u32 sample_rate;
	__u32 bit_rate;
	__u32 rate_control;
	__u32 profile;
	__u32 level;
	__u32 ch_mode;
	__u32 format;
	__u32 align;
	union snd_codec_options options;
	__u32 reserved[3];
};

struct snd_compr_params {
	struct snd_compressed_buffer buffer;
	struct snd_codec codec;
	__u8 no_wake_mode;
};

struct snd_compr_metadata {
	__u32 key;
	__u32 value[8];
};

struct snd_compr_tstamp {
	__u32 byte_offset;
	__u32 copied_total;
	__u32 pcm_frames;
	__u32 pcm_io_frames;
	__u32 sampling_rate;
};

struct snd_compr_caps {
	__u32 num_codecs;
	__u32 direction;
	__u32 min_fragment_size;
	__u32 max_fragment_size;
	__u32 min_fragments;
	__u32 max_fragments;
	__u32 codecs[32];
	__u32 reserved[11];
};

struct snd_codec_desc {
	__u32 max_ch;
	__u32 sample_rates[32];
	__u32 num_sample_rates;
	__u32 bit_rate[32];
	__u32 num_bitrates;
	__u32 rate_control;
	__u32 profiles;
	__u32 modes;
	__u32 formats;
	__u32 min_buffer;
	__u32 reserved[15];
};

struct snd_compr_codec_caps {
	__u32 codec;
	__u32 num_descriptors;
	struct snd_codec_desc descriptor[32];
};

struct snd_compr_runtime {
	snd_pcm_state_t state;
	struct snd_compr_ops *ops;
	void *buffer;
	u64 buffer_size;
	u32 fragment_size;
	u32 fragments;
	u64 total_bytes_available;
	u64 total_bytes_transferred;
	wait_queue_head_t sleep;
	void *private_data;
	unsigned char *dma_area;
	dma_addr_t dma_addr;
	size_t dma_bytes;
	struct snd_dma_buffer *dma_buffer_p;
};

struct snd_compr {
	const char *name;
	struct device *dev;
	struct snd_compr_ops *ops;
	void *private_data;
	struct snd_card *card;
	unsigned int direction;
	struct mutex lock;
	int device;
	bool use_pause_in_draining;
	char id[64];
	struct snd_info_entry *proc_root;
	struct snd_info_entry *proc_info_entry;
};

struct snd_soc_dai_stream {
	struct snd_soc_dapm_widget *widget;
	unsigned int active;
	unsigned int tdm_mask;
	void *dma_data;
};

struct snd_soc_dai_driver;

struct snd_soc_dai {
	const char *name;
	int id;
	struct device *dev;
	struct snd_soc_dai_driver *driver;
	struct snd_soc_dai_stream stream[2];
	unsigned int rate;
	unsigned int channels;
	unsigned int sample_bits;
	struct snd_soc_component *component;
	struct list_head list;
	struct snd_pcm_substream *mark_startup;
	struct snd_pcm_substream *mark_hw_params;
	struct snd_pcm_substream *mark_trigger;
	struct snd_compr_stream *mark_compr_startup;
	unsigned int probed: 1;
};

struct snd_soc_dai_ops;

struct snd_soc_cdai_ops;

struct snd_soc_dai_driver {
	const char *name;
	unsigned int id;
	unsigned int base;
	struct snd_soc_dobj dobj;
	struct of_phandle_args *dai_args;
	const struct snd_soc_dai_ops *ops;
	const struct snd_soc_cdai_ops *cops;
	struct snd_soc_pcm_stream capture;
	struct snd_soc_pcm_stream playback;
	unsigned int symmetric_rate: 1;
	unsigned int symmetric_channels: 1;
	unsigned int symmetric_sample_bits: 1;
};

struct snd_soc_dai_ops {
	int (*probe)(struct snd_soc_dai *);
	int (*remove)(struct snd_soc_dai *);
	int (*compress_new)(struct snd_soc_pcm_runtime *, int);
	int (*pcm_new)(struct snd_soc_pcm_runtime *, struct snd_soc_dai *);
	int (*set_sysclk)(struct snd_soc_dai *, int, unsigned int, int);
	int (*set_pll)(struct snd_soc_dai *, int, int, unsigned int, unsigned int);
	int (*set_clkdiv)(struct snd_soc_dai *, int, int);
	int (*set_bclk_ratio)(struct snd_soc_dai *, unsigned int);
	int (*set_fmt)(struct snd_soc_dai *, unsigned int);
	int (*xlate_tdm_slot_mask)(unsigned int, unsigned int *, unsigned int *);
	int (*set_tdm_slot)(struct snd_soc_dai *, unsigned int, unsigned int, int, int);
	int (*set_channel_map)(struct snd_soc_dai *, unsigned int, unsigned int *, unsigned int, unsigned int *);
	int (*get_channel_map)(struct snd_soc_dai *, unsigned int *, unsigned int *, unsigned int *, unsigned int *);
	int (*set_tristate)(struct snd_soc_dai *, int);
	int (*set_stream)(struct snd_soc_dai *, void *, int);
	void * (*get_stream)(struct snd_soc_dai *, int);
	int (*mute_stream)(struct snd_soc_dai *, int, int);
	int (*startup)(struct snd_pcm_substream *, struct snd_soc_dai *);
	void (*shutdown)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *, struct snd_soc_dai *);
	int (*hw_free)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*prepare)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*trigger)(struct snd_pcm_substream *, int, struct snd_soc_dai *);
	int (*bespoke_trigger)(struct snd_pcm_substream *, int, struct snd_soc_dai *);
	snd_pcm_sframes_t (*delay)(struct snd_pcm_substream *, struct snd_soc_dai *);
	u64 *auto_selectable_formats;
	int num_auto_selectable_formats;
	int probe_order;
	int remove_order;
	unsigned int no_capture_mute: 1;
	unsigned int mute_unmute_on_trigger: 1;
};

struct snd_soc_cdai_ops {
	int (*startup)(struct snd_compr_stream *, struct snd_soc_dai *);
	int (*shutdown)(struct snd_compr_stream *, struct snd_soc_dai *);
	int (*set_params)(struct snd_compr_stream *, struct snd_compr_params *, struct snd_soc_dai *);
	int (*get_params)(struct snd_compr_stream *, struct snd_codec *, struct snd_soc_dai *);
	int (*set_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *, struct snd_soc_dai *);
	int (*get_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *, struct snd_soc_dai *);
	int (*trigger)(struct snd_compr_stream *, int, struct snd_soc_dai *);
	int (*pointer)(struct snd_compr_stream *, struct snd_compr_tstamp *, struct snd_soc_dai *);
	int (*ack)(struct snd_compr_stream *, size_t, struct snd_soc_dai *);
};

struct snd_jack;

struct snd_soc_jack {
	struct mutex mutex;
	struct snd_jack *jack;
	struct snd_soc_card *card;
	struct list_head pins;
	int status;
	struct blocking_notifier_head notifier;
	struct list_head jack_zones;
};

struct snd_jack {
	struct list_head kctl_list;
	struct snd_card *card;
	const char *id;
	struct input_dev *input_dev;
	struct mutex input_dev_lock;
	int registered;
	int type;
	char name[100];
	unsigned int key[6];
	int hw_status_cache;
	void *private_data;
	void (*private_free)(struct snd_jack *);
};

struct snd_compress_ops {
	int (*open)(struct snd_soc_component *, struct snd_compr_stream *);
	int (*free)(struct snd_soc_component *, struct snd_compr_stream *);
	int (*set_params)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_params *);
	int (*get_params)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_codec *);
	int (*set_metadata)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*get_metadata)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*trigger)(struct snd_soc_component *, struct snd_compr_stream *, int);
	int (*pointer)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_tstamp *);
	int (*copy)(struct snd_soc_component *, struct snd_compr_stream *, char __attribute__((btf_type_tag("user"))) *, size_t);
	int (*mmap)(struct snd_soc_component *, struct snd_compr_stream *, struct vm_area_struct *);
	int (*ack)(struct snd_soc_component *, struct snd_compr_stream *, size_t);
	int (*get_caps)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_caps *);
	int (*get_codec_caps)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_codec_caps *);
};

struct snd_soc_codec_conf {
	struct snd_soc_dai_link_component dlc;
	const char *name_prefix;
};

struct snd_soc_aux_dev {
	struct snd_soc_dai_link_component dlc;
	int (*init)(struct snd_soc_component *);
};

struct snd_soc_dapm_update {
	struct snd_kcontrol *kcontrol;
	int reg;
	int mask;
	int val;
	int reg2;
	int mask2;
	int val2;
	bool has_second_set;
};

typedef void (*btf_trace_snd_soc_bias_level_done)(void *, struct snd_soc_card *, int);

typedef void (*btf_trace_snd_soc_dapm_start)(void *, struct snd_soc_card *);

typedef void (*btf_trace_snd_soc_dapm_done)(void *, struct snd_soc_card *);

typedef void (*btf_trace_snd_soc_dapm_widget_power)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_widget_event_start)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_widget_event_done)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_walk_done)(void *, struct snd_soc_card *);

enum snd_soc_dapm_direction {
	SND_SOC_DAPM_DIR_IN = 0,
	SND_SOC_DAPM_DIR_OUT = 1,
};

struct snd_soc_dapm_path;

typedef void (*btf_trace_snd_soc_dapm_path)(void *, struct snd_soc_dapm_widget *, enum snd_soc_dapm_direction, struct snd_soc_dapm_path *);

struct snd_soc_dapm_path {
	const char *name;
	union {
		struct {
			struct snd_soc_dapm_widget *source;
			struct snd_soc_dapm_widget *sink;
		};
		struct snd_soc_dapm_widget *node[2];
	};
	u32 connect: 1;
	u32 walking: 1;
	u32 weak: 1;
	u32 is_supply: 1;
	int (*connected)(struct snd_soc_dapm_widget *, struct snd_soc_dapm_widget *);
	struct list_head list_node[2];
	struct list_head list_kcontrol;
	struct list_head list;
};

typedef void (*btf_trace_snd_soc_dapm_connected)(void *, int, int);

typedef void (*btf_trace_snd_soc_jack_irq)(void *, const char *);

typedef void (*btf_trace_snd_soc_jack_report)(void *, struct snd_soc_jack *, int, int);

typedef void (*btf_trace_snd_soc_jack_notify)(void *, struct snd_soc_jack *, int);

enum {
	SNDRV_PCM_STREAM_PLAYBACK = 0,
	SNDRV_PCM_STREAM_CAPTURE = 1,
	SNDRV_PCM_STREAM_LAST = 1,
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

struct trace_event_raw_snd_soc_card {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_basic {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_widget {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_walk_done {
	struct trace_entry ent;
	u32 __data_loc_name;
	int power_checks;
	int path_checks;
	int neighbour_checks;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_path {
	struct trace_entry ent;
	u32 __data_loc_wname;
	u32 __data_loc_pname;
	u32 __data_loc_pnname;
	int path_node;
	int path_connect;
	int path_dir;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_connected {
	struct trace_entry ent;
	int paths;
	int stream;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_irq {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_report {
	struct trace_entry ent;
	u32 __data_loc_name;
	int mask;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_notify {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_snd_soc_card {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_basic {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_widget {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_walk_done {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_path {
	u32 wname;
	u32 pname;
	u32 pnname;
};

struct trace_event_data_offsets_snd_soc_jack_irq {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_jack_report {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_jack_notify {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_connected {};

struct bpf_mem_caches;

struct bpf_mem_cache;

struct bpf_mem_alloc {
	struct bpf_mem_caches __attribute__((btf_type_tag("percpu"))) *caches;
	struct bpf_mem_cache __attribute__((btf_type_tag("percpu"))) *cache;
	bool percpu;
	struct work_struct work;
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	struct bpf_mem_alloc selem_ma;
	struct bpf_mem_alloc storage_ma;
	bool bpf_ma;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_mem_cache {
	struct llist_head free_llist;
	local_t active;
	struct llist_head free_llist_extra;
	struct irq_work refill_work;
	struct obj_cgroup *objcg;
	int unit_size;
	int free_cnt;
	int low_watermark;
	int high_watermark;
	int batch;
	int percpu_size;
	bool draining;
	struct bpf_mem_cache *tgt;
	struct llist_head free_by_rcu;
	struct llist_node *free_by_rcu_tail;
	struct llist_head waiting_for_gp;
	struct llist_node *waiting_for_gp_tail;
	struct callback_head rcu;
	atomic_t call_rcu_in_progress;
	struct llist_head free_llist_extra_rcu;
	struct llist_head free_by_rcu_ttrace;
	struct llist_head waiting_for_gp_ttrace;
	struct callback_head rcu_ttrace;
	atomic_t call_rcu_ttrace_in_progress;
};

struct bpf_mem_caches {
	struct bpf_mem_cache cache[11];
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map __attribute__((btf_type_tag("rcu"))) *smap;
	u8 data[0];
};

struct bpf_id_pair {
	u32 old;
	u32 cur;
};

struct bpf_idmap {
	u32 tmp_id_gen;
	struct bpf_id_pair map[600];
};

struct bpf_idset {
	u32 count;
	u32 ids[600];
};

struct bpf_verifier_log {
	u64 start_pos;
	u64 end_pos;
	char __attribute__((btf_type_tag("user"))) *ubuf;
	u32 level;
	u32 len_total;
	u32 len_max;
	char kbuf[1024];
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	bool has_tail_call;
	bool tail_call_reachable;
	bool has_ld_abs;
	bool is_cb;
	bool is_async_cb;
	bool is_exception_cb;
};

struct backtrack_state {
	struct bpf_verifier_env *env;
	u32 frame;
	u32 reg_masks[8];
	u64 stack_masks[8];
};

typedef sockptr_t bpfptr_t;

struct bpf_verifier_ops;

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_insn_aux_data;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	struct btf_mod_pair used_btfs[64];
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 id_gen;
	u32 hidden_subprog_cnt;
	int exception_callback_subprog;
	bool explore_alu_limits;
	bool allow_ptr_leaks;
	bool allow_uninit_stack;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	bool seen_exception;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[258];
	union {
		struct bpf_idmap idmap_scratch;
		struct bpf_idset idset_scratch;
	};
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	struct backtrack_state bt;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
	bpfptr_t fd_array;
	u32 scratched_regs;
	u64 scratched_stack_slots;
	u64 prev_log_pos;
	u64 prev_insn_print_pos;
	char tmp_str_buf[320];
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

struct bpf_insn_access_aux;

struct bpf_reg_state;

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct bpf_reg_state *, int, int);
};

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	union {
		int ctx_field_size;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
	};
	struct bpf_verifier_log *log;
};

enum bpf_dynptr_type {
	BPF_DYNPTR_TYPE_INVALID = 0,
	BPF_DYNPTR_TYPE_LOCAL = 1,
	BPF_DYNPTR_TYPE_RINGBUF = 2,
	BPF_DYNPTR_TYPE_SKB = 3,
	BPF_DYNPTR_TYPE_XDP = 4,
};

enum bpf_iter_state {
	BPF_ITER_STATE_INVALID = 0,
	BPF_ITER_STATE_ACTIVE = 1,
	BPF_ITER_STATE_DRAINED = 2,
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	s32 off;
	union {
		int range;
		struct {
			struct bpf_map *map_ptr;
			u32 map_uid;
		};
		struct {
			struct btf *btf;
			u32 btf_id;
		};
		struct {
			u32 mem_size;
			u32 dynptr_id;
		};
		struct {
			enum bpf_dynptr_type type;
			bool first_slot;
		} dynptr;
		struct {
			struct btf *btf;
			u32 btf_id;
			enum bpf_iter_state state: 2;
			int depth: 30;
		} iter;
		struct {
			unsigned long raw1;
			unsigned long raw2;
		} raw;
		u32 subprogno;
	};
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	u32 id;
	u32 ref_obj_id;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
};

struct bpf_active_lock {
	void *ptr;
	u32 id;
};

struct bpf_idx_pair;

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	struct bpf_active_lock active_lock;
	bool speculative;
	bool active_rcu_lock;
	bool used_as_loop_entry;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_verifier_state *loop_entry;
	struct bpf_idx_pair *jmp_history;
	u32 jmp_history_cnt;
	u32 dfs_depth;
	u32 callback_unroll_depth;
};

struct bpf_reference_state;

struct bpf_stack_state;

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	u32 async_entry_cnt;
	bool in_callback_fn;
	struct tnum callback_ret_range;
	bool in_async_callback_fn;
	bool in_exception_callback_fn;
	u32 callback_depth;
	int acquired_refs;
	struct bpf_reference_state *refs;
	int allocated_stack;
	struct bpf_stack_state *stack;
};

struct bpf_reference_state {
	int id;
	int insn_idx;
	int callback_ref;
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_idx_pair {
	u32 prev_idx;
	u32 idx;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_loop_inline_state {
	unsigned int initialized: 1;
	unsigned int fit_for_inline: 1;
	u32 callback_subprogno;
};

struct btf_struct_meta;

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		unsigned long map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				struct {
					struct btf *btf;
					u32 btf_id;
				};
				u32 mem_size;
			};
		} btf_var;
		struct bpf_loop_inline_state loop_inline_state;
	};
	union {
		u64 obj_new_size;
		u64 insert_off;
	};
	struct btf_struct_meta *kptr_struct_meta;
	u64 map_key_state;
	int ctx_field_size;
	u32 seen;
	bool sanitize_stack_spill;
	bool zext_dst;
	bool storage_get_func_atomic;
	bool is_iter_next;
	bool call_with_percpu_alloc_ptr;
	u8 alu_state;
	unsigned int orig_idx;
	bool jmp_point;
	bool prune_point;
	bool force_checkpoint;
	bool calls_callback;
};

struct btf_struct_meta {
	u32 btf_id;
	struct btf_record *record;
};

struct nf_hook_state {
	u8 hook;
	u8 pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr __attribute__((btf_type_tag("rcu"))) *tun_src;
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *stream_parser;
	struct bpf_prog *stream_verdict;
	struct bpf_prog *skb_verdict;
};

struct strp_stats {
	unsigned long long msgs;
	unsigned long long bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
};

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

struct sk_psock_work_state {
	u32 len;
	u32 off;
};

struct sk_msg;

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	bool redir_ingress;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	struct strparser strp;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	spinlock_t ingress_lock;
	unsigned long state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_destroy)(struct sock *);
	void (*saved_close)(struct sock *, long);
	void (*saved_write_space)(struct sock *);
	void (*saved_data_ready)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	struct proto *sk_proto;
	struct mutex work_mutex;
	struct sk_psock_work_state work_state;
	struct delayed_work work;
	struct sock *sk_pair;
	struct rcu_work rwork;
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	unsigned long copy[1];
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	void *rw_image;
	u32 image_off;
	struct bpf_ksym ksym;
};

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
	int (*ipv6_setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*ipv6_getsockopt)(struct sock *, int, int, sockptr_t, sockptr_t);
	int (*ipv6_dev_get_saddr)(struct net *, const struct net_device *, const struct in6_addr *, unsigned int, struct in6_addr *);
};

struct bpf_scratchpad {
	union {
		__be32 diff[128];
		u8 buff[512];
	};
};

struct dst_cache_pcpu {
	unsigned long refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

enum {
	BPF_F_NEIGH = 2,
	BPF_F_PEER = 4,
	BPF_F_NEXTHOP = 8,
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_F_INGRESS = 1,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum {
	SKBFL_ZEROCOPY_ENABLE = 1,
	SKBFL_SHARED_FRAG = 2,
	SKBFL_PURE_ZEROCOPY = 4,
	SKBFL_DONT_ORPHAN = 8,
	SKBFL_MANAGED_FRAG_REFS = 16,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
	BPF_F_ADJ_ROOM_ENCAP_L2_ETH = 64,
	BPF_F_ADJ_ROOM_DECAP_L3_IPV4 = 128,
	BPF_F_ADJ_ROOM_DECAP_L3_IPV6 = 256,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

struct xsk_queue;

struct xdp_umem;

struct xdp_sock {
	struct sock sk;
	long: 64;
	long: 64;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	bool sg;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	long: 64;
	struct xsk_queue *tx;
	struct list_head tx_list;
	u32 tx_budget_spent;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct sk_buff *skb;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
};

struct xdp_umem {
	void *addrs;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
	struct work_struct work;
};

enum {
	BPF_F_INDEX_MASK = 4294967295ULL,
	BPF_F_CURRENT_CPU = 4294967295ULL,
	BPF_F_CTXLEN_MASK = 4503595332403200ULL,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_TUNINFO_FLAGS = 16,
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	LWTUNNEL_ENCAP_IOAM6 = 9,
	LWTUNNEL_ENCAP_XFRM = 10,
	__LWTUNNEL_ENCAP_MAX = 11,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
	BPF_F_NO_TUNNEL_KEY = 16,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
	BPF_FIB_LOOKUP_SKIP_NEIGH = 4,
	BPF_FIB_LOOKUP_TBID = 8,
	BPF_FIB_LOOKUP_SRC = 16,
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	IPV4_DEVCONF_ARP_EVICT_NOCARRIER = 33,
	__IPV4_DEVCONF_MAX = 34,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
	BPF_FIB_LKUP_RET_NO_SRC_ADDR = 9,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

enum bpf_check_mtu_ret {
	BPF_MTU_CHK_RET_SUCCESS = 0,
	BPF_MTU_CHK_RET_FRAG_NEEDED = 1,
	BPF_MTU_CHK_RET_SEGS_TOOBIG = 2,
};

enum bpf_check_mtu_flags {
	BPF_MTU_CHK_SEGS = 1,
};

enum bpf_lwt_encap_mode {
	BPF_LWT_ENCAP_SEG6 = 0,
	BPF_LWT_ENCAP_SEG6_INLINE = 1,
	BPF_LWT_ENCAP_IP = 2,
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	BPF_SKB_TSTAMP_UNSPEC = 0,
	BPF_SKB_TSTAMP_DELIVERY_MONO = 1,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

struct bpf_flow_dissector;

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

struct bpf_flow_keys;

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	const void *data;
	const void *data_end;
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

struct bpf_redir_neigh;

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid_curr)();

typedef u64 (*btf_bpf_skb_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_xdp_get_buff_len)(struct xdp_buff *);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_load_bytes)(struct xdp_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_xdp_store_bytes)(struct xdp_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

struct bpf_tunnel_key;

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	union {
		__u16 tunnel_ext;
		__be16 tunnel_flags;
	};
	__u32 tunnel_label;
	union {
		__u32 local_ipv4;
		__u32 local_ipv6[4];
	};
};

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);

typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

struct bpf_sock_addr_kern;

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
	u32 uaddrlen;
};

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_ptr_cookie)(struct sock *);

struct bpf_sock_ops_kern;

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	u64 temp;
};

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sk_msg)(struct sk_msg *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_unlocked_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_unlocked_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

struct bpf_fib_lookup;

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	union {
		__u16 tot_len;
		__u16 mtu_result;
	};
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	union {
		struct {
			__be16 h_vlan_proto;
			__be16 h_vlan_TCI;
		};
		__u32 tbid;
	};
	__u8 smac[6];
	__u8 dmac[6];
};

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_check_mtu)(struct sk_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_xdp_check_mtu)(struct xdp_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

struct bpf_sock_tuple;

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tstamp)(struct sk_buff *, u64, u32);

struct sk_reuseport_kern;

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	struct sock *migrating_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

struct bpf_sk_lookup_kern;

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	u32 ingress_ifindex;
	bool no_reuseport;
};

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_unix_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_mptcp_sock)(struct sock *);

typedef u64 (*btf_bpf_sock_from_file)(struct file *);

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

struct strp_msg {
	int full_len;
	int offset;
};

struct tls_strparser {
	struct sock *sk;
	u32 mark: 8;
	u32 stopped: 1;
	u32 copy_mode: 1;
	u32 mixed_decrypted: 1;
	u32 msg_ready: 1;
	struct strp_msg stm;
	struct sk_buff *anchor;
	struct work_struct work;
};

struct crypto_aead;

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	u8 reader_present;
	u8 async_capable: 1;
	u8 zc_capable: 1;
	u8 reader_contended: 1;
	struct tls_strparser strp;
	atomic_t decrypt_pending;
	spinlock_t decrypt_compl_lock;
	struct sk_buff_head async_hold;
	struct wait_queue_head wq;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	unsigned long *tb_data;
	unsigned long __data[0];
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct mptcp_sock {};

typedef unsigned int (*bpf_func_t)(const void *, const struct bpf_insn *);

struct sock_fprog {
	unsigned short len;
	struct sock_filter __attribute__((btf_type_tag("user"))) *filter;
};

struct cgroup_cls_state {
	struct cgroup_subsys_state css;
	u32 classid;
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

struct cipher_context {
	char iv[20];
	char rec_seq[8];
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_chacha20_poly1305 {
	struct tls_crypto_info info;
	unsigned char iv[12];
	unsigned char key[32];
	unsigned char salt[0];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_sm4_gcm {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_sm4_ccm {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
		struct tls12_crypto_info_chacha20_poly1305 chacha20_poly1305;
		struct tls12_crypto_info_sm4_gcm sm4_gcm;
		struct tls12_crypto_info_sm4_ccm sm4_ccm;
	};
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	u8 zerocopy_sendfile: 1;
	u8 rx_no_pad: 1;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device __attribute__((btf_type_tag("rcu"))) *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool splicing_pages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	unsigned long flags;
	struct proto *sk_proto;
	struct sock *sk;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

typedef unsigned long (*bpf_ctx_copy_t)(void *, const void *, unsigned long, unsigned long);

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct bpf_dynptr_kern {
	void *data;
	u32 size;
	u32 offset;
};

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	unsigned short overhead;
	short cell_align;
	unsigned short mpu;
	__u32 rate;
};

struct qdisc_rate_table {
	struct tc_ratespec rate;
	u32 data[256];
	struct qdisc_rate_table *next;
	int refcnt;
};

enum tc_link_layer {
	TC_LINKLAYER_UNAWARE = 0,
	TC_LINKLAYER_ETHERNET = 1,
	TC_LINKLAYER_ATM = 2,
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
	__QDISC_STATE_MISSED = 2,
	__QDISC_STATE_DRAINING = 3,
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_GETMULTICAST = 58,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_SETSTATS = 95,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	RTM_NEWNEXTHOPBUCKET = 116,
	RTM_DELNEXTHOPBUCKET = 117,
	RTM_GETNEXTHOPBUCKET = 118,
	RTM_NEWTUNNEL = 120,
	RTM_DELTUNNEL = 121,
	RTM_GETTUNNEL = 122,
	__RTM_MAX = 123,
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	TCA_EXT_WARN_MSG = 16,
	__TCA_MAX = 17,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

enum {
	TCA_STAB_UNSPEC = 0,
	TCA_STAB_BASE = 1,
	TCA_STAB_DATA = 2,
	__TCA_STAB_MAX = 3,
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	RTNLGRP_MCTP_IFADDR = 34,
	RTNLGRP_TUNNEL = 35,
	RTNLGRP_STATS = 36,
	__RTNLGRP_MAX = 37,
};

enum tc_root_command {
	TC_ROOT_GRAFT = 0,
};

struct Qdisc_class_common {
	u32 classid;
	unsigned int filter_cnt;
	struct hlist_node hnode;
};

struct qdisc_watchdog {
	struct hrtimer timer;
	struct Qdisc *qdisc;
};

struct check_loop_arg {
	struct qdisc_walker w;
	struct Qdisc *p;
	int depth;
};

struct tc_bind_class_args {
	struct qdisc_walker w;
	unsigned long new_cl;
	u32 portid;
	u32 clid;
};

struct qdisc_dump_args {
	struct qdisc_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

struct tc_root_qopt_offload {
	enum tc_root_command command;
	u32 handle;
	bool ingress;
};

struct Qdisc_class_hash {
	struct hlist_head *hash;
	unsigned int hashsize;
	unsigned int hashmask;
	unsigned int hashelems;
};

struct tc_query_caps_base {
	enum tc_setup_type type;
	void *caps;
};

struct tcf_bind_args {
	struct tcf_walker w;
	unsigned long base;
	unsigned long cl;
	u32 classid;
};

enum {
	ETHTOOL_STATS_ETH_PHY = 0,
	ETHTOOL_STATS_ETH_MAC = 1,
	ETHTOOL_STATS_ETH_CTRL = 2,
	ETHTOOL_STATS_RMON = 3,
	__ETHTOOL_STATS_CNT = 4,
};

enum {
	ETHTOOL_A_STATS_UNSPEC = 0,
	ETHTOOL_A_STATS_PAD = 1,
	ETHTOOL_A_STATS_HEADER = 2,
	ETHTOOL_A_STATS_GROUPS = 3,
	ETHTOOL_A_STATS_GRP = 4,
	ETHTOOL_A_STATS_SRC = 5,
	__ETHTOOL_A_STATS_CNT = 6,
	ETHTOOL_A_STATS_MAX = 5,
};

enum {
	ETHTOOL_A_STATS_GRP_UNSPEC = 0,
	ETHTOOL_A_STATS_GRP_PAD = 1,
	ETHTOOL_A_STATS_GRP_ID = 2,
	ETHTOOL_A_STATS_GRP_SS_ID = 3,
	ETHTOOL_A_STATS_GRP_STAT = 4,
	ETHTOOL_A_STATS_GRP_HIST_RX = 5,
	ETHTOOL_A_STATS_GRP_HIST_TX = 6,
	ETHTOOL_A_STATS_GRP_HIST_BKT_LOW = 7,
	ETHTOOL_A_STATS_GRP_HIST_BKT_HI = 8,
	ETHTOOL_A_STATS_GRP_HIST_VAL = 9,
	__ETHTOOL_A_STATS_GRP_CNT = 10,
	ETHTOOL_A_STATS_GRP_MAX = 9,
};

enum {
	ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR = 0,
	__ETHTOOL_A_STATS_ETH_PHY_CNT = 1,
	ETHTOOL_A_STATS_ETH_PHY_MAX = 0,
};

enum {
	ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT = 0,
	ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL = 1,
	ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL = 2,
	ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT = 3,
	ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR = 4,
	ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR = 5,
	ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES = 6,
	ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER = 7,
	ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL = 8,
	ETHTOOL_A_STATS_ETH_MAC_11_XS_COL = 9,
	ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR = 10,
	ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR = 11,
	ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES = 12,
	ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR = 13,
	ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST = 14,
	ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST = 15,
	ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER = 16,
	ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST = 17,
	ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST = 18,
	ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR = 19,
	ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN = 20,
	ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR = 21,
	__ETHTOOL_A_STATS_ETH_MAC_CNT = 22,
	ETHTOOL_A_STATS_ETH_MAC_MAX = 21,
};

enum {
	ETHTOOL_A_STATS_ETH_CTRL_3_TX = 0,
	ETHTOOL_A_STATS_ETH_CTRL_4_RX = 1,
	ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP = 2,
	__ETHTOOL_A_STATS_ETH_CTRL_CNT = 3,
	ETHTOOL_A_STATS_ETH_CTRL_MAX = 2,
};

enum {
	ETHTOOL_A_STATS_RMON_UNDERSIZE = 0,
	ETHTOOL_A_STATS_RMON_OVERSIZE = 1,
	ETHTOOL_A_STATS_RMON_FRAG = 2,
	ETHTOOL_A_STATS_RMON_JABBER = 3,
	__ETHTOOL_A_STATS_RMON_CNT = 4,
	ETHTOOL_A_STATS_RMON_MAX = 3,
};

struct stats_req_info {
	struct ethnl_req_info base;
	unsigned long stat_mask[1];
	enum ethtool_mac_stats_src src;
};

struct stats_reply_data {
	struct ethnl_reply_data base;
	union {
		struct {
			struct ethtool_eth_phy_stats phy_stats;
			struct ethtool_eth_mac_stats mac_stats;
			struct ethtool_eth_ctrl_stats ctrl_stats;
			struct ethtool_rmon_stats rmon_stats;
		};
		struct {
			struct ethtool_eth_phy_stats phy_stats;
			struct ethtool_eth_mac_stats mac_stats;
			struct ethtool_eth_ctrl_stats ctrl_stats;
			struct ethtool_rmon_stats rmon_stats;
		} stats;
	};
	const struct ethtool_rmon_hist_range *rmon_ranges;
};

typedef const char (* const ethnl_string_array_t)[32];

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		__u32 tcp_tw_isn;
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	union {
		struct {
			__u32 is_app_limited: 1;
			__u32 delivered_ce: 20;
			__u32 unused: 11;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
	};
};

struct pipe_buffer;

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	unsigned int head;
	unsigned int tail;
	unsigned int max_usage;
	unsigned int ring_size;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	bool poll_usage;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

struct pipe_buf_operations;

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	unsigned long private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

struct scm_stat {
	atomic_t nr_fds;
};

struct unix_address;

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct list_head link;
	atomic_long_t inflight;
	spinlock_t lock;
	unsigned long gc_flags;
	long: 64;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	struct sk_buff *oob_skb;
	long: 64;
};

struct unix_address {
	refcount_t refcnt;
	int len;
	struct sockaddr_un name[0];
};

struct scm_fp_list;

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 consumed;
};

struct scm_fp_list {
	short count;
	short max;
	struct user_struct *user;
	struct file *fp[253];
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
	long: 64;
	long: 64;
	long: 64;
};

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct bpf_iter__unix {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct unix_sock *unix_sk;
	};
	uid_t uid;
};

struct bpf_unix_iter_state {
	struct seq_net_private p;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

enum rpc_msg_type {
	RPC_CALL = 0,
	RPC_REPLY = 1,
};

enum {
	TLS_RECORD_TYPE_CHANGE_CIPHER_SPEC = 20,
	TLS_RECORD_TYPE_ALERT = 21,
	TLS_RECORD_TYPE_HANDSHAKE = 22,
	TLS_RECORD_TYPE_DATA = 23,
	TLS_RECORD_TYPE_HEARTBEAT = 24,
	TLS_RECORD_TYPE_TLS12_CID = 25,
	TLS_RECORD_TYPE_ACK = 26,
};

enum {
	TLS_ALERT_LEVEL_WARNING = 1,
	TLS_ALERT_LEVEL_FATAL = 2,
};

enum {
	XPT_BUSY = 0,
	XPT_CONN = 1,
	XPT_CLOSE = 2,
	XPT_DATA = 3,
	XPT_TEMP = 4,
	XPT_DEAD = 5,
	XPT_CHNGBUF = 6,
	XPT_DEFERRED = 7,
	XPT_OLD = 8,
	XPT_LISTENER = 9,
	XPT_CACHE_AUTH = 10,
	XPT_LOCAL = 11,
	XPT_KILL_TEMP = 12,
	XPT_CONG_CTRL = 13,
	XPT_HANDSHAKE = 14,
	XPT_TLS_SESSION = 15,
	XPT_PEER_AUTH = 16,
};

struct sock_xprt {
	struct rpc_xprt xprt;
	struct socket *sock;
	struct sock *inet;
	struct file *file;
	struct {
		struct {
			__be32 fraghdr;
			__be32 xid;
			__be32 calldir;
		};
		u32 offset;
		u32 len;
		unsigned long copied;
	} recv;
	struct {
		u32 offset;
	} xmit;
	unsigned long sock_state;
	struct delayed_work connect_worker;
	struct work_struct error_worker;
	struct work_struct recv_worker;
	struct mutex recv_mutex;
	struct completion handshake_done;
	struct __kernel_sockaddr_storage srcaddr;
	unsigned short srcport;
	int xprt_err;
	struct rpc_clnt *clnt;
	size_t rcvsize;
	size_t sndsize;
	struct rpc_timeout tcp_timeout;
	void (*old_data_ready)(struct sock *);
	void (*old_state_change)(struct sock *);
	void (*old_write_space)(struct sock *);
	void (*old_error_report)(struct sock *);
};

struct page_frag_cache {
	void *va;
	__u16 offset;
	__u16 size;
	unsigned int pagecnt_bias;
	bool pfmemalloc;
};

struct svc_sock {
	struct svc_xprt sk_xprt;
	struct socket *sk_sock;
	struct sock *sk_sk;
	void (*sk_ostate)(struct sock *);
	void (*sk_odata)(struct sock *);
	void (*sk_owspace)(struct sock *);
	__be32 sk_marker;
	u32 sk_tcplen;
	u32 sk_datalen;
	struct page_frag_cache sk_frag_cache;
	struct completion sk_handshake_done;
	struct page *sk_pages[259];
};

struct rpc_buffer {
	size_t len;
	char data[0];
};

typedef __be32 rpc_fraghdr;

typedef void (*tls_done_func_t)(void *, int, key_serial_t);

struct tls_handshake_args {
	struct socket *ta_sock;
	tls_done_func_t ta_done;
	void *ta_data;
	const char *ta_peername;
	unsigned int ta_timeout_ms;
	key_serial_t ta_keyring;
	key_serial_t ta_my_cert;
	key_serial_t ta_my_privkey;
	unsigned int ta_num_peerids;
	key_serial_t ta_my_peerids[5];
};

struct rpc_create_args {
	struct net *net;
	int protocol;
	struct sockaddr *address;
	size_t addrsize;
	struct sockaddr *saddress;
	const struct rpc_timeout *timeout;
	const char *servername;
	const char *nodename;
	const struct rpc_program *program;
	u32 prognumber;
	u32 version;
	rpc_authflavor_t authflavor;
	u32 nconnect;
	unsigned long flags;
	char *client_name;
	struct svc_xprt *bc_xprt;
	const struct cred *cred;
	unsigned int max_connect;
	struct xprtsec_parms xprtsec;
	unsigned long connect_timeout;
	unsigned long reconnect_timeout;
};

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct efi_smbios_record {
	u8 type;
	u8 length;
	u16 handle;
};

struct efi_smbios_type4_record {
	struct efi_smbios_record header;
	u8 socket;
	u8 processor_type;
	u8 processor_family;
	u8 processor_manufacturer;
	u8 processor_id[8];
	u8 processor_version;
	u8 voltage;
	u16 external_clock;
	u16 max_speed;
	u16 current_speed;
	u8 status;
	u8 processor_upgrade;
	u16 l1_cache_handle;
	u16 l2_cache_handle;
	u16 l3_cache_handle;
	u8 serial_number;
	u8 asset_tag;
	u8 part_number;
	u8 core_count;
	u8 enabled_core_count;
	u8 thread_count;
	u16 processor_characteristics;
	u16 processor_family2;
	u16 core_count2;
	u16 enabled_core_count2;
	u16 thread_count2;
	u16 thread_enabled;
};

enum efi_cmdline_option {
	EFI_CMDLINE_NONE = 0,
	EFI_CMDLINE_MODE_NUM = 1,
	EFI_CMDLINE_RES = 2,
	EFI_CMDLINE_AUTO = 3,
	EFI_CMDLINE_LIST = 4,
};

typedef struct {
	u32 red_mask;
	u32 green_mask;
	u32 blue_mask;
	u32 reserved_mask;
} efi_pixel_bitmask_t;

typedef struct {
	u32 version;
	u32 horizontal_resolution;
	u32 vertical_resolution;
	int pixel_format;
	efi_pixel_bitmask_t pixel_information;
	u32 pixels_per_scan_line;
} efi_graphics_output_mode_info_t;

union efi_graphics_output_protocol;

typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;

union efi_graphics_output_protocol_mode;

typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;

union efi_graphics_output_protocol {
	struct {
		efi_status_t (*query_mode)(efi_graphics_output_protocol_t *, u32, unsigned long *, efi_graphics_output_mode_info_t **);
		efi_status_t (*set_mode)(efi_graphics_output_protocol_t *, u32);
		void *blt;
		efi_graphics_output_protocol_mode_t *mode;
	};
	struct {
		u32 query_mode;
		u32 set_mode;
		u32 blt;
		u32 mode;
	} mixed_mode;
};

union efi_graphics_output_protocol_mode {
	struct {
		u32 max_mode;
		u32 mode;
		efi_graphics_output_mode_info_t *info;
		unsigned long size_of_info;
		efi_physical_addr_t frame_buffer_base;
		unsigned long frame_buffer_size;
	};
	struct {
		u32 max_mode;
		u32 mode;
		u32 info;
		u32 size_of_info;
		u64 frame_buffer_base;
		u32 frame_buffer_size;
	} mixed_mode;
};

struct break_hook {
	struct list_head node;
	int (*fn)(struct pt_regs *, unsigned long);
	u16 imm;
	u16 mask;
};

struct step_hook {
	struct list_head node;
	int (*fn)(struct pt_regs *, unsigned long);
};

enum probe_insn {
	INSN_REJECTED = 0,
	INSN_GOOD_NO_SLOT = 1,
	INSN_GOOD = 2,
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

typedef u32 probe_opcode_t;

typedef bool pstate_check_t(unsigned long);

typedef void probes_handler_t(u32, long, struct pt_regs *);

struct arch_probe_insn {
	probe_opcode_t *insn;
	pstate_check_t *pstate_cc;
	probes_handler_t *handler;
	unsigned long restore;
};

struct arch_uprobe {
	union {
		u8 insn[4];
		u8 ixol[4];
	};
	struct arch_probe_insn api;
	bool simulate;
};

enum {
	kvm_ioeventfd_flag_nr_datamatch = 0,
	kvm_ioeventfd_flag_nr_pio = 1,
	kvm_ioeventfd_flag_nr_deassign = 2,
	kvm_ioeventfd_flag_nr_virtio_ccw_notify = 3,
	kvm_ioeventfd_flag_nr_fast_mmio = 4,
	kvm_ioeventfd_flag_nr_max = 5,
};

struct kvm_irq_ack_notifier {
	struct hlist_node link;
	unsigned int gsi;
	void (*irq_acked)(struct kvm_irq_ack_notifier *);
};

struct irq_bypass_producer;

struct irq_bypass_consumer {
	struct list_head node;
	void *token;
	int (*add_producer)(struct irq_bypass_consumer *, struct irq_bypass_producer *);
	void (*del_producer)(struct irq_bypass_consumer *, struct irq_bypass_producer *);
	void (*stop)(struct irq_bypass_consumer *);
	void (*start)(struct irq_bypass_consumer *);
};

struct kvm_kernel_irqfd_resampler;

struct kvm_kernel_irqfd {
	struct kvm *kvm;
	wait_queue_entry_t wait;
	struct kvm_kernel_irq_routing_entry irq_entry;
	seqcount_spinlock_t irq_entry_sc;
	int gsi;
	struct work_struct inject;
	struct kvm_kernel_irqfd_resampler *resampler;
	struct eventfd_ctx *resamplefd;
	struct list_head resampler_link;
	struct eventfd_ctx *eventfd;
	struct list_head list;
	poll_table pt;
	struct work_struct shutdown;
	struct irq_bypass_consumer consumer;
	struct irq_bypass_producer *producer;
};

struct kvm_kernel_irqfd_resampler {
	struct kvm *kvm;
	struct list_head list;
	struct kvm_irq_ack_notifier notifier;
	struct list_head link;
};

struct irq_bypass_producer {
	struct list_head node;
	void *token;
	int irq;
	int (*add_consumer)(struct irq_bypass_producer *, struct irq_bypass_consumer *);
	void (*del_consumer)(struct irq_bypass_producer *, struct irq_bypass_consumer *);
	void (*stop)(struct irq_bypass_producer *);
	void (*start)(struct irq_bypass_producer *);
};

struct _ioeventfd {
	struct list_head list;
	u64 addr;
	int length;
	struct eventfd_ctx *eventfd;
	u64 datamatch;
	struct kvm_io_device dev;
	u8 bus_idx;
	bool wildcard;
};

struct kvm_irqfd {
	__u32 fd;
	__u32 gsi;
	__u32 flags;
	__u32 resamplefd;
	__u8 pad[16];
};

struct kvm_ioeventfd {
	__u64 datamatch;
	__u64 addr;
	__u32 len;
	__s32 fd;
	__u32 flags;
	__u8 pad[36];
};

enum __kvm_host_smccc_func {
	__KVM_HOST_SMCCC_FUNC___kvm_get_mdcr_el2 = 1,
	__KVM_HOST_SMCCC_FUNC___pkvm_init = 2,
	__KVM_HOST_SMCCC_FUNC___pkvm_create_private_mapping = 3,
	__KVM_HOST_SMCCC_FUNC___pkvm_cpu_set_vector = 4,
	__KVM_HOST_SMCCC_FUNC___kvm_enable_ssbs = 5,
	__KVM_HOST_SMCCC_FUNC___vgic_v3_init_lrs = 6,
	__KVM_HOST_SMCCC_FUNC___vgic_v3_get_gic_config = 7,
	__KVM_HOST_SMCCC_FUNC___pkvm_prot_finalize = 8,
	__KVM_HOST_SMCCC_FUNC___pkvm_host_share_hyp = 9,
	__KVM_HOST_SMCCC_FUNC___pkvm_host_unshare_hyp = 10,
	__KVM_HOST_SMCCC_FUNC___kvm_adjust_pc = 11,
	__KVM_HOST_SMCCC_FUNC___kvm_vcpu_run = 12,
	__KVM_HOST_SMCCC_FUNC___kvm_flush_vm_context = 13,
	__KVM_HOST_SMCCC_FUNC___kvm_tlb_flush_vmid_ipa = 14,
	__KVM_HOST_SMCCC_FUNC___kvm_tlb_flush_vmid_ipa_nsh = 15,
	__KVM_HOST_SMCCC_FUNC___kvm_tlb_flush_vmid = 16,
	__KVM_HOST_SMCCC_FUNC___kvm_tlb_flush_vmid_range = 17,
	__KVM_HOST_SMCCC_FUNC___kvm_flush_cpu_context = 18,
	__KVM_HOST_SMCCC_FUNC___kvm_timer_set_cntvoff = 19,
	__KVM_HOST_SMCCC_FUNC___vgic_v3_read_vmcr = 20,
	__KVM_HOST_SMCCC_FUNC___vgic_v3_write_vmcr = 21,
	__KVM_HOST_SMCCC_FUNC___vgic_v3_save_aprs = 22,
	__KVM_HOST_SMCCC_FUNC___vgic_v3_restore_aprs = 23,
	__KVM_HOST_SMCCC_FUNC___pkvm_vcpu_init_traps = 24,
	__KVM_HOST_SMCCC_FUNC___pkvm_init_vm = 25,
	__KVM_HOST_SMCCC_FUNC___pkvm_init_vcpu = 26,
	__KVM_HOST_SMCCC_FUNC___pkvm_teardown_vm = 27,
};

struct sys_reg_params;

struct sys_reg_desc {
	const char *name;
	enum {
		AA32_DIRECT = 0,
		AA32_LO = 1,
		AA32_HI = 2,
	} aarch32_map;
	u8 Op0;
	u8 Op1;
	u8 CRn;
	u8 CRm;
	u8 Op2;
	bool (*access)(struct kvm_vcpu *, struct sys_reg_params *, const struct sys_reg_desc *);
	u64 (*reset)(struct kvm_vcpu *, const struct sys_reg_desc *);
	int reg;
	u64 val;
	int (*__get_user)(struct kvm_vcpu *, const struct sys_reg_desc *, u64 *);
	int (*set_user)(struct kvm_vcpu *, const struct sys_reg_desc *, u64);
	unsigned int (*visibility)(const struct kvm_vcpu *, const struct sys_reg_desc *);
};

struct sys_reg_params {
	u8 Op0;
	u8 Op1;
	u8 CRn;
	u8 CRm;
	u8 Op2;
	u64 regval;
	bool is_write;
};

struct kvm_nvhe_stacktrace_info {
	unsigned long stack_base;
	unsigned long overflow_stack_base;
	unsigned long fp;
	unsigned long pc;
};

struct kvm_ffa_descriptor_buffer {
	void *buf;
	size_t len;
};

struct kvm_ffa_buffers {
	hyp_spinlock_t lock;
	void *tx;
	void *rx;
};

struct ffa_mem_region_attributes {
	u16 receiver;
	u8 attrs;
	u8 flag;
	u32 composite_off;
	u64 reserved;
};

struct ffa_mem_region_addr_range {
	u64 address;
	u32 pg_cnt;
	u32 reserved;
};

struct ffa_composite_mem_region {
	u32 total_pg_cnt;
	u32 addr_range_cnt;
	u64 reserved;
	struct ffa_mem_region_addr_range constituents[0];
};

struct ffa_mem_region {
	u16 sender_id;
	u16 attributes;
	u32 flags;
	u64 handle;
	u64 tag;
	u32 ep_mem_size;
	u32 ep_count;
	u32 ep_mem_offset;
	u32 reserved[3];
};

struct __user_cap_header_struct;

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

struct __user_cap_data_struct;

typedef struct __user_cap_data_struct __attribute__((btf_type_tag("user"))) *cap_user_data_t;

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

struct user_regset;

struct membuf;

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void __attribute__((btf_type_tag("user"))) *);

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct membuf {
	void *p;
	size_t left;
};

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_kthread_work_queue_work)(void *, struct kthread_worker *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_start)(void *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_end)(void *, struct kthread_work *, kthread_work_func_t);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *, unsigned int);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64, u64);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_skip_vma_numa)(void *, struct mm_struct *, struct vm_area_struct *, enum numa_vmaskip_reason);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

typedef void (*btf_trace_pelt_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_pelt_rt_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_dl_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_thermal_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_irq_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_cpu_capacity_tp)(void *, struct rq *);

typedef void (*btf_trace_sched_overutilized_tp)(void *, struct root_domain *, bool);

typedef void (*btf_trace_sched_util_est_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_sched_util_est_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_update_nr_running_tp)(void *, struct rq *, int);

typedef void (*btf_trace_sched_compute_energy_tp)(void *, struct task_struct *, int, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_ipi_raise)(void *, const struct cpumask *, const char *);

typedef void (*btf_trace_ipi_send_cpu)(void *, const unsigned int, unsigned long, void *);

typedef void (*btf_trace_ipi_send_cpumask)(void *, const struct cpumask *, unsigned long, void *);

typedef void (*btf_trace_ipi_entry)(void *, const char *);

typedef void (*btf_trace_ipi_exit)(void *, const char *);

enum ctx_state {
	CONTEXT_DISABLED = -1,
	CONTEXT_KERNEL = 0,
	CONTEXT_IDLE = 1,
	CONTEXT_USER = 2,
	CONTEXT_GUEST = 3,
	CONTEXT_MAX = 4,
};

enum rseq_event_mask_bits {
	RSEQ_EVENT_PREEMPT_BIT = 0,
	RSEQ_EVENT_SIGNAL_BIT = 1,
	RSEQ_EVENT_MIGRATE_BIT = 2,
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_CGROUP_SWITCHES = 11,
	PERF_COUNT_SW_MAX = 12,
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

enum mm_cid_state {
	MM_CID_UNSET = 4294967295,
	MM_CID_LAZY_PUT = 2147483648,
};

union cpumask_rcuhead {
	cpumask_t cpumask;
	struct callback_head rcu;
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *worker;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 runtime;
	u64 vruntime;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_skip_vma_numa {
	struct trace_entry ent;
	unsigned long numa_scan_offset;
	unsigned long vm_start;
	unsigned long vm_end;
	enum numa_vmaskip_reason reason;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_raw_ipi_raise {
	struct trace_entry ent;
	u32 __data_loc_target_cpus;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_send_cpu {
	struct trace_entry ent;
	unsigned int cpu;
	void *callsite;
	void *callback;
	char __data[0];
};

struct trace_event_raw_ipi_send_cpumask {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	void *callsite;
	void *callback;
	char __data[0];
};

struct trace_event_raw_ipi_handler {
	struct trace_entry ent;
	const char *reason;
	char __data[0];
};

struct irqtime {
	u64 total;
	u64 tick_delta;
	u64 irq_start_time;
	struct u64_stats_sync sync;
};

struct sched_param {
	int sched_priority;
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
};

struct trace_event_data_offsets_ipi_raise {
	u32 target_cpus;
};

struct trace_event_data_offsets_ipi_send_cpumask {
	u32 cpumask;
};

typedef struct {
	void *lock;
} class_rcu_t;

typedef struct {
	raw_spinlock_t *lock;
} class_raw_spinlock_irq_t;

typedef struct {
	void *lock;
} class_preempt_t;

typedef struct {
	raw_spinlock_t *lock;
	raw_spinlock_t *lock2;
} class_double_raw_spinlock_t;

typedef struct {
	struct rq *lock;
	struct rq *lock2;
} class_double_rq_lock_t;

typedef struct {
	struct rq *lock;
	struct rq_flags rf;
} class_rq_lock_irqsave_t;

typedef struct {
	raw_spinlock_t *lock;
	unsigned long flags;
} class_raw_spinlock_irqsave_t;

typedef struct {
	struct task_struct *lock;
	struct rq *rq;
	struct rq_flags rf;
} class_task_rq_lock_t;

typedef struct task_struct *class_find_get_task_t;

typedef struct {
	void *lock;
	unsigned long flags;
} class_irqsave_t;

struct sched_domain_attr {
	int relax_domain_level;
};

struct rt_bandwidth {
	raw_spinlock_t rt_runtime_lock;
	ktime_t rt_period;
	u64 rt_runtime;
	struct hrtimer rt_period_timer;
	unsigned int rt_period_active;
};

struct set_affinity_pending;

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
	struct set_affinity_pending *pending;
};

struct set_affinity_pending {
	refcount_t refs;
	unsigned int stop_pending;
	struct completion done;
	struct cpu_stop_work stop_work;
	struct migration_arg arg;
};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_kthread_work_queue_work {};

struct trace_event_data_offsets_sched_kthread_work_execute_start {};

struct trace_event_data_offsets_sched_kthread_work_execute_end {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_skip_vma_numa {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

struct trace_event_data_offsets_ipi_send_cpu {};

struct trace_event_data_offsets_ipi_handler {};

typedef int (*tg_visitor)(struct task_group *, void *);

struct migration_swap_arg {
	struct task_struct *src_task;
	struct task_struct *dst_task;
	int src_cpu;
	int dst_cpu;
};

typedef int (*task_call_f)(struct task_struct *, void *);

struct kernel_clone_args {
	u64 flags;
	int __attribute__((btf_type_tag("user"))) *pidfd;
	int __attribute__((btf_type_tag("user"))) *child_tid;
	int __attribute__((btf_type_tag("user"))) *parent_tid;
	const char *name;
	int exit_signal;
	u32 kthread: 1;
	u32 io_thread: 1;
	u32 user_worker: 1;
	u32 no_files: 1;
	unsigned long stack;
	unsigned long stack_size;
	unsigned long tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	int idle;
	int (*fn)(void *);
	void *fn_arg;
	struct cgroup *cgrp;
	struct css_set *cset;
};

struct fmeter {
	int cnt;
	int val;
	time64_t time;
	spinlock_t lock;
};

enum prs_errcode {
	PERR_NONE = 0,
	PERR_INVCPUS = 1,
	PERR_INVPARENT = 2,
	PERR_NOTPART = 3,
	PERR_NOTEXCL = 4,
	PERR_NOCPUS = 5,
	PERR_HOTPLUG = 6,
	PERR_CPUSEMPTY = 7,
	PERR_HKEEPING = 8,
};

struct cpuset {
	struct cgroup_subsys_state css;
	unsigned long flags;
	cpumask_var_t cpus_allowed;
	nodemask_t mems_allowed;
	cpumask_var_t effective_cpus;
	nodemask_t effective_mems;
	cpumask_var_t effective_xcpus;
	cpumask_var_t exclusive_cpus;
	nodemask_t old_mems_allowed;
	struct fmeter fmeter;
	int attach_in_progress;
	int pn;
	int relax_domain_level;
	int nr_subparts;
	int partition_root_state;
	int use_parent_ecpus;
	int child_ecpus_count;
	int nr_deadline_tasks;
	int nr_migrate_dl_tasks;
	u64 sum_migrate_dl_bw;
	enum prs_errcode prs_err;
	struct cgroup_file partition_file;
	struct list_head remote_sibling;
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
	CGRP_KILL = 4,
};

enum partition_cmd {
	partcmd_enable = 0,
	partcmd_disable = 1,
	partcmd_update = 2,
	partcmd_invalidate = 3,
};

struct cpuset_migrate_mm_work {
	struct work_struct work;
	struct mm_struct *mm;
	nodemask_t from;
	nodemask_t to;
};

struct tmpmasks {
	cpumask_var_t addmask;
	cpumask_var_t delmask;
	cpumask_var_t new_cpus;
};

typedef enum {
	CS_ONLINE = 0,
	CS_CPU_EXCLUSIVE = 1,
	CS_MEM_EXCLUSIVE = 2,
	CS_MEM_HARDWALL = 3,
	CS_MEMORY_MIGRATE = 4,
	CS_SCHED_LOAD_BALANCE = 5,
	CS_SPREAD_PAGE = 6,
	CS_SPREAD_SLAB = 7,
} cpuset_flagbits_t;

typedef enum {
	FILE_MEMORY_MIGRATE = 0,
	FILE_CPULIST = 1,
	FILE_MEMLIST = 2,
	FILE_EFFECTIVE_CPULIST = 3,
	FILE_EFFECTIVE_MEMLIST = 4,
	FILE_SUBPARTS_CPULIST = 5,
	FILE_EXCLUSIVE_CPULIST = 6,
	FILE_EFFECTIVE_XCPULIST = 7,
	FILE_CPU_EXCLUSIVE = 8,
	FILE_MEM_EXCLUSIVE = 9,
	FILE_MEM_HARDWALL = 10,
	FILE_SCHED_LOAD_BALANCE = 11,
	FILE_PARTITION_ROOT = 12,
	FILE_SCHED_RELAX_DOMAIN_LEVEL = 13,
	FILE_MEMORY_PRESSURE_ENABLED = 14,
	FILE_MEMORY_PRESSURE = 15,
	FILE_SPREAD_PAGE = 16,
	FILE_SPREAD_SLAB = 17,
} cpuset_filetype_t;

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

struct fetch_type {
	const char *name;
	size_t size;
	bool is_signed;
	bool is_string;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_BAD_MAXACT_TYPE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_NON_UNIQ_SYMBOL = 10,
	TP_ERR_BAD_RETPROBE = 11,
	TP_ERR_NO_TRACEPOINT = 12,
	TP_ERR_BAD_ADDR_SUFFIX = 13,
	TP_ERR_NO_GROUP_NAME = 14,
	TP_ERR_GROUP_TOO_LONG = 15,
	TP_ERR_BAD_GROUP_NAME = 16,
	TP_ERR_NO_EVENT_NAME = 17,
	TP_ERR_EVENT_TOO_LONG = 18,
	TP_ERR_BAD_EVENT_NAME = 19,
	TP_ERR_EVENT_EXIST = 20,
	TP_ERR_RETVAL_ON_PROBE = 21,
	TP_ERR_NO_RETVAL = 22,
	TP_ERR_BAD_STACK_NUM = 23,
	TP_ERR_BAD_ARG_NUM = 24,
	TP_ERR_BAD_VAR = 25,
	TP_ERR_BAD_REG_NAME = 26,
	TP_ERR_BAD_MEM_ADDR = 27,
	TP_ERR_BAD_IMM = 28,
	TP_ERR_IMMSTR_NO_CLOSE = 29,
	TP_ERR_FILE_ON_KPROBE = 30,
	TP_ERR_BAD_FILE_OFFS = 31,
	TP_ERR_SYM_ON_UPROBE = 32,
	TP_ERR_TOO_MANY_OPS = 33,
	TP_ERR_DEREF_NEED_BRACE = 34,
	TP_ERR_BAD_DEREF_OFFS = 35,
	TP_ERR_DEREF_OPEN_BRACE = 36,
	TP_ERR_COMM_CANT_DEREF = 37,
	TP_ERR_BAD_FETCH_ARG = 38,
	TP_ERR_ARRAY_NO_CLOSE = 39,
	TP_ERR_BAD_ARRAY_SUFFIX = 40,
	TP_ERR_BAD_ARRAY_NUM = 41,
	TP_ERR_ARRAY_TOO_BIG = 42,
	TP_ERR_BAD_TYPE = 43,
	TP_ERR_BAD_STRING = 44,
	TP_ERR_BAD_SYMSTRING = 45,
	TP_ERR_BAD_BITFIELD = 46,
	TP_ERR_ARG_NAME_TOO_LONG = 47,
	TP_ERR_NO_ARG_NAME = 48,
	TP_ERR_BAD_ARG_NAME = 49,
	TP_ERR_USED_ARG_NAME = 50,
	TP_ERR_ARG_TOO_LONG = 51,
	TP_ERR_NO_ARG_BODY = 52,
	TP_ERR_BAD_INSN_BNDRY = 53,
	TP_ERR_FAIL_REG_PROBE = 54,
	TP_ERR_DIFF_PROBE_TYPE = 55,
	TP_ERR_DIFF_ARG_TYPE = 56,
	TP_ERR_SAME_PROBE = 57,
	TP_ERR_NO_EVENT_INFO = 58,
	TP_ERR_BAD_ATTACH_EVENT = 59,
	TP_ERR_BAD_ATTACH_ARG = 60,
	TP_ERR_NO_EP_FILTER = 61,
	TP_ERR_NOSUP_BTFARG = 62,
	TP_ERR_NO_BTFARG = 63,
	TP_ERR_NO_BTF_ENTRY = 64,
	TP_ERR_BAD_VAR_ARGS = 65,
	TP_ERR_NOFENTRY_ARGS = 66,
	TP_ERR_DOUBLE_ARGS = 67,
	TP_ERR_ARGS_2LONG = 68,
	TP_ERR_ARGIDX_2BIG = 69,
	TP_ERR_NO_PTR_STRCT = 70,
	TP_ERR_NOSUP_DAT_ARG = 71,
	TP_ERR_BAD_HYPHEN = 72,
	TP_ERR_NO_BTF_FIELD = 73,
	TP_ERR_BAD_BTF_TID = 74,
	TP_ERR_BAD_TYPE4STR = 75,
};

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_DEREF = 10,
	FETCH_OP_UDEREF = 11,
	FETCH_OP_ST_RAW = 12,
	FETCH_OP_ST_MEM = 13,
	FETCH_OP_ST_UMEM = 14,
	FETCH_OP_ST_STRING = 15,
	FETCH_OP_ST_USTRING = 16,
	FETCH_OP_ST_SYMSTR = 17,
	FETCH_OP_MOD_BF = 18,
	FETCH_OP_LP_ARRAY = 19,
	FETCH_OP_TP_ARG = 20,
	FETCH_OP_END = 21,
	FETCH_NOP_SYMBOL = 22,
};

enum probe_print_type {
	PROBE_PRINT_NORMAL = 0,
	PROBE_PRINT_RETURN = 1,
	PROBE_PRINT_EVENT = 2,
};

enum {
	BTF_KIND_UNKN = 0,
	BTF_KIND_INT = 1,
	BTF_KIND_PTR = 2,
	BTF_KIND_ARRAY = 3,
	BTF_KIND_STRUCT = 4,
	BTF_KIND_UNION = 5,
	BTF_KIND_ENUM = 6,
	BTF_KIND_FWD = 7,
	BTF_KIND_TYPEDEF = 8,
	BTF_KIND_VOLATILE = 9,
	BTF_KIND_CONST = 10,
	BTF_KIND_RESTRICT = 11,
	BTF_KIND_FUNC = 12,
	BTF_KIND_FUNC_PROTO = 13,
	BTF_KIND_VAR = 14,
	BTF_KIND_DATASEC = 15,
	BTF_KIND_FLOAT = 16,
	BTF_KIND_DECL_TAG = 17,
	BTF_KIND_TYPE_TAG = 18,
	BTF_KIND_ENUM64 = 19,
	NR_BTF_KINDS = 20,
	BTF_KIND_MAX = 19,
};

enum {
	TRACE_EVENT_FL_FILTERED = 1,
	TRACE_EVENT_FL_CAP_ANY = 2,
	TRACE_EVENT_FL_NO_SET_FILTER = 4,
	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
	TRACE_EVENT_FL_TRACEPOINT = 16,
	TRACE_EVENT_FL_DYNAMIC = 32,
	TRACE_EVENT_FL_KPROBE = 64,
	TRACE_EVENT_FL_UPROBE = 128,
	TRACE_EVENT_FL_EPROBE = 256,
	TRACE_EVENT_FL_FPROBE = 512,
	TRACE_EVENT_FL_CUSTOM = 1024,
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	int is_signed;
	int len;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

struct fetch_insn;

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		unsigned long immediate;
		void *data;
	};
};

struct btf_param;

struct traceprobe_parse_context {
	struct trace_event_call *event;
	const char *funcname;
	const struct btf_type *proto;
	const struct btf_param *params;
	s32 nr_params;
	struct btf *btf;
	const struct btf_type *last_type;
	u32 last_bitoffs;
	u32 last_bitsize;
	unsigned int flags;
	int offset;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

struct trace_probe_event;

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_arg args[0];
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

struct bucket;

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bpf_mem_alloc ma;
	struct bpf_mem_alloc pcpu_ma;
	struct bucket *buckets;
	void *elems;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem * __attribute__((btf_type_tag("percpu"))) *extra_elems;
	struct percpu_counter pcount;
	atomic_t count;
	bool use_percpu_counter;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	struct lock_class_key lockdep_key;
	int __attribute__((btf_type_tag("percpu"))) *map_locked[8];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bucket {
	struct hlist_nulls_head head;
	raw_spinlock_t raw_lock;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		void *ptr_to_pptr;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	long: 0;
	char key[0];
};

struct __una_u32 {
	u32 x;
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_COMPLETED = 16384,
	VM_FAULT_HINDEX_MASK = 983040,
};

typedef unsigned int zap_flags_t;

typedef int rmap_t;

struct ptdesc {
	unsigned long __page_flags;
	union {
		struct callback_head pt_rcu_head;
		struct list_head pt_list;
		struct {
			unsigned long _pt_pad_1;
			pgtable_t pmd_huge_pte;
		};
	};
	unsigned long __page_mapping;
	union {
		struct mm_struct *pt_mm;
		atomic_t pt_frag_refcount;
	};
	union {
		unsigned long _pt_pad_2;
		spinlock_t ptl;
	};
	unsigned int __page_type;
	atomic_t _refcount;
	unsigned long pt_memcg_data;
};

typedef u64 p4dval_t;

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct encoded_page *encoded_pages[0];
};

struct mmu_table_batch;

struct mmu_gather {
	struct mm_struct *mm;
	struct mmu_table_batch *batch;
	unsigned long start;
	unsigned long end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int delayed_rmap: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int vma_pfn: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

struct mmu_table_batch {
	struct callback_head rcu;
	unsigned int nr;
	void *tables[0];
};

typedef unsigned long pte_marker;

struct zap_details {
	struct folio *single_folio;
	bool even_cows;
	zap_flags_t zap_flags;
};

typedef struct {
	u64 val;
} pfn_t;

typedef unsigned int pgtbl_mod_mask;

struct copy_subpage_arg {
	struct page *dst;
	struct page *src;
	struct vm_area_struct *vma;
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct flock {
	short l_type;
	short l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

typedef s64 compat_loff_t;

struct compat_flock64 {
	short l_type;
	short l_whence;
	compat_loff_t l_start;
	compat_loff_t l_len;
	compat_pid_t l_pid;
};

typedef s32 compat_off_t;

struct compat_flock {
	short l_type;
	short l_whence;
	compat_off_t l_start;
	compat_off_t l_len;
	compat_pid_t l_pid;
};

struct iomap_swapfile_info {
	struct iomap iomap;
	struct swap_info_struct *sis;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	unsigned long nr_pages;
	int nr_extents;
	struct file *file;
};

struct configfs_fragment;

struct configfs_dirent {
	atomic_t s_count;
	int s_dependent_count;
	struct list_head s_sibling;
	struct list_head s_children;
	int s_links;
	void *s_element;
	int s_type;
	umode_t s_mode;
	struct dentry *s_dentry;
	struct iattr *s_iattr;
	struct configfs_fragment *s_frag;
};

struct configfs_fragment {
	atomic_t frag_count;
	struct rw_semaphore frag_sem;
	bool frag_dead;
};

typedef struct {
	__le32 a_version;
} ext4_acl_header;

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext4_acl_entry;

struct squashfs_inode_info {
	u64 start;
	int offset;
	u64 xattr;
	unsigned int xattr_size;
	int xattr_count;
	union {
		struct {
			u64 fragment_block;
			int fragment_size;
			int fragment_offset;
			u64 block_list_start;
		};
		struct {
			u64 dir_idx_start;
			int dir_idx_offset;
			int dir_idx_cnt;
			int parent;
		};
	};
	struct inode vfs_inode;
};

struct squashfs_dir_index {
	__le32 index;
	__le32 start_block;
	__le32 size;
	unsigned char name[0];
};

struct squashfs_dir_header {
	__le32 count;
	__le32 start_block;
	__le32 inode_number;
};

struct squashfs_dir_entry {
	__le16 offset;
	__le16 inode_number;
	__le16 type;
	__le16 size;
	char name[0];
};

enum ramfs_param {
	Opt_mode = 0,
};

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

struct nfs_io_completion {
	void (*complete)(void *);
	void *data;
	struct kref refcount;
};

enum {
	PG_BUSY = 0,
	PG_MAPPED = 1,
	PG_FOLIO = 2,
	PG_CLEAN = 3,
	PG_COMMIT_TO_DS = 4,
	PG_INODE_REF = 5,
	PG_HEADLOCK = 6,
	PG_TEARDOWN = 7,
	PG_UNLOCKPAGE = 8,
	PG_UPTODATE = 9,
	PG_WB_END = 10,
	PG_REMOVE = 11,
	PG_CONTENDED1 = 12,
	PG_CONTENDED2 = 13,
};

enum nfs_stat_bytecounters {
	NFSIOS_NORMALREADBYTES = 0,
	NFSIOS_NORMALWRITTENBYTES = 1,
	NFSIOS_DIRECTREADBYTES = 2,
	NFSIOS_DIRECTWRITTENBYTES = 3,
	NFSIOS_SERVERREADBYTES = 4,
	NFSIOS_SERVERWRITTENBYTES = 5,
	NFSIOS_READPAGES = 6,
	NFSIOS_WRITEPAGES = 7,
	__NFSIOS_BYTESMAX = 8,
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

struct nlm_lockowner {
	struct list_head list;
	refcount_t count;
	struct nlm_host *host;
	fl_owner_t owner;
	uint32_t pid;
};

struct nsm_handle;

struct nlm_host {
	struct hlist_node h_hash;
	struct __kernel_sockaddr_storage h_addr;
	size_t h_addrlen;
	struct __kernel_sockaddr_storage h_srcaddr;
	size_t h_srcaddrlen;
	struct rpc_clnt *h_rpcclnt;
	char *h_name;
	u32 h_version;
	unsigned short h_proto;
	unsigned short h_reclaiming: 1;
	unsigned short h_server: 1;
	unsigned short h_noresvport: 1;
	unsigned short h_inuse: 1;
	wait_queue_head_t h_gracewait;
	struct rw_semaphore h_rwsem;
	u32 h_state;
	u32 h_nsmstate;
	u32 h_pidcount;
	refcount_t h_count;
	struct mutex h_mutex;
	unsigned long h_nextrebind;
	unsigned long h_expires;
	struct list_head h_lockowners;
	spinlock_t h_lock;
	struct list_head h_granted;
	struct list_head h_reclaim;
	struct nsm_handle *h_nsmhandle;
	char *h_addrbuf;
	struct net *net;
	const struct cred *h_cred;
	char nodename[65];
	const struct nlmclnt_operations *h_nlmclnt_ops;
};

struct nsm_private {
	unsigned char data[16];
};

struct nsm_handle {
	struct list_head sm_link;
	refcount_t sm_count;
	char *sm_mon_name;
	char *sm_name;
	struct __kernel_sockaddr_storage sm_addr;
	size_t sm_addrlen;
	unsigned int sm_monitored: 1;
	unsigned int sm_sticky: 1;
	struct nsm_private sm_priv;
	char sm_addrbuf[51];
};

struct nlmsvc_binding {
	__be32 (*fopen)(struct svc_rqst *, struct nfs_fh *, struct file **, int);
	void (*fclose)(struct file *);
};

enum {
	SP_TASK_PENDING = 0,
	SP_NEED_VICTIM = 1,
	SP_VICTIM_REMAINS = 2,
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	__u64 dad_nonce;
	unsigned long cstamp;
	unsigned long tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head if_list_aux;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	u8 ifa_proto;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct lock_manager {
	struct list_head list;
	bool block_opens;
};

struct lockd_net {
	unsigned int nlmsvc_users;
	unsigned long next_gc;
	unsigned long nrhosts;
	struct delayed_work grace_period_end;
	struct lock_manager lockd_manager;
	struct list_head nsm_handles;
};

struct match_token {
	int token;
	const char *pattern;
};

enum p9_trans_status {
	Connected = 0,
	BeginDisconnect = 1,
	Disconnected = 2,
	Hung = 3,
};

enum p9_session_flags {
	V9FS_PROTO_2000U = 1,
	V9FS_PROTO_2000L = 2,
	V9FS_ACCESS_SINGLE = 4,
	V9FS_ACCESS_USER = 8,
	V9FS_ACCESS_CLIENT = 16,
	V9FS_POSIX_ACL = 32,
	V9FS_NO_XATTR = 64,
	V9FS_IGNORE_QV = 128,
	V9FS_DIRECT_IO = 256,
	V9FS_SYNC = 512,
};

enum p9_cache_bits {
	CACHE_NONE = 0,
	CACHE_FILE = 1,
	CACHE_META = 2,
	CACHE_WRITEBACK = 4,
	CACHE_LOOSE = 8,
	CACHE_FSCACHE = 128,
};

enum {
	Opt_debug___2 = 0,
	Opt_dfltuid = 1,
	Opt_dfltgid = 2,
	Opt_afid = 3,
	Opt_uname = 4,
	Opt_remotename = 5,
	Opt_cache = 6,
	Opt_cachetag = 7,
	Opt_nodevmap = 8,
	Opt_noxattr = 9,
	Opt_directio = 10,
	Opt_ignoreqv = 11,
	Opt_access = 12,
	Opt_posixacl = 13,
	Opt_locktimeout = 14,
	Opt_err___2 = 15,
};

enum p9_cache_shortcuts {
	CACHE_SC_NONE = 0,
	CACHE_SC_READAHEAD = 1,
	CACHE_SC_MMAP = 5,
	CACHE_SC_LOOSE = 15,
	CACHE_SC_FSCACHE = 143,
};

struct netfs_inode {
	struct inode inode;
	const struct netfs_request_ops *ops;
	loff_t remote_i_size;
};

struct p9_qid {
	u8 type;
	u32 version;
	u64 path;
};

struct v9fs_inode {
	struct netfs_inode netfs;
	struct p9_qid qid;
	unsigned int cache_validity;
	struct mutex v_mutex;
};

struct p9_trans_module;

struct p9_client {
	spinlock_t lock;
	unsigned int msize;
	unsigned char proto_version;
	struct p9_trans_module *trans_mod;
	enum p9_trans_status status;
	void *trans;
	struct kmem_cache *fcall_cache;
	union {
		struct {
			int rfd;
			int wfd;
		} fd;
		struct {
			u16 port;
			bool privport;
		} tcp;
	} trans_opts;
	struct idr fids;
	struct idr reqs;
	char name[65];
};

struct p9_req_t;

struct p9_trans_module {
	struct list_head list;
	char *name;
	int maxsize;
	bool pooled_rbuffers;
	int def;
	struct module *owner;
	int (*create)(struct p9_client *, const char *, char *);
	void (*close)(struct p9_client *);
	int (*request)(struct p9_client *, struct p9_req_t *);
	int (*cancel)(struct p9_client *, struct p9_req_t *);
	int (*cancelled)(struct p9_client *, struct p9_req_t *);
	int (*zc_request)(struct p9_client *, struct p9_req_t *, struct iov_iter *, struct iov_iter *, int, int, int);
	int (*show_options)(struct seq_file *, struct p9_client *);
};

struct p9_fcall {
	u32 size;
	u8 id;
	u16 tag;
	size_t offset;
	size_t capacity;
	struct kmem_cache *cache;
	u8 *sdata;
	bool zc;
};

struct p9_req_t {
	int status;
	int t_err;
	refcount_t refcount;
	wait_queue_head_t wq;
	struct p9_fcall tc;
	struct p9_fcall rc;
	struct list_head req_list;
};

struct v9fs_session_info {
	unsigned int flags;
	unsigned char nodev;
	unsigned short debug;
	unsigned int afid;
	unsigned int cache;
	char *uname;
	char *aname;
	unsigned int maxdata;
	kuid_t dfltuid;
	kgid_t dfltgid;
	kuid_t uid;
	struct p9_client *clnt;
	struct list_head slist;
	struct rw_semaphore rename_sem;
	long session_lock_timeout;
};

typedef struct {
	char *from;
	char *to;
} substring_t;

struct p9_fid {
	struct p9_client *clnt;
	u32 fid;
	refcount_t count;
	int mode;
	struct p9_qid qid;
	u32 iounit;
	kuid_t uid;
	void *rdir;
	struct hlist_node dlist;
	struct hlist_node ilist;
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

enum lsm_order {
	LSM_ORDER_FIRST = -1,
	LSM_ORDER_MUTABLE = 0,
	LSM_ORDER_LAST = 1,
};

struct lsm_blob_sizes;

struct lsm_info {
	const char *name;
	enum lsm_order order;
	unsigned long flags;
	int *enabled;
	int (*init)();
	struct lsm_blob_sizes *blobs;
};

struct lsm_blob_sizes {
	int lbs_cred;
	int lbs_file;
	int lbs_inode;
	int lbs_superblock;
	int lbs_ipc;
	int lbs_msg_msg;
	int lbs_task;
	int lbs_xattr_count;
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

struct timezone;

struct xattr;

struct sembuf;

union security_list_options {
	int (*binder_set_context_mgr)(const struct cred *);
	int (*binder_transaction)(const struct cred *, const struct cred *);
	int (*binder_transfer_binder)(const struct cred *, const struct cred *);
	int (*binder_transfer_file)(const struct cred *, const struct cred *, const struct file *);
	int (*ptrace_access_check)(struct task_struct *, unsigned int);
	int (*ptrace_traceme)(struct task_struct *);
	int (*capget)(const struct task_struct *, kernel_cap_t *, kernel_cap_t *, kernel_cap_t *);
	int (*capset)(struct cred *, const struct cred *, const kernel_cap_t *, const kernel_cap_t *, const kernel_cap_t *);
	int (*capable)(const struct cred *, struct user_namespace *, int, unsigned int);
	int (*quotactl)(int, int, int, const struct super_block *);
	int (*quota_on)(struct dentry *);
	int (*syslog)(int);
	int (*settime)(const struct timespec64 *, const struct timezone *);
	int (*vm_enough_memory)(struct mm_struct *, long);
	int (*bprm_creds_for_exec)(struct linux_binprm *);
	int (*bprm_creds_from_file)(struct linux_binprm *, const struct file *);
	int (*bprm_check_security)(struct linux_binprm *);
	void (*bprm_committing_creds)(const struct linux_binprm *);
	void (*bprm_committed_creds)(const struct linux_binprm *);
	int (*fs_context_submount)(struct fs_context *, struct super_block *);
	int (*fs_context_dup)(struct fs_context *, struct fs_context *);
	int (*fs_context_parse_param)(struct fs_context *, struct fs_parameter *);
	int (*sb_alloc_security)(struct super_block *);
	void (*sb_delete)(struct super_block *);
	void (*sb_free_security)(struct super_block *);
	void (*sb_free_mnt_opts)(void *);
	int (*sb_eat_lsm_opts)(char *, void **);
	int (*sb_mnt_opts_compat)(struct super_block *, void *);
	int (*sb_remount)(struct super_block *, void *);
	int (*sb_kern_mount)(const struct super_block *);
	int (*sb_show_options)(struct seq_file *, struct super_block *);
	int (*sb_statfs)(struct dentry *);
	int (*sb_mount)(const char *, const struct path *, const char *, unsigned long, void *);
	int (*sb_umount)(struct vfsmount *, int);
	int (*sb_pivotroot)(const struct path *, const struct path *);
	int (*sb_set_mnt_opts)(struct super_block *, void *, unsigned long, unsigned long *);
	int (*sb_clone_mnt_opts)(const struct super_block *, struct super_block *, unsigned long, unsigned long *);
	int (*move_mount)(const struct path *, const struct path *);
	int (*dentry_init_security)(struct dentry *, int, const struct qstr *, const char **, void **, u32 *);
	int (*dentry_create_files_as)(struct dentry *, int, struct qstr *, const struct cred *, struct cred *);
	int (*path_notify)(const struct path *, u64, unsigned int);
	int (*inode_alloc_security)(struct inode *);
	void (*inode_free_security)(struct inode *);
	int (*inode_init_security)(struct inode *, struct inode *, const struct qstr *, struct xattr *, int *);
	int (*inode_init_security_anon)(struct inode *, const struct qstr *, const struct inode *);
	int (*inode_create)(struct inode *, struct dentry *, umode_t);
	int (*inode_link)(struct dentry *, struct inode *, struct dentry *);
	int (*inode_unlink)(struct inode *, struct dentry *);
	int (*inode_symlink)(struct inode *, struct dentry *, const char *);
	int (*inode_mkdir)(struct inode *, struct dentry *, umode_t);
	int (*inode_rmdir)(struct inode *, struct dentry *);
	int (*inode_mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*inode_rename)(struct inode *, struct dentry *, struct inode *, struct dentry *);
	int (*inode_readlink)(struct dentry *);
	int (*inode_follow_link)(struct dentry *, struct inode *, bool);
	int (*inode_permission)(struct inode *, int);
	int (*inode_setattr)(struct dentry *, struct iattr *);
	int (*inode_getattr)(const struct path *);
	int (*inode_setxattr)(struct mnt_idmap *, struct dentry *, const char *, const void *, size_t, int);
	void (*inode_post_setxattr)(struct dentry *, const char *, const void *, size_t, int);
	int (*inode_getxattr)(struct dentry *, const char *);
	int (*inode_listxattr)(struct dentry *);
	int (*inode_removexattr)(struct mnt_idmap *, struct dentry *, const char *);
	int (*inode_set_acl)(struct mnt_idmap *, struct dentry *, const char *, struct posix_acl *);
	int (*inode_get_acl)(struct mnt_idmap *, struct dentry *, const char *);
	int (*inode_remove_acl)(struct mnt_idmap *, struct dentry *, const char *);
	int (*inode_need_killpriv)(struct dentry *);
	int (*inode_killpriv)(struct mnt_idmap *, struct dentry *);
	int (*inode_getsecurity)(struct mnt_idmap *, struct inode *, const char *, void **, bool);
	int (*inode_setsecurity)(struct inode *, const char *, const void *, size_t, int);
	int (*inode_listsecurity)(struct inode *, char *, size_t);
	void (*inode_getsecid)(struct inode *, u32 *);
	int (*inode_copy_up)(struct dentry *, struct cred **);
	int (*inode_copy_up_xattr)(const char *);
	int (*kernfs_init_security)(struct kernfs_node *, struct kernfs_node *);
	int (*file_permission)(struct file *, int);
	int (*file_alloc_security)(struct file *);
	void (*file_free_security)(struct file *);
	int (*file_ioctl)(struct file *, unsigned int, unsigned long);
	int (*mmap_addr)(unsigned long);
	int (*mmap_file)(struct file *, unsigned long, unsigned long, unsigned long);
	int (*file_mprotect)(struct vm_area_struct *, unsigned long, unsigned long);
	int (*file_lock)(struct file *, unsigned int);
	int (*file_fcntl)(struct file *, unsigned int, unsigned long);
	void (*file_set_fowner)(struct file *);
	int (*file_send_sigiotask)(struct task_struct *, struct fown_struct *, int);
	int (*file_receive)(struct file *);
	int (*file_open)(struct file *);
	int (*file_truncate)(struct file *);
	int (*task_alloc)(struct task_struct *, unsigned long);
	void (*task_free)(struct task_struct *);
	int (*cred_alloc_blank)(struct cred *, gfp_t);
	void (*cred_free)(struct cred *);
	int (*cred_prepare)(struct cred *, const struct cred *, gfp_t);
	void (*cred_transfer)(struct cred *, const struct cred *);
	void (*cred_getsecid)(const struct cred *, u32 *);
	int (*kernel_act_as)(struct cred *, u32);
	int (*kernel_create_files_as)(struct cred *, struct inode *);
	int (*kernel_module_request)(char *);
	int (*kernel_load_data)(enum kernel_load_data_id, bool);
	int (*kernel_post_load_data)(char *, loff_t, enum kernel_load_data_id, char *);
	int (*kernel_read_file)(struct file *, enum kernel_read_file_id, bool);
	int (*kernel_post_read_file)(struct file *, char *, loff_t, enum kernel_read_file_id);
	int (*task_fix_setuid)(struct cred *, const struct cred *, int);
	int (*task_fix_setgid)(struct cred *, const struct cred *, int);
	int (*task_fix_setgroups)(struct cred *, const struct cred *);
	int (*task_setpgid)(struct task_struct *, pid_t);
	int (*task_getpgid)(struct task_struct *);
	int (*task_getsid)(struct task_struct *);
	void (*current_getsecid_subj)(u32 *);
	void (*task_getsecid_obj)(struct task_struct *, u32 *);
	int (*task_setnice)(struct task_struct *, int);
	int (*task_setioprio)(struct task_struct *, int);
	int (*task_getioprio)(struct task_struct *);
	int (*task_prlimit)(const struct cred *, const struct cred *, unsigned int);
	int (*task_setrlimit)(struct task_struct *, unsigned int, struct rlimit *);
	int (*task_setscheduler)(struct task_struct *);
	int (*task_getscheduler)(struct task_struct *);
	int (*task_movememory)(struct task_struct *);
	int (*task_kill)(struct task_struct *, struct kernel_siginfo *, int, const struct cred *);
	int (*task_prctl)(int, unsigned long, unsigned long, unsigned long, unsigned long);
	void (*task_to_inode)(struct task_struct *, struct inode *);
	int (*userns_create)(const struct cred *);
	int (*ipc_permission)(struct kern_ipc_perm *, short);
	void (*ipc_getsecid)(struct kern_ipc_perm *, u32 *);
	int (*msg_msg_alloc_security)(struct msg_msg *);
	void (*msg_msg_free_security)(struct msg_msg *);
	int (*msg_queue_alloc_security)(struct kern_ipc_perm *);
	void (*msg_queue_free_security)(struct kern_ipc_perm *);
	int (*msg_queue_associate)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgctl)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgsnd)(struct kern_ipc_perm *, struct msg_msg *, int);
	int (*msg_queue_msgrcv)(struct kern_ipc_perm *, struct msg_msg *, struct task_struct *, long, int);
	int (*shm_alloc_security)(struct kern_ipc_perm *);
	void (*shm_free_security)(struct kern_ipc_perm *);
	int (*shm_associate)(struct kern_ipc_perm *, int);
	int (*shm_shmctl)(struct kern_ipc_perm *, int);
	int (*shm_shmat)(struct kern_ipc_perm *, char __attribute__((btf_type_tag("user"))) *, int);
	int (*sem_alloc_security)(struct kern_ipc_perm *);
	void (*sem_free_security)(struct kern_ipc_perm *);
	int (*sem_associate)(struct kern_ipc_perm *, int);
	int (*sem_semctl)(struct kern_ipc_perm *, int);
	int (*sem_semop)(struct kern_ipc_perm *, struct sembuf *, unsigned int, int);
	int (*netlink_send)(struct sock *, struct sk_buff *);
	void (*d_instantiate)(struct dentry *, struct inode *);
	int (*getprocattr)(struct task_struct *, const char *, char **);
	int (*setprocattr)(const char *, void *, size_t);
	int (*ismaclabel)(const char *);
	int (*secid_to_secctx)(u32, char **, u32 *);
	int (*secctx_to_secid)(const char *, u32, u32 *);
	void (*release_secctx)(char *, u32);
	void (*inode_invalidate_secctx)(struct inode *);
	int (*inode_notifysecctx)(struct inode *, void *, u32);
	int (*inode_setsecctx)(struct dentry *, void *, u32);
	int (*inode_getsecctx)(struct inode *, void **, u32 *);
	int (*key_alloc)(struct key *, const struct cred *, unsigned long);
	void (*key_free)(struct key *);
	int (*key_permission)(key_ref_t, const struct cred *, enum key_need_perm);
	int (*key_getsecurity)(struct key *, char **);
	int (*audit_rule_init)(u32, u32, char *, void **);
	int (*audit_rule_known)(struct audit_krule *);
	int (*audit_rule_match)(u32, u32, u32, void *);
	void (*audit_rule_free)(void *);
	int (*bpf)(int, union bpf_attr *, unsigned int);
	int (*bpf_map)(struct bpf_map *, fmode_t);
	int (*bpf_prog)(struct bpf_prog *);
	int (*bpf_map_alloc_security)(struct bpf_map *);
	void (*bpf_map_free_security)(struct bpf_map *);
	int (*bpf_prog_alloc_security)(struct bpf_prog_aux *);
	void (*bpf_prog_free_security)(struct bpf_prog_aux *);
	int (*locked_down)(enum lockdown_reason);
	int (*perf_event_open)(struct perf_event_attr *, int);
	int (*perf_event_alloc)(struct perf_event *);
	void (*perf_event_free)(struct perf_event *);
	int (*perf_event_read)(struct perf_event *);
	int (*perf_event_write)(struct perf_event *);
	int (*uring_override_creds)(const struct cred *);
	int (*uring_sqpoll)();
	int (*uring_cmd)(struct io_uring_cmd *);
};

struct security_hook_list {
	struct hlist_node list;
	struct hlist_head *head;
	union security_list_options hook;
	const char *lsm;
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct sembuf {
	unsigned short sem_num;
	short sem_op;
	short sem_flg;
};

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

struct public_key_signature;

struct asymmetric_key_subtype {
	struct module *owner;
	const char *name;
	unsigned short name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct key_preparsed_payload {
	const char *orig_description;
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	time64_t expiry;
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

struct asymmetric_key_id;

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[3];
	u8 *s;
	u8 *digest;
	u32 s_size;
	u32 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
};

struct asymmetric_key_id {
	unsigned short len;
	unsigned char data[0];
};

enum {
	BLK_MQ_F_SHOULD_MERGE = 1,
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 32,
	BLK_MQ_F_NO_SCHED = 64,
	BLK_MQ_F_NO_SCHED_BY_DEFAULT = 128,
	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_MAX_DEPTH = 10240,
	BLK_MQ_CPU_WORK_BATCH = 8,
};

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

typedef bool busy_tag_iter_fn(struct request *, void *);

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

struct blk_expired_data {
	bool has_timedout_rq;
	unsigned long next;
	unsigned long timeout_start;
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct mq_inflight {
	struct block_device *part;
	unsigned int inflight[2];
};

struct blk_rq_wait {
	struct completion done;
	blk_status_t ret;
};

typedef unsigned long mpi_limb_t;

typedef mpi_limb_t UWtype;

typedef mpi_limb_t *mpi_ptr_t;

typedef int mpi_size_t;

typedef unsigned int UHWtype;

struct gcry_mpi;

typedef struct gcry_mpi *MPI;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

typedef long mpi_limb_signed_t;

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
};

struct z_stream_s;

typedef struct z_stream_s z_stream;

typedef z_stream *z_streamp;

typedef unsigned char Byte;

typedef unsigned long uLong;

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

typedef unsigned short ush;

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

typedef unsigned char uch;

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

typedef struct static_tree_desc_s static_tree_desc;

typedef unsigned long ulg;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

typedef struct tree_desc_s tree_desc;

typedef unsigned int uInt;

typedef ush Pos;

typedef unsigned int IPos;

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

typedef struct deflate_state deflate_state;

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

struct odmi_data {
	struct resource res;
	void *base;
	unsigned int spi_base;
};

struct combiner_reg {
	void *addr;
	unsigned long enabled;
};

struct combiner {
	struct irq_domain *domain;
	int parent_irq;
	u32 nirqs;
	u32 nregs;
	struct combiner_reg regs[0];
};

struct get_registers_context {
	struct device *dev;
	struct combiner *combiner;
	int err;
};

struct uniphier_system_bus_bank {
	u32 base;
	u32 end;
};

struct uniphier_system_bus_priv {
	struct device *dev;
	void *membase;
	struct uniphier_system_bus_bank bank[8];
};

enum imx8_pcie_phy_type {
	IMX8MM = 0,
	IMX8MP = 1,
};

struct imx8_pcie_phy_drvdata {
	const char *gpr;
	enum imx8_pcie_phy_type variant;
};

struct imx8_pcie_phy {
	void *base;
	struct clk *clk;
	struct phy *phy;
	struct regmap *iomuxc_gpr;
	struct reset_control *perst;
	struct reset_control *reset;
	u32 refclk_pad_mode;
	u32 tx_deemph_gen1;
	u32 tx_deemph_gen2;
	bool clkreq_unused;
	const struct imx8_pcie_phy_drvdata *drvdata;
};

struct tegra_xusb_lane_soc;

struct tegra_xusb_pad;

struct tegra_xusb_lane {
	const struct tegra_xusb_lane_soc *soc;
	struct tegra_xusb_pad *pad;
	struct device_node *np;
	struct list_head list;
	unsigned int function;
	unsigned int index;
};

struct tegra_xusb_lane_soc {
	const char *name;
	unsigned int offset;
	unsigned int shift;
	unsigned int mask;
	const char * const *funcs;
	unsigned int num_funcs;
	struct {
		unsigned int misc_ctl2;
	} regs;
};

struct tegra_xusb_pad_soc;

struct tegra_xusb_padctl;

struct tegra_xusb_lane_ops;

struct tegra_xusb_pad {
	const struct tegra_xusb_pad_soc *soc;
	struct tegra_xusb_padctl *padctl;
	struct phy_provider *provider;
	struct phy **lanes;
	struct device dev;
	const struct tegra_xusb_lane_ops *ops;
	struct list_head list;
};

struct tegra_xusb_pad_ops;

struct tegra_xusb_pad_soc {
	const char *name;
	const struct tegra_xusb_lane_soc *lanes;
	unsigned int num_lanes;
	const struct tegra_xusb_pad_ops *ops;
};

struct tegra_xusb_pad_ops {
	struct tegra_xusb_pad * (*probe)(struct tegra_xusb_padctl *, const struct tegra_xusb_pad_soc *, struct device_node *);
	void (*remove)(struct tegra_xusb_pad *);
};

struct tegra_xusb_padctl_soc;

struct tegra_xusb_padctl {
	struct device *dev;
	void *regs;
	struct mutex lock;
	struct reset_control *rst;
	const struct tegra_xusb_padctl_soc *soc;
	struct tegra_xusb_pad *pcie;
	struct tegra_xusb_pad *sata;
	struct tegra_xusb_pad *ulpi;
	struct tegra_xusb_pad *usb2;
	struct tegra_xusb_pad *hsic;
	struct list_head ports;
	struct list_head lanes;
	struct list_head pads;
	unsigned int enable;
	struct clk *clk;
	struct regulator_bulk_data *supplies;
};

struct tegra_xusb_port_ops;

struct tegra_xusb_padctl_ops;

struct tegra_xusb_padctl_soc {
	const struct tegra_xusb_pad_soc * const *pads;
	unsigned int num_pads;
	struct {
		struct {
			const struct tegra_xusb_port_ops *ops;
			unsigned int count;
		} usb2;
		struct {
			const struct tegra_xusb_port_ops *ops;
			unsigned int count;
		} ulpi;
		struct {
			const struct tegra_xusb_port_ops *ops;
			unsigned int count;
		} hsic;
		struct {
			const struct tegra_xusb_port_ops *ops;
			unsigned int count;
		} usb3;
	} ports;
	const struct tegra_xusb_padctl_ops *ops;
	const char * const *supply_names;
	unsigned int num_supplies;
	bool supports_gen2;
	bool need_fake_usb3_port;
	bool poll_trk_completed;
	bool trk_hw_mode;
	bool supports_lp_cfg_en;
};

struct tegra_xusb_port;

struct tegra_xusb_port_ops {
	void (*release)(struct tegra_xusb_port *);
	void (*remove)(struct tegra_xusb_port *);
	int (*enable)(struct tegra_xusb_port *);
	void (*disable)(struct tegra_xusb_port *);
	struct tegra_xusb_lane * (*map)(struct tegra_xusb_port *);
};

struct tegra_xusb_port {
	struct tegra_xusb_padctl *padctl;
	struct tegra_xusb_lane *lane;
	unsigned int index;
	struct list_head list;
	struct device dev;
	struct usb_role_switch *usb_role_sw;
	struct work_struct usb_phy_work;
	struct usb_phy usb_phy;
	const struct tegra_xusb_port_ops *ops;
};

struct tegra_xusb_padctl_ops {
	struct tegra_xusb_padctl * (*probe)(struct device *, const struct tegra_xusb_padctl_soc *);
	void (*remove)(struct tegra_xusb_padctl *);
	int (*suspend_noirq)(struct tegra_xusb_padctl *);
	int (*resume_noirq)(struct tegra_xusb_padctl *);
	int (*usb3_save_context)(struct tegra_xusb_padctl *, unsigned int);
	int (*hsic_set_idle)(struct tegra_xusb_padctl *, unsigned int, bool);
	int (*usb3_set_lfps_detect)(struct tegra_xusb_padctl *, unsigned int, bool);
	int (*vbus_override)(struct tegra_xusb_padctl *, bool);
	int (*utmi_port_reset)(struct phy *);
	void (*utmi_pad_power_on)(struct phy *);
	void (*utmi_pad_power_down)(struct phy *);
};

struct tegra_xusb_lane_ops {
	struct tegra_xusb_lane * (*probe)(struct tegra_xusb_pad *, struct device_node *, unsigned int);
	void (*remove)(struct tegra_xusb_lane *);
	void (*iddq_enable)(struct tegra_xusb_lane *);
	void (*iddq_disable)(struct tegra_xusb_lane *);
	int (*enable_phy_sleepwalk)(struct tegra_xusb_lane *, enum usb_device_speed);
	int (*disable_phy_sleepwalk)(struct tegra_xusb_lane *);
	int (*enable_phy_wake)(struct tegra_xusb_lane *);
	int (*disable_phy_wake)(struct tegra_xusb_lane *);
	bool (*remote_wake_detected)(struct tegra_xusb_lane *);
};

struct tegra_xusb_usb2_port {
	struct tegra_xusb_port base;
	struct regulator *supply;
	enum usb_dr_mode mode;
	bool internal;
	int usb3_port_fake;
};

struct tegra_xusb_usb3_port {
	struct tegra_xusb_port base;
	bool context_saved;
	unsigned int port;
	bool internal;
	bool disable_gen2;
	u32 tap1;
	u32 amp;
	u32 ctle_z;
	u32 ctle_g;
};

struct tegra_xusb_ulpi_port {
	struct tegra_xusb_port base;
	struct regulator *supply;
	bool internal;
};

struct tegra_xusb_hsic_port {
	struct tegra_xusb_port base;
};

struct tegra_xusb_lane_map {
	unsigned int port;
	const char *type;
	unsigned int index;
	const char *func;
};

enum {
	PINCTRL_PIN_REG_MODE = 0,
	PINCTRL_PIN_REG_DIR = 1,
	PINCTRL_PIN_REG_DI = 2,
	PINCTRL_PIN_REG_DO = 3,
	PINCTRL_PIN_REG_SR = 4,
	PINCTRL_PIN_REG_SMT = 5,
	PINCTRL_PIN_REG_PD = 6,
	PINCTRL_PIN_REG_PU = 7,
	PINCTRL_PIN_REG_E4 = 8,
	PINCTRL_PIN_REG_E8 = 9,
	PINCTRL_PIN_REG_TDSEL = 10,
	PINCTRL_PIN_REG_RDSEL = 11,
	PINCTRL_PIN_REG_DRV = 12,
	PINCTRL_PIN_REG_PUPD = 13,
	PINCTRL_PIN_REG_R0 = 14,
	PINCTRL_PIN_REG_R1 = 15,
	PINCTRL_PIN_REG_IES = 16,
	PINCTRL_PIN_REG_PULLEN = 17,
	PINCTRL_PIN_REG_PULLSEL = 18,
	PINCTRL_PIN_REG_DRV_EN = 19,
	PINCTRL_PIN_REG_DRV_E0 = 20,
	PINCTRL_PIN_REG_DRV_E1 = 21,
	PINCTRL_PIN_REG_DRV_ADV = 22,
	PINCTRL_PIN_REG_RSEL = 23,
	PINCTRL_PIN_REG_MAX = 24,
};

struct pmic_mpp_state {
	struct device *dev;
	struct regmap *map;
	struct pinctrl_dev *ctrl;
	struct gpio_chip chip;
};

struct pmic_mpp_pad {
	u16 base;
	bool is_enabled;
	bool out_value;
	bool output_enabled;
	bool input_enabled;
	bool paired;
	bool has_pullup;
	unsigned int num_sources;
	unsigned int power_source;
	unsigned int amux_input;
	unsigned int aout_level;
	unsigned int pullup;
	unsigned int function;
	unsigned int drive_strength;
	unsigned int dtest;
};

enum sunxi_desc_bias_voltage {
	BIAS_VOLTAGE_NONE = 0,
	BIAS_VOLTAGE_GRP_CONFIG = 1,
	BIAS_VOLTAGE_PIO_POW_MODE_SEL = 2,
	BIAS_VOLTAGE_PIO_POW_MODE_CTL = 3,
};

struct sunxi_desc_pin;

struct sunxi_pinctrl_desc {
	const struct sunxi_desc_pin *pins;
	int npins;
	unsigned int pin_base;
	unsigned int irq_banks;
	const unsigned int *irq_bank_map;
	bool irq_read_needs_mux;
	bool disable_strict_mode;
	enum sunxi_desc_bias_voltage io_bias_cfg_variant;
};

struct sunxi_desc_function;

struct sunxi_desc_pin {
	struct pinctrl_pin_desc pin;
	unsigned long variant;
	struct sunxi_desc_function *functions;
};

struct sunxi_desc_function {
	unsigned long variant;
	const char *name;
	u8 muxval;
	u8 irqbank;
	u8 irqnum;
};

struct mpc8xxx_gpio_devtype {
	int (*gpio_dir_out)(struct gpio_chip *, unsigned int, int);
	int (*gpio_get)(struct gpio_chip *, unsigned int);
	int (*irq_set_type)(struct irq_data *, unsigned int);
};

struct mpc8xxx_gpio_chip {
	struct gpio_chip gc;
	void *regs;
	raw_spinlock_t lock;
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	struct irq_domain *irq;
	int irqn;
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct ls_pcie_drvdata {
	const u32 pf_off;
	bool pm_support;
};

struct ls_pcie {
	struct dw_pcie *pci;
	const struct ls_pcie_drvdata *drvdata;
	void *pf_base;
	bool big_endian;
};

struct acpi_lpat {
	int temp;
	int raw;
};

struct acpi_lpat_conversion_table {
	struct acpi_lpat *lpat;
	int lpat_count;
};

struct acpi_prmt_module_info {
	u16 revision;
	u16 length;
	u8 module_guid[16];
	u16 major_rev;
	u16 minor_rev;
	u16 handler_info_count;
	u32 handler_info_offset;
	u64 mmio_list_pointer;
} __attribute__((packed));

struct acpi_prmt_handler_info {
	u16 revision;
	u16 length;
	u8 handler_guid[16];
	u64 handler_address;
	u64 static_data_buffer_address;
	u64 acpi_param_buffer_address;
} __attribute__((packed));

struct prm_buffer {
	u8 prm_status;
	u64 efi_status;
	u8 prm_cmd;
	guid_t handler_guid;
} __attribute__((packed));

struct prm_handler_info {
	guid_t guid;
	efi_status_t (*handler_addr)(u64, void *);
	u64 static_data_buffer_addr;
	u64 acpi_param_buffer_addr;
	struct list_head handler_list;
};

struct prm_mmio_info;

struct prm_module_info {
	guid_t guid;
	u16 major_rev;
	u16 minor_rev;
	u16 handler_count;
	struct prm_mmio_info *mmio_info;
	bool updatable;
	struct list_head module_list;
	struct prm_handler_info handlers[0];
};

struct prm_mmio_addr_range {
	u64 phys_addr;
	u64 virt_addr;
	u32 length;
} __attribute__((packed));

struct prm_mmio_info {
	u64 mmio_count;
	struct prm_mmio_addr_range addr_ranges[0];
};

struct prm_context_buffer {
	char signature[4];
	u16 revision;
	u16 reserved;
	guid_t identifier;
	u64 static_data_buffer;
	struct prm_mmio_info *mmio_ranges;
};

typedef u64 acpi_integer;

enum {
	AML_FIELD_ATTRIB_QUICK = 2,
	AML_FIELD_ATTRIB_SEND_RECEIVE = 4,
	AML_FIELD_ATTRIB_BYTE = 6,
	AML_FIELD_ATTRIB_WORD = 8,
	AML_FIELD_ATTRIB_BLOCK = 10,
	AML_FIELD_ATTRIB_BYTES = 11,
	AML_FIELD_ATTRIB_PROCESS_CALL = 12,
	AML_FIELD_ATTRIB_BLOCK_PROCESS_CALL = 13,
	AML_FIELD_ATTRIB_RAW_BYTES = 14,
	AML_FIELD_ATTRIB_RAW_PROCESS_BYTES = 15,
};

struct acpi_name_info {
	char name[4];
	u16 argument_list;
	u8 expected_btypes;
} __attribute__((packed));

struct acpi_package_info {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 object_type2;
	u8 count2;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info2 {
	u8 type;
	u8 count;
	u8 object_type[4];
	u8 reserved;
};

struct acpi_package_info3 {
	u8 type;
	u8 count;
	u8 object_type[2];
	u8 tail_object_type;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info4 {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 sub_object_types;
	u8 pkg_count;
	u16 reserved;
} __attribute__((packed));

union acpi_predefined_info {
	struct acpi_name_info info;
	struct acpi_package_info ret_info;
	struct acpi_package_info2 ret_info2;
	struct acpi_package_info3 ret_info3;
	struct acpi_package_info4 ret_info4;
};

struct acpi_evaluate_info {
	struct acpi_namespace_node *prefix_node;
	const char *relative_pathname;
	union acpi_operand_object **parameters;
	struct acpi_namespace_node *node;
	union acpi_operand_object *obj_desc;
	char *full_pathname;
	const union acpi_predefined_info *predefined;
	union acpi_operand_object *return_object;
	union acpi_operand_object *parent_package;
	u32 return_flags;
	u32 return_btype;
	u16 param_count;
	u16 node_flags;
	u8 pass_number;
	u8 return_object_type;
	u8 flags;
};

struct acpi_namestring_info {
	const char *external_name;
	const char *next_external_char;
	char *internal_name;
	u32 length;
	u32 num_segments;
	u32 num_carats;
	u8 fully_qualified;
};

typedef enum {
	ACPI_IMODE_LOAD_PASS1 = 1,
	ACPI_IMODE_LOAD_PASS2 = 2,
	ACPI_IMODE_EXECUTE = 3,
} acpi_interpreter_mode;

struct acpi_pci_routing_table {
	u32 length;
	u32 pin;
	u64 address;
	u32 source_index;
	union {
		char pad[4];
		struct {
			struct {} __Empty_source;
			char source[0];
		};
	};
};

typedef acpi_status (*acpi_walk_aml_callback)(u8 *, u32, u32, u8, void **);

struct acpi_hest_generic;

struct ghes_estatus_cache {
	u32 estatus_len;
	atomic_t count;
	struct acpi_hest_generic *generic;
	unsigned long long time_in;
	struct callback_head rcu;
};

struct acpi_hest_header {
	u16 type;
	u16 source_id;
};

struct acpi_hest_notify {
	u8 type;
	u8 length;
	u16 config_write_enable;
	u32 poll_interval;
	u32 vector;
	u32 polling_threshold_value;
	u32 polling_threshold_window;
	u32 error_threshold_value;
	u32 error_threshold_window;
};

struct acpi_hest_generic {
	struct acpi_hest_header header;
	u16 related_source_id;
	u8 reserved;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u32 max_raw_data_length;
	struct acpi_generic_address error_status_address;
	struct acpi_hest_notify notify;
	u32 error_block_length;
};

enum hest_status {
	HEST_ENABLED = 0,
	HEST_DISABLED = 1,
	HEST_NOT_FOUND = 2,
};

enum {
	GHES_SEV_NO = 0,
	GHES_SEV_CORRECTED = 1,
	GHES_SEV_RECOVERABLE = 2,
	GHES_SEV_PANIC = 3,
};

enum acpi_hest_types {
	ACPI_HEST_TYPE_IA32_CHECK = 0,
	ACPI_HEST_TYPE_IA32_CORRECTED_CHECK = 1,
	ACPI_HEST_TYPE_IA32_NMI = 2,
	ACPI_HEST_TYPE_NOT_USED3 = 3,
	ACPI_HEST_TYPE_NOT_USED4 = 4,
	ACPI_HEST_TYPE_NOT_USED5 = 5,
	ACPI_HEST_TYPE_AER_ROOT_PORT = 6,
	ACPI_HEST_TYPE_AER_ENDPOINT = 7,
	ACPI_HEST_TYPE_AER_BRIDGE = 8,
	ACPI_HEST_TYPE_GENERIC_ERROR = 9,
	ACPI_HEST_TYPE_GENERIC_ERROR_V2 = 10,
	ACPI_HEST_TYPE_IA32_DEFERRED_CHECK = 11,
	ACPI_HEST_TYPE_RESERVED = 12,
};

enum {
	CPER_SEV_RECOVERABLE = 0,
	CPER_SEV_FATAL = 1,
	CPER_SEV_CORRECTED = 2,
	CPER_SEV_INFORMATIONAL = 3,
};

enum mf_flags {
	MF_COUNT_INCREASED = 1,
	MF_ACTION_REQUIRED = 2,
	MF_MUST_KILL = 4,
	MF_SOFT_OFFLINE = 8,
	MF_UNPOISON = 16,
	MF_SW_SIMULATED = 32,
	MF_NO_RETRY = 64,
};

enum acpi_hest_notify_types {
	ACPI_HEST_NOTIFY_POLLED = 0,
	ACPI_HEST_NOTIFY_EXTERNAL = 1,
	ACPI_HEST_NOTIFY_LOCAL = 2,
	ACPI_HEST_NOTIFY_SCI = 3,
	ACPI_HEST_NOTIFY_NMI = 4,
	ACPI_HEST_NOTIFY_CMCI = 5,
	ACPI_HEST_NOTIFY_MCE = 6,
	ACPI_HEST_NOTIFY_GPIO = 7,
	ACPI_HEST_NOTIFY_SEA = 8,
	ACPI_HEST_NOTIFY_SEI = 9,
	ACPI_HEST_NOTIFY_GSIV = 10,
	ACPI_HEST_NOTIFY_SOFTWARE_DELEGATED = 11,
	ACPI_HEST_NOTIFY_RESERVED = 12,
};

struct acpi_hest_generic_v2;

struct acpi_hest_generic_status;

struct ghes {
	union {
		struct acpi_hest_generic *generic;
		struct acpi_hest_generic_v2 *generic_v2;
	};
	struct acpi_hest_generic_status *estatus;
	unsigned long flags;
	union {
		struct list_head list;
		struct timer_list timer;
		unsigned int irq;
	};
	struct device *dev;
	struct list_head elist;
};

struct acpi_hest_generic_v2 {
	struct acpi_hest_header header;
	u16 related_source_id;
	u8 reserved;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u32 max_raw_data_length;
	struct acpi_generic_address error_status_address;
	struct acpi_hest_notify notify;
	u32 error_block_length;
	struct acpi_generic_address read_ack_register;
	u64 read_ack_preserve;
	u64 read_ack_write;
} __attribute__((packed));

struct acpi_hest_generic_status {
	u32 block_status;
	u32 raw_data_offset;
	u32 raw_data_length;
	u32 data_length;
	u32 error_severity;
};

struct ghes_estatus_node {
	struct llist_node llnode;
	struct acpi_hest_generic *generic;
	struct ghes *ghes;
	int task_work_cpu;
	struct callback_head task_work;
};

struct acpi_hest_generic_data {
	u8 section_type[16];
	u32 error_severity;
	u16 revision;
	u8 validation_bits;
	u8 flags;
	u32 error_data_length;
	u8 fru_id[16];
	u8 fru_text[20];
};

struct acpi_hest_generic_data_v300 {
	u8 section_type[16];
	u32 error_severity;
	u16 revision;
	u8 validation_bits;
	u8 flags;
	u32 error_data_length;
	u8 fru_id[16];
	u8 fru_text[20];
	u64 time_stamp;
};

struct aer_header_log_regs {
	unsigned int dw0;
	unsigned int dw1;
	unsigned int dw2;
	unsigned int dw3;
};

struct aer_capability_regs {
	u32 header;
	u32 uncor_status;
	u32 uncor_mask;
	u32 uncor_severity;
	u32 cor_status;
	u32 cor_mask;
	u32 cap_control;
	struct aer_header_log_regs header_log;
	u32 root_command;
	u32 root_status;
	u16 cor_err_source;
	u16 uncor_err_source;
};

struct cper_arm_err_info {
	u8 version;
	u8 length;
	u16 validation_bits;
	u8 type;
	u16 multiple_error;
	u8 flags;
	u64 error_info;
	u64 virt_fault_addr;
	u64 physical_fault_addr;
} __attribute__((packed));

struct ghes_vendor_record_entry {
	struct work_struct work;
	int error_severity;
	char vendor_record[0];
};

struct cper_sec_mem_err {
	u64 validation_bits;
	u64 error_status;
	u64 physical_addr;
	u64 physical_addr_mask;
	u16 node;
	u16 card;
	u16 module;
	u16 bank;
	u16 device;
	u16 row;
	u16 column;
	u16 bit_pos;
	u64 requestor_id;
	u64 responder_id;
	u64 target_id;
	u8 error_type;
	u8 extended;
	u16 rank;
	u16 mem_array_handle;
	u16 mem_dev_handle;
};

struct cper_sec_pcie {
	u64 validation_bits;
	u32 port_type;
	struct {
		u8 minor;
		u8 major;
		u8 reserved[2];
	} version;
	u16 command;
	u16 status;
	u32 reserved;
	struct {
		u16 vendor_id;
		u16 device_id;
		u8 class_code[3];
		u8 function;
		u8 device;
		u16 segment;
		u8 bus;
		u8 secondary_bus;
		u16 slot;
		u8 reserved;
	} __attribute__((packed)) device_id;
	struct {
		u32 lower;
		u32 upper;
	} serial_number;
	struct {
		u16 secondary_status;
		u16 control;
	} bridge;
	u8 capability[60];
	u8 aer_info[96];
};

struct cper_sec_proc_arm {
	u32 validation_bits;
	u16 err_info_num;
	u16 context_info_num;
	u32 section_length;
	u8 affinity_level;
	u8 reserved[3];
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
};

struct scpi_dvfs_info;

struct scpi_ops;

struct scpi_clk {
	u32 id;
	struct clk_hw hw;
	struct scpi_dvfs_info *info;
	struct scpi_ops *scpi_ops;
};

struct scpi_opp;

struct scpi_dvfs_info {
	unsigned int count;
	unsigned int latency;
	struct scpi_opp *opps;
};

struct scpi_opp {
	u32 freq;
	u32 m_volt;
};

struct scpi_sensor_info;

struct scpi_ops {
	u32 (*get_version)();
	int (*clk_get_range)(u16, unsigned long *, unsigned long *);
	unsigned long (*clk_get_val)(u16);
	int (*clk_set_val)(u16, unsigned long);
	int (*dvfs_get_idx)(u8);
	int (*dvfs_set_idx)(u8, u8);
	struct scpi_dvfs_info * (*dvfs_get_info)(u8);
	int (*device_domain_id)(struct device *);
	int (*get_transition_latency)(struct device *);
	int (*add_opps_to_device)(struct device *);
	int (*sensor_get_capability)(u16 *);
	int (*sensor_get_info)(u16, struct scpi_sensor_info *);
	int (*sensor_get_value)(u16, u64 *);
	int (*device_get_power_state)(u16);
	int (*device_set_power_state)(u16, u8);
};

struct scpi_sensor_info {
	u16 sensor_id;
	u8 class;
	u8 trigger_type;
	char name[20];
};

struct scpi_clk_data {
	struct scpi_clk **clk;
	unsigned int clk_num;
};

struct hi6220_clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u32 mask;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

struct hisi_reset_controller;

struct hi3519_crg_data {
	struct hisi_clock_data *clk_data;
	struct hisi_reset_controller *rstc;
};

struct sci_clk_provider;

struct sci_clk {
	struct clk_hw hw;
	u16 dev_id;
	u32 clk_id;
	u32 num_parents;
	struct sci_clk_provider *provider;
	u8 flags;
	struct list_head node;
	unsigned long cached_req;
	unsigned long cached_res;
};

struct ti_sci_handle;

struct ti_sci_clk_ops;

struct sci_clk_provider {
	const struct ti_sci_handle *sci;
	const struct ti_sci_clk_ops *ops;
	struct device *dev;
	struct sci_clk **clocks;
	int num_clocks;
};

struct ti_sci_version_info {
	u8 abi_major;
	u8 abi_minor;
	u16 firmware_revision;
	char firmware_description[32];
};

struct ti_sci_core_ops {
	int (*reboot_device)(const struct ti_sci_handle *);
};

struct ti_sci_dev_ops {
	int (*get_device)(const struct ti_sci_handle *, u32);
	int (*get_device_exclusive)(const struct ti_sci_handle *, u32);
	int (*idle_device)(const struct ti_sci_handle *, u32);
	int (*idle_device_exclusive)(const struct ti_sci_handle *, u32);
	int (*put_device)(const struct ti_sci_handle *, u32);
	int (*is_valid)(const struct ti_sci_handle *, u32);
	int (*get_context_loss_count)(const struct ti_sci_handle *, u32, u32 *);
	int (*is_idle)(const struct ti_sci_handle *, u32, bool *);
	int (*is_stop)(const struct ti_sci_handle *, u32, bool *, bool *);
	int (*is_on)(const struct ti_sci_handle *, u32, bool *, bool *);
	int (*is_transitioning)(const struct ti_sci_handle *, u32, bool *);
	int (*set_device_resets)(const struct ti_sci_handle *, u32, u32);
	int (*get_device_resets)(const struct ti_sci_handle *, u32, u32 *);
};

struct ti_sci_clk_ops {
	int (*get_clock)(const struct ti_sci_handle *, u32, u32, bool, bool, bool);
	int (*idle_clock)(const struct ti_sci_handle *, u32, u32);
	int (*put_clock)(const struct ti_sci_handle *, u32, u32);
	int (*is_auto)(const struct ti_sci_handle *, u32, u32, bool *);
	int (*is_on)(const struct ti_sci_handle *, u32, u32, bool *, bool *);
	int (*is_off)(const struct ti_sci_handle *, u32, u32, bool *, bool *);
	int (*set_parent)(const struct ti_sci_handle *, u32, u32, u32);
	int (*get_parent)(const struct ti_sci_handle *, u32, u32, u32 *);
	int (*get_num_parents)(const struct ti_sci_handle *, u32, u32, u32 *);
	int (*get_best_match_freq)(const struct ti_sci_handle *, u32, u32, u64, u64, u64, u64 *);
	int (*set_freq)(const struct ti_sci_handle *, u32, u32, u64, u64, u64);
	int (*get_freq)(const struct ti_sci_handle *, u32, u32, u64 *);
};

struct ti_sci_resource_desc;

struct ti_sci_rm_core_ops {
	int (*get_range)(const struct ti_sci_handle *, u32, u8, struct ti_sci_resource_desc *);
	int (*get_range_from_shost)(const struct ti_sci_handle *, u32, u8, u8, struct ti_sci_resource_desc *);
};

struct ti_sci_rm_irq_ops {
	int (*set_irq)(const struct ti_sci_handle *, u16, u16, u16, u16);
	int (*set_event_map)(const struct ti_sci_handle *, u16, u16, u16, u16, u16, u8);
	int (*free_irq)(const struct ti_sci_handle *, u16, u16, u16, u16);
	int (*free_event_map)(const struct ti_sci_handle *, u16, u16, u16, u16, u16, u8);
};

struct ti_sci_msg_rm_ring_cfg;

struct ti_sci_rm_ringacc_ops {
	int (*set_cfg)(const struct ti_sci_handle *, const struct ti_sci_msg_rm_ring_cfg *);
};

struct ti_sci_rm_psil_ops {
	int (*pair)(const struct ti_sci_handle *, u32, u32, u32);
	int (*unpair)(const struct ti_sci_handle *, u32, u32, u32);
};

struct ti_sci_msg_rm_udmap_tx_ch_cfg;

struct ti_sci_msg_rm_udmap_rx_ch_cfg;

struct ti_sci_msg_rm_udmap_flow_cfg;

struct ti_sci_rm_udmap_ops {
	int (*tx_ch_cfg)(const struct ti_sci_handle *, const struct ti_sci_msg_rm_udmap_tx_ch_cfg *);
	int (*rx_ch_cfg)(const struct ti_sci_handle *, const struct ti_sci_msg_rm_udmap_rx_ch_cfg *);
	int (*rx_flow_cfg)(const struct ti_sci_handle *, const struct ti_sci_msg_rm_udmap_flow_cfg *);
};

struct ti_sci_proc_ops {
	int (*request)(const struct ti_sci_handle *, u8);
	int (*release)(const struct ti_sci_handle *, u8);
	int (*handover)(const struct ti_sci_handle *, u8, u8);
	int (*set_config)(const struct ti_sci_handle *, u8, u64, u32, u32);
	int (*set_control)(const struct ti_sci_handle *, u8, u32, u32);
	int (*get_status)(const struct ti_sci_handle *, u8, u64 *, u32 *, u32 *, u32 *);
};

struct ti_sci_ops {
	struct ti_sci_core_ops core_ops;
	struct ti_sci_dev_ops dev_ops;
	struct ti_sci_clk_ops clk_ops;
	struct ti_sci_rm_core_ops rm_core_ops;
	struct ti_sci_rm_irq_ops rm_irq_ops;
	struct ti_sci_rm_ringacc_ops rm_ring_ops;
	struct ti_sci_rm_psil_ops rm_psil_ops;
	struct ti_sci_rm_udmap_ops rm_udmap_ops;
	struct ti_sci_proc_ops proc_ops;
};

struct ti_sci_handle {
	struct ti_sci_version_info version;
	struct ti_sci_ops ops;
};

struct ti_sci_resource_desc {
	u16 start;
	u16 num;
	u16 start_sec;
	u16 num_sec;
	unsigned long *res_map;
};

struct ti_sci_msg_rm_ring_cfg {
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u32 addr_lo;
	u32 addr_hi;
	u32 count;
	u8 mode;
	u8 size;
	u8 order_id;
	u16 virtid;
	u8 asel;
};

struct ti_sci_msg_rm_udmap_tx_ch_cfg {
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u8 tx_pause_on_err;
	u8 tx_filt_einfo;
	u8 tx_filt_pswords;
	u8 tx_atype;
	u8 tx_chan_type;
	u8 tx_supr_tdpkt;
	u16 tx_fetch_size;
	u8 tx_credit_count;
	u16 txcq_qnum;
	u8 tx_priority;
	u8 tx_qos;
	u8 tx_orderid;
	u16 fdepth;
	u8 tx_sched_priority;
	u8 tx_burst_size;
	u8 tx_tdtype;
	u8 extended_ch_type;
};

struct ti_sci_msg_rm_udmap_rx_ch_cfg {
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u16 rx_fetch_size;
	u16 rxcq_qnum;
	u8 rx_priority;
	u8 rx_qos;
	u8 rx_orderid;
	u8 rx_sched_priority;
	u16 flowid_start;
	u16 flowid_cnt;
	u8 rx_pause_on_err;
	u8 rx_atype;
	u8 rx_chan_type;
	u8 rx_ignore_short;
	u8 rx_ignore_long;
	u8 rx_burst_size;
};

struct ti_sci_msg_rm_udmap_flow_cfg {
	u32 valid_params;
	u16 nav_id;
	u16 flow_index;
	u8 rx_einfo_present;
	u8 rx_psinfo_present;
	u8 rx_error_handling;
	u8 rx_desc_type;
	u16 rx_sop_offset;
	u16 rx_dest_qnum;
	u8 rx_src_tag_hi;
	u8 rx_src_tag_lo;
	u8 rx_dest_tag_hi;
	u8 rx_dest_tag_lo;
	u8 rx_src_tag_hi_sel;
	u8 rx_src_tag_lo_sel;
	u8 rx_dest_tag_hi_sel;
	u8 rx_dest_tag_lo_sel;
	u16 rx_fdq0_sz0_qnum;
	u16 rx_fdq1_qnum;
	u16 rx_fdq2_qnum;
	u16 rx_fdq3_qnum;
	u8 rx_ps_location;
};

typedef int (*list_cmp_func_t)(void *, const struct list_head *, const struct list_head *);

struct mtk_mux_nb {
	struct notifier_block nb;
	const struct clk_ops *ops;
	u8 bypass_index;
	u8 original_index;
};

struct reg_sequence {
	unsigned int reg;
	unsigned int def;
	unsigned int delay_us;
};

struct meson_clk_hw_data {
	struct clk_hw **hws;
	unsigned int num;
};

struct clk_regmap___2;

struct meson_eeclkc_data {
	struct clk_regmap___2 * const *regmap_clks;
	unsigned int regmap_clk_num;
	const struct reg_sequence *init_regs;
	unsigned int init_count;
	struct meson_clk_hw_data hw_clks;
};

struct clk_regmap___2 {
	struct clk_hw hw;
	struct regmap *map;
	void *data;
};

enum {
	PLL_OFF_L_VAL = 0,
	PLL_OFF_CAL_L_VAL = 1,
	PLL_OFF_ALPHA_VAL = 2,
	PLL_OFF_ALPHA_VAL_U = 3,
	PLL_OFF_USER_CTL = 4,
	PLL_OFF_USER_CTL_U = 5,
	PLL_OFF_USER_CTL_U1 = 6,
	PLL_OFF_CONFIG_CTL = 7,
	PLL_OFF_CONFIG_CTL_U = 8,
	PLL_OFF_CONFIG_CTL_U1 = 9,
	PLL_OFF_TEST_CTL = 10,
	PLL_OFF_TEST_CTL_U = 11,
	PLL_OFF_TEST_CTL_U1 = 12,
	PLL_OFF_TEST_CTL_U2 = 13,
	PLL_OFF_STATE = 14,
	PLL_OFF_STATUS = 15,
	PLL_OFF_OPMODE = 16,
	PLL_OFF_FRAC = 17,
	PLL_OFF_CAL_VAL = 18,
	PLL_OFF_MAX_REGS = 19,
};

struct clk_regmap_phy_mux {
	u32 reg;
	struct clk_regmap clkr;
};

struct clk_regmap_div {
	u32 reg;
	u32 shift;
	u32 width;
	struct clk_regmap clkr;
};

struct clk_regmap_mux {
	u32 reg;
	u32 shift;
	u32 width;
	const struct parent_map *parent_map;
	struct clk_regmap clkr;
};

struct clk_rcg_dfs_data {
	struct clk_rcg2 *rcg;
	struct clk_init_data *init;
};

struct cpg_core_clk;

struct rzg2l_mod_clk;

struct rzg2l_reset;

struct rzg2l_cpg_info {
	const struct cpg_core_clk *core_clks;
	unsigned int num_core_clks;
	unsigned int last_dt_core_clk;
	unsigned int num_total_core_clks;
	const struct rzg2l_mod_clk *mod_clks;
	unsigned int num_mod_clks;
	unsigned int num_hw_mod_clks;
	const unsigned int *no_pm_mod_clks;
	unsigned int num_no_pm_mod_clks;
	const struct rzg2l_reset *resets;
	unsigned int num_resets;
	const unsigned int *crit_mod_clks;
	unsigned int num_crit_mod_clks;
	bool has_clk_mon_regs;
};

struct cpg_core_clk {
	const char *name;
	unsigned int id;
	unsigned int parent;
	unsigned int div;
	unsigned int mult;
	unsigned int type;
	unsigned int conf;
	unsigned int sconf;
	const struct clk_div_table *dtable;
	const u32 *mtable;
	const unsigned long invalid_rate;
	const unsigned long max_rate;
	const char * const *parent_names;
	notifier_fn_t notifier;
	u32 flag;
	u32 mux_flags;
	int num_parents;
};

struct rzg2l_mod_clk {
	const char *name;
	unsigned int id;
	unsigned int parent;
	u16 off;
	u8 bit;
	bool is_coupled;
};

struct rzg2l_reset {
	u16 off;
	u8 bit;
	s8 monbit;
};

struct rcar_gen3_cpg_pll_config {
	u8 extal_div;
	u8 pll1_mult;
	u8 pll1_div;
	u8 pll3_mult;
	u8 pll3_div;
	u8 osc_prediv;
};

enum clk_reg_layout {
	CLK_REG_LAYOUT_RCAR_GEN2_AND_GEN3 = 0,
	CLK_REG_LAYOUT_RZ_A = 1,
	CLK_REG_LAYOUT_RCAR_GEN4 = 2,
};

enum rcar_gen3_clk_types {
	CLK_TYPE_GEN3_MAIN = 5,
	CLK_TYPE_GEN3_PLL0 = 6,
	CLK_TYPE_GEN3_PLL1 = 7,
	CLK_TYPE_GEN3_PLL2 = 8,
	CLK_TYPE_GEN3_PLL3 = 9,
	CLK_TYPE_GEN3_PLL4 = 10,
	CLK_TYPE_GEN3_SDH = 11,
	CLK_TYPE_GEN3_SD = 12,
	CLK_TYPE_GEN3_R = 13,
	CLK_TYPE_GEN3_MDSEL = 14,
	CLK_TYPE_GEN3_Z = 15,
	CLK_TYPE_GEN3_ZG = 16,
	CLK_TYPE_GEN3_OSC = 17,
	CLK_TYPE_GEN3_RCKSEL = 18,
	CLK_TYPE_GEN3_RPCSRC = 19,
	CLK_TYPE_GEN3_E3_RPCSRC = 20,
	CLK_TYPE_GEN3_RPC = 21,
	CLK_TYPE_GEN3_RPCD2 = 22,
	CLK_TYPE_GEN3_SOC_BASE = 23,
};

struct cpg_pll_clk {
	struct clk_hw hw;
	void *pllcr_reg;
	void *pllecr_reg;
	unsigned int fixed_mult;
	u32 pllecr_pllst_mask;
};

struct cpg_z_clk {
	struct clk_hw hw;
	void *reg;
	void *kick_reg;
	unsigned long max_rate;
	unsigned int fixed_div;
	u32 mask;
};

struct cpg_simple_notifier {
	struct notifier_block nb;
	void *reg;
	u32 saved;
};

struct cpg_core_clk___2 {
	const char *name;
	unsigned int id;
	unsigned int type;
	unsigned int parent;
	unsigned int div;
	unsigned int mult;
	unsigned int offset;
};

struct mssr_mod_clk;

struct cpg_mssr_info {
	const struct cpg_core_clk___2 *early_core_clks;
	unsigned int num_early_core_clks;
	const struct mssr_mod_clk *early_mod_clks;
	unsigned int num_early_mod_clks;
	const struct cpg_core_clk___2 *core_clks;
	unsigned int num_core_clks;
	unsigned int last_dt_core_clk;
	unsigned int num_total_core_clks;
	enum clk_reg_layout reg_layout;
	const struct mssr_mod_clk *mod_clks;
	unsigned int num_mod_clks;
	unsigned int num_hw_mod_clks;
	const unsigned int *crit_mod_clks;
	unsigned int num_crit_mod_clks;
	const unsigned int *core_pm_clks;
	unsigned int num_core_pm_clks;
	int (*init)(struct device *);
	struct clk * (*cpg_clk_register)(struct device *, const struct cpg_core_clk___2 *, const struct cpg_mssr_info *, struct clk **, void *, struct raw_notifier_head *);
};

struct mssr_mod_clk {
	const char *name;
	unsigned int id;
	unsigned int parent;
};

struct clk {
	struct clk_core *core;
	struct device *dev;
	const char *dev_id;
	const char *con_id;
	unsigned long min_rate;
	unsigned long max_rate;
	unsigned int exclusive_count;
	struct hlist_node clks_node;
};

struct sprd_clk_common {
	struct regmap *regmap;
	u32 reg;
	struct clk_hw hw;
};

struct sprd_gate {
	u32 enable_mask;
	u16 flags;
	u16 sc_offset;
	u16 udelay;
	struct sprd_clk_common common;
};

struct sun6i_rtc_match_data {
	bool have_ext_osc32k: 1;
	bool have_iosc_calibration: 1;
	bool rtc_32k_single_parent: 1;
	const struct clk_parent_data *osc32k_fanout_parents;
	u8 osc32k_fanout_nparents;
};

struct uniphier_clk_cpugear {
	struct clk_hw hw;
	struct regmap *regmap;
	unsigned int regbase;
	unsigned int mask;
};

struct uniphier_clk_cpugear_data {
	const char *parent_names[16];
	unsigned int num_parents;
	unsigned int regbase;
	unsigned int mask;
};

struct bcm2835_desc;

struct bcm2835_chan {
	struct virt_dma_chan vc;
	struct dma_slave_config cfg;
	unsigned int dreq;
	int ch;
	struct bcm2835_desc *desc;
	struct dma_pool *cb_pool;
	void *chan_base;
	int irq_number;
	unsigned int irq_flags;
	bool is_lite_channel;
};

struct bcm2835_dma_cb;

struct bcm2835_cb_entry {
	struct bcm2835_dma_cb *cb;
	dma_addr_t paddr;
};

struct bcm2835_desc {
	struct bcm2835_chan *c;
	struct virt_dma_desc vd;
	enum dma_transfer_direction dir;
	unsigned int frames;
	size_t size;
	bool cyclic;
	struct bcm2835_cb_entry cb_list[0];
};

struct bcm2835_dma_cb {
	uint32_t info;
	uint32_t src;
	uint32_t dst;
	uint32_t length;
	uint32_t stride;
	uint32_t next;
	uint32_t pad[2];
};

struct bcm2835_dmadev {
	struct dma_device ddev;
	void *base;
	dma_addr_t zero_page;
};

struct psil_ep;

struct psil_ep_map {
	char *name;
	struct psil_ep *src;
	int src_count;
	struct psil_ep *dst;
	int dst_count;
};

enum psil_endpoint_type {
	PSIL_EP_NATIVE = 0,
	PSIL_EP_PDMA_XY = 1,
	PSIL_EP_PDMA_MCAN = 2,
	PSIL_EP_PDMA_AASRC = 3,
};

enum udma_tp_level {
	UDMA_TP_NORMAL = 0,
	UDMA_TP_HIGH = 1,
	UDMA_TP_ULTRAHIGH = 2,
	UDMA_TP_LAST = 3,
};

struct psil_endpoint_config {
	enum psil_endpoint_type ep_type;
	enum udma_tp_level channel_tpl;
	unsigned int pkt_mode: 1;
	unsigned int notdpkt: 1;
	unsigned int needs_epib: 1;
	unsigned int pdma_acc32: 1;
	unsigned int pdma_burst: 1;
	u32 psd_size;
	s16 mapped_channel_id;
	u16 flow_start;
	u16 flow_num;
	s16 default_flow_id;
};

struct psil_ep {
	u32 thread_id;
	struct psil_endpoint_config ep_config;
};

struct apple_rtkit_crashlog_regs {
	u32 unk_0;
	u32 unk_4;
	u64 regs[31];
	u64 sp;
	u64 pc;
	u64 psr;
	u64 cpacr;
	u64 fpsr;
	u64 fpcr;
	u64 unk[64];
	u64 far;
	u64 unk_X;
	u64 esr;
	u64 unk_Z;
};

struct apple_rtkit_shmem {
	void *buffer;
	void *iomem;
	size_t size;
	dma_addr_t iova;
	bool is_mapped;
	void *private;
};

struct apple_rtkit_ops;

struct apple_rtkit {
	void *cookie;
	const struct apple_rtkit_ops *ops;
	struct device *dev;
	const char *mbox_name;
	int mbox_idx;
	struct mbox_client mbox_cl;
	struct mbox_chan *mbox_chan;
	struct completion epmap_completion;
	struct completion iop_pwr_ack_completion;
	struct completion ap_pwr_ack_completion;
	int boot_result;
	int version;
	unsigned int iop_power_state;
	unsigned int ap_power_state;
	bool crashed;
	unsigned long endpoints[4];
	struct apple_rtkit_shmem ioreport_buffer;
	struct apple_rtkit_shmem crashlog_buffer;
	struct apple_rtkit_shmem syslog_buffer;
	char *syslog_msg_buffer;
	size_t syslog_n_entries;
	size_t syslog_msg_size;
	struct workqueue_struct *wq;
};

struct apple_rtkit_ops {
	void (*crashed)(void *);
	void (*recv_message)(void *, u8, u64);
	bool (*recv_message_early)(void *, u8, u64);
	int (*shmem_setup)(void *, struct apple_rtkit_shmem *);
	void (*shmem_destroy)(void *, struct apple_rtkit_shmem *);
};

struct apple_rtkit_crashlog_mbox_entry {
	u64 msg0;
	u64 msg1;
	u32 timestamp;
	u8 _unk[4];
};

struct apple_rtkit_crashlog_header {
	u32 fourcc;
	u32 version;
	u32 size;
	u32 flags;
	u8 _unk[16];
};

struct meson_gx_soc_id {
	const char *name;
	unsigned int id;
};

struct meson_gx_package_id {
	const char *name;
	unsigned int major_id;
	unsigned int pack_id;
	unsigned int pack_mask;
};

struct renesas_family;

struct renesas_soc {
	const struct renesas_family *family;
	u32 id;
};

struct renesas_family {
	const char name[16];
	u32 reg;
};

struct renesas_id {
	unsigned int offset;
	u32 mask;
};

enum tegra_revision {
	TEGRA_REVISION_UNKNOWN = 0,
	TEGRA_REVISION_A01 = 1,
	TEGRA_REVISION_A02 = 2,
	TEGRA_REVISION_A03 = 3,
	TEGRA_REVISION_A03p = 4,
	TEGRA_REVISION_A04 = 5,
	TEGRA_REVISION_MAX = 6,
};

struct ti_sci_genpd_provider;

struct ti_sci_pm_domain {
	int idx;
	u8 exclusive;
	struct generic_pm_domain pd;
	struct list_head node;
	struct ti_sci_genpd_provider *parent;
};

struct ti_sci_genpd_provider {
	const struct ti_sci_handle *ti_sci;
	struct device *dev;
	struct list_head pd_list;
	struct genpd_onecell_data data;
};

struct xsd_errors {
	int errnum;
	const char *errstring;
};

enum xsd_sockmsg_type {
	XS_CONTROL = 0,
	XS_DIRECTORY = 1,
	XS_READ = 2,
	XS_GET_PERMS = 3,
	XS_WATCH = 4,
	XS_UNWATCH = 5,
	XS_TRANSACTION_START = 6,
	XS_TRANSACTION_END = 7,
	XS_INTRODUCE = 8,
	XS_RELEASE = 9,
	XS_GET_DOMAIN_PATH = 10,
	XS_WRITE = 11,
	XS_MKDIR = 12,
	XS_RM = 13,
	XS_SET_PERMS = 14,
	XS_WATCH_EVENT = 15,
	XS_ERROR = 16,
	XS_IS_DOMAIN_INTRODUCED = 17,
	XS_RESUME = 18,
	XS_SET_TARGET = 19,
	XS_RESET_WATCHES = 21,
	XS_DIRECTORY_PART = 22,
	XS_TYPE_COUNT = 23,
	XS_INVALID = 65535,
};

enum xb_req_state {
	xb_req_state_queued = 0,
	xb_req_state_wait_reply = 1,
	xb_req_state_got_reply = 2,
	xb_req_state_aborted = 3,
};

enum xenstore_init {
	XS_UNKNOWN = 0,
	XS_PV = 1,
	XS_HVM = 2,
	XS_LOCAL = 3,
};

struct xs_watch_event {
	struct list_head list;
	unsigned int len;
	struct xenbus_watch *handle;
	const char *path;
	const char *token;
	char body[0];
};

struct xsd_sockmsg {
	uint32_t type;
	uint32_t req_id;
	uint32_t tx_id;
	uint32_t len;
};

struct xb_req_data {
	struct list_head list;
	wait_queue_head_t wq;
	struct xsd_sockmsg msg;
	uint32_t caller_req_id;
	enum xsd_sockmsg_type type;
	char *body;
	const struct kvec *vec;
	int num_vecs;
	int err;
	enum xb_req_state state;
	bool user_req;
	void (*cb)(struct xb_req_data *);
	void *par;
};

struct hyp_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct hyp_sysfs_attr *, char *);
	ssize_t (*store)(struct hyp_sysfs_attr *, const char *, size_t);
	union {
		void *hyp_attr_data;
		unsigned long hyp_attr_value;
	};
};

struct xen_feature_info {
	unsigned int submap_idx;
	uint32_t submap;
};

struct xen_platform_parameters {
	xen_ulong_t virt_start;
};

struct xen_build_id {
	uint32_t len;
	unsigned char buf[0];
};

typedef uint8_t xen_domain_handle_t[16];

struct xen_compile_info {
	char compiler[64];
	char compile_by[16];
	char compile_domain[32];
	char compile_date[32];
};

struct hi6421v530_regulator_info {
	struct regulator_desc rdesc;
	u8 mode_mask;
	u32 eco_microamp;
};

struct hi6421_pmic {
	struct regmap *regmap;
};

struct pc9450_dvs_config {
	unsigned int run_reg;
	unsigned int run_mask;
	unsigned int standby_reg;
	unsigned int standby_mask;
};

struct pca9450_regulator_desc {
	struct regulator_desc desc;
	const struct pc9450_dvs_config dvs;
};

enum pca9450_chip_type {
	PCA9450_TYPE_PCA9450A = 0,
	PCA9450_TYPE_PCA9450BC = 1,
	PCA9450_TYPE_AMOUNT = 2,
};

enum {
	PCA9450_REG_DEV_ID = 0,
	PCA9450_REG_INT1 = 1,
	PCA9450_REG_INT1_MSK = 2,
	PCA9450_REG_STATUS1 = 3,
	PCA9450_REG_STATUS2 = 4,
	PCA9450_REG_PWRON_STAT = 5,
	PCA9450_REG_SWRST = 6,
	PCA9450_REG_PWRCTRL = 7,
	PCA9450_REG_RESET_CTRL = 8,
	PCA9450_REG_CONFIG1 = 9,
	PCA9450_REG_CONFIG2 = 10,
	PCA9450_REG_BUCK123_DVS = 12,
	PCA9450_REG_BUCK1OUT_LIMIT = 13,
	PCA9450_REG_BUCK2OUT_LIMIT = 14,
	PCA9450_REG_BUCK3OUT_LIMIT = 15,
	PCA9450_REG_BUCK1CTRL = 16,
	PCA9450_REG_BUCK1OUT_DVS0 = 17,
	PCA9450_REG_BUCK1OUT_DVS1 = 18,
	PCA9450_REG_BUCK2CTRL = 19,
	PCA9450_REG_BUCK2OUT_DVS0 = 20,
	PCA9450_REG_BUCK2OUT_DVS1 = 21,
	PCA9450_REG_BUCK3CTRL = 22,
	PCA9450_REG_BUCK3OUT_DVS0 = 23,
	PCA9450_REG_BUCK3OUT_DVS1 = 24,
	PCA9450_REG_BUCK4CTRL = 25,
	PCA9450_REG_BUCK4OUT = 26,
	PCA9450_REG_BUCK5CTRL = 27,
	PCA9450_REG_BUCK5OUT = 28,
	PCA9450_REG_BUCK6CTRL = 29,
	PCA9450_REG_BUCK6OUT = 30,
	PCA9450_REG_LDO_AD_CTRL = 32,
	PCA9450_REG_LDO1CTRL = 33,
	PCA9450_REG_LDO2CTRL = 34,
	PCA9450_REG_LDO3CTRL = 35,
	PCA9450_REG_LDO4CTRL = 36,
	PCA9450_REG_LDO5CTRL_L = 37,
	PCA9450_REG_LDO5CTRL_H = 38,
	PCA9450_REG_LOADSW_CTRL = 42,
	PCA9450_REG_VRFLT1_STS = 43,
	PCA9450_REG_VRFLT2_STS = 44,
	PCA9450_REG_VRFLT1_MASK = 45,
	PCA9450_REG_VRFLT2_MASK = 46,
	PCA9450_MAX_REGISTER = 47,
};

enum {
	PCA9450_DVS_LEVEL_RUN = 0,
	PCA9450_DVS_LEVEL_STANDBY = 1,
	PCA9450_DVS_LEVEL_MAX = 2,
};

struct pca9450 {
	struct device *dev;
	struct regmap *regmap;
	struct gpio_desc *sd_vsel_gpio;
	enum pca9450_chip_type type;
	unsigned int rcnt;
	int irq;
};

struct imx7_src_signal;

struct imx7_src_variant {
	const struct imx7_src_signal *signals;
	unsigned int signals_num;
	struct reset_control_ops ops;
};

struct imx7_src_signal {
	unsigned int offset;
	unsigned int bit;
};

struct imx7_src {
	struct reset_controller_dev rcdev;
	struct regmap *regmap;
	const struct imx7_src_signal *signals;
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct pl011_dmabuf {
	dma_addr_t dma;
	size_t len;
	char *buf;
};

struct pl011_dmarx_data {
	struct dma_chan *chan;
	struct completion complete;
	bool use_buf_b;
	struct pl011_dmabuf dbuf_a;
	struct pl011_dmabuf dbuf_b;
	dma_cookie_t cookie;
	bool running;
	struct timer_list timer;
	unsigned int last_residue;
	unsigned long last_jiffies;
	bool auto_poll_rate;
	unsigned int poll_rate;
	unsigned int poll_timeout;
};

struct pl011_dmatx_data {
	struct dma_chan *chan;
	dma_addr_t dma;
	size_t len;
	char *buf;
	bool queued;
};

struct vendor_data;

struct uart_amba_port {
	struct uart_port port;
	const u16 *reg_offset;
	struct clk *clk;
	const struct vendor_data *vendor;
	unsigned int dmacr;
	unsigned int im;
	unsigned int old_status;
	unsigned int fifosize;
	unsigned int fixed_baud;
	char type[12];
	bool rs485_tx_started;
	unsigned int rs485_tx_drain_interval;
	bool using_tx_dma;
	bool using_rx_dma;
	struct pl011_dmarx_data dmarx;
	struct pl011_dmatx_data dmatx;
	bool dma_probed;
};

struct vendor_data {
	const u16 *reg_offset;
	unsigned int ifls;
	unsigned int fr_busy;
	unsigned int fr_dsr;
	unsigned int fr_cts;
	unsigned int fr_ri;
	unsigned int inv_fr;
	bool access_32b;
	bool oversampling;
	bool dma_threshold;
	bool cts_event_workaround;
	bool always_enabled;
	bool fixed_options;
	unsigned int (*get_fifosize)(struct amba_device *);
};

enum {
	REG_DR = 0,
	REG_ST_DMAWM = 1,
	REG_ST_TIMEOUT = 2,
	REG_FR = 3,
	REG_LCRH_RX = 4,
	REG_LCRH_TX = 5,
	REG_IBRD = 6,
	REG_FBRD = 7,
	REG_CR = 8,
	REG_IFLS = 9,
	REG_IMSC = 10,
	REG_RIS = 11,
	REG_MIS = 12,
	REG_ICR = 13,
	REG_DMACR = 14,
	REG_ST_XFCR = 15,
	REG_ST_XON1 = 16,
	REG_ST_XON2 = 17,
	REG_ST_XOFF1 = 18,
	REG_ST_XOFF2 = 19,
	REG_ST_ITCR = 20,
	REG_ST_ITIP = 21,
	REG_ST_ABCR = 22,
	REG_ST_ABIMSC = 23,
	REG_ARRAY_SIZE = 24,
};

struct amba_pl011_data {
	bool (*dma_filter)(struct dma_chan *, void *);
	void *dma_rx_param;
	void *dma_tx_param;
	bool dma_rx_poll_enable;
	unsigned int dma_rx_poll_rate;
	unsigned int dma_rx_poll_timeout;
	void (*init)();
	void (*exit)();
};

struct cavium_rng_pf {
	void *control_status;
};

enum qcom_iommu_clk {
	CLK_IFACE = 0,
	CLK_BUS = 1,
	CLK_TBU = 2,
	CLK_NUM = 3,
};

struct qcom_iommu_dev;

struct qcom_iommu_domain {
	struct io_pgtable_ops *pgtbl_ops;
	spinlock_t pgtbl_lock;
	struct mutex init_mutex;
	struct iommu_domain domain;
	struct qcom_iommu_dev *iommu;
	struct iommu_fwspec *fwspec;
};

struct qcom_iommu_ctx;

struct qcom_iommu_dev {
	struct iommu_device iommu;
	struct device *dev;
	struct clk_bulk_data clks[3];
	void *local_base;
	u32 sec_id;
	u8 max_asid;
	struct qcom_iommu_ctx *ctxs[0];
};

struct qcom_iommu_ctx {
	struct device *dev;
	void *base;
	bool secure_init;
	bool secured_ctx;
	u8 asid;
	struct iommu_domain *domain;
};

struct drm_dmi_panel_orientation_data {
	int width;
	int height;
	const char * const *bios_dates;
	int orientation;
};

enum drm_panel_orientation {
	DRM_MODE_PANEL_ORIENTATION_UNKNOWN = -1,
	DRM_MODE_PANEL_ORIENTATION_NORMAL = 0,
	DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP = 1,
	DRM_MODE_PANEL_ORIENTATION_LEFT_UP = 2,
	DRM_MODE_PANEL_ORIENTATION_RIGHT_UP = 3,
};

struct aggregate_device;

struct component_ops;

struct component {
	struct list_head node;
	struct aggregate_device *adev;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_master_ops;

struct component_match;

struct aggregate_device {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *parent;
	struct component_match *match;
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component_match_array;

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_name_devm {
	unsigned long magic;
	const char *name;
};

typedef void (*async_func_t)(void *, async_cookie_t);

struct chip_data {
	u32 cid_addr;
	u32 cid_shift;
	const struct mfd_cell *cells;
	int cell_size;
	int (*irq_init)(struct mt6397_chip *);
};

struct altr_sysmgr {
	struct regmap *regmap;
};

enum sas_phy_role {
	PHY_ROLE_NONE = 0,
	PHY_ROLE_TARGET = 64,
	PHY_ROLE_INITIATOR = 128,
};

enum sas_oob_mode {
	OOB_NOT_CONNECTED = 0,
	SATA_OOB_MODE = 1,
	SAS_OOB_MODE = 2,
};

enum ex_phy_state {
	PHY_EMPTY = 0,
	PHY_VACANT = 1,
	PHY_NOT_PRESENT = 2,
	PHY_DEVICE_DISCOVERED = 3,
};

enum routing_attribute {
	DIRECT_ROUTING = 0,
	SUBTRACTIVE_ROUTING = 1,
	TABLE_ROUTING = 2,
};

enum task_attribute {
	TASK_ATTR_SIMPLE = 0,
	TASK_ATTR_HOQ = 1,
	TASK_ATTR_ORDERED = 2,
	TASK_ATTR_ACA = 4,
};

enum sas_internal_abort {
	SAS_INTERNAL_ABORT_SINGLE = 0,
	SAS_INTERNAL_ABORT_DEV = 1,
};

enum service_response {
	SAS_TASK_COMPLETE = 0,
	SAS_TASK_UNDELIVERED = -1,
};

enum exec_status {
	SAS_SAM_STAT_GOOD = 0,
	SAS_SAM_STAT_BUSY = 8,
	SAS_SAM_STAT_TASK_ABORTED = 64,
	SAS_SAM_STAT_CHECK_CONDITION = 2,
	SAS_DEV_NO_RESPONSE = 128,
	SAS_DATA_UNDERRUN = 129,
	SAS_DATA_OVERRUN = 130,
	SAS_INTERRUPTED = 131,
	SAS_QUEUE_FULL = 132,
	SAS_DEVICE_UNKNOWN = 133,
	SAS_OPEN_REJECT = 134,
	SAS_OPEN_TO = 135,
	SAS_PROTO_RESPONSE = 136,
	SAS_PHY_DOWN = 137,
	SAS_NAK_R_ERR = 138,
	SAS_PENDING = 139,
	SAS_ABORTED_TASK = 140,
};

enum sas_open_rej_reason {
	SAS_OREJ_UNKNOWN = 0,
	SAS_OREJ_BAD_DEST = 1,
	SAS_OREJ_CONN_RATE = 2,
	SAS_OREJ_EPROTO = 3,
	SAS_OREJ_RESV_AB0 = 4,
	SAS_OREJ_RESV_AB1 = 5,
	SAS_OREJ_RESV_AB2 = 6,
	SAS_OREJ_RESV_AB3 = 7,
	SAS_OREJ_WRONG_DEST = 8,
	SAS_OREJ_STP_NORES = 9,
	SAS_OREJ_NO_DEST = 10,
	SAS_OREJ_PATH_BLOCKED = 11,
	SAS_OREJ_RSVD_CONT0 = 12,
	SAS_OREJ_RSVD_CONT1 = 13,
	SAS_OREJ_RSVD_INIT0 = 14,
	SAS_OREJ_RSVD_INIT1 = 15,
	SAS_OREJ_RSVD_STOP0 = 16,
	SAS_OREJ_RSVD_STOP1 = 17,
	SAS_OREJ_RSVD_RETRY = 18,
};

enum phy_func {
	PHY_FUNC_NOP = 0,
	PHY_FUNC_LINK_RESET = 1,
	PHY_FUNC_HARD_RESET = 2,
	PHY_FUNC_DISABLE = 3,
	PHY_FUNC_CLEAR_ERROR_LOG = 5,
	PHY_FUNC_CLEAR_AFFIL = 6,
	PHY_FUNC_TX_SATA_PS_SIGNAL = 7,
	PHY_FUNC_RELEASE_SPINUP_HOLD = 16,
	PHY_FUNC_SET_LINK_RATE = 17,
	PHY_FUNC_GET_EVENTS = 18,
};

struct sas_work {
	struct list_head drain_node;
	struct work_struct work;
};

struct asd_sas_phy;

struct asd_sas_event {
	struct sas_work work;
	struct asd_sas_phy *phy;
	int event;
};

struct asd_sas_port;

struct sas_ha_struct;

struct asd_sas_phy {
	atomic_t event_nr;
	int in_shutdown;
	int error;
	int suspended;
	struct sas_phy *phy;
	int enabled;
	int id;
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	enum sas_phy_role role;
	enum sas_oob_mode oob_mode;
	enum sas_linkrate linkrate;
	u8 *sas_addr;
	u8 attached_sas_addr[8];
	spinlock_t frame_rcvd_lock;
	u8 *frame_rcvd;
	int frame_rcvd_size;
	spinlock_t sas_prim_lock;
	u32 sas_prim;
	struct list_head port_phy_el;
	struct asd_sas_port *port;
	struct sas_ha_struct *ha;
	void *lldd_phy;
};

struct sas_discovery_event {
	struct sas_work work;
	struct asd_sas_port *port;
};

struct sas_discovery {
	struct sas_discovery_event disc_work[4];
	unsigned long pending;
	u8 fanout_sas_addr[8];
	u8 eeds_a[8];
	u8 eeds_b[8];
	int max_level;
};

struct domain_device;

struct asd_sas_port {
	struct sas_discovery disc;
	struct domain_device *port_dev;
	spinlock_t dev_list_lock;
	struct list_head dev_list;
	struct list_head disco_list;
	struct list_head destroy_list;
	struct list_head sas_port_del_list;
	enum sas_linkrate linkrate;
	struct sas_work work;
	int suspended;
	int id;
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	enum sas_oob_mode oob_mode;
	spinlock_t phy_list_lock;
	struct list_head phy_list;
	int num_phys;
	u32 phy_mask;
	struct sas_ha_struct *ha;
	struct sas_port *port;
	void *lldd_port;
};

struct ex_phy;

struct expander_device {
	struct list_head children;
	int ex_change_count;
	u16 max_route_indexes;
	u8 num_phys;
	u8 t2t_supp: 1;
	u8 configuring: 1;
	u8 conf_route_table: 1;
	u8 enclosure_logical_id[8];
	struct ex_phy *ex_phy;
	struct sas_port *parent_port;
	struct mutex cmd_mutex;
};

struct dev_to_host_fis {
	u8 fis_type;
	u8 flags;
	u8 status;
	u8 error;
	u8 lbal;
	union {
		u8 lbam;
		u8 byte_count_low;
	};
	union {
		u8 lbah;
		u8 byte_count_high;
	};
	u8 device;
	u8 lbal_exp;
	u8 lbam_exp;
	u8 lbah_exp;
	u8 _r_a;
	union {
		u8 sector_count;
		u8 interrupt_reason;
	};
	u8 sector_count_exp;
	u8 _r_b;
	u8 _r_c;
	u32 _r_d;
};

struct report_phy_sata_resp {
	u8 _r_a[5];
	u8 phy_id;
	u8 _r_b;
	u8 affil_valid: 1;
	u8 affil_supp: 1;
	u8 _r_c: 6;
	u32 _r_d;
	u8 stp_sas_addr[8];
	struct dev_to_host_fis fis;
	u32 _r_e;
	u8 affil_stp_ini_addr[8];
	__be32 crc;
};

struct smp_rps_resp {
	u8 frame_type;
	u8 function;
	u8 result;
	u8 reserved;
	struct report_phy_sata_resp rps;
};

struct sata_device {
	unsigned int class;
	u8 port_no;
	struct ata_port *ap;
	struct ata_host *ata_host;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct smp_rps_resp rps_resp;
	u8 fis[24];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

struct ssp_device {
	struct list_head eh_list_node;
	struct scsi_lun reset_lun;
};

struct domain_device {
	spinlock_t done_lock;
	enum sas_device_type dev_type;
	enum sas_linkrate linkrate;
	enum sas_linkrate min_linkrate;
	enum sas_linkrate max_linkrate;
	int pathways;
	struct domain_device *parent;
	struct list_head siblings;
	struct asd_sas_port *port;
	struct sas_phy *phy;
	struct list_head dev_list_node;
	struct list_head disco_list_node;
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	struct sas_rphy *rphy;
	u8 sas_addr[8];
	u8 hashed_sas_addr[3];
	u8 frame_rcvd[32];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct expander_device ex_dev;
		struct sata_device sata_dev;
		struct ssp_device ssp_dev;
	};
	void *lldd_dev;
	unsigned long state;
	struct kref kref;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ex_phy {
	int phy_id;
	enum ex_phy_state phy_state;
	enum sas_device_type attached_dev_type;
	enum sas_linkrate linkrate;
	u8 attached_sata_host: 1;
	u8 attached_sata_dev: 1;
	u8 attached_sata_ps: 1;
	enum sas_protocol attached_tproto;
	enum sas_protocol attached_iproto;
	u8 attached_sas_addr[8];
	u8 attached_phy_id;
	int phy_change_count;
	enum routing_attribute routing_attr;
	u8 virtual: 1;
	int last_da_index;
	struct sas_phy *phy;
	struct sas_port *port;
};

struct sas_ha_struct {
	struct list_head defer_q;
	struct mutex drain_mutex;
	unsigned long state;
	spinlock_t lock;
	int eh_active;
	wait_queue_head_t eh_wait_q;
	struct list_head eh_dev_q;
	struct mutex disco_mutex;
	struct Scsi_Host *shost;
	char *sas_ha_name;
	struct device *dev;
	struct workqueue_struct *event_q;
	struct workqueue_struct *disco_q;
	u8 *sas_addr;
	u8 hashed_sas_addr[3];
	spinlock_t phy_port_lock;
	struct asd_sas_phy **sas_phy;
	struct asd_sas_port **sas_port;
	int num_phys;
	int strict_wide_ports;
	void *lldd_ha;
	struct list_head eh_done_q;
	struct list_head eh_ata_q;
	int event_thres;
};

struct sas_task;

struct sas_domain_function_template {
	void (*lldd_port_formed)(struct asd_sas_phy *);
	void (*lldd_port_deformed)(struct asd_sas_phy *);
	int (*lldd_dev_found)(struct domain_device *);
	void (*lldd_dev_gone)(struct domain_device *);
	int (*lldd_execute_task)(struct sas_task *, gfp_t);
	int (*lldd_abort_task)(struct sas_task *);
	int (*lldd_abort_task_set)(struct domain_device *, u8 *);
	int (*lldd_clear_task_set)(struct domain_device *, u8 *);
	int (*lldd_I_T_nexus_reset)(struct domain_device *);
	int (*lldd_ata_check_ready)(struct domain_device *);
	void (*lldd_ata_set_dmamode)(struct domain_device *);
	int (*lldd_lu_reset)(struct domain_device *, u8 *);
	int (*lldd_query_task)(struct sas_task *);
	void (*lldd_tmf_exec_complete)(struct domain_device *);
	void (*lldd_tmf_aborted)(struct sas_task *);
	bool (*lldd_abort_timeout)(struct sas_task *, void *);
	int (*lldd_clear_nexus_port)(struct asd_sas_port *);
	int (*lldd_clear_nexus_ha)(struct sas_ha_struct *);
	int (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);
	int (*lldd_write_gpio)(struct sas_ha_struct *, u8, u8, u8, u8 *);
};

struct host_to_dev_fis {
	u8 fis_type;
	u8 flags;
	u8 command;
	u8 features;
	u8 lbal;
	union {
		u8 lbam;
		u8 byte_count_low;
	};
	union {
		u8 lbah;
		u8 byte_count_high;
	};
	u8 device;
	u8 lbal_exp;
	u8 lbam_exp;
	u8 lbah_exp;
	u8 features_exp;
	union {
		u8 sector_count;
		u8 interrupt_reason;
	};
	u8 sector_count_exp;
	u8 _r_a;
	u8 control;
	u32 _r_b;
};

struct sas_ata_task {
	struct host_to_dev_fis fis;
	u8 atapi_packet[16];
	u8 dma_xfer: 1;
	u8 use_ncq: 1;
	u8 return_fis_on_success: 1;
	u8 device_control_reg_update: 1;
	bool force_phy;
	int force_phy_id;
};

struct sas_smp_task {
	struct scatterlist smp_req;
	struct scatterlist smp_resp;
};

struct sas_ssp_task {
	u8 LUN[8];
	enum task_attribute task_attr;
	struct scsi_cmnd *cmd;
};

struct sas_internal_abort_task {
	enum sas_internal_abort type;
	unsigned int qid;
	u16 tag;
};

struct task_status_struct {
	enum service_response resp;
	enum exec_status stat;
	int buf_valid_size;
	u8 buf[96];
	u32 residual;
	enum sas_open_rej_reason open_rej_reason;
};

struct sas_task_slow;

struct sas_tmf_task;

struct sas_task {
	struct domain_device *dev;
	spinlock_t task_state_lock;
	unsigned int task_state_flags;
	enum sas_protocol task_proto;
	union {
		struct sas_ata_task ata_task;
		struct sas_smp_task smp_task;
		struct sas_ssp_task ssp_task;
		struct sas_internal_abort_task abort_task;
	};
	struct scatterlist *scatter;
	int num_scatter;
	u32 total_xfer_len;
	u8 data_dir: 2;
	struct task_status_struct task_status;
	void (*task_done)(struct sas_task *);
	void *lldd_task;
	void *uldd_task;
	struct sas_task_slow *slow_task;
	struct sas_tmf_task *tmf;
};

struct sas_task_slow {
	struct timer_list timer;
	struct completion completion;
	struct sas_task *task;
};

struct sas_tmf_task {
	u8 tmf;
	u16 tag_of_task_to_be_managed;
};

enum scsi_host_status {
	DID_OK = 0,
	DID_NO_CONNECT = 1,
	DID_BUS_BUSY = 2,
	DID_TIME_OUT = 3,
	DID_BAD_TARGET = 4,
	DID_ABORT = 5,
	DID_PARITY = 6,
	DID_ERROR = 7,
	DID_RESET = 8,
	DID_BAD_INTR = 9,
	DID_PASSTHROUGH = 10,
	DID_SOFT_ERROR = 11,
	DID_IMM_RETRY = 12,
	DID_REQUEUE = 13,
	DID_TRANSPORT_DISRUPTED = 14,
	DID_TRANSPORT_FAILFAST = 15,
	DID_TRANSPORT_MARGINAL = 20,
};

enum ata_link_iter_mode {
	ATA_LITER_EDGE = 0,
	ATA_LITER_HOST_FIRST = 1,
	ATA_LITER_PMP_FIRST = 2,
};

enum scsi_disposition {
	NEEDS_RETRY = 8193,
	SUCCESS = 8194,
	FAILED = 8195,
	QUEUED = 8196,
	SOFT_ERROR = 8197,
	ADD_TO_MLQUEUE = 8198,
	TIMEOUT_ERROR = 8199,
	SCSI_RETURN_NOT_HANDLED = 8200,
	FAST_IO_FAIL = 8201,
};

enum ata_dev_iter_mode {
	ATA_DITER_ENABLED = 0,
	ATA_DITER_ENABLED_REVERSE = 1,
	ATA_DITER_ALL = 2,
	ATA_DITER_ALL_REVERSE = 3,
};

struct ata_port_info {
	unsigned long flags;
	unsigned long link_flags;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	struct ata_port_operations *port_ops;
	void *private_data;
};

struct nand_ecc_req_tweak_ctx {
	struct nand_page_io_req orig_req;
	struct nand_device *nand;
	unsigned int page_buffer_size;
	unsigned int oob_buffer_size;
	void *spare_databuf;
	void *spare_oobbuf;
	bool bounce_data;
	bool bounce_oob;
};

struct nand_ecc_sw_hamming_conf {
	struct nand_ecc_req_tweak_ctx req_ctx;
	unsigned int code_size;
	u8 *calc_buf;
	u8 *code_buf;
	unsigned int sm_order;
};

struct marvell_hw_ecc_layout {
	int writesize;
	int chunk;
	int strength;
	int nchunks;
	int full_chunk_cnt;
	int data_bytes;
	int spare_bytes;
	int ecc_bytes;
	int last_data_bytes;
	int last_spare_bytes;
	int last_ecc_bytes;
};

struct nand_op_parser_pattern;

struct nand_op_parser {
	const struct nand_op_parser_pattern *patterns;
	unsigned int npatterns;
};

struct nand_op_parser_pattern_elem;

struct nand_subop;

struct nand_op_parser_pattern {
	const struct nand_op_parser_pattern_elem *elems;
	unsigned int nelems;
	int (*exec)(struct nand_chip *, const struct nand_subop *);
};

struct nand_op_parser_addr_constraints {
	unsigned int maxcycles;
};

struct nand_op_parser_data_constraints {
	unsigned int maxlen;
};

struct nand_op_parser_pattern_elem {
	enum nand_op_instr_type type;
	bool optional;
	union {
		struct nand_op_parser_addr_constraints addr;
		struct nand_op_parser_data_constraints data;
	} ctx;
};

struct nand_subop {
	unsigned int cs;
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
	unsigned int first_instr_start_off;
	unsigned int last_instr_end_off;
};

struct marvell_nfc_caps {
	unsigned int max_cs_nb;
	unsigned int max_rb_nb;
	bool need_system_controller;
	bool legacy_of_bindings;
	bool is_nfcv2;
	bool use_dma;
	unsigned int max_mode_number;
};

struct marvell_nand_chip_sel {
	unsigned int cs;
	u32 ndcb0_csel;
	unsigned int rb;
};

struct marvell_nand_chip {
	struct nand_chip chip;
	struct list_head node;
	const struct marvell_hw_ecc_layout *layout;
	u32 ndcr;
	u32 ndtr0;
	u32 ndtr1;
	int addr_cyc;
	int selected_die;
	unsigned int nsels;
	struct marvell_nand_chip_sel sels[0];
};

struct marvell_nfc {
	struct nand_controller controller;
	struct device *dev;
	void *regs;
	struct clk *core_clk;
	struct clk *reg_clk;
	struct completion complete;
	unsigned long assigned_cs;
	struct list_head chips;
	struct nand_chip *selected_chip;
	const struct marvell_nfc_caps *caps;
	bool use_dma;
	struct dma_chan *dma_chan;
	u8 *dma_buf;
};

struct marvell_nfc_op {
	u32 ndcb[4];
	unsigned int cle_ale_delay_ns;
	unsigned int rdy_timeout_ms;
	unsigned int rdy_delay_ns;
	unsigned int data_delay_ns;
	unsigned int data_instr_idx;
	const struct nand_op_instr *data_instr;
};

struct pxa3xx_nand_platform_data {
	bool keep_config;
	bool flash_bbt;
	int ecc_strength;
	int ecc_step_size;
	const struct mtd_partition *parts;
	unsigned int nr_parts;
};

struct marvell_nfc_timings {
	unsigned int tRP;
	unsigned int tRH;
	unsigned int tWP;
	unsigned int tWH;
	unsigned int tCS;
	unsigned int tCH;
	unsigned int tADL;
	unsigned int tAR;
	unsigned int tWHR;
	unsigned int tRHW;
	unsigned int tR;
};

struct sfp_eeprom_id;

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *);
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

enum stat_access_type {
	PHY = 0,
	MMD = 1,
};

struct at803x_hw_stat {
	const char *string;
	u8 reg;
	u32 mask;
	enum stat_access_type access_type;
};

enum {
	ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_CODE_OK = 1,
	ETHTOOL_A_CABLE_RESULT_CODE_OPEN = 2,
	ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT = 3,
	ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT = 4,
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

struct at803x_priv {
	int flags;
	u16 clk_25m_reg;
	u16 clk_25m_mask;
	u8 smarteee_lpi_tw_1g;
	u8 smarteee_lpi_tw_100m;
	bool is_fiber;
	bool is_1000basex;
	struct regulator_dev *vddio_rdev;
	struct regulator_dev *vddh_rdev;
	u64 stats[3];
};

struct at803x_context {
	u16 bmcr;
	u16 advertise;
	u16 control1000;
	u16 int_enable;
	u16 smart_speed;
	u16 led_control;
};

enum xgbe_xpcs_access {
	XGBE_XPCS_ACCESS_V1 = 0,
	XGBE_XPCS_ACCESS_V2 = 1,
};

enum xgbe_mdio_mode {
	XGBE_MDIO_MODE_NONE = 0,
	XGBE_MDIO_MODE_CL22 = 1,
	XGBE_MDIO_MODE_CL45 = 2,
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

enum xgbe_int {
	XGMAC_INT_DMA_CH_SR_TI = 0,
	XGMAC_INT_DMA_CH_SR_TPS = 1,
	XGMAC_INT_DMA_CH_SR_TBU = 2,
	XGMAC_INT_DMA_CH_SR_RI = 3,
	XGMAC_INT_DMA_CH_SR_RBU = 4,
	XGMAC_INT_DMA_CH_SR_RPS = 5,
	XGMAC_INT_DMA_CH_SR_TI_RI = 6,
	XGMAC_INT_DMA_CH_SR_FBE = 7,
	XGMAC_INT_DMA_ALL = 8,
};

enum xgbe_ecc_sec {
	XGBE_ECC_SEC_TX = 0,
	XGBE_ECC_SEC_RX = 1,
	XGBE_ECC_SEC_DESC = 2,
};

enum xgbe_i2c_cmd {
	XGBE_I2C_CMD_READ = 0,
	XGBE_I2C_CMD_WRITE = 1,
};

enum xgbe_an {
	XGBE_AN_READY = 0,
	XGBE_AN_PAGE_RECEIVED = 1,
	XGBE_AN_INCOMPAT_LINK = 2,
	XGBE_AN_COMPLETE = 3,
	XGBE_AN_NO_LINK = 4,
	XGBE_AN_ERROR = 5,
};

enum xgbe_rx {
	XGBE_RX_BPA = 0,
	XGBE_RX_XNP = 1,
	XGBE_RX_COMPLETE = 2,
	XGBE_RX_ERROR = 3,
};

enum xgbe_an_mode {
	XGBE_AN_MODE_CL73 = 0,
	XGBE_AN_MODE_CL73_REDRV = 1,
	XGBE_AN_MODE_CL37 = 2,
	XGBE_AN_MODE_CL37_SGMII = 3,
	XGBE_AN_MODE_NONE = 4,
};

enum xgbe_mode {
	XGBE_MODE_KX_1000 = 0,
	XGBE_MODE_KX_2500 = 1,
	XGBE_MODE_KR = 2,
	XGBE_MODE_X = 3,
	XGBE_MODE_SGMII_10 = 4,
	XGBE_MODE_SGMII_100 = 5,
	XGBE_MODE_SGMII_1000 = 6,
	XGBE_MODE_SFI = 7,
	XGBE_MODE_UNKNOWN = 8,
};

enum xgbe_port_mode {
	XGBE_PORT_MODE_RSVD = 0,
	XGBE_PORT_MODE_BACKPLANE = 1,
	XGBE_PORT_MODE_BACKPLANE_2500 = 2,
	XGBE_PORT_MODE_1000BASE_T = 3,
	XGBE_PORT_MODE_1000BASE_X = 4,
	XGBE_PORT_MODE_NBASE_T = 5,
	XGBE_PORT_MODE_10GBASE_T = 6,
	XGBE_PORT_MODE_10GBASE_R = 7,
	XGBE_PORT_MODE_SFP = 8,
	XGBE_PORT_MODE_BACKPLANE_NO_AUTONEG = 9,
	XGBE_PORT_MODE_MAX = 10,
};

enum xgbe_conn_type {
	XGBE_CONN_TYPE_NONE = 0,
	XGBE_CONN_TYPE_SFP = 1,
	XGBE_CONN_TYPE_MDIO = 2,
	XGBE_CONN_TYPE_RSVD1 = 3,
	XGBE_CONN_TYPE_BACKPLANE = 4,
	XGBE_CONN_TYPE_MAX = 5,
};

enum xgbe_sfp_comm {
	XGBE_SFP_COMM_DIRECT = 0,
	XGBE_SFP_COMM_PCA9545 = 1,
};

enum xgbe_sfp_base {
	XGBE_SFP_BASE_UNKNOWN = 0,
	XGBE_SFP_BASE_1000_T = 1,
	XGBE_SFP_BASE_1000_SX = 2,
	XGBE_SFP_BASE_1000_LX = 3,
	XGBE_SFP_BASE_1000_CX = 4,
	XGBE_SFP_BASE_10000_SR = 5,
	XGBE_SFP_BASE_10000_LR = 6,
	XGBE_SFP_BASE_10000_LRM = 7,
	XGBE_SFP_BASE_10000_ER = 8,
	XGBE_SFP_BASE_10000_CR = 9,
};

enum xgbe_sfp_cable {
	XGBE_SFP_CABLE_UNKNOWN = 0,
	XGBE_SFP_CABLE_ACTIVE = 1,
	XGBE_SFP_CABLE_PASSIVE = 2,
	XGBE_SFP_CABLE_FIBER = 3,
};

enum xgbe_sfp_speed {
	XGBE_SFP_SPEED_UNKNOWN = 0,
	XGBE_SFP_SPEED_100_1000 = 1,
	XGBE_SFP_SPEED_1000 = 2,
	XGBE_SFP_SPEED_10000 = 3,
};

enum xgbe_mdio_reset {
	XGBE_MDIO_RESET_NONE = 0,
	XGBE_MDIO_RESET_I2C_GPIO = 1,
	XGBE_MDIO_RESET_INT_GPIO = 2,
	XGBE_MDIO_RESET_MAX = 3,
};

enum xgbe_phy_redrv_if {
	XGBE_PHY_REDRV_IF_MDIO = 0,
	XGBE_PHY_REDRV_IF_I2C = 1,
	XGBE_PHY_REDRV_IF_MAX = 2,
};

enum xgbe_phy_redrv_model {
	XGBE_PHY_REDRV_MODEL_4223 = 0,
	XGBE_PHY_REDRV_MODEL_4227 = 1,
	XGBE_PHY_REDRV_MODEL_MAX = 2,
};

enum xgbe_mb_cmd {
	XGBE_MB_CMD_POWER_OFF = 0,
	XGBE_MB_CMD_SET_1G = 1,
	XGBE_MB_CMD_SET_2_5G = 2,
	XGBE_MB_CMD_SET_10G_SFI = 3,
	XGBE_MB_CMD_SET_10G_KR = 4,
	XGBE_MB_CMD_RRC = 5,
};

enum xgbe_mb_subcmd {
	XGBE_MB_SUBCMD_NONE = 0,
	XGBE_MB_SUBCMD_RX_ADAP = 1,
	XGBE_MB_SUBCMD_ACTIVE = 0,
	XGBE_MB_SUBCMD_PASSIVE_1M = 1,
	XGBE_MB_SUBCMD_PASSIVE_3M = 2,
	XGBE_MB_SUBCMD_PASSIVE_OTHER = 3,
	XGBE_MB_SUBCMD_10MBITS = 0,
	XGBE_MB_SUBCMD_100MBITS = 1,
	XGBE_MB_SUBCMD_1G_SGMII = 2,
	XGBE_MB_SUBCMD_1G_KX = 3,
};

enum xgbe_state {
	XGBE_DOWN = 0,
	XGBE_LINK_INIT = 1,
	XGBE_LINK_ERR = 2,
	XGBE_STOPPED = 3,
};

enum xgbe_phy_redrv_mode {
	XGBE_PHY_REDRV_MODE_CX = 5,
	XGBE_PHY_REDRV_MODE_SR = 9,
};

struct xgbe_sfp_eeprom {
	u8 base[64];
	u8 extd[32];
	u8 vendor[32];
};

struct xgbe_ring_desc;

struct xgbe_prv_data;

struct xgbe_channel;

struct xgbe_ring_data;

struct xgbe_ring;

struct xgbe_hw_if {
	int (*tx_complete)(struct xgbe_ring_desc *);
	int (*set_mac_address)(struct xgbe_prv_data *, const u8 *);
	int (*config_rx_mode)(struct xgbe_prv_data *);
	int (*enable_rx_csum)(struct xgbe_prv_data *);
	int (*disable_rx_csum)(struct xgbe_prv_data *);
	int (*enable_rx_vlan_stripping)(struct xgbe_prv_data *);
	int (*disable_rx_vlan_stripping)(struct xgbe_prv_data *);
	int (*enable_rx_vlan_filtering)(struct xgbe_prv_data *);
	int (*disable_rx_vlan_filtering)(struct xgbe_prv_data *);
	int (*update_vlan_hash_table)(struct xgbe_prv_data *);
	int (*read_mmd_regs)(struct xgbe_prv_data *, int, int);
	void (*write_mmd_regs)(struct xgbe_prv_data *, int, int, int);
	int (*set_speed)(struct xgbe_prv_data *, int);
	int (*set_ext_mii_mode)(struct xgbe_prv_data *, unsigned int, enum xgbe_mdio_mode);
	int (*read_ext_mii_regs_c22)(struct xgbe_prv_data *, int, int);
	int (*write_ext_mii_regs_c22)(struct xgbe_prv_data *, int, int, u16);
	int (*read_ext_mii_regs_c45)(struct xgbe_prv_data *, int, int, int);
	int (*write_ext_mii_regs_c45)(struct xgbe_prv_data *, int, int, int, u16);
	int (*set_gpio)(struct xgbe_prv_data *, unsigned int);
	int (*clr_gpio)(struct xgbe_prv_data *, unsigned int);
	void (*enable_tx)(struct xgbe_prv_data *);
	void (*disable_tx)(struct xgbe_prv_data *);
	void (*enable_rx)(struct xgbe_prv_data *);
	void (*disable_rx)(struct xgbe_prv_data *);
	void (*powerup_tx)(struct xgbe_prv_data *);
	void (*powerdown_tx)(struct xgbe_prv_data *);
	void (*powerup_rx)(struct xgbe_prv_data *);
	void (*powerdown_rx)(struct xgbe_prv_data *);
	int (*init)(struct xgbe_prv_data *);
	int (*exit)(struct xgbe_prv_data *);
	int (*enable_int)(struct xgbe_channel *, enum xgbe_int);
	int (*disable_int)(struct xgbe_channel *, enum xgbe_int);
	void (*dev_xmit)(struct xgbe_channel *);
	int (*dev_read)(struct xgbe_channel *);
	void (*tx_desc_init)(struct xgbe_channel *);
	void (*rx_desc_init)(struct xgbe_channel *);
	void (*tx_desc_reset)(struct xgbe_ring_data *);
	void (*rx_desc_reset)(struct xgbe_prv_data *, struct xgbe_ring_data *, unsigned int);
	int (*is_last_desc)(struct xgbe_ring_desc *);
	int (*is_context_desc)(struct xgbe_ring_desc *);
	void (*tx_start_xmit)(struct xgbe_channel *, struct xgbe_ring *);
	int (*config_tx_flow_control)(struct xgbe_prv_data *);
	int (*config_rx_flow_control)(struct xgbe_prv_data *);
	int (*config_rx_coalesce)(struct xgbe_prv_data *);
	int (*config_tx_coalesce)(struct xgbe_prv_data *);
	unsigned int (*usec_to_riwt)(struct xgbe_prv_data *, unsigned int);
	unsigned int (*riwt_to_usec)(struct xgbe_prv_data *, unsigned int);
	int (*config_rx_threshold)(struct xgbe_prv_data *, unsigned int);
	int (*config_tx_threshold)(struct xgbe_prv_data *, unsigned int);
	int (*config_rsf_mode)(struct xgbe_prv_data *, unsigned int);
	int (*config_tsf_mode)(struct xgbe_prv_data *, unsigned int);
	int (*config_osp_mode)(struct xgbe_prv_data *);
	void (*rx_mmc_int)(struct xgbe_prv_data *);
	void (*tx_mmc_int)(struct xgbe_prv_data *);
	void (*read_mmc_stats)(struct xgbe_prv_data *);
	int (*config_tstamp)(struct xgbe_prv_data *, unsigned int);
	void (*update_tstamp_addend)(struct xgbe_prv_data *, unsigned int);
	void (*set_tstamp_time)(struct xgbe_prv_data *, unsigned int, unsigned int);
	u64 (*get_tstamp_time)(struct xgbe_prv_data *);
	u64 (*get_tx_tstamp)(struct xgbe_prv_data *);
	void (*config_tc)(struct xgbe_prv_data *);
	void (*config_dcb_tc)(struct xgbe_prv_data *);
	void (*config_dcb_pfc)(struct xgbe_prv_data *);
	int (*enable_rss)(struct xgbe_prv_data *);
	int (*disable_rss)(struct xgbe_prv_data *);
	int (*set_rss_hash_key)(struct xgbe_prv_data *, const u8 *);
	int (*set_rss_lookup_table)(struct xgbe_prv_data *, const u32 *);
	void (*disable_ecc_ded)(struct xgbe_prv_data *);
	void (*disable_ecc_sec)(struct xgbe_prv_data *, enum xgbe_ecc_sec);
	void (*enable_vxlan)(struct xgbe_prv_data *);
	void (*disable_vxlan)(struct xgbe_prv_data *);
	void (*set_vxlan_id)(struct xgbe_prv_data *);
};

struct xgbe_phy_impl_if {
	int (*init)(struct xgbe_prv_data *);
	void (*exit)(struct xgbe_prv_data *);
	int (*reset)(struct xgbe_prv_data *);
	int (*start)(struct xgbe_prv_data *);
	void (*stop)(struct xgbe_prv_data *);
	int (*link_status)(struct xgbe_prv_data *, int *);
	bool (*valid_speed)(struct xgbe_prv_data *, int);
	bool (*use_mode)(struct xgbe_prv_data *, enum xgbe_mode);
	void (*set_mode)(struct xgbe_prv_data *, enum xgbe_mode);
	enum xgbe_mode (*get_mode)(struct xgbe_prv_data *, int);
	enum xgbe_mode (*switch_mode)(struct xgbe_prv_data *);
	enum xgbe_mode (*cur_mode)(struct xgbe_prv_data *);
	enum xgbe_an_mode (*an_mode)(struct xgbe_prv_data *);
	int (*an_config)(struct xgbe_prv_data *);
	void (*an_advertising)(struct xgbe_prv_data *, struct ethtool_link_ksettings *);
	enum xgbe_mode (*an_outcome)(struct xgbe_prv_data *);
	void (*an_pre)(struct xgbe_prv_data *);
	void (*an_post)(struct xgbe_prv_data *);
	void (*kr_training_pre)(struct xgbe_prv_data *);
	void (*kr_training_post)(struct xgbe_prv_data *);
	int (*module_info)(struct xgbe_prv_data *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct xgbe_prv_data *, struct ethtool_eeprom *, u8 *);
};

struct xgbe_phy_if {
	int (*phy_init)(struct xgbe_prv_data *);
	void (*phy_exit)(struct xgbe_prv_data *);
	int (*phy_reset)(struct xgbe_prv_data *);
	int (*phy_start)(struct xgbe_prv_data *);
	void (*phy_stop)(struct xgbe_prv_data *);
	void (*phy_status)(struct xgbe_prv_data *);
	int (*phy_config_aneg)(struct xgbe_prv_data *);
	bool (*phy_valid_speed)(struct xgbe_prv_data *, int);
	irqreturn_t (*an_isr)(struct xgbe_prv_data *);
	int (*module_info)(struct xgbe_prv_data *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct xgbe_prv_data *, struct ethtool_eeprom *, u8 *);
	struct xgbe_phy_impl_if phy_impl;
};

struct xgbe_desc_if {
	int (*alloc_ring_resources)(struct xgbe_prv_data *);
	void (*free_ring_resources)(struct xgbe_prv_data *);
	int (*map_tx_skb)(struct xgbe_channel *, struct sk_buff *);
	int (*map_rx_buffer)(struct xgbe_prv_data *, struct xgbe_ring *, struct xgbe_ring_data *);
	void (*unmap_rdata)(struct xgbe_prv_data *, struct xgbe_ring_data *);
	void (*wrapper_tx_desc_init)(struct xgbe_prv_data *);
	void (*wrapper_rx_desc_init)(struct xgbe_prv_data *);
};

struct xgbe_i2c_op;

struct xgbe_i2c_if {
	int (*i2c_init)(struct xgbe_prv_data *);
	int (*i2c_start)(struct xgbe_prv_data *);
	void (*i2c_stop)(struct xgbe_prv_data *);
	int (*i2c_xfer)(struct xgbe_prv_data *, struct xgbe_i2c_op *);
	irqreturn_t (*i2c_isr)(struct xgbe_prv_data *);
};

struct xgbe_mmc_stats {
	u64 txoctetcount_gb;
	u64 txframecount_gb;
	u64 txbroadcastframes_g;
	u64 txmulticastframes_g;
	u64 tx64octets_gb;
	u64 tx65to127octets_gb;
	u64 tx128to255octets_gb;
	u64 tx256to511octets_gb;
	u64 tx512to1023octets_gb;
	u64 tx1024tomaxoctets_gb;
	u64 txunicastframes_gb;
	u64 txmulticastframes_gb;
	u64 txbroadcastframes_gb;
	u64 txunderflowerror;
	u64 txoctetcount_g;
	u64 txframecount_g;
	u64 txpauseframes;
	u64 txvlanframes_g;
	u64 rxframecount_gb;
	u64 rxoctetcount_gb;
	u64 rxoctetcount_g;
	u64 rxbroadcastframes_g;
	u64 rxmulticastframes_g;
	u64 rxcrcerror;
	u64 rxrunterror;
	u64 rxjabbererror;
	u64 rxundersize_g;
	u64 rxoversize_g;
	u64 rx64octets_gb;
	u64 rx65to127octets_gb;
	u64 rx128to255octets_gb;
	u64 rx256to511octets_gb;
	u64 rx512to1023octets_gb;
	u64 rx1024tomaxoctets_gb;
	u64 rxunicastframes_g;
	u64 rxlengtherror;
	u64 rxoutofrangetype;
	u64 rxpauseframes;
	u64 rxfifooverflow;
	u64 rxvlanframes_gb;
	u64 rxwatchdogerror;
};

struct xgbe_ext_stats {
	u64 tx_tso_packets;
	u64 rx_split_header_packets;
	u64 rx_buffer_unavailable;
	u64 txq_packets[16];
	u64 txq_bytes[16];
	u64 rxq_packets[16];
	u64 rxq_bytes[16];
	u64 tx_vxlan_packets;
	u64 rx_vxlan_packets;
	u64 rx_csum_errors;
	u64 rx_vxlan_csum_errors;
};

struct xgbe_hw_features {
	unsigned int version;
	unsigned int gmii;
	unsigned int vlhash;
	unsigned int sma;
	unsigned int rwk;
	unsigned int mgk;
	unsigned int mmc;
	unsigned int aoe;
	unsigned int ts;
	unsigned int eee;
	unsigned int tx_coe;
	unsigned int rx_coe;
	unsigned int addn_mac;
	unsigned int ts_src;
	unsigned int sa_vlan_ins;
	unsigned int vxn;
	unsigned int rx_fifo_size;
	unsigned int tx_fifo_size;
	unsigned int adv_ts_hi;
	unsigned int dma_width;
	unsigned int dcb;
	unsigned int sph;
	unsigned int tso;
	unsigned int dma_debug;
	unsigned int rss;
	unsigned int tc_cnt;
	unsigned int hash_table_size;
	unsigned int l3l4_filter_num;
	unsigned int rx_q_cnt;
	unsigned int tx_q_cnt;
	unsigned int rx_ch_cnt;
	unsigned int tx_ch_cnt;
	unsigned int pps_out_num;
	unsigned int aux_snap_num;
};

struct xgbe_phy {
	struct ethtool_link_ksettings lks;
	int address;
	int autoneg;
	int speed;
	int duplex;
	int link;
	int pause_autoneg;
	int tx_pause;
	int rx_pause;
};

struct xgbe_i2c_op_state {
	struct xgbe_i2c_op *op;
	unsigned int tx_len;
	unsigned char *tx_buf;
	unsigned int rx_len;
	unsigned char *rx_buf;
	unsigned int tx_abort_source;
	int ret;
};

struct xgbe_i2c {
	unsigned int started;
	unsigned int max_speed_mode;
	unsigned int rx_fifo_size;
	unsigned int tx_fifo_size;
	struct xgbe_i2c_op_state op_state;
};

struct xgbe_version_data;

struct xgbe_prv_data {
	struct net_device *netdev;
	struct pci_dev *pcidev;
	struct platform_device *platdev;
	struct acpi_device *adev;
	struct device *dev;
	struct platform_device *phy_platdev;
	struct device *phy_dev;
	struct xgbe_version_data *vdata;
	unsigned int use_acpi;
	void *xgmac_regs;
	void *xpcs_regs;
	void *rxtx_regs;
	void *sir0_regs;
	void *sir1_regs;
	void *xprop_regs;
	void *xi2c_regs;
	unsigned int pp0;
	unsigned int pp1;
	unsigned int pp2;
	unsigned int pp3;
	unsigned int pp4;
	spinlock_t lock;
	spinlock_t xpcs_lock;
	unsigned int xpcs_window_def_reg;
	unsigned int xpcs_window_sel_reg;
	unsigned int xpcs_window;
	unsigned int xpcs_window_size;
	unsigned int xpcs_window_mask;
	struct mutex rss_mutex;
	unsigned long dev_state;
	unsigned long tx_sec_period;
	unsigned long tx_ded_period;
	unsigned long rx_sec_period;
	unsigned long rx_ded_period;
	unsigned long desc_sec_period;
	unsigned long desc_ded_period;
	unsigned int tx_sec_count;
	unsigned int tx_ded_count;
	unsigned int rx_sec_count;
	unsigned int rx_ded_count;
	unsigned int desc_ded_count;
	unsigned int desc_sec_count;
	int dev_irq;
	int ecc_irq;
	int i2c_irq;
	int channel_irq[16];
	unsigned int per_channel_irq;
	unsigned int irq_count;
	unsigned int channel_irq_count;
	unsigned int channel_irq_mode;
	char ecc_name[48];
	struct xgbe_hw_if hw_if;
	struct xgbe_phy_if phy_if;
	struct xgbe_desc_if desc_if;
	struct xgbe_i2c_if i2c_if;
	unsigned int coherent;
	unsigned int arcr;
	unsigned int awcr;
	unsigned int awarcr;
	struct workqueue_struct *dev_workqueue;
	struct work_struct service_work;
	struct timer_list service_timer;
	struct xgbe_channel *channel[16];
	unsigned int tx_max_channel_count;
	unsigned int rx_max_channel_count;
	unsigned int channel_count;
	unsigned int tx_ring_count;
	unsigned int tx_desc_count;
	unsigned int rx_ring_count;
	unsigned int rx_desc_count;
	unsigned int new_tx_ring_count;
	unsigned int new_rx_ring_count;
	unsigned int tx_max_q_count;
	unsigned int rx_max_q_count;
	unsigned int tx_q_count;
	unsigned int rx_q_count;
	unsigned int blen;
	unsigned int pbl;
	unsigned int aal;
	unsigned int rd_osr_limit;
	unsigned int wr_osr_limit;
	unsigned int tx_sf_mode;
	unsigned int tx_threshold;
	unsigned int tx_osp_mode;
	unsigned int tx_max_fifo_size;
	unsigned int rx_sf_mode;
	unsigned int rx_threshold;
	unsigned int rx_max_fifo_size;
	unsigned int tx_usecs;
	unsigned int tx_frames;
	unsigned int rx_riwt;
	unsigned int rx_usecs;
	unsigned int rx_frames;
	unsigned int rx_buf_size;
	unsigned int pause_autoneg;
	unsigned int tx_pause;
	unsigned int rx_pause;
	unsigned int rx_rfa[16];
	unsigned int rx_rfd[16];
	u8 rss_key[40];
	u32 rss_table[256];
	u32 rss_options;
	u16 vxlan_port;
	unsigned char mac_addr[6];
	netdev_features_t netdev_features;
	struct napi_struct napi;
	struct xgbe_mmc_stats mmc_stats;
	struct xgbe_ext_stats ext_stats;
	unsigned long active_vlans[64];
	struct clk *sysclk;
	unsigned long sysclk_rate;
	struct clk *ptpclk;
	unsigned long ptpclk_rate;
	spinlock_t tstamp_lock;
	struct ptp_clock_info ptp_clock_info;
	struct ptp_clock *ptp_clock;
	struct hwtstamp_config tstamp_config;
	struct cyclecounter tstamp_cc;
	struct timecounter tstamp_tc;
	unsigned int tstamp_addend;
	struct work_struct tx_tstamp_work;
	struct sk_buff *tx_tstamp_skb;
	u64 tx_tstamp;
	struct ieee_ets *ets;
	struct ieee_pfc *pfc;
	unsigned int q2tc_map[16];
	unsigned int prio2q_map[8];
	unsigned int pfcq[16];
	unsigned int pfc_rfa;
	u8 num_tcs;
	struct xgbe_hw_features hw_feat;
	struct work_struct restart_work;
	struct work_struct stopdev_work;
	unsigned int power_down;
	u32 msg_enable;
	phy_interface_t phy_mode;
	int phy_link;
	int phy_speed;
	unsigned int phy_started;
	void *phy_data;
	struct xgbe_phy phy;
	int mdio_mmd;
	unsigned long link_check;
	struct completion mdio_complete;
	unsigned int kr_redrv;
	char an_name[48];
	struct workqueue_struct *an_workqueue;
	int an_irq;
	struct work_struct an_irq_work;
	unsigned int an_int;
	unsigned int an_status;
	struct mutex an_mutex;
	enum xgbe_an an_result;
	enum xgbe_an an_state;
	enum xgbe_rx kr_state;
	enum xgbe_rx kx_state;
	struct work_struct an_work;
	unsigned int an_again;
	unsigned int an_supported;
	unsigned int parallel_detect;
	unsigned int fec_ability;
	unsigned long an_start;
	unsigned long kr_start_time;
	enum xgbe_an_mode an_mode;
	struct xgbe_i2c i2c;
	struct mutex i2c_mutex;
	struct completion i2c_complete;
	char i2c_name[48];
	unsigned int lpm_ctrl;
	unsigned int isr_as_tasklet;
	struct tasklet_struct tasklet_dev;
	struct tasklet_struct tasklet_ecc;
	struct tasklet_struct tasklet_i2c;
	struct tasklet_struct tasklet_an;
	struct dentry *xgbe_debugfs;
	unsigned int debugfs_xgmac_reg;
	unsigned int debugfs_xpcs_mmd;
	unsigned int debugfs_xpcs_reg;
	unsigned int debugfs_xprop_reg;
	unsigned int debugfs_xi2c_reg;
	bool debugfs_an_cdr_workaround;
	bool debugfs_an_cdr_track_early;
	bool en_rx_adap;
	int rx_adapt_retries;
	bool rx_adapt_done;
	bool mode_set;
};

struct xgbe_version_data {
	void (*init_function_ptrs_phy_impl)(struct xgbe_phy_if *);
	enum xgbe_xpcs_access xpcs_access;
	unsigned int mmc_64bit;
	unsigned int tx_max_fifo_size;
	unsigned int rx_max_fifo_size;
	unsigned int tx_tstamp_workaround;
	unsigned int ecc_support;
	unsigned int i2c_support;
	unsigned int irq_reissue_support;
	unsigned int tx_desc_prefetch;
	unsigned int rx_desc_prefetch;
	unsigned int an_cdr_workaround;
	unsigned int enable_rrc;
};

struct xgbe_ring_desc {
	__le32 desc0;
	__le32 desc1;
	__le32 desc2;
	__le32 desc3;
};

struct xgbe_channel {
	char name[16];
	struct xgbe_prv_data *pdata;
	unsigned int queue_index;
	void *dma_regs;
	int dma_irq;
	char dma_irq_name[48];
	struct napi_struct napi;
	unsigned int curr_ier;
	unsigned int saved_ier;
	unsigned int tx_timer_active;
	struct timer_list tx_timer;
	struct xgbe_ring *tx_ring;
	struct xgbe_ring *rx_ring;
	int node;
	cpumask_t affinity_mask;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xgbe_packet_data {
	struct sk_buff *skb;
	unsigned int attributes;
	unsigned int errors;
	unsigned int rdesc_count;
	unsigned int length;
	unsigned int header_len;
	unsigned int tcp_header_len;
	unsigned int tcp_payload_len;
	unsigned short mss;
	unsigned short vlan_ctag;
	u64 rx_tstamp;
	u32 rss_hash;
	enum pkt_hash_types rss_hash_type;
	unsigned int tx_packets;
	unsigned int tx_bytes;
};

struct xgbe_page_alloc {
	struct page *pages;
	unsigned int pages_len;
	unsigned int pages_offset;
	dma_addr_t pages_dma;
};

struct xgbe_ring {
	spinlock_t lock;
	struct xgbe_packet_data packet_data;
	struct xgbe_ring_desc *rdesc;
	dma_addr_t rdesc_dma;
	unsigned int rdesc_count;
	struct xgbe_ring_data *rdata;
	struct xgbe_page_alloc rx_hdr_pa;
	struct xgbe_page_alloc rx_buf_pa;
	int node;
	unsigned int cur;
	unsigned int dirty;
	unsigned int coalesce_count;
	union {
		struct {
			unsigned int queue_stopped;
			unsigned int xmit_more;
			unsigned short cur_mss;
			unsigned short cur_vlan_ctag;
		} tx;
	};
	long: 64;
};

struct xgbe_tx_ring_data {
	unsigned int packets;
	unsigned int bytes;
};

struct xgbe_buffer_data {
	struct xgbe_page_alloc pa;
	struct xgbe_page_alloc pa_unmap;
	dma_addr_t dma_base;
	unsigned long dma_off;
	unsigned int dma_len;
};

struct xgbe_rx_ring_data {
	struct xgbe_buffer_data hdr;
	struct xgbe_buffer_data buf;
	unsigned short hdr_len;
	unsigned short len;
};

struct xgbe_ring_data {
	struct xgbe_ring_desc *rdesc;
	dma_addr_t rdesc_dma;
	struct sk_buff *skb;
	dma_addr_t skb_dma;
	unsigned int skb_dma_len;
	struct xgbe_tx_ring_data tx;
	struct xgbe_rx_ring_data rx;
	unsigned int mapped_as_page;
	unsigned int state_saved;
	struct {
		struct sk_buff *skb;
		unsigned int len;
		unsigned int error;
	} state;
};

struct xgbe_i2c_op {
	enum xgbe_i2c_cmd cmd;
	unsigned int target;
	void *buf;
	unsigned int len;
};

struct xgbe_phy_data {
	enum xgbe_port_mode port_mode;
	unsigned int port_id;
	unsigned int port_speeds;
	enum xgbe_conn_type conn_type;
	enum xgbe_mode cur_mode;
	enum xgbe_mode start_mode;
	unsigned int rrc_count;
	unsigned int mdio_addr;
	enum xgbe_sfp_comm sfp_comm;
	unsigned int sfp_mux_address;
	unsigned int sfp_mux_channel;
	unsigned int sfp_gpio_address;
	unsigned int sfp_gpio_mask;
	unsigned int sfp_gpio_inputs;
	unsigned int sfp_gpio_rx_los;
	unsigned int sfp_gpio_tx_fault;
	unsigned int sfp_gpio_mod_absent;
	unsigned int sfp_gpio_rate_select;
	unsigned int sfp_rx_los;
	unsigned int sfp_tx_fault;
	unsigned int sfp_mod_absent;
	unsigned int sfp_changed;
	unsigned int sfp_phy_avail;
	unsigned int sfp_cable_len;
	enum xgbe_sfp_base sfp_base;
	enum xgbe_sfp_cable sfp_cable;
	enum xgbe_sfp_speed sfp_speed;
	struct xgbe_sfp_eeprom sfp_eeprom;
	enum xgbe_mdio_mode phydev_mode;
	struct mii_bus *mii;
	struct phy_device *phydev;
	enum xgbe_mdio_reset mdio_reset;
	unsigned int mdio_reset_addr;
	unsigned int mdio_reset_gpio;
	unsigned int redrv;
	unsigned int redrv_if;
	unsigned int redrv_addr;
	unsigned int redrv_lane;
	unsigned int redrv_model;
	unsigned int phy_cdr_notrack;
	unsigned int phy_cdr_delay;
};

struct dsa_device_ops;

struct dsa_switch_tree;

struct dsa_switch;

struct dsa_bridge;

struct dsa_lag;

struct dsa_port {
	union {
		struct net_device *conduit;
		struct net_device *user;
	};
	const struct dsa_device_ops *tag_ops;
	struct dsa_switch_tree *dst;
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *);
	struct dsa_switch *ds;
	unsigned int index;
	enum {
		DSA_PORT_TYPE_UNUSED = 0,
		DSA_PORT_TYPE_CPU = 1,
		DSA_PORT_TYPE_DSA = 2,
		DSA_PORT_TYPE_USER = 3,
	} type;
	const char *name;
	struct dsa_port *cpu_dp;
	u8 mac[6];
	u8 stp_state;
	u8 vlan_filtering: 1;
	u8 learning: 1;
	u8 lag_tx_enabled: 1;
	u8 conduit_admin_up: 1;
	u8 conduit_oper_up: 1;
	u8 cpu_port_in_lag: 1;
	u8 setup: 1;
	struct device_node *dn;
	unsigned int ageing_time;
	struct dsa_bridge *bridge;
	struct devlink_port devlink_port;
	struct phylink *pl;
	struct phylink_config pl_config;
	struct dsa_lag *lag;
	struct net_device *hsr_dev;
	struct list_head list;
	const struct ethtool_ops *orig_ethtool_ops;
	struct mutex addr_lists_lock;
	struct list_head fdbs;
	struct list_head mdbs;
	struct mutex vlans_lock;
	union {
		struct list_head vlans;
		struct list_head user_vlans;
	};
};

enum dsa_tag_protocol {
	DSA_TAG_PROTO_NONE = 0,
	DSA_TAG_PROTO_BRCM = 1,
	DSA_TAG_PROTO_BRCM_LEGACY = 22,
	DSA_TAG_PROTO_BRCM_PREPEND = 2,
	DSA_TAG_PROTO_DSA = 3,
	DSA_TAG_PROTO_EDSA = 4,
	DSA_TAG_PROTO_GSWIP = 5,
	DSA_TAG_PROTO_KSZ9477 = 6,
	DSA_TAG_PROTO_KSZ9893 = 7,
	DSA_TAG_PROTO_LAN9303 = 8,
	DSA_TAG_PROTO_MTK = 9,
	DSA_TAG_PROTO_QCA = 10,
	DSA_TAG_PROTO_TRAILER = 11,
	DSA_TAG_PROTO_8021Q = 12,
	DSA_TAG_PROTO_SJA1105 = 13,
	DSA_TAG_PROTO_KSZ8795 = 14,
	DSA_TAG_PROTO_OCELOT = 15,
	DSA_TAG_PROTO_AR9331 = 16,
	DSA_TAG_PROTO_RTL4_A = 17,
	DSA_TAG_PROTO_HELLCREEK = 18,
	DSA_TAG_PROTO_XRS700X = 19,
	DSA_TAG_PROTO_OCELOT_8021Q = 20,
	DSA_TAG_PROTO_SEVILLE = 21,
	DSA_TAG_PROTO_SJA1110 = 23,
	DSA_TAG_PROTO_RTL8_4 = 24,
	DSA_TAG_PROTO_RTL8_4T = 25,
	DSA_TAG_PROTO_RZN1_A5PSW = 26,
	DSA_TAG_PROTO_LAN937X = 27,
};

struct dsa_device_ops {
	struct sk_buff * (*xmit)(struct sk_buff *, struct net_device *);
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *);
	void (*flow_dissect)(const struct sk_buff *, __be16 *, int *);
	int (*connect)(struct dsa_switch *);
	void (*disconnect)(struct dsa_switch *);
	unsigned int needed_headroom;
	unsigned int needed_tailroom;
	const char *name;
	enum dsa_tag_protocol proto;
	bool promisc_on_conduit;
};

struct dsa_8021q_context;

struct dsa_chip_data;

struct dsa_switch_ops;

struct dsa_switch {
	struct device *dev;
	struct dsa_switch_tree *dst;
	unsigned int index;
	u32 setup: 1;
	u32 vlan_filtering_is_global: 1;
	u32 needs_standalone_vlan_filtering: 1;
	u32 configure_vlan_while_not_filtering: 1;
	u32 untag_bridge_pvid: 1;
	u32 assisted_learning_on_cpu_port: 1;
	u32 vlan_filtering: 1;
	u32 mtu_enforcement_ingress: 1;
	u32 fdb_isolation: 1;
	struct notifier_block nb;
	void *priv;
	void *tagger_data;
	struct dsa_chip_data *cd;
	const struct dsa_switch_ops *ops;
	u32 phys_mii_mask;
	struct mii_bus *user_mii_bus;
	unsigned int ageing_time_min;
	unsigned int ageing_time_max;
	struct dsa_8021q_context *tag_8021q_ctx;
	struct devlink *devlink;
	unsigned int num_tx_queues;
	unsigned int num_lag_ids;
	unsigned int max_num_bridges;
	unsigned int num_ports;
};

struct dsa_platform_data;

struct dsa_switch_tree {
	struct list_head list;
	struct list_head ports;
	struct raw_notifier_head nh;
	unsigned int index;
	struct kref refcount;
	struct dsa_lag **lags;
	const struct dsa_device_ops *tag_ops;
	enum dsa_tag_protocol default_proto;
	bool setup;
	struct dsa_platform_data *pd;
	struct list_head rtable;
	unsigned int lags_len;
	unsigned int last_switch;
};

struct dsa_lag {
	struct net_device *dev;
	unsigned int id;
	struct mutex fdb_lock;
	struct list_head fdbs;
	refcount_t refcount;
};

struct dsa_platform_data {
	struct device *netdev;
	struct net_device *of_netdev;
	int nr_chips;
	struct dsa_chip_data *chip;
};

struct dsa_chip_data {
	struct device *host_dev;
	int sw_addr;
	struct device *netdev[12];
	int eeprom_len;
	struct device_node *of_node;
	char *port_names[12];
	struct device_node *port_dn[12];
	s8 rtable[4];
};

typedef int dsa_fdb_dump_cb_t(const unsigned char *, u16, bool, void *);

struct fixed_phy_status;

struct netdev_notifier_changeupper_info;

struct switchdev_mst_state;

struct switchdev_brport_flags;

struct switchdev_obj_port_vlan;

struct switchdev_vlan_msti;

struct dsa_db;

struct switchdev_obj_port_mdb;

struct dsa_mall_mirror_tc_entry;

struct dsa_mall_policer_tc_entry;

struct netdev_lag_upper_info;

struct devlink_param_gset_ctx;

struct switchdev_obj_mrp;

struct switchdev_obj_ring_role_mrp;

struct dsa_switch_ops {
	enum dsa_tag_protocol (*get_tag_protocol)(struct dsa_switch *, int, enum dsa_tag_protocol);
	int (*change_tag_protocol)(struct dsa_switch *, enum dsa_tag_protocol);
	int (*connect_tag_protocol)(struct dsa_switch *, enum dsa_tag_protocol);
	int (*port_change_conduit)(struct dsa_switch *, int, struct net_device *, struct netlink_ext_ack *);
	int (*setup)(struct dsa_switch *);
	void (*teardown)(struct dsa_switch *);
	int (*port_setup)(struct dsa_switch *, int);
	void (*port_teardown)(struct dsa_switch *, int);
	u32 (*get_phy_flags)(struct dsa_switch *, int);
	int (*phy_read)(struct dsa_switch *, int, int);
	int (*phy_write)(struct dsa_switch *, int, int, u16);
	void (*adjust_link)(struct dsa_switch *, int, struct phy_device *);
	void (*fixed_link_update)(struct dsa_switch *, int, struct fixed_phy_status *);
	void (*phylink_get_caps)(struct dsa_switch *, int, struct phylink_config *);
	struct phylink_pcs * (*phylink_mac_select_pcs)(struct dsa_switch *, int, phy_interface_t);
	int (*phylink_mac_prepare)(struct dsa_switch *, int, unsigned int, phy_interface_t);
	void (*phylink_mac_config)(struct dsa_switch *, int, unsigned int, const struct phylink_link_state *);
	int (*phylink_mac_finish)(struct dsa_switch *, int, unsigned int, phy_interface_t);
	void (*phylink_mac_link_down)(struct dsa_switch *, int, unsigned int, phy_interface_t);
	void (*phylink_mac_link_up)(struct dsa_switch *, int, unsigned int, phy_interface_t, struct phy_device *, int, int, bool, bool);
	void (*phylink_fixed_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*get_strings)(struct dsa_switch *, int, u32, uint8_t *);
	void (*get_ethtool_stats)(struct dsa_switch *, int, uint64_t *);
	int (*get_sset_count)(struct dsa_switch *, int, int);
	void (*get_ethtool_phy_stats)(struct dsa_switch *, int, uint64_t *);
	void (*get_eth_phy_stats)(struct dsa_switch *, int, struct ethtool_eth_phy_stats *);
	void (*get_eth_mac_stats)(struct dsa_switch *, int, struct ethtool_eth_mac_stats *);
	void (*get_eth_ctrl_stats)(struct dsa_switch *, int, struct ethtool_eth_ctrl_stats *);
	void (*get_rmon_stats)(struct dsa_switch *, int, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
	void (*get_stats64)(struct dsa_switch *, int, struct rtnl_link_stats64 *);
	void (*get_pause_stats)(struct dsa_switch *, int, struct ethtool_pause_stats *);
	void (*self_test)(struct dsa_switch *, int, struct ethtool_test *, u64 *);
	void (*get_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*set_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*get_ts_info)(struct dsa_switch *, int, struct ethtool_ts_info *);
	int (*get_mm)(struct dsa_switch *, int, struct ethtool_mm_state *);
	int (*set_mm)(struct dsa_switch *, int, struct ethtool_mm_cfg *, struct netlink_ext_ack *);
	void (*get_mm_stats)(struct dsa_switch *, int, struct ethtool_mm_stats *);
	int (*port_get_default_prio)(struct dsa_switch *, int);
	int (*port_set_default_prio)(struct dsa_switch *, int, u8);
	int (*port_get_dscp_prio)(struct dsa_switch *, int, u8);
	int (*port_add_dscp_prio)(struct dsa_switch *, int, u8, u8);
	int (*port_del_dscp_prio)(struct dsa_switch *, int, u8, u8);
	int (*suspend)(struct dsa_switch *);
	int (*resume)(struct dsa_switch *);
	int (*port_enable)(struct dsa_switch *, int, struct phy_device *);
	void (*port_disable)(struct dsa_switch *, int);
	int (*port_set_mac_address)(struct dsa_switch *, int, const unsigned char *);
	struct dsa_port * (*preferred_default_local_cpu_port)(struct dsa_switch *);
	int (*set_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_eeprom_len)(struct dsa_switch *);
	int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*get_regs_len)(struct dsa_switch *, int);
	void (*get_regs)(struct dsa_switch *, int, struct ethtool_regs *, void *);
	int (*port_prechangeupper)(struct dsa_switch *, int, struct netdev_notifier_changeupper_info *);
	int (*set_ageing_time)(struct dsa_switch *, unsigned int);
	int (*port_bridge_join)(struct dsa_switch *, int, struct dsa_bridge, bool *, struct netlink_ext_ack *);
	void (*port_bridge_leave)(struct dsa_switch *, int, struct dsa_bridge);
	void (*port_stp_state_set)(struct dsa_switch *, int, u8);
	int (*port_mst_state_set)(struct dsa_switch *, int, const struct switchdev_mst_state *);
	void (*port_fast_age)(struct dsa_switch *, int);
	int (*port_vlan_fast_age)(struct dsa_switch *, int, u16);
	int (*port_pre_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
	int (*port_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
	void (*port_set_host_flood)(struct dsa_switch *, int, bool, bool);
	int (*port_vlan_filtering)(struct dsa_switch *, int, bool, struct netlink_ext_ack *);
	int (*port_vlan_add)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *, struct netlink_ext_ack *);
	int (*port_vlan_del)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *);
	int (*vlan_msti_set)(struct dsa_switch *, struct dsa_bridge, const struct switchdev_vlan_msti *);
	int (*port_fdb_add)(struct dsa_switch *, int, const unsigned char *, u16, struct dsa_db);
	int (*port_fdb_del)(struct dsa_switch *, int, const unsigned char *, u16, struct dsa_db);
	int (*port_fdb_dump)(struct dsa_switch *, int, dsa_fdb_dump_cb_t *, void *);
	int (*lag_fdb_add)(struct dsa_switch *, struct dsa_lag, const unsigned char *, u16, struct dsa_db);
	int (*lag_fdb_del)(struct dsa_switch *, struct dsa_lag, const unsigned char *, u16, struct dsa_db);
	int (*port_mdb_add)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *, struct dsa_db);
	int (*port_mdb_del)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *, struct dsa_db);
	int (*get_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *);
	int (*cls_flower_add)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_del)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_stats)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*port_mirror_add)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *, bool, struct netlink_ext_ack *);
	void (*port_mirror_del)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *);
	int (*port_policer_add)(struct dsa_switch *, int, struct dsa_mall_policer_tc_entry *);
	void (*port_policer_del)(struct dsa_switch *, int);
	int (*port_setup_tc)(struct dsa_switch *, int, enum tc_setup_type, void *);
	int (*crosschip_bridge_join)(struct dsa_switch *, int, int, int, struct dsa_bridge, struct netlink_ext_ack *);
	void (*crosschip_bridge_leave)(struct dsa_switch *, int, int, int, struct dsa_bridge);
	int (*crosschip_lag_change)(struct dsa_switch *, int, int);
	int (*crosschip_lag_join)(struct dsa_switch *, int, int, struct dsa_lag, struct netdev_lag_upper_info *, struct netlink_ext_ack *);
	int (*crosschip_lag_leave)(struct dsa_switch *, int, int, struct dsa_lag);
	int (*port_hwtstamp_get)(struct dsa_switch *, int, struct ifreq *);
	int (*port_hwtstamp_set)(struct dsa_switch *, int, struct ifreq *);
	void (*port_txtstamp)(struct dsa_switch *, int, struct sk_buff *);
	bool (*port_rxtstamp)(struct dsa_switch *, int, struct sk_buff *, unsigned int);
	int (*devlink_param_get)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_param_set)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_info_get)(struct dsa_switch *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*devlink_sb_pool_get)(struct dsa_switch *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*devlink_sb_pool_set)(struct dsa_switch *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*devlink_sb_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *);
	int (*devlink_sb_port_pool_set)(struct dsa_switch *, int, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*devlink_sb_tc_pool_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*devlink_sb_tc_pool_bind_set)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*devlink_sb_occ_snapshot)(struct dsa_switch *, unsigned int);
	int (*devlink_sb_occ_max_clear)(struct dsa_switch *, unsigned int);
	int (*devlink_sb_occ_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *, u32 *);
	int (*devlink_sb_occ_tc_port_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*port_change_mtu)(struct dsa_switch *, int, int);
	int (*port_max_mtu)(struct dsa_switch *, int);
	int (*port_lag_change)(struct dsa_switch *, int);
	int (*port_lag_join)(struct dsa_switch *, int, struct dsa_lag, struct netdev_lag_upper_info *, struct netlink_ext_ack *);
	int (*port_lag_leave)(struct dsa_switch *, int, struct dsa_lag);
	int (*port_hsr_join)(struct dsa_switch *, int, struct net_device *, struct netlink_ext_ack *);
	int (*port_hsr_leave)(struct dsa_switch *, int, struct net_device *);
	int (*port_mrp_add)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
	int (*port_mrp_del)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
	int (*port_mrp_add_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
	int (*port_mrp_del_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
	int (*tag_8021q_vlan_add)(struct dsa_switch *, int, u16, u16);
	int (*tag_8021q_vlan_del)(struct dsa_switch *, int, u16);
	void (*conduit_state_change)(struct dsa_switch *, const struct net_device *, bool);
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

struct dsa_bridge {
	struct net_device *dev;
	unsigned int num;
	bool tx_fwd_offload;
	refcount_t refcount;
};

struct switchdev_mst_state {
	u16 msti;
	u8 state;
};

struct switchdev_brport_flags {
	unsigned long val;
	unsigned long mask;
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
	SWITCHDEV_OBJ_ID_MRP = 4,
	SWITCHDEV_OBJ_ID_RING_TEST_MRP = 5,
	SWITCHDEV_OBJ_ID_RING_ROLE_MRP = 6,
	SWITCHDEV_OBJ_ID_RING_STATE_MRP = 7,
	SWITCHDEV_OBJ_ID_IN_TEST_MRP = 8,
	SWITCHDEV_OBJ_ID_IN_ROLE_MRP = 9,
	SWITCHDEV_OBJ_ID_IN_STATE_MRP = 10,
};

struct switchdev_obj {
	struct list_head list;
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
};

struct switchdev_obj_port_vlan {
	struct switchdev_obj obj;
	u16 flags;
	u16 vid;
	bool changed;
};

struct switchdev_vlan_msti {
	u16 vid;
	u16 msti;
};

enum dsa_db_type {
	DSA_DB_PORT = 0,
	DSA_DB_LAG = 1,
	DSA_DB_BRIDGE = 2,
};

struct dsa_db {
	enum dsa_db_type type;
	union {
		const struct dsa_port *dp;
		struct dsa_lag lag;
		struct dsa_bridge bridge;
	};
};

struct switchdev_obj_port_mdb {
	struct switchdev_obj obj;
	unsigned char addr[6];
	u16 vid;
};

struct dsa_mall_mirror_tc_entry {
	u8 to_local_port;
	bool ingress;
};

struct dsa_mall_policer_tc_entry {
	u32 burst;
	u64 rate_bytes_per_sec;
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_VLAN_SRCMAC = 6,
	NETDEV_LAG_HASH_UNKNOWN = 7,
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

union devlink_param_value {
	u8 vu8;
	u16 vu16;
	u32 vu32;
	char vstr[32];
	bool vbool;
};

enum devlink_param_cmode {
	DEVLINK_PARAM_CMODE_RUNTIME = 0,
	DEVLINK_PARAM_CMODE_DRIVERINIT = 1,
	DEVLINK_PARAM_CMODE_PERMANENT = 2,
	__DEVLINK_PARAM_CMODE_MAX = 3,
	DEVLINK_PARAM_CMODE_MAX = 2,
};

struct devlink_param_gset_ctx {
	union devlink_param_value val;
	enum devlink_param_cmode cmode;
};

struct switchdev_obj_mrp {
	struct switchdev_obj obj;
	struct net_device *p_port;
	struct net_device *s_port;
	u32 ring_id;
	u16 prio;
};

struct switchdev_obj_ring_role_mrp {
	struct switchdev_obj obj;
	u8 ring_role;
	u32 ring_id;
	u8 sw_backup;
};

struct bgmac_stat {
	u8 size;
	u32 offset;
	const char *name;
};

enum bcma_hosttype {
	BCMA_HOSTTYPE_PCI = 0,
	BCMA_HOSTTYPE_SDIO = 1,
	BCMA_HOSTTYPE_SOC = 2,
};

enum bgmac_dma_ring_type {
	BGMAC_DMA_RING_TX = 0,
	BGMAC_DMA_RING_RX = 1,
};

struct bgmac_slot_info {
	union {
		struct sk_buff *skb;
		void *buf;
	};
	dma_addr_t dma_addr;
};

struct bgmac_dma_desc;

struct bgmac_dma_ring {
	u32 start;
	u32 end;
	struct bgmac_dma_desc *cpu_base;
	dma_addr_t dma_base;
	u32 index_base;
	u16 mmio_base;
	bool unaligned;
	struct bgmac_slot_info slots[512];
};

struct bcma_device;

struct bgmac {
	union {
		struct {
			void *base;
			void *idm_base;
			void *nicpm_base;
		} plat;
		struct {
			struct bcma_device *core;
			struct bcma_device *cmn;
		} bcma;
	};
	struct device *dev;
	struct device *dma_dev;
	u32 feature_flags;
	struct net_device *net_dev;
	struct napi_struct napi;
	struct mii_bus *mii_bus;
	struct bgmac_dma_ring tx_ring[4];
	struct bgmac_dma_ring rx_ring[1];
	bool stats_grabbed;
	u32 mib_tx_regs[43];
	u32 mib_rx_regs[31];
	int irq;
	u32 int_mask;
	bool in_init;
	int mac_speed;
	int mac_duplex;
	u8 phyaddr;
	bool has_robosw;
	bool loopback;
	u32 (*read)(struct bgmac *, u16);
	void (*write)(struct bgmac *, u16, u32);
	u32 (*idm_read)(struct bgmac *, u16);
	void (*idm_write)(struct bgmac *, u16, u32);
	bool (*clk_enabled)(struct bgmac *);
	void (*clk_enable)(struct bgmac *, u32);
	void (*cco_ctl_maskset)(struct bgmac *, u32, u32, u32);
	u32 (*get_bus_clock)(struct bgmac *);
	void (*cmn_maskset32)(struct bgmac *, u16, u32, u32);
	int (*phy_connect)(struct bgmac *);
};

struct bcma_device_id {
	__u16 manuf;
	__u16 id;
	__u8 rev;
	__u8 class;
};

struct bcma_bus;

struct bcma_device {
	struct bcma_bus *bus;
	struct bcma_device_id id;
	struct device dev;
	struct device *dma_dev;
	unsigned int irq;
	bool dev_registered;
	u8 core_index;
	u8 core_unit;
	u32 addr;
	u32 addr_s[8];
	u32 wrap;
	void *io_addr;
	void *io_wrap;
	void *drvdata;
	struct list_head list;
};

struct bcma_chipinfo {
	u16 id;
	u8 rev;
	u8 pkg;
};

struct bcma_boardinfo {
	u16 vendor;
	u16 type;
};

struct bcma_chipcommon_pmu {
	struct bcma_device *core;
	u8 rev;
	u32 crystalfreq;
};

struct bcma_drv_cc {
	struct bcma_device *core;
	u32 status;
	u32 capabilities;
	u32 capabilities_ext;
	u8 setup_done: 1;
	u8 early_setup_done: 1;
	u16 fast_pwrup_delay;
	struct bcma_chipcommon_pmu pmu;
	u32 ticks_per_ms;
	struct platform_device *watchdog;
	spinlock_t gpio_lock;
};

struct bcma_drv_cc_b {
	struct bcma_device *core;
	u8 setup_done: 1;
	void *mii;
};

struct bcma_drv_pci {
	struct bcma_device *core;
	u8 early_setup_done: 1;
	u8 setup_done: 1;
	u8 hostmode: 1;
};

struct bcma_drv_pcie2 {
	struct bcma_device *core;
	u16 reqsize;
};

struct bcma_drv_mips {
	struct bcma_device *core;
	u8 setup_done: 1;
	u8 early_setup_done: 1;
};

struct bcma_drv_gmac_cmn {
	struct bcma_device *core;
	struct mutex phy_mutex;
};

struct ssb_sprom_core_pwr_info {
	u8 itssi_2g;
	u8 itssi_5g;
	u8 maxpwr_2g;
	u8 maxpwr_5gl;
	u8 maxpwr_5g;
	u8 maxpwr_5gh;
	u16 pa_2g[4];
	u16 pa_5gl[4];
	u16 pa_5g[4];
	u16 pa_5gh[4];
};

struct ssb_sprom {
	u8 revision;
	short: 0;
	u8 il0mac[6];
	u8 et0mac[6];
	u8 et1mac[6];
	u8 et2mac[6];
	u8 et0phyaddr;
	u8 et1phyaddr;
	u8 et2phyaddr;
	u8 et0mdcport;
	u8 et1mdcport;
	u8 et2mdcport;
	u16 dev_id;
	u16 board_rev;
	u16 board_num;
	u16 board_type;
	u8 country_code;
	char alpha2[2];
	u8 leddc_on_time;
	u8 leddc_off_time;
	u8 ant_available_a;
	u8 ant_available_bg;
	u16 pa0b0;
	u16 pa0b1;
	u16 pa0b2;
	u16 pa1b0;
	u16 pa1b1;
	u16 pa1b2;
	u16 pa1lob0;
	u16 pa1lob1;
	u16 pa1lob2;
	u16 pa1hib0;
	u16 pa1hib1;
	u16 pa1hib2;
	u8 gpio0;
	u8 gpio1;
	u8 gpio2;
	u8 gpio3;
	u8 maxpwr_bg;
	u8 maxpwr_al;
	u8 maxpwr_a;
	u8 maxpwr_ah;
	u8 itssi_a;
	u8 itssi_bg;
	u8 tri2g;
	u8 tri5gl;
	u8 tri5g;
	u8 tri5gh;
	u8 txpid2g[4];
	u8 txpid5gl[4];
	u8 txpid5g[4];
	u8 txpid5gh[4];
	s8 rxpo2g;
	s8 rxpo5g;
	u8 rssisav2g;
	u8 rssismc2g;
	u8 rssismf2g;
	u8 bxa2g;
	u8 rssisav5g;
	u8 rssismc5g;
	u8 rssismf5g;
	u8 bxa5g;
	u16 cck2gpo;
	u32 ofdm2gpo;
	u32 ofdm5glpo;
	u32 ofdm5gpo;
	u32 ofdm5ghpo;
	u32 boardflags;
	u32 boardflags2;
	u32 boardflags3;
	u16 boardflags_lo;
	u16 boardflags_hi;
	u16 boardflags2_lo;
	u16 boardflags2_hi;
	struct ssb_sprom_core_pwr_info core_pwr_info[4];
	struct {
		s8 a0;
		s8 a1;
		s8 a2;
		s8 a3;
	} antenna_gain;
	struct {
		struct {
			u8 tssipos;
			u8 extpa_gain;
			u8 pdet_range;
			u8 tr_iso;
			u8 antswlut;
		} ghz2;
		struct {
			u8 tssipos;
			u8 extpa_gain;
			u8 pdet_range;
			u8 tr_iso;
			u8 antswlut;
		} ghz5;
	} fem;
	u16 mcs2gpo[8];
	u16 mcs5gpo[8];
	u16 mcs5glpo[8];
	u16 mcs5ghpo[8];
	u8 opo;
	u8 rxgainerr2ga[3];
	u8 rxgainerr5gla[3];
	u8 rxgainerr5gma[3];
	u8 rxgainerr5gha[3];
	u8 rxgainerr5gua[3];
	u8 noiselvl2ga[3];
	u8 noiselvl5gla[3];
	u8 noiselvl5gma[3];
	u8 noiselvl5gha[3];
	u8 noiselvl5gua[3];
	u8 regrev;
	u8 txchain;
	u8 rxchain;
	u8 antswitch;
	u16 cddpo;
	u16 stbcpo;
	u16 bw40po;
	u16 bwduppo;
	u8 tempthresh;
	u8 tempoffset;
	u16 rawtempsense;
	u8 measpower;
	u8 tempsense_slope;
	u8 tempcorrx;
	u8 tempsense_option;
	u8 freqoffset_corr;
	u8 iqcal_swp_dis;
	u8 hw_iqcal_en;
	u8 elna2g;
	u8 elna5g;
	u8 phycal_tempdelta;
	u8 temps_period;
	u8 temps_hysteresis;
	u8 measpower1;
	u8 measpower2;
	u8 pcieingress_war;
	u16 cckbw202gpo;
	u16 cckbw20ul2gpo;
	u32 legofdmbw202gpo;
	u32 legofdmbw20ul2gpo;
	u32 legofdmbw205glpo;
	u32 legofdmbw20ul5glpo;
	u32 legofdmbw205gmpo;
	u32 legofdmbw20ul5gmpo;
	u32 legofdmbw205ghpo;
	u32 legofdmbw20ul5ghpo;
	u32 mcsbw202gpo;
	u32 mcsbw20ul2gpo;
	u32 mcsbw402gpo;
	u32 mcsbw205glpo;
	u32 mcsbw20ul5glpo;
	u32 mcsbw405glpo;
	u32 mcsbw205gmpo;
	u32 mcsbw20ul5gmpo;
	u32 mcsbw405gmpo;
	u32 mcsbw205ghpo;
	u32 mcsbw20ul5ghpo;
	u32 mcsbw405ghpo;
	u16 mcs32po;
	u16 legofdm40duppo;
	u8 sar2g;
	u8 sar5g;
};

struct bcma_host_ops;

struct bcma_bus {
	struct device *dev;
	void *mmio;
	const struct bcma_host_ops *ops;
	enum bcma_hosttype hosttype;
	bool host_is_pcie2;
	struct pci_dev *host_pci;
	struct bcma_chipinfo chipinfo;
	struct bcma_boardinfo boardinfo;
	struct bcma_device *mapped_core;
	struct list_head cores;
	u8 nr_cores;
	u8 num;
	struct bcma_drv_cc drv_cc;
	struct bcma_drv_cc_b drv_cc_b;
	struct bcma_drv_pci drv_pci[2];
	struct bcma_drv_pcie2 drv_pcie2;
	struct bcma_drv_mips drv_mips;
	struct bcma_drv_gmac_cmn drv_gmac_cmn;
	struct ssb_sprom sprom;
};

struct bcma_host_ops {
	u8 (*read8)(struct bcma_device *, u16);
	u16 (*read16)(struct bcma_device *, u16);
	u32 (*read32)(struct bcma_device *, u16);
	void (*write8)(struct bcma_device *, u16, u8);
	void (*write16)(struct bcma_device *, u16, u16);
	void (*write32)(struct bcma_device *, u16, u32);
	u32 (*aread32)(struct bcma_device *, u16);
	void (*awrite32)(struct bcma_device *, u16, u32);
};

struct bgmac_dma_desc {
	__le32 ctl0;
	__le32 ctl1;
	__le32 addr_low;
	__le32 addr_high;
};

struct bgmac_rx_header {
	__le16 len;
	__le16 flags;
	__le16 pad[12];
};

enum ptp_clock_events {
	PTP_CLOCK_ALARM = 0,
	PTP_CLOCK_EXTTS = 1,
	PTP_CLOCK_PPS = 2,
	PTP_CLOCK_PPSUSR = 3,
};

struct ctrl_regs;

struct alarm_regs;

struct fiper_regs;

struct etts_regs;

struct ptp_qoriq_registers {
	struct ctrl_regs *ctrl_regs;
	struct alarm_regs *alarm_regs;
	struct fiper_regs *fiper_regs;
	struct etts_regs *etts_regs;
};

struct ptp_qoriq {
	void *base;
	struct ptp_qoriq_registers regs;
	spinlock_t lock;
	struct ptp_clock *clock;
	struct ptp_clock_info caps;
	struct resource *rsrc;
	struct dentry *debugfs_root;
	struct device *dev;
	bool extts_fifo_support;
	bool fiper3_support;
	bool etsec;
	int irq;
	int phc_index;
	u32 tclk_period;
	u32 tmr_prsc;
	u32 tmr_add;
	u32 cksel;
	u32 tmr_fiper1;
	u32 tmr_fiper2;
	u32 tmr_fiper3;
	u32 (*read)(unsigned int *);
	void (*write)(unsigned int *, u32);
};

struct ctrl_regs {
	u32 tmr_ctrl;
	u32 tmr_tevent;
	u32 tmr_temask;
	u32 tmr_pevent;
	u32 tmr_pemask;
	u32 tmr_stat;
	u32 tmr_cnt_h;
	u32 tmr_cnt_l;
	u32 tmr_add;
	u32 tmr_acc;
	u32 tmr_prsc;
	u8 res1[4];
	u32 tmroff_h;
	u32 tmroff_l;
};

struct alarm_regs {
	u32 tmr_alarm1_h;
	u32 tmr_alarm1_l;
	u32 tmr_alarm2_h;
	u32 tmr_alarm2_l;
};

struct fiper_regs {
	u32 tmr_fiper1;
	u32 tmr_fiper2;
	u32 tmr_fiper3;
};

struct etts_regs {
	u32 tmr_etts1_h;
	u32 tmr_etts1_l;
	u32 tmr_etts2_h;
	u32 tmr_etts2_l;
};

struct pps_event_time {
	struct timespec64 ts_real;
};

struct ptp_clock_event {
	int type;
	int index;
	union {
		u64 timestamp;
		struct pps_event_time pps_times;
	};
};

enum mdio_c22_op_seq {
	MDIO_C22_WRITE = 1,
	MDIO_C22_READ = 2,
};

enum mdio_st_clause {
	MDIO_ST_CLAUSE_45 = 0,
	MDIO_ST_CLAUSE_22 = 1,
};

enum mdio_c45_op_seq {
	MDIO_C45_WRITE_ADDR = 0,
	MDIO_C45_WRITE_DATA = 1,
	MDIO_C45_READ_INCREMENT = 2,
	MDIO_C45_READ = 3,
};

struct hns_mdio_sc_reg {
	u16 mdio_clk_en;
	u16 mdio_clk_dis;
	u16 mdio_reset_req;
	u16 mdio_reset_dreq;
	u16 mdio_clk_st;
	u16 mdio_reset_st;
};

struct hns_mdio_device {
	u8 *vbase;
	struct regmap *subctrl_vbase;
	struct hns_mdio_sc_reg sc_reg;
};

enum e1000_state_t {
	__E1000_TESTING = 0,
	__E1000_RESETTING = 1,
	__E1000_DOWN = 2,
	__E1000_DISABLED = 3,
};

enum {
	e1000_10_half = 0,
	e1000_10_full = 1,
	e1000_100_half = 2,
	e1000_100_full = 3,
};

enum latency_range {
	lowest_latency = 0,
	low_latency = 1,
	bulk_latency = 2,
	latency_invalid = 255,
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

struct e1000_context_desc {
	union {
		__le32 ip_config;
		struct {
			u8 ipcss;
			u8 ipcso;
			__le16 ipcse;
		} ip_fields;
	} lower_setup;
	union {
		__le32 tcp_config;
		struct {
			u8 tucss;
			u8 tucso;
			__le16 tucse;
		} tcp_fields;
	} upper_setup;
	__le32 cmd_and_length;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 hdr_len;
			__le16 mss;
		} fields;
	} tcp_seg_setup;
};

struct e1000_tx_desc {
	__le64 buffer_addr;
	union {
		__le32 data;
		struct {
			__le16 length;
			u8 cso;
			u8 cmd;
		} flags;
	} lower;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 css;
			__le16 special;
		} fields;
	} upper;
};

struct e1000_rx_desc {
	__le64 buffer_addr;
	__le16 length;
	__le16 csum;
	u8 status;
	u8 errors;
	__le16 special;
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

typedef enum {
	e1000_undefined = 0,
	e1000_82542_rev2_0 = 1,
	e1000_82542_rev2_1 = 2,
	e1000_82543 = 3,
	e1000_82544 = 4,
	e1000_82540 = 5,
	e1000_82545 = 6,
	e1000_82545_rev_3 = 7,
	e1000_82546 = 8,
	e1000_ce4100 = 9,
	e1000_82546_rev_3 = 10,
	e1000_82541 = 11,
	e1000_82541_rev_2 = 12,
	e1000_82547 = 13,
	e1000_82547_rev_2 = 14,
	e1000_num_macs = 15,
} e1000_mac_type;

typedef enum {
	e1000_phy_m88___2 = 0,
	e1000_phy_igp___2 = 1,
	e1000_phy_8211 = 2,
	e1000_phy_8201 = 3,
	e1000_phy_undefined = 255,
} e1000_phy_type;

typedef enum {
	e1000_media_type_copper___2 = 0,
	e1000_media_type_fiber___2 = 1,
	e1000_media_type_internal_serdes___2 = 2,
	e1000_num_media_types___2 = 3,
} e1000_media_type;

typedef enum {
	E1000_FC_NONE = 0,
	E1000_FC_RX_PAUSE = 1,
	E1000_FC_TX_PAUSE = 2,
	E1000_FC_FULL = 3,
	E1000_FC_DEFAULT = 255,
} e1000_fc_type;

typedef enum {
	e1000_bus_speed_unknown = 0,
	e1000_bus_speed_33 = 1,
	e1000_bus_speed_66 = 2,
	e1000_bus_speed_100 = 3,
	e1000_bus_speed_120 = 4,
	e1000_bus_speed_133 = 5,
	e1000_bus_speed_reserved = 6,
} e1000_bus_speed;

typedef enum {
	e1000_bus_width_unknown___2 = 0,
	e1000_bus_width_32___2 = 1,
	e1000_bus_width_64___2 = 2,
	e1000_bus_width_reserved___2 = 3,
} e1000_bus_width;

typedef enum {
	e1000_bus_type_unknown = 0,
	e1000_bus_type_pci = 1,
	e1000_bus_type_pcix = 2,
	e1000_bus_type_reserved = 3,
} e1000_bus_type;

typedef enum {
	e1000_eeprom_uninitialized = 0,
	e1000_eeprom_spi = 1,
	e1000_eeprom_microwire = 2,
	e1000_eeprom_flash = 3,
	e1000_eeprom_none = 4,
	e1000_num_eeprom_types = 5,
} e1000_eeprom_type;

struct e1000_eeprom_info {
	e1000_eeprom_type type;
	u16 word_size;
	u16 opcode_bits;
	u16 address_bits;
	u16 delay_usec;
	u16 page_size;
};

typedef enum {
	e1000_ms_hw_default___2 = 0,
	e1000_ms_force_master___2 = 1,
	e1000_ms_force_slave___2 = 2,
	e1000_ms_auto___2 = 3,
} e1000_ms_type;

typedef enum {
	e1000_ffe_config_enabled = 0,
	e1000_ffe_config_active = 1,
	e1000_ffe_config_blocked = 2,
} e1000_ffe_config;

typedef enum {
	e1000_smart_speed_default___2 = 0,
	e1000_smart_speed_on___2 = 1,
	e1000_smart_speed_off___2 = 2,
} e1000_smart_speed;

typedef enum {
	e1000_dsp_config_disabled = 0,
	e1000_dsp_config_enabled = 1,
	e1000_dsp_config_activated = 2,
	e1000_dsp_config_undefined = 255,
} e1000_dsp_config;

struct e1000_shadow_ram___2;

struct e1000_hw___2 {
	u8 *hw_addr;
	u8 *flash_address;
	void *ce4100_gbe_mdio_base_virt;
	e1000_mac_type mac_type;
	e1000_phy_type phy_type;
	u32 phy_init_script;
	e1000_media_type media_type;
	void *back;
	struct e1000_shadow_ram___2 *eeprom_shadow_ram;
	u32 flash_bank_size;
	u32 flash_base_addr;
	e1000_fc_type fc;
	e1000_bus_speed bus_speed;
	e1000_bus_width bus_width;
	e1000_bus_type bus_type;
	struct e1000_eeprom_info eeprom;
	e1000_ms_type master_slave;
	e1000_ms_type original_master_slave;
	e1000_ffe_config ffe_config_state;
	u32 asf_firmware_present;
	u32 eeprom_semaphore_present;
	unsigned long io_base;
	u32 phy_id;
	u32 phy_revision;
	u32 phy_addr;
	u32 original_fc;
	u32 txcw;
	u32 autoneg_failed;
	u32 max_frame_size;
	u32 min_frame_size;
	u32 mc_filter_type;
	u32 num_mc_addrs;
	u32 collision_delta;
	u32 tx_packet_delta;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	bool tx_pkt_filtering;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	u16 phy_spd_default;
	u16 autoneg_advertised;
	u16 pci_cmd_word;
	u16 fc_high_water;
	u16 fc_low_water;
	u16 fc_pause_time;
	u16 current_ifs_val;
	u16 ifs_min_val;
	u16 ifs_max_val;
	u16 ifs_step_size;
	u16 ifs_ratio;
	u16 device_id;
	u16 vendor_id;
	u16 subsystem_id;
	u16 subsystem_vendor_id;
	u8 revision_id;
	u8 autoneg;
	u8 mdix;
	u8 forced_speed_duplex;
	u8 wait_autoneg_complete;
	u8 dma_fairness;
	u8 mac_addr[6];
	u8 perm_mac_addr[6];
	bool disable_polarity_correction;
	bool speed_downgraded;
	e1000_smart_speed smart_speed;
	e1000_dsp_config dsp_config_state;
	bool get_link_status;
	bool serdes_has_link;
	bool tbi_compatibility_en;
	bool tbi_compatibility_on;
	bool laa_is_present;
	bool phy_reset_disable;
	bool initialize_hw_bits_disable;
	bool fc_send_xon;
	bool fc_strict_ieee;
	bool report_tx_early;
	bool adaptive_ifs;
	bool ifs_params_forced;
	bool in_ifs_mode;
	bool mng_reg_access_disabled;
	bool leave_av_bit_off;
	bool bad_tx_carr_stats_fd;
	bool has_smbus;
};

struct e1000_hw_stats___2 {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 txerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorcl;
	u64 gorch;
	u64 gotcl;
	u64 gotch;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rlerrc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 torl;
	u64 torh;
	u64 totl;
	u64 toth;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
};

typedef enum {
	e1000_cable_length_50 = 0,
	e1000_cable_length_50_80 = 1,
	e1000_cable_length_80_110 = 2,
	e1000_cable_length_110_140 = 3,
	e1000_cable_length_140 = 4,
	e1000_cable_length_undefined = 255,
} e1000_cable_length;

typedef enum {
	e1000_10bt_ext_dist_enable_normal = 0,
	e1000_10bt_ext_dist_enable_lower = 1,
	e1000_10bt_ext_dist_enable_undefined = 255,
} e1000_10bt_ext_dist_enable;

typedef enum {
	e1000_rev_polarity_normal___2 = 0,
	e1000_rev_polarity_reversed___2 = 1,
	e1000_rev_polarity_undefined___2 = 255,
} e1000_rev_polarity;

typedef enum {
	e1000_downshift_normal = 0,
	e1000_downshift_activated = 1,
	e1000_downshift_undefined = 255,
} e1000_downshift;

typedef enum {
	e1000_polarity_reversal_enabled = 0,
	e1000_polarity_reversal_disabled = 1,
	e1000_polarity_reversal_undefined = 255,
} e1000_polarity_reversal;

typedef enum {
	e1000_auto_x_mode_manual_mdi = 0,
	e1000_auto_x_mode_manual_mdix = 1,
	e1000_auto_x_mode_auto1 = 2,
	e1000_auto_x_mode_auto2 = 3,
	e1000_auto_x_mode_undefined = 255,
} e1000_auto_x_mode;

typedef enum {
	e1000_1000t_rx_status_not_ok___2 = 0,
	e1000_1000t_rx_status_ok___2 = 1,
	e1000_1000t_rx_status_undefined___2 = 255,
} e1000_1000t_rx_status;

struct e1000_phy_info___2 {
	e1000_cable_length cable_length;
	e1000_10bt_ext_dist_enable extended_10bt_distance;
	e1000_rev_polarity cable_polarity;
	e1000_downshift downshift;
	e1000_polarity_reversal polarity_correction;
	e1000_auto_x_mode mdix_mode;
	e1000_1000t_rx_status local_rx;
	e1000_1000t_rx_status remote_rx;
};

struct e1000_tx_buffer;

struct e1000_tx_ring {
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	unsigned int next_to_use;
	unsigned int next_to_clean;
	struct e1000_tx_buffer *buffer_info;
	u16 tdh;
	u16 tdt;
	bool last_tx_tso;
};

struct e1000_rx_buffer;

struct e1000_rx_ring {
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	unsigned int next_to_use;
	unsigned int next_to_clean;
	struct e1000_rx_buffer *buffer_info;
	struct sk_buff *rx_skb_top;
	int cpu;
	u16 rdh;
	u16 rdt;
};

struct e1000_adapter___2 {
	unsigned long active_vlans[64];
	u16 mng_vlan_id;
	u32 bd_number;
	u32 rx_buffer_len;
	u32 wol;
	u32 smartspeed;
	u32 en_mng_pt;
	u16 link_speed;
	u16 link_duplex;
	spinlock_t stats_lock;
	unsigned int total_tx_bytes;
	unsigned int total_tx_packets;
	unsigned int total_rx_bytes;
	unsigned int total_rx_packets;
	u32 itr;
	u32 itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	u8 fc_autoneg;
	struct e1000_tx_ring *tx_ring;
	unsigned int restart_queue;
	u32 txd_cmd;
	u32 tx_int_delay;
	u32 tx_abs_int_delay;
	u32 gotcl;
	u64 gotcl_old;
	u64 tpt_old;
	u64 colc_old;
	u32 tx_timeout_count;
	u32 tx_fifo_head;
	u32 tx_head_addr;
	u32 tx_fifo_size;
	u8 tx_timeout_factor;
	atomic_t tx_fifo_stall;
	bool pcix_82544;
	bool detect_tx_hung;
	bool dump_buffers;
	bool (*clean_rx)(struct e1000_adapter___2 *, struct e1000_rx_ring *, int *, int);
	void (*alloc_rx_buf)(struct e1000_adapter___2 *, struct e1000_rx_ring *, int);
	struct e1000_rx_ring *rx_ring;
	struct napi_struct napi;
	int num_tx_queues;
	int num_rx_queues;
	u64 hw_csum_err;
	u64 hw_csum_good;
	u32 alloc_rx_buff_failed;
	u32 rx_int_delay;
	u32 rx_abs_int_delay;
	bool rx_csum;
	u32 gorcl;
	u64 gorcl_old;
	struct net_device *netdev;
	struct pci_dev *pdev;
	struct e1000_hw___2 hw;
	struct e1000_hw_stats___2 stats;
	struct e1000_phy_info___2 phy_info;
	struct e1000_phy_stats phy_stats;
	u32 test_icr;
	struct e1000_tx_ring test_tx_ring;
	struct e1000_rx_ring test_rx_ring;
	int msg_enable;
	bool tso_force;
	bool smart_power_down;
	bool quad_port_a;
	unsigned long flags;
	u32 eeprom_wol;
	int bars;
	int need_ioport;
	bool discarding;
	struct work_struct reset_task;
	struct delayed_work watchdog_task;
	struct delayed_work fifo_stall_task;
	struct delayed_work phy_info_task;
};

struct e1000_tx_buffer {
	struct sk_buff *skb;
	dma_addr_t dma;
	unsigned long time_stamp;
	u16 length;
	u16 next_to_watch;
	bool mapped_as_page;
	unsigned short segs;
	unsigned int bytecount;
};

struct e1000_rx_buffer {
	union {
		struct page *page;
		u8 *data;
	} rxbuf;
	dma_addr_t dma;
};

struct e1000_shadow_ram___2 {
	u16 eeprom_word;
	bool modified;
};

struct my_u {
	__le64 a;
	__le64 b;
};

struct vfio {
	struct class *class;
	struct list_head group_list;
	struct mutex group_lock;
	struct ida group_ida;
	dev_t group_devt;
};

enum vfio_group_type {
	VFIO_IOMMU = 0,
	VFIO_EMULATED_IOMMU = 1,
	VFIO_NO_IOMMU = 2,
};

enum {
	vfio_noiommu = 0,
};

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

struct vfio_container;

struct vfio_group {
	struct device dev;
	struct cdev cdev;
	refcount_t drivers;
	unsigned int container_users;
	struct iommu_group *iommu_group;
	struct vfio_container *container;
	struct list_head device_list;
	struct mutex device_lock;
	struct list_head vfio_next;
	struct list_head container_next;
	enum vfio_group_type type;
	struct mutex group_lock;
	struct kvm___2 *kvm;
	struct file *opened_file;
	struct blocking_notifier_head notifier;
	struct iommufd_ctx *iommufd;
	spinlock_t kvm_ref_lock;
	unsigned int cdev_device_open_cnt;
};

struct vfio_device_file {
	struct vfio_device *device;
	struct vfio_group *group;
	u8 access_granted;
	u32 devid;
	spinlock_t kvm_ref_lock;
	struct kvm___2 *kvm;
	struct iommufd_ctx *iommufd;
};

struct vfio_group_status {
	__u32 argsz;
	__u32 flags;
};

struct ulpi_device_id;

struct ulpi_driver {
	const struct ulpi_device_id *id_table;
	int (*probe)(struct ulpi *);
	void (*remove)(struct ulpi *);
	struct device_driver driver;
};

struct ulpi_device_id {
	__u16 vendor;
	__u16 product;
	kernel_ulong_t driver_data;
};

struct ulpi {
	struct device dev;
	struct ulpi_device_id id;
	const struct ulpi_ops *ops;
};

struct onboard_hub_pdata {
	unsigned long reset_us;
	unsigned int num_supplies;
};

struct pdev_list_entry {
	struct platform_device *pdev;
	struct list_head node;
};

struct dwc3_xlnx {
	int num_clocks;
	struct clk_bulk_data *clks;
	struct device *dev;
	void *regs;
	int (*pltfm_init)(struct dwc3_xlnx *);
	struct phy *usb3_phy;
};

enum mtu3_g_ep0_state {
	MU3D_EP0_STATE_SETUP = 1,
	MU3D_EP0_STATE_TX = 2,
	MU3D_EP0_STATE_RX = 3,
	MU3D_EP0_STATE_TX_END = 4,
	MU3D_EP0_STATE_STALL = 5,
};

enum mtu3_speed {
	MTU3_SPEED_INACTIVE = 0,
	MTU3_SPEED_FULL = 1,
	MTU3_SPEED_HIGH = 3,
	MTU3_SPEED_SUPER = 4,
	MTU3_SPEED_SUPER_PLUS = 5,
};

struct mtu3_fifo_info {
	u32 base;
	u32 limit;
	unsigned long bitmap[2];
};

struct mtu3_ep;

struct mtu3;

struct qmu_gpd;

struct mtu3_request {
	struct usb_request request;
	struct list_head list;
	struct mtu3_ep *mep;
	struct mtu3 *mtu;
	struct qmu_gpd *gpd;
	int epnum;
};

struct ssusb_mtk;

struct mtu3 {
	spinlock_t lock;
	struct ssusb_mtk *ssusb;
	struct device *dev;
	void *mac_base;
	void *ippc_base;
	int irq;
	struct mtu3_fifo_info tx_fifo;
	struct mtu3_fifo_info rx_fifo;
	struct mtu3_ep *ep_array;
	struct mtu3_ep *in_eps;
	struct mtu3_ep *out_eps;
	struct mtu3_ep *ep0;
	int num_eps;
	int slot;
	int active_ep;
	struct dma_pool *qmu_gpd_pool;
	enum mtu3_g_ep0_state ep0_state;
	struct usb_gadget g;
	struct usb_gadget_driver *gadget_driver;
	struct mtu3_request ep0_req;
	u8 setup_buf[6];
	enum usb_device_speed max_speed;
	enum usb_device_speed speed;
	unsigned int is_active: 1;
	unsigned int may_wakeup: 1;
	unsigned int is_self_powered: 1;
	unsigned int test_mode: 1;
	unsigned int softconnect: 1;
	unsigned int u1_enable: 1;
	unsigned int u2_enable: 1;
	unsigned int u3_capable: 1;
	unsigned int delayed_status: 1;
	unsigned int gen2cp: 1;
	unsigned int connected: 1;
	unsigned int async_callbacks: 1;
	unsigned int separate_fifo: 1;
	u8 address;
	u8 test_mode_nr;
	u32 hw_version;
};

struct otg_switch_mtk {
	struct regulator *vbus;
	struct extcon_dev *edev;
	struct notifier_block id_nb;
	struct work_struct dr_work;
	enum usb_role desired_role;
	enum usb_role default_role;
	struct usb_role_switch *role_sw;
	bool role_sw_used;
	bool is_u3_drd;
	bool manual_drd_enabled;
};

struct ssusb_mtk {
	struct device *dev;
	struct mtu3 *u3d;
	void *mac_base;
	void *ippc_base;
	struct phy **phys;
	int num_phys;
	int wakeup_irq;
	struct regulator *vusb33;
	struct clk_bulk_data clks[6];
	struct otg_switch_mtk otg_switch;
	enum usb_dr_mode dr_mode;
	bool is_host;
	int u2_ports;
	int u3_ports;
	int u2p_dis_msk;
	int u3p_dis_msk;
	struct dentry *dbgfs_root;
	bool uwk_en;
	struct regmap *uwk;
	u32 uwk_reg_base;
	u32 uwk_vers;
};

struct mtu3_gpd_ring {
	dma_addr_t dma;
	struct qmu_gpd *start;
	struct qmu_gpd *end;
	struct qmu_gpd *enqueue;
	struct qmu_gpd *dequeue;
};

struct mtu3_ep {
	struct usb_ep ep;
	char name[12];
	struct mtu3 *mtu;
	u8 epnum;
	u8 type;
	u8 is_in;
	u16 maxp;
	int slot;
	u32 fifo_size;
	u32 fifo_addr;
	u32 fifo_seg_size;
	struct mtu3_fifo_info *fifo;
	struct list_head req_list;
	struct mtu3_gpd_ring gpd_ring;
	const struct usb_ss_ep_comp_descriptor *comp_desc;
	const struct usb_endpoint_descriptor *desc;
	int flags;
};

struct qmu_gpd {
	__le32 dw0_info;
	__le32 next_gpd;
	__le32 buffer;
	__le32 dw3_info;
};

enum sam_status {
	SAM_STAT_GOOD = 0,
	SAM_STAT_CHECK_CONDITION = 2,
	SAM_STAT_CONDITION_MET = 4,
	SAM_STAT_BUSY = 8,
	SAM_STAT_INTERMEDIATE = 16,
	SAM_STAT_INTERMEDIATE_CONDITION_MET = 20,
	SAM_STAT_RESERVATION_CONFLICT = 24,
	SAM_STAT_COMMAND_TERMINATED = 34,
	SAM_STAT_TASK_SET_FULL = 40,
	SAM_STAT_ACA_ACTIVE = 48,
	SAM_STAT_TASK_ABORTED = 64,
};

enum {
	US_FL_SINGLE_LUN = 1,
	US_FL_NEED_OVERRIDE = 2,
	US_FL_SCM_MULT_TARG = 4,
	US_FL_FIX_INQUIRY = 8,
	US_FL_FIX_CAPACITY = 16,
	US_FL_IGNORE_RESIDUE = 32,
	US_FL_BULK32 = 64,
	US_FL_NOT_LOCKABLE = 128,
	US_FL_GO_SLOW = 256,
	US_FL_NO_WP_DETECT = 512,
	US_FL_MAX_SECTORS_64 = 1024,
	US_FL_IGNORE_DEVICE = 2048,
	US_FL_CAPACITY_HEURISTICS = 4096,
	US_FL_MAX_SECTORS_MIN = 8192,
	US_FL_BULK_IGNORE_TAG = 16384,
	US_FL_SANE_SENSE = 32768,
	US_FL_CAPACITY_OK = 65536,
	US_FL_BAD_SENSE = 131072,
	US_FL_NO_READ_DISC_INFO = 262144,
	US_FL_NO_READ_CAPACITY_16 = 524288,
	US_FL_INITIAL_READ10 = 1048576,
	US_FL_WRITE_CACHE = 2097152,
	US_FL_NEEDS_CAP16 = 4194304,
	US_FL_IGNORE_UAS = 8388608,
	US_FL_BROKEN_FUA = 16777216,
	US_FL_NO_ATA_1X = 33554432,
	US_FL_NO_REPORT_OPCODES = 67108864,
	US_FL_MAX_SECTORS_240 = 134217728,
	US_FL_NO_REPORT_LUNS = 268435456,
	US_FL_ALWAYS_SYNC = 536870912,
	US_FL_NO_SAME = 1073741824,
	US_FL_SENSE_AFTER_SYNC = 2147483648,
};

enum xfer_buf_dir {
	TO_XFER_BUF = 0,
	FROM_XFER_BUF = 1,
};

struct bulk_cb_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 DataTransferLength;
	__u8 Flags;
	__u8 Lun;
	__u8 Length;
	__u8 CDB[16];
};

struct bulk_cs_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 Residue;
	__u8 Status;
};

struct us_data;

typedef int (*trans_cmnd)(struct scsi_cmnd *, struct us_data *);

typedef int (*trans_reset)(struct us_data *);

typedef void (*proto_cmnd)(struct scsi_cmnd *, struct us_data *);

struct usb_sg_request {
	int status;
	size_t bytes;
	spinlock_t lock;
	struct usb_device *dev;
	int pipe;
	int entries;
	struct urb **urbs;
	int count;
	struct completion complete;
};

typedef void (*extra_data_destructor)(void *);

typedef void (*pm_hook)(struct us_data *, int);

struct us_unusual_dev;

struct us_data {
	struct mutex dev_mutex;
	struct usb_device *pusb_dev;
	struct usb_interface *pusb_intf;
	const struct us_unusual_dev *unusual_dev;
	u64 fflags;
	unsigned long dflags;
	unsigned int send_bulk_pipe;
	unsigned int recv_bulk_pipe;
	unsigned int send_ctrl_pipe;
	unsigned int recv_ctrl_pipe;
	unsigned int recv_intr_pipe;
	char *transport_name;
	char *protocol_name;
	__le32 bcs_signature;
	u8 subclass;
	u8 protocol;
	u8 max_lun;
	u8 ifnum;
	u8 ep_bInterval;
	trans_cmnd transport;
	trans_reset transport_reset;
	proto_cmnd proto_handler;
	struct scsi_cmnd *srb;
	unsigned int tag;
	char scsi_name[32];
	struct urb *current_urb;
	struct usb_ctrlrequest *cr;
	struct usb_sg_request current_sg;
	unsigned char *iobuf;
	dma_addr_t iobuf_dma;
	struct task_struct *ctl_thread;
	struct completion cmnd_ready;
	struct completion notify;
	wait_queue_head_t delay_wait;
	struct delayed_work scan_dwork;
	void *extra;
	extra_data_destructor extra_destructor;
	pm_hook suspend_resume_hook;
	int use_last_sector_hacks;
	int last_sector_retries;
};

struct us_unusual_dev {
	const char *vendorName;
	const char *productName;
	__u8 useProtocol;
	__u8 useTransport;
	int (*initFunction)(struct us_data *);
};

struct opal_dev;

struct scsi_disk {
	struct scsi_device *device;
	struct device disk_dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	sector_t capacity;
	int max_retries;
	u32 min_xfer_blocks;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	u8 nr_actuators;
	bool suspended;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char cmnd[32];
	struct scsi_data_buffer sdb;
	struct scatterlist sense_sgl;
};

struct ff_periodic_effect_compat {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	compat_uptr_t custom_data;
};

struct ff_effect_compat {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect_compat periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_event_compat {
	compat_ulong_t sec;
	compat_ulong_t usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

enum ps2_disposition {
	PS2_PROCESS = 0,
	PS2_IGNORE = 1,
	PS2_ERROR = 2,
};

enum psmouse_type {
	PSMOUSE_NONE = 0,
	PSMOUSE_PS2 = 1,
	PSMOUSE_PS2PP = 2,
	PSMOUSE_THINKPS = 3,
	PSMOUSE_GENPS = 4,
	PSMOUSE_IMPS = 5,
	PSMOUSE_IMEX = 6,
	PSMOUSE_SYNAPTICS = 7,
	PSMOUSE_ALPS = 8,
	PSMOUSE_LIFEBOOK = 9,
	PSMOUSE_TRACKPOINT = 10,
	PSMOUSE_TOUCHKIT_PS2 = 11,
	PSMOUSE_CORTRON = 12,
	PSMOUSE_HGPK = 13,
	PSMOUSE_ELANTECH = 14,
	PSMOUSE_FSP = 15,
	PSMOUSE_SYNAPTICS_RELATIVE = 16,
	PSMOUSE_CYPRESS = 17,
	PSMOUSE_FOCALTECH = 18,
	PSMOUSE_VMMOUSE = 19,
	PSMOUSE_BYD = 20,
	PSMOUSE_SYNAPTICS_SMBUS = 21,
	PSMOUSE_ELANTECH_SMBUS = 22,
	PSMOUSE_AUTO = 23,
};

enum psmouse_state {
	PSMOUSE_IGNORE = 0,
	PSMOUSE_INITIALIZING = 1,
	PSMOUSE_RESYNCING = 2,
	PSMOUSE_CMD_MODE = 3,
	PSMOUSE_ACTIVATED = 4,
};

enum psmouse_scale {
	PSMOUSE_SCALE11 = 0,
	PSMOUSE_SCALE21 = 1,
};

struct ps2dev;

typedef enum ps2_disposition (*ps2_pre_receive_handler_t)(struct ps2dev *, u8, unsigned int);

typedef void (*ps2_receive_handler_t)(struct ps2dev *, u8);

struct serio;

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	unsigned long flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
	ps2_pre_receive_handler_t pre_receive_handler;
	ps2_receive_handler_t receive_handler;
};

typedef enum {
	PSMOUSE_BAD_DATA = 0,
	PSMOUSE_GOOD_DATA = 1,
	PSMOUSE_FULL_PACKET = 2,
} psmouse_ret_t;

struct psmouse_protocol;

struct psmouse {
	void *private;
	struct input_dev *dev;
	struct ps2dev ps2dev;
	struct delayed_work resync_work;
	const char *vendor;
	const char *name;
	const struct psmouse_protocol *protocol;
	unsigned char packet[8];
	unsigned char badbyte;
	unsigned char pktcnt;
	unsigned char pktsize;
	unsigned char oob_data_type;
	unsigned char extra_buttons;
	bool acks_disable_command;
	unsigned int model;
	unsigned long last;
	unsigned long out_of_sync_cnt;
	unsigned long num_resyncs;
	enum psmouse_state state;
	char devname[64];
	char phys[32];
	unsigned int rate;
	unsigned int resolution;
	unsigned int resetafter;
	unsigned int resync_time;
	bool smartscroll;
	psmouse_ret_t (*protocol_handler)(struct psmouse *);
	void (*set_rate)(struct psmouse *, unsigned int);
	void (*set_resolution)(struct psmouse *, unsigned int);
	void (*set_scale)(struct psmouse *, enum psmouse_scale);
	int (*reconnect)(struct psmouse *);
	int (*fast_reconnect)(struct psmouse *);
	void (*disconnect)(struct psmouse *);
	void (*cleanup)(struct psmouse *);
	int (*poll)(struct psmouse *);
	void (*pt_activate)(struct psmouse *);
	void (*pt_deactivate)(struct psmouse *);
};

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

struct psmouse_protocol {
	enum psmouse_type type;
	bool maxproto;
	bool ignore_parity;
	bool try_passthru;
	bool smbus_companion;
	const char *name;
	const char *alias;
	int (*detect)(struct psmouse *, bool);
	int (*init)(struct psmouse *);
};

struct focaltech_finger_state {
	bool active;
	bool valid;
	unsigned int x;
	unsigned int y;
};

struct focaltech_hw_state {
	struct focaltech_finger_state fingers[5];
	unsigned int width;
	bool pressed;
};

struct focaltech_data {
	unsigned int x_max;
	unsigned int y_max;
	struct focaltech_hw_state state;
};

enum i2c_driver_flags {
	I2C_DRV_ACPI_WAIVE_D0_PROBE = 1,
};

enum acpi_reconfig_event {
	ACPI_RECONFIG_DEVICE_ADD = 0,
	ACPI_RECONFIG_DEVICE_REMOVE = 1,
};

struct gsb_buffer {
	u8 status;
	u8 len;
	union {
		u16 wdata;
		u8 bdata;
		struct {
			struct {} __empty_data;
			u8 data[0];
		};
	};
};

struct i2c_acpi_irq_context {
	int irq;
	bool wake_capable;
};

struct i2c_acpi_lookup {
	struct i2c_board_info *info;
	acpi_handle adapter_handle;
	acpi_handle device_handle;
	acpi_handle search_handle;
	int n;
	int index;
	u32 speed;
	u32 min_speed;
	u32 force_speed;
};

struct acpi_connection_info {
	u8 *connection;
	u16 length;
	u8 access_length;
};

struct i2c_acpi_handler_data {
	struct acpi_connection_info info;
	struct i2c_adapter *adapter;
};

struct rcar_gen3_thermal_priv;

struct rcar_thermal_info {
	int ths_tj_1;
	void (*read_fuses)(struct rcar_gen3_thermal_priv *);
};

struct rcar_gen3_thermal_tsc;

struct rcar_gen3_thermal_priv {
	struct rcar_gen3_thermal_tsc *tscs[5];
	struct thermal_zone_device_ops ops;
	unsigned int num_tscs;
	int ptat[3];
	const struct rcar_thermal_info *info;
};

struct equation_coefs {
	int a1;
	int b1;
	int a2;
	int b2;
};

struct rcar_gen3_thermal_tsc {
	void *base;
	struct thermal_zone_device *zone;
	struct equation_coefs coef;
	int tj_t;
	int thcode[3];
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct dbs_data;

struct policy_dbs_info;

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)();
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct dbs_data {
	struct gov_attr_set attr_set;
	struct dbs_governor *gov;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct mmci_host;

struct mmci_host_ops {
	int (*validate_data)(struct mmci_host *, struct mmc_data *);
	int (*prep_data)(struct mmci_host *, struct mmc_data *, bool);
	void (*unprep_data)(struct mmci_host *, struct mmc_data *, int);
	u32 (*get_datactrl_cfg)(struct mmci_host *);
	void (*get_next_data)(struct mmci_host *, struct mmc_data *);
	int (*dma_setup)(struct mmci_host *);
	void (*dma_release)(struct mmci_host *);
	int (*dma_start)(struct mmci_host *, unsigned int *);
	void (*dma_finalize)(struct mmci_host *, struct mmc_data *);
	void (*dma_error)(struct mmci_host *);
	void (*set_clkreg)(struct mmci_host *, unsigned int);
	void (*set_pwrreg)(struct mmci_host *, unsigned int);
	bool (*busy_complete)(struct mmci_host *, struct mmc_command *, u32, u32);
	void (*pre_sig_volt_switch)(struct mmci_host *);
	int (*post_sig_volt_switch)(struct mmci_host *, struct mmc_ios *);
};

enum mmci_busy_state {
	MMCI_BUSY_WAITING_FOR_START_IRQ = 0,
	MMCI_BUSY_WAITING_FOR_END_IRQ = 1,
	MMCI_BUSY_DONE = 2,
};

struct mmci_platform_data;

struct variant_data;

struct mmci_host {
	phys_addr_t phybase;
	void *base;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_command stop_abort;
	struct mmc_data *data;
	struct mmc_host *mmc;
	struct clk *clk;
	u8 singleirq: 1;
	struct reset_control *rst;
	spinlock_t lock;
	unsigned int mclk;
	unsigned int clock_cache;
	unsigned int cclk;
	u32 pwr_reg;
	u32 pwr_reg_add;
	u32 clk_reg;
	u32 clk_reg_add;
	u32 datactrl_reg;
	enum mmci_busy_state busy_state;
	u32 busy_status;
	u32 mask1_reg;
	u8 vqmmc_enabled: 1;
	struct mmci_platform_data *plat;
	struct mmc_host_ops *mmc_ops;
	struct mmci_host_ops *ops;
	struct variant_data *variant;
	void *variant_priv;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_opendrain;
	u8 hw_designer;
	u8 hw_revision: 4;
	struct timer_list timer;
	unsigned int oldstat;
	u32 irq_action;
	struct sg_mapping_iter sg_miter;
	unsigned int size;
	int (*get_rx_fifocnt)(struct mmci_host *, u32, int);
	u8 use_dma: 1;
	u8 dma_in_progress: 1;
	void *dma_priv;
	s32 next_cookie;
	struct delayed_work ux500_busy_timeout_work;
};

struct variant_data {
	unsigned int clkreg;
	unsigned int clkreg_enable;
	unsigned int clkreg_8bit_bus_enable;
	unsigned int clkreg_neg_edge_enable;
	unsigned int cmdreg_cpsm_enable;
	unsigned int cmdreg_lrsp_crc;
	unsigned int cmdreg_srsp_crc;
	unsigned int cmdreg_srsp;
	unsigned int cmdreg_stop;
	unsigned int datalength_bits;
	unsigned int fifosize;
	unsigned int fifohalfsize;
	unsigned int data_cmd_enable;
	unsigned int datactrl_mask_ddrmode;
	unsigned int datactrl_mask_sdio;
	unsigned int datactrl_blocksz;
	u8 datactrl_any_blocksz: 1;
	u8 dma_power_of_2: 1;
	u8 datactrl_first: 1;
	u8 datacnt_useless: 1;
	u8 st_sdio: 1;
	u8 st_clkdiv: 1;
	u8 stm32_clkdiv: 1;
	u32 pwrreg_powerup;
	u32 f_max;
	u8 signal_direction: 1;
	u8 pwrreg_clkgate: 1;
	u8 busy_detect: 1;
	u8 busy_timeout: 1;
	u32 busy_dpsm_flag;
	u32 busy_detect_flag;
	u32 busy_detect_mask;
	u8 pwrreg_nopower: 1;
	u8 explicit_mclk_control: 1;
	u8 qcom_fifo: 1;
	u8 qcom_dml: 1;
	u8 reversed_irq_handling: 1;
	u8 mmcimask1: 1;
	unsigned int irq_pio_mask;
	u32 start_err;
	u32 opendrain;
	u8 dma_lli: 1;
	u32 stm32_idmabsize_mask;
	u32 stm32_idmabsize_align;
	bool dma_flow_controller;
	void (*init)(struct mmci_host *);
};

struct sdmmc_dlyb;

struct sdmmc_tuning_ops {
	int (*dlyb_enable)(struct sdmmc_dlyb *);
	void (*set_input_ck)(struct sdmmc_dlyb *);
	int (*tuning_prepare)(struct mmci_host *);
	int (*set_cfg)(struct sdmmc_dlyb *, int, int, bool);
};

struct sdmmc_dlyb {
	void *base;
	u32 unit;
	u32 max;
	struct sdmmc_tuning_ops *ops;
};

struct sdmmc_lli_desc {
	u32 idmalar;
	u32 idmabase;
	u32 idmasize;
};

struct sdmmc_idma {
	dma_addr_t sg_dma;
	void *sg_cpu;
	dma_addr_t bounce_dma_addr;
	void *bounce_buf;
	bool use_bounce_buffer;
};

struct esdhc_clk_fixup {
	const unsigned int sd_dflt_max_clk;
	const unsigned int max_clk[11];
};

struct sdhci_esdhc {
	u8 vendor_ver;
	u8 spec_ver;
	bool quirk_incorrect_hostver;
	bool quirk_limited_clk_division;
	bool quirk_unreliable_pulse_detection;
	bool quirk_tuning_erratum_type1;
	bool quirk_tuning_erratum_type2;
	bool quirk_ignore_data_inhibit;
	bool quirk_delay_before_data_reset;
	bool quirk_trans_complete_erratum;
	bool in_sw_tuning;
	unsigned int peripheral_clock;
	const struct esdhc_clk_fixup *clk_fixup;
	u32 div_ratio;
};

enum scmi_power_scale {
	SCMI_POWER_BOGOWATTS = 0,
	SCMI_POWER_MILLIWATTS = 1,
	SCMI_POWER_MICROWATTS = 2,
};

struct scmi_perf_domain_info;

struct scmi_perf_proto_ops {
	int (*num_domains_get)(const struct scmi_protocol_handle *);
	const struct scmi_perf_domain_info * (*info_get)(const struct scmi_protocol_handle *, u32);
	int (*limits_set)(const struct scmi_protocol_handle *, u32, u32, u32);
	int (*limits_get)(const struct scmi_protocol_handle *, u32, u32 *, u32 *);
	int (*level_set)(const struct scmi_protocol_handle *, u32, u32, bool);
	int (*level_get)(const struct scmi_protocol_handle *, u32, u32 *, bool);
	int (*transition_latency_get)(const struct scmi_protocol_handle *, u32);
	int (*device_opps_add)(const struct scmi_protocol_handle *, struct device *, u32);
	int (*freq_set)(const struct scmi_protocol_handle *, u32, unsigned long, bool);
	int (*freq_get)(const struct scmi_protocol_handle *, u32, unsigned long *, bool);
	int (*est_power_get)(const struct scmi_protocol_handle *, u32, unsigned long *, unsigned long *);
	bool (*fast_switch_possible)(const struct scmi_protocol_handle *, u32);
	enum scmi_power_scale (*power_scale_get)(const struct scmi_protocol_handle *);
};

struct scmi_perf_domain_info {
	char name[64];
	bool set_perf;
};

enum scmi_performance_protocol_cmd {
	PERF_DOMAIN_ATTRIBUTES = 3,
	PERF_DESCRIBE_LEVELS = 4,
	PERF_LIMITS_SET = 5,
	PERF_LIMITS_GET = 6,
	PERF_LEVEL_SET = 7,
	PERF_LEVEL_GET = 8,
	PERF_NOTIFY_LIMITS = 9,
	PERF_NOTIFY_LEVEL = 10,
	PERF_DESCRIBE_FASTCHANNEL = 11,
	PERF_DOMAIN_NAME_GET = 12,
};

enum {
	PERF_FC_LEVEL = 0,
	PERF_FC_LIMIT = 1,
	PERF_FC_MAX = 2,
};

enum scmi_notification_events {
	SCMI_EVENT_POWER_STATE_CHANGED = 0,
	SCMI_EVENT_CLOCK_RATE_CHANGED = 0,
	SCMI_EVENT_CLOCK_RATE_CHANGE_REQUESTED = 1,
	SCMI_EVENT_PERFORMANCE_LIMITS_CHANGED = 0,
	SCMI_EVENT_PERFORMANCE_LEVEL_CHANGED = 1,
	SCMI_EVENT_SENSOR_TRIP_POINT_EVENT = 0,
	SCMI_EVENT_SENSOR_UPDATE = 1,
	SCMI_EVENT_RESET_ISSUED = 0,
	SCMI_EVENT_BASE_ERROR_EVENT = 0,
	SCMI_EVENT_SYSTEM_POWER_STATE_NOTIFIER = 0,
	SCMI_EVENT_POWERCAP_CAP_CHANGED = 0,
	SCMI_EVENT_POWERCAP_MEASUREMENTS_CHANGED = 1,
};

struct scmi_opp {
	u32 perf;
	u32 power;
	u32 trans_latency_us;
	u32 indicative_freq;
	u32 level_index;
	struct hlist_node hash;
};

struct perf_dom_info;

struct scmi_perf_info {
	u32 version;
	u16 num_domains;
	enum scmi_power_scale power_scale;
	u64 stats_addr;
	u32 stats_size;
	struct perf_dom_info *dom_info;
};

struct scmi_fc_info;

struct perf_dom_info {
	u32 id;
	bool set_limits;
	bool perf_limit_notify;
	bool perf_level_notify;
	bool perf_fastchannels;
	bool level_indexing_mode;
	u32 opp_count;
	u32 sustained_freq_khz;
	u32 sustained_perf_level;
	unsigned long mult_factor;
	struct scmi_perf_domain_info info;
	struct scmi_opp opp[16];
	struct scmi_fc_info *fc_info;
	struct xarray opps_by_idx;
	struct xarray opps_by_lvl;
	struct hlist_head opps_by_freq[16];
};

struct scmi_fc_info {
	void *set_addr;
	void *get_addr;
	struct scmi_fc_db_info *set_db;
};

struct scmi_msg_resp_perf_attributes {
	__le16 num_domains;
	__le16 flags;
	__le32 stats_addr_low;
	__le32 stats_addr_high;
	__le32 stats_size;
};

struct scmi_msg_resp_perf_domain_attributes {
	__le32 flags;
	__le32 rate_limit_us;
	__le32 sustained_freq_khz;
	__le32 sustained_perf_level;
	u8 name[16];
};

struct scmi_perf_ipriv {
	u32 version;
	struct perf_dom_info *perf_dom;
};

struct scmi_msg_resp_perf_describe_levels {
	__le16 num_returned;
	__le16 num_remaining;
	struct {
		__le32 perf_val;
		__le32 power;
		__le16 transition_latency_us;
		__le16 reserved;
	} opp[0];
};

struct scmi_msg_resp_perf_describe_levels_v4 {
	__le16 num_returned;
	__le16 num_remaining;
	struct {
		__le32 perf_val;
		__le32 power;
		__le16 transition_latency_us;
		__le16 reserved;
		__le32 indicative_freq;
		__le32 level_index;
	} opp[0];
};

struct scmi_perf_set_limits {
	__le32 domain;
	__le32 max_level;
	__le32 min_level;
};

struct scmi_perf_get_limits {
	__le32 max_level;
	__le32 min_level;
};

struct dev_pm_opp_data {
	unsigned int level;
	unsigned long freq;
	unsigned long u_volt;
};

struct scmi_perf_set_level {
	__le32 domain;
	__le32 level;
};

struct scmi_perf_notify_level_or_limits {
	__le32 domain;
	__le32 notify_enable;
};

struct scmi_msg_perf_describe_levels {
	__le32 domain;
	__le32 level_index;
};

struct scmi_perf_limits_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 range_max;
	__le32 range_min;
};

struct scmi_perf_limits_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int range_max;
	unsigned int range_min;
};

struct scmi_perf_level_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 performance_level;
};

struct scmi_perf_level_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int performance_level;
};

struct scmi_powercap_info;

struct scmi_powercap_proto_ops {
	int (*num_domains_get)(const struct scmi_protocol_handle *);
	const struct scmi_powercap_info * (*info_get)(const struct scmi_protocol_handle *, u32);
	int (*cap_get)(const struct scmi_protocol_handle *, u32, u32 *);
	int (*cap_set)(const struct scmi_protocol_handle *, u32, u32, bool);
	int (*cap_enable_set)(const struct scmi_protocol_handle *, u32, bool);
	int (*cap_enable_get)(const struct scmi_protocol_handle *, u32, bool *);
	int (*pai_get)(const struct scmi_protocol_handle *, u32, u32 *);
	int (*pai_set)(const struct scmi_protocol_handle *, u32, u32);
	int (*measurements_get)(const struct scmi_protocol_handle *, u32, u32 *, u32 *);
	int (*measurements_threshold_set)(const struct scmi_protocol_handle *, u32, u32, u32);
	int (*measurements_threshold_get)(const struct scmi_protocol_handle *, u32, u32 *, u32 *);
};

struct scmi_powercap_info {
	unsigned int id;
	bool notify_powercap_cap_change;
	bool notify_powercap_measurement_change;
	bool async_powercap_cap_set;
	bool powercap_cap_config;
	bool powercap_monitoring;
	bool powercap_pai_config;
	bool powercap_scale_mw;
	bool powercap_scale_uw;
	bool fastchannels;
	char name[64];
	unsigned int min_pai;
	unsigned int max_pai;
	unsigned int pai_step;
	unsigned int min_power_cap;
	unsigned int max_power_cap;
	unsigned int power_cap_step;
	unsigned int sustainable_power;
	unsigned int accuracy;
	unsigned int parent_id;
	struct scmi_fc_info *fc_info;
};

enum scmi_powercap_protocol_cmd {
	POWERCAP_DOMAIN_ATTRIBUTES = 3,
	POWERCAP_CAP_GET = 4,
	POWERCAP_CAP_SET = 5,
	POWERCAP_PAI_GET = 6,
	POWERCAP_PAI_SET = 7,
	POWERCAP_DOMAIN_NAME_GET = 8,
	POWERCAP_MEASUREMENTS_GET = 9,
	POWERCAP_CAP_NOTIFY = 10,
	POWERCAP_MEASUREMENTS_NOTIFY = 11,
	POWERCAP_DESCRIBE_FASTCHANNEL = 12,
};

enum {
	POWERCAP_FC_CAP = 0,
	POWERCAP_FC_PAI = 1,
	POWERCAP_FC_MAX = 2,
};

struct scmi_powercap_state;

struct powercap_info {
	u32 version;
	int num_domains;
	struct scmi_powercap_state *states;
	struct scmi_powercap_info *powercaps;
};

struct scmi_powercap_state {
	bool enabled;
	u32 last_pcap;
	bool meas_notif_enabled;
	u64 thresholds;
};

struct scmi_msg_resp_powercap_domain_attributes {
	__le32 attributes;
	u8 name[16];
	__le32 min_pai;
	__le32 max_pai;
	__le32 pai_step;
	__le32 min_power_cap;
	__le32 max_power_cap;
	__le32 power_cap_step;
	__le32 sustainable_power;
	__le32 accuracy;
	__le32 parent_id;
};

struct scmi_msg_powercap_set_cap_or_pai {
	__le32 domain;
	__le32 flags;
	__le32 value;
};

struct scmi_msg_resp_powercap_cap_set_complete {
	__le32 domain;
	__le32 power_cap;
};

struct scmi_msg_resp_powercap_meas_get {
	__le32 power;
	__le32 pai;
};

struct scmi_msg_powercap_notify_cap {
	__le32 domain;
	__le32 notify_enable;
};

struct scmi_msg_powercap_notify_thresh {
	__le32 domain;
	__le32 notify_enable;
	__le32 power_thresh_low;
	__le32 power_thresh_high;
};

struct scmi_powercap_cap_changed_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 power_cap;
	__le32 pai;
};

struct scmi_powercap_cap_changed_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int power_cap;
	unsigned int pai;
};

struct scmi_powercap_meas_changed_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 power;
};

struct scmi_powercap_meas_changed_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int power;
};

struct mct_clock_event_device {
	struct clock_event_device evt;
	unsigned long base;
	char name[11];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	MCT_INT_SPI = 0,
	MCT_INT_PPI = 1,
};

struct supplier_bindings {
	struct device_node * (*parse_prop)(struct device_node *, const char *, int);
	bool optional;
	bool node_not_dev;
};

struct of_endpoint {
	unsigned int port;
	unsigned int id;
	const struct device_node *local_node;
};

struct hwspinlock_ops {
	int (*trylock)(struct hwspinlock *);
	void (*unlock)(struct hwspinlock *);
	void (*relax)(struct hwspinlock *);
};

struct hwspinlock_device;

struct hwspinlock {
	struct hwspinlock_device *bank;
	spinlock_t lock;
	void *priv;
};

struct hwspinlock_device {
	struct device *dev;
	const struct hwspinlock_ops *ops;
	int base_id;
	int num_locks;
	struct hwspinlock lock[0];
};

struct qcom_hwspinlock_of_data {
	u32 offset;
	u32 stride;
	const struct regmap_config *regmap_config;
};

struct reg_field {
	unsigned int reg;
	unsigned int lsb;
	unsigned int msb;
	unsigned int id_size;
	unsigned int id_offset;
};

struct __extcon_info {
	unsigned int type;
	unsigned int id;
	const char *name;
};

struct extcon_cable;

struct extcon_dev {
	const char *name;
	const unsigned int *supported_cable;
	const u32 *mutually_exclusive;
	struct device dev;
	unsigned int id;
	struct raw_notifier_head nh_all;
	struct raw_notifier_head *nh;
	struct list_head entry;
	int max_supported;
	spinlock_t lock;
	u32 state;
	struct device_type extcon_dev_type;
	struct extcon_cable *cables;
	struct attribute_group attr_g_muex;
	struct attribute **attrs_muex;
	struct device_attribute *d_attrs_muex;
};

union extcon_property_value {
	int intval;
};

struct extcon_cable {
	struct extcon_dev *edev;
	int cable_index;
	struct attribute_group attr_g;
	struct device_attribute attr_name;
	struct device_attribute attr_state;
	struct attribute *attrs[3];
	union extcon_property_value usb_propval[3];
	union extcon_property_value chg_propval[1];
	union extcon_property_value jack_propval[1];
	union extcon_property_value disp_propval[2];
	unsigned long usb_bits[1];
	unsigned long chg_bits[1];
	unsigned long jack_bits[1];
	unsigned long disp_bits[1];
};

struct icc_node;

struct icc_node_data;

struct icc_provider {
	struct list_head provider_list;
	struct list_head nodes;
	int (*set)(struct icc_node *, struct icc_node *);
	int (*aggregate)(struct icc_node *, u32, u32, u32, u32 *, u32 *);
	void (*pre_aggregate)(struct icc_node *);
	int (*get_bw)(struct icc_node *, u32 *, u32 *);
	struct icc_node * (*xlate)(struct of_phandle_args *, void *);
	struct icc_node_data * (*xlate_extended)(struct of_phandle_args *, void *);
	struct device *dev;
	int users;
	bool inter_set;
	void *data;
};

struct icc_clk_node {
	struct clk *clk;
	bool enabled;
};

struct icc_clk_provider {
	struct icc_provider provider;
	int num_clocks;
	struct icc_clk_node clocks[0];
};

struct icc_node {
	int id;
	const char *name;
	struct icc_node **links;
	size_t num_links;
	struct icc_provider *provider;
	struct list_head node_list;
	struct list_head search_list;
	struct icc_node *reverse;
	u8 is_traversed: 1;
	struct hlist_head req_list;
	u32 avg_bw;
	u32 peak_bw;
	u32 init_avg;
	u32 init_peak;
	void *data;
};

struct icc_node_data {
	struct icc_node *node;
	u32 tag;
};

struct icc_clk_data {
	struct clk *clk;
	const char *name;
};

struct icc_onecell_data {
	unsigned int num_nodes;
	struct icc_node *nodes[0];
};

struct net_device_devres {
	struct net_device *ndev;
};

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
	SK_PSOCK_RX_STRP_ENABLED = 1,
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct xdp_buff_xsk;

struct xdp_desc;

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	struct list_head xskb_list;
	u32 heads_cnt;
	u16 queue_id;
	long: 64;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	struct xdp_desc *tx_descs;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 chunk_shift;
	u32 frame_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool dma_need_sync;
	bool unaligned;
	void *addrs;
	spinlock_t cq_lock;
	struct xdp_buff_xsk *free_heads[0];
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	u8 cb[24];
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	u64 orig_addr;
	struct list_head free_list_node;
	struct list_head xskb_list_node;
};

struct xdp_desc {
	__u64 addr;
	__u32 len;
	__u32 options;
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	bool req_usec_ts;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

struct inet6_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
};

struct dsa_stubs {
	int (*conduit_hwtstamp_validate)(struct net_device *, const struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
};

struct gss_krb5_enctype;

struct crypto_sync_skcipher;

struct crypto_ahash;

struct krb5_ctx {
	int initiate;
	u32 enctype;
	u32 flags;
	const struct gss_krb5_enctype *gk5e;
	struct crypto_sync_skcipher *enc;
	struct crypto_sync_skcipher *seq;
	struct crypto_sync_skcipher *acceptor_enc;
	struct crypto_sync_skcipher *initiator_enc;
	struct crypto_sync_skcipher *acceptor_enc_aux;
	struct crypto_sync_skcipher *initiator_enc_aux;
	struct crypto_ahash *acceptor_sign;
	struct crypto_ahash *initiator_sign;
	struct crypto_ahash *initiator_integ;
	struct crypto_ahash *acceptor_integ;
	u8 Ksess[32];
	u8 cksum[32];
	atomic_t seq_send;
	atomic64_t seq_send64;
	time64_t endtime;
	struct xdr_netobj mech_used;
};

struct gss_krb5_enctype {
	const u32 etype;
	const u32 ctype;
	const char *name;
	const char *encrypt_name;
	const char *aux_cipher;
	const char *cksum_name;
	const u16 signalg;
	const u16 sealalg;
	const u32 cksumlength;
	const u32 keyed_cksum;
	const u32 keybytes;
	const u32 keylength;
	const u32 Kc_length;
	const u32 Ke_length;
	const u32 Ki_length;
	int (*derive_key)(const struct gss_krb5_enctype *, const struct xdr_netobj *, struct xdr_netobj *, const struct xdr_netobj *, gfp_t);
	u32 (*encrypt)(struct krb5_ctx *, u32, struct xdr_buf *, struct page **);
	u32 (*decrypt)(struct krb5_ctx *, u32, u32, struct xdr_buf *, u32 *, u32 *);
	u32 (*get_mic)(struct krb5_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*verify_mic)(struct krb5_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*wrap)(struct krb5_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*unwrap)(struct krb5_ctx *, int, int, struct xdr_buf *, unsigned int *, unsigned int *);
};

struct crypto_skcipher {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

enum vlan_flags {
	VLAN_FLAG_REORDER_HDR = 1,
	VLAN_FLAG_GVRP = 2,
	VLAN_FLAG_LOOSE_BINDING = 4,
	VLAN_FLAG_MVRP = 8,
	VLAN_FLAG_BRIDGE_BINDING = 16,
};

enum vlan_protos {
	VLAN_PROTO_8021Q = 0,
	VLAN_PROTO_8021AD = 1,
	VLAN_PROTO_NUM = 2,
};

struct vlan_pcpu_stats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t rx_multicast;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_errors;
	u32 tx_dropped;
};

struct vlan_vid_info {
	struct list_head list;
	__be16 proto;
	u16 vid;
	int refcount;
};

struct vlan_ethhdr {
	union {
		struct {
			unsigned char h_dest[6];
			unsigned char h_source[6];
		};
		struct {
			unsigned char h_dest[6];
			unsigned char h_source[6];
		} addrs;
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct napi_gro_cb {
	union {
		struct {
			void *frag0;
			unsigned int frag0_len;
		};
		struct {
			struct sk_buff *last;
			unsigned long age;
		};
	};
	int data_offset;
	u16 flush;
	u16 flush_id;
	u16 count;
	u16 proto;
	union {
		struct {
			u16 gro_remcsum_start;
			u8 same_flow: 1;
			u8 encap_mark: 1;
			u8 csum_valid: 1;
			u8 csum_cnt: 3;
			u8 free: 2;
			u8 is_ipv6: 1;
			u8 is_fou: 1;
			u8 is_atomic: 1;
			u8 recursion_counter: 4;
			u8 is_flist: 1;
		};
		struct {
			u16 gro_remcsum_start;
			u8 same_flow: 1;
			u8 encap_mark: 1;
			u8 csum_valid: 1;
			u8 csum_cnt: 3;
			u8 free: 2;
			u8 is_ipv6: 1;
			u8 is_fou: 1;
			u8 is_atomic: 1;
			u8 recursion_counter: 4;
			u8 is_flist: 1;
		} zeroed;
	};
	__wsum csum;
};

struct vlan_priority_tci_mapping;

struct vlan_dev_priv {
	unsigned int nr_ingress_mappings;
	u32 ingress_priority_map[8];
	unsigned int nr_egress_mappings;
	struct vlan_priority_tci_mapping *egress_priority_map[16];
	__be16 vlan_proto;
	u16 vlan_id;
	u16 flags;
	struct net_device *real_dev;
	netdevice_tracker dev_tracker;
	unsigned char real_dev_addr[6];
	struct proc_dir_entry *dent;
	struct vlan_pcpu_stats __attribute__((btf_type_tag("percpu"))) *vlan_pcpu_stats;
};

struct vlan_priority_tci_mapping {
	u32 priority;
	u16 vlan_qos;
	struct vlan_priority_tci_mapping *next;
};

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

typedef struct {
	unsigned char op;
	unsigned char bits;
	unsigned short val;
} code;

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	unsigned long check;
	unsigned long total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	unsigned long hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	unsigned short lens[320];
	unsigned short work[288];
	code codes[2048];
};

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

typedef struct {
	u16 version;
	u16 length;
	u32 runtime_services_supported;
} efi_rt_properties_table_t;

struct linux_efi_memreserve {
	int size;
	atomic_t count;
	phys_addr_t next;
	struct {
		phys_addr_t base;
		phys_addr_t size;
	} entry[0];
};

struct linux_efi_initrd {
	unsigned long base;
	unsigned long size;
};

typedef bool (*smp_cond_func_t)(int, void *);

struct pmu_hw_events;

struct arm_pmu {
	struct pmu pmu;
	cpumask_t supported_cpus;
	char *name;
	int pmuver;
	irqreturn_t (*handle_irq)(struct arm_pmu *);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	int (*get_event_idx)(struct pmu_hw_events *, struct perf_event *);
	void (*clear_event_idx)(struct pmu_hw_events *, struct perf_event *);
	int (*set_event_filter)(struct hw_perf_event *, struct perf_event_attr *);
	u64 (*read_counter)(struct perf_event *);
	void (*write_counter)(struct perf_event *, u64);
	void (*start)(struct arm_pmu *);
	void (*stop)(struct arm_pmu *);
	void (*reset)(void *);
	int (*map_event)(struct perf_event *);
	int num_events;
	bool secure_access;
	unsigned long pmceid_bitmap[1];
	unsigned long pmceid_ext_bitmap[1];
	struct platform_device *plat_device;
	struct pmu_hw_events __attribute__((btf_type_tag("percpu"))) *hw_events;
	struct hlist_node node;
	struct notifier_block cpu_pm_nb;
	const struct attribute_group *attr_groups[5];
	u64 reg_pmmir;
	unsigned long acpi_cpuid;
};

struct pmu_hw_events {
	struct perf_event *events[32];
	unsigned long used_mask[1];
	raw_spinlock_t pmu_lock;
	struct arm_pmu *percpu_pmu;
	int irq;
};

struct kvm_pmu_event_filter {
	__u16 base_event;
	__u16 nevents;
	__u8 action;
	__u8 pad[3];
};

struct arm_pmu_entry {
	struct list_head entry;
	struct arm_pmu *arm_pmu;
};

struct pkvm_hyp_vcpu;

struct pkvm_hyp_vm {
	struct kvm___2 kvm;
	struct kvm___2 *host_kvm;
	struct kvm_pgtable___2 pgt;
	struct kvm_pgtable_mm_ops mm_ops;
	struct hyp_pool pool;
	hyp_spinlock_t lock;
	unsigned int nr_vcpus;
	struct pkvm_hyp_vcpu *vcpus[0];
};

struct pkvm_hyp_vcpu {
	struct kvm_vcpu___2 vcpu;
	struct kvm_vcpu___2 *host_vcpu;
	long: 64;
};

struct wq_flusher;

struct worker;

struct workqueue_attrs;

struct pool_workqueue;

struct wq_device;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int saved_max_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[24];
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int flags;
	struct pool_workqueue __attribute__((btf_type_tag("percpu"))) __attribute__((btf_type_tag("rcu"))) **cpu_pwq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct worker_pool;

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	u64 current_at;
	unsigned int current_color;
	int sleeping;
	work_func_t last_func;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	unsigned long last_active;
	unsigned int flags;
	int id;
	char desc[24];
	struct workqueue_struct *rescue_wq;
};

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[16];
	int nr_active;
	int max_active;
	struct list_head inactive_works;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	u64 stats[8];
	struct kthread_work release_work;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	unsigned long watchdog_ts;
	bool cpu_stall;
	int nr_running;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct work_struct idle_cull_work;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct list_head dying_workers;
	struct completion *detach_completion;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	struct callback_head rcu;
};

enum wq_affn_scope {
	WQ_AFFN_DFL = 0,
	WQ_AFFN_CPU = 1,
	WQ_AFFN_SMT = 2,
	WQ_AFFN_CACHE = 3,
	WQ_AFFN_NUMA = 4,
	WQ_AFFN_SYSTEM = 5,
	WQ_AFFN_NR_TYPES = 6,
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	cpumask_var_t __pod_cpumask;
	bool affn_strict;
	enum wq_affn_scope affn_scope;
	bool ordered;
};

struct wq_device {
	struct workqueue_struct *wq;
	struct device dev;
};

typedef void (*btf_trace_workqueue_queue_work)(void *, int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

struct wq_pod_type {
	int nr_pods;
	cpumask_var_t *pod_cpus;
	int *pod_node;
	int *cpu_pod;
};

enum {
	POOL_MANAGER_ACTIVE = 1,
	POOL_DISASSOCIATED = 4,
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 75000,
	MAYDAY_INITIAL_TIMEOUT = 2,
	MAYDAY_INTERVAL = 25,
	CREATE_COOLDOWN = 250,
	RESCUER_NICE_LEVEL = -20,
	HIGHPRI_NICE_LEVEL = -20,
	WQ_NAME_LEN = 24,
};

enum pool_workqueue_stats {
	PWQ_STAT_STARTED = 0,
	PWQ_STAT_COMPLETED = 1,
	PWQ_STAT_CPU_TIME = 2,
	PWQ_STAT_CPU_INTENSIVE = 3,
	PWQ_STAT_CM_WAKEUP = 4,
	PWQ_STAT_REPATRIATED = 5,
	PWQ_STAT_MAYDAY = 6,
	PWQ_STAT_RESCUED = 7,
	PWQ_NR_STATS = 8,
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	u32 __data_loc_workqueue;
	int req_cpu;
	int cpu;
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct cwt_wait {
	wait_queue_entry_t wait;
	struct work_struct *work;
};

struct work_for_cpu {
	struct work_struct work;
	long (*fn)(void *);
	void *arg;
	long ret;
};

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct trace_event_data_offsets_workqueue_queue_work {
	u32 workqueue;
};

struct pr_cont_work_struct {
	bool comma;
	work_func_t func;
	long ctr;
};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_execute_end {};

struct execute_work {
	struct work_struct work;
};

struct swsusp_header {
	char reserved[4056];
	u32 hw_sig;
	u32 crc32;
	sector_t image;
	unsigned int flags;
	char orig_sig[10];
	char sig[10];
};

struct swsusp_extent {
	struct rb_node node;
	unsigned long start;
	unsigned long end;
};

struct swsusp_info {
	struct new_utsname uts;
	u32 version_code;
	unsigned long num_physpages;
	int cpus;
	unsigned long image_pages;
	unsigned long pages;
	unsigned long size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct swap_map_page {
	sector_t entries[511];
	sector_t next_swap;
};

struct swap_map_page_list;

struct swap_map_handle {
	struct swap_map_page *cur;
	struct swap_map_page_list *maps;
	sector_t cur_swap;
	sector_t first_sector;
	unsigned int k;
	unsigned long reqd_free_pages;
	u32 crc32;
};

struct swap_map_page_list {
	struct swap_map_page *map;
	struct swap_map_page_list *next;
};

struct hib_bio_batch {
	atomic_t count;
	wait_queue_head_t wait;
	blk_status_t error;
	struct blk_plug plug;
};

struct snapshot_handle {
	unsigned int cur;
	void *buffer;
	int sync_read;
};

struct crc_data {
	struct task_struct *thr;
	atomic_t ready;
	atomic_t stop;
	unsigned int run_threads;
	wait_queue_head_t go;
	wait_queue_head_t done;
	u32 *crc32;
	size_t *unc_len[3];
	unsigned char *unc[3];
};

struct cmp_data {
	struct task_struct *thr;
	atomic_t ready;
	atomic_t stop;
	int ret;
	wait_queue_head_t go;
	wait_queue_head_t done;
	size_t unc_len;
	size_t cmp_len;
	unsigned char unc[131072];
	unsigned char cmp[143360];
	unsigned char wrk[16384];
};

struct dec_data {
	struct task_struct *thr;
	atomic_t ready;
	atomic_t stop;
	int ret;
	wait_queue_head_t go;
	wait_queue_head_t done;
	size_t unc_len;
	size_t cmp_len;
	unsigned char unc[131072];
	unsigned char cmp[143360];
};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct timens_offset {
	s64 sec;
	u64 nsec;
};

struct arch_vdso_data {};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_data arch_data;
};

struct tk_read_base {
	struct clocksource *clock;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	struct tk_read_base tkr_raw;
	u64 xtime_sec;
	unsigned long ktime_sec;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	ktime_t next_leap_ktime;
	u64 raw_sec;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
};

struct proc_timens_offset {
	int clockid;
	struct timespec64 val;
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

struct dyn_event;

struct dyn_event_operations {
	struct list_head list;
	int (*create)(const char *);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
};

enum uprobe_filter_ctx {
	UPROBE_FILTER_REGISTER = 0,
	UPROBE_FILTER_UNREGISTER = 1,
	UPROBE_FILTER_MMAP = 2,
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *);
	int (*ret_handler)(struct uprobe_consumer *, unsigned long, struct pt_regs *);
	bool (*filter)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);
	struct uprobe_consumer *next;
};

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	struct inode *inode;
	char *filename;
	unsigned long offset;
	unsigned long ref_ctr_offset;
	unsigned long nhit;
	struct trace_probe tp;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	unsigned long vaddr[0];
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	unsigned long bp_addr;
};

typedef u32 (*bpf_prog_run_fn)(const struct bpf_prog *, const void *);

struct bpf_trace_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
	bool is_uprobe;
};

typedef bool (*filter_func_t)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);

struct btf_kfunc_hook_filter {
	btf_kfunc_filter_t filters[16];
	u32 nr_filters;
};

struct btf_kfunc_set_tab {
	struct btf_id_set8 *sets[13];
	struct btf_kfunc_hook_filter hook_filters[13];
};

struct btf_id_dtor_kfunc {
	u32 btf_id;
	u32 kfunc_btf_id;
};

struct btf_id_dtor_kfunc_tab {
	u32 cnt;
	struct btf_id_dtor_kfunc dtors[0];
};

struct btf_struct_metas {
	u32 cnt;
	struct btf_struct_meta types[0];
};

struct bpf_sock;

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
	__u8 tstamp_type;
	__u64 hwtstamp;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__be16 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
	__u64 skb_hwtstamp;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

struct bpf_cgroup_dev_ctx {
	__u32 access_type;
	__u32 major;
	__u32 minor;
};

struct bpf_sysctl {
	__u32 write;
	__u32 file_pos;
};

struct bpf_sysctl_kern {
	struct ctl_table_header *head;
	struct ctl_table *table;
	void *cur_val;
	size_t cur_len;
	void *new_val;
	size_t new_len;
	int new_updated;
	int write;
	loff_t *ppos;
	u64 tmp_reg;
};

struct bpf_sockopt {
	union {
		struct bpf_sock *sk;
	};
	union {
		void *optval;
	};
	union {
		void *optval_end;
	};
	__s32 level;
	__s32 optname;
	__s32 optlen;
	__s32 retval;
};

struct bpf_sockopt_kern {
	struct sock *sk;
	u8 *optval;
	u8 *optval_end;
	s32 level;
	s32 optname;
	s32 optlen;
	struct task_struct *current_task;
	u64 tmp_reg;
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
	union {
		struct bpf_sock *sk;
	};
	union {
		struct bpf_sock *migrating_sk;
	};
};

struct bpf_sk_lookup {
	union {
		union {
			struct bpf_sock *sk;
		};
		__u64 cookie;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__be16 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
	__u32 ingress_ifindex;
};

struct bpf_nf_ctx {
	const struct nf_hook_state *state;
	struct sk_buff *skb;
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
	void *BPF_PROG_TYPE_LSM_prog;
	void *BPF_PROG_TYPE_LSM_kern;
	void *BPF_PROG_TYPE_SYSCALL_prog;
	void *BPF_PROG_TYPE_SYSCALL_kern;
	struct bpf_nf_ctx BPF_PROG_TYPE_NETFILTER_prog;
	struct bpf_nf_ctx BPF_PROG_TYPE_NETFILTER_kern;
};

struct btf_verifier_env;

struct resolve_vertex;

struct btf_show;

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, va_list);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct bpf_cand_cache {
	const char *name;
	u32 name_len;
	u16 kind;
	u16 cnt;
	struct {
		const struct btf *btf;
		u32 id;
	} cands[0];
};

enum bpf_type_flag {
	PTR_MAYBE_NULL = 256,
	MEM_RDONLY = 512,
	MEM_RINGBUF = 1024,
	MEM_USER = 2048,
	MEM_PERCPU = 4096,
	OBJ_RELEASE = 8192,
	PTR_UNTRUSTED = 16384,
	MEM_UNINIT = 32768,
	DYNPTR_TYPE_LOCAL = 65536,
	DYNPTR_TYPE_RINGBUF = 131072,
	MEM_FIXED_SIZE = 262144,
	MEM_ALLOC = 524288,
	PTR_TRUSTED = 1048576,
	MEM_RCU = 2097152,
	NON_OWN_REF = 4194304,
	DYNPTR_TYPE_SKB = 8388608,
	DYNPTR_TYPE_XDP = 16777216,
	__BPF_TYPE_FLAG_MAX = 16777217,
	__BPF_TYPE_LAST_FLAG = 16777216,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

enum {
	BTF_MODULE_F_LIVE = 1,
};

enum btf_kfunc_hook {
	BTF_KFUNC_HOOK_COMMON = 0,
	BTF_KFUNC_HOOK_XDP = 1,
	BTF_KFUNC_HOOK_TC = 2,
	BTF_KFUNC_HOOK_STRUCT_OPS = 3,
	BTF_KFUNC_HOOK_TRACING = 4,
	BTF_KFUNC_HOOK_SYSCALL = 5,
	BTF_KFUNC_HOOK_FMODRET = 6,
	BTF_KFUNC_HOOK_CGROUP_SKB = 7,
	BTF_KFUNC_HOOK_SCHED_ACT = 8,
	BTF_KFUNC_HOOK_SK_SKB = 9,
	BTF_KFUNC_HOOK_SOCKET_FILTER = 10,
	BTF_KFUNC_HOOK_LWT = 11,
	BTF_KFUNC_HOOK_NETFILTER = 12,
	BTF_KFUNC_HOOK_MAX = 13,
};

enum {
	BTF_KFUNC_SET_MAX_CNT = 256,
	BTF_DTOR_KFUNC_MAX_CNT = 256,
	BTF_KFUNC_FILTER_MAX_CNT = 16,
};

enum bpf_core_relo_kind {
	BPF_CORE_FIELD_BYTE_OFFSET = 0,
	BPF_CORE_FIELD_BYTE_SIZE = 1,
	BPF_CORE_FIELD_EXISTS = 2,
	BPF_CORE_FIELD_SIGNED = 3,
	BPF_CORE_FIELD_LSHIFT_U64 = 4,
	BPF_CORE_FIELD_RSHIFT_U64 = 5,
	BPF_CORE_TYPE_ID_LOCAL = 6,
	BPF_CORE_TYPE_ID_TARGET = 7,
	BPF_CORE_TYPE_EXISTS = 8,
	BPF_CORE_TYPE_SIZE = 9,
	BPF_CORE_ENUMVAL_EXISTS = 10,
	BPF_CORE_ENUMVAL_VALUE = 11,
	BPF_CORE_TYPE_MATCHES = 12,
};

enum {
	BTF_FIELD_IGNORE = 0,
	BTF_FIELD_FOUND = 1,
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

struct btf_module {
	struct list_head list;
	struct module *module;
	struct btf *btf;
	struct bin_attribute *sysfs_attr;
	int flags;
};

typedef u64 (*btf_bpf_btf_find_by_name_kind)(char *, int, u32, int);

struct btf_decl_tag {
	__s32 component_idx;
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_var {
	__u32 linkage;
};

struct btf_enum64 {
	__u32 name_off;
	__u32 val_lo32;
	__u32 val_hi32;
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

struct btf_field_info {
	enum btf_field_type type;
	u32 off;
	union {
		struct {
			u32 type_id;
		} kptr;
		struct {
			const char *node_name;
			u32 value_btf_id;
		} graph_root;
	};
};

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

typedef void (*swap_r_func_t)(void *, void *, int, const void *);

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

struct bpf_core_ctx {
	struct bpf_verifier_log *log;
	const struct btf *btf;
};

struct bpf_core_relo {
	__u32 insn_off;
	__u32 type_id;
	__u32 access_str_off;
	enum bpf_core_relo_kind kind;
};

struct bpf_core_cand;

struct bpf_core_cand_list {
	struct bpf_core_cand *cands;
	int len;
};

struct bpf_core_cand {
	const struct btf *btf;
	__u32 id;
};

struct bpf_core_accessor {
	__u32 type_id;
	__u32 idx;
	const char *name;
};

struct bpf_core_spec {
	const struct btf *btf;
	struct bpf_core_accessor spec[64];
	__u32 root_type_id;
	enum bpf_core_relo_kind relo_kind;
	int len;
	int raw_spec[64];
	int raw_len;
	__u32 bit_offset;
};

struct bpf_core_relo_res {
	__u64 orig_val;
	__u64 new_val;
	bool poison;
	bool validate;
	bool fail_memsz_adjust;
	__u32 orig_sz;
	__u32 orig_type_id;
	__u32 new_sz;
	__u32 new_type_id;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
	__u64 name;
	__u32 name_len;
	__u32 kernel_btf;
};

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[0];
};

struct vm_unmapped_area_info;

typedef void (*btf_trace_vm_unmapped_area)(void *, unsigned long, struct vm_unmapped_area_info *);

struct vm_unmapped_area_info {
	unsigned long flags;
	unsigned long length;
	unsigned long low_limit;
	unsigned long high_limit;
	unsigned long align_mask;
	unsigned long align_offset;
};

typedef void (*btf_trace_vma_mas_szero)(void *, struct maple_tree *, unsigned long, unsigned long);

typedef void (*btf_trace_vma_store)(void *, struct maple_tree *, struct vm_area_struct *);

typedef void (*btf_trace_exit_mmap)(void *, struct mm_struct *);

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	unsigned long rb_subtree_last;
};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	unsigned long addr;
	unsigned long total_vm;
	unsigned long flags;
	unsigned long length;
	unsigned long low_limit;
	unsigned long high_limit;
	unsigned long align_mask;
	unsigned long align_offset;
	char __data[0];
};

struct trace_event_raw_vma_mas_szero {
	struct trace_entry ent;
	struct maple_tree *mt;
	unsigned long start;
	unsigned long end;
	char __data[0];
};

struct trace_event_raw_vma_store {
	struct trace_entry ent;
	struct maple_tree *mt;
	struct vm_area_struct *vma;
	unsigned long vm_start;
	unsigned long vm_end;
	char __data[0];
};

struct trace_event_raw_exit_mmap {
	struct trace_entry ent;
	struct mm_struct *mm;
	struct maple_tree *mt;
	char __data[0];
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct vma_prepare {
	struct vm_area_struct *vma;
	struct vm_area_struct *adj_next;
	struct file *file;
	struct address_space *mapping;
	struct anon_vma *anon_vma;
	struct vm_area_struct *insert;
	struct vm_area_struct *remove;
	struct vm_area_struct *remove2;
};

struct trace_event_data_offsets_vm_unmapped_area {};

struct trace_event_data_offsets_vma_mas_szero {};

struct trace_event_data_offsets_vma_store {};

struct trace_event_data_offsets_exit_mmap {};

enum {
	PAGE_WAS_MAPPED = 1,
	PAGE_WAS_MLOCKED = 2,
};

struct rmap_walk_control {
	void *arg;
	bool try_lock;
	bool contended;
	bool (*rmap_one)(struct folio *, struct vm_area_struct *, unsigned long, void *);
	int (*done)(struct folio *);
	struct anon_vma * (*anon_lock)(struct folio *, struct rmap_walk_control *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct page_vma_mapped_walk {
	unsigned long pfn;
	unsigned long nr_pages;
	unsigned long pgoff;
	struct vm_area_struct *vma;
	unsigned long address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct migrate_pages_stats {
	int nr_succeeded;
	int nr_failed_pages;
	int nr_thp_succeeded;
	int nr_thp_failed;
	int nr_thp_split;
	int nr_split;
};

union migration_ptr {
	struct anon_vma *anon_vma;
	struct address_space *mapping;
};

typedef int filler_t(struct file *, struct folio *);

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

struct core_vma_metadata;

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct file *file;
	unsigned long limit;
	unsigned long mm_flags;
	int cpu;
	loff_t written;
	loff_t pos;
	loff_t to_skip;
	int vma_count;
	size_t vma_data_size;
	struct core_vma_metadata *vma_meta;
};

struct core_vma_metadata {
	unsigned long start;
	unsigned long end;
	unsigned long flags;
	unsigned long dump_size;
	unsigned long pgoff;
	struct file *file;
};

struct gnu_property {
	u32 pr_type;
	u32 pr_datasz;
};

typedef unsigned short __kernel_old_uid_t;

typedef __kernel_old_uid_t old_uid_t;

typedef unsigned short __kernel_old_gid_t;

typedef __kernel_old_gid_t old_gid_t;

struct arch_elf_state {
	int flags;
};

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

typedef s32 compat_timer_t;

typedef s32 compat_clock_t;

struct compat_siginfo {
	int si_signo;
	int si_errno;
	int si_code;
	union {
		int _pad[29];
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
		} _kill;
		struct {
			compat_timer_t _tid;
			int _overrun;
			compat_sigval_t _sigval;
		} _timer;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			compat_sigval_t _sigval;
		} _rt;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			int _status;
			compat_clock_t _utime;
			compat_clock_t _stime;
		} _sigchld;
		struct {
			compat_uptr_t _addr;
			union {
				int _trapno;
				short _addr_lsb;
				struct {
					char _dummy_bnd[4];
					compat_uptr_t _lower;
					compat_uptr_t _upper;
				} _addr_bnd;
				struct {
					char _dummy_pkey[4];
					u32 _pkey;
				} _addr_pkey;
				struct {
					compat_ulong_t _data;
					u32 _type;
					u32 _flags;
				} _perf;
			};
		} _sigfault;
		struct {
			compat_long_t _band;
			int _fd;
		} _sigpoll;
		struct {
			compat_uptr_t _call_addr;
			int _syscall;
			unsigned int _arch;
		} _sigsys;
	} _sifields;
};

typedef struct compat_siginfo compat_siginfo_t;

struct elf_thread_core_info;

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	compat_siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct compat_elf_siginfo {
	compat_int_t si_signo;
	compat_int_t si_code;
	compat_int_t si_errno;
};

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct compat_elf_prstatus_common {
	struct compat_elf_siginfo pr_info;
	short pr_cursig;
	compat_ulong_t pr_sigpend;
	compat_ulong_t pr_sighold;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	struct old_timeval32 pr_utime;
	struct old_timeval32 pr_stime;
	struct old_timeval32 pr_cutime;
	struct old_timeval32 pr_cstime;
};

typedef unsigned int compat_elf_greg_t;

typedef compat_elf_greg_t compat_elf_gregset_t[18];

struct compat_elf_prstatus {
	struct compat_elf_prstatus_common common;
	compat_elf_gregset_t pr_reg;
	compat_int_t pr_fpvalid;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct compat_elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct compat_elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	compat_ulong_t pr_flag;
	__compat_uid_t pr_uid;
	__compat_gid_t pr_gid;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct elf32_shdr {
	Elf32_Word sh_name;
	Elf32_Word sh_type;
	Elf32_Word sh_flags;
	Elf32_Addr sh_addr;
	Elf32_Off sh_offset;
	Elf32_Word sh_size;
	Elf32_Word sh_link;
	Elf32_Word sh_info;
	Elf32_Word sh_addralign;
	Elf32_Word sh_entsize;
};

enum {
	PROC_ENTRY_PERMANENT = 1,
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct ext4_dir_entry_hash {
	__le32 hash;
	__le32 minor_hash;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
};

struct ext2_block_alloc_info;

struct ext2_inode_info {
	__le32 i_data[15];
	__u32 i_flags;
	__u32 i_faddr;
	__u8 i_frag_no;
	__u8 i_frag_size;
	__u16 i_state;
	__u32 i_file_acl;
	__u32 i_dir_acl;
	__u32 i_dtime;
	__u32 i_block_group;
	struct ext2_block_alloc_info *i_block_alloc_info;
	__u32 i_dir_start_lookup;
	rwlock_t i_meta_lock;
	struct mutex truncate_mutex;
	struct inode vfs_inode;
	struct list_head i_orphan;
	struct dquot *i_dquot[3];
};

typedef unsigned long ext2_fsblk_t;

struct ext2_reserve_window {
	ext2_fsblk_t _rsv_start;
	ext2_fsblk_t _rsv_end;
};

struct ext2_reserve_window_node {
	struct rb_node rsv_node;
	__u32 rsv_goal_size;
	__u32 rsv_alloc_hit;
	struct ext2_reserve_window rsv_window;
};

struct ext2_block_alloc_info {
	struct ext2_reserve_window_node rsv_window_node;
	__u32 last_alloc_logical_block;
	ext2_fsblk_t last_alloc_physical_block;
};

struct fileattr {
	u32 flags;
	u32 fsx_xflags;
	u32 fsx_extsize;
	u32 fsx_nextents;
	u32 fsx_projid;
	u32 fsx_cowextsize;
	bool flags_valid: 1;
	bool fsx_valid: 1;
};

struct ext2_super_block;

struct ext2_sb_info {
	unsigned long s_inodes_per_block;
	unsigned long s_blocks_per_group;
	unsigned long s_inodes_per_group;
	unsigned long s_itb_per_group;
	unsigned long s_gdb_count;
	unsigned long s_desc_per_block;
	unsigned long s_groups_count;
	unsigned long s_overhead_last;
	unsigned long s_blocks_last;
	struct buffer_head *s_sbh;
	struct ext2_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned long s_mount_opt;
	unsigned long s_sb_block;
	kuid_t s_resuid;
	kgid_t s_resgid;
	unsigned short s_mount_state;
	unsigned short s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	spinlock_t s_next_gen_lock;
	u32 s_next_generation;
	unsigned long s_dir_count;
	u8 *s_debts;
	struct percpu_counter s_freeblocks_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct blockgroup_lock *s_blockgroup_lock;
	spinlock_t s_rsv_window_lock;
	struct rb_root s_rsv_window_root;
	struct ext2_reserve_window_node s_rsv_window_head;
	spinlock_t s_lock;
	struct mb_cache *s_ea_block_cache;
	struct dax_device *s_daxdev;
	u64 s_dax_part_off;
};

struct ext2_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count;
	__le32 s_r_blocks_count;
	__le32 s_free_blocks_count;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_frag_size;
	__le32 s_blocks_per_group;
	__le32 s_frags_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__u16 s_padding1;
	__u8 s_journal_uuid[16];
	__u32 s_journal_inum;
	__u32 s_journal_dev;
	__u32 s_last_orphan;
	__u32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_reserved_char_pad;
	__u16 s_reserved_word_pad;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__u32 s_reserved[190];
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct msdos_inode_info {
	spinlock_t cache_lru_lock;
	struct list_head cache_lru;
	int nr_caches;
	unsigned int cache_valid_id;
	loff_t mmu_private;
	int i_start;
	int i_logstart;
	int i_attrs;
	loff_t i_pos;
	struct hlist_node i_fat_hash;
	struct hlist_node i_dir_hash;
	struct rw_semaphore truncate_lock;
	struct timespec64 i_crtime;
	struct inode vfs_inode;
};

struct fat_mount_options {
	kuid_t fs_uid;
	kgid_t fs_gid;
	unsigned short fs_fmask;
	unsigned short fs_dmask;
	unsigned short codepage;
	int time_offset;
	char *iocharset;
	unsigned short shortname;
	unsigned char name_check;
	unsigned char errors;
	unsigned char nfs;
	unsigned short allow_utime;
	unsigned int quiet: 1;
	unsigned int showexec: 1;
	unsigned int sys_immutable: 1;
	unsigned int dotsOK: 1;
	unsigned int isvfat: 1;
	unsigned int utf8: 1;
	unsigned int unicode_xlate: 1;
	unsigned int numtail: 1;
	unsigned int flush: 1;
	unsigned int nocase: 1;
	unsigned int usefree: 1;
	unsigned int tz_set: 1;
	unsigned int rodir: 1;
	unsigned int discard: 1;
	unsigned int dos1xfloppy: 1;
};

struct nls_table;

struct fatent_operations;

struct msdos_sb_info {
	unsigned short sec_per_clus;
	unsigned short cluster_bits;
	unsigned int cluster_size;
	unsigned char fats;
	unsigned char fat_bits;
	unsigned short fat_start;
	unsigned long fat_length;
	unsigned long dir_start;
	unsigned short dir_entries;
	unsigned long data_start;
	unsigned long max_cluster;
	unsigned long root_cluster;
	unsigned long fsinfo_sector;
	struct mutex fat_lock;
	struct mutex nfs_build_inode_lock;
	struct mutex s_lock;
	unsigned int prev_free;
	unsigned int free_clusters;
	unsigned int free_clus_valid;
	struct fat_mount_options options;
	struct nls_table *nls_disk;
	struct nls_table *nls_io;
	const void *dir_ops;
	int dir_per_block;
	int dir_per_block_bits;
	unsigned int vol_id;
	int fatent_shift;
	const struct fatent_operations *fatent_ops;
	struct inode *fat_inode;
	struct inode *fsinfo_inode;
	struct ratelimit_state ratelimit;
	spinlock_t inode_hash_lock;
	struct hlist_head inode_hashtable[256];
	spinlock_t dir_hash_lock;
	struct hlist_head dir_hashtable[256];
	unsigned int dirty;
	struct callback_head rcu;
};

typedef u16 wchar_t;

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct fat_entry;

struct fatent_operations {
	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
	void (*ent_set_ptr)(struct fat_entry *, int);
	int (*ent_bread)(struct super_block *, struct fat_entry *, int, sector_t);
	int (*ent_get)(struct fat_entry *);
	void (*ent_put)(struct fat_entry *, int);
	int (*ent_next)(struct fat_entry *);
};

struct fat_entry {
	int entry;
	union {
		u8 *ent12_p[2];
		__le16 *ent16_p;
		__le32 *ent32_p;
	} u;
	int nr_bhs;
	struct buffer_head *bhs[2];
	struct inode *fat_inode;
};

enum {
	TLS_NO_KEYRING = 0,
	TLS_NO_PEERID = 0,
	TLS_NO_CERT = 0,
	TLS_NO_PRIVKEY = 0,
};

enum nfs_param {
	Opt_ac = 0,
	Opt_acdirmax = 1,
	Opt_acdirmin = 2,
	Opt_acl___2 = 3,
	Opt_acregmax = 4,
	Opt_acregmin = 5,
	Opt_actimeo = 6,
	Opt_addr = 7,
	Opt_bg = 8,
	Opt_bsize = 9,
	Opt_clientaddr = 10,
	Opt_cto = 11,
	Opt_fg = 12,
	Opt_fscache = 13,
	Opt_fscache_flag = 14,
	Opt_hard = 15,
	Opt_intr = 16,
	Opt_local_lock = 17,
	Opt_lock = 18,
	Opt_lookupcache = 19,
	Opt_migration = 20,
	Opt_minorversion = 21,
	Opt_mountaddr = 22,
	Opt_mounthost = 23,
	Opt_mountport = 24,
	Opt_mountproto = 25,
	Opt_mountvers = 26,
	Opt_namelen = 27,
	Opt_nconnect = 28,
	Opt_max_connect = 29,
	Opt_port = 30,
	Opt_posix = 31,
	Opt_proto = 32,
	Opt_rdirplus = 33,
	Opt_rdma = 34,
	Opt_resvport = 35,
	Opt_retrans = 36,
	Opt_retry = 37,
	Opt_rsize = 38,
	Opt_sec = 39,
	Opt_sharecache = 40,
	Opt_sloppy = 41,
	Opt_soft = 42,
	Opt_softerr = 43,
	Opt_softreval = 44,
	Opt_source = 45,
	Opt_tcp = 46,
	Opt_timeo = 47,
	Opt_trunkdiscovery = 48,
	Opt_udp = 49,
	Opt_v = 50,
	Opt_vers = 51,
	Opt_wsize = 52,
	Opt_write = 53,
	Opt_xprtsec = 54,
};

enum {
	Opt_xprt_rdma = 0,
	Opt_xprt_rdma6 = 1,
	Opt_xprt_tcp = 2,
	Opt_xprt_tcp6 = 3,
	Opt_xprt_udp = 4,
	Opt_xprt_udp6 = 5,
	nr__Opt_xprt = 6,
};

enum {
	Opt_lookupcache_all = 0,
	Opt_lookupcache_none = 1,
	Opt_lookupcache_positive = 2,
};

enum {
	Opt_local_lock_all = 0,
	Opt_local_lock_flock = 1,
	Opt_local_lock_none = 2,
	Opt_local_lock_posix = 3,
};

enum {
	Opt_write_lazy = 0,
	Opt_write_eager = 1,
	Opt_write_wait = 2,
};

enum {
	Opt_vers_2 = 0,
	Opt_vers_3 = 1,
	Opt_vers_4 = 2,
	Opt_vers_4_0 = 3,
	Opt_vers_4_1 = 4,
	Opt_vers_4_2 = 5,
};

enum {
	Opt_sec_krb5 = 0,
	Opt_sec_krb5i = 1,
	Opt_sec_krb5p = 2,
	Opt_sec_lkey = 3,
	Opt_sec_lkeyi = 4,
	Opt_sec_lkeyp = 5,
	Opt_sec_none = 6,
	Opt_sec_spkm = 7,
	Opt_sec_spkmi = 8,
	Opt_sec_spkmp = 9,
	Opt_sec_sys = 10,
	nr__Opt_sec = 11,
};

enum {
	Opt_xprtsec_none = 0,
	Opt_xprtsec_tls = 1,
	Opt_xprtsec_mtls = 2,
	nr__Opt_xprtsec = 3,
};

typedef u32 compat_uint_t;

struct compat_nfs_string {
	compat_uint_t len;
	compat_uptr_t data;
};

struct compat_nfs4_mount_data_v1 {
	compat_int_t version;
	compat_int_t flags;
	compat_int_t rsize;
	compat_int_t wsize;
	compat_int_t timeo;
	compat_int_t retrans;
	compat_int_t acregmin;
	compat_int_t acregmax;
	compat_int_t acdirmin;
	compat_int_t acdirmax;
	struct compat_nfs_string client_addr;
	struct compat_nfs_string mnt_path;
	struct compat_nfs_string hostname;
	compat_uint_t host_addrlen;
	compat_uptr_t host_addr;
	compat_int_t proto;
	compat_int_t auth_flavourlen;
	compat_uptr_t auth_flavours;
};

struct nfs2_fh {
	char data[32];
};

struct nfs3_fh {
	unsigned short size;
	unsigned char data[64];
};

struct nfs_mount_data {
	int version;
	int fd;
	struct nfs2_fh old_root;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct sockaddr_in addr;
	char hostname[256];
	int namlen;
	unsigned int bsize;
	struct nfs3_fh root;
	int pseudoflavor;
	char context[257];
};

struct nfs_string {
	unsigned int len;
	const char __attribute__((btf_type_tag("user"))) *data;
};

struct nfs4_mount_data {
	int version;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct nfs_string client_addr;
	struct nfs_string mnt_path;
	struct nfs_string hostname;
	unsigned int host_addrlen;
	struct sockaddr __attribute__((btf_type_tag("user"))) *host_addr;
	int proto;
	int auth_flavourlen;
	int __attribute__((btf_type_tag("user"))) *auth_flavours;
};

struct nfs4_add_xprt_data {
	struct nfs_client *clp;
	const struct cred *cred;
};

struct rpc_add_xprt_test {
	void (*add_xprt_test)(struct rpc_clnt *, struct rpc_xprt *, void *);
	void *data;
};

enum {
	NLM_LCK_GRANTED = 0,
	NLM_LCK_DENIED = 1,
	NLM_LCK_DENIED_NOLOCKS = 2,
	NLM_LCK_BLOCKED = 3,
	NLM_LCK_DENIED_GRACE_PERIOD = 4,
	NLM_DEADLCK = 5,
	NLM_ROFS = 6,
	NLM_STALE_FH = 7,
	NLM_FBIG = 8,
	NLM_FAILED = 9,
};

struct nlm_cookie {
	unsigned char data[32];
	unsigned int len;
};

struct nlm_lock {
	char *caller;
	unsigned int len;
	struct nfs_fh fh;
	struct xdr_netobj oh;
	u32 svid;
	u64 lock_start;
	u64 lock_len;
	struct file_lock fl;
};

struct nlm_res {
	struct nlm_cookie cookie;
	__be32 status;
	struct nlm_lock lock;
};

struct nlm_args {
	struct nlm_cookie cookie;
	struct nlm_lock lock;
	u32 block;
	u32 reclaim;
	u32 state;
	u32 monitor;
	u32 fsm_access;
	u32 fsm_mode;
};

struct efivarfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
};

struct efivarfs_fs_info {
	struct efivarfs_mount_opts mount_opts;
};

struct efi_variable {
	efi_char16_t VariableName[512];
	efi_guid_t VendorGuid;
	unsigned long DataSize;
	__u8 Data[1024];
	efi_status_t Status;
	__u32 Attributes;
} __attribute__((packed));

struct efivar_entry {
	struct efi_variable var;
	struct list_head list;
	struct kobject kobj;
};

enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC = 0,
	CRYPTOCFGA_PRIORITY_VAL = 1,
	CRYPTOCFGA_REPORT_LARVAL = 2,
	CRYPTOCFGA_REPORT_HASH = 3,
	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
	CRYPTOCFGA_REPORT_AEAD = 5,
	CRYPTOCFGA_REPORT_COMPRESS = 6,
	CRYPTOCFGA_REPORT_RNG = 7,
	CRYPTOCFGA_REPORT_CIPHER = 8,
	CRYPTOCFGA_REPORT_AKCIPHER = 9,
	CRYPTOCFGA_REPORT_KPP = 10,
	CRYPTOCFGA_REPORT_ACOMP = 11,
	CRYPTOCFGA_STAT_LARVAL = 12,
	CRYPTOCFGA_STAT_HASH = 13,
	CRYPTOCFGA_STAT_BLKCIPHER = 14,
	CRYPTOCFGA_STAT_AEAD = 15,
	CRYPTOCFGA_STAT_COMPRESS = 16,
	CRYPTOCFGA_STAT_RNG = 17,
	CRYPTOCFGA_STAT_CIPHER = 18,
	CRYPTOCFGA_STAT_AKCIPHER = 19,
	CRYPTOCFGA_STAT_KPP = 20,
	CRYPTOCFGA_STAT_ACOMP = 21,
	__CRYPTOCFGA_MAX = 22,
};

struct crypto_akcipher {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct akcipher_request;

struct akcipher_alg {
	int (*sign)(struct akcipher_request *);
	int (*verify)(struct akcipher_request *);
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	struct crypto_alg base;
};

typedef void (*crypto_completion_t)(void *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	union {
		struct {
			char head[72];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct crypto_istat_akcipher {
	atomic64_t encrypt_cnt;
	atomic64_t encrypt_tlen;
	atomic64_t decrypt_cnt;
	atomic64_t decrypt_tlen;
	atomic64_t verify_cnt;
	atomic64_t sign_cnt;
	atomic64_t err_cnt;
};

struct crypto_akcipher_sync_data {
	struct crypto_akcipher *tfm;
	const void *src;
	void *dst;
	unsigned int slen;
	unsigned int dlen;
	struct akcipher_request *req;
	struct crypto_wait cwait;
	struct scatterlist sg;
	u8 *buf;
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_report_akcipher {
	char type[64];
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

typedef struct blkcg_policy_data *blkcg_pol_alloc_cpd_fn(gfp_t);

typedef void blkcg_pol_free_cpd_fn(struct blkcg_policy_data *);

typedef struct blkg_policy_data *blkcg_pol_alloc_pd_fn(struct gendisk *, struct blkcg *, gfp_t);

typedef void blkcg_pol_init_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_online_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_offline_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_free_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_reset_pd_stats_fn(struct blkg_policy_data *);

typedef void blkcg_pol_stat_pd_fn(struct blkg_policy_data *, struct seq_file *);

struct blkcg_policy {
	int plid;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	blkcg_pol_alloc_cpd_fn *cpd_alloc_fn;
	blkcg_pol_free_cpd_fn *cpd_free_fn;
	blkcg_pol_alloc_pd_fn *pd_alloc_fn;
	blkcg_pol_init_pd_fn *pd_init_fn;
	blkcg_pol_online_pd_fn *pd_online_fn;
	blkcg_pol_offline_pd_fn *pd_offline_fn;
	blkcg_pol_free_pd_fn *pd_free_fn;
	blkcg_pol_reset_pd_stats_fn *pd_reset_stats_fn;
	blkcg_pol_stat_pd_fn *pd_stat_fn;
};

enum blkg_iostat_type {
	BLKG_IOSTAT_READ = 0,
	BLKG_IOSTAT_WRITE = 1,
	BLKG_IOSTAT_DISCARD = 2,
	BLKG_IOSTAT_NR = 3,
};

struct blkg_conf_ctx {
	char *input;
	char *body;
	struct block_device *bdev;
	struct blkcg_gq *blkg;
};

enum {
	IO_SQ_THREAD_SHOULD_STOP = 0,
	IO_SQ_THREAD_SHOULD_PARK = 1,
};

typedef uint32_t U32;

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

typedef uint8_t BYTE;

typedef struct {
	BYTE nbBits;
	BYTE byte;
} HUF_DEltX1;

typedef struct {
	U32 rankVal[13];
	U32 rankStart[13];
	U32 statsWksp[218];
	BYTE symbols[256];
	BYTE huffWeight[256];
} HUF_ReadDTableX1_Workspace;

typedef uint16_t U16;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX2;

typedef U32 rankValCol_t[13];

typedef struct {
	BYTE symbol;
} sortedSymbol_t;

typedef struct {
	rankValCol_t rankVal[12];
	U32 rankStats[13];
	U32 rankStart0[15];
	sortedSymbol_t sortedSymbol[256];
	BYTE weightList[256];
	U32 calleeWksp[218];
} HUF_ReadDTableX2_Workspace;

typedef uint64_t U64;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef U32 HUF_DTable;

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
	const char *limitPtr;
} BIT_DStream_t;

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

struct node_groups {
	unsigned int id;
	union {
		unsigned int ngroups;
		unsigned int ncpus;
	};
};

struct owl_sirq_params {
	bool reg_shared;
	u16 reg_offset[3];
};

struct owl_sirq_chip_data {
	const struct owl_sirq_params *params;
	void *base;
	raw_spinlock_t lock;
	u32 ext_irqs[3];
};

struct rzg2l_irqc_priv {
	void *base;
	struct irq_fwspec fwspec[41];
	raw_spinlock_t lock;
};

enum xgene_phy_mode {
	MODE_SATA = 0,
	MODE_SGMII = 1,
	MODE_PCIE = 2,
	MODE_USB = 3,
	MODE_XFI = 4,
	MODE_MAX = 5,
};

enum clk_type_t {
	CLK_EXT_DIFF = 0,
	CLK_INT_DIFF = 1,
	CLK_INT_SING = 2,
};

enum cmu_type_t {
	REF_CMU = 0,
	PHY_CMU = 1,
};

struct xgene_sata_override_param {
	u32 speed[2];
	u32 txspeed[3];
	u32 txboostgain[6];
	u32 txeyetuning[6];
	u32 txeyedirection[6];
	u32 txamplitude[6];
	u32 txprecursor_cn1[6];
	u32 txprecursor_cn2[6];
	u32 txpostcursor_cp1[6];
};

struct xgene_phy_ctx {
	struct device *dev;
	struct phy *phy;
	enum xgene_phy_mode mode;
	enum clk_type_t clk_type;
	void *sds_base;
	struct clk *clk;
	struct xgene_sata_override_param sata_param;
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

struct radix_tree_iter {
	unsigned long index;
	unsigned long next_index;
	unsigned long tags;
	struct xa_node *node;
};

struct pinctrl_setting_configs {
	unsigned int group_or_pin;
	unsigned long *configs;
	unsigned int num_configs;
};

struct pinctrl_setting {
	struct list_head node;
	enum pinctrl_map_type type;
	struct pinctrl_dev *pctldev;
	const char *dev_name;
	union {
		struct pinctrl_setting_mux mux;
		struct pinctrl_setting_configs configs;
	} data;
};

struct mtk_pinctrl_devdata;

struct mtk_pinctrl___2 {
	struct regmap *regmap1;
	struct regmap *regmap2;
	struct pinctrl_desc pctl_desc;
	struct device *dev;
	struct gpio_chip *chip;
	struct mtk_pinctrl_group *groups;
	unsigned int ngroups;
	const char **grp_names;
	struct pinctrl_dev *pctl_dev;
	const struct mtk_pinctrl_devdata *devdata;
	struct mtk_eint *eint;
};

struct mtk_desc_pin;

struct mtk_drv_group_desc;

struct mtk_pin_drv_grp;

struct mtk_pin_ies_smt_set;

struct mtk_pin_spec_pupd_set_samereg;

struct mtk_pinctrl_devdata {
	const struct mtk_desc_pin *pins;
	unsigned int npins;
	const struct mtk_drv_group_desc *grp_desc;
	unsigned int n_grp_cls;
	const struct mtk_pin_drv_grp *pin_drv_grp;
	unsigned int n_pin_drv_grps;
	const struct mtk_pin_ies_smt_set *spec_ies;
	unsigned int n_spec_ies;
	const struct mtk_pin_spec_pupd_set_samereg *spec_pupd;
	unsigned int n_spec_pupd;
	const struct mtk_pin_ies_smt_set *spec_smt;
	unsigned int n_spec_smt;
	int (*spec_pull_set)(struct regmap *, const struct mtk_pinctrl_devdata *, unsigned int, bool, unsigned int);
	int (*spec_ies_smt_set)(struct regmap *, const struct mtk_pinctrl_devdata *, unsigned int, int, enum pin_config_param);
	void (*spec_pinmux_set)(struct regmap *, unsigned int, unsigned int);
	void (*spec_dir_set)(unsigned int *, unsigned int);
	int (*mt8365_set_clr_mode)(struct regmap *, unsigned int, unsigned int, unsigned int, bool, bool);
	unsigned int dir_offset;
	unsigned int ies_offset;
	unsigned int smt_offset;
	unsigned int pullen_offset;
	unsigned int pullsel_offset;
	unsigned int drv_offset;
	unsigned int dout_offset;
	unsigned int din_offset;
	unsigned int pinmux_offset;
	unsigned short type1_start;
	unsigned short type1_end;
	unsigned char port_shf;
	unsigned char port_mask;
	unsigned char port_align;
	struct mtk_eint_hw eint_hw;
	struct mtk_eint_regs *eint_regs;
	unsigned int mode_mask;
	unsigned int mode_per_reg;
	unsigned int mode_shf;
};

struct mtk_desc_eint {
	unsigned char eintmux;
	unsigned char eintnum;
};

struct mtk_desc_function;

struct mtk_desc_pin {
	struct pinctrl_pin_desc pin;
	const struct mtk_desc_eint eint;
	const struct mtk_desc_function *functions;
};

struct mtk_desc_function {
	const char *name;
	unsigned char muxval;
};

struct mtk_drv_group_desc {
	unsigned char min_drv;
	unsigned char max_drv;
	unsigned char low_bit;
	unsigned char high_bit;
	unsigned char step;
};

struct mtk_pin_drv_grp {
	unsigned short pin;
	unsigned short offset;
	unsigned char bit;
	unsigned char grp;
};

struct mtk_pin_ies_smt_set {
	unsigned short start;
	unsigned short end;
	unsigned short offset;
	unsigned char bit;
};

struct mtk_pin_spec_pupd_set_samereg {
	unsigned short pin;
	unsigned short offset;
	unsigned char pupd_bit;
	unsigned char r1_bit;
	unsigned char r0_bit;
};

struct sunxi_pinctrl_regulator {
	struct regulator *regulator;
	refcount_t refcount;
};

struct sunxi_pinctrl_function;

struct sunxi_pinctrl_group;

struct sunxi_pinctrl {
	void *membase;
	struct gpio_chip *chip;
	const struct sunxi_pinctrl_desc *desc;
	struct device *dev;
	struct sunxi_pinctrl_regulator regulators[9];
	struct irq_domain *domain;
	struct sunxi_pinctrl_function *functions;
	unsigned int nfunctions;
	struct sunxi_pinctrl_group *groups;
	unsigned int ngroups;
	int *irq;
	unsigned int *irq_array;
	raw_spinlock_t lock;
	struct pinctrl_dev *pctl_dev;
	unsigned long variant;
	u32 bank_mem_size;
	u32 pull_regs_offset;
	u32 dlevel_field_width;
};

struct sunxi_pinctrl_function {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct sunxi_pinctrl_group {
	const char *name;
	unsigned int pin;
};

struct gpio_device {
	struct device dev;
	struct cdev chrdev;
	int id;
	struct device *mockdev;
	struct module *owner;
	struct gpio_chip *chip;
	struct gpio_desc *descs;
	int base;
	u16 ngpio;
	const char *label;
	void *data;
	struct list_head list;
	struct blocking_notifier_head line_state_notifier;
	struct blocking_notifier_head device_notifier;
	struct rw_semaphore sem;
	struct list_head pin_ranges;
};

struct visconti_gpio {
	void *base;
	spinlock_t lock;
	struct gpio_chip gpio_chip;
	struct device *dev;
};

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, bool);
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_BPINFO = 64,
	NVME_REG_BPRSEL = 68,
	NVME_REG_BPMBL = 72,
	NVME_REG_CMBMSC = 80,
	NVME_REG_CRTO = 104,
	NVME_REG_PMRCAP = 3584,
	NVME_REG_PMRCTL = 3588,
	NVME_REG_PMRSTS = 3592,
	NVME_REG_PMREBS = 3596,
	NVME_REG_PMRSWTP = 3600,
	NVME_REG_DBS = 4096,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_CSS_CSI = 96,
	NVME_CC_CSS_MASK = 112,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES = 4194304,
	NVME_CC_CRIME = 16777216,
};

enum {
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	int hook_offset;
};

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
} __attribute__((packed));

struct histb_pcie {
	struct dw_pcie *pci;
	struct clk *aux_clk;
	struct clk *pipe_clk;
	struct clk *sys_clk;
	struct clk *bus_clk;
	struct phy *phy;
	struct reset_control *soft_reset;
	struct reset_control *sys_reset;
	struct reset_control *bus_reset;
	void *ctrl;
	struct gpio_desc *reset_gpio;
	struct regulator *vpcie;
};

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

struct broken_edid {
	u8 manufacturer[4];
	u32 model;
	u32 fix;
};

enum display_flags {
	DISPLAY_FLAGS_HSYNC_LOW = 1,
	DISPLAY_FLAGS_HSYNC_HIGH = 2,
	DISPLAY_FLAGS_VSYNC_LOW = 4,
	DISPLAY_FLAGS_VSYNC_HIGH = 8,
	DISPLAY_FLAGS_DE_LOW = 16,
	DISPLAY_FLAGS_DE_HIGH = 32,
	DISPLAY_FLAGS_PIXDATA_POSEDGE = 64,
	DISPLAY_FLAGS_PIXDATA_NEGEDGE = 128,
	DISPLAY_FLAGS_INTERLACED = 256,
	DISPLAY_FLAGS_DOUBLESCAN = 512,
	DISPLAY_FLAGS_DOUBLECLK = 1024,
	DISPLAY_FLAGS_SYNC_POSEDGE = 2048,
	DISPLAY_FLAGS_SYNC_NEGEDGE = 4096,
};

struct __fb_timings {
	u32 dclk;
	u32 hfreq;
	u32 vfreq;
	u32 hactive;
	u32 vactive;
	u32 hblank;
	u32 vblank;
	u32 htotal;
	u32 vtotal;
};

struct videomode {
	unsigned long pixelclock;
	u32 hactive;
	u32 hfront_porch;
	u32 hback_porch;
	u32 hsync_len;
	u32 vactive;
	u32 vfront_porch;
	u32 vback_porch;
	u32 vsync_len;
	enum display_flags flags;
};

struct acpi_table_madt {
	struct acpi_table_header header;
	u32 address;
	u32 flags;
};

struct acpi_madt_local_apic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u32 lapic_flags;
};

struct acpi_madt_local_x2apic {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 local_apic_id;
	u32 lapic_flags;
	u32 uid;
};

struct acpi_madt_local_sapic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u8 eid;
	u8 reserved[3];
	u32 lapic_flags;
	u32 uid;
	char uid_string[0];
};

struct acpi_madt_rintc {
	struct acpi_subtable_header header;
	u8 version;
	u8 reserved;
	u32 flags;
	u64 hart_id;
	u32 uid;
	u32 ext_intc_id;
	u64 imsic_addr;
	u32 imsic_size;
} __attribute__((packed));

struct acpi_madt_core_pic {
	struct acpi_subtable_header header;
	u8 version;
	u32 processor_id;
	u32 core_id;
	u32 flags;
} __attribute__((packed));

struct apd_private_data;

struct apd_device_desc {
	unsigned int fixed_clk_rate;
	struct property_entry *properties;
	int (*setup)(struct apd_private_data *);
};

struct apd_private_data {
	struct clk *clk;
	struct acpi_device *adev;
	const struct apd_device_desc *dev_desc;
};

struct acpi_init_walk_info {
	u32 table_index;
	u32 object_count;
	u32 method_count;
	u32 serial_method_count;
	u32 non_serial_method_count;
	u32 serialized_method_count;
	u32 device_count;
	u32 op_region_count;
	u32 field_count;
	u32 buffer_count;
	u32 package_count;
	u32 op_region_init;
	u32 field_init;
	u32 buffer_init;
	u32 package_init;
	acpi_owner_id owner_id;
};

typedef acpi_status (*acpi_execute_op)(struct acpi_walk_state *);

struct acpi_pci_id {
	u16 segment;
	u16 bus;
	u16 device;
	u16 function;
};

struct acpi_data_table_mapping {
	void *pointer;
};

struct acpi_mem_mapping;

struct acpi_mem_space_context {
	u32 length;
	acpi_physical_address address;
	struct acpi_mem_mapping *cur_mm;
	struct acpi_mem_mapping *first_mm;
};

struct acpi_mem_mapping {
	acpi_physical_address physical_address;
	u8 *logical_address;
	acpi_size length;
	struct acpi_mem_mapping *next_mm;
};

struct acpi_table_gtdt;

struct acpi_gtdt_descriptor {
	struct acpi_table_gtdt *gtdt;
	void *gtdt_end;
	void *platform_timer;
};

struct acpi_table_gtdt {
	struct acpi_table_header header;
	u64 counter_block_addresss;
	u32 reserved;
	u32 secure_el1_interrupt;
	u32 secure_el1_flags;
	u32 non_secure_el1_interrupt;
	u32 non_secure_el1_flags;
	u32 virtual_timer_interrupt;
	u32 virtual_timer_flags;
	u32 non_secure_el2_interrupt;
	u32 non_secure_el2_flags;
	u64 counter_read_block_address;
	u32 platform_timer_count;
	u32 platform_timer_offset;
} __attribute__((packed));

enum arch_timer_ppi_nr {
	ARCH_TIMER_PHYS_SECURE_PPI = 0,
	ARCH_TIMER_PHYS_NONSECURE_PPI = 1,
	ARCH_TIMER_VIRT_PPI = 2,
	ARCH_TIMER_HYP_PPI = 3,
	ARCH_TIMER_HYP_VIRT_PPI = 4,
	ARCH_TIMER_MAX_TIMER_PPI = 5,
};

enum acpi_gtdt_type {
	ACPI_GTDT_TYPE_TIMER_BLOCK = 0,
	ACPI_GTDT_TYPE_WATCHDOG = 1,
	ACPI_GTDT_TYPE_RESERVED = 2,
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
	IORES_DESC_CXL = 9,
};

struct acpi_gtdt_header {
	u8 type;
	u16 length;
} __attribute__((packed));

struct acpi_gtdt_watchdog {
	struct acpi_gtdt_header header;
	u8 reserved;
	u64 refresh_frame_address;
	u64 control_frame_address;
	u32 timer_interrupt;
	u32 timer_flags;
} __attribute__((packed));

struct arch_timer_mem_frame {
	bool valid;
	phys_addr_t cntbase;
	size_t size;
	int phys_irq;
	int virt_irq;
};

struct arch_timer_mem {
	phys_addr_t cntctlbase;
	size_t size;
	struct arch_timer_mem_frame frame[8];
};

struct acpi_gtdt_timer_block {
	struct acpi_gtdt_header header;
	u8 reserved;
	u64 block_address;
	u32 timer_count;
	u32 timer_offset;
} __attribute__((packed));

struct acpi_gtdt_timer_entry {
	u8 frame_number;
	u8 reserved[3];
	u64 base_address;
	u64 el0_base_address;
	u32 timer_interrupt;
	u32 timer_flags;
	u32 virtual_timer_interrupt;
	u32 virtual_timer_flags;
	u32 common_flags;
} __attribute__((packed));

struct clk_fixed_rate {
	struct clk_hw hw;
	unsigned long fixed_rate;
	unsigned long fixed_accuracy;
	unsigned long flags;
};

enum xgene_pll_type {
	PLL_TYPE_PCP = 0,
	PLL_TYPE_SOC = 1,
};

struct xgene_clk_pll {
	struct clk_hw hw;
	void *reg;
	spinlock_t *lock;
	u32 pll_offset;
	enum xgene_pll_type type;
	int version;
};

struct xgene_clk_pmd {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u32 mask;
	u64 denom;
	u32 flags;
	spinlock_t *lock;
};

struct xgene_dev_parameters {
	void *csr_reg;
	u32 reg_clk_offset;
	u32 reg_clk_mask;
	u32 reg_csr_offset;
	u32 reg_csr_mask;
	void *divider_reg;
	u32 reg_divider_offset;
	u32 reg_divider_shift;
	u32 reg_divider_width;
};

struct xgene_clk {
	struct clk_hw hw;
	spinlock_t *lock;
	struct xgene_dev_parameters param;
};

struct hisi_crg_funcs {
	struct hisi_clock_data * (*register_clks)(struct platform_device *);
	void (*unregister_clks)(struct platform_device *);
};

struct hi3559av100_pll_clock {
	u32 id;
	const char *name;
	const char *parent_name;
	const u32 ctrl_reg1;
	const u8 frac_shift;
	const u8 frac_width;
	const u8 postdiv1_shift;
	const u8 postdiv1_width;
	const u8 postdiv2_shift;
	const u8 postdiv2_width;
	const u32 ctrl_reg2;
	const u8 fbdiv_shift;
	const u8 fbdiv_width;
	const u8 refdiv_shift;
	const u8 refdiv_width;
};

struct hi3559av100_clk_pll {
	struct clk_hw hw;
	u32 id;
	void *ctrl_reg1;
	u8 frac_shift;
	u8 frac_width;
	u8 postdiv1_shift;
	u8 postdiv1_width;
	u8 postdiv2_shift;
	u8 postdiv2_width;
	void *ctrl_reg2;
	u8 fbdiv_shift;
	u8 fbdiv_width;
	u8 refdiv_shift;
	u8 refdiv_width;
};

struct hisi_crg_dev {
	struct hisi_clock_data *clk_data;
	struct hisi_reset_controller *rstc;
	const struct hisi_crg_funcs *funcs;
};

struct clk_composite {
	struct clk_hw hw;
	struct clk_ops ops;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	const struct clk_ops *mux_ops;
	const struct clk_ops *rate_ops;
	const struct clk_ops *gate_ops;
};

struct clk_gate {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

struct clk_periph_data {
	const char *name;
	const char * const *parent_names;
	int num_parents;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	struct clk_hw *muxrate_hw;
	bool is_double_div;
};

struct clk_double_div {
	struct clk_hw hw;
	void *reg1;
	u8 shift1;
	void *reg2;
	u8 shift2;
};

struct clk_pm_cpu {
	struct clk_hw hw;
	void *reg_mux;
	u8 shift_mux;
	u32 mask_mux;
	void *reg_div;
	u8 shift_div;
	struct regmap *nb_pm_base;
	unsigned long l1_expiration;
};

struct clk_periph_driver_data {
	struct clk_hw_onecell_data *hw_data;
	spinlock_t lock;
	void *reg;
	u32 tbg_sel;
	u32 div_sel0;
	u32 div_sel1;
	u32 div_sel2;
	u32 clk_sel;
	u32 clk_dis;
};

struct clk_smd_rpm;

struct rpm_smd_clk_desc {
	struct clk_smd_rpm **clks;
	size_t num_clks;
	const struct clk_smd_rpm ** const icc_clks;
	size_t num_icc_clks;
	bool scaling_before_handover;
};

struct clk_smd_rpm {
	const int rpm_res_type;
	const int rpm_key;
	const int rpm_clk_id;
	const bool active_only;
	bool enabled;
	bool branch;
	struct clk_smd_rpm *peer;
	struct clk_hw hw;
	unsigned long rate;
};

struct clk_smd_rpm_req {
	__le32 key;
	__le32 nbytes;
	__le32 value;
};

struct rcar_gen4_cpg_pll_config {
	u8 extal_div;
	u8 pll1_mult;
	u8 pll1_div;
	u8 pll2_mult;
	u8 pll2_div;
	u8 pll3_mult;
	u8 pll3_div;
	u8 pll4_mult;
	u8 pll4_div;
	u8 pll5_mult;
	u8 pll5_div;
	u8 pll6_mult;
	u8 pll6_div;
	u8 osc_prediv;
};

enum clk_ids {
	LAST_DT_CORE_CLK = 42,
	CLK_EXTAL = 43,
	CLK_EXTALR = 44,
	CLK_MAIN = 45,
	CLK_PLL1 = 46,
	CLK_PLL20 = 47,
	CLK_PLL21 = 48,
	CLK_PLL30 = 49,
	CLK_PLL31 = 50,
	CLK_PLL5 = 51,
	CLK_PLL1_DIV2 = 52,
	CLK_PLL20_DIV2 = 53,
	CLK_PLL21_DIV2 = 54,
	CLK_PLL30_DIV2 = 55,
	CLK_PLL31_DIV2 = 56,
	CLK_PLL5_DIV2 = 57,
	CLK_PLL5_DIV4 = 58,
	CLK_S1 = 59,
	CLK_S3 = 60,
	CLK_SDSRC = 61,
	CLK_RPCSRC = 62,
	CLK_OCO = 63,
	MOD_CLK_BASE = 64,
};

struct _ccu_nm {
	unsigned long n;
	unsigned long min_n;
	unsigned long max_n;
	unsigned long m;
	unsigned long min_m;
	unsigned long max_m;
};

struct tegra_cpu_car_ops {
	void (*wait_for_reset)(u32);
	void (*put_in_reset)(u32);
	void (*out_of_reset)(u32);
	void (*enable_clock)(u32);
	void (*disable_clock)(u32);
	bool (*rail_off_ready)();
	void (*suspend)();
	void (*resume)();
};

typedef void (*tegra_clk_apply_init_table_func)();

struct tegra_clk_periph_regs {
	u32 enb_reg;
	u32 enb_set_reg;
	u32 enb_clr_reg;
	u32 rst_reg;
	u32 rst_set_reg;
	u32 rst_clr_reg;
};

struct tegra_clk_duplicate {
	int clk_id;
	struct clk_lookup lookup;
};

struct tegra_clk_init_table {
	unsigned int clk_id;
	unsigned int parent_id;
	unsigned long rate;
	int state;
};

struct tegra_devclk {
	int dt_id;
	char *dev_id;
	char *con_id;
};

struct tegra_clk {
	int dt_id;
	bool present;
};

enum uniphier_clk_type {
	UNIPHIER_CLK_TYPE_CPUGEAR = 0,
	UNIPHIER_CLK_TYPE_FIXED_FACTOR = 1,
	UNIPHIER_CLK_TYPE_FIXED_RATE = 2,
	UNIPHIER_CLK_TYPE_GATE = 3,
	UNIPHIER_CLK_TYPE_MUX = 4,
};

struct uniphier_clk_fixed_factor_data {
	const char *parent_name;
	unsigned int mult;
	unsigned int div;
};

struct uniphier_clk_fixed_rate_data {
	unsigned long fixed_rate;
};

struct uniphier_clk_gate_data {
	const char *parent_name;
	unsigned int reg;
	unsigned int bit;
};

struct uniphier_clk_mux_data {
	const char *parent_names[8];
	unsigned int num_parents;
	unsigned int reg;
	unsigned int masks[8];
	unsigned int vals[8];
};

struct uniphier_clk_data {
	const char *name;
	enum uniphier_clk_type type;
	int idx;
	union {
		struct uniphier_clk_cpugear_data cpugear;
		struct uniphier_clk_fixed_factor_data factor;
		struct uniphier_clk_fixed_rate_data rate;
		struct uniphier_clk_gate_data gate;
		struct uniphier_clk_mux_data mux;
	} data;
};

struct visconti_reset {
	struct reset_controller_dev rcdev;
	struct regmap *regmap;
	const struct visconti_reset_data *resets;
	spinlock_t *lock;
};

enum rz_dmac_prep_type {
	RZ_DMAC_DESC_MEMCPY = 0,
	RZ_DMAC_DESC_SLAVE_SG = 1,
};

struct rz_dmac_chan;

struct rz_dmac {
	struct dma_device engine;
	struct device *dev;
	struct reset_control *rstc;
	void *base;
	void *ext_base;
	unsigned int n_channels;
	struct rz_dmac_chan *channels;
	unsigned long modules[16];
};

struct rz_dmac_desc;

struct rz_lmdesc;

struct rz_dmac_chan {
	struct virt_dma_chan vc;
	void *ch_base;
	void *ch_cmn_base;
	unsigned int index;
	int irq;
	struct rz_dmac_desc *desc;
	int descs_allocated;
	dma_addr_t src_per_address;
	dma_addr_t dst_per_address;
	u32 chcfg;
	u32 chctrl;
	int mid_rid;
	struct list_head ld_free;
	struct list_head ld_queue;
	struct list_head ld_active;
	struct {
		struct rz_lmdesc *base;
		struct rz_lmdesc *head;
		struct rz_lmdesc *tail;
		dma_addr_t base_dma;
	} lmdesc;
};

struct rz_dmac_desc {
	struct virt_dma_desc vd;
	dma_addr_t src;
	dma_addr_t dest;
	size_t len;
	struct list_head node;
	enum dma_transfer_direction direction;
	enum rz_dmac_prep_type type;
	struct scatterlist *sg;
	unsigned int sgcount;
};

struct rz_lmdesc {
	u32 header;
	u32 sa;
	u32 da;
	u32 tb;
	u32 chcfg;
	u32 chitvl;
	u32 chext;
	u32 nxla;
};

struct bm_addr {
	void *ce;
	__be32 *ce_be;
	void *ci;
};

struct bm_rcr_entry;

struct bm_rcr {
	struct bm_rcr_entry *ring;
	struct bm_rcr_entry *cursor;
	u8 ci;
	u8 available;
	u8 ithresh;
	u8 vbit;
};

struct bm_mc_command;

union bm_mc_result;

struct bm_mc {
	struct bm_mc_command *cr;
	union bm_mc_result *rr;
	u8 rridx;
	u8 vbit;
};

struct bm_portal {
	struct bm_addr addr;
	struct bm_rcr rcr;
	struct bm_mc mc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bm_portal_config;

struct bman_portal {
	struct bm_portal p;
	unsigned long irq_sources;
	const struct bm_portal_config *config;
	char irqname[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bm_buffer {
	union {
		struct {
			__be16 bpid;
			__be16 hi;
			__be32 lo;
		};
		__be64 data;
	};
};

struct bm_rcr_entry {
	union {
		struct {
			u8 _ncw_verb;
			u8 bpid;
			u8 __reserved1[62];
		};
		struct bm_buffer bufs[8];
	};
};

struct bm_mc_command {
	u8 _ncw_verb;
	u8 bpid;
	u8 __reserved[62];
};

union bm_mc_result {
	struct {
		u8 verb;
		u8 bpid;
		u8 __reserved[62];
	};
	struct bm_buffer bufs[8];
};

struct bm_portal_config {
	void *addr_virt_ce;
	void *addr_virt_ci;
	struct list_head list;
	struct device *dev;
	int cpu;
	int irq;
};

enum bm_rcr_pmode {
	bm_rcr_pci = 0,
	bm_rcr_pce = 1,
	bm_rcr_pvb = 2,
};

enum bm_rcr_cmode {
	bm_rcr_cci = 0,
	bm_rcr_cce = 1,
};

struct bman_pool {
	u32 bpid;
	struct bman_portal *portal;
	struct bman_pool *next;
};

struct exynos_asv_table {
	unsigned int num_rows;
	unsigned int num_cols;
	u32 *buf;
};

struct exynos_asv;

struct exynos_asv_subsys {
	struct exynos_asv *asv;
	const char *cpu_dt_compat;
	int id;
	struct exynos_asv_table table;
	unsigned int base_volt;
	unsigned int offset_volt_h;
	unsigned int offset_volt_l;
};

struct exynos_asv {
	struct device *dev;
	struct regmap *chipid_regmap;
	struct exynos_asv_subsys subsys[2];
	int (*opp_get_voltage)(const struct exynos_asv_subsys *, int, unsigned int);
	unsigned int group;
	unsigned int table;
	bool use_sg;
	int of_bin;
};

struct rcar_sysc_area;

struct rcar_sysc_info {
	int (*init)();
	const struct rcar_sysc_area *areas;
	unsigned int num_areas;
	u32 extmask_offs;
	u32 extmask_val;
};

struct rcar_sysc_area {
	const char *name;
	u16 chan_offs;
	u8 chan_bit;
	u8 isr_bit;
	s8 parent;
	u8 flags;
};

struct rcar_gen4_sysc_area;

struct rcar_gen4_sysc_info {
	const struct rcar_gen4_sysc_area *areas;
	unsigned int num_areas;
};

struct rcar_gen4_sysc_area {
	const char *name;
	u8 pdr;
	s8 parent;
	u8 flags;
};

struct rcar_sysc_ch {
	u16 chan_offs;
	u8 chan_bit;
	u8 isr_bit;
};

struct rcar_sysc_pd {
	struct generic_pm_domain genpd;
	struct rcar_sysc_ch ch;
	unsigned int flags;
	char name[0];
};

struct rcar_pm_domains {
	struct genpd_onecell_data onecell_data;
	struct generic_pm_domain *domains[33];
};

struct evtchn_loop_ctrl {
	ktime_t timeout;
	unsigned int count;
	bool defer_eoi;
};

enum ipi_vector {
	XEN_PLACEHOLDER_VECTOR = 0,
	XEN_NR_IPIS = 1,
};

struct irq_info {
	struct list_head list;
	struct list_head eoi_list;
	struct rcu_work rwork;
	short refcnt;
	u8 spurious_cnt;
	u8 is_accounted;
	short type;
	u8 mask_reason;
	u8 is_active;
	unsigned int irq;
	evtchn_port_t evtchn;
	unsigned short cpu;
	unsigned short eoi_cpu;
	unsigned int irq_epoch;
	u64 eoi_time;
	raw_spinlock_t lock;
	bool is_static;
	union {
		unsigned short virq;
		enum ipi_vector ipi;
		struct {
			unsigned short pirq;
			unsigned short gsi;
			unsigned char vector;
			unsigned char flags;
			uint16_t domid;
		} pirq;
		struct xenbus_device *interdomain;
	} u;
};

struct lateeoi_work {
	struct delayed_work delayed;
	spinlock_t eoi_list_lock;
	struct list_head eoi_list;
};

enum xen_irq_type {
	IRQT_UNBOUND = 0,
	IRQT_PIRQ = 1,
	IRQT_VIRQ = 2,
	IRQT_IPI = 3,
	IRQT_EVTCHN = 4,
};

struct evtchn_send {
	evtchn_port_t port;
};

struct physdev_irq_status_query {
	uint32_t irq;
	uint32_t flags;
};

struct evtchn_close {
	evtchn_port_t port;
};

struct evtchn_bind_interdomain {
	domid_t remote_dom;
	evtchn_port_t remote_port;
	evtchn_port_t local_port;
};

struct evtchn_status {
	domid_t dom;
	evtchn_port_t port;
	uint32_t status;
	uint32_t vcpu;
	union {
		struct {
			domid_t dom;
		} unbound;
		struct {
			domid_t dom;
			evtchn_port_t port;
		} interdomain;
		uint32_t pirq;
		uint32_t virq;
	} u;
};

struct evtchn_bind_ipi {
	uint32_t vcpu;
	evtchn_port_t port;
};

typedef struct {
	union {
		evtchn_port_t *p;
		uint64_t q;
	};
} __guest_handle_evtchn_port_t;

struct sched_poll {
	__guest_handle_evtchn_port_t ports;
	unsigned int nr_ports;
	uint64_t timeout;
};

struct evtchn_bind_virq {
	uint32_t virq;
	uint32_t vcpu;
	evtchn_port_t port;
};

struct physdev_map_pirq {
	domid_t domid;
	int type;
	int index;
	int pirq;
	int bus;
	int devfn;
	int entry_nr;
	uint64_t table_base;
};

struct physdev_eoi {
	uint32_t irq;
};

struct evtchn_bind_vcpu {
	evtchn_port_t port;
	uint32_t vcpu;
};

struct physdev_irq {
	uint32_t irq;
	uint32_t vector;
};

struct physdev_get_free_pirq {
	int type;
	uint32_t pirq;
};

struct physdev_unmap_pirq {
	domid_t domid;
	int pirq;
};

struct evtchn_set_priority {
	evtchn_port_t port;
	uint32_t priority;
};

struct evtchn_bind_pirq {
	uint32_t pirq;
	uint32_t flags;
	evtchn_port_t port;
};

struct npcm_reset_info {
	u32 bmc_id;
	u32 num_ipsrst;
	const u32 *ipsrst;
};

enum {
	BMC_NPCM7XX = 0,
	BMC_NPCM8XX = 1,
};

struct npcm_rc_data {
	struct reset_controller_dev rcdev;
	struct notifier_block restart_nb;
	const struct npcm_reset_info *info;
	struct regmap *gcr_regmap;
	u32 sw_reset_number;
	void *base;
	spinlock_t lock;
};

struct hv_ops;

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	char *outbuf;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	unsigned long flags;
};

struct hv_ops {
	int (*get_chars)(uint32_t, char *, int);
	int (*put_chars)(uint32_t, const char *, int);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, bool);
};

struct bcm2835_aux_serial_driver_data {
	resource_size_t offset;
};

struct bcm2835aux_data {
	struct clk *clk;
	int line;
	u32 cntl;
};

struct uart_regs_layout {
	unsigned int rbr;
	unsigned int tsh;
	unsigned int ctrl;
	unsigned int intr;
};

struct uart_flags {
	unsigned int ctrl_tx_rdy_int;
	unsigned int ctrl_rx_rdy_int;
	unsigned int stat_tx_rdy;
	unsigned int stat_rx_rdy;
};

struct mvebu_uart_driver_data {
	bool is_ext;
	struct uart_regs_layout regs;
	struct uart_flags flags;
};

enum {
	UART_IRQ_SUM = 0,
	UART_RX_IRQ = 0,
	UART_TX_IRQ = 1,
	UART_IRQ_COUNT = 2,
};

struct mvebu_uart_pm_regs {
	unsigned int rbr;
	unsigned int tsh;
	unsigned int ctrl;
	unsigned int intr;
	unsigned int stat;
	unsigned int brdv;
	unsigned int osamp;
};

struct mvebu_uart {
	struct uart_port *port;
	struct clk *clk;
	int irq[2];
	struct mvebu_uart_driver_data *data;
	struct mvebu_uart_pm_regs pm_regs;
};

struct mvebu_uart_clock {
	struct clk_hw clk_hw;
	int clock_idx;
	u32 pm_context_reg1;
	u32 pm_context_reg2;
};

struct mvebu_uart_clock_base {
	struct mvebu_uart_clock clocks[2];
	unsigned int parent_rates[5];
	int parent_idx;
	unsigned int div;
	void *reg1;
	void *reg2;
	bool configured;
};

typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);

typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);

typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);

typedef void (*btf_trace_map)(void *, unsigned long, phys_addr_t, size_t);

typedef void (*btf_trace_unmap)(void *, unsigned long, size_t, size_t);

typedef void (*btf_trace_io_page_fault)(void *, struct device *, unsigned long, int);

struct trace_event_raw_iommu_group_event {
	struct trace_entry ent;
	int gid;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_iommu_device_event {
	struct trace_entry ent;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_map {
	struct trace_entry ent;
	u64 iova;
	u64 paddr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_unmap {
	struct trace_entry ent;
	u64 iova;
	size_t size;
	size_t unmapped_size;
	char __data[0];
};

struct trace_event_raw_iommu_error {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u64 iova;
	int flags;
	char __data[0];
};

struct trace_event_data_offsets_iommu_group_event {
	u32 device;
};

struct trace_event_data_offsets_iommu_device_event {
	u32 device;
};

struct trace_event_data_offsets_iommu_error {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_map {};

struct trace_event_data_offsets_unmap {};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

struct bcm2835_pm {
	struct device *dev;
	void *base;
	void *asb;
	void *rpivid_asb;
};

enum s2mpa01_reg {
	S2MPA01_REG_ID = 0,
	S2MPA01_REG_INT1 = 1,
	S2MPA01_REG_INT2 = 2,
	S2MPA01_REG_INT3 = 3,
	S2MPA01_REG_INT1M = 4,
	S2MPA01_REG_INT2M = 5,
	S2MPA01_REG_INT3M = 6,
	S2MPA01_REG_ST1 = 7,
	S2MPA01_REG_ST2 = 8,
	S2MPA01_REG_PWRONSRC = 9,
	S2MPA01_REG_OFFSRC = 10,
	S2MPA01_REG_RTC_BUF = 11,
	S2MPA01_REG_CTRL1 = 12,
	S2MPA01_REG_ETC_TEST = 13,
	S2MPA01_REG_RSVD1 = 14,
	S2MPA01_REG_BU_CHG = 15,
	S2MPA01_REG_RAMP1 = 16,
	S2MPA01_REG_RAMP2 = 17,
	S2MPA01_REG_LDO_DSCH1 = 18,
	S2MPA01_REG_LDO_DSCH2 = 19,
	S2MPA01_REG_LDO_DSCH3 = 20,
	S2MPA01_REG_LDO_DSCH4 = 21,
	S2MPA01_REG_OTP_ADRL = 22,
	S2MPA01_REG_OTP_ADRH = 23,
	S2MPA01_REG_OTP_DATA = 24,
	S2MPA01_REG_MON1SEL = 25,
	S2MPA01_REG_MON2SEL = 26,
	S2MPA01_REG_LEE = 27,
	S2MPA01_REG_RSVD2 = 28,
	S2MPA01_REG_RSVD3 = 29,
	S2MPA01_REG_RSVD4 = 30,
	S2MPA01_REG_RSVD5 = 31,
	S2MPA01_REG_RSVD6 = 32,
	S2MPA01_REG_TOP_RSVD = 33,
	S2MPA01_REG_DVS_SEL = 34,
	S2MPA01_REG_DVS_PTR = 35,
	S2MPA01_REG_DVS_DATA = 36,
	S2MPA01_REG_RSVD_NO = 37,
	S2MPA01_REG_UVLO = 38,
	S2MPA01_REG_LEE_NO = 39,
	S2MPA01_REG_B1CTRL1 = 40,
	S2MPA01_REG_B1CTRL2 = 41,
	S2MPA01_REG_B2CTRL1 = 42,
	S2MPA01_REG_B2CTRL2 = 43,
	S2MPA01_REG_B3CTRL1 = 44,
	S2MPA01_REG_B3CTRL2 = 45,
	S2MPA01_REG_B4CTRL1 = 46,
	S2MPA01_REG_B4CTRL2 = 47,
	S2MPA01_REG_B5CTRL1 = 48,
	S2MPA01_REG_B5CTRL2 = 49,
	S2MPA01_REG_B5CTRL3 = 50,
	S2MPA01_REG_B5CTRL4 = 51,
	S2MPA01_REG_B5CTRL5 = 52,
	S2MPA01_REG_B5CTRL6 = 53,
	S2MPA01_REG_B6CTRL1 = 54,
	S2MPA01_REG_B6CTRL2 = 55,
	S2MPA01_REG_B7CTRL1 = 56,
	S2MPA01_REG_B7CTRL2 = 57,
	S2MPA01_REG_B8CTRL1 = 58,
	S2MPA01_REG_B8CTRL2 = 59,
	S2MPA01_REG_B9CTRL1 = 60,
	S2MPA01_REG_B9CTRL2 = 61,
	S2MPA01_REG_B10CTRL1 = 62,
	S2MPA01_REG_B10CTRL2 = 63,
	S2MPA01_REG_L1CTRL = 64,
	S2MPA01_REG_L2CTRL = 65,
	S2MPA01_REG_L3CTRL = 66,
	S2MPA01_REG_L4CTRL = 67,
	S2MPA01_REG_L5CTRL = 68,
	S2MPA01_REG_L6CTRL = 69,
	S2MPA01_REG_L7CTRL = 70,
	S2MPA01_REG_L8CTRL = 71,
	S2MPA01_REG_L9CTRL = 72,
	S2MPA01_REG_L10CTRL = 73,
	S2MPA01_REG_L11CTRL = 74,
	S2MPA01_REG_L12CTRL = 75,
	S2MPA01_REG_L13CTRL = 76,
	S2MPA01_REG_L14CTRL = 77,
	S2MPA01_REG_L15CTRL = 78,
	S2MPA01_REG_L16CTRL = 79,
	S2MPA01_REG_L17CTRL = 80,
	S2MPA01_REG_L18CTRL = 81,
	S2MPA01_REG_L19CTRL = 82,
	S2MPA01_REG_L20CTRL = 83,
	S2MPA01_REG_L21CTRL = 84,
	S2MPA01_REG_L22CTRL = 85,
	S2MPA01_REG_L23CTRL = 86,
	S2MPA01_REG_L24CTRL = 87,
	S2MPA01_REG_L25CTRL = 88,
	S2MPA01_REG_L26CTRL = 89,
	S2MPA01_REG_LDO_OVCB1 = 90,
	S2MPA01_REG_LDO_OVCB2 = 91,
	S2MPA01_REG_LDO_OVCB3 = 92,
	S2MPA01_REG_LDO_OVCB4 = 93,
};

enum s2mps11_reg {
	S2MPS11_REG_ID = 0,
	S2MPS11_REG_INT1 = 1,
	S2MPS11_REG_INT2 = 2,
	S2MPS11_REG_INT3 = 3,
	S2MPS11_REG_INT1M = 4,
	S2MPS11_REG_INT2M = 5,
	S2MPS11_REG_INT3M = 6,
	S2MPS11_REG_ST1 = 7,
	S2MPS11_REG_ST2 = 8,
	S2MPS11_REG_OFFSRC = 9,
	S2MPS11_REG_PWRONSRC = 10,
	S2MPS11_REG_RTC_CTRL = 11,
	S2MPS11_REG_CTRL1 = 12,
	S2MPS11_REG_ETC_TEST = 13,
	S2MPS11_REG_RSVD3 = 14,
	S2MPS11_REG_BU_CHG = 15,
	S2MPS11_REG_RAMP = 16,
	S2MPS11_REG_RAMP_BUCK = 17,
	S2MPS11_REG_LDO1_8 = 18,
	S2MPS11_REG_LDO9_16 = 19,
	S2MPS11_REG_LDO17_24 = 20,
	S2MPS11_REG_LDO25_32 = 21,
	S2MPS11_REG_LDO33_38 = 22,
	S2MPS11_REG_LDO1_8_1 = 23,
	S2MPS11_REG_LDO9_16_1 = 24,
	S2MPS11_REG_LDO17_24_1 = 25,
	S2MPS11_REG_LDO25_32_1 = 26,
	S2MPS11_REG_LDO33_38_1 = 27,
	S2MPS11_REG_OTP_ADRL = 28,
	S2MPS11_REG_OTP_ADRH = 29,
	S2MPS11_REG_OTP_DATA = 30,
	S2MPS11_REG_MON1SEL = 31,
	S2MPS11_REG_MON2SEL = 32,
	S2MPS11_REG_LEE = 33,
	S2MPS11_REG_RSVD_NO = 34,
	S2MPS11_REG_UVLO = 35,
	S2MPS11_REG_LEE_NO = 36,
	S2MPS11_REG_B1CTRL1 = 37,
	S2MPS11_REG_B1CTRL2 = 38,
	S2MPS11_REG_B2CTRL1 = 39,
	S2MPS11_REG_B2CTRL2 = 40,
	S2MPS11_REG_B3CTRL1 = 41,
	S2MPS11_REG_B3CTRL2 = 42,
	S2MPS11_REG_B4CTRL1 = 43,
	S2MPS11_REG_B4CTRL2 = 44,
	S2MPS11_REG_B5CTRL1 = 45,
	S2MPS11_REG_BUCK5_SW = 46,
	S2MPS11_REG_B5CTRL2 = 47,
	S2MPS11_REG_B5CTRL3 = 48,
	S2MPS11_REG_B5CTRL4 = 49,
	S2MPS11_REG_B5CTRL5 = 50,
	S2MPS11_REG_B6CTRL1 = 51,
	S2MPS11_REG_B6CTRL2 = 52,
	S2MPS11_REG_B7CTRL1 = 53,
	S2MPS11_REG_B7CTRL2 = 54,
	S2MPS11_REG_B8CTRL1 = 55,
	S2MPS11_REG_B8CTRL2 = 56,
	S2MPS11_REG_B9CTRL1 = 57,
	S2MPS11_REG_B9CTRL2 = 58,
	S2MPS11_REG_B10CTRL1 = 59,
	S2MPS11_REG_B10CTRL2 = 60,
	S2MPS11_REG_L1CTRL = 61,
	S2MPS11_REG_L2CTRL = 62,
	S2MPS11_REG_L3CTRL = 63,
	S2MPS11_REG_L4CTRL = 64,
	S2MPS11_REG_L5CTRL = 65,
	S2MPS11_REG_L6CTRL = 66,
	S2MPS11_REG_L7CTRL = 67,
	S2MPS11_REG_L8CTRL = 68,
	S2MPS11_REG_L9CTRL = 69,
	S2MPS11_REG_L10CTRL = 70,
	S2MPS11_REG_L11CTRL = 71,
	S2MPS11_REG_L12CTRL = 72,
	S2MPS11_REG_L13CTRL = 73,
	S2MPS11_REG_L14CTRL = 74,
	S2MPS11_REG_L15CTRL = 75,
	S2MPS11_REG_L16CTRL = 76,
	S2MPS11_REG_L17CTRL = 77,
	S2MPS11_REG_L18CTRL = 78,
	S2MPS11_REG_L19CTRL = 79,
	S2MPS11_REG_L20CTRL = 80,
	S2MPS11_REG_L21CTRL = 81,
	S2MPS11_REG_L22CTRL = 82,
	S2MPS11_REG_L23CTRL = 83,
	S2MPS11_REG_L24CTRL = 84,
	S2MPS11_REG_L25CTRL = 85,
	S2MPS11_REG_L26CTRL = 86,
	S2MPS11_REG_L27CTRL = 87,
	S2MPS11_REG_L28CTRL = 88,
	S2MPS11_REG_L29CTRL = 89,
	S2MPS11_REG_L30CTRL = 90,
	S2MPS11_REG_L31CTRL = 91,
	S2MPS11_REG_L32CTRL = 92,
	S2MPS11_REG_L33CTRL = 93,
	S2MPS11_REG_L34CTRL = 94,
	S2MPS11_REG_L35CTRL = 95,
	S2MPS11_REG_L36CTRL = 96,
	S2MPS11_REG_L37CTRL = 97,
	S2MPS11_REG_L38CTRL = 98,
};

enum S2MPU02_reg {
	S2MPU02_REG_ID = 0,
	S2MPU02_REG_INT1 = 1,
	S2MPU02_REG_INT2 = 2,
	S2MPU02_REG_INT3 = 3,
	S2MPU02_REG_INT1M = 4,
	S2MPU02_REG_INT2M = 5,
	S2MPU02_REG_INT3M = 6,
	S2MPU02_REG_ST1 = 7,
	S2MPU02_REG_ST2 = 8,
	S2MPU02_REG_PWRONSRC = 9,
	S2MPU02_REG_OFFSRC = 10,
	S2MPU02_REG_BU_CHG = 11,
	S2MPU02_REG_RTCCTRL = 12,
	S2MPU02_REG_PMCTRL1 = 13,
	S2MPU02_REG_RSVD1 = 14,
	S2MPU02_REG_RSVD2 = 15,
	S2MPU02_REG_RSVD3 = 16,
	S2MPU02_REG_RSVD4 = 17,
	S2MPU02_REG_RSVD5 = 18,
	S2MPU02_REG_RSVD6 = 19,
	S2MPU02_REG_RSVD7 = 20,
	S2MPU02_REG_WRSTEN = 21,
	S2MPU02_REG_RSVD8 = 22,
	S2MPU02_REG_RSVD9 = 23,
	S2MPU02_REG_RSVD10 = 24,
	S2MPU02_REG_B1CTRL1 = 25,
	S2MPU02_REG_B1CTRL2 = 26,
	S2MPU02_REG_B2CTRL1 = 27,
	S2MPU02_REG_B2CTRL2 = 28,
	S2MPU02_REG_B3CTRL1 = 29,
	S2MPU02_REG_B3CTRL2 = 30,
	S2MPU02_REG_B4CTRL1 = 31,
	S2MPU02_REG_B4CTRL2 = 32,
	S2MPU02_REG_B5CTRL1 = 33,
	S2MPU02_REG_B5CTRL2 = 34,
	S2MPU02_REG_B5CTRL3 = 35,
	S2MPU02_REG_B5CTRL4 = 36,
	S2MPU02_REG_B5CTRL5 = 37,
	S2MPU02_REG_B6CTRL1 = 38,
	S2MPU02_REG_B6CTRL2 = 39,
	S2MPU02_REG_B7CTRL1 = 40,
	S2MPU02_REG_B7CTRL2 = 41,
	S2MPU02_REG_RAMP1 = 42,
	S2MPU02_REG_RAMP2 = 43,
	S2MPU02_REG_L1CTRL = 44,
	S2MPU02_REG_L2CTRL1 = 45,
	S2MPU02_REG_L2CTRL2 = 46,
	S2MPU02_REG_L2CTRL3 = 47,
	S2MPU02_REG_L2CTRL4 = 48,
	S2MPU02_REG_L3CTRL = 49,
	S2MPU02_REG_L4CTRL = 50,
	S2MPU02_REG_L5CTRL = 51,
	S2MPU02_REG_L6CTRL = 52,
	S2MPU02_REG_L7CTRL = 53,
	S2MPU02_REG_L8CTRL = 54,
	S2MPU02_REG_L9CTRL = 55,
	S2MPU02_REG_L10CTRL = 56,
	S2MPU02_REG_L11CTRL = 57,
	S2MPU02_REG_L12CTRL = 58,
	S2MPU02_REG_L13CTRL = 59,
	S2MPU02_REG_L14CTRL = 60,
	S2MPU02_REG_L15CTRL = 61,
	S2MPU02_REG_L16CTRL = 62,
	S2MPU02_REG_L17CTRL = 63,
	S2MPU02_REG_L18CTRL = 64,
	S2MPU02_REG_L19CTRL = 65,
	S2MPU02_REG_L20CTRL = 66,
	S2MPU02_REG_L21CTRL = 67,
	S2MPU02_REG_L22CTRL = 68,
	S2MPU02_REG_L23CTRL = 69,
	S2MPU02_REG_L24CTRL = 70,
	S2MPU02_REG_L25CTRL = 71,
	S2MPU02_REG_L26CTRL = 72,
	S2MPU02_REG_L27CTRL = 73,
	S2MPU02_REG_L28CTRL = 74,
	S2MPU02_REG_LDODSCH1 = 75,
	S2MPU02_REG_LDODSCH2 = 76,
	S2MPU02_REG_LDODSCH3 = 77,
	S2MPU02_REG_LDODSCH4 = 78,
	S2MPU02_REG_SELMIF = 79,
	S2MPU02_REG_RSVD11 = 80,
	S2MPU02_REG_RSVD12 = 81,
	S2MPU02_REG_RSVD13 = 82,
	S2MPU02_REG_DVSSEL = 83,
	S2MPU02_REG_DVSPTR = 84,
	S2MPU02_REG_DVSDATA = 85,
};

enum s2mps13_reg {
	S2MPS13_REG_ID = 0,
	S2MPS13_REG_INT1 = 1,
	S2MPS13_REG_INT2 = 2,
	S2MPS13_REG_INT3 = 3,
	S2MPS13_REG_INT1M = 4,
	S2MPS13_REG_INT2M = 5,
	S2MPS13_REG_INT3M = 6,
	S2MPS13_REG_ST1 = 7,
	S2MPS13_REG_ST2 = 8,
	S2MPS13_REG_PWRONSRC = 9,
	S2MPS13_REG_OFFSRC = 10,
	S2MPS13_REG_BU_CHG = 11,
	S2MPS13_REG_RTCCTRL = 12,
	S2MPS13_REG_CTRL1 = 13,
	S2MPS13_REG_CTRL2 = 14,
	S2MPS13_REG_RSVD1 = 15,
	S2MPS13_REG_RSVD2 = 16,
	S2MPS13_REG_RSVD3 = 17,
	S2MPS13_REG_RSVD4 = 18,
	S2MPS13_REG_RSVD5 = 19,
	S2MPS13_REG_RSVD6 = 20,
	S2MPS13_REG_CTRL3 = 21,
	S2MPS13_REG_RSVD7 = 22,
	S2MPS13_REG_RSVD8 = 23,
	S2MPS13_REG_WRSTBI = 24,
	S2MPS13_REG_B1CTRL = 25,
	S2MPS13_REG_B1OUT = 26,
	S2MPS13_REG_B2CTRL = 27,
	S2MPS13_REG_B2OUT = 28,
	S2MPS13_REG_B3CTRL = 29,
	S2MPS13_REG_B3OUT = 30,
	S2MPS13_REG_B4CTRL = 31,
	S2MPS13_REG_B4OUT = 32,
	S2MPS13_REG_B5CTRL = 33,
	S2MPS13_REG_B5OUT = 34,
	S2MPS13_REG_B6CTRL = 35,
	S2MPS13_REG_B6OUT = 36,
	S2MPS13_REG_B7CTRL = 37,
	S2MPS13_REG_B7SW = 38,
	S2MPS13_REG_B7OUT = 39,
	S2MPS13_REG_B8CTRL = 40,
	S2MPS13_REG_B8OUT = 41,
	S2MPS13_REG_B9CTRL = 42,
	S2MPS13_REG_B9OUT = 43,
	S2MPS13_REG_B10CTRL = 44,
	S2MPS13_REG_B10OUT = 45,
	S2MPS13_REG_BB1CTRL = 46,
	S2MPS13_REG_BB1OUT = 47,
	S2MPS13_REG_BUCK_RAMP1 = 48,
	S2MPS13_REG_BUCK_RAMP2 = 49,
	S2MPS13_REG_LDO_DVS1 = 50,
	S2MPS13_REG_LDO_DVS2 = 51,
	S2MPS13_REG_LDO_DVS3 = 52,
	S2MPS13_REG_B6OUT2 = 53,
	S2MPS13_REG_L1CTRL = 54,
	S2MPS13_REG_L2CTRL = 55,
	S2MPS13_REG_L3CTRL = 56,
	S2MPS13_REG_L4CTRL = 57,
	S2MPS13_REG_L5CTRL = 58,
	S2MPS13_REG_L6CTRL = 59,
	S2MPS13_REG_L7CTRL = 60,
	S2MPS13_REG_L8CTRL = 61,
	S2MPS13_REG_L9CTRL = 62,
	S2MPS13_REG_L10CTRL = 63,
	S2MPS13_REG_L11CTRL = 64,
	S2MPS13_REG_L12CTRL = 65,
	S2MPS13_REG_L13CTRL = 66,
	S2MPS13_REG_L14CTRL = 67,
	S2MPS13_REG_L15CTRL = 68,
	S2MPS13_REG_L16CTRL = 69,
	S2MPS13_REG_L17CTRL = 70,
	S2MPS13_REG_L18CTRL = 71,
	S2MPS13_REG_L19CTRL = 72,
	S2MPS13_REG_L20CTRL = 73,
	S2MPS13_REG_L21CTRL = 74,
	S2MPS13_REG_L22CTRL = 75,
	S2MPS13_REG_L23CTRL = 76,
	S2MPS13_REG_L24CTRL = 77,
	S2MPS13_REG_L25CTRL = 78,
	S2MPS13_REG_L26CTRL = 79,
	S2MPS13_REG_L27CTRL = 80,
	S2MPS13_REG_L28CTRL = 81,
	S2MPS13_REG_L29CTRL = 82,
	S2MPS13_REG_L30CTRL = 83,
	S2MPS13_REG_L31CTRL = 84,
	S2MPS13_REG_L32CTRL = 85,
	S2MPS13_REG_L33CTRL = 86,
	S2MPS13_REG_L34CTRL = 87,
	S2MPS13_REG_L35CTRL = 88,
	S2MPS13_REG_L36CTRL = 89,
	S2MPS13_REG_L37CTRL = 90,
	S2MPS13_REG_L38CTRL = 91,
	S2MPS13_REG_L39CTRL = 92,
	S2MPS13_REG_L40CTRL = 93,
	S2MPS13_REG_LDODSCH1 = 94,
	S2MPS13_REG_LDODSCH2 = 95,
	S2MPS13_REG_LDODSCH3 = 96,
	S2MPS13_REG_LDODSCH4 = 97,
	S2MPS13_REG_LDODSCH5 = 98,
};

enum discover_event {
	DISCE_DISCOVER_DOMAIN = 0,
	DISCE_REVALIDATE_DOMAIN = 1,
	DISCE_SUSPEND = 2,
	DISCE_RESUME = 3,
	DISC_NUM_EVENTS = 4,
};

enum {
	AHCI_MAX_PORTS = 32,
	AHCI_MAX_SG = 168,
	AHCI_DMA_BOUNDARY = 4294967295,
	AHCI_MAX_CMDS = 32,
	AHCI_CMD_SZ = 32,
	AHCI_CMD_SLOT_SZ = 1024,
	AHCI_RX_FIS_SZ = 256,
	AHCI_CMD_TBL_CDB = 64,
	AHCI_CMD_TBL_HDR_SZ = 128,
	AHCI_CMD_TBL_SZ = 2816,
	AHCI_CMD_TBL_AR_SZ = 90112,
	AHCI_PORT_PRIV_DMA_SZ = 91392,
	AHCI_PORT_PRIV_FBS_DMA_SZ = 95232,
	AHCI_IRQ_ON_SG = 2147483648,
	AHCI_CMD_ATAPI = 32,
	AHCI_CMD_WRITE = 64,
	AHCI_CMD_PREFETCH = 128,
	AHCI_CMD_RESET = 256,
	AHCI_CMD_CLR_BUSY = 1024,
	RX_FIS_PIO_SETUP = 32,
	RX_FIS_D2H_REG = 64,
	RX_FIS_SDB = 88,
	RX_FIS_UNK = 96,
	HOST_CAP = 0,
	HOST_CTL = 4,
	HOST_IRQ_STAT = 8,
	HOST_PORTS_IMPL = 12,
	HOST_VERSION = 16,
	HOST_EM_LOC = 28,
	HOST_EM_CTL = 32,
	HOST_CAP2 = 36,
	HOST_RESET = 1,
	HOST_IRQ_EN = 2,
	HOST_MRSM = 4,
	HOST_AHCI_EN = 2147483648,
	HOST_CAP_SXS = 32,
	HOST_CAP_EMS = 64,
	HOST_CAP_CCC = 128,
	HOST_CAP_PART = 8192,
	HOST_CAP_SSC = 16384,
	HOST_CAP_PIO_MULTI = 32768,
	HOST_CAP_FBS = 65536,
	HOST_CAP_PMP = 131072,
	HOST_CAP_ONLY = 262144,
	HOST_CAP_CLO = 16777216,
	HOST_CAP_LED = 33554432,
	HOST_CAP_ALPM = 67108864,
	HOST_CAP_SSS = 134217728,
	HOST_CAP_MPS = 268435456,
	HOST_CAP_SNTF = 536870912,
	HOST_CAP_NCQ = 1073741824,
	HOST_CAP_64 = 2147483648,
	HOST_CAP2_BOH = 1,
	HOST_CAP2_NVMHCI = 2,
	HOST_CAP2_APST = 4,
	HOST_CAP2_SDS = 8,
	HOST_CAP2_SADM = 16,
	HOST_CAP2_DESO = 32,
	PORT_LST_ADDR = 0,
	PORT_LST_ADDR_HI = 4,
	PORT_FIS_ADDR = 8,
	PORT_FIS_ADDR_HI = 12,
	PORT_IRQ_STAT = 16,
	PORT_IRQ_MASK = 20,
	PORT_CMD = 24,
	PORT_TFDATA = 32,
	PORT_SIG = 36,
	PORT_CMD_ISSUE = 56,
	PORT_SCR_STAT = 40,
	PORT_SCR_CTL = 44,
	PORT_SCR_ERR = 48,
	PORT_SCR_ACT = 52,
	PORT_SCR_NTF = 60,
	PORT_FBS = 64,
	PORT_DEVSLP = 68,
	PORT_IRQ_COLD_PRES = 2147483648,
	PORT_IRQ_TF_ERR = 1073741824,
	PORT_IRQ_HBUS_ERR = 536870912,
	PORT_IRQ_HBUS_DATA_ERR = 268435456,
	PORT_IRQ_IF_ERR = 134217728,
	PORT_IRQ_IF_NONFATAL = 67108864,
	PORT_IRQ_OVERFLOW = 16777216,
	PORT_IRQ_BAD_PMP = 8388608,
	PORT_IRQ_PHYRDY = 4194304,
	PORT_IRQ_DMPS = 128,
	PORT_IRQ_CONNECT = 64,
	PORT_IRQ_SG_DONE = 32,
	PORT_IRQ_UNK_FIS = 16,
	PORT_IRQ_SDB_FIS = 8,
	PORT_IRQ_DMAS_FIS = 4,
	PORT_IRQ_PIOS_FIS = 2,
	PORT_IRQ_D2H_REG_FIS = 1,
	PORT_IRQ_FREEZE = 683671632,
	PORT_IRQ_ERROR = 2025848912,
	DEF_PORT_IRQ = 2025848959,
	PORT_CMD_ASP = 134217728,
	PORT_CMD_ALPE = 67108864,
	PORT_CMD_ATAPI = 16777216,
	PORT_CMD_FBSCP = 4194304,
	PORT_CMD_ESP = 2097152,
	PORT_CMD_CPD = 1048576,
	PORT_CMD_MPSP = 524288,
	PORT_CMD_HPCP = 262144,
	PORT_CMD_PMP = 131072,
	PORT_CMD_LIST_ON = 32768,
	PORT_CMD_FIS_ON = 16384,
	PORT_CMD_FIS_RX = 16,
	PORT_CMD_CLO = 8,
	PORT_CMD_POWER_ON = 4,
	PORT_CMD_SPIN_UP = 2,
	PORT_CMD_START = 1,
	PORT_CMD_ICC_MASK = 4026531840,
	PORT_CMD_ICC_ACTIVE = 268435456,
	PORT_CMD_ICC_PARTIAL = 536870912,
	PORT_CMD_ICC_SLUMBER = 1610612736,
	PORT_CMD_CAP = 8126464,
	PORT_FBS_DWE_OFFSET = 16,
	PORT_FBS_ADO_OFFSET = 12,
	PORT_FBS_DEV_OFFSET = 8,
	PORT_FBS_DEV_MASK = 3840,
	PORT_FBS_SDE = 4,
	PORT_FBS_DEC = 2,
	PORT_FBS_EN = 1,
	PORT_DEVSLP_DM_OFFSET = 25,
	PORT_DEVSLP_DM_MASK = 503316480,
	PORT_DEVSLP_DITO_OFFSET = 15,
	PORT_DEVSLP_MDAT_OFFSET = 10,
	PORT_DEVSLP_DETO_OFFSET = 2,
	PORT_DEVSLP_DSP = 2,
	PORT_DEVSLP_ADSE = 1,
	AHCI_HFLAG_NO_NCQ = 1,
	AHCI_HFLAG_IGN_IRQ_IF_ERR = 2,
	AHCI_HFLAG_IGN_SERR_INTERNAL = 4,
	AHCI_HFLAG_32BIT_ONLY = 8,
	AHCI_HFLAG_MV_PATA = 16,
	AHCI_HFLAG_NO_MSI = 32,
	AHCI_HFLAG_NO_PMP = 64,
	AHCI_HFLAG_SECT255 = 256,
	AHCI_HFLAG_YES_NCQ = 512,
	AHCI_HFLAG_NO_SUSPEND = 1024,
	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE = 2048,
	AHCI_HFLAG_NO_SNTF = 4096,
	AHCI_HFLAG_NO_FPDMA_AA = 8192,
	AHCI_HFLAG_YES_FBS = 16384,
	AHCI_HFLAG_DELAY_ENGINE = 32768,
	AHCI_HFLAG_NO_DEVSLP = 131072,
	AHCI_HFLAG_NO_FBS = 262144,
	AHCI_HFLAG_MULTI_MSI = 1048576,
	AHCI_HFLAG_WAKE_BEFORE_STOP = 4194304,
	AHCI_HFLAG_YES_ALPM = 8388608,
	AHCI_HFLAG_NO_WRITE_TO_RO = 16777216,
	AHCI_HFLAG_USE_LPM_POLICY = 33554432,
	AHCI_HFLAG_SUSPEND_PHYS = 67108864,
	AHCI_HFLAG_NO_SXS = 268435456,
	AHCI_FLAG_COMMON = 393346,
	ICH_MAP = 144,
	PCS_6 = 146,
	PCS_7 = 148,
	EM_MAX_SLOTS = 15,
	EM_MAX_RETRY = 5,
	EM_CTL_RST = 512,
	EM_CTL_TM = 256,
	EM_CTL_MR = 1,
	EM_CTL_ALHD = 67108864,
	EM_CTL_XMT = 33554432,
	EM_CTL_SMB = 16777216,
	EM_CTL_SGPIO = 524288,
	EM_CTL_SES = 262144,
	EM_CTL_SAFTE = 131072,
	EM_CTL_LED = 65536,
	EM_MSG_TYPE_LED = 1,
	EM_MSG_TYPE_SAFTE = 2,
	EM_MSG_TYPE_SES2 = 4,
	EM_MSG_TYPE_SGPIO = 8,
};

struct ahci_host_priv {
	unsigned int flags;
	u32 mask_port_map;
	void *mmio;
	u32 cap;
	u32 cap2;
	u32 version;
	u32 port_map;
	u32 saved_cap;
	u32 saved_cap2;
	u32 saved_port_map;
	u32 saved_port_cap[32];
	u32 em_loc;
	u32 em_buf_sz;
	u32 em_msg_type;
	u32 remapped_nvme;
	bool got_runtime_pm;
	unsigned int n_clks;
	struct clk_bulk_data *clks;
	unsigned int f_rsts;
	struct reset_control *rsts;
	struct regulator **target_pwrs;
	struct regulator *ahci_regulator;
	struct regulator *phy_regulator;
	struct phy **phys;
	unsigned int nports;
	void *plat_data;
	unsigned int irq;
	void (*start_engine)(struct ata_port *);
	int (*stop_engine)(struct ata_port *);
	irqreturn_t (*irq_handler)(int, void *);
	int (*get_irq_vector)(struct ata_host *, int);
};

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	unsigned short cylinders;
	unsigned long start;
};

enum {
	GENHD_FL_REMOVABLE = 1,
	GENHD_FL_HIDDEN = 2,
	GENHD_FL_NO_PART = 4,
};

struct mtd_blktrans_ops;

struct mtd_blktrans_dev {
	struct mtd_blktrans_ops *tr;
	struct list_head list;
	struct mtd_info *mtd;
	struct mutex lock;
	int devnum;
	bool bg_stop;
	unsigned long size;
	int readonly;
	int open;
	struct kref ref;
	struct gendisk *disk;
	struct attribute_group *disk_attributes;
	struct request_queue *rq;
	struct list_head rq_list;
	struct blk_mq_tag_set *tag_set;
	spinlock_t queue_lock;
	void *priv;
	bool writable;
};

struct mtd_blktrans_ops {
	char *name;
	int major;
	int part_bits;
	int blksize;
	int blkshift;
	int (*readsect)(struct mtd_blktrans_dev *, unsigned long, char *);
	int (*writesect)(struct mtd_blktrans_dev *, unsigned long, char *);
	int (*discard)(struct mtd_blktrans_dev *, unsigned long, unsigned int);
	void (*background)(struct mtd_blktrans_dev *);
	int (*getgeo)(struct mtd_blktrans_dev *, struct hd_geometry *);
	int (*flush)(struct mtd_blktrans_dev *);
	int (*open)(struct mtd_blktrans_dev *);
	void (*release)(struct mtd_blktrans_dev *);
	void (*add_mtd)(struct mtd_blktrans_ops *, struct mtd_info *);
	void (*remove_dev)(struct mtd_blktrans_dev *);
	struct list_head devs;
	struct list_head list;
	struct module *owner;
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

struct nand_onfi_vendor_macronix {
	u8 reserved;
	u8 reliability_func;
};

enum spi_nor_option_flags {
	SNOR_F_HAS_SR_TB = 1,
	SNOR_F_NO_OP_CHIP_ERASE = 2,
	SNOR_F_BROKEN_RESET = 4,
	SNOR_F_4B_OPCODES = 8,
	SNOR_F_HAS_4BAIT = 16,
	SNOR_F_HAS_LOCK = 32,
	SNOR_F_HAS_16BIT_SR = 64,
	SNOR_F_NO_READ_CR = 128,
	SNOR_F_HAS_SR_TB_BIT6 = 256,
	SNOR_F_HAS_4BIT_BP = 512,
	SNOR_F_HAS_SR_BP3_BIT6 = 1024,
	SNOR_F_IO_MODE_EN_VOLATILE = 2048,
	SNOR_F_SOFT_RESET = 4096,
	SNOR_F_SWP_IS_VOLATILE = 8192,
	SNOR_F_RWW = 16384,
	SNOR_F_ECC = 32768,
	SNOR_F_NO_WP = 65536,
};

struct spi_qup {
	void *base;
	struct device *dev;
	struct clk *cclk;
	struct clk *iclk;
	struct icc_path *icc_path;
	int irq;
	spinlock_t lock;
	int in_fifo_sz;
	int out_fifo_sz;
	int in_blk_sz;
	int out_blk_sz;
	struct spi_transfer *xfer;
	struct completion done;
	int error;
	int w_size;
	int n_words;
	int tx_bytes;
	int rx_bytes;
	const u8 *tx_buf;
	u8 *rx_buf;
	int qup_v1;
	int mode;
	struct dma_slave_config rx_conf;
	struct dma_slave_config tx_conf;
	u32 bw_speed_hz;
};

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

enum xgbe_speedset {
	XGBE_SPEEDSET_1000_10000 = 0,
	XGBE_SPEEDSET_2500_10000 = 1,
};

enum xgbe_speed {
	XGBE_SPEED_1000 = 0,
	XGBE_SPEED_2500 = 1,
	XGBE_SPEED_10000 = 2,
	XGBE_SPEEDS = 3,
};

struct xgbe_phy_data___2 {
	unsigned int speed_set;
	u32 blwc[3];
	u32 cdr_rate[3];
	u32 pq_skew[3];
	u32 tx_amp[3];
	u32 dfe_tap_cfg[3];
	u32 dfe_tap_ena[3];
};

struct macb_usrio_config;

struct macb_config {
	u32 caps;
	unsigned int dma_burst_length;
	int (*clk_init)(struct platform_device *, struct clk **, struct clk **, struct clk **, struct clk **, struct clk **);
	int (*init)(struct platform_device *);
	unsigned int max_tx_length;
	int jumbo_max_len;
	const struct macb_usrio_config *usrio;
};

struct macb_usrio_config {
	u32 mii;
	u32 rmii;
	u32 rgmii;
	u32 refclk;
	u32 hdfctlen;
};

struct gem_statistic {
	char stat_string[32];
	int offset;
	u32 stat_bits;
};

struct macb;

struct macb_ptp_info {
	void (*ptp_init)(struct net_device *);
	void (*ptp_remove)(struct net_device *);
	s32 (*get_ptp_max_adj)();
	unsigned int (*get_tsu_rate)(struct macb *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_hwtst)(struct net_device *, struct ifreq *);
	int (*set_hwtst)(struct net_device *, struct ifreq *, int);
};

struct macb_stats {
	u32 rx_pause_frames;
	u32 tx_ok;
	u32 tx_single_cols;
	u32 tx_multiple_cols;
	u32 rx_ok;
	u32 rx_fcs_errors;
	u32 rx_align_errors;
	u32 tx_deferred;
	u32 tx_late_cols;
	u32 tx_excessive_cols;
	u32 tx_underruns;
	u32 tx_carrier_errors;
	u32 rx_resource_errors;
	u32 rx_overruns;
	u32 rx_symbol_errors;
	u32 rx_oversize_pkts;
	u32 rx_jabbers;
	u32 rx_undersize_pkts;
	u32 sqe_test_errors;
	u32 rx_length_mismatch;
	u32 tx_pause_frames;
};

struct gem_stats {
	u32 tx_octets_31_0;
	u32 tx_octets_47_32;
	u32 tx_frames;
	u32 tx_broadcast_frames;
	u32 tx_multicast_frames;
	u32 tx_pause_frames;
	u32 tx_64_byte_frames;
	u32 tx_65_127_byte_frames;
	u32 tx_128_255_byte_frames;
	u32 tx_256_511_byte_frames;
	u32 tx_512_1023_byte_frames;
	u32 tx_1024_1518_byte_frames;
	u32 tx_greater_than_1518_byte_frames;
	u32 tx_underrun;
	u32 tx_single_collision_frames;
	u32 tx_multiple_collision_frames;
	u32 tx_excessive_collisions;
	u32 tx_late_collisions;
	u32 tx_deferred_frames;
	u32 tx_carrier_sense_errors;
	u32 rx_octets_31_0;
	u32 rx_octets_47_32;
	u32 rx_frames;
	u32 rx_broadcast_frames;
	u32 rx_multicast_frames;
	u32 rx_pause_frames;
	u32 rx_64_byte_frames;
	u32 rx_65_127_byte_frames;
	u32 rx_128_255_byte_frames;
	u32 rx_256_511_byte_frames;
	u32 rx_512_1023_byte_frames;
	u32 rx_1024_1518_byte_frames;
	u32 rx_greater_than_1518_byte_frames;
	u32 rx_undersized_frames;
	u32 rx_oversize_frames;
	u32 rx_jabbers;
	u32 rx_frame_check_sequence_errors;
	u32 rx_length_field_frame_errors;
	u32 rx_symbol_errors;
	u32 rx_alignment_errors;
	u32 rx_resource_errors;
	u32 rx_overruns;
	u32 rx_ip_header_checksum_errors;
	u32 rx_tcp_checksum_errors;
	u32 rx_udp_checksum_errors;
};

struct queue_stats {
	union {
		unsigned long first;
		unsigned long rx_packets;
	};
	unsigned long rx_bytes;
	unsigned long rx_dropped;
	unsigned long tx_packets;
	unsigned long tx_bytes;
	unsigned long tx_dropped;
};

struct macb_dma_desc;

struct macb_tx_skb;

struct macb_queue {
	struct macb *bp;
	int irq;
	unsigned int ISR;
	unsigned int IER;
	unsigned int IDR;
	unsigned int IMR;
	unsigned int TBQP;
	unsigned int TBQPH;
	unsigned int RBQS;
	unsigned int RBQP;
	unsigned int RBQPH;
	spinlock_t tx_ptr_lock;
	unsigned int tx_head;
	unsigned int tx_tail;
	struct macb_dma_desc *tx_ring;
	struct macb_tx_skb *tx_skb;
	dma_addr_t tx_ring_dma;
	struct work_struct tx_error_task;
	bool txubr_pending;
	struct napi_struct napi_tx;
	dma_addr_t rx_ring_dma;
	dma_addr_t rx_buffers_dma;
	unsigned int rx_tail;
	unsigned int rx_prepared_head;
	struct macb_dma_desc *rx_ring;
	struct sk_buff **rx_skbuff;
	void *rx_buffers;
	struct napi_struct napi_rx;
	struct queue_stats stats;
};

struct macb_or_gem_ops {
	int (*mog_alloc_rx_buffers)(struct macb *);
	void (*mog_free_rx_buffers)(struct macb *);
	void (*mog_init_rings)(struct macb *);
	int (*mog_rx)(struct macb_queue *, struct napi_struct *, int);
};

struct macb_tx_skb {
	struct sk_buff *skb;
	dma_addr_t mapping;
	size_t size;
	bool mapped_as_page;
};

struct tsu_incr {
	u32 sub_ns;
	u32 ns;
};

struct ethtool_rx_fs_list {
	struct list_head list;
	unsigned int count;
};

struct macb_pm_data {
	u32 scrt2;
	u32 usrio;
};

struct macb {
	void *regs;
	bool native_io;
	u32 (*macb_reg_readl)(struct macb *, int);
	void (*macb_reg_writel)(struct macb *, int, u32);
	size_t rx_buffer_size;
	unsigned int rx_ring_size;
	unsigned int tx_ring_size;
	unsigned int num_queues;
	unsigned int queue_mask;
	struct macb_queue queues[8];
	spinlock_t lock;
	struct platform_device *pdev;
	struct clk *pclk;
	struct clk *hclk;
	struct clk *tx_clk;
	struct clk *rx_clk;
	struct clk *tsu_clk;
	struct net_device *dev;
	union {
		struct macb_stats macb;
		struct gem_stats gem;
	} hw_stats;
	struct macb_or_gem_ops macbgem_ops;
	struct mii_bus *mii_bus;
	struct phylink *phylink;
	struct phylink_config phylink_config;
	struct phylink_pcs phylink_usx_pcs;
	struct phylink_pcs phylink_sgmii_pcs;
	u32 caps;
	unsigned int dma_burst_length;
	phy_interface_t phy_interface;
	struct macb_tx_skb rm9200_txq[2];
	unsigned int max_tx_length;
	u64 ethtool_stats[91];
	unsigned int rx_frm_len_mask;
	unsigned int jumbo_max_len;
	u32 wol;
	u32 rx_watermark;
	struct macb_ptp_info *ptp_info;
	struct phy *sgmii_phy;
	uint8_t hw_dma_cap;
	spinlock_t tsu_clk_lock;
	unsigned int tsu_rate;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct tsu_incr tsu_incr;
	struct hwtstamp_config tstamp_config;
	struct ethtool_rx_fs_list rx_fs_list;
	spinlock_t rx_fs_lock;
	unsigned int max_tuples;
	struct tasklet_struct hresp_err_tasklet;
	int rx_bd_rd_prefetch;
	int tx_bd_rd_prefetch;
	u32 rx_intr_mask;
	struct macb_pm_data pm_data;
	const struct macb_usrio_config *usrio;
};

struct macb_dma_desc {
	u32 addr;
	u32 ctrl;
};

struct sifive_fu540_macb_mgmt {
	void *reg;
	unsigned long rate;
	struct clk_hw hw;
};

enum macb_bd_control {
	TSTAMP_DISABLED = 0,
	TSTAMP_FRAME_PTP_EVENT_ONLY = 1,
	TSTAMP_ALL_PTP_FRAMES = 2,
	TSTAMP_ALL_FRAMES = 3,
};

enum {
	MLO_PAUSE_NONE = 0,
	MLO_PAUSE_RX = 1,
	MLO_PAUSE_TX = 2,
	MLO_PAUSE_TXRX_MASK = 3,
	MLO_PAUSE_AN = 4,
	MLO_AN_PHY = 0,
	MLO_AN_FIXED = 1,
	MLO_AN_INBAND = 2,
	PHYLINK_PCS_NEG_NONE = 0,
	PHYLINK_PCS_NEG_ENABLED = 16,
	PHYLINK_PCS_NEG_OUTBAND = 32,
	PHYLINK_PCS_NEG_INBAND = 64,
	PHYLINK_PCS_NEG_INBAND_DISABLED = 64,
	PHYLINK_PCS_NEG_INBAND_ENABLED = 80,
	MAC_SYM_PAUSE = 1,
	MAC_ASYM_PAUSE = 2,
	MAC_10HD = 4,
	MAC_10FD = 8,
	MAC_10 = 12,
	MAC_100HD = 16,
	MAC_100FD = 32,
	MAC_100 = 48,
	MAC_1000HD = 64,
	MAC_1000FD = 128,
	MAC_1000 = 192,
	MAC_2500FD = 256,
	MAC_5000FD = 512,
	MAC_10000FD = 1024,
	MAC_20000FD = 2048,
	MAC_25000FD = 4096,
	MAC_40000FD = 8192,
	MAC_50000FD = 16384,
	MAC_56000FD = 32768,
	MAC_100000FD = 65536,
	MAC_200000FD = 131072,
	MAC_400000FD = 262144,
};

enum pm_api_id {
	PM_GET_API_VERSION = 1,
	PM_REGISTER_NOTIFIER = 5,
	PM_FORCE_POWERDOWN = 8,
	PM_REQUEST_WAKEUP = 10,
	PM_SYSTEM_SHUTDOWN = 12,
	PM_REQUEST_NODE = 13,
	PM_RELEASE_NODE = 14,
	PM_SET_REQUIREMENT = 15,
	PM_RESET_ASSERT = 17,
	PM_RESET_GET_STATUS = 18,
	PM_MMIO_WRITE = 19,
	PM_MMIO_READ = 20,
	PM_PM_INIT_FINALIZE = 21,
	PM_FPGA_LOAD = 22,
	PM_FPGA_GET_STATUS = 23,
	PM_GET_CHIPID = 24,
	PM_SECURE_SHA = 26,
	PM_PINCTRL_REQUEST = 28,
	PM_PINCTRL_RELEASE = 29,
	PM_PINCTRL_GET_FUNCTION = 30,
	PM_PINCTRL_SET_FUNCTION = 31,
	PM_PINCTRL_CONFIG_PARAM_GET = 32,
	PM_PINCTRL_CONFIG_PARAM_SET = 33,
	PM_IOCTL = 34,
	PM_QUERY_DATA = 35,
	PM_CLOCK_ENABLE = 36,
	PM_CLOCK_DISABLE = 37,
	PM_CLOCK_GETSTATE = 38,
	PM_CLOCK_SETDIVIDER = 39,
	PM_CLOCK_GETDIVIDER = 40,
	PM_CLOCK_SETRATE = 41,
	PM_CLOCK_GETRATE = 42,
	PM_CLOCK_SETPARENT = 43,
	PM_CLOCK_GETPARENT = 44,
	PM_FPGA_READ = 46,
	PM_SECURE_AES = 47,
	PM_FEATURE_CHECK = 63,
};

enum pm_ioctl_id {
	IOCTL_GET_RPU_OPER_MODE = 0,
	IOCTL_SET_RPU_OPER_MODE = 1,
	IOCTL_RPU_BOOT_ADDR_CONFIG = 2,
	IOCTL_TCM_COMB_CONFIG = 3,
	IOCTL_SET_TAPDELAY_BYPASS = 4,
	IOCTL_SD_DLL_RESET = 6,
	IOCTL_SET_SD_TAPDELAY = 7,
	IOCTL_SET_PLL_FRAC_MODE = 8,
	IOCTL_GET_PLL_FRAC_MODE = 9,
	IOCTL_SET_PLL_FRAC_DATA = 10,
	IOCTL_GET_PLL_FRAC_DATA = 11,
	IOCTL_WRITE_GGS = 12,
	IOCTL_READ_GGS = 13,
	IOCTL_WRITE_PGGS = 14,
	IOCTL_READ_PGGS = 15,
	IOCTL_SET_BOOT_HEALTH_STATUS = 17,
	IOCTL_OSPI_MUX_SELECT = 21,
	IOCTL_REGISTER_SGI = 25,
	IOCTL_SET_FEATURE_CONFIG = 26,
	IOCTL_GET_FEATURE_CONFIG = 27,
	IOCTL_SET_SD_CONFIG = 30,
	IOCTL_SET_GEM_CONFIG = 31,
};

enum pm_gem_config_type {
	GEM_CONFIG_SGMII_MODE = 1,
	GEM_CONFIG_FIXED = 2,
};

struct macb_dma_desc_64 {
	u32 addrh;
	u32 resvd;
};

struct ethtool_rx_fs_item {
	struct ethtool_rx_flow_spec fs;
	struct list_head list;
};

struct clock_identity {
	u8 id[8];
};

struct port_identity {
	struct clock_identity clock_identity;
	__be16 port_number;
};

struct ptp_header {
	u8 tsmt;
	u8 ver;
	__be16 message_length;
	u8 domain_number;
	u8 reserved1;
	u8 flag_field[2];
	__be64 correction;
	__be32 reserved2;
	struct port_identity source_port_identity;
	__be16 sequence_id;
	u8 control;
	u8 log_message_interval;
} __attribute__((packed));

struct macb_platform_data {
	struct clk *pclk;
	struct clk *hclk;
};

struct dprtc_cmd_open {
	__le32 dprtc_id;
};

struct dprtc_cmd_set_irq_enable {
	u8 en;
	u8 pad[3];
	u8 irq_index;
};

struct dprtc_cmd_get_irq {
	__le32 pad;
	u8 irq_index;
} __attribute__((packed));

struct dprtc_rsp_get_irq_enable {
	u8 en;
};

struct dprtc_cmd_set_irq_mask {
	__le32 mask;
	u8 irq_index;
} __attribute__((packed));

struct dprtc_rsp_get_irq_mask {
	__le32 mask;
};

struct dprtc_cmd_get_irq_status {
	__le32 status;
	u8 irq_index;
} __attribute__((packed));

struct dprtc_rsp_get_irq_status {
	__le32 status;
};

struct dprtc_cmd_clear_irq_status {
	__le32 status;
	u8 irq_index;
} __attribute__((packed));

struct enetc_ierb {
	void *regs;
};

struct hclge_hw_error {
	u32 int_msk;
	const char *msg;
	enum hnae3_reset_type reset_level;
};

struct hclge_dev;

struct hclge_hw_blk {
	u32 msk;
	const char *name;
	int (*config_err_int)(struct hclge_dev *, bool);
};

struct hclge_mac_tnl_stats {
	u64 time;
	u32 status;
};

struct hclge_desc;

struct hclge_comm_cmq_ring {
	dma_addr_t desc_dma_addr;
	struct hclge_desc *desc;
	struct pci_dev *pdev;
	u32 head;
	u32 tail;
	u16 buf_size;
	u16 desc_num;
	int next_to_use;
	int next_to_clean;
	u8 ring_type;
	spinlock_t lock;
};

enum hclge_comm_cmd_status {
	HCLGE_COMM_STATUS_SUCCESS = 0,
	HCLGE_COMM_ERR_CSQ_FULL = -1,
	HCLGE_COMM_ERR_CSQ_TIMEOUT = -2,
	HCLGE_COMM_ERR_CSQ_ERROR = -3,
};

struct hclge_comm_cmq {
	struct hclge_comm_cmq_ring csq;
	struct hclge_comm_cmq_ring crq;
	u16 tx_timeout;
	enum hclge_comm_cmd_status last_status;
};

struct hclge_comm_hw {
	void *io_base;
	void *mem_base;
	struct hclge_comm_cmq cmq;
	unsigned long comm_state;
};

struct hclge_wol_info {
	u32 wol_support_mode;
	u32 wol_current_mode;
	u8 wol_sopass[6];
	u8 wol_sopass_size;
};

struct hclge_mac {
	u8 mac_id;
	u8 phy_addr;
	u8 flag;
	u8 media_type;
	u8 mac_addr[6];
	u8 autoneg;
	u8 duplex;
	u8 support_autoneg;
	u8 speed_type;
	u8 lane_num;
	u32 speed;
	u32 max_speed;
	u32 speed_ability;
	u32 module_type;
	u32 fec_mode;
	u32 user_fec_mode;
	u32 fec_ability;
	int link;
	struct hclge_wol_info wol;
	struct phy_device *phydev;
	struct mii_bus *mdio_bus;
	phy_interface_t phy_if;
	unsigned long supported[2];
	unsigned long advertising[2];
};

struct hclge_hw {
	struct hclge_comm_hw hw;
	struct hclge_mac mac;
	int num_vec;
};

struct hclge_misc_vector {
	u8 *addr;
	int vector_irq;
	char name[32];
};

struct hclge_mac_stats {
	u64 mac_tx_mac_pause_num;
	u64 mac_rx_mac_pause_num;
	u64 rsv0;
	u64 mac_tx_pfc_pri0_pkt_num;
	u64 mac_tx_pfc_pri1_pkt_num;
	u64 mac_tx_pfc_pri2_pkt_num;
	u64 mac_tx_pfc_pri3_pkt_num;
	u64 mac_tx_pfc_pri4_pkt_num;
	u64 mac_tx_pfc_pri5_pkt_num;
	u64 mac_tx_pfc_pri6_pkt_num;
	u64 mac_tx_pfc_pri7_pkt_num;
	u64 mac_rx_pfc_pri0_pkt_num;
	u64 mac_rx_pfc_pri1_pkt_num;
	u64 mac_rx_pfc_pri2_pkt_num;
	u64 mac_rx_pfc_pri3_pkt_num;
	u64 mac_rx_pfc_pri4_pkt_num;
	u64 mac_rx_pfc_pri5_pkt_num;
	u64 mac_rx_pfc_pri6_pkt_num;
	u64 mac_rx_pfc_pri7_pkt_num;
	u64 mac_tx_total_pkt_num;
	u64 mac_tx_total_oct_num;
	u64 mac_tx_good_pkt_num;
	u64 mac_tx_bad_pkt_num;
	u64 mac_tx_good_oct_num;
	u64 mac_tx_bad_oct_num;
	u64 mac_tx_uni_pkt_num;
	u64 mac_tx_multi_pkt_num;
	u64 mac_tx_broad_pkt_num;
	u64 mac_tx_undersize_pkt_num;
	u64 mac_tx_oversize_pkt_num;
	u64 mac_tx_64_oct_pkt_num;
	u64 mac_tx_65_127_oct_pkt_num;
	u64 mac_tx_128_255_oct_pkt_num;
	u64 mac_tx_256_511_oct_pkt_num;
	u64 mac_tx_512_1023_oct_pkt_num;
	u64 mac_tx_1024_1518_oct_pkt_num;
	u64 mac_tx_1519_2047_oct_pkt_num;
	u64 mac_tx_2048_4095_oct_pkt_num;
	u64 mac_tx_4096_8191_oct_pkt_num;
	u64 rsv1;
	u64 mac_tx_8192_9216_oct_pkt_num;
	u64 mac_tx_9217_12287_oct_pkt_num;
	u64 mac_tx_12288_16383_oct_pkt_num;
	u64 mac_tx_1519_max_good_oct_pkt_num;
	u64 mac_tx_1519_max_bad_oct_pkt_num;
	u64 mac_rx_total_pkt_num;
	u64 mac_rx_total_oct_num;
	u64 mac_rx_good_pkt_num;
	u64 mac_rx_bad_pkt_num;
	u64 mac_rx_good_oct_num;
	u64 mac_rx_bad_oct_num;
	u64 mac_rx_uni_pkt_num;
	u64 mac_rx_multi_pkt_num;
	u64 mac_rx_broad_pkt_num;
	u64 mac_rx_undersize_pkt_num;
	u64 mac_rx_oversize_pkt_num;
	u64 mac_rx_64_oct_pkt_num;
	u64 mac_rx_65_127_oct_pkt_num;
	u64 mac_rx_128_255_oct_pkt_num;
	u64 mac_rx_256_511_oct_pkt_num;
	u64 mac_rx_512_1023_oct_pkt_num;
	u64 mac_rx_1024_1518_oct_pkt_num;
	u64 mac_rx_1519_2047_oct_pkt_num;
	u64 mac_rx_2048_4095_oct_pkt_num;
	u64 mac_rx_4096_8191_oct_pkt_num;
	u64 rsv2;
	u64 mac_rx_8192_9216_oct_pkt_num;
	u64 mac_rx_9217_12287_oct_pkt_num;
	u64 mac_rx_12288_16383_oct_pkt_num;
	u64 mac_rx_1519_max_good_oct_pkt_num;
	u64 mac_rx_1519_max_bad_oct_pkt_num;
	u64 mac_tx_fragment_pkt_num;
	u64 mac_tx_undermin_pkt_num;
	u64 mac_tx_jabber_pkt_num;
	u64 mac_tx_err_all_pkt_num;
	u64 mac_tx_from_app_good_pkt_num;
	u64 mac_tx_from_app_bad_pkt_num;
	u64 mac_rx_fragment_pkt_num;
	u64 mac_rx_undermin_pkt_num;
	u64 mac_rx_jabber_pkt_num;
	u64 mac_rx_fcs_err_pkt_num;
	u64 mac_rx_send_app_good_pkt_num;
	u64 mac_rx_send_app_bad_pkt_num;
	u64 mac_tx_pfc_pause_pkt_num;
	u64 mac_rx_pfc_pause_pkt_num;
	u64 mac_tx_ctrl_pkt_num;
	u64 mac_rx_ctrl_pkt_num;
	u64 mac_tx_pfc_pri0_xoff_time;
	u64 mac_tx_pfc_pri1_xoff_time;
	u64 mac_tx_pfc_pri2_xoff_time;
	u64 mac_tx_pfc_pri3_xoff_time;
	u64 mac_tx_pfc_pri4_xoff_time;
	u64 mac_tx_pfc_pri5_xoff_time;
	u64 mac_tx_pfc_pri6_xoff_time;
	u64 mac_tx_pfc_pri7_xoff_time;
	u64 mac_rx_pfc_pri0_xoff_time;
	u64 mac_rx_pfc_pri1_xoff_time;
	u64 mac_rx_pfc_pri2_xoff_time;
	u64 mac_rx_pfc_pri3_xoff_time;
	u64 mac_rx_pfc_pri4_xoff_time;
	u64 mac_rx_pfc_pri5_xoff_time;
	u64 mac_rx_pfc_pri6_xoff_time;
	u64 mac_rx_pfc_pri7_xoff_time;
	u64 mac_tx_pause_xoff_time;
	u64 mac_rx_pause_xoff_time;
};

struct hclge_fec_stats {
	u64 rs_corr_blocks;
	u64 rs_uncorr_blocks;
	u64 rs_error_blocks;
	u64 base_r_lane_num;
	u64 base_r_corr_blocks;
	u64 base_r_uncorr_blocks;
	union {
		struct {
			u64 base_r_corr_per_lanes[8];
			u64 base_r_uncorr_per_lanes[8];
		};
		u64 per_lanes[16];
	};
};

struct hclge_rst_stats {
	u32 reset_done_cnt;
	u32 hw_reset_done_cnt;
	u32 pf_rst_cnt;
	u32 flr_rst_cnt;
	u32 global_rst_cnt;
	u32 imp_rst_cnt;
	u32 reset_cnt;
	u32 reset_fail_cnt;
};

enum hclge_fc_mode {
	HCLGE_FC_NONE = 0,
	HCLGE_FC_RX_PAUSE = 1,
	HCLGE_FC_TX_PAUSE = 2,
	HCLGE_FC_FULL = 3,
	HCLGE_FC_PFC = 4,
	HCLGE_FC_DEFAULT = 5,
};

struct hclge_pg_info {
	u8 pg_id;
	u8 pg_sch_mode;
	u8 tc_bit_map;
	u32 bw_limit;
	u8 tc_dwrr[8];
};

struct hclge_tc_info {
	u8 tc_id;
	u8 tc_sch_mode;
	u8 pgid;
	u32 bw_limit;
};

struct hclge_tm_info {
	u8 num_tc;
	u8 num_pg;
	u8 pg_dwrr[4];
	u8 prio_tc[8];
	struct hclge_pg_info pg_info[4];
	struct hclge_tc_info tc_info[8];
	enum hclge_fc_mode fc_mode;
	u8 hw_pfc_map;
	u8 pfc_en;
};

struct hclge_vlan_type_cfg {
	u16 rx_ot_fst_vlan_type;
	u16 rx_ot_sec_vlan_type;
	u16 rx_in_fst_vlan_type;
	u16 rx_in_sec_vlan_type;
	u16 tx_ot_vlan_type;
	u16 tx_in_vlan_type;
};

struct hclge_fd_key_cfg {
	u8 key_sel;
	u8 inner_sipv6_word_en;
	u8 inner_dipv6_word_en;
	u8 outer_sipv6_word_en;
	u8 outer_dipv6_word_en;
	u32 tuple_active;
	u32 meta_data_active;
};

struct hclge_fd_user_def_cfg {
	u16 ref_cnt;
	u16 offset;
};

struct hclge_fd_cfg {
	u8 fd_mode;
	u16 max_key_length;
	u32 rule_num[2];
	u16 cnt_num[2];
	struct hclge_fd_key_cfg key_cfg[2];
	struct hclge_fd_user_def_cfg user_def_cfg[3];
};

enum HCLGE_FD_ACTIVE_RULE_TYPE {
	HCLGE_FD_RULE_NONE = 0,
	HCLGE_FD_ARFS_ACTIVE = 1,
	HCLGE_FD_EP_ACTIVE = 2,
	HCLGE_FD_TC_FLOWER_ACTIVE = 3,
};

struct hclge_comm_rss_tuple_cfg {
	u8 ipv4_tcp_en;
	u8 ipv4_udp_en;
	u8 ipv4_sctp_en;
	u8 ipv4_fragment_en;
	u8 ipv6_tcp_en;
	u8 ipv6_udp_en;
	u8 ipv6_sctp_en;
	u8 ipv6_fragment_en;
};

struct hclge_comm_rss_cfg {
	u8 rss_hash_key[40];
	u16 *rss_indirection_tbl;
	u32 rss_algo;
	struct hclge_comm_rss_tuple_cfg rss_tuple_sets;
	u32 rss_size;
};

struct hclge_comm_tqp;

struct hclge_vport;

struct hclge_ptp;

struct hclge_dev {
	struct pci_dev *pdev;
	struct hnae3_ae_dev *ae_dev;
	struct hclge_hw hw;
	struct hclge_misc_vector misc_vector;
	struct hclge_mac_stats mac_stats;
	struct hclge_fec_stats fec_stats;
	unsigned long state;
	unsigned long flr_state;
	unsigned long last_reset_time;
	enum hnae3_reset_type reset_type;
	enum hnae3_reset_type reset_level;
	unsigned long default_reset_request;
	unsigned long reset_request;
	unsigned long reset_pending;
	struct hclge_rst_stats rst_stats;
	struct semaphore reset_sem;
	u32 fw_version;
	u16 num_tqps;
	u16 num_req_vfs;
	u16 base_tqp_pid;
	u16 alloc_rss_size;
	u16 vf_rss_size_max;
	u16 pf_rss_size_max;
	u32 tx_spare_buf_size;
	u16 fdir_pf_filter_count;
	u16 num_alloc_vport;
	u32 numa_node_mask;
	u16 rx_buf_len;
	u16 num_tx_desc;
	u16 num_rx_desc;
	u8 hw_tc_map;
	enum hclge_fc_mode fc_mode_last_time;
	u8 support_sfp_query;
	u8 tx_sch_mode;
	u8 tc_max;
	u8 pfc_max;
	u8 default_up;
	u8 dcbx_cap;
	struct hclge_tm_info tm_info;
	u16 num_msi;
	u16 num_msi_left;
	u16 num_msi_used;
	u16 *vector_status;
	int *vector_irq;
	u16 num_nic_msi;
	u16 num_roce_msi;
	unsigned long service_timer_period;
	unsigned long service_timer_previous;
	struct timer_list reset_timer;
	struct delayed_work service_task;
	bool cur_promisc;
	int num_alloc_vfs;
	struct hclge_comm_tqp *htqp;
	struct hclge_vport *vport;
	struct dentry *hclge_dbgfs;
	struct hnae3_client *nic_client;
	struct hnae3_client *roce_client;
	u32 flag;
	u32 pkt_buf_size;
	u32 tx_buf_size;
	u32 dv_buf_size;
	u32 mps;
	struct mutex vport_lock;
	struct hclge_vlan_type_cfg vlan_type_cfg;
	unsigned long vlan_table[16384];
	unsigned long vf_vlan_full[4];
	unsigned long vport_config_block[4];
	struct hclge_fd_cfg fd_cfg;
	struct hlist_head fd_rule_list;
	spinlock_t fd_rule_lock;
	u16 hclge_fd_rule_num;
	unsigned long serv_processed_cnt;
	unsigned long last_serv_processed;
	unsigned long last_rst_scheduled;
	unsigned long last_mbx_scheduled;
	unsigned long fd_bmap[64];
	enum HCLGE_FD_ACTIVE_RULE_TYPE fd_active_type;
	u8 fd_en;
	bool gro_en;
	u16 wanted_umv_size;
	u16 max_umv_size;
	u16 priv_umv_size;
	u16 share_umv_size;
	u16 used_mc_mac_num;
	struct {
		union {
			struct __kfifo kfifo;
			struct hclge_mac_tnl_stats *type;
			const struct hclge_mac_tnl_stats *const_type;
			char (*rectype)[0];
			struct hclge_mac_tnl_stats *ptr;
			const struct hclge_mac_tnl_stats *ptr_const;
		};
		struct hclge_mac_tnl_stats buf[8];
	} mac_tnl_log;
	struct hclge_ptp *ptp;
	struct devlink *devlink;
	struct hclge_comm_rss_cfg rss_cfg;
};

struct hclge_desc {
	__le16 opcode;
	__le16 flag;
	__le16 retval;
	__le16 rsv;
	__le32 data[6];
};

struct hclge_comm_tqp_stats {
	u64 rcb_tx_ring_pktnum_rcd;
	u64 rcb_rx_ring_pktnum_rcd;
};

struct hclge_comm_tqp {
	struct device *dev;
	struct hnae3_queue q;
	struct hclge_comm_tqp_stats tqp_stats;
	u16 index;
	bool alloced;
};

struct hclge_vlan_info {
	u16 vlan_proto;
	u16 qos;
	u16 vlan_tag;
};

struct hclge_port_base_vlan_config {
	u16 state;
	bool tbl_sta;
	struct hclge_vlan_info vlan_info;
	struct hclge_vlan_info old_vlan_info;
};

struct hclge_tx_vtag_cfg {
	bool accept_tag1;
	bool accept_untag1;
	bool accept_tag2;
	bool accept_untag2;
	bool insert_tag1_en;
	bool insert_tag2_en;
	u16 default_tag1;
	u16 default_tag2;
	bool tag_shift_mode_en;
};

struct hclge_rx_vtag_cfg {
	bool rx_vlan_offload_en;
	bool strip_tag1_en;
	bool strip_tag2_en;
	bool vlan1_vlan_prionly;
	bool vlan2_vlan_prionly;
	bool strip_tag1_discard_en;
	bool strip_tag2_discard_en;
};

struct hclge_vf_info {
	int link_state;
	u8 mac[6];
	u32 spoofchk;
	u32 max_tx_rate;
	u32 trusted;
	u8 request_uc_en;
	u8 request_mc_en;
	u8 request_bc_en;
};

struct hclge_vport {
	u16 alloc_tqps;
	u16 qs_offset;
	u32 bw_limit;
	u8 dwrr;
	bool req_vlan_fltr_en;
	bool cur_vlan_fltr_en;
	unsigned long vlan_del_fail_bmap[64];
	struct hclge_port_base_vlan_config port_base_vlan_cfg;
	struct hclge_tx_vtag_cfg txvlan_cfg;
	struct hclge_rx_vtag_cfg rxvlan_cfg;
	u16 used_umv_num;
	u16 vport_id;
	struct hclge_dev *back;
	struct hnae3_handle nic;
	struct hnae3_handle roce;
	unsigned long state;
	unsigned long need_notify;
	unsigned long last_active_jiffies;
	u32 mps;
	struct hclge_vf_info vf_info;
	u8 overflow_promisc_flags;
	u8 last_promisc_flags;
	spinlock_t mac_list_lock;
	struct list_head uc_mac_list;
	struct list_head mc_mac_list;
	struct list_head vlan_list;
};

struct hclge_ptp_cycle {
	u32 quo;
	u32 numer;
	u32 den;
};

struct hclge_ptp {
	struct hclge_dev *hdev;
	struct ptp_clock *clock;
	struct sk_buff *tx_skb;
	unsigned long flags;
	void *io_base;
	struct ptp_clock_info info;
	struct hwtstamp_config ts_cfg;
	spinlock_t lock;
	u32 ptp_cfg;
	u32 last_tx_seqid;
	struct hclge_ptp_cycle cycle;
	unsigned long tx_start;
	unsigned long tx_cnt;
	unsigned long tx_skipped;
	unsigned long tx_cleaned;
	unsigned long last_rx;
	unsigned long rx_cnt;
	unsigned long tx_timeout;
};

enum hclge_mod_name_list {
	MODULE_NONE = 0,
	MODULE_BIOS_COMMON = 1,
	MODULE_GE = 2,
	MODULE_IGU_EGU = 3,
	MODULE_LGE = 4,
	MODULE_NCSI = 5,
	MODULE_PPP = 6,
	MODULE_QCN = 7,
	MODULE_RCB_RX = 8,
	MODULE_RTC = 9,
	MODULE_SSU = 10,
	MODULE_TM = 11,
	MODULE_RCB_TX = 12,
	MODULE_TXDMA = 13,
	MODULE_MASTER = 14,
	MODULE_HIMAC = 15,
	MODULE_ROCEE_TOP = 40,
	MODULE_ROCEE_TIMER = 41,
	MODULE_ROCEE_MDB = 42,
	MODULE_ROCEE_TSP = 43,
	MODULE_ROCEE_TRP = 44,
	MODULE_ROCEE_SCC = 45,
	MODULE_ROCEE_CAEP = 46,
	MODULE_ROCEE_GEN_AC = 47,
	MODULE_ROCEE_QMM = 48,
	MODULE_ROCEE_LSAN = 49,
};

struct hclge_hw_module_id {
	enum hclge_mod_name_list module_id;
	const char *msg;
};

enum hclge_err_type_list {
	NONE_ERROR = 0,
	FIFO_ERROR = 1,
	MEMORY_ERROR = 2,
	POISON_ERROR = 3,
	MSIX_ECC_ERROR = 4,
	TQP_INT_ECC_ERROR = 5,
	PF_ABNORMAL_INT_ERROR = 6,
	MPF_ABNORMAL_INT_ERROR = 7,
	COMMON_ERROR = 8,
	PORT_ERROR = 9,
	ETS_ERROR = 10,
	NCSI_ERROR = 11,
	GLB_ERROR = 12,
	LINK_ERROR = 13,
	PTP_ERROR = 14,
	ROCEE_NORMAL_ERR = 40,
	ROCEE_OVF_ERR = 41,
	ROCEE_BUS_ERR = 42,
};

struct hclge_hw_type_id {
	enum hclge_err_type_list type_id;
	const char *msg;
	bool cause_by_vf;
};

enum hclge_opcode_type {
	HCLGE_OPC_QUERY_FW_VER = 1,
	HCLGE_OPC_CFG_RST_TRIGGER = 32,
	HCLGE_OPC_GBL_RST_STATUS = 33,
	HCLGE_OPC_QUERY_FUNC_STATUS = 34,
	HCLGE_OPC_QUERY_PF_RSRC = 35,
	HCLGE_OPC_QUERY_VF_RSRC = 36,
	HCLGE_OPC_GET_CFG_PARAM = 37,
	HCLGE_OPC_PF_RST_DONE = 38,
	HCLGE_OPC_QUERY_VF_RST_RDY = 39,
	HCLGE_OPC_STATS_64_BIT = 48,
	HCLGE_OPC_STATS_32_BIT = 49,
	HCLGE_OPC_STATS_MAC = 50,
	HCLGE_OPC_QUERY_MAC_REG_NUM = 51,
	HCLGE_OPC_STATS_MAC_ALL = 52,
	HCLGE_OPC_QUERY_REG_NUM = 64,
	HCLGE_OPC_QUERY_32_BIT_REG = 65,
	HCLGE_OPC_QUERY_64_BIT_REG = 66,
	HCLGE_OPC_DFX_BD_NUM = 67,
	HCLGE_OPC_DFX_BIOS_COMMON_REG = 68,
	HCLGE_OPC_DFX_SSU_REG_0 = 69,
	HCLGE_OPC_DFX_SSU_REG_1 = 70,
	HCLGE_OPC_DFX_IGU_EGU_REG = 71,
	HCLGE_OPC_DFX_RPU_REG_0 = 72,
	HCLGE_OPC_DFX_RPU_REG_1 = 73,
	HCLGE_OPC_DFX_NCSI_REG = 74,
	HCLGE_OPC_DFX_RTC_REG = 75,
	HCLGE_OPC_DFX_PPP_REG = 76,
	HCLGE_OPC_DFX_RCB_REG = 77,
	HCLGE_OPC_DFX_TQP_REG = 78,
	HCLGE_OPC_DFX_SSU_REG_2 = 79,
	HCLGE_OPC_QUERY_DEV_SPECS = 80,
	HCLGE_OPC_GET_QUEUE_ERR_VF = 103,
	HCLGE_OPC_CONFIG_MAC_MODE = 769,
	HCLGE_OPC_CONFIG_AN_MODE = 772,
	HCLGE_OPC_QUERY_LINK_STATUS = 775,
	HCLGE_OPC_CONFIG_MAX_FRM_SIZE = 776,
	HCLGE_OPC_CONFIG_SPEED_DUP = 777,
	HCLGE_OPC_QUERY_MAC_TNL_INT = 784,
	HCLGE_OPC_MAC_TNL_INT_EN = 785,
	HCLGE_OPC_CLEAR_MAC_TNL_INT = 786,
	HCLGE_OPC_COMMON_LOOPBACK = 789,
	HCLGE_OPC_QUERY_FEC_STATS = 790,
	HCLGE_OPC_CONFIG_FEC_MODE = 794,
	HCLGE_OPC_QUERY_ROH_TYPE_INFO = 905,
	HCLGE_OPC_PTP_INT_EN = 1281,
	HCLGE_OPC_PTP_MODE_CFG = 1287,
	HCLGE_OPC_CFG_MAC_PAUSE_EN = 1793,
	HCLGE_OPC_CFG_PFC_PAUSE_EN = 1794,
	HCLGE_OPC_CFG_MAC_PARA = 1795,
	HCLGE_OPC_CFG_PFC_PARA = 1796,
	HCLGE_OPC_QUERY_MAC_TX_PKT_CNT = 1797,
	HCLGE_OPC_QUERY_MAC_RX_PKT_CNT = 1798,
	HCLGE_OPC_QUERY_PFC_TX_PKT_CNT = 1799,
	HCLGE_OPC_QUERY_PFC_RX_PKT_CNT = 1800,
	HCLGE_OPC_PRI_TO_TC_MAPPING = 1801,
	HCLGE_OPC_QOS_MAP = 1802,
	HCLGE_OPC_TM_PG_TO_PRI_LINK = 2052,
	HCLGE_OPC_TM_QS_TO_PRI_LINK = 2053,
	HCLGE_OPC_TM_NQ_TO_QS_LINK = 2054,
	HCLGE_OPC_TM_RQ_TO_QS_LINK = 2055,
	HCLGE_OPC_TM_PORT_WEIGHT = 2056,
	HCLGE_OPC_TM_PG_WEIGHT = 2057,
	HCLGE_OPC_TM_QS_WEIGHT = 2058,
	HCLGE_OPC_TM_PRI_WEIGHT = 2059,
	HCLGE_OPC_TM_PRI_C_SHAPPING = 2060,
	HCLGE_OPC_TM_PRI_P_SHAPPING = 2061,
	HCLGE_OPC_TM_PG_C_SHAPPING = 2062,
	HCLGE_OPC_TM_PG_P_SHAPPING = 2063,
	HCLGE_OPC_TM_PORT_SHAPPING = 2064,
	HCLGE_OPC_TM_PG_SCH_MODE_CFG = 2066,
	HCLGE_OPC_TM_PRI_SCH_MODE_CFG = 2067,
	HCLGE_OPC_TM_QS_SCH_MODE_CFG = 2068,
	HCLGE_OPC_TM_BP_TO_QSET_MAPPING = 2069,
	HCLGE_OPC_TM_NODES = 2070,
	HCLGE_OPC_ETS_TC_WEIGHT = 2115,
	HCLGE_OPC_QSET_DFX_STS = 2116,
	HCLGE_OPC_PRI_DFX_STS = 2117,
	HCLGE_OPC_PG_DFX_STS = 2118,
	HCLGE_OPC_PORT_DFX_STS = 2119,
	HCLGE_OPC_SCH_NQ_CNT = 2120,
	HCLGE_OPC_SCH_RQ_CNT = 2121,
	HCLGE_OPC_TM_INTERNAL_STS = 2128,
	HCLGE_OPC_TM_INTERNAL_CNT = 2129,
	HCLGE_OPC_TM_INTERNAL_STS_1 = 2130,
	HCLGE_OPC_TM_FLUSH = 2162,
	HCLGE_OPC_TX_BUFF_ALLOC = 2305,
	HCLGE_OPC_RX_PRIV_BUFF_ALLOC = 2306,
	HCLGE_OPC_RX_PRIV_WL_ALLOC = 2307,
	HCLGE_OPC_RX_COM_THRD_ALLOC = 2308,
	HCLGE_OPC_RX_COM_WL_ALLOC = 2309,
	HCLGE_OPC_RX_GBL_PKT_CNT = 2310,
	HCLGE_OPC_SET_TQP_MAP = 2561,
	HCLGE_OPC_CFG_TX_QUEUE = 2817,
	HCLGE_OPC_QUERY_TX_POINTER = 2818,
	HCLGE_OPC_QUERY_TX_STATS = 2819,
	HCLGE_OPC_TQP_TX_QUEUE_TC = 2820,
	HCLGE_OPC_CFG_RX_QUEUE = 2833,
	HCLGE_OPC_QUERY_RX_POINTER = 2834,
	HCLGE_OPC_QUERY_RX_STATS = 2835,
	HCLGE_OPC_STASH_RX_QUEUE_LRO = 2838,
	HCLGE_OPC_CFG_RX_QUEUE_LRO = 2839,
	HCLGE_OPC_CFG_COM_TQP_QUEUE = 2848,
	HCLGE_OPC_RESET_TQP_QUEUE = 2850,
	HCLGE_OPC_PPU_PF_OTHER_INT_DFX = 2890,
	HCLGE_OPC_TSO_GENERIC_CONFIG = 3073,
	HCLGE_OPC_GRO_GENERIC_CONFIG = 3088,
	HCLGE_OPC_RSS_GENERIC_CONFIG = 3329,
	HCLGE_OPC_RSS_INDIR_TABLE = 3335,
	HCLGE_OPC_RSS_TC_MODE = 3336,
	HCLGE_OPC_RSS_INPUT_TUPLE = 3330,
	HCLGE_OPC_CFG_PROMISC_MODE = 3585,
	HCLGE_OPC_VLAN_PORT_TX_CFG = 3841,
	HCLGE_OPC_VLAN_PORT_RX_CFG = 3842,
	HCLGE_OPC_ADD_RING_TO_VECTOR = 5379,
	HCLGE_OPC_DEL_RING_TO_VECTOR = 5380,
	HCLGE_OPC_MAC_VLAN_ADD = 4096,
	HCLGE_OPC_MAC_VLAN_REMOVE = 4097,
	HCLGE_OPC_MAC_VLAN_TYPE_ID = 4098,
	HCLGE_OPC_MAC_VLAN_INSERT = 4099,
	HCLGE_OPC_MAC_VLAN_ALLOCATE = 4100,
	HCLGE_OPC_MAC_ETHTYPE_ADD = 4112,
	HCLGE_OPC_MAC_ETHTYPE_REMOVE = 4113,
	HCLGE_OPC_MAC_VLAN_SWITCH_PARAM = 4147,
	HCLGE_OPC_VLAN_FILTER_CTRL = 4352,
	HCLGE_OPC_VLAN_FILTER_PF_CFG = 4353,
	HCLGE_OPC_VLAN_FILTER_VF_CFG = 4354,
	HCLGE_OPC_PORT_VLAN_BYPASS = 4355,
	HCLGE_OPC_FD_MODE_CTRL = 4608,
	HCLGE_OPC_FD_GET_ALLOCATION = 4609,
	HCLGE_OPC_FD_KEY_CONFIG = 4610,
	HCLGE_OPC_FD_TCAM_OP = 4611,
	HCLGE_OPC_FD_AD_OP = 4612,
	HCLGE_OPC_FD_CNT_OP = 4613,
	HCLGE_OPC_FD_USER_DEF_OP = 4615,
	HCLGE_OPC_FD_QB_CTRL = 4624,
	HCLGE_OPC_FD_QB_AD_OP = 4625,
	HCLGE_OPC_MDIO_CONFIG = 6400,
	HCLGE_OPC_QCN_MOD_CFG = 6657,
	HCLGE_OPC_QCN_GRP_TMPLT_CFG = 6658,
	HCLGE_OPC_QCN_SHAPPING_CFG = 6659,
	HCLGE_OPC_QCN_SHAPPING_BS_CFG = 6660,
	HCLGE_OPC_QCN_QSET_LINK_CFG = 6661,
	HCLGE_OPC_QCN_RP_STATUS_GET = 6662,
	HCLGE_OPC_QCN_AJUST_INIT = 6663,
	HCLGE_OPC_QCN_DFX_CNT_STATUS = 6664,
	HCLGEVF_OPC_MBX_PF_TO_VF = 8192,
	HCLGEVF_OPC_MBX_VF_TO_PF = 8193,
	HCLGE_OPC_LED_STATUS_CFG = 45056,
	HCLGE_OPC_CLEAR_HW_RESOURCE = 28683,
	HCLGE_OPC_QUERY_NCL_CONFIG = 28689,
	HCLGE_OPC_IMP_STATS_BD = 28690,
	HCLGE_OPC_IMP_STATS_INFO = 28691,
	HCLGE_OPC_IMP_COMPAT_CFG = 28698,
	HCLGE_OPC_GET_SFP_EEPROM = 28928,
	HCLGE_OPC_GET_SFP_EXIST = 28929,
	HCLGE_OPC_GET_SFP_INFO = 28932,
	HCLGE_MAC_COMMON_INT_EN = 782,
	HCLGE_TM_SCH_ECC_INT_EN = 2089,
	HCLGE_SSU_ECC_INT_CMD = 2441,
	HCLGE_SSU_COMMON_INT_CMD = 2444,
	HCLGE_PPU_MPF_ECC_INT_CMD = 2880,
	HCLGE_PPU_MPF_OTHER_INT_CMD = 2881,
	HCLGE_PPU_PF_OTHER_INT_CMD = 2882,
	HCLGE_COMMON_ECC_INT_CFG = 5381,
	HCLGE_QUERY_RAS_INT_STS_BD_NUM = 5392,
	HCLGE_QUERY_CLEAR_MPF_RAS_INT = 5393,
	HCLGE_QUERY_CLEAR_PF_RAS_INT = 5394,
	HCLGE_QUERY_MSIX_INT_STS_BD_NUM = 5395,
	HCLGE_QUERY_CLEAR_ALL_MPF_MSIX_INT = 5396,
	HCLGE_QUERY_CLEAR_ALL_PF_MSIX_INT = 5397,
	HCLGE_QUERY_ALL_ERR_BD_NUM = 5398,
	HCLGE_QUERY_ALL_ERR_INFO = 5399,
	HCLGE_CONFIG_ROCEE_RAS_INT_EN = 5504,
	HCLGE_QUERY_CLEAR_ROCEE_RAS_INT = 5505,
	HCLGE_ROCEE_PF_RAS_INT_CMD = 5508,
	HCLGE_QUERY_ROCEE_ECC_RAS_INFO_CMD = 5509,
	HCLGE_QUERY_ROCEE_AXI_RAS_INFO_CMD = 5510,
	HCLGE_IGU_EGU_TNL_INT_EN = 6147,
	HCLGE_IGU_COMMON_INT_EN = 6150,
	HCLGE_TM_QCN_MEM_INT_CFG = 6676,
	HCLGE_PPP_CMD0_INT_CMD = 8448,
	HCLGE_PPP_CMD1_INT_CMD = 8449,
	HCLGE_MAC_ETHERTYPE_IDX_RD = 8453,
	HCLGE_OPC_WOL_GET_SUPPORTED_MODE = 8705,
	HCLGE_OPC_WOL_CFG = 8706,
	HCLGE_NCSI_INT_EN = 9217,
	HCLGE_OPC_MAC_ADDR_CHECK = 36868,
	HCLGE_OPC_PHY_LINK_KSETTING = 28709,
	HCLGE_OPC_PHY_REG = 28710,
	HCLGE_OPC_QUERY_LINK_DIAGNOSIS = 28714,
};

enum HCLGE_DEV_STATE {
	HCLGE_STATE_REINITING = 0,
	HCLGE_STATE_DOWN = 1,
	HCLGE_STATE_DISABLED = 2,
	HCLGE_STATE_REMOVING = 3,
	HCLGE_STATE_NIC_REGISTERED = 4,
	HCLGE_STATE_ROCE_REGISTERED = 5,
	HCLGE_STATE_SERVICE_INITED = 6,
	HCLGE_STATE_RST_SERVICE_SCHED = 7,
	HCLGE_STATE_RST_HANDLING = 8,
	HCLGE_STATE_MBX_SERVICE_SCHED = 9,
	HCLGE_STATE_MBX_HANDLING = 10,
	HCLGE_STATE_ERR_SERVICE_SCHED = 11,
	HCLGE_STATE_STATISTICS_UPDATING = 12,
	HCLGE_STATE_LINK_UPDATING = 13,
	HCLGE_STATE_RST_FAIL = 14,
	HCLGE_STATE_FD_TBL_CHANGED = 15,
	HCLGE_STATE_FD_CLEAR_ALL = 16,
	HCLGE_STATE_FD_USER_DEF_CHANGED = 17,
	HCLGE_STATE_PTP_EN = 18,
	HCLGE_STATE_PTP_TX_HANDLING = 19,
	HCLGE_STATE_FEC_STATS_UPDATING = 20,
	HCLGE_STATE_MAX = 21,
};

struct hclge_query_ppu_pf_other_int_dfx_cmd {
	__le16 over_8bd_no_fe_qid;
	__le16 over_8bd_no_fe_vf_id;
	__le16 tso_mss_cmp_min_err_qid;
	__le16 tso_mss_cmp_min_err_vf_id;
	__le16 tso_mss_cmp_max_err_qid;
	__le16 tso_mss_cmp_max_err_vf_id;
	__le16 tx_rd_fbd_poison_qid;
	__le16 tx_rd_fbd_poison_vf_id;
	__le16 rx_rd_fbd_poison_qid;
	__le16 rx_rd_fbd_poison_vf_id;
	u8 rsv[4];
};

struct hclge_sum_err_info {
	u8 reset_type;
	u8 mod_num;
	u8 rsv[2];
};

struct hclge_mod_err_info {
	u8 mod_id;
	u8 err_num;
	u8 rsv[2];
};

struct hclge_type_reg_err_info {
	u8 type_id;
	u8 reg_num;
	u8 rsv[2];
	u32 hclge_reg[256];
};

enum ring_id {
	NETSEC_RING_TX = 0,
	NETSEC_RING_RX = 1,
};

enum buf_type {
	TYPE_NETSEC_SKB = 0,
	TYPE_NETSEC_XDP_TX = 1,
	TYPE_NETSEC_XDP_NDO = 2,
};

struct netsec_desc;

struct netsec_desc_ring {
	dma_addr_t desc_dma;
	struct netsec_desc *desc;
	void *vaddr;
	u16 head;
	u16 tail;
	u16 xdp_xmit;
	struct page_pool *page_pool;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netsec_priv {
	struct netsec_desc_ring desc_ring[2];
	struct ethtool_coalesce et_coalesce;
	struct bpf_prog *xdp_prog;
	spinlock_t reglock;
	struct napi_struct napi;
	phy_interface_t phy_interface;
	struct net_device *ndev;
	struct device_node *phy_np;
	struct phy_device *phydev;
	struct mii_bus *mii_bus;
	void *ioaddr;
	void *eeprom_base;
	struct device *dev;
	struct clk *clk;
	u32 msg_enable;
	u32 freq;
	u32 phy_addr;
	bool rx_cksum_offload_flag;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netsec_desc {
	union {
		struct sk_buff *skb;
		struct xdp_frame *xdpf;
	};
	dma_addr_t dma_addr;
	void *addr;
	u16 len;
	u8 buf_type;
};

struct xdp_frame_bulk {
	int count;
	void *xa;
	void *q[16];
};

struct netsec_de {
	u32 attr;
	u32 data_buf_addr_up;
	u32 data_buf_addr_lw;
	u32 buf_len_info;
};

struct netsec_rx_pkt_info {
	int rx_cksum_result;
	int err_code;
	bool err_flag;
};

struct netsec_tx_pkt_ctrl {
	u16 tcp_seg_len;
	bool tcp_seg_offload_flag;
	bool cksum_offload_flag;
};

struct mu3h_sch_bw_info;

struct mu3h_sch_tt;

struct mu3h_sch_ep_info {
	u32 esit;
	u32 num_esit;
	u32 num_budget_microframes;
	struct list_head endpoint;
	struct hlist_node hentry;
	struct list_head tt_endpoint;
	struct mu3h_sch_bw_info *bw_info;
	struct mu3h_sch_tt *sch_tt;
	u32 ep_type;
	u32 maxpkt;
	struct usb_host_endpoint *ep;
	enum usb_device_speed speed;
	bool allocated;
	u32 offset;
	u32 repeat;
	u32 pkts;
	u32 cs_count;
	u32 burst_mode;
	u32 bw_budget_table[0];
};

struct mu3h_sch_bw_info {
	u32 bus_bw[64];
};

struct mu3h_sch_tt {
	u16 fs_bus_bw_out[64];
	u16 fs_bus_bw_in[64];
	u8 ls_bus_bw[64];
	u16 fs_frame_bw[8];
	u8 in_ss_cnt[64];
	struct list_head ep_list;
};

struct mu3c_ippc_regs;

struct xhci_hcd_mtk {
	struct device *dev;
	struct usb_hcd *hcd;
	struct mu3h_sch_bw_info *sch_array;
	struct list_head bw_ep_chk_list;
	struct hlist_head sch_ep_hash[32];
	struct mu3c_ippc_regs *ippc_regs;
	int num_u2_ports;
	int num_u3_ports;
	int u2p_dis_msk;
	int u3p_dis_msk;
	struct clk_bulk_data clks[6];
	struct regulator_bulk_data supplies[2];
	unsigned int has_ippc: 1;
	unsigned int lpm_support: 1;
	unsigned int u2_lpm_disable: 1;
	unsigned int uwk_en: 1;
	struct regmap *uwk;
	u32 uwk_reg_base;
	u32 uwk_vers;
	u32 rxfifo_depth;
};

struct mu3c_ippc_regs {
	__le32 ip_pw_ctr0;
	__le32 ip_pw_ctr1;
	__le32 ip_pw_ctr2;
	__le32 ip_pw_ctr3;
	__le32 ip_pw_sts1;
	__le32 ip_pw_sts2;
	__le32 reserved0[3];
	__le32 ip_xhci_cap;
	__le32 reserved1[2];
	__le64 u3_ctrl_p[4];
	__le64 u2_ctrl_p[5];
	__le32 reserved2;
	__le32 u2_phy_pll;
	__le32 reserved3[33];
};

struct amba_kmi_port {
	struct serio *io;
	struct clk *clk;
	void *base;
	unsigned int irq;
	unsigned int divisor;
	unsigned int open;
};

struct psmouse_smbus_dev {
	struct i2c_board_info board;
	struct psmouse *psmouse;
	struct i2c_client *client;
	struct list_head node;
	bool dead;
	bool need_deactivate;
};

struct psmouse_smbus_removal_work {
	struct work_struct work;
	struct i2c_client *client;
};

struct i2c_algo_bit_data {
	void *data;
	void (*setsda)(void *, int);
	void (*setscl)(void *, int);
	int (*getsda)(void *);
	int (*getscl)(void *);
	int (*pre_xfer)(struct i2c_adapter *);
	void (*post_xfer)(struct i2c_adapter *);
	int udelay;
	int timeout;
	bool can_do_atomic;
};

struct qup_i2c_block {
	int count;
	int pos;
	int tx_tag_len;
	int rx_tag_len;
	int data_len;
	int cur_blk_len;
	int total_tx_len;
	int total_rx_len;
	int tx_fifo_data_pos;
	int tx_fifo_free;
	int rx_fifo_data_pos;
	int fifo_available;
	u32 tx_fifo_data;
	u32 rx_fifo_data;
	u8 *cur_data;
	u8 *cur_tx_tags;
	bool tx_tags_sent;
	bool send_last_word;
	bool rx_tags_fetched;
	bool rx_bytes_read;
	bool is_tx_blk_mode;
	bool is_rx_blk_mode;
	u8 tags[6];
};

struct qup_i2c_tag {
	u8 *start;
	dma_addr_t addr;
};

struct qup_i2c_bam {
	struct qup_i2c_tag tag;
	struct dma_chan *dma;
	struct scatterlist *sg;
	unsigned int sg_cnt;
};

struct qup_i2c_dev {
	struct device *dev;
	void *base;
	int irq;
	struct clk *clk;
	struct clk *pclk;
	struct i2c_adapter adap;
	int clk_ctl;
	int out_fifo_sz;
	int in_fifo_sz;
	int out_blk_sz;
	int in_blk_sz;
	int blk_xfer_limit;
	unsigned long one_byte_t;
	unsigned long xfer_timeout;
	struct qup_i2c_block blk;
	struct i2c_msg *msg;
	int pos;
	u32 bus_err;
	u32 qup_err;
	bool is_last;
	bool is_smbus_read;
	u32 config_run;
	bool is_dma;
	bool use_dma;
	unsigned int max_xfer_sg_len;
	unsigned int tag_buf_pos;
	unsigned int blk_mode_threshold;
	struct dma_pool *dpool;
	struct qup_i2c_tag start_tag;
	struct qup_i2c_bam brx;
	struct qup_i2c_bam btx;
	struct completion xfer;
	void (*write_tx_fifo)(struct qup_i2c_dev *);
	void (*read_rx_fifo)(struct qup_i2c_dev *);
	void (*write_rx_tags)(struct qup_i2c_dev *);
};

struct npcm_wdt {
	struct watchdog_device wdd;
	void *reg;
	struct clk *clk;
};

enum opp_table_access {
	OPP_TABLE_ACCESS_UNKNOWN = 0,
	OPP_TABLE_ACCESS_EXCLUSIVE = 1,
	OPP_TABLE_ACCESS_SHARED = 2,
};

enum dev_pm_opp_event {
	OPP_EVENT_ADD = 0,
	OPP_EVENT_REMOVE = 1,
	OPP_EVENT_ENABLE = 2,
	OPP_EVENT_DISABLE = 3,
	OPP_EVENT_ADJUST_VOLTAGE = 4,
};

struct dev_pm_opp_icc_bw;

struct dev_pm_opp {
	struct list_head node;
	struct kref kref;
	bool available;
	bool dynamic;
	bool turbo;
	bool suspend;
	bool removed;
	unsigned long *rates;
	unsigned int level;
	struct dev_pm_opp_supply *supplies;
	struct dev_pm_opp_icc_bw *bandwidth;
	unsigned long clock_latency_ns;
	struct dev_pm_opp **required_opps;
	struct opp_table *opp_table;
	struct device_node *np;
	struct dentry *dentry;
	const char *of_name;
};

struct dev_pm_opp_icc_bw {
	u32 avg;
	u32 peak;
};

struct opp_table {
	struct list_head node;
	struct list_head lazy;
	struct blocking_notifier_head head;
	struct list_head dev_list;
	struct list_head opp_list;
	struct kref kref;
	struct mutex lock;
	struct device_node *np;
	unsigned long clock_latency_ns_max;
	unsigned int voltage_tolerance_v1;
	unsigned int parsed_static_opps;
	enum opp_table_access shared_opp;
	unsigned long rate_clk_single;
	struct dev_pm_opp *current_opp;
	struct dev_pm_opp *suspend_opp;
	struct device **genpd_virt_devs;
	struct opp_table **required_opp_tables;
	unsigned int required_opp_count;
	unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char *prop_name;
	config_clks_t config_clks;
	struct clk **clks;
	struct clk *clk;
	int clk_count;
	config_regulators_t config_regulators;
	struct regulator **regulators;
	int regulator_count;
	struct icc_path **paths;
	unsigned int path_count;
	bool enabled;
	bool is_genpd;
	int (*set_required_opps)(struct device *, struct opp_table *, struct dev_pm_opp *, bool);
	struct dentry *dentry;
	char dentry_name[255];
};

struct opp_device {
	struct list_head node;
	const struct device *dev;
	struct dentry *dentry;
};

struct opp_config_data {
	struct opp_table *opp_table;
	unsigned int flags;
};

typedef void (*btf_trace_mmc_request_start)(void *, struct mmc_host *, struct mmc_request *);

typedef void (*btf_trace_mmc_request_done)(void *, struct mmc_host *, struct mmc_request *);

enum mmc_busy_cmd {
	MMC_BUSY_CMD6 = 0,
	MMC_BUSY_ERASE = 1,
	MMC_BUSY_HPI = 2,
	MMC_BUSY_EXTR_SINGLE = 3,
	MMC_BUSY_IO = 4,
};

enum mmc_err_stat {
	MMC_ERR_CMD_TIMEOUT = 0,
	MMC_ERR_CMD_CRC = 1,
	MMC_ERR_DAT_TIMEOUT = 2,
	MMC_ERR_DAT_CRC = 3,
	MMC_ERR_AUTO_CMD = 4,
	MMC_ERR_ADMA = 5,
	MMC_ERR_TUNING = 6,
	MMC_ERR_CMDQ_RED = 7,
	MMC_ERR_CMDQ_GCE = 8,
	MMC_ERR_CMDQ_ICCE = 9,
	MMC_ERR_REQ_TIMEOUT = 10,
	MMC_ERR_CMDQ_REQ_TIMEOUT = 11,
	MMC_ERR_ICE_CFG = 12,
	MMC_ERR_CTRL_TIMEOUT = 13,
	MMC_ERR_UNEXPECTED_IRQ = 14,
	MMC_ERR_MAX = 15,
};

struct trace_event_raw_mmc_request_start {
	struct trace_entry ent;
	u32 cmd_opcode;
	u32 cmd_arg;
	unsigned int cmd_flags;
	unsigned int cmd_retries;
	u32 stop_opcode;
	u32 stop_arg;
	unsigned int stop_flags;
	unsigned int stop_retries;
	u32 sbc_opcode;
	u32 sbc_arg;
	unsigned int sbc_flags;
	unsigned int sbc_retries;
	unsigned int blocks;
	unsigned int blk_addr;
	unsigned int blksz;
	unsigned int data_flags;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mmc_request_done {
	struct trace_entry ent;
	u32 cmd_opcode;
	int cmd_err;
	u32 cmd_resp[4];
	unsigned int cmd_retries;
	u32 stop_opcode;
	int stop_err;
	u32 stop_resp[4];
	unsigned int stop_retries;
	u32 sbc_opcode;
	int sbc_err;
	u32 sbc_resp[4];
	unsigned int sbc_retries;
	unsigned int bytes_xfered;
	int data_err;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_mmc_request_start {
	u32 name;
};

struct trace_event_data_offsets_mmc_request_done {
	u32 name;
};

struct bcm2835_host {
	spinlock_t lock;
	struct mutex mutex;
	void *ioaddr;
	u32 phys_addr;
	struct platform_device *pdev;
	int clock;
	unsigned int max_clk;
	struct work_struct dma_work;
	struct delayed_work timeout_work;
	struct sg_mapping_iter sg_miter;
	unsigned int blocks;
	int irq;
	u32 ns_per_fifo_word;
	u32 hcfg;
	u32 cdiv;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
	bool data_complete: 1;
	bool use_busy: 1;
	bool use_sbc: 1;
	bool irq_block;
	bool irq_busy;
	bool irq_data;
	struct dma_chan *dma_chan_rxtx;
	struct dma_chan *dma_chan;
	struct dma_slave_config dma_cfg_rx;
	struct dma_slave_config dma_cfg_tx;
	struct dma_async_tx_descriptor *dma_desc;
	u32 dma_dir;
	u32 drain_words;
	struct page *drain_page;
	u32 drain_offset;
	bool use_dma;
};

enum ufs_dev_pwr_mode {
	UFS_ACTIVE_PWR_MODE = 1,
	UFS_SLEEP_PWR_MODE = 2,
	UFS_POWERDOWN_PWR_MODE = 3,
	UFS_DEEPSLEEP_PWR_MODE = 4,
};

enum uic_link_state {
	UIC_LINK_OFF_STATE = 0,
	UIC_LINK_ACTIVE_STATE = 1,
	UIC_LINK_HIBERN8_STATE = 2,
	UIC_LINK_BROKEN_STATE = 3,
};

enum ufs_pm_level {
	UFS_PM_LVL_0 = 0,
	UFS_PM_LVL_1 = 1,
	UFS_PM_LVL_2 = 2,
	UFS_PM_LVL_3 = 3,
	UFS_PM_LVL_4 = 4,
	UFS_PM_LVL_5 = 5,
	UFS_PM_LVL_6 = 6,
	UFS_PM_LVL_MAX = 7,
};

enum ufs_notify_change_status {
	PRE_CHANGE = 0,
	POST_CHANGE = 1,
};

enum uic_cmd_dme {
	UIC_CMD_DME_GET = 1,
	UIC_CMD_DME_SET = 2,
	UIC_CMD_DME_PEER_GET = 3,
	UIC_CMD_DME_PEER_SET = 4,
	UIC_CMD_DME_POWERON = 16,
	UIC_CMD_DME_POWEROFF = 17,
	UIC_CMD_DME_ENABLE = 18,
	UIC_CMD_DME_RESET = 20,
	UIC_CMD_DME_END_PT_RST = 21,
	UIC_CMD_DME_LINK_STARTUP = 22,
	UIC_CMD_DME_HIBER_ENTER = 23,
	UIC_CMD_DME_HIBER_EXIT = 24,
	UIC_CMD_DME_TEST_MODE = 26,
};

enum ufs_pm_op {
	UFS_RUNTIME_PM = 0,
	UFS_SYSTEM_PM = 1,
	UFS_SHUTDOWN_PM = 2,
};

enum devfreq_timer {
	DEVFREQ_TIMER_DEFERRABLE = 0,
	DEVFREQ_TIMER_DELAYED = 1,
	DEVFREQ_TIMER_NUM = 2,
};

enum ufs_event_type {
	UFS_EVT_PA_ERR = 0,
	UFS_EVT_DL_ERR = 1,
	UFS_EVT_NL_ERR = 2,
	UFS_EVT_TL_ERR = 3,
	UFS_EVT_DME_ERR = 4,
	UFS_EVT_AUTO_HIBERN8_ERR = 5,
	UFS_EVT_FATAL_ERR = 6,
	UFS_EVT_LINK_STARTUP_FAIL = 7,
	UFS_EVT_RESUME_ERR = 8,
	UFS_EVT_SUSPEND_ERR = 9,
	UFS_EVT_WL_SUSP_ERR = 10,
	UFS_EVT_WL_RES_ERR = 11,
	UFS_EVT_DEV_RESET = 12,
	UFS_EVT_HOST_RESET = 13,
	UFS_EVT_ABORT = 14,
	UFS_EVT_CNT = 15,
};

enum ufs_ref_clk_freq {
	REF_CLK_FREQ_19_2_MHZ = 0,
	REF_CLK_FREQ_26_MHZ = 1,
	REF_CLK_FREQ_38_4_MHZ = 2,
	REF_CLK_FREQ_52_MHZ = 3,
	REF_CLK_FREQ_INVAL = -1,
};

enum ufshcd_state {
	UFSHCD_STATE_RESET = 0,
	UFSHCD_STATE_OPERATIONAL = 1,
	UFSHCD_STATE_EH_SCHEDULED_NON_FATAL = 2,
	UFSHCD_STATE_EH_SCHEDULED_FATAL = 3,
	UFSHCD_STATE_ERROR = 4,
};

enum dev_cmd_type {
	DEV_CMD_TYPE_NOP = 0,
	DEV_CMD_TYPE_QUERY = 1,
	DEV_CMD_TYPE_RPMB = 2,
};

enum clk_gating_state {
	CLKS_OFF = 0,
	CLKS_ON = 1,
	REQ_CLKS_OFF = 2,
	REQ_CLKS_ON = 3,
};

enum bkops_status {
	BKOPS_STATUS_NO_OP = 0,
	BKOPS_STATUS_NON_CRITICAL = 1,
	BKOPS_STATUS_PERF_IMPACT = 2,
	BKOPS_STATUS_CRITICAL = 3,
	BKOPS_STATUS_MAX = 3,
};

enum query_opcode {
	UPIU_QUERY_OPCODE_NOP = 0,
	UPIU_QUERY_OPCODE_READ_DESC = 1,
	UPIU_QUERY_OPCODE_WRITE_DESC = 2,
	UPIU_QUERY_OPCODE_READ_ATTR = 3,
	UPIU_QUERY_OPCODE_WRITE_ATTR = 4,
	UPIU_QUERY_OPCODE_READ_FLAG = 5,
	UPIU_QUERY_OPCODE_SET_FLAG = 6,
	UPIU_QUERY_OPCODE_CLEAR_FLAG = 7,
	UPIU_QUERY_OPCODE_TOGGLE_FLAG = 8,
};

enum upiu_request_transaction {
	UPIU_TRANSACTION_NOP_OUT = 0,
	UPIU_TRANSACTION_COMMAND = 1,
	UPIU_TRANSACTION_DATA_OUT = 2,
	UPIU_TRANSACTION_TASK_REQ = 4,
	UPIU_TRANSACTION_QUERY_REQ = 22,
};

enum ufs_bsg_msg_code {
	UPIU_TRANSACTION_UIC_CMD = 31,
	UPIU_TRANSACTION_ARPMB_CMD = 32,
};

enum ufs_rpmb_op_type {
	UFS_RPMB_WRITE_KEY = 1,
	UFS_RPMB_READ_CNT = 2,
	UFS_RPMB_WRITE = 3,
	UFS_RPMB_READ = 4,
	UFS_RPMB_READ_RESP = 5,
	UFS_RPMB_SEC_CONF_WRITE = 6,
	UFS_RPMB_SEC_CONF_READ = 7,
	UFS_RPMB_PURGE_ENABLE = 8,
	UFS_RPMB_PURGE_STATUS_READ = 9,
};

struct ufs_event_hist {
	int pos;
	u32 val[8];
	u64 tstamp[8];
	unsigned long long cnt;
};

struct ufs_stats {
	u32 last_intr_status;
	u64 last_intr_ts;
	u32 hibern8_exit_cnt;
	u64 last_hibern8_exit_tstamp;
	struct ufs_event_hist event[15];
};

struct utp_upiu_query {
	__u8 opcode;
	__u8 idn;
	__u8 index;
	__u8 selector;
	__be16 reserved_osf;
	__be16 length;
	__be32 value;
	__be32 reserved[2];
};

struct ufs_query_req {
	u8 query_func;
	struct utp_upiu_query upiu_req;
};

struct ufs_query_res {
	struct utp_upiu_query upiu_res;
};

struct ufs_query {
	struct ufs_query_req request;
	u8 *descriptor;
	struct ufs_query_res response;
};

struct ufs_dev_cmd {
	enum dev_cmd_type type;
	struct mutex lock;
	struct completion *complete;
	struct ufs_query query;
};

struct ufs_dev_info {
	bool f_power_on_wp_en;
	bool is_lu_power_on_wp;
	u8 max_lu_supported;
	u16 wmanufacturerid;
	u8 *model;
	u16 wspecversion;
	u32 clk_gating_wait_us;
	u8 bqueuedepth;
	bool wb_enabled;
	bool wb_buf_flush_enabled;
	u8 wb_dedicated_lu;
	u8 wb_buffer_type;
	bool b_rpm_dev_flush_capable;
	u8 b_presrv_uspc_en;
	bool b_advanced_rpmb_en;
	bool b_ext_iid_en;
};

struct ufs_vreg;

struct ufs_vreg_info {
	struct ufs_vreg *vcc;
	struct ufs_vreg *vccq;
	struct ufs_vreg *vccq2;
	struct ufs_vreg *vdd_hba;
};

struct ufs_pa_layer_attr {
	u32 gear_rx;
	u32 gear_tx;
	u32 lane_rx;
	u32 lane_tx;
	u32 pwr_rx;
	u32 pwr_tx;
	u32 hs_rate;
};

struct ufs_pwr_mode_info {
	bool is_valid;
	struct ufs_pa_layer_attr info;
};

struct ufs_clk_gating {
	struct delayed_work gate_work;
	struct work_struct ungate_work;
	enum clk_gating_state state;
	unsigned long delay_ms;
	bool is_suspended;
	struct device_attribute delay_attr;
	struct device_attribute enable_attr;
	bool is_enabled;
	bool is_initialized;
	int active_reqs;
	struct workqueue_struct *clk_gating_workq;
};

struct ufs_clk_scaling {
	int active_reqs;
	unsigned long tot_busy_t;
	ktime_t window_start_t;
	ktime_t busy_start_t;
	struct device_attribute enable_attr;
	struct ufs_pa_layer_attr saved_pwr_info;
	struct workqueue_struct *workq;
	struct work_struct suspend_work;
	struct work_struct resume_work;
	unsigned long target_freq;
	u32 min_gear;
	bool is_enabled;
	bool is_allowed;
	bool is_initialized;
	bool is_busy_started;
	bool is_suspended;
};

struct ufs_hba_monitor {
	unsigned long chunk_size;
	unsigned long nr_sec_rw[2];
	ktime_t total_busy[2];
	unsigned long nr_req[2];
	ktime_t lat_sum[2];
	ktime_t lat_max[2];
	ktime_t lat_min[2];
	u32 nr_queued[2];
	ktime_t busy_start_ts[2];
	ktime_t enabled_ts;
	bool enabled;
};

struct ufshcd_res_info {
	const char *name;
	struct resource *resource;
	void *base;
};

struct ufshcd_mcq_opr_info_t {
	unsigned long offset;
	unsigned long stride;
	void *base;
};

struct utp_transfer_cmd_desc;

struct utp_transfer_req_desc;

struct utp_task_req_desc;

struct ufshcd_lrb;

struct ufs_hba_variant_ops;

struct ufs_hba_variant_params;

struct uic_command;

struct devfreq;

struct ufs_hw_queue;

struct ufs_hba {
	void *mmio_base;
	struct utp_transfer_cmd_desc *ucdl_base_addr;
	struct utp_transfer_req_desc *utrdl_base_addr;
	struct utp_task_req_desc *utmrdl_base_addr;
	dma_addr_t ucdl_dma_addr;
	dma_addr_t utrdl_dma_addr;
	dma_addr_t utmrdl_dma_addr;
	struct Scsi_Host *host;
	struct device *dev;
	struct scsi_device *ufs_device_wlun;
	enum ufs_dev_pwr_mode curr_dev_pwr_mode;
	enum uic_link_state uic_link_state;
	enum ufs_pm_level rpm_lvl;
	enum ufs_pm_level spm_lvl;
	int pm_op_in_progress;
	u32 ahit;
	struct ufshcd_lrb *lrb;
	unsigned long outstanding_tasks;
	spinlock_t outstanding_lock;
	unsigned long outstanding_reqs;
	u32 capabilities;
	int nutrs;
	u32 mcq_capabilities;
	int nutmrs;
	u32 reserved_slot;
	u32 ufs_version;
	const struct ufs_hba_variant_ops *vops;
	struct ufs_hba_variant_params *vps;
	void *priv;
	unsigned int irq;
	bool is_irq_enabled;
	enum ufs_ref_clk_freq dev_ref_clk_freq;
	unsigned int quirks;
	unsigned int dev_quirks;
	struct blk_mq_tag_set tmf_tag_set;
	struct request_queue *tmf_queue;
	struct request **tmf_rqs;
	struct uic_command *active_uic_cmd;
	struct mutex uic_cmd_mutex;
	struct completion *uic_async_done;
	enum ufshcd_state ufshcd_state;
	u32 eh_flags;
	u32 intr_mask;
	u16 ee_ctrl_mask;
	u16 ee_drv_mask;
	u16 ee_usr_mask;
	struct mutex ee_ctrl_mutex;
	bool is_powered;
	bool shutting_down;
	struct semaphore host_sem;
	struct workqueue_struct *eh_wq;
	struct work_struct eh_work;
	struct work_struct eeh_work;
	u32 errors;
	u32 uic_error;
	u32 saved_err;
	u32 saved_uic_err;
	struct ufs_stats ufs_stats;
	bool force_reset;
	bool force_pmc;
	bool silence_err_logs;
	struct ufs_dev_cmd dev_cmd;
	ktime_t last_dme_cmd_tstamp;
	int nop_out_timeout;
	struct ufs_dev_info dev_info;
	bool auto_bkops_enabled;
	struct ufs_vreg_info vreg_info;
	struct list_head clk_list_head;
	bool use_pm_opp;
	int req_abort_count;
	u32 lanes_per_direction;
	struct ufs_pa_layer_attr pwr_info;
	struct ufs_pwr_mode_info max_pwr_info;
	struct ufs_clk_gating clk_gating;
	u32 caps;
	struct devfreq *devfreq;
	struct ufs_clk_scaling clk_scaling;
	bool system_suspending;
	bool is_sys_suspended;
	enum bkops_status urgent_bkops_lvl;
	bool is_urgent_bkops_lvl_checked;
	struct mutex wb_mutex;
	struct rw_semaphore clk_scaling_lock;
	atomic_t scsi_block_reqs_cnt;
	struct device bsg_dev;
	struct request_queue *bsg_queue;
	struct delayed_work rpm_dev_flush_recheck_work;
	struct ufs_hba_monitor monitor;
	struct dentry *debugfs_root;
	struct delayed_work debugfs_ee_work;
	u32 debugfs_ee_rate_limit_ms;
	u32 luns_avail;
	unsigned int nr_hw_queues;
	unsigned int nr_queues[3];
	bool complete_put;
	bool ext_iid_sup;
	bool scsi_host_added;
	bool mcq_sup;
	bool mcq_enabled;
	struct ufshcd_res_info res[7];
	void *mcq_base;
	struct ufs_hw_queue *uhq;
	struct ufs_hw_queue *dev_cmd_queue;
	struct ufshcd_mcq_opr_info_t mcq_opr[4];
};

struct utp_transfer_cmd_desc {
	u8 command_upiu[512];
	u8 response_upiu[512];
	u8 prd_table[0];
};

struct request_desc_header {
	u8 cci;
	u8 ehs_length;
	u8 reserved2: 7;
	u8 enable_crypto: 1;
	u8 interrupt: 1;
	u8 data_direction: 2;
	u8 reserved1: 1;
	u8 command_type: 4;
	__le32 dunl;
	u8 ocs;
	u8 cds;
	__le16 ldbc;
	__le32 dunu;
};

struct utp_transfer_req_desc {
	struct request_desc_header header;
	__le64 command_desc_base_addr;
	__le16 response_upiu_length;
	__le16 response_upiu_offset;
	__le16 prd_table_length;
	__le16 prd_table_offset;
};

struct utp_upiu_header {
	union {
		struct {
			__be32 dword_0;
			__be32 dword_1;
			__be32 dword_2;
		};
		struct {
			__u8 transaction_code;
			__u8 flags;
			__u8 lun;
			__u8 task_tag;
			__u8 command_set_type: 4;
			__u8 iid: 4;
			union {
				__u8 tm_function;
				__u8 query_function;
			};
			__u8 response;
			__u8 status;
			__u8 ehs_length;
			__u8 device_information;
			__be16 data_segment_length;
		};
	};
};

struct utp_task_req_desc {
	struct request_desc_header header;
	struct {
		struct utp_upiu_header req_header;
		__be32 input_param1;
		__be32 input_param2;
		__be32 input_param3;
		__be32 __reserved1[2];
	} upiu_req;
	struct {
		struct utp_upiu_header rsp_header;
		__be32 output_param1;
		__be32 output_param2;
		__be32 __reserved2[3];
	} upiu_rsp;
};

struct utp_upiu_req;

struct utp_upiu_rsp;

struct ufshcd_sg_entry;

struct ufshcd_lrb {
	struct utp_transfer_req_desc *utr_descriptor_ptr;
	struct utp_upiu_req *ucd_req_ptr;
	struct utp_upiu_rsp *ucd_rsp_ptr;
	struct ufshcd_sg_entry *ucd_prdt_ptr;
	dma_addr_t utrd_dma_addr;
	dma_addr_t ucd_req_dma_addr;
	dma_addr_t ucd_rsp_dma_addr;
	dma_addr_t ucd_prdt_dma_addr;
	struct scsi_cmnd *cmd;
	int scsi_status;
	int command_type;
	int task_tag;
	u8 lun;
	bool intr_cmd;
	ktime_t issue_time_stamp;
	u64 issue_time_stamp_local_clock;
	ktime_t compl_time_stamp;
	u64 compl_time_stamp_local_clock;
	bool req_abort_skip;
};

struct utp_upiu_cmd {
	__be32 exp_data_transfer_len;
	__u8 cdb[16];
};

struct utp_upiu_req {
	struct utp_upiu_header header;
	union {
		struct utp_upiu_cmd sc;
		struct utp_upiu_query qr;
		struct utp_upiu_query uc;
	};
};

struct utp_cmd_rsp {
	__be32 residual_transfer_count;
	__be32 reserved[4];
	__be16 sense_data_len;
	u8 sense_data[18];
};

struct utp_upiu_rsp {
	struct utp_upiu_header header;
	union {
		struct utp_cmd_rsp sr;
		struct utp_upiu_query qr;
	};
};

struct ufshcd_sg_entry {
	__le64 addr;
	__le32 reserved;
	__le32 size;
};

struct devfreq_dev_profile;

struct devfreq_simple_ondemand_data;

union ufs_crypto_cfg_entry;

struct ufs_hba_variant_ops {
	const char *name;
	int (*init)(struct ufs_hba *);
	void (*exit)(struct ufs_hba *);
	u32 (*get_ufs_hci_version)(struct ufs_hba *);
	int (*clk_scale_notify)(struct ufs_hba *, bool, enum ufs_notify_change_status);
	int (*setup_clocks)(struct ufs_hba *, bool, enum ufs_notify_change_status);
	int (*hce_enable_notify)(struct ufs_hba *, enum ufs_notify_change_status);
	int (*link_startup_notify)(struct ufs_hba *, enum ufs_notify_change_status);
	int (*pwr_change_notify)(struct ufs_hba *, enum ufs_notify_change_status, struct ufs_pa_layer_attr *, struct ufs_pa_layer_attr *);
	void (*setup_xfer_req)(struct ufs_hba *, int, bool);
	void (*setup_task_mgmt)(struct ufs_hba *, int, u8);
	void (*hibern8_notify)(struct ufs_hba *, enum uic_cmd_dme, enum ufs_notify_change_status);
	int (*apply_dev_quirks)(struct ufs_hba *);
	void (*fixup_dev_quirks)(struct ufs_hba *);
	int (*suspend)(struct ufs_hba *, enum ufs_pm_op, enum ufs_notify_change_status);
	int (*resume)(struct ufs_hba *, enum ufs_pm_op);
	void (*dbg_register_dump)(struct ufs_hba *);
	int (*phy_initialization)(struct ufs_hba *);
	int (*device_reset)(struct ufs_hba *);
	void (*config_scaling_param)(struct ufs_hba *, struct devfreq_dev_profile *, struct devfreq_simple_ondemand_data *);
	int (*program_key)(struct ufs_hba *, const union ufs_crypto_cfg_entry *, int);
	void (*event_notify)(struct ufs_hba *, enum ufs_event_type, void *);
	void (*reinit_notify)(struct ufs_hba *);
	int (*mcq_config_resource)(struct ufs_hba *);
	int (*get_hba_mac)(struct ufs_hba *);
	int (*op_runtime_config)(struct ufs_hba *);
	int (*get_outstanding_cqs)(struct ufs_hba *, unsigned long *);
	int (*config_esi)(struct ufs_hba *);
	void (*config_scsi_dev)(struct scsi_device *);
};

struct devfreq_dev_status;

struct devfreq_dev_profile {
	unsigned long initial_freq;
	unsigned int polling_ms;
	enum devfreq_timer timer;
	int (*target)(struct device *, unsigned long *, u32);
	int (*get_dev_status)(struct device *, struct devfreq_dev_status *);
	int (*get_cur_freq)(struct device *, unsigned long *);
	void (*exit)(struct device *);
	unsigned long *freq_table;
	unsigned int max_state;
	bool is_cooling_device;
};

struct devfreq_dev_status {
	unsigned long total_time;
	unsigned long busy_time;
	unsigned long current_frequency;
	void *private_data;
};

struct devfreq_simple_ondemand_data {
	unsigned int upthreshold;
	unsigned int downdifferential;
};

union ufs_crypto_cfg_entry {
	__le32 reg_val[32];
	struct {
		u8 crypto_key[64];
		u8 data_unit_size;
		u8 crypto_cap_idx;
		u8 reserved_1;
		u8 config_enable;
		u8 reserved_multi_host;
		u8 reserved_2;
		u8 vsb[2];
		u8 reserved_3[56];
	};
};

struct ufs_hba_variant_params {
	struct devfreq_dev_profile devfreq_profile;
	struct devfreq_simple_ondemand_data ondemand_data;
	u16 hba_enable_delay_us;
	u32 wb_flush_threshold;
};

struct uic_command {
	u32 command;
	u32 argument1;
	u32 argument2;
	u32 argument3;
	int cmd_active;
	struct completion done;
};

struct ufs_vreg {
	struct regulator *reg;
	const char *name;
	bool always_on;
	bool enabled;
	int max_uA;
};

struct devfreq_stats {
	unsigned int total_trans;
	unsigned int *trans_table;
	u64 *time_in_state;
	u64 last_update;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_usage srcuu;
	struct srcu_struct srcu;
	struct notifier_block __attribute__((btf_type_tag("rcu"))) *head;
};

struct devfreq_governor;

struct devfreq {
	struct list_head node;
	struct mutex lock;
	struct device dev;
	struct devfreq_dev_profile *profile;
	const struct devfreq_governor *governor;
	struct opp_table *opp_table;
	struct notifier_block nb;
	struct delayed_work work;
	unsigned long *freq_table;
	unsigned int max_state;
	unsigned long previous_freq;
	struct devfreq_dev_status last_status;
	void *data;
	void *governor_data;
	struct dev_pm_qos_request user_min_freq_req;
	struct dev_pm_qos_request user_max_freq_req;
	unsigned long scaling_min_freq;
	unsigned long scaling_max_freq;
	bool stop_polling;
	unsigned long suspend_freq;
	unsigned long resume_freq;
	atomic_t suspend_count;
	struct devfreq_stats stats;
	struct srcu_notifier_head transition_notifier_list;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct devfreq_governor {
	struct list_head node;
	const char name[16];
	const u64 attrs;
	const u64 flags;
	int (*get_target_freq)(struct devfreq *, unsigned long *);
	int (*event_handler)(struct devfreq *, unsigned int, void *);
};

struct cq_entry;

struct ufs_hw_queue {
	void *mcq_sq_head;
	void *mcq_sq_tail;
	void *mcq_cq_head;
	void *mcq_cq_tail;
	struct utp_transfer_req_desc *sqe_base_addr;
	dma_addr_t sqe_dma_addr;
	struct cq_entry *cqe_base_addr;
	dma_addr_t cqe_dma_addr;
	u32 max_entries;
	u32 id;
	u32 sq_tail_slot;
	spinlock_t sq_lock;
	u32 cq_tail_slot;
	u32 cq_head_slot;
	spinlock_t cq_lock;
	struct mutex sq_mutex;
};

struct cq_entry {
	__le64 command_desc_base_addr;
	__le16 response_upiu_length;
	__le16 response_upiu_offset;
	__le16 prd_table_length;
	__le16 prd_table_offset;
	__le32 status;
	__le32 reserved[3];
};

struct ufs_bsg_request {
	__u32 msgcode;
	struct utp_upiu_req upiu_req;
};

struct ufs_arpmb_meta {
	__be16 req_resp_type;
	__u8 nonce[16];
	__be32 write_counter;
	__be16 addr_lun;
	__be16 block_count;
	__be16 result;
} __attribute__((packed));

struct ufs_ehs {
	__u8 length;
	__u8 ehs_type;
	__be16 ehssub_type;
	struct ufs_arpmb_meta meta;
	__u8 mac_key[32];
};

struct ufs_rpmb_request {
	struct ufs_bsg_request bsg_request;
	struct ufs_ehs ehs_req;
};

struct ufs_bsg_reply {
	int result;
	__u32 reply_payload_rcv_len;
	struct utp_upiu_req upiu_rsp;
};

struct ufs_rpmb_reply {
	struct ufs_bsg_reply bsg_reply;
	struct ufs_ehs ehs_rsp;
};

enum rpi_firmware_property_status {
	RPI_FIRMWARE_STATUS_REQUEST = 0,
	RPI_FIRMWARE_STATUS_SUCCESS = 2147483648,
	RPI_FIRMWARE_STATUS_ERROR = 2147483649,
};

enum rpi_firmware_property_tag {
	RPI_FIRMWARE_PROPERTY_END = 0,
	RPI_FIRMWARE_GET_FIRMWARE_REVISION = 1,
	RPI_FIRMWARE_SET_CURSOR_INFO = 32784,
	RPI_FIRMWARE_SET_CURSOR_STATE = 32785,
	RPI_FIRMWARE_GET_BOARD_MODEL = 65537,
	RPI_FIRMWARE_GET_BOARD_REVISION = 65538,
	RPI_FIRMWARE_GET_BOARD_MAC_ADDRESS = 65539,
	RPI_FIRMWARE_GET_BOARD_SERIAL = 65540,
	RPI_FIRMWARE_GET_ARM_MEMORY = 65541,
	RPI_FIRMWARE_GET_VC_MEMORY = 65542,
	RPI_FIRMWARE_GET_CLOCKS = 65543,
	RPI_FIRMWARE_GET_POWER_STATE = 131073,
	RPI_FIRMWARE_GET_TIMING = 131074,
	RPI_FIRMWARE_SET_POWER_STATE = 163841,
	RPI_FIRMWARE_GET_CLOCK_STATE = 196609,
	RPI_FIRMWARE_GET_CLOCK_RATE = 196610,
	RPI_FIRMWARE_GET_VOLTAGE = 196611,
	RPI_FIRMWARE_GET_MAX_CLOCK_RATE = 196612,
	RPI_FIRMWARE_GET_MAX_VOLTAGE = 196613,
	RPI_FIRMWARE_GET_TEMPERATURE = 196614,
	RPI_FIRMWARE_GET_MIN_CLOCK_RATE = 196615,
	RPI_FIRMWARE_GET_MIN_VOLTAGE = 196616,
	RPI_FIRMWARE_GET_TURBO = 196617,
	RPI_FIRMWARE_GET_MAX_TEMPERATURE = 196618,
	RPI_FIRMWARE_GET_STC = 196619,
	RPI_FIRMWARE_ALLOCATE_MEMORY = 196620,
	RPI_FIRMWARE_LOCK_MEMORY = 196621,
	RPI_FIRMWARE_UNLOCK_MEMORY = 196622,
	RPI_FIRMWARE_RELEASE_MEMORY = 196623,
	RPI_FIRMWARE_EXECUTE_CODE = 196624,
	RPI_FIRMWARE_EXECUTE_QPU = 196625,
	RPI_FIRMWARE_SET_ENABLE_QPU = 196626,
	RPI_FIRMWARE_GET_DISPMANX_RESOURCE_MEM_HANDLE = 196628,
	RPI_FIRMWARE_GET_EDID_BLOCK = 196640,
	RPI_FIRMWARE_GET_CUSTOMER_OTP = 196641,
	RPI_FIRMWARE_GET_DOMAIN_STATE = 196656,
	RPI_FIRMWARE_GET_THROTTLED = 196678,
	RPI_FIRMWARE_GET_CLOCK_MEASURED = 196679,
	RPI_FIRMWARE_NOTIFY_REBOOT = 196680,
	RPI_FIRMWARE_SET_CLOCK_STATE = 229377,
	RPI_FIRMWARE_SET_CLOCK_RATE = 229378,
	RPI_FIRMWARE_SET_VOLTAGE = 229379,
	RPI_FIRMWARE_SET_TURBO = 229385,
	RPI_FIRMWARE_SET_CUSTOMER_OTP = 229409,
	RPI_FIRMWARE_SET_DOMAIN_STATE = 229424,
	RPI_FIRMWARE_GET_GPIO_STATE = 196673,
	RPI_FIRMWARE_SET_GPIO_STATE = 229441,
	RPI_FIRMWARE_SET_SDHOST_CLOCK = 229442,
	RPI_FIRMWARE_GET_GPIO_CONFIG = 196675,
	RPI_FIRMWARE_SET_GPIO_CONFIG = 229443,
	RPI_FIRMWARE_GET_PERIPH_REG = 196677,
	RPI_FIRMWARE_SET_PERIPH_REG = 229445,
	RPI_FIRMWARE_GET_POE_HAT_VAL = 196681,
	RPI_FIRMWARE_SET_POE_HAT_VAL = 196688,
	RPI_FIRMWARE_NOTIFY_XHCI_RESET = 196696,
	RPI_FIRMWARE_NOTIFY_DISPLAY_DONE = 196710,
	RPI_FIRMWARE_FRAMEBUFFER_ALLOCATE = 262145,
	RPI_FIRMWARE_FRAMEBUFFER_BLANK = 262146,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PHYSICAL_WIDTH_HEIGHT = 262147,
	RPI_FIRMWARE_FRAMEBUFFER_GET_VIRTUAL_WIDTH_HEIGHT = 262148,
	RPI_FIRMWARE_FRAMEBUFFER_GET_DEPTH = 262149,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PIXEL_ORDER = 262150,
	RPI_FIRMWARE_FRAMEBUFFER_GET_ALPHA_MODE = 262151,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PITCH = 262152,
	RPI_FIRMWARE_FRAMEBUFFER_GET_VIRTUAL_OFFSET = 262153,
	RPI_FIRMWARE_FRAMEBUFFER_GET_OVERSCAN = 262154,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PALETTE = 262155,
	RPI_FIRMWARE_FRAMEBUFFER_GET_TOUCHBUF = 262159,
	RPI_FIRMWARE_FRAMEBUFFER_GET_GPIOVIRTBUF = 262160,
	RPI_FIRMWARE_FRAMEBUFFER_RELEASE = 294913,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PHYSICAL_WIDTH_HEIGHT = 278531,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_WIDTH_HEIGHT = 278532,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_DEPTH = 278533,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PIXEL_ORDER = 278534,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_ALPHA_MODE = 278535,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_OFFSET = 278537,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_OVERSCAN = 278538,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PALETTE = 278539,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VSYNC = 278542,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PHYSICAL_WIDTH_HEIGHT = 294915,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_WIDTH_HEIGHT = 294916,
	RPI_FIRMWARE_FRAMEBUFFER_SET_DEPTH = 294917,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PIXEL_ORDER = 294918,
	RPI_FIRMWARE_FRAMEBUFFER_SET_ALPHA_MODE = 294919,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_OFFSET = 294921,
	RPI_FIRMWARE_FRAMEBUFFER_SET_OVERSCAN = 294922,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PALETTE = 294923,
	RPI_FIRMWARE_FRAMEBUFFER_SET_TOUCHBUF = 294943,
	RPI_FIRMWARE_FRAMEBUFFER_SET_GPIOVIRTBUF = 294944,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VSYNC = 294926,
	RPI_FIRMWARE_FRAMEBUFFER_SET_BACKLIGHT = 294927,
	RPI_FIRMWARE_VCHIQ_INIT = 294928,
	RPI_FIRMWARE_GET_COMMAND_LINE = 327681,
	RPI_FIRMWARE_GET_DMA_CHANNELS = 393217,
};

struct rpi_firmware {
	struct mbox_client cl;
	struct mbox_chan *chan;
	struct completion c;
	u32 enabled;
	struct kref consumers;
};

struct rpi_firmware_property_tag_header {
	u32 tag;
	u32 buf_size;
	u32 req_resp_size;
};

struct rpi_firmware_clk_rate_request {
	__le32 id;
	__le32 rate;
};

typedef struct {
	u32 version;
	u32 num_entries;
	u32 desc_size;
	u32 flags;
	efi_memory_desc_t entry[0];
} efi_memory_attributes_table_t;

typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *, bool);

struct lg_drv_data {
	unsigned long quirks;
	void *device_props;
};

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan *, void *);
	int (*flush)(struct mbox_chan *, unsigned long);
	int (*startup)(struct mbox_chan *);
	void (*shutdown)(struct mbox_chan *);
	bool (*last_tx_done)(struct mbox_chan *);
	bool (*peek_data)(struct mbox_chan *);
};

struct mbox_controller;

struct mbox_chan {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	struct hrtimer poll_hrt;
	spinlock_t poll_hrt_lock;
	struct list_head node;
};

struct zynqmp_ipi_mchan {
	int is_opened;
	void *req_buf;
	void *resp_buf;
	void *rx_buf;
	size_t req_buf_size;
	size_t resp_buf_size;
	unsigned int chan_type;
};

struct zynqmp_ipi_pdata;

struct zynqmp_ipi_mbox {
	struct zynqmp_ipi_pdata *pdata;
	struct device dev;
	u32 remote_id;
	struct mbox_controller mbox;
	struct zynqmp_ipi_mchan mchans[2];
};

struct zynqmp_ipi_pdata {
	struct device *dev;
	int irq;
	unsigned int method;
	u32 local_id;
	int num_mboxes;
	struct zynqmp_ipi_mbox ipi_mboxes[0];
};

struct zynqmp_ipi_message {
	size_t len;
	u8 data[0];
};

struct userspace_data {
	unsigned long user_frequency;
	bool valid;
};

struct brcmstb_memc_data {
	u32 srpd_offset;
};

struct brcmstb_memc {
	struct device *dev;
	void *ddr_ctrl;
	unsigned int timeout_cycles;
	u32 frequency;
	u32 srpd_offset;
};

enum perf_event_task_context {
	perf_invalid_context = -1,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

struct sunxi_sid_cfg {
	u32 value_offset;
	u32 size;
	bool need_register_readout;
};

struct sunxi_sid {
	void *base;
	u32 value_offset;
};

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	__RTA_MAX = 31,
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	IFLA_PARENT_DEV_NAME = 56,
	IFLA_PARENT_DEV_BUS_NAME = 57,
	IFLA_GRO_MAX_SIZE = 58,
	IFLA_TSO_MAX_SIZE = 59,
	IFLA_TSO_MAX_SEGS = 60,
	IFLA_ALLMULTI = 61,
	IFLA_DEVLINK_PORT = 62,
	IFLA_GSO_IPV4_MAX_SIZE = 63,
	IFLA_GRO_IPV4_MAX_SIZE = 64,
	IFLA_DPLL_PIN = 65,
	__IFLA_MAX = 66,
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	NDA_FLAGS_EXT = 15,
	NDA_NDM_STATE_MASK = 16,
	NDA_NDM_FLAGS_MASK = 17,
	__NDA_MAX = 18,
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	IFLA_BRIDGE_CFM = 5,
	IFLA_BRIDGE_MST = 6,
	__IFLA_BRIDGE_MAX = 7,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT = 37,
	IFLA_BRPORT_MCAST_EHT_HOSTS_CNT = 38,
	IFLA_BRPORT_LOCKED = 39,
	IFLA_BRPORT_MAB = 40,
	IFLA_BRPORT_MCAST_N_GROUPS = 41,
	IFLA_BRPORT_MCAST_MAX_GROUPS = 42,
	IFLA_BRPORT_NEIGH_VLAN_SUPPRESS = 43,
	IFLA_BRPORT_BACKUP_NHID = 44,
	__IFLA_BRPORT_MAX = 45,
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO = 2,
	IFLA_OFFLOAD_XSTATS_L3_STATS = 3,
	__IFLA_OFFLOAD_XSTATS_MAX = 4,
};

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
	RTNL_FLAG_BULK_DEL_SUPPORTED = 2,
};

enum rtnl_kinds {
	RTNL_KIND_NEW = 0,
	RTNL_KIND_DEL = 1,
	RTNL_KIND_GET = 2,
	RTNL_KIND_SET = 3,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum netdev_offload_xstats_type {
	NETDEV_OFFLOAD_XSTATS_TYPE_L3 = 1,
};

enum {
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_REQUEST = 1,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_USED = 2,
	__IFLA_OFFLOAD_XSTATS_HW_S_INFO_MAX = 3,
};

enum {
	IFLA_STATS_GETSET_UNSPEC = 0,
	IFLA_STATS_GET_FILTERS = 1,
	IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS = 2,
	__IFLA_STATS_GETSET_MAX = 3,
};

enum {
	MDBA_GET_ENTRY_UNSPEC = 0,
	MDBA_GET_ENTRY = 1,
	MDBA_GET_ENTRY_ATTRS = 2,
	__MDBA_GET_ENTRY_MAX = 3,
};

enum {
	MDBA_SET_ENTRY_UNSPEC = 0,
	MDBA_SET_ENTRY = 1,
	MDBA_SET_ENTRY_ATTRS = 2,
	__MDBA_SET_ENTRY_MAX = 3,
};

struct rtnl_af_ops {
	struct list_head list;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*set_link_af)(struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

typedef __kernel_clock_t clock_t;

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	unsigned short ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

struct rtnl_offload_xstats_request_used {
	bool request;
	bool used;
};

struct rtnl_newlink_tbs {
	struct nlattr *tb[66];
	struct nlattr *attr[51];
	struct nlattr *slave_attr[45];
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

struct br_port_msg {
	__u8 family;
	__u32 ifindex;
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	struct mutex *cb_mutex;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	void (*release)(struct sock *, unsigned long *);
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	struct netlink_ext_ack *extack;
	void *data;
	struct module *module;
	u32 min_dump_alloc;
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

struct rtnl_stats_dump_filters {
	u32 mask[6];
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct rtnl_mdb_dump_ctx {
	long idx;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct br_mdb_entry {
	__u32 ifindex;
	__u8 state;
	__u8 flags;
	__u16 vid;
	struct {
		union {
			__be32 ip4;
			struct in6_addr ip6;
			unsigned char mac_addr[6];
		} u;
		__be16 proto;
	} addr;
};

struct update_classid_context {
	u32 classid;
	unsigned int batch;
};

struct psample_group {
	struct list_head list;
	struct net *net;
	u32 group_num;
	u32 refcount;
	u32 seq;
	struct callback_head rcu;
};

struct tcf_exts_miss_cookie_node {
	const struct tcf_chain *chain;
	const struct tcf_proto *tp;
	const struct tcf_exts *exts;
	u32 chain_index;
	u32 tp_prio;
	u32 handle;
	u32 miss_cookie_base;
	struct callback_head rcu;
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

enum {
	TCA_ACT_UNSPEC = 0,
	TCA_ACT_KIND = 1,
	TCA_ACT_OPTIONS = 2,
	TCA_ACT_INDEX = 3,
	TCA_ACT_STATS = 4,
	TCA_ACT_PAD = 5,
	TCA_ACT_COOKIE = 6,
	TCA_ACT_FLAGS = 7,
	TCA_ACT_HW_STATS = 8,
	TCA_ACT_USED_HW_STATS = 9,
	TCA_ACT_IN_HW_COUNT = 10,
	__TCA_ACT_MAX = 11,
};

enum net_xmit_qdisc_t {
	__NET_XMIT_STOLEN = 65536,
	__NET_XMIT_BYPASS = 131072,
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum pedit_header_type {
	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
	__PEDIT_HDR_TYPE_MAX = 6,
};

enum pedit_cmd {
	TCA_PEDIT_KEY_EX_CMD_SET = 0,
	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
	__PEDIT_CMD_MAX = 2,
};

enum qdisc_class_ops_flags {
	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

enum tcf_proto_ops_flags {
	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

struct tcf_block_owner_item {
	struct list_head list;
	struct Qdisc *q;
	enum flow_block_binder_type binder_type;
};

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);

struct tcf_filter_chain_list_item {
	struct list_head list;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
};

struct tc_pedit_key;

struct tcf_pedit_key_ex;

struct tcf_pedit_parms {
	struct tc_pedit_key *tcfp_keys;
	struct tcf_pedit_key_ex *tcfp_keys_ex;
	u32 tcfp_off_max_hint;
	unsigned char tcfp_nkeys;
	unsigned char tcfp_flags;
	struct callback_head rcu;
};

struct tc_pedit_key {
	__u32 mask;
	__u32 val;
	__u32 off;
	__u32 at;
	__u32 offmask;
	__u32 shift;
};

struct tcf_pedit_key_ex {
	enum pedit_header_type htype;
	enum pedit_cmd cmd;
};

struct tcf_pedit {
	struct tc_action common;
	struct tcf_pedit_parms __attribute__((btf_type_tag("rcu"))) *parms;
	long: 64;
};

struct tcf_block_ext_info {
	enum flow_block_binder_type binder_type;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
	u32 block_index;
};

struct tcf_net {
	spinlock_t idr_lock;
	struct idr idr;
};

struct action_gate_entry {
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
	struct list_head *cb_list_head;
};

struct tcf_chain_info {
	struct tcf_proto __attribute__((btf_type_tag("rcu"))) **pprev;
	struct tcf_proto __attribute__((btf_type_tag("rcu"))) *next;
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

struct tcf_dump_args {
	struct tcf_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct tcf_block *block;
	struct Qdisc *q;
	u32 parent;
	bool terse_dump;
};

struct tcf_qevent {
	struct tcf_block *block;
	struct tcf_block_ext_info info;
	struct tcf_proto __attribute__((btf_type_tag("rcu"))) *filter_chain;
};

enum {
	ETHTOOL_A_PLCA_UNSPEC = 0,
	ETHTOOL_A_PLCA_HEADER = 1,
	ETHTOOL_A_PLCA_VERSION = 2,
	ETHTOOL_A_PLCA_ENABLED = 3,
	ETHTOOL_A_PLCA_STATUS = 4,
	ETHTOOL_A_PLCA_NODE_CNT = 5,
	ETHTOOL_A_PLCA_NODE_ID = 6,
	ETHTOOL_A_PLCA_TO_TMR = 7,
	ETHTOOL_A_PLCA_BURST_CNT = 8,
	ETHTOOL_A_PLCA_BURST_TMR = 9,
	__ETHTOOL_A_PLCA_CNT = 10,
	ETHTOOL_A_PLCA_MAX = 9,
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	NLA_BE16 = 18,
	NLA_BE32 = 19,
	NLA_SINT = 20,
	NLA_UINT = 21,
	__NLA_TYPE_MAX = 22,
};

struct plca_reply_data {
	struct ethnl_reply_data base;
	struct phy_plca_cfg plca_cfg;
	struct phy_plca_status plca_st;
};

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_plca_cfg)(struct phy_device *, struct phy_plca_cfg *);
	int (*set_plca_cfg)(struct phy_device *, const struct phy_plca_cfg *, struct netlink_ext_ack *);
	int (*get_plca_status)(struct phy_device *, struct phy_plca_status *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct ping_table {
	struct hlist_head hash[64];
	spinlock_t lock;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

enum devlink_multicast_groups {
	DEVLINK_MCGRP_CONFIG = 0,
};

struct devlink_region_ops;

struct devlink_port_region_ops;

struct devlink_region {
	struct devlink *devlink;
	struct devlink_port *port;
	struct list_head list;
	union {
		const struct devlink_region_ops *ops;
		const struct devlink_port_region_ops *port_ops;
	};
	struct mutex snapshot_lock;
	struct list_head snapshot_list;
	u32 max_snapshots;
	u32 cur_snapshots;
	u64 size;
};

struct devlink_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u8 **);
	int (*read)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u64, u32, u8 *);
	void *priv;
};

struct devlink_port_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u8 **);
	int (*read)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u64, u32, u8 *);
	void *priv;
};

struct devlink_snapshot {
	struct list_head list;
	struct devlink_region *region;
	u8 *data;
	u32 id;
};

struct genl_dumpit_info {
	struct genl_split_ops op;
	struct genl_info info;
};

typedef int devlink_chunk_fill_t(void *, u8 *, u32, u64, struct netlink_ext_ack *);

struct unix_domain {
	struct auth_domain h;
};

struct unix_gid {
	struct cache_head h;
	kuid_t uid;
	struct group_info *gi;
	struct callback_head rcu;
};

struct ip_map {
	struct cache_head h;
	char m_class[8];
	struct in6_addr m_addr;
	struct unix_domain *m_client;
	struct callback_head m_rcu;
};

typedef s8 int8_t;

typedef void (*btf_trace_9p_client_req)(void *, struct p9_client *, int8_t, int);

typedef void (*btf_trace_9p_client_res)(void *, struct p9_client *, int8_t, int, int);

typedef void (*btf_trace_9p_protocol_dump)(void *, struct p9_client *, struct p9_fcall *);

typedef void (*btf_trace_9p_fid_ref)(void *, struct p9_fid *, __u8);

enum p9_proto_versions {
	p9_proto_legacy = 0,
	p9_proto_2000u = 1,
	p9_proto_2000L = 2,
};

enum p9_fid_reftype {
	P9_FID_REF_CREATE = 0,
	P9_FID_REF_GET = 1,
	P9_FID_REF_PUT = 2,
	P9_FID_REF_DESTROY = 3,
} __attribute__((mode(byte)));

enum p9_msg_t {
	P9_TLERROR = 6,
	P9_RLERROR = 7,
	P9_TSTATFS = 8,
	P9_RSTATFS = 9,
	P9_TLOPEN = 12,
	P9_RLOPEN = 13,
	P9_TLCREATE = 14,
	P9_RLCREATE = 15,
	P9_TSYMLINK = 16,
	P9_RSYMLINK = 17,
	P9_TMKNOD = 18,
	P9_RMKNOD = 19,
	P9_TRENAME = 20,
	P9_RRENAME = 21,
	P9_TREADLINK = 22,
	P9_RREADLINK = 23,
	P9_TGETATTR = 24,
	P9_RGETATTR = 25,
	P9_TSETATTR = 26,
	P9_RSETATTR = 27,
	P9_TXATTRWALK = 30,
	P9_RXATTRWALK = 31,
	P9_TXATTRCREATE = 32,
	P9_RXATTRCREATE = 33,
	P9_TREADDIR = 40,
	P9_RREADDIR = 41,
	P9_TFSYNC = 50,
	P9_RFSYNC = 51,
	P9_TLOCK = 52,
	P9_RLOCK = 53,
	P9_TGETLOCK = 54,
	P9_RGETLOCK = 55,
	P9_TLINK = 70,
	P9_RLINK = 71,
	P9_TMKDIR = 72,
	P9_RMKDIR = 73,
	P9_TRENAMEAT = 74,
	P9_RRENAMEAT = 75,
	P9_TUNLINKAT = 76,
	P9_RUNLINKAT = 77,
	P9_TVERSION = 100,
	P9_RVERSION = 101,
	P9_TAUTH = 102,
	P9_RAUTH = 103,
	P9_TATTACH = 104,
	P9_RATTACH = 105,
	P9_TERROR = 106,
	P9_RERROR = 107,
	P9_TFLUSH = 108,
	P9_RFLUSH = 109,
	P9_TWALK = 110,
	P9_RWALK = 111,
	P9_TOPEN = 112,
	P9_ROPEN = 113,
	P9_TCREATE = 114,
	P9_RCREATE = 115,
	P9_TREAD = 116,
	P9_RREAD = 117,
	P9_TWRITE = 118,
	P9_RWRITE = 119,
	P9_TCLUNK = 120,
	P9_RCLUNK = 121,
	P9_TREMOVE = 122,
	P9_RREMOVE = 123,
	P9_TSTAT = 124,
	P9_RSTAT = 125,
	P9_TWSTAT = 126,
	P9_RWSTAT = 127,
};

enum p9_open_mode_t {
	P9_OREAD = 0,
	P9_OWRITE = 1,
	P9_ORDWR = 2,
	P9_OEXEC = 3,
	P9_OTRUNC = 16,
	P9_OREXEC = 32,
	P9_ORCLOSE = 64,
	P9_OAPPEND = 128,
	P9_OEXCL = 4096,
	P9L_MODE_MASK = 8191,
	P9L_DIRECT = 8192,
	P9L_NOWRITECACHE = 16384,
	P9L_LOOSE = 32768,
};

enum {
	Opt_msize = 0,
	Opt_trans = 1,
	Opt_legacy = 2,
	Opt_version = 3,
	Opt_err___3 = 4,
};

enum p9_req_status_t {
	REQ_STATUS_ALLOC = 0,
	REQ_STATUS_UNSENT = 1,
	REQ_STATUS_SENT = 2,
	REQ_STATUS_RCVD = 3,
	REQ_STATUS_FLSHD = 4,
	REQ_STATUS_ERROR = 5,
};

struct trace_event_raw_9p_client_req {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	char __data[0];
};

struct trace_event_raw_9p_client_res {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	__u32 err;
	char __data[0];
};

struct trace_event_raw_9p_protocol_dump {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u16 tag;
	u32 __data_loc_line;
	char __data[0];
};

struct trace_event_raw_9p_fid_ref {
	struct trace_entry ent;
	int fid;
	int refcount;
	__u8 type;
	char __data[0];
};

struct trace_event_data_offsets_9p_protocol_dump {
	u32 line;
};

struct p9_wstat {
	u16 size;
	u16 type;
	u32 dev;
	struct p9_qid qid;
	u32 mode;
	u32 atime;
	u32 mtime;
	u64 length;
	const char *name;
	const char *uid;
	const char *gid;
	const char *muid;
	char *extension;
	kuid_t n_uid;
	kgid_t n_gid;
	kuid_t n_muid;
};

struct p9_stat_dotl {
	u64 st_result_mask;
	struct p9_qid qid;
	u32 st_mode;
	kuid_t st_uid;
	kgid_t st_gid;
	u64 st_nlink;
	u64 st_rdev;
	u64 st_size;
	u64 st_blksize;
	u64 st_blocks;
	u64 st_atime_sec;
	u64 st_atime_nsec;
	u64 st_mtime_sec;
	u64 st_mtime_nsec;
	u64 st_ctime_sec;
	u64 st_ctime_nsec;
	u64 st_btime_sec;
	u64 st_btime_nsec;
	u64 st_gen;
	u64 st_data_version;
};

struct trace_event_data_offsets_9p_client_req {};

struct trace_event_data_offsets_9p_client_res {};

struct trace_event_data_offsets_9p_fid_ref {};

struct p9_iattr_dotl {
	u32 valid;
	u32 mode;
	kuid_t uid;
	kgid_t gid;
	u64 size;
	u64 atime_sec;
	u64 atime_nsec;
	u64 mtime_sec;
	u64 mtime_nsec;
};

struct p9_rstatfs {
	u32 type;
	u32 bsize;
	u64 blocks;
	u64 bfree;
	u64 bavail;
	u64 files;
	u64 ffree;
	u64 fsid;
	u32 namelen;
};

struct p9_flock {
	u8 type;
	u32 flags;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_getlock {
	u8 type;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct word_at_a_time {
	const unsigned long one_bits;
	const unsigned long high_bits;
};

enum tcpa_event_types {
	PREBOOT = 0,
	POST_CODE = 1,
	UNUSED = 2,
	NO_ACTION = 3,
	SEPARATOR = 4,
	ACTION = 5,
	EVENT_TAG = 6,
	SCRTM_CONTENTS = 7,
	SCRTM_VERSION = 8,
	CPU_MICROCODE = 9,
	PLATFORM_CONFIG_FLAGS = 10,
	TABLE_OF_DEVICES = 11,
	COMPACT_HASH = 12,
	IPL = 13,
	IPL_PARTITION_DATA = 14,
	NONHOST_CODE = 15,
	NONHOST_CONFIG = 16,
	NONHOST_INFO = 17,
};

struct tcpa_event {
	u32 pcr_index;
	u32 event_type;
	u8 pcr_value[20];
	u32 event_size;
	u8 event_data[0];
};

struct tcg_pcr_event2_head {
	u32 pcr_idx;
	u32 event_type;
	u32 count;
	struct tpm_digest digests[0];
};

struct tcg_efi_specid_event_algs {
	u16 alg_id;
	u16 digest_size;
};

struct tcg_efi_specid_event_head {
	u8 signature[16];
	u32 platform_class;
	u8 spec_version_minor;
	u8 spec_version_major;
	u8 spec_errata;
	u8 uintnsize;
	u32 num_algs;
	struct tcg_efi_specid_event_algs digest_sizes[0];
};

struct tcg_event_field {
	u32 event_size;
	u8 event[0];
};

struct tcg_pcr_event {
	u32 pcr_idx;
	u32 event_type;
	u8 digest[20];
	u32 event_size;
	u8 event[0];
};

struct linux_efi_tpm_eventlog {
	u32 size;
	u32 final_events_preboot_size;
	u8 version;
	u8 log[0];
};

struct efi_tcg2_final_events_table {
	u64 version;
	u64 nr_events;
	u8 events[0];
};

typedef u32 efi_tcg2_event_log_format;

union efi_tcg2_protocol;

typedef union efi_tcg2_protocol efi_tcg2_protocol_t;

struct efi_tcg2_event;

typedef struct efi_tcg2_event efi_tcg2_event_t;

union efi_tcg2_protocol {
	struct {
		void *get_capability;
		efi_status_t (*get_event_log)(efi_tcg2_protocol_t *, efi_tcg2_event_log_format, efi_physical_addr_t *, efi_physical_addr_t *, efi_bool_t *);
		efi_status_t (*hash_log_extend_event)(efi_tcg2_protocol_t *, u64, efi_physical_addr_t, u64, const efi_tcg2_event_t *);
		void *submit_command;
		void *get_active_pcr_banks;
		void *set_active_pcr_banks;
		void *get_result_of_set_active_pcr_banks;
	};
	struct {
		u32 get_capability;
		u32 get_event_log;
		u32 hash_log_extend_event;
		u32 submit_command;
		u32 get_active_pcr_banks;
		u32 set_active_pcr_banks;
		u32 get_result_of_set_active_pcr_banks;
	} mixed_mode;
};

struct efi_tcg2_event {
	u32 event_size;
	struct {
		u32 header_size;
		u16 header_version;
		u32 pcr_index;
		u32 event_type;
	} __attribute__((packed)) event_header;
} __attribute__((packed));

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct dir_entry {
	struct list_head list;
	time64_t mtime;
	char name[0];
};

typedef int (*decompress_fn)(unsigned char *, long, long (*)(void *, unsigned long), long (*)(void *, unsigned long), unsigned char *, long *, void (*)(char *));

struct crash_mem {
	unsigned int max_nr_ranges;
	unsigned int nr_ranges;
	struct range ranges[0];
};

struct kexec_buf {
	struct kimage *image;
	void *buffer;
	unsigned long bufsz;
	unsigned long mem;
	unsigned long memsz;
	unsigned long buf_align;
	unsigned long buf_min;
	unsigned long buf_max;
	bool top_down;
};

struct mhp_params {
	struct vmem_altmap *altmap;
	pgprot_t pgprot;
	struct dev_pagemap *pgmap;
};

struct memory_notify {
	unsigned long start_pfn;
	unsigned long nr_pages;
	int status_change_nid_normal;
	int status_change_nid;
};

struct vgic_reg_attr {
	struct kvm_vcpu *vcpu;
	gpa_t addr;
};

struct kvm_arm_device_addr {
	__u64 id;
	__u64 addr;
};

struct tlb_inv_context {
	u64 tcr;
};

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

enum error_detector {
	ERROR_DETECTOR_KFENCE = 0,
	ERROR_DETECTOR_KASAN = 1,
	ERROR_DETECTOR_WARN = 2,
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
};

struct warn_args {
	const char *fmt;
	va_list args;
};

enum proc_cn_event {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_NONZERO_EXIT = 536870912,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

struct linked_page;

struct chain_allocator {
	struct linked_page *chain;
	unsigned int used_space;
	gfp_t gfp_mask;
	int safe_needed;
};

struct linked_page {
	struct linked_page *next;
	char data[4088];
};

struct pbe {
	void *address;
	void *orig_address;
	struct pbe *next;
};

struct mem_zone_bm_rtree;

struct rtree_node;

struct bm_position {
	struct mem_zone_bm_rtree *zone;
	struct rtree_node *node;
	unsigned long node_pfn;
	unsigned long cur_pfn;
	int node_bit;
};

struct memory_bitmap {
	struct list_head zones;
	struct linked_page *p_list;
	struct bm_position cur;
};

struct mem_zone_bm_rtree {
	struct list_head list;
	struct list_head nodes;
	struct list_head leaves;
	unsigned long start_pfn;
	unsigned long end_pfn;
	struct rtree_node *rtree;
	int levels;
	unsigned int blocks;
};

struct rtree_node {
	struct list_head list;
	unsigned long *data;
};

struct nosave_region {
	struct list_head list;
	unsigned long start_pfn;
	unsigned long end_pfn;
};

struct mem_extent {
	struct list_head hook;
	unsigned long start;
	unsigned long end;
};

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long len;
};

enum pci_p2pdma_map_type {
	PCI_P2PDMA_MAP_UNKNOWN = 0,
	PCI_P2PDMA_MAP_NOT_SUPPORTED = 1,
	PCI_P2PDMA_MAP_BUS_ADDR = 2,
	PCI_P2PDMA_MAP_THRU_HOST_BRIDGE = 3,
};

struct io_tlb_area;

struct io_tlb_slot;

struct io_tlb_pool {
	phys_addr_t start;
	phys_addr_t end;
	void *vaddr;
	unsigned long nslabs;
	bool late_alloc;
	unsigned int nareas;
	unsigned int area_nslabs;
	struct io_tlb_area *areas;
	struct io_tlb_slot *slots;
};

struct io_tlb_mem {
	struct io_tlb_pool defpool;
	unsigned long nslabs;
	struct dentry *debugfs;
	bool force_bounce;
	bool for_alloc;
	atomic_long_t total_used;
	atomic_long_t used_hiwater;
};

struct pci_p2pdma_map_state {
	struct dev_pagemap *pgmap;
	int map;
	u64 bus_off;
};

struct profile_hit {
	u32 pc;
	u32 hits;
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

typedef u32 compat_old_sigset_t;

typedef unsigned long old_sigset_t;

struct compat_rusage {
	struct old_timeval32 ru_utime;
	struct old_timeval32 ru_stime;
	compat_long_t ru_maxrss;
	compat_long_t ru_ixrss;
	compat_long_t ru_idrss;
	compat_long_t ru_isrss;
	compat_long_t ru_minflt;
	compat_long_t ru_majflt;
	compat_long_t ru_nswap;
	compat_long_t ru_inblock;
	compat_long_t ru_oublock;
	compat_long_t ru_msgsnd;
	compat_long_t ru_msgrcv;
	compat_long_t ru_nsignals;
	compat_long_t ru_nvcsw;
	compat_long_t ru_nivcsw;
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

struct buffer_data_page;

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	unsigned long real_end;
	struct buffer_data_page *page;
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
};

struct ring_buffer_per_cpu;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	unsigned long head;
	unsigned long next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	unsigned long cache_read;
	unsigned long cache_pages_removed;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	int missed_events;
};

struct rb_time_struct {
	local64_t time;
};

typedef struct rb_time_struct rb_time_t;

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	long wait_index;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	unsigned long nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	unsigned long lost_events;
	unsigned long last_overrun;
	unsigned long nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_lost;
	local_t pages_read;
	long last_pages_touch;
	size_t shortest_full;
	unsigned long read;
	unsigned long read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	u64 event_stamp[5];
	u64 read_stamp;
	unsigned long pages_removed;
	long nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
};

struct trace_buffer {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	atomic_t resizing;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)();
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	unsigned long length;
	struct buffer_page *tail_page;
	int add_timestamp;
};

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
};

struct dynevent_arg {
	const char *str;
	char separator;
};

typedef int (*dynevent_check_arg_fn_t)(void *);

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct bpf_cgroup_storage_map {
	struct bpf_map map;
	spinlock_t lock;
	struct rb_root root;
	struct list_head list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

struct bpf_cpumask {
	cpumask_t cpumask;
	refcount_t usage;
};

enum mod_mem_type {
	MOD_TEXT = 0,
	MOD_DATA = 1,
	MOD_RODATA = 2,
	MOD_RO_AFTER_INIT = 3,
	MOD_INIT_TEXT = 4,
	MOD_INIT_DATA = 5,
	MOD_INIT_RODATA = 6,
	MOD_MEM_NUM_TYPES = 7,
	MOD_INVALID = -1,
};

struct static_key_deferred {
	struct static_key key;
	unsigned long timeout;
	struct delayed_work work;
};

struct static_key_mod {
	struct static_key_mod *next;
	struct jump_entry *entries;
	struct module *mod;
};

typedef void (*btf_trace_kmem_cache_alloc)(void *, unsigned long, const void *, struct kmem_cache *, gfp_t, int);

typedef void (*btf_trace_kmalloc)(void *, unsigned long, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kfree)(void *, unsigned long, const void *);

typedef void (*btf_trace_kmem_cache_free)(void *, unsigned long, const void *, const struct kmem_cache *);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int, int);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int);

struct kmalloc_info_struct {
	const char *name[4];
	unsigned int size;
};

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	PARTIAL_NODE = 2,
	UP = 3,
	FULL = 4,
};

struct trace_event_raw_kmem_cache_alloc {
	struct trace_entry ent;
	unsigned long call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	unsigned long gfp_flags;
	int node;
	bool accounted;
	char __data[0];
};

struct trace_event_raw_kmalloc {
	struct trace_entry ent;
	unsigned long call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	unsigned long gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kfree {
	struct trace_entry ent;
	unsigned long call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_kmem_cache_free {
	struct trace_entry ent;
	unsigned long call_site;
	const void *ptr;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	unsigned long pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	unsigned long pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	unsigned long pfn;
	unsigned int order;
	unsigned long gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	unsigned long pfn;
	unsigned int order;
	int migratetype;
	int percpu_refill;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	unsigned long pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	unsigned long pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long size;
	char __data[0];
};

struct trace_event_data_offsets_kmem_cache_free {
	u32 name;
};

struct kmem_obj_info {
	void *kp_ptr;
	struct slab *kp_slab;
	void *kp_objp;
	unsigned long kp_data_offset;
	struct kmem_cache *kp_slab_cache;
	void *kp_ret;
	void *kp_stack[16];
	void *kp_free_stack[16];
};

struct slabinfo {
	unsigned long active_objs;
	unsigned long num_objs;
	unsigned long active_slabs;
	unsigned long num_slabs;
	unsigned long shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

struct trace_event_data_offsets_kmem_cache_alloc {};

struct trace_event_data_offsets_kmalloc {};

struct trace_event_data_offsets_kfree {};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_rss_stat {};

typedef void (*btf_trace_alloc_vmap_area)(void *, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, int);

typedef void (*btf_trace_purge_vmap_area_lazy)(void *, unsigned long, unsigned long, unsigned int);

typedef void (*btf_trace_free_vmap_area_noflush)(void *, unsigned long, unsigned long, unsigned long);

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
	struct xarray vmap_blocks;
};

struct vmap_area {
	unsigned long va_start;
	unsigned long va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		unsigned long subtree_max_size;
		struct vm_struct *vm;
	};
	unsigned long flags;
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

typedef unsigned int kasan_vmalloc_flags_t;

struct trace_event_raw_alloc_vmap_area {
	struct trace_entry ent;
	unsigned long addr;
	unsigned long size;
	unsigned long align;
	unsigned long vstart;
	unsigned long vend;
	int failed;
	char __data[0];
};

struct trace_event_raw_purge_vmap_area_lazy {
	struct trace_entry ent;
	unsigned long start;
	unsigned long end;
	unsigned int npurged;
	char __data[0];
};

struct trace_event_raw_free_vmap_area_noflush {
	struct trace_entry ent;
	unsigned long va_start;
	unsigned long nr_lazy;
	unsigned long nr_lazy_max;
	char __data[0];
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	unsigned long free;
	unsigned long dirty;
	unsigned long used_map[16];
	unsigned long dirty_min;
	unsigned long dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
};

struct trace_event_data_offsets_alloc_vmap_area {};

struct trace_event_data_offsets_purge_vmap_area_lazy {};

struct trace_event_data_offsets_free_vmap_area_noflush {};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct xattr_handler * const *xattr;
	const struct dentry_operations *dops;
	unsigned long magic;
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_ANY = -1,
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 1,
	FSNOTIFY_OBJ_TYPE_SB = 2,
	FSNOTIFY_OBJ_TYPE_COUNT = 3,
	FSNOTIFY_OBJ_TYPE_DETACHED = 3,
};

struct dnotify_struct;

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	const char *lsm;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	struct inode vfs_inode;
};

struct page_region {
	__u64 start;
	__u64 end;
	__u64 categories;
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vma_iterator iter;
	struct mempolicy *task_mempolicy;
};

struct pm_scan_arg {
	__u64 size;
	__u64 flags;
	__u64 start;
	__u64 end;
	__u64 walk_end;
	__u64 vec;
	__u64 vec_len;
	__u64 max_pages;
	__u64 category_inverted;
	__u64 category_mask;
	__u64 category_anyof_mask;
	__u64 return_mask;
};

struct pagemap_scan_private {
	struct pm_scan_arg arg;
	unsigned long masks_of_interest;
	unsigned long cur_vma_category;
	struct page_region *vec_buf;
	unsigned long vec_buf_len;
	unsigned long vec_buf_index;
	unsigned long found_pages;
	struct page_region __attribute__((btf_type_tag("user"))) *vec_out;
};

struct mem_size_stats {
	unsigned long resident;
	unsigned long shared_clean;
	unsigned long shared_dirty;
	unsigned long private_clean;
	unsigned long private_dirty;
	unsigned long referenced;
	unsigned long anonymous;
	unsigned long lazyfree;
	unsigned long anonymous_thp;
	unsigned long shmem_thp;
	unsigned long file_thp;
	unsigned long swap;
	unsigned long shared_hugetlb;
	unsigned long private_hugetlb;
	unsigned long ksm;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_dirty;
	u64 pss_locked;
	u64 swap_pss;
};

typedef struct {
	u64 pme;
} pagemap_entry_t;

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct clear_refs_private {
	enum clear_refs_types type;
};

struct numa_maps {
	unsigned long pages;
	unsigned long anon;
	unsigned long active;
	unsigned long writeback;
	unsigned long mapcount_max;
	unsigned long dirty;
	unsigned long swapcache;
	unsigned long node[16];
};

struct numa_maps_private {
	struct proc_maps_private proc_maps;
	struct numa_maps md;
};

enum criteria {
	CR_POWER2_ALIGNED = 0,
	CR_GOAL_LEN_FAST = 1,
	CR_BEST_AVAIL_LEN = 2,
	CR_GOAL_LEN_SLOW = 3,
	CR_ANY_FREE = 4,
	EXT4_MB_NUM_CRS = 5,
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct ext4_buddy {
	struct page *bd_buddy_page;
	void *bd_buddy;
	struct page *bd_bitmap_page;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

enum nfs_stat {
	NFS_OK = 0,
	NFSERR_PERM = 1,
	NFSERR_NOENT = 2,
	NFSERR_IO = 5,
	NFSERR_NXIO = 6,
	NFSERR_EAGAIN = 11,
	NFSERR_ACCES = 13,
	NFSERR_EXIST = 17,
	NFSERR_XDEV = 18,
	NFSERR_NODEV = 19,
	NFSERR_NOTDIR = 20,
	NFSERR_ISDIR = 21,
	NFSERR_INVAL = 22,
	NFSERR_FBIG = 27,
	NFSERR_NOSPC = 28,
	NFSERR_ROFS = 30,
	NFSERR_MLINK = 31,
	NFSERR_OPNOTSUPP = 45,
	NFSERR_NAMETOOLONG = 63,
	NFSERR_NOTEMPTY = 66,
	NFSERR_DQUOT = 69,
	NFSERR_STALE = 70,
	NFSERR_REMOTE = 71,
	NFSERR_WFLUSH = 99,
	NFSERR_BADHANDLE = 10001,
	NFSERR_NOT_SYNC = 10002,
	NFSERR_BAD_COOKIE = 10003,
	NFSERR_NOTSUPP = 10004,
	NFSERR_TOOSMALL = 10005,
	NFSERR_SERVERFAULT = 10006,
	NFSERR_BADTYPE = 10007,
	NFSERR_JUKEBOX = 10008,
	NFSERR_SAME = 10009,
	NFSERR_DENIED = 10010,
	NFSERR_EXPIRED = 10011,
	NFSERR_LOCKED = 10012,
	NFSERR_GRACE = 10013,
	NFSERR_FHEXPIRED = 10014,
	NFSERR_SHARE_DENIED = 10015,
	NFSERR_WRONGSEC = 10016,
	NFSERR_CLID_INUSE = 10017,
	NFSERR_RESOURCE = 10018,
	NFSERR_MOVED = 10019,
	NFSERR_NOFILEHANDLE = 10020,
	NFSERR_MINOR_VERS_MISMATCH = 10021,
	NFSERR_STALE_CLIENTID = 10022,
	NFSERR_STALE_STATEID = 10023,
	NFSERR_OLD_STATEID = 10024,
	NFSERR_BAD_STATEID = 10025,
	NFSERR_BAD_SEQID = 10026,
	NFSERR_NOT_SAME = 10027,
	NFSERR_LOCK_RANGE = 10028,
	NFSERR_SYMLINK = 10029,
	NFSERR_RESTOREFH = 10030,
	NFSERR_LEASE_MOVED = 10031,
	NFSERR_ATTRNOTSUPP = 10032,
	NFSERR_NO_GRACE = 10033,
	NFSERR_RECLAIM_BAD = 10034,
	NFSERR_RECLAIM_CONFLICT = 10035,
	NFSERR_BAD_XDR = 10036,
	NFSERR_LOCKS_HELD = 10037,
	NFSERR_OPENMODE = 10038,
	NFSERR_BADOWNER = 10039,
	NFSERR_BADCHAR = 10040,
	NFSERR_BADNAME = 10041,
	NFSERR_BAD_RANGE = 10042,
	NFSERR_LOCK_NOTSUPP = 10043,
	NFSERR_OP_ILLEGAL = 10044,
	NFSERR_DEADLOCK = 10045,
	NFSERR_FILE_OPEN = 10046,
	NFSERR_ADMIN_REVOKED = 10047,
	NFSERR_CB_PATH_DOWN = 10048,
};

enum nfs_ftype {
	NFNON = 0,
	NFREG = 1,
	NFDIR = 2,
	NFBLK = 3,
	NFCHR = 4,
	NFLNK = 5,
	NFSOCK = 6,
	NFBAD = 7,
	NFFIFO = 8,
};

enum nfs2_ftype {
	NF2NON = 0,
	NF2REG = 1,
	NF2DIR = 2,
	NF2BLK = 3,
	NF2CHR = 4,
	NF2LNK = 5,
	NF2SOCK = 6,
	NF2BAD = 7,
	NF2FIFO = 8,
};

struct nfs_diropok {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_readdirargs {
	struct nfs_fh *fh;
	__u32 cookie;
	unsigned int count;
	struct page **pages;
};

struct nfs2_fsstat {
	__u32 tsize;
	__u32 bsize;
	__u32 blocks;
	__u32 bfree;
	__u32 bavail;
};

struct nfs_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
};

struct nfs_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

enum nfs4_session_state {
	NFS4_SESSION_INITING = 0,
	NFS4_SESSION_ESTABLISHED = 1,
};

enum nfs4_slot_tbl_state {
	NFS4_SLOT_TBL_DRAINING = 0,
};

struct nlm_file;

struct nlm_share {
	struct nlm_share *s_next;
	struct nlm_host *s_host;
	struct nlm_file *s_file;
	struct xdr_netobj s_owner;
	u32 s_access;
	u32 s_mode;
};

struct nlm_file {
	struct hlist_node f_list;
	struct nfs_fh f_handle;
	struct file *f_file[2];
	struct nlm_share *f_shares;
	struct list_head f_blocks;
	unsigned int f_locks;
	unsigned int f_count;
	struct mutex f_mutex;
};

typedef int (*nlm_host_match_fn_t)(void *, struct nlm_host *);

enum {
	Opt_direct = 0,
	Opt_fd = 1,
	Opt_gid = 2,
	Opt_ignore = 3,
	Opt_indirect = 4,
	Opt_maxproto = 5,
	Opt_minproto = 6,
	Opt_offset = 7,
	Opt_pgrp = 8,
	Opt_strictexpire = 9,
	Opt_uid = 10,
};

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	unsigned long exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

typedef unsigned int autofs_wqt_t;

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	struct qstr name;
	u32 offset;
	u32 dev;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

struct autofs_info {
	struct dentry *dentry;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	unsigned long last_used;
	int count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_fs_context {
	kuid_t uid;
	kgid_t gid;
	int pgrp;
	bool pgrp_set;
};

enum {
	Opt_uid___2 = 0,
	Opt_gid___2 = 1,
};

typedef u16 ucs2_char_t;

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

struct assoc_array_ops {
	unsigned long (*get_key_chunk)(const void *, int);
	unsigned long (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	unsigned long index_key[0];
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	unsigned long nr_leaves_on_branch;
};

struct assoc_array_edit {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	time64_t now;
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct sha512_state;

typedef void sha512_block_fn(struct sha512_state *, const u8 *, int);

struct sha512_state {
	u64 state[8];
	u64 count[2];
	u8 buf[128];
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

struct sg_io_v4;

typedef int bsg_sg_io_fn(struct request_queue *, struct sg_io_v4 *, bool, unsigned int);

struct bsg_device {
	struct request_queue *queue;
	struct device device;
	struct cdev cdev;
	int max_queue;
	unsigned int timeout;
	unsigned int reserved_size;
	bsg_sg_io_fn *sg_io_fn;
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

struct io_sync {
	struct file *file;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

enum {
	IO_WQ_BIT_EXIT = 0,
};

enum {
	IO_WORKER_F_UP = 1,
	IO_WORKER_F_RUNNING = 2,
	IO_WORKER_F_FREE = 4,
	IO_WORKER_F_BOUND = 8,
};

enum {
	IO_ACCT_STALLED_BIT = 0,
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
	IO_WQ_ACCT_NR = 2,
};

typedef struct io_wq_work *free_work_fn(struct io_wq_work *);

typedef void io_wq_work_fn(struct io_wq_work *);

struct io_wq_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	int index;
	atomic_t nr_running;
	raw_spinlock_t lock;
	struct io_wq_work_list work_list;
	unsigned long flags;
};

struct io_wq {
	unsigned long state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct io_wq_hash *hash;
	atomic_t worker_refs;
	struct completion worker_done;
	struct hlist_node cpuhp_node;
	struct task_struct *task;
	struct io_wq_acct acct[2];
	raw_spinlock_t lock;
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct wait_queue_entry wait;
	struct io_wq_work *hash_tail[64];
	cpumask_var_t cpu_mask;
};

struct io_worker {
	refcount_t ref;
	unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wq *wq;
	struct io_wq_work *cur_work;
	struct io_wq_work *next_work;
	raw_spinlock_t lock;
	struct completion ref_done;
	unsigned long create_state;
	struct callback_head create_work;
	int create_index;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct online_data {
	unsigned int cpu;
	bool online;
};

struct io_wq_data {
	struct io_wq_hash *hash;
	struct task_struct *task;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

typedef uint8_t U8;

typedef struct {
	U16 nextState;
	BYTE nbAdditionalBits;
	BYTE nbBits;
	U32 baseValue;
} ZSTD_seqSymbol;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

typedef enum {
	ZSTD_lo_isRegularOffset = 0,
	ZSTD_lo_isLongOffset = 1,
} ZSTD_longOffset_e;

typedef int16_t S16;

typedef struct {
	U32 fastMode;
	U32 tableLog;
} ZSTD_seqSymbol_header;

typedef __kernel_long_t __kernel_ptrdiff_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

typedef struct {
	ZSTD_seqSymbol LLTable[513];
	ZSTD_seqSymbol OFTable[257];
	ZSTD_seqSymbol MLTable[513];
	HUF_DTable hufTable[4097];
	U32 rep[3];
	U32 workspace[157];
} ZSTD_entropyDTables_t;

typedef enum {
	ZSTD_frame = 0,
	ZSTD_skippableFrame = 1,
} ZSTD_frameType_e;

typedef struct {
	unsigned long long frameContentSize;
	unsigned long long windowSize;
	unsigned int blockSizeMax;
	ZSTD_frameType_e frameType;
	unsigned int headerSize;
	unsigned int dictID;
	unsigned int checksumFlag;
} ZSTD_frameHeader;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

typedef enum {
	ZSTD_f_zstd1 = 0,
	ZSTD_f_zstd1_magicless = 1,
} ZSTD_format_e;

typedef enum {
	ZSTD_d_validateChecksum = 0,
	ZSTD_d_ignoreChecksum = 1,
} ZSTD_forceIgnoreChecksum_e;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

typedef enum {
	ZSTD_use_indefinitely = -1,
	ZSTD_dont_use = 0,
	ZSTD_use_once = 1,
} ZSTD_dictUses_e;

struct ZSTD_DDict_s;

typedef struct ZSTD_DDict_s ZSTD_DDict;

typedef struct {
	const ZSTD_DDict **ddictPtrTable;
	size_t ddictPtrTableSize;
	size_t ddictPtrCount;
} ZSTD_DDictHashSet;

typedef enum {
	ZSTD_rmd_refSingleDDict = 0,
	ZSTD_rmd_refMultipleDDicts = 1,
} ZSTD_refMultipleDDicts_e;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

typedef enum {
	ZSTD_bm_buffered = 0,
	ZSTD_bm_stable = 1,
} ZSTD_bufferMode_e;

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

typedef enum {
	ZSTD_not_in_dst = 0,
	ZSTD_in_dst = 1,
	ZSTD_split = 2,
} ZSTD_litLocation_e;

struct ZSTD_DCtx_s {
	const ZSTD_seqSymbol *LLTptr;
	const ZSTD_seqSymbol *MLTptr;
	const ZSTD_seqSymbol *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyDTables_t entropy;
	U32 workspace[640];
	const void *previousDstEnd;
	const void *prefixStart;
	const void *virtualStart;
	const void *dictEnd;
	size_t expected;
	ZSTD_frameHeader fParams;
	U64 processedCSize;
	U64 decodedSize;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	ZSTD_format_e format;
	ZSTD_forceIgnoreChecksum_e forceIgnoreChecksum;
	U32 validateChecksum;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	size_t staticSize;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	U32 dictID;
	int ddictIsCold;
	ZSTD_dictUses_e dictUses;
	ZSTD_DDictHashSet *ddictSet;
	ZSTD_refMultipleDDicts_e refMultipleDDicts;
	ZSTD_dStreamStage streamStage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t lhSize;
	U32 hostageByte;
	int noForwardProgress;
	ZSTD_bufferMode_e outBufferMode;
	ZSTD_outBuffer expectedOutBuffer;
	BYTE *litBuffer;
	const BYTE *litBufferEnd;
	ZSTD_litLocation_e litBufferLocation;
	BYTE litExtraBuffer[65568];
	BYTE headerBuffer[18];
	size_t oversizedDuration;
};

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	ZSTD_entropyDTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
};

typedef enum {
	not_streaming = 0,
	is_streaming = 1,
} streaming_operation;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
} seq_t;

typedef struct {
	size_t state;
	const ZSTD_seqSymbol *table;
} ZSTD_fseState;

typedef struct {
	BIT_DStream_t DStream;
	ZSTD_fseState stateLL;
	ZSTD_fseState stateOffb;
	ZSTD_fseState stateML;
	size_t prevOffset[3];
} seqState_t;

typedef enum {
	ZSTD_no_overlap = 0,
	ZSTD_overlap_src_before_dst = 1,
} ZSTD_overlap_e;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

struct bcm2836_arm_irqchip_intc {
	struct irq_domain *domain;
	void *base;
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_ISOLATED_MSI = 32,
	IRQ_DOMAIN_FLAG_NO_MAP = 64,
	IRQ_DOMAIN_FLAG_MSI_PARENT = 256,
	IRQ_DOMAIN_FLAG_MSI_DEVICE = 512,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

struct mtk_cirq_chip_data {
	void *base;
	unsigned int ext_irq_start;
	unsigned int ext_irq_end;
	const u32 *offsets;
	struct irq_domain *domain;
};

enum mtk_cirq_regoffs_index {
	CIRQ_STA = 0,
	CIRQ_ACK = 1,
	CIRQ_MASK_SET = 2,
	CIRQ_MASK_CLR = 3,
	CIRQ_SENS_SET = 4,
	CIRQ_SENS_CLR = 5,
	CIRQ_POL_SET = 6,
	CIRQ_POL_CLR = 7,
	CIRQ_CONTROL = 8,
};

struct ti_sci_resource {
	u16 sets;
	raw_spinlock_t lock;
	struct ti_sci_resource_desc *desc;
};

struct ti_sci_intr_irq_domain {
	const struct ti_sci_handle *sci;
	struct ti_sci_resource *out_irqs;
	struct device *dev;
	u32 ti_sci_id;
	u32 type;
};

struct dpcon_cmd_open {
	__le32 dpcon_id;
};

struct dpcon_rsp_get_attr {
	__le32 id;
	__le16 qbman_ch_id;
	u8 num_priorities;
	u8 pad;
};

struct dpcon_cmd_set_notification {
	__le32 dpio_id;
	u8 priority;
	u8 pad[3];
	__le64 user_ctx;
};

struct dpcon_attr {
	int id;
	u16 qbman_ch_id;
	u8 num_priorities;
};

struct dpcon_notification_cfg {
	int dpio_id;
	u8 priority;
	u64 user_ctx;
};

enum meson_soc_id {
	MESON_SOC_G12A = 0,
	MESON_SOC_A1 = 1,
};

struct phy_meson_g12a_usb2_priv {
	struct device *dev;
	struct regmap *regmap;
	struct clk *clk;
	struct reset_control *reset;
	int soc_id;
};

struct rockchip_emmc_phy {
	unsigned int reg_offset;
	struct regmap *reg_base;
	struct clk *emmcclk;
	unsigned int drive_impedance;
	unsigned int enable_strobe_pulldown;
	unsigned int output_tapdelay_select;
};

struct max77620_pin_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
	int mux_option;
};

enum max77620_alternate_pinmux_option {
	MAX77620_PINMUX_GPIO = 0,
	MAX77620_PINMUX_LOW_POWER_MODE_CONTROL_IN = 1,
	MAX77620_PINMUX_FLEXIBLE_POWER_SEQUENCER_OUT = 2,
	MAX77620_PINMUX_32K_OUT1 = 3,
	MAX77620_PINMUX_SD0_DYNAMIC_VOLTAGE_SCALING_IN = 4,
	MAX77620_PINMUX_SD1_DYNAMIC_VOLTAGE_SCALING_IN = 5,
	MAX77620_PINMUX_REFERENCE_OUT = 6,
};

struct max77620_pingroup {
	const char *name;
	const unsigned int pins[1];
	unsigned int npins;
	enum max77620_alternate_pinmux_option alt_option;
};

enum max77620_chip_id {
	MAX77620 = 0,
	MAX20024 = 1,
	MAX77663 = 2,
};

enum max77620_pin_ppdrv {
	MAX77620_PIN_UNCONFIG_DRV = 0,
	MAX77620_PIN_OD_DRV = 1,
	MAX77620_PIN_PP_DRV = 2,
};

enum {
	MAX77620_GPIO0 = 0,
	MAX77620_GPIO1 = 1,
	MAX77620_GPIO2 = 2,
	MAX77620_GPIO3 = 3,
	MAX77620_GPIO4 = 4,
	MAX77620_GPIO5 = 5,
	MAX77620_GPIO6 = 6,
	MAX77620_GPIO7 = 7,
	MAX77620_GPIO_NR = 8,
};

enum max77620_fps_src {
	MAX77620_FPS_SRC_0 = 0,
	MAX77620_FPS_SRC_1 = 1,
	MAX77620_FPS_SRC_2 = 2,
	MAX77620_FPS_SRC_NONE = 3,
	MAX77620_FPS_SRC_DEF = 4,
};

struct max77620_pin_info {
	enum max77620_pin_ppdrv drv_type;
	int pull_config;
};

struct max77620_fps_config {
	int active_fps_src;
	int active_power_up_slots;
	int active_power_down_slots;
	int suspend_fps_src;
	int suspend_power_up_slots;
	int suspend_power_down_slots;
};

struct max77620_pctrl_info {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct regmap *rmap;
	int pins_current_opt[8];
	const struct max77620_pin_function *functions;
	unsigned int num_functions;
	const struct max77620_pingroup *pin_groups;
	int num_pin_groups;
	const struct pinctrl_pin_desc *pins;
	unsigned int num_pins;
	struct max77620_pin_info pin_info[8];
	struct max77620_fps_config fps_config[8];
};

struct max77620_chip {
	struct device *dev;
	struct regmap *rmap;
	int chip_irq;
	enum max77620_chip_id chip_id;
	bool sleep_enable;
	bool enable_global_lpm;
	int shutdown_fps_period[3];
	int suspend_fps_period[3];
	struct regmap_irq_chip_data *top_irq_data;
	struct regmap_irq_chip_data *gpio_irq_data;
};

struct imx_pinctrl;

struct imx_pin;

struct imx_pinctrl_soc_info {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	unsigned int flags;
	const char *gpr_compatible;
	unsigned int mux_mask;
	u8 mux_shift;
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	int (*imx_pinconf_get)(struct pinctrl_dev *, unsigned int, unsigned long *);
	int (*imx_pinconf_set)(struct pinctrl_dev *, unsigned int, unsigned long *, unsigned int);
	void (*imx_pinctrl_parse_pin)(struct imx_pinctrl *, unsigned int *, struct imx_pin *, const __be32 **);
};

struct imx_pin_reg;

struct imx_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	void *base;
	void *input_sel_base;
	const struct imx_pinctrl_soc_info *info;
	struct imx_pin_reg *pin_regs;
	unsigned int group_index;
	struct mutex mutex;
};

struct imx_pin_reg {
	s16 mux_reg;
	s16 conf_reg;
};

struct imx_pin_mmio {
	unsigned int mux_mode;
	u16 input_reg;
	unsigned int input_val;
	unsigned long config;
};

struct imx_pin_scu {
	unsigned int mux_mode;
	unsigned long config;
};

struct imx_pin {
	unsigned int pin;
	union {
		struct imx_pin_mmio mmio;
		struct imx_pin_scu scu;
	} conf;
};

struct gpio {
	unsigned int gpio;
	unsigned long flags;
	const char *label;
};

struct aer_recover_entry {
	u8 bus;
	u8 devfn;
	u16 domain;
	int severity;
	struct aer_capability_regs *regs;
};

struct pcie_device;

struct pcie_port_service_driver {
	const char *name;
	int (*probe)(struct pcie_device *);
	void (*remove)(struct pcie_device *);
	int (*suspend)(struct pcie_device *);
	int (*resume_noirq)(struct pcie_device *);
	int (*resume)(struct pcie_device *);
	int (*runtime_suspend)(struct pcie_device *);
	int (*runtime_resume)(struct pcie_device *);
	int (*slot_reset)(struct pcie_device *);
	int port_type;
	u32 service;
	struct device_driver driver;
};

struct pcie_device {
	int irq;
	struct pci_dev *port;
	u32 service;
	void *priv_data;
	struct device device;
};

struct aer_stats {
	u64 dev_cor_errs[16];
	u64 dev_fatal_errs[27];
	u64 dev_nonfatal_errs[27];
	u64 dev_total_cor_errs;
	u64 dev_total_fatal_errs;
	u64 dev_total_nonfatal_errs;
	u64 rootport_total_cor_errs;
	u64 rootport_total_fatal_errs;
	u64 rootport_total_nonfatal_errs;
};

struct aer_err_source {
	unsigned int status;
	unsigned int id;
};

struct aer_err_info {
	struct pci_dev *dev[5];
	int error_dev_num;
	unsigned int id: 16;
	unsigned int severity: 2;
	unsigned int __pad1: 5;
	unsigned int multi_error_valid: 1;
	unsigned int first_error: 5;
	unsigned int __pad2: 2;
	unsigned int tlp_header_valid: 1;
	unsigned int status;
	unsigned int mask;
	struct aer_header_log_regs tlp;
};

struct aer_rpc {
	struct pci_dev *rpd;
	struct {
		union {
			struct __kfifo kfifo;
			struct aer_err_source *type;
			const struct aer_err_source *const_type;
			char (*rectype)[0];
			struct aer_err_source *ptr;
			const struct aer_err_source *ptr_const;
		};
		struct aer_err_source buf[128];
	} aer_fifo;
};

enum altera_pcie_version {
	ALTERA_PCIE_V1 = 0,
	ALTERA_PCIE_V2 = 1,
};

struct altera_pcie_ops;

struct altera_pcie_data {
	const struct altera_pcie_ops *ops;
	enum altera_pcie_version version;
	u32 cap_offset;
	u32 cfgrd0;
	u32 cfgrd1;
	u32 cfgwr0;
	u32 cfgwr1;
};

struct altera_pcie;

struct altera_pcie_ops {
	int (*tlp_read_pkt)(struct altera_pcie *, u32 *);
	void (*tlp_write_pkt)(struct altera_pcie *, u32 *, u32, bool);
	bool (*get_link_status)(struct altera_pcie *);
	int (*rp_read_cfg)(struct altera_pcie *, int, int, u32 *);
	int (*rp_write_cfg)(struct altera_pcie *, u8, int, int, u32);
};

struct altera_pcie {
	struct platform_device *pdev;
	void *cra_base;
	void *hip_base;
	int irq;
	u8 root_bus_nr;
	struct irq_domain *irq_domain;
	struct resource bus_range;
	const struct altera_pcie_data *pcie_data;
};

struct tlp_rp_regpair_t {
	u32 ctrl;
	u32 reg0;
	u32 reg1;
};

struct efifb_par {
	u32 pseudo_palette[16];
	resource_size_t base;
	resource_size_t size;
};

struct acpi_pci_device {
	acpi_handle device;
	struct acpi_pci_device *next;
};

struct acpi_table_rsdp {
	char signature[8];
	u8 checksum;
	char oem_id[6];
	u8 revision;
	u32 rsdt_physical_address;
	u32 length;
	u64 xsdt_physical_address;
	u8 extended_checksum;
	u8 reserved[3];
} __attribute__((packed));

struct clk_gpio {
	struct clk_hw hw;
	struct gpio_desc *gpiod;
};

struct owl_reset_map;

struct owl_reset {
	struct reset_controller_dev rcdev;
	const struct owl_reset_map *reset_map;
	struct regmap *regmap;
};

struct owl_reset_map {
	u32 reg;
	u32 bit;
};

enum kp_band {
	KP_BAND_MID = 0,
	KP_BAND_HIGH = 1,
	KP_BAND_HIGH_HIGH = 2,
};

enum vco_freq_range {
	VCO_LOW = 700000000,
	VCO_MID = 1200000000,
	VCO_HIGH = 2200000000,
	VCO_HIGH_HIGH = 3100000000,
	VCO_MAX = 4000000000,
};

struct iproc_pll;

struct iproc_clk_ctrl;

struct iproc_clk {
	struct clk_hw hw;
	struct iproc_pll *pll;
	const struct iproc_clk_ctrl *ctrl;
};

struct iproc_pll_ctrl;

struct iproc_pll_vco_param;

struct iproc_pll {
	void *status_base;
	void *control_base;
	void *pwr_base;
	void *asiu_base;
	const struct iproc_pll_ctrl *ctrl;
	const struct iproc_pll_vco_param *vco_param;
	unsigned int num_vco_entries;
};

struct iproc_pll_aon_pwr_ctrl {
	unsigned int offset;
	unsigned int pwr_width;
	unsigned int pwr_shift;
	unsigned int iso_shift;
};

struct iproc_asiu_gate {
	unsigned int offset;
	unsigned int en_shift;
};

struct iproc_pll_reset_ctrl {
	unsigned int offset;
	unsigned int reset_shift;
	unsigned int p_reset_shift;
};

struct iproc_pll_dig_filter_ctrl {
	unsigned int offset;
	unsigned int ki_shift;
	unsigned int ki_width;
	unsigned int kp_shift;
	unsigned int kp_width;
	unsigned int ka_shift;
	unsigned int ka_width;
};

struct iproc_pll_sw_ctrl {
	unsigned int offset;
	unsigned int shift;
};

struct iproc_clk_reg_op {
	unsigned int offset;
	unsigned int shift;
	unsigned int width;
};

struct iproc_pll_vco_ctrl {
	unsigned int u_offset;
	unsigned int l_offset;
};

struct iproc_pll_ctrl {
	unsigned long flags;
	struct iproc_pll_aon_pwr_ctrl aon;
	struct iproc_asiu_gate asiu;
	struct iproc_pll_reset_ctrl reset;
	struct iproc_pll_dig_filter_ctrl dig_filter;
	struct iproc_pll_sw_ctrl sw_ctrl;
	struct iproc_clk_reg_op ndiv_int;
	struct iproc_clk_reg_op ndiv_frac;
	struct iproc_clk_reg_op pdiv;
	struct iproc_pll_vco_ctrl vco_ctrl;
	struct iproc_clk_reg_op status;
	struct iproc_clk_reg_op macro_mode;
};

struct iproc_pll_vco_param {
	unsigned long rate;
	unsigned int ndiv_int;
	unsigned int ndiv_frac;
	unsigned int pdiv;
};

struct iproc_clk_enable_ctrl {
	unsigned int offset;
	unsigned int enable_shift;
	unsigned int hold_shift;
	unsigned int bypass_shift;
};

struct iproc_clk_ctrl {
	unsigned int channel;
	unsigned long flags;
	struct iproc_clk_enable_ctrl enable;
	struct iproc_clk_reg_op mdiv;
};

struct clk_gate_exclusive {
	struct clk_gate gate;
	u32 exclusive_mask;
};

enum imx_pllv4_type {
	IMX_PLLV4_IMX7ULP = 0,
	IMX_PLLV4_IMX8ULP = 1,
	IMX_PLLV4_IMX8ULP_1GHZ = 2,
};

struct clk_pllv4 {
	struct clk_hw hw;
	void *base;
	u32 cfg_offset;
	u32 num_offset;
	u32 denom_offset;
	bool use_mult_range;
};

enum clk_sel {
	LOW_SPEED_IO_SEL = 0,
	NON_IO_SEL = 1,
	FAST_SEL = 2,
	AUDIO_SEL = 3,
	VIDEO_SEL = 4,
	TPM_SEL = 5,
	CKO1_SEL = 6,
	CKO2_SEL = 7,
	MISC_SEL = 8,
	MAX_SEL = 9,
};

struct imx93_clk_root {
	u32 clk;
	char *name;
	u32 off;
	enum clk_sel sel;
	unsigned long flags;
};

struct imx93_clk_ccgr {
	u32 clk;
	char *name;
	char *parent_name;
	u32 off;
	unsigned long flags;
	u32 *shared_count;
};

struct imx_fracn_gppll_rate_table;

struct imx_fracn_gppll_clk {
	const struct imx_fracn_gppll_rate_table *rate_table;
	int rate_count;
	int flags;
};

struct imx_fracn_gppll_rate_table {
	unsigned int rate;
	unsigned int mfi;
	unsigned int mfn;
	unsigned int mfd;
	unsigned int rdiv;
	unsigned int odiv;
};

struct parm {
	u16 reg_off;
	u8 shift;
	u8 width;
};

struct pll_params_table;

struct pll_mult_range;

struct meson_clk_pll_data {
	struct parm en;
	struct parm m;
	struct parm n;
	struct parm frac;
	struct parm l;
	struct parm rst;
	struct parm current_en;
	struct parm l_detect;
	const struct reg_sequence *init_regs;
	unsigned int init_count;
	const struct pll_params_table *table;
	const struct pll_mult_range *range;
	u8 flags;
};

struct pll_params_table {
	unsigned int m;
	unsigned int n;
};

struct pll_mult_range {
	unsigned int min;
	unsigned int max;
};

enum clk_ids___2 {
	LAST_DT_CORE_CLK___2 = 51,
	CLK_EXTAL___2 = 52,
	CLK_EXTALR___2 = 53,
	CLK_MAIN___2 = 54,
	CLK_PLL0 = 55,
	CLK_PLL1___2 = 56,
	CLK_PLL2 = 57,
	CLK_PLL3 = 58,
	CLK_PLL4 = 59,
	CLK_PLL1_DIV2___2 = 60,
	CLK_PLL1_DIV4 = 61,
	CLK_S0 = 62,
	CLK_S1___2 = 63,
	CLK_S2 = 64,
	CLK_S3___2 = 65,
	CLK_SDSRC___2 = 66,
	CLK_SSPSRC = 67,
	CLK_RPCSRC___2 = 68,
	CLK_RINT = 69,
	MOD_CLK_BASE___2 = 70,
};

struct sprd_mux_ssel {
	u8 shift;
	u8 width;
	const u8 *table;
};

struct sprd_mux {
	struct sprd_mux_ssel mux;
	struct sprd_clk_common common;
};

enum fsl_edma_pm_state {
	RUNNING = 0,
	SUSPENDED = 1,
};

struct fsl_edma_engine;

struct fsl_edma_desc;

struct fsl_edma_hw_tcd;

struct fsl_edma_chan {
	struct virt_dma_chan vchan;
	enum dma_status status;
	enum fsl_edma_pm_state pm_state;
	bool idle;
	u32 slave_id;
	struct fsl_edma_engine *edma;
	struct fsl_edma_desc *edesc;
	struct dma_slave_config cfg;
	u32 attr;
	bool is_sw;
	struct dma_pool *tcd_pool;
	dma_addr_t dma_dev_addr;
	u32 dma_dev_size;
	enum dma_data_direction dma_dir;
	char chan_name[32];
	struct fsl_edma_hw_tcd *tcd;
	u32 real_count;
	struct work_struct issue_worker;
	struct platform_device *pdev;
	struct device *pd_dev;
	u32 srcid;
	struct clk *clk;
	int priority;
	int hw_chanid;
	int txirq;
	bool is_rxchan;
	bool is_remote;
	bool is_multi_fifo;
};

struct edma_regs {
	void *cr;
	void *es;
	void *erqh;
	void *erql;
	void *eeih;
	void *eeil;
	void *seei;
	void *ceei;
	void *serq;
	void *cerq;
	void *cint;
	void *cerr;
	void *ssrt;
	void *cdne;
	void *inth;
	void *intl;
	void *errh;
	void *errl;
};

struct fsl_edma_drvdata;

struct fsl_edma_engine {
	struct dma_device dma_dev;
	void *membase;
	void *muxbase[2];
	struct clk *muxclk[2];
	struct clk *dmaclk;
	struct clk *chclk;
	struct mutex fsl_edma_mutex;
	const struct fsl_edma_drvdata *drvdata;
	u32 n_chans;
	int txirq;
	int errirq;
	bool big_endian;
	struct edma_regs regs;
	u64 chan_masked;
	struct fsl_edma_chan chans[0];
};

struct fsl_edma_drvdata {
	u32 dmamuxs;
	u32 chreg_off;
	u32 chreg_space_sz;
	u32 flags;
	int (*setup_irq)(struct platform_device *, struct fsl_edma_engine *);
};

struct fsl_edma_sw_tcd {
	dma_addr_t ptcd;
	struct fsl_edma_hw_tcd *vtcd;
};

struct fsl_edma_desc {
	struct virt_dma_desc vdesc;
	struct fsl_edma_chan *echan;
	bool iscyclic;
	enum dma_transfer_direction dirn;
	unsigned int n_tcds;
	struct fsl_edma_sw_tcd tcd[0];
};

struct fsl_edma_hw_tcd {
	__le32 saddr;
	__le16 soff;
	__le16 attr;
	__le32 nbytes;
	__le32 slast;
	__le32 daddr;
	__le16 doff;
	__le16 citer;
	__le32 dlast_sga;
	__le16 csr;
	__le16 biter;
};

struct fsl_edma3_ch_reg {
	__le32 ch_csr;
	__le32 ch_es;
	__le32 ch_int;
	__le32 ch_sbr;
	__le32 ch_pri;
	__le32 ch_mux;
	__le32 ch_mattr;
	__le32 ch_reserved;
	struct fsl_edma_hw_tcd tcd;
};

struct fsl_soc_data {
	const char *sfp_compat;
	u32 uid_offset;
};

struct fsl_soc_die_attr {
	char *die;
	u32 svr;
	u32 mask;
};

struct qcom_rpm_header {
	__le32 service_type;
	__le32 length;
};

struct qcom_rpm_request {
	__le32 msg_id;
	__le32 flags;
	__le32 type;
	__le32 id;
	__le32 data_len;
};

struct qcom_rpm_message {
	__le32 msg_type;
	__le32 length;
	union {
		__le32 msg_id;
		struct {
			struct {} __empty_message;
			u8 message[0];
		};
	};
};

struct qcom_smd_rpm {
	struct rpmsg_endpoint *rpm_channel;
	struct device *dev;
	struct completion ack;
	struct mutex lock;
	int ack_status;
};

struct rockchip_grf_value;

struct rockchip_grf_info {
	const struct rockchip_grf_value *values;
	int num_values;
};

struct rockchip_grf_value {
	const char *desc;
	u32 reg;
	u32 val;
};

struct k3_soc_id {
	unsigned int id;
	const char *family_name;
};

struct imx_pgc_domain;

struct imx_pgc_regs;

struct imx_pgc_domain_data {
	const struct imx_pgc_domain *domains;
	size_t domains_num;
	const struct regmap_access_table *reg_access_table;
	const struct imx_pgc_regs *pgc_regs;
};

struct imx_pgc_domain {
	struct generic_pm_domain genpd;
	struct regmap *regmap;
	const struct imx_pgc_regs *regs;
	struct regulator *regulator;
	struct reset_control *reset;
	struct clk_bulk_data *clks;
	int num_clks;
	unsigned long pgc;
	const struct {
		u32 pxx;
		u32 map;
		u32 hskreq;
		u32 hskack;
	} bits;
	const int voltage;
	const bool keep_clocks;
	struct device *dev;
	unsigned int pgc_sw_pup_reg;
	unsigned int pgc_sw_pdn_reg;
};

struct imx_pgc_regs {
	u16 map;
	u16 pup;
	u16 pdn;
	u16 hsk;
};

struct grant_frames {
	xen_pfn_t *pfn;
	unsigned int count;
	void *vaddr;
};

struct gnttab_ops {
	unsigned int version;
	unsigned int grefs_per_grant_frame;
	int (*map_frames)(xen_pfn_t *, unsigned int);
	void (*unmap_frames)();
	void (*update_entry)(grant_ref_t, domid_t, unsigned long, unsigned int);
	int (*end_foreign_access_ref)(grant_ref_t);
	unsigned long (*read_frame)(grant_ref_t);
};

struct gnttab_free_callback {
	struct gnttab_free_callback *next;
	void (*fn)(void *);
	void *arg;
	u16 count;
};

typedef uint16_t grant_status_t;

struct grant_entry_v1 {
	uint16_t flags;
	domid_t domid;
	uint32_t frame;
};

struct grant_entry_header {
	uint16_t flags;
	domid_t domid;
};

union grant_entry_v2 {
	struct grant_entry_header hdr;
	struct {
		struct grant_entry_header hdr;
		uint32_t pad0;
		uint64_t frame;
	} full_page;
	struct {
		struct grant_entry_header hdr;
		uint16_t page_off;
		uint16_t length;
		uint64_t frame;
	} sub_page;
	struct {
		struct grant_entry_header hdr;
		domid_t trans_domid;
		uint16_t pad0;
		grant_ref_t gref;
	} transitive;
	uint32_t __spacer[4];
};

struct deferred_entry {
	struct list_head list;
	grant_ref_t ref;
	uint16_t warn_delay;
	struct page *page;
};

struct xen_page_foreign {
	domid_t domid;
	grant_ref_t gref;
};

struct gntab_unmap_queue_data;

typedef void (*gnttab_unmap_refs_done)(int, struct gntab_unmap_queue_data *);

struct gnttab_unmap_grant_ref;

struct gntab_unmap_queue_data {
	struct delayed_work gnttab_work;
	void *data;
	gnttab_unmap_refs_done done;
	struct gnttab_unmap_grant_ref *unmap_ops;
	struct gnttab_unmap_grant_ref *kunmap_ops;
	struct page **pages;
	unsigned int count;
	unsigned int age;
};

typedef uint32_t grant_handle_t;

struct gnttab_unmap_grant_ref {
	uint64_t host_addr;
	uint64_t dev_bus_addr;
	grant_handle_t handle;
	int16_t status;
};

struct gnttab_query_size {
	domid_t dom;
	uint32_t nr_frames;
	uint32_t max_nr_frames;
	int16_t status;
};

struct gnttab_page_cache {
	spinlock_t lock;
	struct list_head pages;
	unsigned int num_pages;
};

struct gnttab_map_grant_ref {
	uint64_t host_addr;
	uint32_t flags;
	grant_ref_t ref;
	domid_t dom;
	int16_t status;
	grant_handle_t handle;
	uint64_t dev_bus_addr;
};

struct gnttab_set_version {
	uint32_t version;
};

struct gnttab_copy_ptr {
	union {
		grant_ref_t ref;
		xen_pfn_t gmfn;
	} u;
	domid_t domid;
	uint16_t offset;
};

struct gnttab_copy {
	struct gnttab_copy_ptr source;
	struct gnttab_copy_ptr dest;
	uint16_t len;
	uint16_t flags;
	int16_t status;
};

struct unmap_refs_callback_data {
	struct completion completion;
	int result;
};

struct gnttab_setup_table {
	domid_t dom;
	uint32_t nr_frames;
	int16_t status;
	__guest_handle_xen_pfn_t frame_list;
};

struct xen_add_to_physmap {
	domid_t domid;
	uint16_t size;
	unsigned int space;
	xen_ulong_t idx;
	xen_pfn_t gpfn;
};

typedef struct {
	union {
		uint64_t *p;
		uint64_t q;
	};
} __guest_handle_uint64_t;

struct gnttab_get_status_frames {
	uint32_t nr_frames;
	domid_t dom;
	int16_t status;
	__guest_handle_uint64_t frame_list;
};

enum device_id {
	MAX8973 = 0,
	MAX77621 = 1,
};

struct max8973_regulator_platform_data {
	struct regulator_init_data *reg_init_data;
	unsigned long control_flags;
	unsigned long junction_temp_warning;
	bool enable_ext_control;
	int enable_gpio;
	int dvs_gpio;
	unsigned int dvs_def_state: 1;
};

struct max8973_chip {
	struct device *dev;
	struct regulator_desc desc;
	struct regmap *regmap;
	bool enable_external_control;
	int dvs_gpio;
	int lru_index[2];
	int curr_vout_val[2];
	int curr_vout_reg;
	int curr_gpio_val;
	struct regulator_ops ops;
	enum device_id id;
	int junction_temp_warning;
	int irq;
	struct thermal_zone_device *tz_device;
};

enum s2mps11_regulators {
	S2MPS11_LDO1 = 0,
	S2MPS11_LDO2 = 1,
	S2MPS11_LDO3 = 2,
	S2MPS11_LDO4 = 3,
	S2MPS11_LDO5 = 4,
	S2MPS11_LDO6 = 5,
	S2MPS11_LDO7 = 6,
	S2MPS11_LDO8 = 7,
	S2MPS11_LDO9 = 8,
	S2MPS11_LDO10 = 9,
	S2MPS11_LDO11 = 10,
	S2MPS11_LDO12 = 11,
	S2MPS11_LDO13 = 12,
	S2MPS11_LDO14 = 13,
	S2MPS11_LDO15 = 14,
	S2MPS11_LDO16 = 15,
	S2MPS11_LDO17 = 16,
	S2MPS11_LDO18 = 17,
	S2MPS11_LDO19 = 18,
	S2MPS11_LDO20 = 19,
	S2MPS11_LDO21 = 20,
	S2MPS11_LDO22 = 21,
	S2MPS11_LDO23 = 22,
	S2MPS11_LDO24 = 23,
	S2MPS11_LDO25 = 24,
	S2MPS11_LDO26 = 25,
	S2MPS11_LDO27 = 26,
	S2MPS11_LDO28 = 27,
	S2MPS11_LDO29 = 28,
	S2MPS11_LDO30 = 29,
	S2MPS11_LDO31 = 30,
	S2MPS11_LDO32 = 31,
	S2MPS11_LDO33 = 32,
	S2MPS11_LDO34 = 33,
	S2MPS11_LDO35 = 34,
	S2MPS11_LDO36 = 35,
	S2MPS11_LDO37 = 36,
	S2MPS11_LDO38 = 37,
	S2MPS11_BUCK1 = 38,
	S2MPS11_BUCK2 = 39,
	S2MPS11_BUCK3 = 40,
	S2MPS11_BUCK4 = 41,
	S2MPS11_BUCK5 = 42,
	S2MPS11_BUCK6 = 43,
	S2MPS11_BUCK7 = 44,
	S2MPS11_BUCK8 = 45,
	S2MPS11_BUCK9 = 46,
	S2MPS11_BUCK10 = 47,
	S2MPS11_REGULATOR_MAX = 48,
};

enum s2mps14_regulators {
	S2MPS14_LDO1 = 0,
	S2MPS14_LDO2 = 1,
	S2MPS14_LDO3 = 2,
	S2MPS14_LDO4 = 3,
	S2MPS14_LDO5 = 4,
	S2MPS14_LDO6 = 5,
	S2MPS14_LDO7 = 6,
	S2MPS14_LDO8 = 7,
	S2MPS14_LDO9 = 8,
	S2MPS14_LDO10 = 9,
	S2MPS14_LDO11 = 10,
	S2MPS14_LDO12 = 11,
	S2MPS14_LDO13 = 12,
	S2MPS14_LDO14 = 13,
	S2MPS14_LDO15 = 14,
	S2MPS14_LDO16 = 15,
	S2MPS14_LDO17 = 16,
	S2MPS14_LDO18 = 17,
	S2MPS14_LDO19 = 18,
	S2MPS14_LDO20 = 19,
	S2MPS14_LDO21 = 20,
	S2MPS14_LDO22 = 21,
	S2MPS14_LDO23 = 22,
	S2MPS14_LDO24 = 23,
	S2MPS14_LDO25 = 24,
	S2MPS14_BUCK1 = 25,
	S2MPS14_BUCK2 = 26,
	S2MPS14_BUCK3 = 27,
	S2MPS14_BUCK4 = 28,
	S2MPS14_BUCK5 = 29,
	S2MPS14_REGULATOR_MAX = 30,
};

enum S2MPU02_regulators {
	S2MPU02_LDO1 = 0,
	S2MPU02_LDO2 = 1,
	S2MPU02_LDO3 = 2,
	S2MPU02_LDO4 = 3,
	S2MPU02_LDO5 = 4,
	S2MPU02_LDO6 = 5,
	S2MPU02_LDO7 = 6,
	S2MPU02_LDO8 = 7,
	S2MPU02_LDO9 = 8,
	S2MPU02_LDO10 = 9,
	S2MPU02_LDO11 = 10,
	S2MPU02_LDO12 = 11,
	S2MPU02_LDO13 = 12,
	S2MPU02_LDO14 = 13,
	S2MPU02_LDO15 = 14,
	S2MPU02_LDO16 = 15,
	S2MPU02_LDO17 = 16,
	S2MPU02_LDO18 = 17,
	S2MPU02_LDO19 = 18,
	S2MPU02_LDO20 = 19,
	S2MPU02_LDO21 = 20,
	S2MPU02_LDO22 = 21,
	S2MPU02_LDO23 = 22,
	S2MPU02_LDO24 = 23,
	S2MPU02_LDO25 = 24,
	S2MPU02_LDO26 = 25,
	S2MPU02_LDO27 = 26,
	S2MPU02_LDO28 = 27,
	S2MPU02_BUCK1 = 28,
	S2MPU02_BUCK2 = 29,
	S2MPU02_BUCK3 = 30,
	S2MPU02_BUCK4 = 31,
	S2MPU02_BUCK5 = 32,
	S2MPU02_BUCK6 = 33,
	S2MPU02_BUCK7 = 34,
	S2MPU02_REGULATOR_MAX = 35,
};

struct of_regulator_match {
	const char *name;
	void *driver_data;
	struct regulator_init_data *init_data;
	struct device_node *of_node;
	const struct regulator_desc *desc;
};

struct s2mps11_info {
	int ramp_delay2;
	int ramp_delay34;
	int ramp_delay5;
	int ramp_delay16;
	int ramp_delay7810;
	int ramp_delay9;
	enum sec_device_type dev_type;
	unsigned long suspend_state[1];
	struct gpio_desc **ext_control_gpiod;
};

struct msm_dma {
	struct dma_chan *chan;
	enum dma_data_direction dir;
	dma_addr_t phys;
	unsigned char *virt;
	dma_cookie_t cookie;
	u32 enable_bit;
	unsigned int count;
	struct dma_async_tx_descriptor *desc;
};

struct msm_port {
	struct uart_port uart;
	char name[16];
	struct clk *clk;
	struct clk *pclk;
	unsigned int imr;
	int is_uartdm;
	unsigned int old_snap_state;
	bool break_detected;
	struct msm_dma tx_dma;
	struct msm_dma rx_dma;
};

struct msm_baud_map {
	u16 divisor;
	u8 code;
	u8 rxstale;
};

enum {
	UARTDM_1P1 = 1,
	UARTDM_1P2 = 2,
	UARTDM_1P3 = 3,
	UARTDM_1P4 = 4,
};

struct qcom_adm_peripheral_config {
	u32 crci;
	u32 mux;
};

struct bcm2835_rng_of_data {
	bool mask_interrupts;
};

struct bcm2835_rng_priv {
	struct hwrng rng;
	void *base;
	bool mask_interrupts;
	struct clk *clk;
	struct reset_control *reset;
};

enum bios_platform_class {
	BIOS_CLIENT = 0,
	BIOS_SERVER = 1,
};

struct client_hdr {
	u32 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct server_hdr {
	u16 reserved;
	u64 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct acpi_tcpa {
	struct acpi_table_header hdr;
	u16 platform_class;
	union {
		struct client_hdr client;
		struct server_hdr server;
	};
};

struct acpi_table_tpm2 {
	struct acpi_table_header header;
	u16 platform_class;
	u16 reserved;
	u64 control_address;
	u32 start_method;
} __attribute__((packed));

struct acpi_tpm2_phy {
	u8 start_method_specific[12];
	u32 log_area_minimum_length;
	u64 log_area_start_address;
};

enum tegra_icc_client_type {
	TEGRA_ICC_NONE = 0,
	TEGRA_ICC_NISO = 1,
	TEGRA_ICC_ISO_DISPLAY = 2,
	TEGRA_ICC_ISO_VI = 3,
	TEGRA_ICC_ISO_AUDIO = 4,
	TEGRA_ICC_ISO_VIFAL = 5,
};

struct tegra_smmu;

struct tegra_smmu_group_soc;

struct tegra_smmu_group {
	struct list_head list;
	struct tegra_smmu *smmu;
	const struct tegra_smmu_group_soc *soc;
	struct iommu_group *group;
	unsigned int swgroup;
};

struct tegra_mc;

struct tegra_smmu_soc;

struct tegra_smmu {
	void *regs;
	struct device *dev;
	struct tegra_mc *mc;
	const struct tegra_smmu_soc *soc;
	struct list_head groups;
	unsigned long pfn_mask;
	unsigned long tlb_mask;
	unsigned long *asids;
	struct mutex lock;
	struct list_head list;
	struct dentry *debugfs;
	struct iommu_device iommu;
};

struct tegra_mc_soc;

struct tegra_mc_timing;

struct tegra_mc {
	struct tegra_bpmp *bpmp;
	struct device *dev;
	struct tegra_smmu *smmu;
	void *regs;
	void *bcast_ch_regs;
	void **ch_regs;
	struct clk *clk;
	int irq;
	const struct tegra_mc_soc *soc;
	unsigned long tick;
	struct tegra_mc_timing *timings;
	unsigned int num_timings;
	unsigned int num_channels;
	bool bwmgr_mrq_supported;
	struct reset_controller_dev reset;
	struct icc_provider provider;
	spinlock_t lock;
	struct {
		struct dentry *root;
	} debugfs;
};

struct tegra_mc_client;

struct tegra_mc_reset_ops;

struct tegra_mc_reset;

struct tegra_mc_icc_ops;

struct tegra_mc_ops;

struct tegra_mc_soc {
	const struct tegra_mc_client *clients;
	unsigned int num_clients;
	const unsigned long *emem_regs;
	unsigned int num_emem_regs;
	unsigned int num_address_bits;
	unsigned int atom_size;
	unsigned int num_carveouts;
	u16 client_id_mask;
	u8 num_channels;
	const struct tegra_smmu_soc *smmu;
	u32 intmask;
	u32 ch_intmask;
	u32 global_intstatus_channel_shift;
	bool has_addr_hi_reg;
	const struct tegra_mc_reset_ops *reset_ops;
	const struct tegra_mc_reset *resets;
	unsigned int num_resets;
	const struct tegra_mc_icc_ops *icc_ops;
	const struct tegra_mc_ops *ops;
};

struct tegra_mc_client {
	unsigned int id;
	unsigned int bpmp_id;
	enum tegra_icc_client_type type;
	const char *name;
	union {
		unsigned int swgroup;
		unsigned int sid;
	};
	unsigned int fifo_size;
	struct {
		struct {
			unsigned int reg;
			unsigned int bit;
		} smmu;
		struct {
			unsigned int reg;
			unsigned int shift;
			unsigned int mask;
			unsigned int def;
		} la;
		struct {
			unsigned int override;
			unsigned int security;
		} sid;
	} regs;
};

struct tegra_smmu_swgroup;

struct tegra_smmu_soc {
	const struct tegra_mc_client *clients;
	unsigned int num_clients;
	const struct tegra_smmu_swgroup *swgroups;
	unsigned int num_swgroups;
	const struct tegra_smmu_group_soc *groups;
	unsigned int num_groups;
	bool supports_round_robin_arbitration;
	bool supports_request_limit;
	unsigned int num_tlb_lines;
	unsigned int num_asids;
};

struct tegra_smmu_swgroup {
	const char *name;
	unsigned int swgroup;
	unsigned int reg;
};

struct tegra_smmu_group_soc {
	const char *name;
	const unsigned int *swgroups;
	unsigned int num_swgroups;
};

struct tegra_mc_reset_ops {
	int (*hotreset_assert)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*hotreset_deassert)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*block_dma)(struct tegra_mc *, const struct tegra_mc_reset *);
	bool (*dma_idling)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*unblock_dma)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*reset_status)(struct tegra_mc *, const struct tegra_mc_reset *);
};

struct tegra_mc_reset {
	const char *name;
	unsigned long id;
	unsigned int control;
	unsigned int status;
	unsigned int reset;
	unsigned int bit;
};

struct tegra_mc_icc_ops {
	int (*set)(struct icc_node *, struct icc_node *);
	int (*aggregate)(struct icc_node *, u32, u32, u32, u32 *, u32 *);
	struct icc_node * (*xlate)(struct of_phandle_args *, void *);
	struct icc_node_data * (*xlate_extended)(struct of_phandle_args *, void *);
	int (*get_bw)(struct icc_node *, u32 *, u32 *);
};

struct tegra_mc_ops {
	int (*probe)(struct tegra_mc *);
	void (*remove)(struct tegra_mc *);
	irqreturn_t (*handle_irq)(int, void *);
	int (*probe_device)(struct tegra_mc *, struct device *);
};

struct tegra_mc_timing {
	unsigned long rate;
	u32 *emem_data;
};

struct tegra_smmu_as {
	struct iommu_domain domain;
	struct tegra_smmu *smmu;
	unsigned int use_count;
	spinlock_t lock;
	u32 *count;
	struct page **pts;
	struct page *pd;
	dma_addr_t pd_dma;
	unsigned int id;
	u32 attr;
};

typedef int (*regmap_hw_write)(void *, const void *, size_t);

typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);

struct regmap_async;

typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);

typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);

typedef int (*regmap_hw_reg_noinc_write)(void *, unsigned int, const void *, size_t);

typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);

typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);

typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);

typedef int (*regmap_hw_reg_noinc_read)(void *, unsigned int, void *, size_t);

typedef void (*regmap_hw_free_context)(void *);

typedef struct regmap_async * (*regmap_hw_async_alloc)();

struct regmap_bus {
	bool fast_io;
	bool free_on_exit;
	regmap_hw_write write;
	regmap_hw_gather_write gather_write;
	regmap_hw_async_write async_write;
	regmap_hw_reg_write reg_write;
	regmap_hw_reg_noinc_write reg_noinc_write;
	regmap_hw_reg_update_bits reg_update_bits;
	regmap_hw_read read;
	regmap_hw_reg_read reg_read;
	regmap_hw_reg_noinc_read reg_noinc_read;
	regmap_hw_free_context free_context;
	regmap_hw_async_alloc async_alloc;
	u8 read_flag_mask;
	enum regmap_endian reg_format_endian_default;
	enum regmap_endian val_format_endian_default;
	size_t max_raw_read;
	size_t max_raw_write;
};

struct regmap_async {
	struct list_head list;
	struct regmap *map;
	void *work_buf;
};

struct regmap_format {
	size_t buf_size;
	size_t reg_bytes;
	size_t pad_bytes;
	size_t val_bytes;
	s8 reg_shift;
	void (*format_write)(struct regmap *, unsigned int, unsigned int);
	void (*format_reg)(void *, unsigned int, unsigned int);
	void (*format_val)(void *, unsigned int, unsigned int);
	unsigned int (*parse_val)(const void *);
	void (*parse_inplace)(void *);
};

struct regcache_ops;

struct regmap {
	union {
		struct mutex mutex;
		struct {
			spinlock_t spinlock;
			unsigned long spinlock_flags;
		};
		struct {
			raw_spinlock_t raw_spinlock;
			unsigned long raw_spinlock_flags;
		};
	};
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	gfp_t alloc_flags;
	unsigned int reg_base;
	struct device *dev;
	void *work_buf;
	struct regmap_format format;
	const struct regmap_bus *bus;
	void *bus_context;
	const char *name;
	bool async;
	spinlock_t async_lock;
	wait_queue_head_t async_waitq;
	struct list_head async_list;
	struct list_head async_free;
	int async_ret;
	bool debugfs_disable;
	struct dentry *debugfs;
	const char *debugfs_name;
	unsigned int debugfs_reg_len;
	unsigned int debugfs_val_len;
	unsigned int debugfs_tot_len;
	struct list_head debugfs_off_cache;
	struct mutex cache_lock;
	unsigned int max_register;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	int (*read)(void *, const void *, size_t, void *, size_t);
	int (*write)(void *, const void *, size_t);
	bool defer_caching;
	unsigned long read_flag_mask;
	unsigned long write_flag_mask;
	int reg_shift;
	int reg_stride;
	int reg_stride_order;
	bool force_write_field;
	const struct regcache_ops *cache_ops;
	enum regcache_type cache_type;
	unsigned int cache_size_raw;
	unsigned int cache_word_size;
	unsigned int num_reg_defaults;
	unsigned int num_reg_defaults_raw;
	bool cache_only;
	bool cache_bypass;
	bool cache_free;
	struct reg_default *reg_defaults;
	const void *reg_defaults_raw;
	void *cache;
	bool cache_dirty;
	bool no_sync_defaults;
	struct reg_sequence *patch;
	int patch_regs;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	size_t max_raw_read;
	size_t max_raw_write;
	struct rb_root range_tree;
	void *selector_work_buf;
	struct hwspinlock *hwlock;
	bool can_sleep;
};

struct regcache_ops {
	const char *name;
	enum regcache_type type;
	int (*init)(struct regmap *);
	int (*exit)(struct regmap *);
	void (*debugfs_init)(struct regmap *);
	int (*read)(struct regmap *, unsigned int, unsigned int *);
	int (*write)(struct regmap *, unsigned int, unsigned int);
	int (*sync)(struct regmap *, unsigned int, unsigned int);
	int (*drop)(struct regmap *, unsigned int, unsigned int);
};

enum hi6421_type {
	HI6421 = 0,
	HI6421_V530 = 1,
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

enum ata_prot_flags {
	ATA_PROT_FLAG_PIO = 1,
	ATA_PROT_FLAG_DMA = 2,
	ATA_PROT_FLAG_NCQ = 4,
	ATA_PROT_FLAG_ATAPI = 8,
	ATA_PROT_UNKNOWN = 255,
	ATA_PROT_NODATA = 0,
	ATA_PROT_PIO = 1,
	ATA_PROT_DMA = 2,
	ATA_PROT_NCQ_NODATA = 4,
	ATA_PROT_NCQ = 6,
	ATAPI_PROT_NODATA = 8,
	ATAPI_PROT_PIO = 9,
	ATAPI_PROT_DMA = 10,
};

struct mtd_concat {
	struct mtd_info mtd;
	int num_subdev;
	struct mtd_info **subdev;
};

struct spi_device_id;

struct spi_driver {
	const struct spi_device_id *id_table;
	int (*probe)(struct spi_device *);
	void (*remove)(struct spi_device *);
	void (*shutdown)(struct spi_device *);
	struct device_driver driver;
};

struct spi_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct flash_info___2 {
	const char *name;
	uint16_t device_id;
	unsigned int page_size;
	unsigned int nr_pages;
	unsigned int erase_size;
};

struct sst25l_flash {
	struct spi_device *spi;
	struct mutex lock;
	struct mtd_info mtd;
};

struct flash_platform_data {
	char *name;
	struct mtd_partition *parts;
	unsigned int nr_parts;
	char *type;
};

struct spi_mem_driver {
	struct spi_driver spidrv;
	int (*probe)(struct spi_mem *);
	int (*remove)(struct spi_mem *);
	void (*shutdown)(struct spi_mem *);
};

struct cqspi_flash_pdata;

struct cqspi_st;

struct cqspi_driver_platdata {
	u32 hwcaps_mask;
	u8 quirks;
	int (*indirect_read_dma)(struct cqspi_flash_pdata *, u_char *, loff_t, size_t);
	u32 (*get_dma_status)(struct cqspi_st *);
	int (*jh7110_clk_init)(struct platform_device *, struct cqspi_st *);
};

struct cqspi_flash_pdata {
	struct cqspi_st *cqspi;
	u32 clk_rate;
	u32 read_delay;
	u32 tshsl_ns;
	u32 tsd2d_ns;
	u32 tchsh_ns;
	u32 tslch_ns;
	u8 cs;
};

struct cqspi_st {
	struct platform_device *pdev;
	struct spi_controller *host;
	struct clk *clk;
	struct clk *clks[2];
	unsigned int sclk;
	void *iobase;
	void *ahb_base;
	resource_size_t ahb_size;
	struct completion transfer_complete;
	struct dma_chan *rx_chan;
	struct completion rx_dma_complete;
	dma_addr_t mmap_phys_base;
	int current_cs;
	unsigned long master_ref_clk_hz;
	bool is_decoded_cs;
	u32 fifo_depth;
	u32 fifo_width;
	u32 num_chipselect;
	bool rclk_en;
	u32 trigger_address;
	u32 wr_delay;
	bool use_direct_mode;
	bool use_direct_mode_wr;
	struct cqspi_flash_pdata f_pdata[16];
	bool use_dma_read;
	u32 pd_dev_id;
	bool wr_completion;
	bool slow_sram;
	bool apb_ahb_hazard;
	bool is_jh7110;
};

enum {
	CLK_QSPI_APB = 0,
	CLK_QSPI_AHB = 1,
	CLK_QSPI_NUM = 2,
};

enum ospi_mux_select_type {
	PM_OSPI_MUX_SEL_DMA = 0,
	PM_OSPI_MUX_SEL_LINEAR = 1,
};

struct fec_stat {
	char name[32];
	u16 offset;
};

struct fec_devinfo {
	u32 quirks;
};

enum fec_txbuf_type {
	FEC_TXBUF_T_SKB = 0,
	FEC_TXBUF_T_XDP_NDO = 1,
	FEC_TXBUF_T_XDP_TX = 2,
};

enum {
	RX_XDP_REDIRECT = 0,
	RX_XDP_PASS = 1,
	RX_XDP_DROP = 2,
	RX_XDP_TX = 3,
	RX_XDP_TX_ERRORS = 4,
	TX_XDP_XMIT = 5,
	TX_XDP_XMIT_ERRORS = 6,
	XDP_STATS_TOTAL = 7,
};

struct bufdesc {
	__le16 cbd_datlen;
	__le16 cbd_sc;
	__le32 cbd_bufaddr;
};

struct bufdesc_ex {
	struct bufdesc desc;
	__le32 cbd_esc;
	__le32 cbd_prot;
	__le32 cbd_bdu;
	__le32 ts;
	__le16 res0[4];
};

struct fec_stop_mode_gpr {
	struct regmap *gpr;
	u8 reg;
	u8 bit;
};

struct fec_enet_priv_tx_q;

struct fec_enet_priv_rx_q;

struct fec_enet_private {
	void *hwp;
	struct net_device *netdev;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_ref;
	struct clk *clk_enet_out;
	struct clk *clk_ptp;
	struct clk *clk_2x_txclk;
	bool ptp_clk_on;
	struct mutex ptp_clk_mutex;
	unsigned int num_tx_queues;
	unsigned int num_rx_queues;
	struct fec_enet_priv_tx_q *tx_queue[3];
	struct fec_enet_priv_rx_q *rx_queue[3];
	unsigned int total_tx_ring_size;
	unsigned int total_rx_ring_size;
	struct platform_device *pdev;
	int dev_id;
	struct mii_bus *mii_bus;
	uint phy_speed;
	phy_interface_t phy_interface;
	struct device_node *phy_node;
	bool rgmii_txc_dly;
	bool rgmii_rxc_dly;
	bool rpm_active;
	int link;
	int full_duplex;
	int speed;
	int irq[3];
	bool bufdesc_ex;
	int pause_flag;
	int wol_flag;
	int wake_irq;
	u32 quirks;
	struct napi_struct napi;
	int csum_flags;
	struct work_struct tx_timeout_work;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_caps;
	spinlock_t tmreg_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	u32 cycle_speed;
	int hwts_rx_en;
	int hwts_tx_en;
	struct delayed_work time_keep;
	struct regulator *reg_phy;
	struct fec_stop_mode_gpr stop_gpr;
	struct pm_qos_request pm_qos_req;
	unsigned int tx_align;
	unsigned int rx_align;
	unsigned int rx_pkts_itr;
	unsigned int rx_time_itr;
	unsigned int tx_pkts_itr;
	unsigned int tx_time_itr;
	unsigned int itr_clk_rate;
	struct ethtool_eee eee;
	unsigned int clk_ref_rate;
	unsigned int ptp_inc;
	int pps_channel;
	unsigned int reload_period;
	int pps_enable;
	unsigned int next_counter;
	struct hrtimer perout_timer;
	u64 perout_stime;
	struct imx_sc_ipc *ipc_handle;
	struct bpf_prog *xdp_prog;
	u64 ethtool_stats[0];
};

struct bufdesc_prop {
	int qid;
	struct bufdesc *base;
	struct bufdesc *last;
	struct bufdesc *cur;
	void *reg_desc_active;
	dma_addr_t dma;
	unsigned short ring_size;
	unsigned char dsize;
	unsigned char dsize_log2;
};

struct fec_tx_buffer {
	void *buf_p;
	enum fec_txbuf_type type;
};

struct fec_enet_priv_tx_q {
	struct bufdesc_prop bd;
	unsigned char *tx_bounce[1024];
	struct fec_tx_buffer tx_buf[1024];
	unsigned short tx_stop_threshold;
	unsigned short tx_wake_threshold;
	struct bufdesc *dirty_tx;
	char *tso_hdrs;
	dma_addr_t tso_hdrs_dma;
};

struct fec_enet_priv_txrx_info {
	int offset;
	struct page *page;
	struct sk_buff *skb;
};

struct fec_enet_priv_rx_q {
	struct bufdesc_prop bd;
	struct fec_enet_priv_txrx_info rx_skb_info[256];
	struct page_pool *page_pool;
	struct xdp_rxq_info xdp_rxq;
	u32 stats[7];
	u8 id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct fec_dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
};

struct fec_platform_data {
	phy_interface_t phy;
	unsigned char mac[6];
	void (*sleep_mode_enable)(int);
};

struct page_pool_stats {
	struct page_pool_alloc_stats alloc_stats;
	struct page_pool_recycle_stats recycle_stats;
};

struct mac_stats_string {
	const char desc[32];
	unsigned long offset;
};

enum mac_mode {
	MAC_MODE_INVALID = 0,
	MAC_MODE_MII_10 = 65546,
	MAC_MODE_MII_100 = 65636,
	MAC_MODE_RMII_10 = 131082,
	MAC_MODE_RMII_100 = 131172,
	MAC_MODE_SMII_10 = 196618,
	MAC_MODE_SMII_100 = 196708,
	MAC_MODE_GMII_1000 = 263144,
	MAC_MODE_RGMII_10 = 327690,
	MAC_MODE_RGMII_100 = 327780,
	MAC_MODE_RGMII_1000 = 328680,
	MAC_MODE_TBI_1000 = 394216,
	MAC_MODE_RTBI_1000 = 459752,
	MAC_MODE_SGMII_10 = 524298,
	MAC_MODE_SGMII_100 = 524388,
	MAC_MODE_SGMII_1000 = 525288,
	MAC_MODE_XGMII_10000 = 599824,
	MAC_MODE_QSGMII_1000 = 656360,
};

enum mac_commom_mode {
	MAC_COMM_MODE_NONE = 0,
	MAC_COMM_MODE_RX = 1,
	MAC_COMM_MODE_TX = 2,
	MAC_COMM_MODE_RX_AND_TX = 3,
};

enum mac_speed {
	MAC_SPEED_10 = 10,
	MAC_SPEED_100 = 100,
	MAC_SPEED_1000 = 1000,
	MAC_SPEED_10000 = 10000,
};

enum hns_gmac_duplex_mdoe {
	GMAC_HALF_DUPLEX_MODE = 0,
	GMAC_FULL_DUPLEX_MODE = 1,
};

enum hns_port_mode {
	GMAC_10M_MII = 0,
	GMAC_100M_MII = 1,
	GMAC_1000M_GMII = 2,
	GMAC_10M_RGMII = 3,
	GMAC_100M_RGMII = 4,
	GMAC_1000M_RGMII = 5,
	GMAC_10M_SGMII = 6,
	GMAC_100M_SGMII = 7,
	GMAC_1000M_SGMII = 8,
	GMAC_10000M_SGMII = 9,
};

struct mac_info;

struct mac_driver {
	void (*mac_init)(void *);
	void (*mac_free)(void *);
	void (*mac_enable)(void *, enum mac_commom_mode);
	void (*mac_disable)(void *, enum mac_commom_mode);
	void (*set_mac_addr)(void *, const char *);
	int (*adjust_link)(void *, enum mac_speed, u32);
	bool (*need_adjust_link)(void *, enum mac_speed, int);
	void (*set_an_mode)(void *, u8);
	int (*config_loopback)(void *, enum hnae_loop, u8);
	void (*config_max_frame_length)(void *, u16);
	void (*config_pad_and_crc)(void *, u8);
	void (*set_tx_auto_pause_frames)(void *, u16);
	void (*set_promiscuous)(void *, u8);
	void (*mac_pausefrm_cfg)(void *, u32, u32);
	void (*autoneg_stat)(void *, u32 *);
	int (*set_pause_enable)(void *, u32, u32);
	void (*get_pause_enable)(void *, u32 *, u32 *);
	void (*get_link_status)(void *, u32 *);
	void (*get_regs)(void *, void *);
	int (*get_regs_count)();
	void (*get_strings)(u32, u8 *);
	int (*get_sset_count)(int);
	void (*get_ethtool_stats)(void *, u64 *);
	void (*get_info)(void *, struct mac_info *);
	void (*update_stats)(void *);
	int (*wait_fifo_clean)(void *);
	enum mac_mode mac_mode;
	u8 mac_id;
	struct hns_mac_cb *mac_cb;
	u8 *io_base;
	unsigned int mac_en_flg;
	unsigned int virt_dev_num;
	struct device *dev;
};

struct mac_info {
	u16 speed;
	u8 duplex;
	u8 auto_neg;
	enum hnae_loop loop_mode;
	u8 tx_pause_en;
	u8 tx_pause_time;
	u8 rx_pause_en;
	u8 pad_and_crc_en;
	u8 promiscuous_en;
	u8 port_en;
};

struct hns_gmac_port_mode_cfg {
	enum hns_port_mode port_mode;
	u32 max_frm_size;
	u32 short_runts_thr;
	u32 pad_enable;
	u32 crc_add;
	u32 an_enable;
	u32 runt_pkt_en;
	u32 strip_pad_en;
};

struct mac_params {
	char addr[6];
	u8 *vaddr;
	struct device *dev;
	u8 mac_id;
	enum mac_mode mac_mode;
};

struct sky2_stat {
	char name[32];
	u16 offset;
};

enum {
	PCI_DEV_REG1 = 64,
	PCI_DEV_REG2 = 68,
	PCI_DEV_STATUS = 124,
	PCI_DEV_REG3 = 128,
	PCI_DEV_REG4 = 132,
	PCI_DEV_REG5 = 136,
	PCI_CFG_REG_0 = 144,
	PCI_CFG_REG_1 = 148,
	PSM_CONFIG_REG0 = 152,
	PSM_CONFIG_REG1 = 156,
	PSM_CONFIG_REG2 = 352,
	PSM_CONFIG_REG3 = 356,
	PSM_CONFIG_REG4 = 360,
	PCI_LDO_CTRL = 188,
};

enum csr_regs {
	B0_RAP = 0,
	B0_CTST = 4,
	B0_POWER_CTRL = 7,
	B0_ISRC = 8,
	B0_IMSK = 12,
	B0_HWE_ISRC = 16,
	B0_HWE_IMSK = 20,
	B0_Y2_SP_ISRC2 = 28,
	B0_Y2_SP_ISRC3 = 32,
	B0_Y2_SP_EISR = 36,
	B0_Y2_SP_LISR = 40,
	B0_Y2_SP_ICR = 44,
	B2_MAC_1 = 256,
	B2_MAC_2 = 264,
	B2_MAC_3 = 272,
	B2_CONN_TYP = 280,
	B2_PMD_TYP = 281,
	B2_MAC_CFG = 282,
	B2_CHIP_ID = 283,
	B2_E_0 = 284,
	B2_Y2_CLK_GATE = 285,
	B2_Y2_HW_RES = 286,
	B2_E_3 = 287,
	B2_Y2_CLK_CTRL = 288,
	B2_TI_INI = 304,
	B2_TI_VAL = 308,
	B2_TI_CTRL = 312,
	B2_TI_TEST = 313,
	B2_TST_CTRL1 = 344,
	B2_TST_CTRL2 = 345,
	B2_GP_IO = 348,
	B2_I2C_CTRL = 352,
	B2_I2C_DATA = 356,
	B2_I2C_IRQ = 360,
	B2_I2C_SW = 364,
	Y2_PEX_PHY_DATA = 368,
	Y2_PEX_PHY_ADDR = 370,
	B3_RAM_ADDR = 384,
	B3_RAM_DATA_LO = 388,
	B3_RAM_DATA_HI = 392,
	B3_RI_WTO_R1 = 400,
	B3_RI_WTO_XA1 = 401,
	B3_RI_WTO_XS1 = 402,
	B3_RI_RTO_R1 = 403,
	B3_RI_RTO_XA1 = 404,
	B3_RI_RTO_XS1 = 405,
	B3_RI_WTO_R2 = 406,
	B3_RI_WTO_XA2 = 407,
	B3_RI_WTO_XS2 = 408,
	B3_RI_RTO_R2 = 409,
	B3_RI_RTO_XA2 = 410,
	B3_RI_RTO_XS2 = 411,
	B3_RI_TO_VAL = 412,
	B3_RI_CTRL = 416,
	B3_RI_TEST = 418,
	B3_MA_TOINI_RX1 = 432,
	B3_MA_TOINI_RX2 = 433,
	B3_MA_TOINI_TX1 = 434,
	B3_MA_TOINI_TX2 = 435,
	B3_MA_TOVAL_RX1 = 436,
	B3_MA_TOVAL_RX2 = 437,
	B3_MA_TOVAL_TX1 = 438,
	B3_MA_TOVAL_TX2 = 439,
	B3_MA_TO_CTRL = 440,
	B3_MA_TO_TEST = 442,
	B3_MA_RCINI_RX1 = 448,
	B3_MA_RCINI_RX2 = 449,
	B3_MA_RCINI_TX1 = 450,
	B3_MA_RCINI_TX2 = 451,
	B3_MA_RCVAL_RX1 = 452,
	B3_MA_RCVAL_RX2 = 453,
	B3_MA_RCVAL_TX1 = 454,
	B3_MA_RCVAL_TX2 = 455,
	B3_MA_RC_CTRL = 456,
	B3_MA_RC_TEST = 458,
	B3_PA_TOINI_RX1 = 464,
	B3_PA_TOINI_RX2 = 468,
	B3_PA_TOINI_TX1 = 472,
	B3_PA_TOINI_TX2 = 476,
	B3_PA_TOVAL_RX1 = 480,
	B3_PA_TOVAL_RX2 = 484,
	B3_PA_TOVAL_TX1 = 488,
	B3_PA_TOVAL_TX2 = 492,
	B3_PA_CTRL = 496,
	B3_PA_TEST = 498,
	Y2_CFG_SPC = 7168,
	Y2_CFG_AER = 7424,
};

enum {
	Y2_VMAIN_AVAIL = 131072,
	Y2_VAUX_AVAIL = 65536,
	Y2_HW_WOL_ON = 32768,
	Y2_HW_WOL_OFF = 16384,
	Y2_ASF_ENABLE = 8192,
	Y2_ASF_DISABLE = 4096,
	Y2_CLK_RUN_ENA = 2048,
	Y2_CLK_RUN_DIS = 1024,
	Y2_LED_STAT_ON = 512,
	Y2_LED_STAT_OFF = 256,
	CS_ST_SW_IRQ = 128,
	CS_CL_SW_IRQ = 64,
	CS_STOP_DONE = 32,
	CS_STOP_MAST = 16,
	CS_MRST_CLR = 8,
	CS_MRST_SET = 4,
	CS_RST_CLR = 2,
	CS_RST_SET = 1,
};

enum {
	CFG_CHIP_R_MSK = 240,
	CFG_DIS_M2_CLK = 2,
	CFG_SNG_MAC = 1,
};

enum {
	CHIP_ID_YUKON_XL = 179,
	CHIP_ID_YUKON_EC_U = 180,
	CHIP_ID_YUKON_EX = 181,
	CHIP_ID_YUKON_EC = 182,
	CHIP_ID_YUKON_FE = 183,
	CHIP_ID_YUKON_FE_P = 184,
	CHIP_ID_YUKON_SUPR = 185,
	CHIP_ID_YUKON_UL_2 = 186,
	CHIP_ID_YUKON_OPT = 188,
	CHIP_ID_YUKON_PRM = 189,
	CHIP_ID_YUKON_OP_2 = 190,
};

enum yukon_xl_rev {
	CHIP_REV_YU_XL_A0 = 0,
	CHIP_REV_YU_XL_A1 = 1,
	CHIP_REV_YU_XL_A2 = 2,
	CHIP_REV_YU_XL_A3 = 3,
};

enum yukon_ex_rev {
	CHIP_REV_YU_EX_A0 = 1,
	CHIP_REV_YU_EX_B0 = 2,
};

enum yukon_ec_rev {
	CHIP_REV_YU_EC_A1 = 0,
	CHIP_REV_YU_EC_A2 = 1,
	CHIP_REV_YU_EC_A3 = 2,
};

enum yukon_fe_p_rev {
	CHIP_REV_YU_FE2_A0 = 0,
};

enum yukon_supr_rev {
	CHIP_REV_YU_SU_A0 = 0,
	CHIP_REV_YU_SU_B0 = 1,
	CHIP_REV_YU_SU_B1 = 3,
};

enum {
	CFG_LED_MODE_MSK = 28,
	CFG_LINK_2_AVAIL = 2,
	CFG_LINK_1_AVAIL = 1,
};

enum {
	Y2_STATUS_LNK2_INAC = 128,
	Y2_CLK_GAT_LNK2_DIS = 64,
	Y2_COR_CLK_LNK2_DIS = 32,
	Y2_PCI_CLK_LNK2_DIS = 16,
	Y2_STATUS_LNK1_INAC = 8,
	Y2_CLK_GAT_LNK1_DIS = 4,
	Y2_COR_CLK_LNK1_DIS = 2,
	Y2_PCI_CLK_LNK1_DIS = 1,
};

enum {
	Y2_IS_TIST_OV = 536870912,
	Y2_IS_SENSOR = 268435456,
	Y2_IS_MST_ERR = 134217728,
	Y2_IS_IRQ_STAT = 67108864,
	Y2_IS_PCI_EXP = 33554432,
	Y2_IS_PCI_NEXP = 16777216,
	Y2_IS_PAR_RD2 = 8192,
	Y2_IS_PAR_WR2 = 4096,
	Y2_IS_PAR_MAC2 = 2048,
	Y2_IS_PAR_RX2 = 1024,
	Y2_IS_TCP_TXS2 = 512,
	Y2_IS_TCP_TXA2 = 256,
	Y2_IS_PAR_RD1 = 32,
	Y2_IS_PAR_WR1 = 16,
	Y2_IS_PAR_MAC1 = 8,
	Y2_IS_PAR_RX1 = 4,
	Y2_IS_TCP_TXS1 = 2,
	Y2_IS_TCP_TXA1 = 1,
	Y2_HWE_L1_MASK = 63,
	Y2_HWE_L2_MASK = 16128,
	Y2_HWE_ALL_MASK = 738213695,
};

enum {
	CPU_WDOG = 3656,
	CPU_CNTR = 3660,
	CPU_TIM = 3664,
	CPU_AHB_ADDR = 3668,
	CPU_AHB_WDATA = 3672,
	CPU_AHB_RDATA = 3676,
	HCU_MAP_BASE = 3680,
	CPU_AHB_CTRL = 3684,
	HCU_CCSR = 3688,
	HCU_HCSR = 3692,
};

enum {
	HCU_CCSR_SMBALERT_MONITOR = 134217728,
	HCU_CCSR_CPU_SLEEP = 67108864,
	HCU_CCSR_CS_TO = 33554432,
	HCU_CCSR_WDOG = 16777216,
	HCU_CCSR_CLR_IRQ_HOST = 131072,
	HCU_CCSR_SET_IRQ_HCU = 65536,
	HCU_CCSR_AHB_RST = 512,
	HCU_CCSR_CPU_RST_MODE = 256,
	HCU_CCSR_SET_SYNC_CPU = 32,
	HCU_CCSR_CPU_CLK_DIVIDE_MSK = 24,
	HCU_CCSR_CPU_CLK_DIVIDE_BASE = 8,
	HCU_CCSR_OS_PRSNT = 4,
	HCU_CCSR_UC_STATE_MSK = 3,
	HCU_CCSR_UC_STATE_BASE = 1,
	HCU_CCSR_ASF_RESET = 0,
	HCU_CCSR_ASF_HALTED = 2,
	HCU_CCSR_ASF_RUNNING = 1,
};

enum {
	B28_Y2_SMB_CONFIG = 3648,
	B28_Y2_SMB_CSD_REG = 3652,
	B28_Y2_ASF_IRQ_V_BASE = 3680,
	B28_Y2_ASF_STAT_CMD = 3688,
	B28_Y2_ASF_HOST_COM = 3692,
	B28_Y2_DATA_REG_1 = 3696,
	B28_Y2_DATA_REG_2 = 3700,
	B28_Y2_DATA_REG_3 = 3704,
	B28_Y2_DATA_REG_4 = 3708,
};

enum {
	Y2_ASF_OS_PRES = 16,
	Y2_ASF_RESET = 8,
	Y2_ASF_RUNNING = 4,
	Y2_ASF_CLR_HSTI = 2,
	Y2_ASF_IRQ = 1,
	Y2_ASF_UC_STATE = 12,
	Y2_ASF_CLK_HALT = 0,
};

enum {
	TST_FRC_DPERR_MR = 128,
	TST_FRC_DPERR_MW = 64,
	TST_FRC_DPERR_TR = 32,
	TST_FRC_DPERR_TW = 16,
	TST_FRC_APERR_M = 8,
	TST_FRC_APERR_T = 4,
	TST_CFG_WRITE_ON = 2,
	TST_CFG_WRITE_OFF = 1,
};

enum {
	GMAC_CTRL = 3840,
	GPHY_CTRL = 3844,
	GMAC_IRQ_SRC = 3848,
	GMAC_IRQ_MSK = 3852,
	GMAC_LINK_CTRL = 3856,
	WOL_CTRL_STAT = 3872,
	WOL_MATCH_CTL = 3874,
	WOL_MATCH_RES = 3875,
	WOL_MAC_ADDR = 3876,
	WOL_PATT_RPTR = 3884,
	WOL_PATT_LEN_LO = 3888,
	WOL_PATT_LEN_HI = 3892,
	WOL_PATT_CNT_0 = 3896,
	WOL_PATT_CNT_4 = 3900,
};

enum {
	GMLC_RST_CLR = 2,
	GMLC_RST_SET = 1,
};

enum {
	GMC_SET_RST = 32768,
	GMC_SEC_RST_OFF = 16384,
	GMC_BYP_MACSECRX_ON = 8192,
	GMC_BYP_MACSECRX_OFF = 4096,
	GMC_BYP_MACSECTX_ON = 2048,
	GMC_BYP_MACSECTX_OFF = 1024,
	GMC_BYP_RETR_ON = 512,
	GMC_BYP_RETR_OFF = 256,
	GMC_H_BURST_ON = 128,
	GMC_H_BURST_OFF = 64,
	GMC_F_LOOPB_ON = 32,
	GMC_F_LOOPB_OFF = 16,
	GMC_PAUSE_ON = 8,
	GMC_PAUSE_OFF = 4,
	GMC_RST_CLR = 2,
	GMC_RST_SET = 1,
};

enum pci_dev_reg_3 {
	P_CLK_ASF_REGS_DIS = 262144,
	P_CLK_COR_REGS_D0_DIS = 131072,
	P_CLK_MACSEC_DIS = 131072,
	P_CLK_PCI_REGS_D0_DIS = 65536,
	P_CLK_COR_YTB_ARB_DIS = 32768,
	P_CLK_MAC_LNK1_D3_DIS = 16384,
	P_CLK_COR_LNK1_D0_DIS = 8192,
	P_CLK_MAC_LNK1_D0_DIS = 4096,
	P_CLK_COR_LNK1_D3_DIS = 2048,
	P_CLK_PCI_MST_ARB_DIS = 1024,
	P_CLK_COR_REGS_D3_DIS = 512,
	P_CLK_PCI_REGS_D3_DIS = 256,
	P_CLK_REF_LNK1_GM_DIS = 128,
	P_CLK_COR_LNK1_GM_DIS = 64,
	P_CLK_PCI_COMMON_DIS = 32,
	P_CLK_COR_COMMON_DIS = 16,
	P_CLK_PCI_LNK1_BMU_DIS = 8,
	P_CLK_COR_LNK1_BMU_DIS = 4,
	P_CLK_PCI_LNK1_BIU_DIS = 2,
	P_CLK_COR_LNK1_BIU_DIS = 1,
	PCIE_OUR3_WOL_D3_COLD_SET = 406548,
};

enum {
	PEX_RD_ACCESS = -2147483648,
	PEX_DB_ACCESS = 1073741824,
};

enum {
	PSM_CONFIG_REG4_TIMER_PHY_LINK_DETECT_MSK = 240,
	PSM_CONFIG_REG4_TIMER_PHY_LINK_DETECT_BASE = 4,
	PSM_CONFIG_REG4_DEBUG_TIMER = 2,
	PSM_CONFIG_REG4_RST_PHY_LINK_DETECT = 1,
};

enum yukon_prm_rev {
	CHIP_REV_YU_PRM_Z1 = 1,
	CHIP_REV_YU_PRM_A0 = 2,
};

enum {
	GPC_TX_PAUSE = 1073741824,
	GPC_RX_PAUSE = 536870912,
	GPC_SPEED = 402653184,
	GPC_LINK = 67108864,
	GPC_DUPLEX = 33554432,
	GPC_CLOCK = 16777216,
	GPC_PDOWN = 8388608,
	GPC_TSTMODE = 4194304,
	GPC_REG18 = 2097152,
	GPC_REG12SEL = 1572864,
	GPC_REG18SEL = 393216,
	GPC_SPILOCK = 65536,
	GPC_LEDMUX = 49152,
	GPC_INTPOL = 8192,
	GPC_DETECT = 4096,
	GPC_1000HD = 2048,
	GPC_SLAVE = 1024,
	GPC_PAUSE = 512,
	GPC_LEDCTL = 192,
	GPC_RST_CLR = 2,
	GPC_RST_SET = 1,
};

enum {
	PHY_M_FC_AUTO_SEL = 32768,
	PHY_M_FC_AN_REG_ACC = 16384,
	PHY_M_FC_RESOLUTION = 8192,
	PHY_M_SER_IF_AN_BP = 4096,
	PHY_M_SER_IF_BP_ST = 2048,
	PHY_M_IRQ_POLARITY = 1024,
	PHY_M_DIS_AUT_MED = 512,
	PHY_M_UNDOC1 = 128,
	PHY_M_DTE_POW_STAT = 16,
	PHY_M_MODE_MASK = 15,
};

enum {
	TIM_START = 4,
	TIM_STOP = 2,
	TIM_CLR_IRQ = 1,
};

enum {
	B28_DPT_INI = 3584,
	B28_DPT_VAL = 3588,
	B28_DPT_CTRL = 3592,
	B28_DPT_TST = 3594,
};

enum {
	DPT_START = 2,
	DPT_STOP = 1,
};

enum {
	GMAC_TI_ST_VAL = 3604,
	GMAC_TI_ST_CTRL = 3608,
	GMAC_TI_ST_TST = 3610,
};

enum {
	GMT_ST_START = 4,
	GMT_ST_STOP = 2,
	GMT_ST_CLR_IRQ = 1,
};

enum {
	TXA_ITI_INI = 512,
	TXA_ITI_VAL = 516,
	TXA_LIM_INI = 520,
	TXA_LIM_VAL = 524,
	TXA_CTRL = 528,
	TXA_TEST = 529,
	TXA_STAT = 530,
	RSS_KEY = 544,
	RSS_CFG = 584,
};

enum {
	TXA_ENA_FSYNC = 128,
	TXA_DIS_FSYNC = 64,
	TXA_ENA_ALLOC = 32,
	TXA_DIS_ALLOC = 16,
	TXA_START_RC = 8,
	TXA_STOP_RC = 4,
	TXA_ENA_ARB = 2,
	TXA_DIS_ARB = 1,
};

enum {
	RI_CLR_RD_PERR = 512,
	RI_CLR_WR_PERR = 256,
	RI_RST_CLR = 2,
	RI_RST_SET = 1,
};

enum {
	STAT_CTRL = 3712,
	STAT_LAST_IDX = 3716,
	STAT_LIST_ADDR_LO = 3720,
	STAT_LIST_ADDR_HI = 3724,
	STAT_TXA1_RIDX = 3728,
	STAT_TXS1_RIDX = 3730,
	STAT_TXA2_RIDX = 3732,
	STAT_TXS2_RIDX = 3734,
	STAT_TX_IDX_TH = 3736,
	STAT_PUT_IDX = 3740,
	STAT_FIFO_WP = 3744,
	STAT_FIFO_RP = 3748,
	STAT_FIFO_RSP = 3750,
	STAT_FIFO_LEVEL = 3752,
	STAT_FIFO_SHLVL = 3754,
	STAT_FIFO_WM = 3756,
	STAT_FIFO_ISR_WM = 3757,
	STAT_LEV_TIMER_INI = 3760,
	STAT_LEV_TIMER_CNT = 3764,
	STAT_LEV_TIMER_CTRL = 3768,
	STAT_LEV_TIMER_TEST = 3769,
	STAT_TX_TIMER_INI = 3776,
	STAT_TX_TIMER_CNT = 3780,
	STAT_TX_TIMER_CTRL = 3784,
	STAT_TX_TIMER_TEST = 3785,
	STAT_ISR_TIMER_INI = 3792,
	STAT_ISR_TIMER_CNT = 3796,
	STAT_ISR_TIMER_CTRL = 3800,
	STAT_ISR_TIMER_TEST = 3801,
};

enum {
	SC_STAT_CLR_IRQ = 16,
	SC_STAT_OP_ON = 8,
	SC_STAT_OP_OFF = 4,
	SC_STAT_RST_CLR = 2,
	SC_STAT_RST_SET = 1,
};

enum {
	PC_VAUX_ENA = 128,
	PC_VAUX_DIS = 64,
	PC_VCC_ENA = 32,
	PC_VCC_DIS = 16,
	PC_VAUX_ON = 8,
	PC_VAUX_OFF = 4,
	PC_VCC_ON = 2,
	PC_VCC_OFF = 1,
};

enum {
	Y2_CLK_DIV_VAL_MSK = 16711680,
	Y2_CLK_DIV_VAL2_MSK = 14680064,
	Y2_CLK_SELECT2_MSK = 2031616,
	Y2_CLK_DIV_ENA = 2,
	Y2_CLK_DIV_DIS = 1,
};

enum pci_dev_reg_4 {
	P_PEX_LTSSM_STAT_MSK = 4261412864,
	P_PEX_LTSSM_L1_STAT = 52,
	P_PEX_LTSSM_DET_STAT = 1,
	P_TIMER_VALUE_MSK = 16711680,
	P_FORCE_ASPM_REQUEST = 32768,
	P_ASPM_GPHY_LINK_DOWN = 16384,
	P_ASPM_INT_FIFO_EMPTY = 8192,
	P_ASPM_CLKRUN_REQUEST = 4096,
	P_ASPM_FORCE_CLKREQ_ENA = 16,
	P_ASPM_CLKREQ_PAD_CTL = 8,
	P_ASPM_A1_MODE_SELECT = 4,
	P_CLK_GATE_PEX_UNIT_ENA = 2,
	P_CLK_GATE_ROOT_COR_ENA = 1,
	P_ASPM_CONTROL_MSK = 61440,
};

enum pci_dev_reg_5 {
	P_CTL_DIV_CORE_CLK_ENA = -2147483648,
	P_CTL_SRESET_VMAIN_AV = 1073741824,
	P_CTL_BYPASS_VMAIN_AV = 536870912,
	P_CTL_TIM_VMAIN_AV_MSK = 402653184,
	P_REL_PCIE_RST_DE_ASS = 67108864,
	P_REL_GPHY_REC_PACKET = 33554432,
	P_REL_INT_FIFO_N_EMPTY = 16777216,
	P_REL_MAIN_PWR_AVAIL = 8388608,
	P_REL_CLKRUN_REQ_REL = 4194304,
	P_REL_PCIE_RESET_ASS = 2097152,
	P_REL_PME_ASSERTED = 1048576,
	P_REL_PCIE_EXIT_L1_ST = 524288,
	P_REL_LOADER_NOT_FIN = 262144,
	P_REL_PCIE_RX_EX_IDLE = 131072,
	P_REL_GPHY_LINK_UP = 65536,
	P_GAT_PCIE_RST_ASSERTED = 1024,
	P_GAT_GPHY_N_REC_PACKET = 512,
	P_GAT_INT_FIFO_EMPTY = 256,
	P_GAT_MAIN_PWR_N_AVAIL = 128,
	P_GAT_CLKRUN_REQ_REL = 64,
	P_GAT_PCIE_RESET_ASS = 32,
	P_GAT_PME_DE_ASSERTED = 16,
	P_GAT_PCIE_ENTER_L1_ST = 8,
	P_GAT_LOADER_FINISHED = 4,
	P_GAT_PCIE_RX_EL_IDLE = 2,
	P_GAT_GPHY_LINK_DOWN = 1,
	PCIE_OUR5_EVENT_CLK_D3_SET = 50987786,
};

enum {
	GLB_GPIO_CLK_DEB_ENA = -2147483648,
	GLB_GPIO_CLK_DBG_MSK = 1006632960,
	GLB_GPIO_INT_RST_D3_DIS = 32768,
	GLB_GPIO_LED_PAD_SPEED_UP = 16384,
	GLB_GPIO_STAT_RACE_DIS = 8192,
	GLB_GPIO_TEST_SEL_MSK = 6144,
	GLB_GPIO_TEST_SEL_BASE = 2048,
	GLB_GPIO_RAND_ENA = 1024,
	GLB_GPIO_RAND_BIT_1 = 512,
};

enum {
	GM_GP_STAT = 0,
	GM_GP_CTRL = 4,
	GM_TX_CTRL = 8,
	GM_RX_CTRL = 12,
	GM_TX_FLOW_CTRL = 16,
	GM_TX_PARAM = 20,
	GM_SERIAL_MODE = 24,
	GM_SRC_ADDR_1L = 28,
	GM_SRC_ADDR_1M = 32,
	GM_SRC_ADDR_1H = 36,
	GM_SRC_ADDR_2L = 40,
	GM_SRC_ADDR_2M = 44,
	GM_SRC_ADDR_2H = 48,
	GM_MC_ADDR_H1 = 52,
	GM_MC_ADDR_H2 = 56,
	GM_MC_ADDR_H3 = 60,
	GM_MC_ADDR_H4 = 64,
	GM_TX_IRQ_SRC = 68,
	GM_RX_IRQ_SRC = 72,
	GM_TR_IRQ_SRC = 76,
	GM_TX_IRQ_MSK = 80,
	GM_RX_IRQ_MSK = 84,
	GM_TR_IRQ_MSK = 88,
	GM_SMI_CTRL = 128,
	GM_SMI_DATA = 132,
	GM_PHY_ADDR = 136,
	GM_MIB_CNT_BASE = 256,
	GM_MIB_CNT_END = 604,
};

enum {
	GM_RXCR_UCF_ENA = 32768,
	GM_RXCR_MCF_ENA = 16384,
	GM_RXCR_CRC_DIS = 8192,
	GM_RXCR_PASS_FC = 4096,
};

enum {
	BASE_GMAC_1 = 10240,
	BASE_GMAC_2 = 14336,
};

enum flow_control {
	FC_NONE = 0,
	FC_TX = 1,
	FC_RX = 2,
	FC_BOTH = 3,
};

enum {
	PHY_MARV_CTRL = 0,
	PHY_MARV_STAT = 1,
	PHY_MARV_ID0 = 2,
	PHY_MARV_ID1 = 3,
	PHY_MARV_AUNE_ADV = 4,
	PHY_MARV_AUNE_LP = 5,
	PHY_MARV_AUNE_EXP = 6,
	PHY_MARV_NEPG = 7,
	PHY_MARV_NEPG_LP = 8,
	PHY_MARV_1000T_CTRL = 9,
	PHY_MARV_1000T_STAT = 10,
	PHY_MARV_EXT_STAT = 15,
	PHY_MARV_PHY_CTRL = 16,
	PHY_MARV_PHY_STAT = 17,
	PHY_MARV_INT_MASK = 18,
	PHY_MARV_INT_STAT = 19,
	PHY_MARV_EXT_CTRL = 20,
	PHY_MARV_RXE_CNT = 21,
	PHY_MARV_EXT_ADR = 22,
	PHY_MARV_PORT_IRQ = 23,
	PHY_MARV_LED_CTRL = 24,
	PHY_MARV_LED_OVER = 25,
	PHY_MARV_EXT_CTRL_2 = 26,
	PHY_MARV_EXT_P_STAT = 27,
	PHY_MARV_CABLE_DIAG = 28,
	PHY_MARV_PAGE_ADDR = 29,
	PHY_MARV_PAGE_DATA = 30,
	PHY_MARV_FE_LED_PAR = 22,
	PHY_MARV_FE_LED_SER = 23,
	PHY_MARV_FE_VCT_TX = 26,
	PHY_MARV_FE_VCT_RX = 27,
	PHY_MARV_FE_SPEC_2 = 28,
};

enum {
	PHY_M_EC_ENA_BC_EXT = 32768,
	PHY_M_EC_ENA_LIN_LB = 16384,
	PHY_M_EC_DIS_LINK_P = 4096,
	PHY_M_EC_M_DSC_MSK = 3072,
	PHY_M_EC_S_DSC_MSK = 768,
	PHY_M_EC_M_DSC_MSK2 = 3584,
	PHY_M_EC_DOWN_S_ENA = 256,
	PHY_M_EC_RX_TIM_CT = 128,
	PHY_M_EC_MAC_S_MSK = 112,
	PHY_M_EC_FIB_AN_ENA = 8,
	PHY_M_EC_DTE_D_ENA = 4,
	PHY_M_EC_TX_TIM_CT = 2,
	PHY_M_EC_TRANS_DIS = 1,
	PHY_M_10B_TE_ENABLE = 128,
};

enum {
	MAC_TX_CLK_0_MHZ = 2,
	MAC_TX_CLK_2_5_MHZ = 6,
	MAC_TX_CLK_25_MHZ = 7,
};

enum {
	PHY_M_PC_MAN_MDI = 0,
	PHY_M_PC_MAN_MDIX = 1,
	PHY_M_PC_ENA_AUTO = 3,
};

enum {
	PHY_M_PC_TX_FFD_MSK = 49152,
	PHY_M_PC_RX_FFD_MSK = 12288,
	PHY_M_PC_ASS_CRS_TX = 2048,
	PHY_M_PC_FL_GOOD = 1024,
	PHY_M_PC_EN_DET_MSK = 768,
	PHY_M_PC_ENA_EXT_D = 128,
	PHY_M_PC_MDIX_MSK = 96,
	PHY_M_PC_DIS_125CLK = 16,
	PHY_M_PC_MAC_POW_UP = 8,
	PHY_M_PC_SQE_T_ENA = 4,
	PHY_M_PC_POL_R_DIS = 2,
	PHY_M_PC_DIS_JABBER = 1,
};

enum {
	PHY_M_FESC_DIS_WAIT = 4,
	PHY_M_FESC_ENA_MCLK = 2,
	PHY_M_FESC_SEL_CL_A = 1,
};

enum {
	PHY_M_PC_DIS_LINK_Pa = 32768,
	PHY_M_PC_DSC_MSK = 28672,
	PHY_M_PC_DOWN_S_ENA = 2048,
};

enum {
	PHY_M_MAC_MD_MSK = 896,
	PHY_M_MAC_GMIF_PUP = 8,
	PHY_M_MAC_MD_AUTO = 3,
	PHY_M_MAC_MD_COPPER = 5,
	PHY_M_MAC_MD_1000BX = 7,
};

enum {
	PHY_M_FIB_FORCE_LNK = 1024,
	PHY_M_FIB_SIGD_POL = 512,
	PHY_M_FIB_TX_DIS = 8,
};

enum {
	PHY_CT_RESET = 32768,
	PHY_CT_LOOP = 16384,
	PHY_CT_SPS_LSB = 8192,
	PHY_CT_ANE = 4096,
	PHY_CT_PDOWN = 2048,
	PHY_CT_ISOL = 1024,
	PHY_CT_RE_CFG = 512,
	PHY_CT_DUP_MD = 256,
	PHY_CT_COL_TST = 128,
	PHY_CT_SPS_MSB = 64,
};

enum {
	PHY_AN_NXT_PG = 32768,
	PHY_AN_ACK = 16384,
	PHY_AN_RF = 8192,
	PHY_AN_PAUSE_ASYM = 2048,
	PHY_AN_PAUSE_CAP = 1024,
	PHY_AN_100BASE4 = 512,
	PHY_AN_100FULL = 256,
	PHY_AN_100HALF = 128,
	PHY_AN_10FULL = 64,
	PHY_AN_10HALF = 32,
	PHY_AN_CSMA = 1,
	PHY_AN_SEL = 31,
	PHY_AN_FULL = 321,
	PHY_AN_ALL = 480,
};

enum {
	PHY_M_1000C_TEST = 57344,
	PHY_M_1000C_MSE = 4096,
	PHY_M_1000C_MSC = 2048,
	PHY_M_1000C_MPD = 1024,
	PHY_M_1000C_AFD = 512,
	PHY_M_1000C_AHD = 256,
};

enum {
	PHY_M_AN_NXT_PG = 32768,
	PHY_M_AN_ACK = 16384,
	PHY_M_AN_RF = 8192,
	PHY_M_AN_ASP = 2048,
	PHY_M_AN_PC = 1024,
	PHY_M_AN_100_T4 = 512,
	PHY_M_AN_100_FD = 256,
	PHY_M_AN_100_HD = 128,
	PHY_M_AN_10_FD = 64,
	PHY_M_AN_10_HD = 32,
	PHY_M_AN_SEL_MSK = 496,
};

enum {
	PHY_M_AN_ASP_X = 256,
	PHY_M_AN_PC_X = 128,
	PHY_M_AN_1000X_AHD = 64,
	PHY_M_AN_1000X_AFD = 32,
};

enum {
	GM_GPCR_PROM_ENA = 16384,
	GM_GPCR_FC_TX_DIS = 8192,
	GM_GPCR_TX_ENA = 4096,
	GM_GPCR_RX_ENA = 2048,
	GM_GPCR_BURST_ENA = 1024,
	GM_GPCR_LOOP_ENA = 512,
	GM_GPCR_PART_ENA = 256,
	GM_GPCR_GIGS_ENA = 128,
	GM_GPCR_FL_PASS = 64,
	GM_GPCR_DUP_FULL = 32,
	GM_GPCR_FC_RX_DIS = 16,
	GM_GPCR_SPEED_100 = 8,
	GM_GPCR_AU_DUP_DIS = 4,
	GM_GPCR_AU_FCT_DIS = 2,
	GM_GPCR_AU_SPD_DIS = 1,
};

enum {
	PHY_CT_SP1000 = 64,
	PHY_CT_SP100 = 8192,
	PHY_CT_SP10 = 0,
};

enum {
	PULS_NO_STR = 0,
	PULS_21MS = 1,
	PULS_42MS = 2,
	PULS_84MS = 3,
	PULS_170MS = 4,
	PULS_340MS = 5,
	PULS_670MS = 6,
	PULS_1300MS = 7,
};

enum {
	PHY_M_LEDC_DIS_LED = 32768,
	PHY_M_LEDC_PULS_MSK = 28672,
	PHY_M_LEDC_F_INT = 2048,
	PHY_M_LEDC_BL_R_MSK = 1792,
	PHY_M_LEDC_DP_C_LSB = 128,
	PHY_M_LEDC_TX_C_LSB = 64,
	PHY_M_LEDC_LK_C_MSK = 56,
};

enum {
	BLINK_42MS = 0,
	BLINK_84MS = 1,
	BLINK_170MS = 2,
	BLINK_340MS = 3,
	BLINK_670MS = 4,
};

enum {
	PHY_M_FELP_LED2_MSK = 3840,
	PHY_M_FELP_LED1_MSK = 240,
	PHY_M_FELP_LED0_MSK = 15,
};

enum {
	LED_PAR_CTRL_COLX = 0,
	LED_PAR_CTRL_ERROR = 1,
	LED_PAR_CTRL_DUPLEX = 2,
	LED_PAR_CTRL_DP_COL = 3,
	LED_PAR_CTRL_SPEED = 4,
	LED_PAR_CTRL_LINK = 5,
	LED_PAR_CTRL_TX = 6,
	LED_PAR_CTRL_RX = 7,
	LED_PAR_CTRL_ACT = 8,
	LED_PAR_CTRL_LNK_RX = 9,
	LED_PAR_CTRL_LNK_AC = 10,
	LED_PAR_CTRL_ACT_BL = 11,
	LED_PAR_CTRL_TX_BL = 12,
	LED_PAR_CTRL_RX_BL = 13,
	LED_PAR_CTRL_COL_BL = 14,
	LED_PAR_CTRL_INACT = 15,
};

enum {
	PHY_M_PC_ENA_DTE_DT = 32768,
	PHY_M_PC_ENA_ENE_DT = 16384,
	PHY_M_PC_DIS_NLP_CK = 8192,
	PHY_M_PC_ENA_LIP_NP = 4096,
	PHY_M_PC_DIS_NLP_GN = 2048,
	PHY_M_PC_DIS_SCRAMB = 512,
	PHY_M_PC_DIS_FEFI = 256,
	PHY_M_PC_SH_TP_SEL = 64,
	PHY_M_PC_RX_FD_MSK = 12,
};

enum {
	PHY_M_LEDC_LOS_MSK = 61440,
	PHY_M_LEDC_INIT_MSK = 3840,
	PHY_M_LEDC_STA1_MSK = 240,
	PHY_M_LEDC_STA0_MSK = 15,
};

enum {
	PHY_M_POLC_LS1M_MSK = 61440,
	PHY_M_POLC_IS0M_MSK = 3840,
	PHY_M_POLC_LOS_MSK = 192,
	PHY_M_POLC_INIT_MSK = 48,
	PHY_M_POLC_STA1_MSK = 12,
	PHY_M_POLC_STA0_MSK = 3,
};

enum {
	PHY_M_LEDC_LINK_MSK = 24,
	PHY_M_LEDC_DP_CTRL = 4,
	PHY_M_LEDC_DP_C_MSB = 4,
	PHY_M_LEDC_RX_CTRL = 2,
	PHY_M_LEDC_TX_CTRL = 1,
	PHY_M_LEDC_TX_C_MSB = 1,
};

enum led_mode {
	MO_LED_NORM = 0,
	MO_LED_BLINK = 1,
	MO_LED_OFF = 2,
	MO_LED_ON = 3,
};

enum {
	PHY_M_IS_AN_ERROR = 32768,
	PHY_M_IS_LSP_CHANGE = 16384,
	PHY_M_IS_DUP_CHANGE = 8192,
	PHY_M_IS_AN_PR = 4096,
	PHY_M_IS_AN_COMPL = 2048,
	PHY_M_IS_LST_CHANGE = 1024,
	PHY_M_IS_SYMB_ERROR = 512,
	PHY_M_IS_FALSE_CARR = 256,
	PHY_M_IS_FIFO_ERROR = 128,
	PHY_M_IS_MDI_CHANGE = 64,
	PHY_M_IS_DOWNSH_DET = 32,
	PHY_M_IS_END_CHANGE = 16,
	PHY_M_IS_DTE_CHANGE = 4,
	PHY_M_IS_POL_CHANGE = 2,
	PHY_M_IS_JABBER = 1,
	PHY_M_DEF_MSK = 25600,
	PHY_M_AN_MSK = 34816,
};

enum {
	PHY_ADDR_MARV = 0,
};

enum {
	GM_SMI_CT_PHY_A_MSK = 63488,
	GM_SMI_CT_REG_A_MSK = 1984,
	GM_SMI_CT_OP_RD = 32,
	GM_SMI_CT_RD_VAL = 16,
	GM_SMI_CT_BUSY = 8,
};

enum pci_dev_reg_2 {
	PCI_VPD_WR_THR = 4278190080,
	PCI_DEV_SEL = 16646144,
	PCI_VPD_ROM_SZ = 114688,
	PCI_PATCH_DIR = 3840,
	PCI_EXT_PATCHS = 240,
	PCI_EN_DUMMY_RD = 8,
	PCI_REV_DESC = 4,
	PCI_USEDATA64 = 1,
};

enum {
	B8_Q_REGS = 1024,
	Q_D = 0,
	Q_VLAN = 32,
	Q_DONE = 36,
	Q_AC_L = 40,
	Q_AC_H = 44,
	Q_BC = 48,
	Q_CSR = 52,
	Q_TEST = 56,
	Q_WM = 64,
	Q_AL = 66,
	Q_RSP = 68,
	Q_RSL = 70,
	Q_RP = 72,
	Q_RL = 74,
	Q_WP = 76,
	Q_WSP = 77,
	Q_WL = 78,
	Q_WSL = 79,
};

enum {
	BMU_IDLE = -2147483648,
	BMU_RX_TCP_PKT = 1073741824,
	BMU_RX_IP_PKT = 536870912,
	BMU_ENA_RX_RSS_HASH = 32768,
	BMU_DIS_RX_RSS_HASH = 16384,
	BMU_ENA_RX_CHKSUM = 8192,
	BMU_DIS_RX_CHKSUM = 4096,
	BMU_CLR_IRQ_PAR = 2048,
	BMU_CLR_IRQ_TCP = 2048,
	BMU_CLR_IRQ_CHK = 1024,
	BMU_STOP = 512,
	BMU_START = 256,
	BMU_FIFO_OP_ON = 128,
	BMU_FIFO_OP_OFF = 64,
	BMU_FIFO_ENA = 32,
	BMU_FIFO_RST = 16,
	BMU_OP_ON = 8,
	BMU_OP_OFF = 4,
	BMU_RST_CLR = 2,
	BMU_RST_SET = 1,
	BMU_CLR_RESET = 22,
	BMU_OPER_INIT = 3368,
	BMU_WM_DEFAULT = 1536,
	BMU_WM_PEX = 128,
};

enum {
	B6_EXT_REG = 768,
	B7_CFG_SPC = 896,
	B8_RQ1_REGS = 1024,
	B8_RQ2_REGS = 1152,
	B8_TS1_REGS = 1536,
	B8_TA1_REGS = 1664,
	B8_TS2_REGS = 1792,
	B8_TA2_REGS = 1920,
	B16_RAM_REGS = 2048,
};

enum {
	RB_START = 0,
	RB_END = 4,
	RB_WP = 8,
	RB_RP = 12,
	RB_RX_UTPP = 16,
	RB_RX_LTPP = 20,
	RB_RX_UTHP = 24,
	RB_RX_LTHP = 28,
	RB_PC = 32,
	RB_LEV = 36,
	RB_CTRL = 40,
	RB_TST1 = 41,
	RB_TST2 = 42,
};

enum {
	RB_ENA_STFWD = 32,
	RB_DIS_STFWD = 16,
	RB_ENA_OP_MD = 8,
	RB_DIS_OP_MD = 4,
	RB_RST_CLR = 2,
	RB_RST_SET = 1,
};

enum {
	LNK_SYNC_INI = 3120,
	LNK_SYNC_VAL = 3124,
	LNK_SYNC_CTRL = 3128,
	LNK_SYNC_TST = 3129,
	LNK_LED_REG = 3132,
	RX_GMF_EA = 3136,
	RX_GMF_AF_THR = 3140,
	RX_GMF_CTRL_T = 3144,
	RX_GMF_FL_MSK = 3148,
	RX_GMF_FL_THR = 3152,
	RX_GMF_FL_CTRL = 3154,
	RX_GMF_TR_THR = 3156,
	RX_GMF_UP_THR = 3160,
	RX_GMF_LP_THR = 3162,
	RX_GMF_VLAN = 3164,
	RX_GMF_WP = 3168,
	RX_GMF_WLEV = 3176,
	RX_GMF_RP = 3184,
	RX_GMF_RLEV = 3192,
};

enum {
	RX_GCLKMAC_ENA = -2147483648,
	RX_GCLKMAC_OFF = 1073741824,
	RX_STFW_DIS = 536870912,
	RX_STFW_ENA = 268435456,
	RX_TRUNC_ON = 134217728,
	RX_TRUNC_OFF = 67108864,
	RX_VLAN_STRIP_ON = 33554432,
	RX_VLAN_STRIP_OFF = 16777216,
	RX_MACSEC_FLUSH_ON = 8388608,
	RX_MACSEC_FLUSH_OFF = 4194304,
	RX_MACSEC_ASF_FLUSH_ON = 2097152,
	RX_MACSEC_ASF_FLUSH_OFF = 1048576,
	GMF_RX_OVER_ON = 524288,
	GMF_RX_OVER_OFF = 262144,
	GMF_ASF_RX_OVER_ON = 131072,
	GMF_ASF_RX_OVER_OFF = 65536,
	GMF_WP_TST_ON = 16384,
	GMF_WP_TST_OFF = 8192,
	GMF_WP_STEP = 4096,
	GMF_RP_TST_ON = 1024,
	GMF_RP_TST_OFF = 512,
	GMF_RP_STEP = 256,
	GMF_RX_F_FL_ON = 128,
	GMF_RX_F_FL_OFF = 64,
	GMF_CLI_RX_FO = 32,
	GMF_CLI_RX_C = 16,
	GMF_OPER_ON = 8,
	GMF_OPER_OFF = 4,
	GMF_RST_CLR = 2,
	GMF_RST_SET = 1,
	RX_GMF_FL_THR_DEF = 10,
	GMF_RX_CTRL_DEF = 136,
};

enum {
	Y2_B8_PREF_REGS = 1104,
	PREF_UNIT_CTRL = 0,
	PREF_UNIT_LAST_IDX = 4,
	PREF_UNIT_ADDR_LO = 8,
	PREF_UNIT_ADDR_HI = 12,
	PREF_UNIT_GET_IDX = 16,
	PREF_UNIT_PUT_IDX = 20,
	PREF_UNIT_FIFO_WP = 32,
	PREF_UNIT_FIFO_RP = 36,
	PREF_UNIT_FIFO_WM = 40,
	PREF_UNIT_FIFO_LEV = 44,
	PREF_UNIT_MASK_IDX = 4095,
};

enum {
	PREF_UNIT_OP_ON = 8,
	PREF_UNIT_OP_OFF = 4,
	PREF_UNIT_RST_CLR = 2,
	PREF_UNIT_RST_SET = 1,
};

enum {
	PHY_M_PC_COP_TX_DIS = 8,
	PHY_M_PC_POW_D_ENA = 4,
};

enum {
	TX_GMF_EA = 3392,
	TX_GMF_AE_THR = 3396,
	TX_GMF_CTRL_T = 3400,
	TX_GMF_WP = 3424,
	TX_GMF_WSP = 3428,
	TX_GMF_WLEV = 3432,
	TX_GMF_RP = 3440,
	TX_GMF_RSTP = 3444,
	TX_GMF_RLEV = 3448,
	ECU_AE_THR = 112,
	ECU_TXFF_LEV = 416,
	ECU_JUMBO_WM = 128,
};

enum {
	Y2_IS_HW_ERR = -2147483648,
	Y2_IS_STAT_BMU = 1073741824,
	Y2_IS_ASF = 536870912,
	Y2_IS_CPU_TO = 268435456,
	Y2_IS_POLL_CHK = 134217728,
	Y2_IS_TWSI_RDY = 67108864,
	Y2_IS_IRQ_SW = 33554432,
	Y2_IS_TIMINT = 16777216,
	Y2_IS_IRQ_PHY2 = 4096,
	Y2_IS_IRQ_MAC2 = 2048,
	Y2_IS_CHK_RX2 = 1024,
	Y2_IS_CHK_TXS2 = 512,
	Y2_IS_CHK_TXA2 = 256,
	Y2_IS_PSM_ACK = 128,
	Y2_IS_PTP_TIST = 64,
	Y2_IS_PHY_QLNK = 32,
	Y2_IS_IRQ_PHY1 = 16,
	Y2_IS_IRQ_MAC1 = 8,
	Y2_IS_CHK_RX1 = 4,
	Y2_IS_CHK_TXS1 = 2,
	Y2_IS_CHK_TXA1 = 1,
	Y2_IS_BASE = -1073741824,
	Y2_IS_PORT_1 = 29,
	Y2_IS_PORT_2 = 7424,
	Y2_IS_ERROR = -2147480307,
};

enum {
	Q_R1 = 0,
	Q_R2 = 128,
	Q_XS1 = 512,
	Q_XA1 = 640,
	Q_XS2 = 768,
	Q_XA2 = 896,
};

enum {
	F_TX_CHK_AUTO_OFF = -2147483648,
	F_TX_CHK_AUTO_ON = 1073741824,
	F_M_RX_RAM_DIS = 16777216,
};

enum yukon_ec_u_rev {
	CHIP_REV_YU_EC_U_A0 = 1,
	CHIP_REV_YU_EC_U_A1 = 2,
	CHIP_REV_YU_EC_U_B0 = 3,
	CHIP_REV_YU_EC_U_B1 = 5,
};

enum {
	HW_OWNER = 128,
	OP_TCPWRITE = 17,
	OP_TCPSTART = 18,
	OP_TCPINIT = 20,
	OP_TCPLCK = 24,
	OP_TCPCHKSUM = 18,
	OP_TCPIS = 22,
	OP_TCPLW = 25,
	OP_TCPLSW = 27,
	OP_TCPLISW = 31,
	OP_ADDR64 = 33,
	OP_VLAN = 34,
	OP_ADDR64VLAN = 35,
	OP_LRGLEN = 36,
	OP_LRGLENVLAN = 38,
	OP_MSS = 40,
	OP_MSSVLAN = 42,
	OP_BUFFER = 64,
	OP_PACKET = 65,
	OP_LARGESEND = 67,
	OP_LSOV2 = 69,
	OP_RXSTAT = 96,
	OP_RXTIMESTAMP = 97,
	OP_RXVLAN = 98,
	OP_RXCHKS = 100,
	OP_RXCHKSVLAN = 102,
	OP_RXTIMEVLAN = 99,
	OP_RSS_HASH = 101,
	OP_TXINDEXLE = 104,
	OP_MACSEC = 108,
	OP_PUTIDX = 112,
};

enum {
	PHY_MARV_ID0_VAL = 321,
	PHY_BCOM_ID1_A1 = 24641,
	PHY_BCOM_ID1_B2 = 24643,
	PHY_BCOM_ID1_C0 = 24644,
	PHY_BCOM_ID1_C5 = 24647,
	PHY_MARV_ID1_B0 = 3107,
	PHY_MARV_ID1_B2 = 3109,
	PHY_MARV_ID1_C2 = 3266,
	PHY_MARV_ID1_Y2 = 3217,
	PHY_MARV_ID1_FE = 3203,
	PHY_MARV_ID1_ECU = 3248,
};

enum {
	GM_IS_TX_CO_OV = 32,
	GM_IS_RX_CO_OV = 16,
	GM_IS_TX_FF_UR = 8,
	GM_IS_TX_COMPL = 4,
	GM_IS_RX_FF_OR = 2,
	GM_IS_RX_COMPL = 1,
};

enum {
	GM_PAR_MIB_CLR = 32,
	GM_PAR_MIB_TST = 16,
};

enum {
	GM_TXCR_FORCE_JAM = 32768,
	GM_TXCR_CRC_DIS = 16384,
	GM_TXCR_PAD_DIS = 8192,
	GM_TXCR_COL_THR_MSK = 7168,
};

enum {
	GM_TXPA_JAMLEN_MSK = 49152,
	GM_TXPA_JAMIPG_MSK = 15872,
	GM_TXPA_JAMDAT_MSK = 496,
	GM_TXPA_BO_LIM_MSK = 15,
	TX_JAM_LEN_DEF = 3,
	TX_JAM_IPG_DEF = 11,
	TX_IPG_JAM_DEF = 28,
	TX_BOF_LIM_DEF = 4,
};

enum {
	GM_SMOD_DATABL_MSK = 63488,
	GM_SMOD_LIMIT_4 = 1024,
	GM_SMOD_VLAN_ENA = 512,
	GM_SMOD_JUMBO_ENA = 256,
	GM_NEW_FLOW_CTRL = 64,
	GM_SMOD_IPG_MSK = 31,
};

enum {
	GMR_FS_LEN = 2147418112,
	GMR_FS_VLAN = 8192,
	GMR_FS_JABBER = 4096,
	GMR_FS_UN_SIZE = 2048,
	GMR_FS_MC = 1024,
	GMR_FS_BC = 512,
	GMR_FS_RX_OK = 256,
	GMR_FS_GOOD_FC = 128,
	GMR_FS_BAD_FC = 64,
	GMR_FS_MII_ERR = 32,
	GMR_FS_LONG_ERR = 16,
	GMR_FS_FRAGMENT = 8,
	GMR_FS_CRC_ERR = 2,
	GMR_FS_RX_FF_OV = 1,
	GMR_FS_ANY_ERR = 6267,
};

enum {
	TX_DYN_WM_ENA = 3,
};

enum {
	TX_STFW_DIS = -2147483648,
	TX_STFW_ENA = 1073741824,
	TX_VLAN_TAG_ON = 33554432,
	TX_VLAN_TAG_OFF = 16777216,
	TX_PCI_JUM_ENA = 8388608,
	TX_PCI_JUM_DIS = 4194304,
	GMF_WSP_TST_ON = 262144,
	GMF_WSP_TST_OFF = 131072,
	GMF_WSP_STEP = 65536,
	GMF_CLI_TX_FU = 64,
	GMF_CLI_TX_FC = 32,
	GMF_CLI_TX_PE = 16,
};

enum {
	RX_IPV6_SA_MOB_ENA = 512,
	RX_IPV6_SA_MOB_DIS = 256,
	RX_IPV6_DA_MOB_ENA = 128,
	RX_IPV6_DA_MOB_DIS = 64,
	RX_PTR_SYNCDLY_ENA = 32,
	RX_PTR_SYNCDLY_DIS = 16,
	RX_ASF_NEWFLAG_ENA = 8,
	RX_ASF_NEWFLAG_DIS = 4,
	RX_FLSH_MISSPKT_ENA = 2,
	RX_FLSH_MISSPKT_DIS = 1,
};

enum {
	TBMU_TEST_BMU_TX_CHK_AUTO_OFF = -2147483648,
	TBMU_TEST_BMU_TX_CHK_AUTO_ON = 1073741824,
	TBMU_TEST_HOME_ADD_PAD_FIX1_EN = 536870912,
	TBMU_TEST_HOME_ADD_PAD_FIX1_DIS = 268435456,
	TBMU_TEST_ROUTING_ADD_FIX_EN = 134217728,
	TBMU_TEST_ROUTING_ADD_FIX_DIS = 67108864,
	TBMU_TEST_HOME_ADD_FIX_EN = 33554432,
	TBMU_TEST_HOME_ADD_FIX_DIS = 16777216,
	TBMU_TEST_TEST_RSPTR_ON = 4194304,
	TBMU_TEST_TEST_RSPTR_OFF = 2097152,
	TBMU_TEST_TESTSTEP_RSPTR = 1048576,
	TBMU_TEST_TEST_RPTR_ON = 262144,
	TBMU_TEST_TEST_RPTR_OFF = 131072,
	TBMU_TEST_TESTSTEP_RPTR = 65536,
	TBMU_TEST_TEST_WSPTR_ON = 16384,
	TBMU_TEST_TEST_WSPTR_OFF = 8192,
	TBMU_TEST_TESTSTEP_WSPTR = 4096,
	TBMU_TEST_TEST_WPTR_ON = 1024,
	TBMU_TEST_TEST_WPTR_OFF = 512,
	TBMU_TEST_TESTSTEP_WPTR = 256,
	TBMU_TEST_TEST_REQ_NB_ON = 64,
	TBMU_TEST_TEST_REQ_NB_OFF = 32,
	TBMU_TEST_TESTSTEP_REQ_NB = 16,
	TBMU_TEST_TEST_DONE_IDX_ON = 4,
	TBMU_TEST_TEST_DONE_IDX_OFF = 2,
	TBMU_TEST_TESTSTEP_DONE_IDX = 1,
};

enum {
	HASH_TCP_IPV6_EX_CTRL = 32,
	HASH_IPV6_EX_CTRL = 16,
	HASH_TCP_IPV6_CTRL = 8,
	HASH_IPV6_CTRL = 4,
	HASH_TCP_IPV4_CTRL = 2,
	HASH_IPV4_CTRL = 1,
	HASH_ALL = 63,
};

enum {
	GM_RXF_UC_OK = 256,
	GM_RXF_BC_OK = 264,
	GM_RXF_MPAUSE = 272,
	GM_RXF_MC_OK = 280,
	GM_RXF_FCS_ERR = 288,
	GM_RXO_OK_LO = 304,
	GM_RXO_OK_HI = 312,
	GM_RXO_ERR_LO = 320,
	GM_RXO_ERR_HI = 328,
	GM_RXF_SHT = 336,
	GM_RXE_FRAG = 344,
	GM_RXF_64B = 352,
	GM_RXF_127B = 360,
	GM_RXF_255B = 368,
	GM_RXF_511B = 376,
	GM_RXF_1023B = 384,
	GM_RXF_1518B = 392,
	GM_RXF_MAX_SZ = 400,
	GM_RXF_LNG_ERR = 408,
	GM_RXF_JAB_PKT = 416,
	GM_RXE_FIFO_OV = 432,
	GM_TXF_UC_OK = 448,
	GM_TXF_BC_OK = 456,
	GM_TXF_MPAUSE = 464,
	GM_TXF_MC_OK = 472,
	GM_TXO_OK_LO = 480,
	GM_TXO_OK_HI = 488,
	GM_TXF_64B = 496,
	GM_TXF_127B = 504,
	GM_TXF_255B = 512,
	GM_TXF_511B = 520,
	GM_TXF_1023B = 528,
	GM_TXF_1518B = 536,
	GM_TXF_MAX_SZ = 544,
	GM_TXF_COL = 560,
	GM_TXF_LAT_COL = 568,
	GM_TXF_ABO_COL = 576,
	GM_TXF_MUL_COL = 584,
	GM_TXF_SNG_COL = 592,
	GM_TXE_FIFO_UR = 600,
};

enum {
	UDPTCP = 1,
	CALSUM = 2,
	WR_SUM = 4,
	INIT_SUM = 8,
	LOCK_SUM = 16,
	INS_VLAN = 32,
	EOP = 128,
};

enum {
	PHY_M_PS_SPEED_MSK = 49152,
	PHY_M_PS_SPEED_1000 = 32768,
	PHY_M_PS_SPEED_100 = 16384,
	PHY_M_PS_SPEED_10 = 0,
	PHY_M_PS_FULL_DUP = 8192,
	PHY_M_PS_PAGE_REC = 4096,
	PHY_M_PS_SPDUP_RES = 2048,
	PHY_M_PS_LINK_UP = 1024,
	PHY_M_PS_CABLE_MSK = 896,
	PHY_M_PS_MDI_X_STAT = 64,
	PHY_M_PS_DOWNS_STAT = 32,
	PHY_M_PS_ENDET_STAT = 16,
	PHY_M_PS_TX_P_EN = 8,
	PHY_M_PS_RX_P_EN = 4,
	PHY_M_PS_POL_REV = 2,
	PHY_M_PS_JABBER = 1,
};

enum {
	LINKLED_OFF = 1,
	LINKLED_ON = 2,
	LINKLED_LINKSYNC_OFF = 4,
	LINKLED_LINKSYNC_ON = 8,
	LINKLED_BLINK_OFF = 16,
	LINKLED_BLINK_ON = 32,
};

enum status_css {
	CSS_TCPUDPCSOK = 128,
	CSS_ISUDP = 64,
	CSS_ISTCP = 32,
	CSS_ISIPFRAG = 16,
	CSS_ISIPV6 = 8,
	CSS_IPV4CSUMOK = 4,
	CSS_ISIPV4 = 2,
	CSS_LINK_BIT = 1,
};

enum {
	WOL_CTL_LINK_CHG_OCC = 32768,
	WOL_CTL_MAGIC_PKT_OCC = 16384,
	WOL_CTL_PATTERN_OCC = 8192,
	WOL_CTL_CLEAR_RESULT = 4096,
	WOL_CTL_ENA_PME_ON_LINK_CHG = 2048,
	WOL_CTL_DIS_PME_ON_LINK_CHG = 1024,
	WOL_CTL_ENA_PME_ON_MAGIC_PKT = 512,
	WOL_CTL_DIS_PME_ON_MAGIC_PKT = 256,
	WOL_CTL_ENA_PME_ON_PATTERN = 128,
	WOL_CTL_DIS_PME_ON_PATTERN = 64,
	WOL_CTL_ENA_LINK_CHG_UNIT = 32,
	WOL_CTL_DIS_LINK_CHG_UNIT = 16,
	WOL_CTL_ENA_MAGIC_PKT_UNIT = 8,
	WOL_CTL_DIS_MAGIC_PKT_UNIT = 4,
	WOL_CTL_ENA_PATTERN_UNIT = 2,
	WOL_CTL_DIS_PATTERN_UNIT = 1,
};

enum pci_dev_reg_1 {
	PCI_Y2_PIG_ENA = -2147483648,
	PCI_Y2_DLL_DIS = 1073741824,
	PCI_SW_PWR_ON_RST = 1073741824,
	PCI_Y2_PHY2_COMA = 536870912,
	PCI_Y2_PHY1_COMA = 268435456,
	PCI_Y2_PHY2_POWD = 134217728,
	PCI_Y2_PHY1_POWD = 67108864,
	PCI_Y2_PME_LEGACY = 32768,
	PCI_PHY_LNK_TIM_MSK = 768,
	PCI_ENA_L1_EVENT = 128,
	PCI_ENA_GPHY_LNK = 64,
	PCI_FORCE_PEX_L1 = 32,
};

struct sky2_status_le;

struct sky2_hw {
	void *regs;
	struct pci_dev *pdev;
	struct napi_struct napi;
	struct net_device *dev[2];
	unsigned long flags;
	u8 chip_id;
	u8 chip_rev;
	u8 pmd_type;
	u8 ports;
	struct sky2_status_le *st_le;
	u32 st_size;
	u32 st_idx;
	dma_addr_t st_dma;
	struct timer_list watchdog_timer;
	struct work_struct restart_work;
	wait_queue_head_t msi_wait;
	char irq_name[0];
};

struct sky2_status_le {
	__le32 status;
	__le16 length;
	u8 css;
	u8 opcode;
};

struct sky2_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
};

struct tx_ring_info;

struct sky2_tx_le;

struct rx_ring_info;

struct sky2_rx_le;

struct sky2_port {
	struct sky2_hw *hw;
	struct net_device *netdev;
	unsigned int port;
	u32 msg_enable;
	spinlock_t phy_lock;
	struct tx_ring_info *tx_ring;
	struct sky2_tx_le *tx_le;
	struct sky2_stats tx_stats;
	u16 tx_ring_size;
	u16 tx_cons;
	u16 tx_prod;
	u16 tx_next;
	u16 tx_pending;
	u16 tx_last_mss;
	u32 tx_last_upper;
	u32 tx_tcpsum;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct rx_ring_info *rx_ring;
	struct sky2_rx_le *rx_le;
	struct sky2_stats rx_stats;
	u16 rx_next;
	u16 rx_put;
	u16 rx_pending;
	u16 rx_data_size;
	u16 rx_nfrags;
	unsigned long last_rx;
	struct {
		unsigned long last;
		u32 mac_rp;
		u8 mac_lev;
		u8 fifo_rp;
		u8 fifo_lev;
	} check;
	dma_addr_t rx_le_map;
	dma_addr_t tx_le_map;
	u16 advertising;
	u16 speed;
	u8 wol;
	u8 duplex;
	u16 flags;
	enum flow_control flow_mode;
	enum flow_control flow_status;
	long: 64;
	long: 64;
	long: 64;
};

struct tx_ring_info {
	struct sk_buff *skb;
	unsigned long flags;
	dma_addr_t mapaddr;
	__u32 maplen;
};

struct sky2_tx_le {
	__le32 addr;
	__le16 length;
	u8 ctrl;
	u8 opcode;
};

struct rx_ring_info {
	struct sk_buff *skb;
	dma_addr_t data_addr;
	__u32 data_size;
	dma_addr_t frag_addr[2];
};

struct sky2_rx_le {
	__le32 addr;
	__le16 length;
	u8 ctrl;
	u8 opcode;
};

struct usb_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct usb_driver {
	const char *name;
	int (*probe)(struct usb_interface *, const struct usb_device_id *);
	void (*disconnect)(struct usb_interface *);
	int (*unlocked_ioctl)(struct usb_interface *, unsigned int, void *);
	int (*suspend)(struct usb_interface *, pm_message_t);
	int (*resume)(struct usb_interface *);
	int (*reset_resume)(struct usb_interface *);
	int (*pre_reset)(struct usb_interface *);
	int (*post_reset)(struct usb_interface *);
	const struct usb_device_id *id_table;
	const struct attribute_group **dev_groups;
	struct usb_dynids dynids;
	struct usbdrv_wrap drvwrap;
	unsigned int no_dynamic_id: 1;
	unsigned int supports_autosuspend: 1;
	unsigned int disable_hub_initiated_lpm: 1;
	unsigned int soft_unbind: 1;
};

enum usb_port_connect_type {
	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
	USB_PORT_CONNECT_TYPE_HOT_PLUG = 1,
	USB_PORT_CONNECT_TYPE_HARD_WIRED = 2,
	USB_PORT_NOT_USED = 3,
};

enum hub_led_mode {
	INDICATOR_AUTO = 0,
	INDICATOR_CYCLE = 1,
	INDICATOR_GREEN_BLINK = 2,
	INDICATOR_GREEN_BLINK_OFF = 3,
	INDICATOR_AMBER_BLINK = 4,
	INDICATOR_AMBER_BLINK_OFF = 5,
	INDICATOR_ALT_BLINK = 6,
	INDICATOR_ALT_BLINK_OFF = 7,
} __attribute__((mode(byte)));

enum hub_quiescing_type {
	HUB_DISCONNECT = 0,
	HUB_PRE_RESET = 1,
	HUB_SUSPEND = 2,
};

enum hub_activation_type {
	HUB_INIT = 0,
	HUB_INIT2 = 1,
	HUB_INIT3 = 2,
	HUB_POST_RESET = 3,
	HUB_RESUME = 4,
	HUB_RESET_RESUME = 5,
};

struct usb_hub_status {
	__le16 wHubStatus;
	__le16 wHubChange;
};

struct usb_port_status {
	__le16 wPortStatus;
	__le16 wPortChange;
	__le32 dwExtPortStatus;
};

struct usb_hub_descriptor;

struct usb_port;

struct usb_hub {
	struct device *intfdev;
	struct usb_device *hdev;
	struct kref kref;
	struct urb *urb;
	u8 (*buffer)[8];
	union {
		struct usb_hub_status hub;
		struct usb_port_status port;
	} *status;
	struct mutex status_mutex;
	int error;
	int nerrors;
	unsigned long event_bits[1];
	unsigned long change_bits[1];
	unsigned long removed_bits[1];
	unsigned long wakeup_bits[1];
	unsigned long power_bits[1];
	unsigned long child_usage_bits[1];
	unsigned long warm_reset_bits[1];
	struct usb_hub_descriptor *descriptor;
	struct usb_tt tt;
	unsigned int mA_per_port;
	unsigned int wakeup_enabled_descendants;
	unsigned int limited_power: 1;
	unsigned int quiescing: 1;
	unsigned int disconnected: 1;
	unsigned int in_reset: 1;
	unsigned int quirk_disable_autosuspend: 1;
	unsigned int quirk_check_port_auto_suspend: 1;
	unsigned int has_indicators: 1;
	u8 indicator[31];
	struct delayed_work leds;
	struct delayed_work init_work;
	struct work_struct events;
	spinlock_t irq_urb_lock;
	struct timer_list irq_urb_retry;
	struct usb_port **ports;
	struct list_head onboard_hub_devs;
};

struct usb_hub_descriptor {
	__u8 bDescLength;
	__u8 bDescriptorType;
	__u8 bNbrPorts;
	__le16 wHubCharacteristics;
	__u8 bPwrOn2PwrGood;
	__u8 bHubContrCurrent;
	union {
		struct {
			__u8 DeviceRemovable[4];
			__u8 PortPwrCtrlMask[4];
		} hs;
		struct {
			__u8 bHubHdrDecLat;
			__le16 wHubDelay;
			__le16 DeviceRemovable;
		} __attribute__((packed)) ss;
	} u;
} __attribute__((packed));

typedef u32 usb_port_location_t;

struct usb_dev_state;

struct typec_connector;

struct usb_port {
	struct usb_device *child;
	struct device dev;
	struct usb_dev_state *port_owner;
	struct usb_port *peer;
	struct typec_connector *connector;
	struct dev_pm_qos_request *req;
	enum usb_port_connect_type connect_type;
	enum usb_device_state state;
	struct kernfs_node *state_kn;
	usb_port_location_t location;
	struct mutex status_lock;
	u32 over_current_count;
	u8 portnum;
	u32 quirks;
	unsigned int early_stop: 1;
	unsigned int ignore_event: 1;
	unsigned int is_superspeed: 1;
	unsigned int usb3_lpm_u1_permit: 1;
	unsigned int usb3_lpm_u2_permit: 1;
};

struct typec_connector {
	void (*attach)(struct typec_connector *, struct device *);
	void (*deattach)(struct typec_connector *, struct device *);
};

struct usb_tt_clear {
	struct list_head clear_list;
	unsigned int tt;
	u16 devinfo;
	struct usb_hcd *hcd;
	struct usb_host_endpoint *ep;
};

struct usb_otg_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bmAttributes;
};

struct usb_qualifier_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__u8 bNumConfigurations;
	__u8 bRESERVED;
};

struct usbdevfs_hub_portinfo {
	char nports;
	char port[127];
};

struct usb_set_sel_req {
	__u8 u1_sel;
	__u8 u1_pel;
	__le16 u2_sel;
	__le16 u2_pel;
};

struct dwc3_of_simple {
	struct device *dev;
	struct clk_bulk_data *clks;
	int num_clocks;
	struct reset_control *resets;
	bool need_reset;
};

enum dwc2_halt_status {
	DWC2_HC_XFER_NO_HALT_STATUS = 0,
	DWC2_HC_XFER_COMPLETE = 1,
	DWC2_HC_XFER_URB_COMPLETE = 2,
	DWC2_HC_XFER_ACK = 3,
	DWC2_HC_XFER_NAK = 4,
	DWC2_HC_XFER_NYET = 5,
	DWC2_HC_XFER_STALL = 6,
	DWC2_HC_XFER_XACT_ERR = 7,
	DWC2_HC_XFER_FRAME_OVERRUN = 8,
	DWC2_HC_XFER_BABBLE_ERR = 9,
	DWC2_HC_XFER_DATA_TOGGLE_ERR = 10,
	DWC2_HC_XFER_AHB_ERR = 11,
	DWC2_HC_XFER_PERIODIC_INCOMPLETE = 12,
	DWC2_HC_XFER_URB_DEQUEUE = 13,
};

enum dwc2_control_phase {
	DWC2_CONTROL_SETUP = 0,
	DWC2_CONTROL_DATA = 1,
	DWC2_CONTROL_STATUS = 2,
};

enum dwc2_transaction_type {
	DWC2_TRANSACTION_NONE = 0,
	DWC2_TRANSACTION_PERIODIC = 1,
	DWC2_TRANSACTION_NON_PERIODIC = 2,
	DWC2_TRANSACTION_ALL = 3,
};

struct dwc2_hs_transfer_time {
	u32 start_schedule_us;
	u16 duration_us;
};

struct dwc2_tt;

struct dwc2_qh {
	struct dwc2_hsotg *hsotg;
	u8 ep_type;
	u8 ep_is_in;
	u16 maxp;
	u16 maxp_mult;
	u8 dev_speed;
	u8 data_toggle;
	u8 ping_state;
	u8 do_split;
	u8 td_first;
	u8 td_last;
	u16 host_us;
	u16 device_us;
	u16 host_interval;
	u16 device_interval;
	u16 next_active_frame;
	u16 start_active_frame;
	s16 num_hs_transfers;
	struct dwc2_hs_transfer_time hs_transfers[8];
	u32 ls_start_schedule_slice;
	u16 ntd;
	u8 *dw_align_buf;
	dma_addr_t dw_align_buf_dma;
	struct list_head qtd_list;
	struct dwc2_host_chan *channel;
	struct list_head qh_list_entry;
	struct dwc2_dma_desc *desc_list;
	dma_addr_t desc_list_dma;
	u32 desc_list_sz;
	u32 *n_bytes;
	struct timer_list unreserve_timer;
	struct hrtimer wait_timer;
	struct dwc2_tt *dwc_tt;
	int ttport;
	unsigned int tt_buffer_dirty: 1;
	unsigned int unreserve_pending: 1;
	unsigned int schedule_low_speed: 1;
	unsigned int want_wait: 1;
	unsigned int wait_timer_cancel: 1;
};

struct dwc2_host_chan {
	u8 hc_num;
	unsigned int dev_addr: 7;
	unsigned int ep_num: 4;
	unsigned int ep_is_in: 1;
	unsigned int speed: 4;
	unsigned int ep_type: 2;
	int: 6;
	unsigned int max_packet: 11;
	unsigned int data_pid_start: 2;
	unsigned int multi_count: 2;
	u8 *xfer_buf;
	dma_addr_t xfer_dma;
	dma_addr_t align_buf;
	u32 xfer_len;
	u32 xfer_count;
	u16 start_pkt_count;
	u8 xfer_started;
	u8 do_ping;
	u8 error_state;
	u8 halt_on_queue;
	u8 halt_pending;
	u8 do_split;
	u8 complete_split;
	u8 hub_addr;
	u8 hub_port;
	u8 xact_pos;
	u8 requests;
	u8 schinfo;
	u16 ntd;
	enum dwc2_halt_status halt_status;
	u32 hcint;
	struct dwc2_qh *qh;
	struct list_head hc_list_entry;
	dma_addr_t desc_list_addr;
	u32 desc_list_sz;
	struct list_head split_order_list_entry;
};

struct dwc2_tt {
	int refcount;
	struct usb_tt *usb_tt;
	unsigned long periodic_bitmaps[0];
};

struct dwc2_hcd_urb;

struct dwc2_qtd {
	enum dwc2_control_phase control_phase;
	u8 in_process;
	u8 data_toggle;
	u8 complete_split;
	u8 isoc_split_pos;
	u16 isoc_frame_index;
	u16 isoc_split_offset;
	u16 isoc_td_last;
	u16 isoc_td_first;
	u32 ssplit_out_xfer_count;
	u8 error_count;
	u8 n_desc;
	u16 isoc_frame_index_last;
	u16 num_naks;
	struct dwc2_hcd_urb *urb;
	struct dwc2_qh *qh;
	struct list_head qtd_list_entry;
};

struct dwc2_hcd_pipe_info {
	u8 dev_addr;
	u8 ep_num;
	u8 pipe_type;
	u8 pipe_dir;
	u16 maxp;
	u16 maxp_mult;
};

struct dwc2_hcd_iso_packet_desc {
	u32 offset;
	u32 length;
	u32 actual_length;
	u32 status;
};

struct dwc2_hcd_urb {
	void *priv;
	struct dwc2_qtd *qtd;
	void *buf;
	dma_addr_t dma;
	void *setup_packet;
	dma_addr_t setup_dma;
	u32 length;
	u32 actual_length;
	u32 status;
	u32 error_count;
	u32 packet_count;
	u32 flags;
	u16 interval;
	struct dwc2_hcd_pipe_info pipe_info;
	struct dwc2_hcd_iso_packet_desc iso_descs[0];
};

struct ohci_driver_overrides {
	const char *product_desc;
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
};

enum ohci_rh_state {
	OHCI_RH_HALTED = 0,
	OHCI_RH_SUSPENDED = 1,
	OHCI_RH_RUNNING = 2,
};

struct ohci_regs;

struct ohci_hcca;

struct ed;

struct td;

struct ohci_hcd {
	spinlock_t lock;
	struct ohci_regs *regs;
	struct ohci_hcca *hcca;
	dma_addr_t hcca_dma;
	struct ed *ed_rm_list;
	struct ed *ed_bulktail;
	struct ed *ed_controltail;
	struct ed *periodic[32];
	void (*start_hnp)(struct ohci_hcd *);
	struct dma_pool *td_cache;
	struct dma_pool *ed_cache;
	struct td *td_hash[64];
	struct td *dl_start;
	struct td *dl_end;
	struct list_head pending;
	struct list_head eds_in_use;
	enum ohci_rh_state rh_state;
	int num_ports;
	int load[32];
	u32 hc_control;
	unsigned long next_statechange;
	u32 fminterval;
	unsigned int autostop: 1;
	unsigned int working: 1;
	unsigned int restart_work: 1;
	unsigned long flags;
	unsigned int prev_frame_no;
	unsigned int wdh_cnt;
	unsigned int prev_wdh_cnt;
	u32 prev_donehead;
	struct timer_list io_watchdog;
	struct work_struct nec_work;
	struct dentry *debug_dir;
	unsigned long priv[0];
};

typedef __u32 __hc32;

struct ohci_roothub_regs {
	__hc32 a;
	__hc32 b;
	__hc32 status;
	__hc32 portstatus[15];
};

struct ohci_regs {
	__hc32 revision;
	__hc32 control;
	__hc32 cmdstatus;
	__hc32 intrstatus;
	__hc32 intrenable;
	__hc32 intrdisable;
	__hc32 hcca;
	__hc32 ed_periodcurrent;
	__hc32 ed_controlhead;
	__hc32 ed_controlcurrent;
	__hc32 ed_bulkhead;
	__hc32 ed_bulkcurrent;
	__hc32 donehead;
	__hc32 fminterval;
	__hc32 fmremaining;
	__hc32 fmnumber;
	__hc32 periodicstart;
	__hc32 lsthresh;
	struct ohci_roothub_regs roothub;
	long: 64;
	long: 64;
};

struct ohci_hcca {
	__hc32 int_table[32];
	__hc32 frame_no;
	__hc32 done_head;
	u8 reserved_for_hc[116];
	u8 what[4];
};

struct ed {
	__hc32 hwINFO;
	__hc32 hwTailP;
	__hc32 hwHeadP;
	__hc32 hwNextED;
	dma_addr_t dma;
	struct td *dummy;
	struct ed *ed_next;
	struct ed *ed_prev;
	struct list_head td_list;
	struct list_head in_use_list;
	u8 state;
	u8 type;
	u8 branch;
	u16 interval;
	u16 load;
	u16 last_iso;
	u16 tick;
	unsigned int takeback_wdh_cnt;
	struct td *pending_td;
	long: 64;
};

typedef __u16 __hc16;

struct td {
	__hc32 hwINFO;
	__hc32 hwCBP;
	__hc32 hwNextTD;
	__hc32 hwBE;
	__hc16 hwPSW[2];
	__u8 index;
	struct ed *ed;
	struct td *td_hash;
	struct td *next_dl_td;
	struct urb *urb;
	dma_addr_t td_dma;
	dma_addr_t data_dma;
	struct list_head td_list;
	long: 64;
};

typedef void (*btf_trace_musb_log)(void *, struct musb *, struct va_format *);

typedef void (*btf_trace_musb_state)(void *, struct musb *, u8, const char *);

typedef void (*btf_trace_musb_readb)(void *, void *, const void *, unsigned int, u8);

typedef void (*btf_trace_musb_writeb)(void *, void *, const void *, unsigned int, u8);

typedef void (*btf_trace_musb_readw)(void *, void *, const void *, unsigned int, u16);

typedef void (*btf_trace_musb_writew)(void *, void *, const void *, unsigned int, u16);

typedef void (*btf_trace_musb_readl)(void *, void *, const void *, unsigned int, u32);

typedef void (*btf_trace_musb_writel)(void *, void *, const void *, unsigned int, u32);

typedef void (*btf_trace_musb_isr)(void *, struct musb *);

typedef void (*btf_trace_musb_urb_start)(void *, struct musb *, struct urb *);

typedef void (*btf_trace_musb_urb_gb)(void *, struct musb *, struct urb *);

typedef void (*btf_trace_musb_urb_rx)(void *, struct musb *, struct urb *);

typedef void (*btf_trace_musb_urb_tx)(void *, struct musb *, struct urb *);

typedef void (*btf_trace_musb_urb_enq)(void *, struct musb *, struct urb *);

typedef void (*btf_trace_musb_urb_deq)(void *, struct musb *, struct urb *);

struct musb_request;

typedef void (*btf_trace_musb_req_gb)(void *, struct musb_request *);

enum buffer_map_state {
	UN_MAPPED = 0,
	PRE_MAPPED = 1,
	MUSB_MAPPED = 2,
};

struct musb_request {
	struct usb_request request;
	struct list_head list;
	struct musb_ep *ep;
	struct musb *musb;
	u8 tx;
	u8 epnum;
	enum buffer_map_state map_state;
};

typedef void (*btf_trace_musb_req_tx)(void *, struct musb_request *);

typedef void (*btf_trace_musb_req_rx)(void *, struct musb_request *);

typedef void (*btf_trace_musb_req_alloc)(void *, struct musb_request *);

typedef void (*btf_trace_musb_req_free)(void *, struct musb_request *);

typedef void (*btf_trace_musb_req_start)(void *, struct musb_request *);

typedef void (*btf_trace_musb_req_enq)(void *, struct musb_request *);

typedef void (*btf_trace_musb_req_deq)(void *, struct musb_request *);

struct trace_event_raw_musb_log {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_musb_state {
	struct trace_entry ent;
	u32 __data_loc_name;
	u8 devctl;
	u32 __data_loc_desc;
	char __data[0];
};

struct trace_event_raw_musb_regb {
	struct trace_entry ent;
	void *caller;
	const void *addr;
	unsigned int offset;
	u8 data;
	char __data[0];
};

struct trace_event_raw_musb_regw {
	struct trace_entry ent;
	void *caller;
	const void *addr;
	unsigned int offset;
	u16 data;
	char __data[0];
};

struct trace_event_raw_musb_regl {
	struct trace_entry ent;
	void *caller;
	const void *addr;
	unsigned int offset;
	u32 data;
	char __data[0];
};

struct trace_event_raw_musb_isr {
	struct trace_entry ent;
	u32 __data_loc_name;
	u8 int_usb;
	u16 int_tx;
	u16 int_rx;
	char __data[0];
};

struct trace_event_raw_musb_urb {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct urb *urb;
	unsigned int pipe;
	int status;
	unsigned int flag;
	u32 buf_len;
	u32 actual_len;
	char __data[0];
};

struct trace_event_raw_musb_req {
	struct trace_entry ent;
	struct usb_request *req;
	u8 is_tx;
	u8 epnum;
	int status;
	unsigned int buf_len;
	unsigned int actual_len;
	unsigned int zero;
	unsigned int short_not_ok;
	unsigned int no_interrupt;
	char __data[0];
};

struct trace_event_data_offsets_musb_log {
	u32 name;
	u32 msg;
};

struct trace_event_data_offsets_musb_state {
	u32 name;
	u32 desc;
};

struct trace_event_data_offsets_musb_isr {
	u32 name;
};

struct trace_event_data_offsets_musb_urb {
	u32 name;
};

struct trace_event_data_offsets_musb_regb {};

struct trace_event_data_offsets_musb_regw {};

struct trace_event_data_offsets_musb_regl {};

struct trace_event_data_offsets_musb_req {};

struct rzv2m_usb3drd {
	void *reg;
	int drd_irq;
	struct device *dev;
	struct reset_control *drd_rstc;
};

enum {
	KPARAM_X = 0,
	KPARAM_Y = 1,
	KPARAM_CNT = 2,
};

struct xenkbd_motion {
	uint8_t type;
	int32_t rel_x;
	int32_t rel_y;
	int32_t rel_z;
};

struct xenkbd_key {
	uint8_t type;
	uint8_t pressed;
	uint32_t keycode;
};

struct xenkbd_position {
	uint8_t type;
	int32_t abs_x;
	int32_t abs_y;
	int32_t rel_z;
};

struct xenkbd_mtouch {
	uint8_t type;
	uint8_t event_type;
	uint8_t contact_id;
	uint8_t reserved[5];
	union {
		struct {
			int32_t abs_x;
			int32_t abs_y;
		} pos;
		struct {
			uint32_t major;
			uint32_t minor;
		} shape;
		int16_t orientation;
	} u;
};

union xenkbd_in_event {
	uint8_t type;
	struct xenkbd_motion motion;
	struct xenkbd_key key;
	struct xenkbd_position pos;
	struct xenkbd_mtouch mtouch;
	char pad[40];
};

struct xenkbd_page;

struct xenkbd_info {
	struct input_dev *kbd;
	struct input_dev *ptr;
	struct input_dev *mtouch;
	struct xenkbd_page *page;
	int gref;
	int irq;
	struct xenbus_device *xbdev;
	char phys[32];
	int mtouch_cur_contact_id;
};

struct xenkbd_page {
	uint32_t in_cons;
	uint32_t in_prod;
	uint32_t out_cons;
	uint32_t out_prod;
};

struct i2c_smbus_alert {
	struct work_struct alert;
	struct i2c_client *ara;
};

struct alert_data {
	unsigned short addr;
	enum i2c_alert_protocol type;
	unsigned int data;
};

struct i2c_slave_host_notify_status {
	u8 index;
	u8 addr;
};

struct i2c_smbus_alert_setup {
	int irq;
};

struct pxa_reg_layout {
	u32 ibmr;
	u32 idbr;
	u32 icr;
	u32 isr;
	u32 isar;
	u32 ilcr;
	u32 iwcr;
	u32 fm;
	u32 hs;
};

enum pxa_i2c_types {
	REGS_PXA2XX = 0,
	REGS_PXA3XX = 1,
	REGS_CE4100 = 2,
	REGS_PXA910 = 3,
	REGS_A3700 = 4,
};

struct pxa_i2c {
	spinlock_t lock;
	wait_queue_head_t wait;
	struct i2c_msg *msg;
	unsigned int msg_num;
	unsigned int msg_idx;
	unsigned int msg_ptr;
	unsigned int slave_addr;
	unsigned int req_slave_addr;
	struct i2c_adapter adap;
	struct clk *clk;
	unsigned int irqlogidx;
	u32 isrlog[32];
	u32 icrlog[32];
	void *reg_base;
	void *reg_ibmr;
	void *reg_idbr;
	void *reg_icr;
	void *reg_isr;
	void *reg_isar;
	void *reg_ilcr;
	void *reg_iwcr;
	unsigned long iobase;
	unsigned long iosize;
	int irq;
	unsigned int use_pio: 1;
	unsigned int fast_mode: 1;
	unsigned int high_mode: 1;
	unsigned char master_code;
	unsigned long rate;
	bool highmode_enter;
	u32 fm_mask;
	u32 hs_mask;
	struct i2c_bus_recovery_info recovery;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_default;
	struct pinctrl_state *pinctrl_recovery;
};

struct i2c_pxa_platform_data {
	unsigned int class;
	unsigned int use_pio: 1;
	unsigned int fast_mode: 1;
	unsigned int high_mode: 1;
	unsigned char master_code;
	unsigned long rate;
};

struct watchdog_core_data {
	struct device dev;
	struct cdev cdev;
	struct watchdog_device *wdd;
	struct mutex lock;
	ktime_t last_keepalive;
	ktime_t last_hw_keepalive;
	ktime_t open_deadline;
	struct hrtimer timer;
	struct kthread_work work;
	unsigned long status;
};

struct cpufreq_policy_data;

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	void (*adjust_perf)(unsigned int, unsigned long, unsigned long, unsigned long);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	int (*exit)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
	void (*register_em)(struct cpufreq_policy *);
};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct em_data_callback {
	int (*active_power)(struct device *, unsigned long *, unsigned long *);
	int (*get_cost)(struct device *, unsigned long, unsigned long *);
};

struct scmi_data {
	int domain_id;
	int nr_opp;
	struct device *cpu_dev;
	cpumask_var_t opp_shared_cpus;
};

typedef void sdio_irq_handler_t(struct sdio_func *);

struct sdio_func {
	struct mmc_card *card;
	struct device dev;
	sdio_irq_handler_t *irq_handler;
	unsigned int num;
	unsigned char class;
	unsigned short vendor;
	unsigned short device;
	unsigned int max_blksize;
	unsigned int cur_blksize;
	unsigned int enable_timeout;
	unsigned int state;
	u8 *tmpbuf;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
};

struct sdio_func_tuple {
	struct sdio_func_tuple *next;
	unsigned char code;
	unsigned char size;
	unsigned char data[0];
};

struct mmc_fixup {
	const char *name;
	u64 rev_start;
	u64 rev_end;
	unsigned int manfid;
	unsigned short oemid;
	unsigned short year;
	unsigned char month;
	u16 cis_vendor;
	u16 cis_device;
	unsigned int ext_csd_rev;
	const char *of_compatible;
	void (*vendor_fixup)(struct mmc_card *, int);
	int data;
};

enum {
	EVENT_CMD_COMPLETE = 0,
	EVENT_XFER_COMPLETE = 1,
	EVENT_DATA_COMPLETE = 2,
	EVENT_DATA_ERROR = 3,
};

enum {
	TRANS_MODE_PIO = 0,
	TRANS_MODE_IDMAC = 1,
	TRANS_MODE_EDMAC = 2,
};

enum dw_mci_cookie {
	COOKIE_UNMAPPED = 0,
	COOKIE_PRE_MAPPED = 1,
	COOKIE_MAPPED = 2,
};

struct idmac_desc_64addr {
	u32 des0;
	u32 des1;
	u32 des2;
	u32 des3;
	u32 des4;
	u32 des5;
	u32 des6;
	u32 des7;
};

struct idmac_desc {
	__le32 des0;
	__le32 des1;
	__le32 des2;
	__le32 des3;
};

enum led_default_state {
	LEDS_DEFSTATE_OFF = 0,
	LEDS_DEFSTATE_ON = 1,
	LEDS_DEFSTATE_KEEP = 2,
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

struct ti_sci_desc {
	u8 default_host_id;
	int max_rx_timeout_ms;
	int max_msgs;
	int max_msg_size;
};

struct ti_sci_xfer;

struct ti_sci_xfers_info {
	struct semaphore sem_xfer_count;
	struct ti_sci_xfer *xfer_block;
	unsigned long *xfer_alloc_table;
	spinlock_t xfer_lock;
};

struct ti_sci_info {
	struct device *dev;
	struct notifier_block nb;
	const struct ti_sci_desc *desc;
	struct dentry *d;
	void *debug_region;
	char *debug_buffer;
	size_t debug_region_size;
	struct ti_sci_handle handle;
	struct mbox_client cl;
	struct mbox_chan *chan_tx;
	struct mbox_chan *chan_rx;
	struct ti_sci_xfers_info minfo;
	struct list_head node;
	u8 host_id;
	int users;
};

struct ti_msgmgr_message {
	size_t len;
	u8 *buf;
	struct mbox_chan *chan_rx;
	int timeout_rx_ms;
};

struct ti_sci_xfer {
	struct ti_msgmgr_message tx_message;
	u8 rx_len;
	u8 *xfer_buf;
	struct completion done;
};

struct ti_sci_msg_hdr {
	u16 type;
	u8 host;
	u8 seq;
	u32 flags;
};

struct ti_sci_msg_resp_version {
	struct ti_sci_msg_hdr hdr;
	char firmware_description[32];
	u16 firmware_revision;
	u8 abi_major;
	u8 abi_minor;
};

struct ti_sci_msg_req_reboot {
	struct ti_sci_msg_hdr hdr;
};

struct ti_sci_msg_req_set_device_state {
	struct ti_sci_msg_hdr hdr;
	u32 id;
	u32 reserved;
	u8 state;
} __attribute__((packed));

struct ti_sci_msg_req_get_device_state {
	struct ti_sci_msg_hdr hdr;
	u32 id;
};

struct ti_sci_msg_resp_get_device_state {
	struct ti_sci_msg_hdr hdr;
	u32 context_loss_count;
	u32 resets;
	u8 programmed_state;
	u8 current_state;
} __attribute__((packed));

struct ti_sci_msg_req_set_device_resets {
	struct ti_sci_msg_hdr hdr;
	u32 id;
	u32 resets;
};

struct ti_sci_msg_req_set_clock_state {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u8 request_state;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_req_get_clock_state {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_get_clock_state {
	struct ti_sci_msg_hdr hdr;
	u8 programmed_state;
	u8 current_state;
} __attribute__((packed));

struct ti_sci_msg_req_set_clock_parent {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u8 parent_id;
	u32 clk_id_32;
	u32 parent_id_32;
} __attribute__((packed));

struct ti_sci_msg_req_get_clock_parent {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_get_clock_parent {
	struct ti_sci_msg_hdr hdr;
	u8 parent_id;
	u32 parent_id_32;
} __attribute__((packed));

struct ti_sci_msg_req_get_clock_num_parents {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_get_clock_num_parents {
	struct ti_sci_msg_hdr hdr;
	u8 num_parents;
	u32 num_parents_32;
} __attribute__((packed));

struct ti_sci_msg_req_query_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u64 min_freq_hz;
	u64 target_freq_hz;
	u64 max_freq_hz;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_query_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u64 freq_hz;
};

struct ti_sci_msg_req_set_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u64 min_freq_hz;
	u64 target_freq_hz;
	u64 max_freq_hz;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_req_get_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_get_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u64 freq_hz;
};

struct ti_sci_msg_req_get_resource_range {
	struct ti_sci_msg_hdr hdr;
	u16 type;
	u8 subtype;
	u8 secondary_host;
};

struct ti_sci_msg_resp_get_resource_range {
	struct ti_sci_msg_hdr hdr;
	u16 range_start;
	u16 range_num;
	u16 range_start_sec;
	u16 range_num_sec;
};

struct ti_sci_msg_req_manage_irq {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 src_id;
	u16 src_index;
	u16 dst_id;
	u16 dst_host_irq;
	u16 ia_id;
	u16 vint;
	u16 global_event;
	u8 vint_status_bit;
	u8 secondary_host;
};

struct ti_sci_msg_rm_ring_cfg_req {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u32 addr_lo;
	u32 addr_hi;
	u32 count;
	u8 mode;
	u8 size;
	u8 order_id;
	u16 virtid;
	u8 asel;
} __attribute__((packed));

struct ti_sci_msg_psil_pair {
	struct ti_sci_msg_hdr hdr;
	u32 nav_id;
	u32 src_thread;
	u32 dst_thread;
};

struct ti_sci_msg_psil_unpair {
	struct ti_sci_msg_hdr hdr;
	u32 nav_id;
	u32 src_thread;
	u32 dst_thread;
};

struct ti_sci_msg_rm_udmap_tx_ch_cfg_req {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u8 tx_pause_on_err;
	u8 tx_filt_einfo;
	u8 tx_filt_pswords;
	u8 tx_atype;
	u8 tx_chan_type;
	u8 tx_supr_tdpkt;
	u16 tx_fetch_size;
	u8 tx_credit_count;
	u16 txcq_qnum;
	u8 tx_priority;
	u8 tx_qos;
	u8 tx_orderid;
	u16 fdepth;
	u8 tx_sched_priority;
	u8 tx_burst_size;
	u8 tx_tdtype;
	u8 extended_ch_type;
} __attribute__((packed));

struct ti_sci_msg_rm_udmap_rx_ch_cfg_req {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u16 rx_fetch_size;
	u16 rxcq_qnum;
	u8 rx_priority;
	u8 rx_qos;
	u8 rx_orderid;
	u8 rx_sched_priority;
	u16 flowid_start;
	u16 flowid_cnt;
	u8 rx_pause_on_err;
	u8 rx_atype;
	u8 rx_chan_type;
	u8 rx_ignore_short;
	u8 rx_ignore_long;
	u8 rx_burst_size;
} __attribute__((packed));

struct ti_sci_msg_rm_udmap_flow_cfg_req {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 nav_id;
	u16 flow_index;
	u8 rx_einfo_present;
	u8 rx_psinfo_present;
	u8 rx_error_handling;
	u8 rx_desc_type;
	u16 rx_sop_offset;
	u16 rx_dest_qnum;
	u8 rx_src_tag_hi;
	u8 rx_src_tag_lo;
	u8 rx_dest_tag_hi;
	u8 rx_dest_tag_lo;
	u8 rx_src_tag_hi_sel;
	u8 rx_src_tag_lo_sel;
	u8 rx_dest_tag_hi_sel;
	u8 rx_dest_tag_lo_sel;
	u16 rx_fdq0_sz0_qnum;
	u16 rx_fdq1_qnum;
	u16 rx_fdq2_qnum;
	u16 rx_fdq3_qnum;
	u8 rx_ps_location;
} __attribute__((packed));

struct ti_sci_msg_req_proc_request {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
} __attribute__((packed));

struct ti_sci_msg_req_proc_release {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
} __attribute__((packed));

struct ti_sci_msg_req_proc_handover {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
	u8 host_id;
} __attribute__((packed));

struct ti_sci_msg_req_set_config {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
	u32 bootvector_low;
	u32 bootvector_high;
	u32 config_flags_set;
	u32 config_flags_clear;
} __attribute__((packed));

struct ti_sci_msg_req_set_ctrl {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
	u32 control_flags_set;
	u32 control_flags_clear;
} __attribute__((packed));

struct ti_sci_msg_req_get_status {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
} __attribute__((packed));

struct ti_sci_msg_resp_get_status {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
	u32 bootvector_low;
	u32 bootvector_high;
	u32 config_flags;
	u32 control_flags;
	u32 status_flags;
} __attribute__((packed));

struct scmi_shared_mem {
	__le32 reserved;
	__le32 channel_status;
	__le32 reserved1[2];
	__le32 flags;
	__le32 length;
	__le32 msg_header;
	u8 msg_payload[0];
};

struct efi_system_resource_table {
	u32 fw_resource_count;
	u32 fw_resource_count_max;
	u64 fw_resource_version;
	u8 entries[0];
};

struct esre_entry;

struct esre_attribute {
	struct attribute attr;
	ssize_t (*show)(struct esre_entry *, char *);
	ssize_t (*store)(struct esre_entry *, const char *, size_t);
};

struct efi_system_resource_entry_v1;

struct esre_entry {
	union {
		struct efi_system_resource_entry_v1 *esre1;
	} esre;
	struct kobject kobj;
	struct list_head list;
};

struct efi_system_resource_entry_v1 {
	efi_guid_t fw_class;
	u32 fw_type;
	u32 fw_version;
	u32 lowest_supported_fw_version;
	u32 capsule_flags;
	u32 last_attempt_version;
	u32 last_attempt_status;
};

struct mhu_link {
	unsigned int irq;
	void *tx_reg;
	void *rx_reg;
};

struct arm_mhu {
	void *base;
	struct mhu_link mlink[3];
	struct mbox_chan chan[3];
	struct mbox_controller mbox;
};

struct qcom_ipcc_chan_info;

struct qcom_ipcc {
	struct device *dev;
	void *base;
	struct irq_domain *irq_domain;
	struct mbox_chan *chans;
	struct qcom_ipcc_chan_info *mchan;
	struct mbox_controller mbox;
	int num_chans;
	int irq;
};

struct qcom_ipcc_chan_info {
	u16 client_id;
	u16 signal_id;
};

enum usb_data_roles {
	DR_NONE = 0,
	DR_HOST = 1,
	DR_DEVICE = 2,
};

enum host_event_code {
	EC_HOST_EVENT_LID_CLOSED = 1,
	EC_HOST_EVENT_LID_OPEN = 2,
	EC_HOST_EVENT_POWER_BUTTON = 3,
	EC_HOST_EVENT_AC_CONNECTED = 4,
	EC_HOST_EVENT_AC_DISCONNECTED = 5,
	EC_HOST_EVENT_BATTERY_LOW = 6,
	EC_HOST_EVENT_BATTERY_CRITICAL = 7,
	EC_HOST_EVENT_BATTERY = 8,
	EC_HOST_EVENT_THERMAL_THRESHOLD = 9,
	EC_HOST_EVENT_DEVICE = 10,
	EC_HOST_EVENT_THERMAL = 11,
	EC_HOST_EVENT_USB_CHARGER = 12,
	EC_HOST_EVENT_KEY_PRESSED = 13,
	EC_HOST_EVENT_INTERFACE_READY = 14,
	EC_HOST_EVENT_KEYBOARD_RECOVERY = 15,
	EC_HOST_EVENT_THERMAL_SHUTDOWN = 16,
	EC_HOST_EVENT_BATTERY_SHUTDOWN = 17,
	EC_HOST_EVENT_THROTTLE_START = 18,
	EC_HOST_EVENT_THROTTLE_STOP = 19,
	EC_HOST_EVENT_HANG_DETECT = 20,
	EC_HOST_EVENT_HANG_REBOOT = 21,
	EC_HOST_EVENT_PD_MCU = 22,
	EC_HOST_EVENT_BATTERY_STATUS = 23,
	EC_HOST_EVENT_PANIC = 24,
	EC_HOST_EVENT_KEYBOARD_FASTBOOT = 25,
	EC_HOST_EVENT_RTC = 26,
	EC_HOST_EVENT_MKBP = 27,
	EC_HOST_EVENT_USB_MUX = 28,
	EC_HOST_EVENT_MODE_CHANGE = 29,
	EC_HOST_EVENT_KEYBOARD_RECOVERY_HW_REINIT = 30,
	EC_HOST_EVENT_WOV = 31,
	EC_HOST_EVENT_INVALID = 32,
};

enum usb_pd_control_role {
	USB_PD_CTRL_ROLE_NO_CHANGE = 0,
	USB_PD_CTRL_ROLE_TOGGLE_ON = 1,
	USB_PD_CTRL_ROLE_TOGGLE_OFF = 2,
	USB_PD_CTRL_ROLE_FORCE_SINK = 3,
	USB_PD_CTRL_ROLE_FORCE_SOURCE = 4,
	USB_PD_CTRL_ROLE_FREEZE = 5,
	USB_PD_CTRL_ROLE_COUNT = 6,
};

enum usb_pd_control_mux {
	USB_PD_CTRL_MUX_NO_CHANGE = 0,
	USB_PD_CTRL_MUX_NONE = 1,
	USB_PD_CTRL_MUX_USB = 2,
	USB_PD_CTRL_MUX_DP = 3,
	USB_PD_CTRL_MUX_DOCK = 4,
	USB_PD_CTRL_MUX_AUTO = 5,
	USB_PD_CTRL_MUX_COUNT = 6,
};

enum usb_pd_control_swap {
	USB_PD_CTRL_SWAP_NONE = 0,
	USB_PD_CTRL_SWAP_DATA = 1,
	USB_PD_CTRL_SWAP_POWER = 2,
	USB_PD_CTRL_SWAP_VCONN = 3,
	USB_PD_CTRL_SWAP_COUNT = 4,
};

enum usb_chg_type {
	USB_CHG_TYPE_NONE = 0,
	USB_CHG_TYPE_PD = 1,
	USB_CHG_TYPE_C = 2,
	USB_CHG_TYPE_PROPRIETARY = 3,
	USB_CHG_TYPE_BC12_DCP = 4,
	USB_CHG_TYPE_BC12_CDP = 5,
	USB_CHG_TYPE_BC12_SDP = 6,
	USB_CHG_TYPE_OTHER = 7,
	USB_CHG_TYPE_VBUS = 8,
	USB_CHG_TYPE_UNKNOWN = 9,
	USB_CHG_TYPE_DEDICATED = 10,
};

struct cros_ec_extcon_info {
	struct device *dev;
	struct extcon_dev *edev;
	int port_id;
	struct cros_ec_device *ec;
	struct notifier_block notifier;
	unsigned int dr;
	bool pr;
	bool dp;
	bool mux;
	unsigned int power_type;
};

struct ec_response_usb_pd_ports {
	uint8_t num_ports;
};

struct usb_chg_measures {
	uint16_t voltage_max;
	uint16_t voltage_now;
	uint16_t current_max;
	uint16_t current_lim;
};

struct ec_response_usb_pd_power_info {
	uint8_t role;
	uint8_t type;
	uint8_t dualrole;
	uint8_t reserved1;
	struct usb_chg_measures meas;
	uint32_t max_power;
};

struct ec_params_usb_pd_power_info {
	uint8_t port;
};

struct ec_response_usb_pd_control_v1 {
	uint8_t enabled;
	uint8_t role;
	uint8_t polarity;
	char state[32];
};

struct ec_params_usb_pd_control {
	uint8_t port;
	uint8_t role;
	uint8_t mux;
	uint8_t swap;
};

struct ec_params_usb_pd_mux_info {
	uint8_t port;
};

struct ec_response_usb_pd_mux_info {
	uint8_t flags;
};

struct bcm_voter;

struct qcom_icc_provider {
	struct icc_provider provider;
	struct device *dev;
	struct qcom_icc_bcm * const *bcms;
	size_t num_bcms;
	struct bcm_voter *voter;
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

enum qdisc_state2_t {
	__QDISC_STATE2_RUNNING = 0,
};

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_sync __attribute__((btf_type_tag("percpu"))) *cpu_bstats;
	struct gnet_stats_queue __attribute__((btf_type_tag("percpu"))) *cpu_qstats;
	unsigned long rcu_state;
};

struct skb_array {
	struct ptr_ring ring;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u16 mpu;
	u8 linklayer;
	u8 shift;
};

struct psched_pktrate {
	u64 rate_pkts_ps;
	u32 mult;
	u8 shift;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc __attribute__((btf_type_tag("rcu"))) **p_miniq;
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eee eee;
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_NUMPROTO = 11,
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

struct net_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int icmp_strict_tag_validation: 1;
};

struct inet_protosw {
	struct list_head list;
	unsigned short type;
	unsigned short protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

typedef unsigned int t_key;

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct {
			struct {} __empty_tnode;
			struct key_vector __attribute__((btf_type_tag("rcu"))) *tnode[0];
		};
	};
};

struct trie {
	struct key_vector kv[1];
};

typedef u8 dscp_t;

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	dscp_t fa_dscp;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	struct callback_head rcu;
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector __attribute__((btf_type_tag("rcu"))) *parent;
	struct key_vector kv[1];
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	dscp_t dscp;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 offload_failed: 1;
	u8 unused: 5;
};

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct rtnexthop;

struct fib_config {
	u8 fc_dst_len;
	dscp_t fc_dscp;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct rtnexthop {
	unsigned short rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	dscp_t dscp;
	u8 type;
	u32 tb_id;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

struct hop_jumbo_hdr {
	u8 nexthdr;
	u8 hdrlen;
	u8 tlv_type;
	u8 tlv_len;
	__be32 jumbo_payload_len;
};

enum {
	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT = 0,
	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE = 1,
};

enum {
	DEVLINK_ATTR_STATS_RX_PACKETS = 0,
	DEVLINK_ATTR_STATS_RX_BYTES = 1,
	DEVLINK_ATTR_STATS_RX_DROPPED = 2,
	__DEVLINK_ATTR_STATS_MAX = 3,
	DEVLINK_ATTR_STATS_MAX = 2,
};

enum devlink_trap_generic_id {
	DEVLINK_TRAP_GENERIC_ID_SMAC_MC = 0,
	DEVLINK_TRAP_GENERIC_ID_VLAN_TAG_MISMATCH = 1,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER = 2,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_STP_FILTER = 3,
	DEVLINK_TRAP_GENERIC_ID_EMPTY_TX_LIST = 4,
	DEVLINK_TRAP_GENERIC_ID_PORT_LOOPBACK_FILTER = 5,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_ROUTE = 6,
	DEVLINK_TRAP_GENERIC_ID_TTL_ERROR = 7,
	DEVLINK_TRAP_GENERIC_ID_TAIL_DROP = 8,
	DEVLINK_TRAP_GENERIC_ID_NON_IP_PACKET = 9,
	DEVLINK_TRAP_GENERIC_ID_UC_DIP_MC_DMAC = 10,
	DEVLINK_TRAP_GENERIC_ID_DIP_LB = 11,
	DEVLINK_TRAP_GENERIC_ID_SIP_MC = 12,
	DEVLINK_TRAP_GENERIC_ID_SIP_LB = 13,
	DEVLINK_TRAP_GENERIC_ID_CORRUPTED_IP_HDR = 14,
	DEVLINK_TRAP_GENERIC_ID_IPV4_SIP_BC = 15,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_RESERVED_SCOPE = 16,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE = 17,
	DEVLINK_TRAP_GENERIC_ID_MTU_ERROR = 18,
	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH = 19,
	DEVLINK_TRAP_GENERIC_ID_RPF = 20,
	DEVLINK_TRAP_GENERIC_ID_REJECT_ROUTE = 21,
	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS = 22,
	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS = 23,
	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE = 24,
	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR = 25,
	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC = 26,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP = 27,
	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP = 28,
	DEVLINK_TRAP_GENERIC_ID_STP = 29,
	DEVLINK_TRAP_GENERIC_ID_LACP = 30,
	DEVLINK_TRAP_GENERIC_ID_LLDP = 31,
	DEVLINK_TRAP_GENERIC_ID_IGMP_QUERY = 32,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V1_REPORT = 33,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_REPORT = 34,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V3_REPORT = 35,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_LEAVE = 36,
	DEVLINK_TRAP_GENERIC_ID_MLD_QUERY = 37,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_REPORT = 38,
	DEVLINK_TRAP_GENERIC_ID_MLD_V2_REPORT = 39,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_DONE = 40,
	DEVLINK_TRAP_GENERIC_ID_IPV4_DHCP = 41,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DHCP = 42,
	DEVLINK_TRAP_GENERIC_ID_ARP_REQUEST = 43,
	DEVLINK_TRAP_GENERIC_ID_ARP_RESPONSE = 44,
	DEVLINK_TRAP_GENERIC_ID_ARP_OVERLAY = 45,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_SOLICIT = 46,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_ADVERT = 47,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BFD = 48,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BFD = 49,
	DEVLINK_TRAP_GENERIC_ID_IPV4_OSPF = 50,
	DEVLINK_TRAP_GENERIC_ID_IPV6_OSPF = 51,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BGP = 52,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BGP = 53,
	DEVLINK_TRAP_GENERIC_ID_IPV4_VRRP = 54,
	DEVLINK_TRAP_GENERIC_ID_IPV6_VRRP = 55,
	DEVLINK_TRAP_GENERIC_ID_IPV4_PIM = 56,
	DEVLINK_TRAP_GENERIC_ID_IPV6_PIM = 57,
	DEVLINK_TRAP_GENERIC_ID_UC_LB = 58,
	DEVLINK_TRAP_GENERIC_ID_LOCAL_ROUTE = 59,
	DEVLINK_TRAP_GENERIC_ID_EXTERNAL_ROUTE = 60,
	DEVLINK_TRAP_GENERIC_ID_IPV6_UC_DIP_LINK_LOCAL_SCOPE = 61,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_NODES = 62,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_ROUTERS = 63,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_SOLICIT = 64,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ADVERT = 65,
	DEVLINK_TRAP_GENERIC_ID_IPV6_REDIRECT = 66,
	DEVLINK_TRAP_GENERIC_ID_IPV4_ROUTER_ALERT = 67,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ALERT = 68,
	DEVLINK_TRAP_GENERIC_ID_PTP_EVENT = 69,
	DEVLINK_TRAP_GENERIC_ID_PTP_GENERAL = 70,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_SAMPLE = 71,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_TRAP = 72,
	DEVLINK_TRAP_GENERIC_ID_EARLY_DROP = 73,
	DEVLINK_TRAP_GENERIC_ID_VXLAN_PARSING = 74,
	DEVLINK_TRAP_GENERIC_ID_LLC_SNAP_PARSING = 75,
	DEVLINK_TRAP_GENERIC_ID_VLAN_PARSING = 76,
	DEVLINK_TRAP_GENERIC_ID_PPPOE_PPP_PARSING = 77,
	DEVLINK_TRAP_GENERIC_ID_MPLS_PARSING = 78,
	DEVLINK_TRAP_GENERIC_ID_ARP_PARSING = 79,
	DEVLINK_TRAP_GENERIC_ID_IP_1_PARSING = 80,
	DEVLINK_TRAP_GENERIC_ID_IP_N_PARSING = 81,
	DEVLINK_TRAP_GENERIC_ID_GRE_PARSING = 82,
	DEVLINK_TRAP_GENERIC_ID_UDP_PARSING = 83,
	DEVLINK_TRAP_GENERIC_ID_TCP_PARSING = 84,
	DEVLINK_TRAP_GENERIC_ID_IPSEC_PARSING = 85,
	DEVLINK_TRAP_GENERIC_ID_SCTP_PARSING = 86,
	DEVLINK_TRAP_GENERIC_ID_DCCP_PARSING = 87,
	DEVLINK_TRAP_GENERIC_ID_GTP_PARSING = 88,
	DEVLINK_TRAP_GENERIC_ID_ESP_PARSING = 89,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_NEXTHOP = 90,
	DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER = 91,
	DEVLINK_TRAP_GENERIC_ID_EAPOL = 92,
	DEVLINK_TRAP_GENERIC_ID_LOCKED_PORT = 93,
	__DEVLINK_TRAP_GENERIC_ID_MAX = 94,
	DEVLINK_TRAP_GENERIC_ID_MAX = 93,
};

enum devlink_trap_group_generic_id {
	DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS = 0,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS = 1,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_EXCEPTIONS = 2,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS = 3,
	DEVLINK_TRAP_GROUP_GENERIC_ID_TUNNEL_DROPS = 4,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_DROPS = 5,
	DEVLINK_TRAP_GROUP_GENERIC_ID_STP = 6,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LACP = 7,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LLDP = 8,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MC_SNOOPING = 9,
	DEVLINK_TRAP_GROUP_GENERIC_ID_DHCP = 10,
	DEVLINK_TRAP_GROUP_GENERIC_ID_NEIGH_DISCOVERY = 11,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BFD = 12,
	DEVLINK_TRAP_GROUP_GENERIC_ID_OSPF = 13,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BGP = 14,
	DEVLINK_TRAP_GROUP_GENERIC_ID_VRRP = 15,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PIM = 16,
	DEVLINK_TRAP_GROUP_GENERIC_ID_UC_LB = 17,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LOCAL_DELIVERY = 18,
	DEVLINK_TRAP_GROUP_GENERIC_ID_EXTERNAL_DELIVERY = 19,
	DEVLINK_TRAP_GROUP_GENERIC_ID_IPV6 = 20,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_EVENT = 21,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_GENERAL = 22,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_SAMPLE = 23,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_TRAP = 24,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PARSER_ERROR_DROPS = 25,
	DEVLINK_TRAP_GROUP_GENERIC_ID_EAPOL = 26,
	__DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 27,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 26,
};

struct devlink_trap_policer_item;

struct devlink_stats;

struct devlink_trap_group_item {
	const struct devlink_trap_group *group;
	struct devlink_trap_policer_item *policer_item;
	struct list_head list;
	struct devlink_stats __attribute__((btf_type_tag("percpu"))) *stats;
};

struct devlink_trap_policer_item {
	const struct devlink_trap_policer *policer;
	u64 rate;
	u64 burst;
	struct list_head list;
};

struct devlink_stats {
	u64_stats_t rx_bytes;
	u64_stats_t rx_packets;
	struct u64_stats_sync syncp;
};

struct devlink_trap_item {
	const struct devlink_trap *trap;
	struct devlink_trap_group_item *group_item;
	struct list_head list;
	enum devlink_trap_action action;
	struct devlink_stats __attribute__((btf_type_tag("percpu"))) *stats;
	void *priv;
};

struct devlink_trap_metadata {
	const char *trap_name;
	const char *trap_group_name;
	struct net_device *input_dev;
	netdevice_tracker dev_tracker;
	const struct flow_action_cookie *fa_cookie;
	enum devlink_trap_type trap_type;
};

struct rpc_sysfs_xprt_switch {
	struct kobject kobject;
	struct net *net;
	struct rpc_xprt_switch *xprt_switch;
	struct rpc_xprt *xprt;
};

struct rpc_sysfs_xprt {
	struct kobject kobject;
	struct rpc_xprt *xprt;
	struct rpc_xprt_switch *xprt_switch;
};

typedef struct rpc_xprt * (*xprt_switch_find_xprt_t)(struct rpc_xprt_switch *, const struct rpc_xprt *);

struct xdp_ring;

struct xsk_queue {
	u32 ring_mask;
	u32 nentries;
	u32 cached_prod;
	u32 cached_cons;
	struct xdp_ring *ring;
	u64 invalid_descs;
	u64 queue_empty_descs;
	size_t ring_vmalloc_size;
};

struct xdp_ring {
	u32 producer;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad1;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 consumer;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad2;
	u32 flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad3;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_umem_ring {
	struct xdp_ring ptrs;
	u64 desc[0];
};

struct xdp_rxtx_ring {
	struct xdp_ring ptrs;
	struct xdp_desc desc[0];
};

struct xsk_map;

struct xsk_map_node {
	struct list_head node;
	struct xsk_map *map;
	struct xdp_sock __attribute__((btf_type_tag("rcu"))) **map_entry;
};

struct xsk_map {
	struct bpf_map map;
	spinlock_t lock;
	atomic_t count;
	struct xdp_sock __attribute__((btf_type_tag("rcu"))) *xsk_map[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum kvm_smccc_filter_action {
	KVM_SMCCC_FILTER_HANDLE = 0,
	KVM_SMCCC_FILTER_DENY = 1,
	KVM_SMCCC_FILTER_FWD_TO_USER = 2,
	NR_SMCCC_FILTER_ACTIONS = 3,
};

enum {
	KVM_REG_ARM_STD_HYP_BIT_PV_TIME = 0,
	KVM_REG_ARM_STD_HYP_BMAP_BIT_COUNT = 1,
};

enum {
	KVM_REG_ARM_STD_BIT_TRNG_V1_0 = 0,
	KVM_REG_ARM_STD_BMAP_BIT_COUNT = 1,
};

enum {
	KVM_REG_ARM_VENDOR_HYP_BIT_FUNC_FEAT = 0,
	KVM_REG_ARM_VENDOR_HYP_BIT_PTP = 1,
	KVM_REG_ARM_VENDOR_HYP_BMAP_BIT_COUNT = 2,
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t raw;
	enum clocksource_ids cs_id;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct kvm_smccc_filter {
	__u32 base;
	__u32 nr_functions;
	__u8 action;
	__u8 pad[15];
};

struct kvm_one_reg {
	__u64 id;
	__u64 addr;
};

enum kvm_arch_timers {
	TIMER_PTIMER = 0,
	TIMER_VTIMER = 1,
	NR_KVM_EL0_TIMERS = 2,
	TIMER_HVTIMER = 2,
	TIMER_HPTIMER = 3,
	NR_KVM_TIMERS = 4,
};

enum kvm_arch_timer_regs {
	TIMER_REG_CNT = 0,
	TIMER_REG_CVAL = 1,
	TIMER_REG_TVAL = 2,
	TIMER_REG_CTL = 3,
	TIMER_REG_VOFF = 4,
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

struct timer_map {
	struct arch_timer_context *direct_vtimer;
	struct arch_timer_context *direct_ptimer;
	struct arch_timer_context *emul_vtimer;
	struct arch_timer_context *emul_ptimer;
};

struct arch_timer_kvm_info {
	struct timecounter timecounter;
	int virtual_irq;
	int physical_irq;
};

struct kvm_arm_counter_offset {
	__u64 counter_offset;
	__u64 reserved;
};

struct gnttab_cache_flush {
	union {
		uint64_t dev_bus_addr;
		grant_ref_t ref;
	} a;
	uint16_t offset;
	uint16_t length;
	uint32_t op;
};

typedef u32 compat_size_t;

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct ucounts *ucounts;
};

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

typedef struct siginfo siginfo_t;

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
		} seccomp;
	};
};

struct ptrace_rseq_configuration {
	__u64 rseq_abi_pointer;
	__u32 rseq_abi_size;
	__u32 signature;
	__u32 flags;
	__u32 pad;
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

struct irq_generic_chip_devres {
	struct irq_chip_generic *gc;
	u32 msk;
	unsigned int clr;
	unsigned int set;
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
	IRQCHIP_AFFINITY_PRE_STARTUP = 1024,
	IRQCHIP_IMMUTABLE = 2048,
};

struct msi_domain_template {
	char name[48];
	struct irq_chip chip;
	struct msi_domain_ops ops;
	struct msi_domain_info info;
};

struct msi_ctrl {
	unsigned int domid;
	unsigned int first;
	unsigned int last;
	unsigned int nirqs;
};

struct msi_map {
	int index;
	int virq;
};

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

struct k_itimer;

struct itimerspec64;

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

enum alarmtimer_restart {
	ALARMTIMER_NORESTART = 0,
	ALARMTIMER_RESTART = 1,
};

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	int firing;
	struct task_struct __attribute__((btf_type_tag("rcu"))) *handling;
};

typedef __kernel_timer_t timer_t;

struct k_itimer {
	struct list_head list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_active;
	s64 it_overrun;
	s64 it_overrun_last;
	int it_requeue_pending;
	int it_sigev_notify;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue *sigq;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

struct futex_waitv {
	__u64 val;
	__u64 uaddr;
	__u32 flags;
	__u32 __reserved;
};

struct futex_vector {
	struct futex_waitv w;
	struct futex_q q;
};

struct auditd_connection {
	struct pid *pid;
	u32 portid;
	struct net *net;
	struct callback_head rcu;
};

struct audit_ctl_mutex {
	struct mutex lock;
	void *owner;
};

struct audit_features {
	__u32 vers;
	__u32 mask;
	__u32 features;
	__u32 lock;
};

enum audit_nlgrps {
	AUDIT_NLGRP_NONE = 0,
	AUDIT_NLGRP_READLOG = 1,
	__AUDIT_NLGRP_MAX = 2,
};

struct audit_reply {
	__u32 portid;
	struct net *net;
	struct sk_buff *skb;
};

struct audit_net {
	struct sock *sk;
};

struct audit_buffer {
	struct sk_buff *skb;
	struct audit_context *ctx;
	gfp_t gfp_mask;
};

struct audit_sig_info {
	uid_t uid;
	pid_t pid;
	char ctx[0];
};

struct audit_tty_status {
	__u32 enabled;
	__u32 log_passwd;
};

struct audit_status {
	__u32 mask;
	__u32 enabled;
	__u32 failure;
	__u32 pid;
	__u32 rate_limit;
	__u32 backlog_limit;
	__u32 lost;
	__u32 backlog;
	union {
		__u32 version;
		__u32 feature_bitmap;
	};
	__u32 backlog_wait_time;
	__u32 backlog_wait_time_actual;
};

struct audit_netlink_list {
	__u32 portid;
	struct net *net;
	struct sk_buff_head q;
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
};

typedef u32 kprobe_opcode_t;

struct kprobe;

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, unsigned long);

struct arch_specific_insn {
	struct arch_probe_insn api;
};

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	unsigned long nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_opcode_t opcode;
	struct arch_specific_insn ainsn;
	u32 flags;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct kretprobe_holder;

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct kretprobe_holder *rph;
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	unsigned long __attribute__((btf_type_tag("percpu"))) *nhit;
	const char *symbol;
	struct trace_probe tp;
};

struct kretprobe_instance {
	struct callback_head rcu;
	struct llist_node llist;
	struct kretprobe_holder *rph;
	kprobe_opcode_t *ret_addr;
	void *fp;
	char data[0];
};

struct objpool_head;

typedef int (*objpool_fini_cb)(struct objpool_head *, void *);

struct objpool_slot;

struct objpool_head {
	int obj_size;
	int nr_objs;
	int nr_cpus;
	int capacity;
	gfp_t gfp;
	refcount_t ref;
	unsigned long flags;
	struct objpool_slot **cpu_slots;
	objpool_fini_cb release;
	void *context;
};

struct kretprobe_holder {
	struct kretprobe __attribute__((btf_type_tag("rcu"))) *rp;
	struct objpool_head pool;
};

struct objpool_slot {
	uint32_t head;
	uint32_t tail;
	uint32_t last;
	uint32_t mask;
	void *entries[0];
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	unsigned long func;
	unsigned long ret_ip;
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	unsigned long ip;
};

struct sym_count_ctx {
	unsigned int count;
	const char *name;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	u64 idx_usage_counts[16];
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

typedef u64 (*btf_bpf_task_storage_get_recur)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_task_storage_get)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_task_storage_delete_recur)(struct bpf_map *, struct task_struct *);

typedef u64 (*btf_bpf_task_storage_delete)(struct bpf_map *, struct task_struct *);

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage __attribute__((btf_type_tag("rcu"))) *local_storage;
	struct callback_head rcu;
	long: 64;
	struct bpf_local_storage_data sdata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct perf_event_mmap_page;

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long watermark;
	long aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	unsigned long mmap_locked;
	struct user_struct *mmap_user;
	long aux_head;
	unsigned int aux_nest;
	long aux_wakeup;
	unsigned long aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	unsigned long aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int online;
	struct perf_cgroup *cgrp;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
};

struct perf_guest_info_callbacks {
	unsigned int (*state)();
	unsigned long (*get_ip)();
	unsigned int (*handle_intel_pt_intr)();
};

struct swevent_hlist;

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
	int recursion[4];
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct min_heap_callbacks {
	int elem_size;
	bool (*less)(const void *, const void *);
	void (*swp)(void *, void *);
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_CPU = 8,
	EVENT_CGROUP = 16,
	EVENT_ALL = 3,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_AUX_OUTPUT_HW_ID = 21,
	PERF_RECORD_MAX = 22,
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_LOST = 16,
	PERF_FORMAT_MAX = 32,
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_PRIV_SAVE = 262144,
	PERF_SAMPLE_BRANCH_MAX = 524288,
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum perf_event_arm_regs {
	PERF_REG_ARM64_X0 = 0,
	PERF_REG_ARM64_X1 = 1,
	PERF_REG_ARM64_X2 = 2,
	PERF_REG_ARM64_X3 = 3,
	PERF_REG_ARM64_X4 = 4,
	PERF_REG_ARM64_X5 = 5,
	PERF_REG_ARM64_X6 = 6,
	PERF_REG_ARM64_X7 = 7,
	PERF_REG_ARM64_X8 = 8,
	PERF_REG_ARM64_X9 = 9,
	PERF_REG_ARM64_X10 = 10,
	PERF_REG_ARM64_X11 = 11,
	PERF_REG_ARM64_X12 = 12,
	PERF_REG_ARM64_X13 = 13,
	PERF_REG_ARM64_X14 = 14,
	PERF_REG_ARM64_X15 = 15,
	PERF_REG_ARM64_X16 = 16,
	PERF_REG_ARM64_X17 = 17,
	PERF_REG_ARM64_X18 = 18,
	PERF_REG_ARM64_X19 = 19,
	PERF_REG_ARM64_X20 = 20,
	PERF_REG_ARM64_X21 = 21,
	PERF_REG_ARM64_X22 = 22,
	PERF_REG_ARM64_X23 = 23,
	PERF_REG_ARM64_X24 = 24,
	PERF_REG_ARM64_X25 = 25,
	PERF_REG_ARM64_X26 = 26,
	PERF_REG_ARM64_X27 = 27,
	PERF_REG_ARM64_X28 = 28,
	PERF_REG_ARM64_X29 = 29,
	PERF_REG_ARM64_LR = 30,
	PERF_REG_ARM64_SP = 31,
	PERF_REG_ARM64_PC = 32,
	PERF_REG_ARM64_MAX = 33,
	PERF_REG_ARM64_VG = 46,
	PERF_REG_ARM64_EXTENDED_MAX = 47,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

enum {
	IF_ACT_NONE = -1,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	unsigned long offset;
	unsigned long size;
	enum perf_addr_filter_action_t action;
};

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

typedef void perf_iterate_f(struct perf_event *, void *);

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	u8 build_id[20];
	u32 build_id_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_aux_event {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u64 hw_id;
};

struct __group_key {
	int cpu;
	struct pmu *pmu;
	struct cgroup *cgroup;
};

struct perf_cgroup_event {
	char *path;
	int path_size;
	struct {
		struct perf_event_header header;
		u64 id;
		char path[0];
	} event_id;
};

struct min_heap {
	void *data;
	int nr;
	int size;
};

struct perf_aux_event___3 {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct perf_namespaces_event {
	struct task_struct *task;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

typedef void (*btf_trace_tlb_flush)(void *, int, unsigned long);

typedef void (*btf_trace_mm_migrate_pages)(void *, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, enum migrate_mode, int);

typedef void (*btf_trace_mm_migrate_pages_start)(void *, enum migrate_mode, int);

typedef void (*btf_trace_set_migration_pte)(void *, unsigned long, unsigned long, int);

typedef void (*btf_trace_remove_migration_pte)(void *, unsigned long, unsigned long, int);

enum hugetlb_page_flags {
	HPG_restore_reserve = 0,
	HPG_migratable = 1,
	HPG_temporary = 2,
	HPG_freed = 3,
	HPG_vmemmap_optimized = 4,
	HPG_raw_hwp_unreliable = 5,
	__NR_HPAGEFLAGS = 6,
};

struct trace_event_raw_tlb_flush {
	struct trace_entry ent;
	int reason;
	unsigned long pages;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	unsigned long succeeded;
	unsigned long failed;
	unsigned long thp_succeeded;
	unsigned long thp_failed;
	unsigned long thp_split;
	unsigned long large_folio_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages_start {
	struct trace_entry ent;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_migration_pte {
	struct trace_entry ent;
	unsigned long addr;
	unsigned long pte;
	int order;
	char __data[0];
};

struct trace_event_data_offsets_tlb_flush {};

struct trace_event_data_offsets_mm_migrate_pages {};

struct trace_event_data_offsets_mm_migrate_pages_start {};

struct trace_event_data_offsets_migration_pte {};

struct folio_referenced_arg {
	int mapcount;
	int referenced;
	unsigned long vm_flags;
	struct mem_cgroup *memcg;
};

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_INO64_GEN = 129,
	FILEID_INO64_GEN_PARENT = 130,
	FILEID_LUSTRE = 151,
	FILEID_BCACHEFS_WITHOUT_PARENT = 177,
	FILEID_BCACHEFS_WITH_PARENT = 178,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct elf64_note {
	Elf64_Word n_namesz;
	Elf64_Word n_descsz;
	Elf64_Word n_type;
};

struct elf_thread_core_info___2;

struct elf_note_info___2 {
	struct elf_thread_core_info___2 *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus_common {
	struct elf_siginfo pr_info;
	short pr_cursig;
	unsigned long pr_sigpend;
	unsigned long pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
};

typedef unsigned long elf_greg_t;

typedef elf_greg_t elf_gregset_t[34];

struct elf_prstatus {
	struct elf_prstatus_common common;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

struct elf_thread_core_info___2 {
	struct elf_thread_core_info___2 *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	unsigned long pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
};

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	unsigned long magic;
	bool new_sb_created;
};

typedef unsigned short __kernel_uid16_t;

typedef __kernel_uid16_t uid16_t;

typedef unsigned short __kernel_gid16_t;

typedef __kernel_gid16_t gid16_t;

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct ext4_io_end;

typedef struct ext4_io_end ext4_io_end_t;

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	sector_t io_next_block;
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	unsigned int can_map: 1;
	unsigned long first_page;
	unsigned long next_page;
	unsigned long last_page;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
	unsigned int journalled_more_data: 1;
};

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	refcount_t count;
	struct list_head list_vec;
};

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
};

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
	EXT4_IGET_BAD = 4,
	EXT4_IGET_EA_INODE = 8,
} ext4_iget_flags;

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct squashfs_stream {
	void *stream;
	struct mutex mutex;
};

enum iter_type {
	ITER_UBUF = 0,
	ITER_IOVEC = 1,
	ITER_BVEC = 2,
	ITER_KVEC = 3,
	ITER_XARRAY = 4,
	ITER_DISCARD = 5,
};

enum {
	FATTR4_SUPPORTED_ATTRS = 0,
	FATTR4_TYPE = 1,
	FATTR4_FH_EXPIRE_TYPE = 2,
	FATTR4_CHANGE = 3,
	FATTR4_SIZE = 4,
	FATTR4_LINK_SUPPORT = 5,
	FATTR4_SYMLINK_SUPPORT = 6,
	FATTR4_NAMED_ATTR = 7,
	FATTR4_FSID = 8,
	FATTR4_UNIQUE_HANDLES = 9,
	FATTR4_LEASE_TIME = 10,
	FATTR4_RDATTR_ERROR = 11,
	FATTR4_ACL = 12,
	FATTR4_ACLSUPPORT = 13,
	FATTR4_ARCHIVE = 14,
	FATTR4_CANSETTIME = 15,
	FATTR4_CASE_INSENSITIVE = 16,
	FATTR4_CASE_PRESERVING = 17,
	FATTR4_CHOWN_RESTRICTED = 18,
	FATTR4_FILEHANDLE = 19,
	FATTR4_FILEID = 20,
	FATTR4_FILES_AVAIL = 21,
	FATTR4_FILES_FREE = 22,
	FATTR4_FILES_TOTAL = 23,
	FATTR4_FS_LOCATIONS = 24,
	FATTR4_HIDDEN = 25,
	FATTR4_HOMOGENEOUS = 26,
	FATTR4_MAXFILESIZE = 27,
	FATTR4_MAXLINK = 28,
	FATTR4_MAXNAME = 29,
	FATTR4_MAXREAD = 30,
	FATTR4_MAXWRITE = 31,
	FATTR4_MIMETYPE = 32,
	FATTR4_MODE = 33,
	FATTR4_NO_TRUNC = 34,
	FATTR4_NUMLINKS = 35,
	FATTR4_OWNER = 36,
	FATTR4_OWNER_GROUP = 37,
	FATTR4_QUOTA_AVAIL_HARD = 38,
	FATTR4_QUOTA_AVAIL_SOFT = 39,
	FATTR4_QUOTA_USED = 40,
	FATTR4_RAWDEV = 41,
	FATTR4_SPACE_AVAIL = 42,
	FATTR4_SPACE_FREE = 43,
	FATTR4_SPACE_TOTAL = 44,
	FATTR4_SPACE_USED = 45,
	FATTR4_SYSTEM = 46,
	FATTR4_TIME_ACCESS = 47,
	FATTR4_TIME_ACCESS_SET = 48,
	FATTR4_TIME_BACKUP = 49,
	FATTR4_TIME_CREATE = 50,
	FATTR4_TIME_DELTA = 51,
	FATTR4_TIME_METADATA = 52,
	FATTR4_TIME_MODIFY = 53,
	FATTR4_TIME_MODIFY_SET = 54,
	FATTR4_MOUNTED_ON_FILEID = 55,
};

enum nfs4_client_state {
	NFS4CLNT_MANAGER_RUNNING = 0,
	NFS4CLNT_CHECK_LEASE = 1,
	NFS4CLNT_LEASE_EXPIRED = 2,
	NFS4CLNT_RECLAIM_REBOOT = 3,
	NFS4CLNT_RECLAIM_NOGRACE = 4,
	NFS4CLNT_DELEGRETURN = 5,
	NFS4CLNT_SESSION_RESET = 6,
	NFS4CLNT_LEASE_CONFIRM = 7,
	NFS4CLNT_SERVER_SCOPE_MISMATCH = 8,
	NFS4CLNT_PURGE_STATE = 9,
	NFS4CLNT_BIND_CONN_TO_SESSION = 10,
	NFS4CLNT_MOVED = 11,
	NFS4CLNT_LEASE_MOVED = 12,
	NFS4CLNT_DELEGATION_EXPIRED = 13,
	NFS4CLNT_RUN_MANAGER = 14,
	NFS4CLNT_MANAGER_AVAILABLE = 15,
	NFS4CLNT_RECALL_RUNNING = 16,
	NFS4CLNT_RECALL_ANY_LAYOUT_READ = 17,
	NFS4CLNT_RECALL_ANY_LAYOUT_RW = 18,
	NFS4CLNT_DELEGRETURN_DELAYED = 19,
};

enum pnfs_layoutreturn_type {
	RETURN_FILE = 1,
	RETURN_FSID = 2,
	RETURN_ALL = 3,
};

struct nfs4_copy_state {
	struct list_head copies;
	struct list_head src_copies;
	nfs4_stateid stateid;
	struct completion completion;
	uint64_t count;
	struct nfs_writeverf verf;
	int error;
	int flags;
	struct nfs4_state *parent_src_state;
	struct nfs4_state *parent_dst_state;
};

struct cb_layoutrecallargs {
	uint32_t cbl_recall_type;
	uint32_t cbl_layout_type;
	uint32_t cbl_layoutchanged;
	union {
		struct {
			struct nfs_fh cbl_fh;
			struct pnfs_layout_range cbl_range;
			nfs4_stateid cbl_stateid;
		};
		struct nfs_fsid cbl_fsid;
	};
};

struct cb_offloadargs {
	struct nfs_fh coa_fh;
	nfs4_stateid coa_stateid;
	uint32_t error;
	uint64_t wr_count;
	struct nfs_writeverf wr_writeverf;
};

struct cb_process_state {
	__be32 drc_status;
	struct nfs_client *clp;
	struct nfs4_slot *slot;
	u32 minorversion;
	struct net *net;
};

struct cb_getattrargs {
	struct nfs_fh fh;
	uint32_t bitmap[2];
};

struct cb_getattrres {
	__be32 status;
	uint32_t bitmap[2];
	uint64_t size;
	uint64_t change_attr;
	struct timespec64 ctime;
	struct timespec64 mtime;
};

struct cb_recallargs {
	struct nfs_fh fh;
	nfs4_stateid stateid;
	uint32_t truncate;
};

struct cb_devicenotifyitem;

struct cb_devicenotifyargs {
	uint32_t ndevs;
	struct cb_devicenotifyitem *devs;
};

struct cb_devicenotifyitem {
	uint32_t cbd_notify_type;
	uint32_t cbd_layout_type;
	struct nfs4_deviceid cbd_dev_id;
	uint32_t cbd_immediate;
};

struct cb_recallanyargs {
	uint32_t craa_objs_to_keep;
	uint32_t craa_type_mask;
};

struct cb_recallslotargs {
	uint32_t crsa_target_highest_slotid;
};

struct nfs_lowner {
	__u64 clientid;
	__u64 id;
	dev_t s_dev;
};

struct cb_notify_lock_args {
	struct nfs_fh cbnl_fh;
	struct nfs_lowner cbnl_owner;
	bool cbnl_valid;
};

struct nlm_reboot {
	char *mon;
	unsigned int len;
	u32 state;
	struct nsm_private priv;
};

struct nlm_block;

struct nlm_rqst {
	refcount_t a_count;
	unsigned int a_flags;
	struct nlm_host *a_host;
	struct nlm_args a_args;
	struct nlm_res a_res;
	struct nlm_block *a_block;
	unsigned int a_retries;
	u8 a_owner[74];
	void *a_callback_data;
};

struct nlm_block {
	struct kref b_count;
	struct list_head b_list;
	struct list_head b_flist;
	struct nlm_rqst *b_call;
	struct svc_serv *b_daemon;
	struct nlm_host *b_host;
	unsigned long b_when;
	unsigned int b_id;
	unsigned char b_granted;
	struct nlm_file *b_file;
	struct cache_req *b_cache_req;
	struct cache_deferred_req *b_deferred_req;
	unsigned int b_flags;
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
};

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct pstore_record;

struct pstore_info {
	struct module *owner;
	const char *name;
	spinlock_t buf_lock;
	char *buf;
	size_t bufsize;
	struct mutex read_mutex;
	int flags;
	int max_reason;
	void *data;
	int (*open)(struct pstore_info *);
	int (*close)(struct pstore_info *);
	ssize_t (*read)(struct pstore_record *);
	int (*write)(struct pstore_record *);
	int (*write_user)(struct pstore_record *, const char __attribute__((btf_type_tag("user"))) *);
	int (*erase)(struct pstore_record *);
};

enum pstore_type_id {
	PSTORE_TYPE_DMESG = 0,
	PSTORE_TYPE_MCE = 1,
	PSTORE_TYPE_CONSOLE = 2,
	PSTORE_TYPE_FTRACE = 3,
	PSTORE_TYPE_PPC_RTAS = 4,
	PSTORE_TYPE_PPC_OF = 5,
	PSTORE_TYPE_PPC_COMMON = 6,
	PSTORE_TYPE_PMSG = 7,
	PSTORE_TYPE_PPC_OPAL = 8,
	PSTORE_TYPE_MAX = 9,
};

struct pstore_record {
	struct pstore_info *psi;
	enum pstore_type_id type;
	u64 id;
	struct timespec64 time;
	char *buf;
	ssize_t size;
	ssize_t ecc_notice_size;
	void *priv;
	int count;
	enum kmsg_dump_reason reason;
	unsigned int part;
	bool compressed;
};

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, enum kmsg_dump_reason);
	enum kmsg_dump_reason max_reason;
	bool registered;
};

struct internal_state {
	int dummy;
};

struct kmsg_dump_iter {
	u64 cur_seq;
	u64 next_seq;
};

struct crypto_comp {
	struct crypto_tfm base;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
	MPI p;
	MPI q;
	MPI dp;
	MPI dq;
	MPI qinv;
};

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	u32 crc;
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct badblocks_context {
	sector_t start;
	sector_t len;
	int ack;
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_CTRL_NOCHECK = 4,
	BIP_DISK_NOCHECK = 8,
	BIP_IP_CHECKSUM = 16,
};

enum blk_integrity_flags {
	BLK_INTEGRITY_VERIFY = 1,
	BLK_INTEGRITY_GENERATE = 2,
	BLK_INTEGRITY_DEVICE_CAPABLE = 4,
	BLK_INTEGRITY_IP_CHECKSUM = 8,
};

enum {
	SOCKET_URING_OP_SIOCINQ = 0,
	SOCKET_URING_OP_SIOCOUTQ = 1,
	SOCKET_URING_OP_GETSOCKOPT = 2,
	SOCKET_URING_OP_SETSOCKOPT = 3,
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

struct sun6i_r_intc_variant {
	u32 first_mux_irq;
	u32 nr_mux_irqs;
	u32 mux_valid[4];
};

struct mvebu_icu_subset_data {
	unsigned int icu_group;
	unsigned int offset_set_ah;
	unsigned int offset_set_al;
	unsigned int offset_clr_ah;
	unsigned int offset_clr_al;
};

struct mvebu_icu {
	void *base;
	struct device *dev;
};

struct mvebu_icu_msi_data {
	struct mvebu_icu *icu;
	atomic_t initialized;
	const struct mvebu_icu_subset_data *subset_data;
};

struct mvebu_icu_irq_data {
	struct mvebu_icu *icu;
	unsigned int icu_group;
	unsigned int type;
};

struct ls_scfg_msi_cfg {
	u32 ibs_shift;
	u32 msir_irqs;
	u32 msir_base;
};

struct ls_scfg_msir;

struct ls_scfg_msi {
	spinlock_t lock;
	struct platform_device *pdev;
	struct irq_domain *parent;
	struct irq_domain *msi_domain;
	void *regs;
	phys_addr_t msiir_addr;
	struct ls_scfg_msi_cfg *cfg;
	u32 msir_num;
	struct ls_scfg_msir *msir;
	u32 irqs_num;
	unsigned long *used;
};

struct ls_scfg_msir {
	struct ls_scfg_msi *msi_data;
	unsigned int index;
	unsigned int gic_irq;
	unsigned int bit_start;
	unsigned int bit_end;
	unsigned int srs;
	void *reg;
};

struct irqsteer_data {
	void *regs;
	struct clk *ipg_clk;
	int irq[8];
	int irq_count;
	raw_spinlock_t lock;
	int reg_num;
	int channel;
	struct irq_domain *domain;
	u32 *saved_reg;
};

struct phy_meson8b_usb2_match_data {
	bool host_enable_aca;
};

struct phy_meson8b_usb2_priv {
	struct regmap *regmap;
	enum usb_dr_mode dr_mode;
	struct clk *clk_usb_general;
	struct clk *clk_usb;
	struct reset_control *reset;
	const struct phy_meson8b_usb2_match_data *match;
};

enum {
	CFG_PRE_INIT = 0,
	CFG_POST_INIT = 1,
	CFG_PRE_PWR_HS = 2,
	CFG_POST_PWR_HS = 3,
	CFG_TAG_MAX = 4,
};

enum {
	LANE_0 = 0,
	LANE_1 = 1,
};

struct samsung_ufs_phy {
	struct device *dev;
	void *reg_pma;
	struct regmap *reg_pmu;
	struct clk_bulk_data *clks;
	const struct samsung_ufs_phy_drvdata *drvdata;
	const struct samsung_ufs_phy_cfg * const *cfgs;
	struct samsung_ufs_phy_pmu_isol isol;
	u8 lane_cnt;
	int ufs_phy_state;
	enum phy_mode mode;
};

struct pcs_conf_type {
	const char *name;
	enum pin_config_param param;
};

struct pcs_soc_data {
	unsigned int flags;
	int irq;
	unsigned int irq_enable_mask;
	unsigned int irq_status_mask;
	void (*rearm)();
};

struct pcs_gpiofunc_range {
	unsigned int offset;
	unsigned int npins;
	unsigned int gpiofunc;
	struct list_head node;
};

struct pcs_data {
	struct pinctrl_pin_desc *pa;
	int cur;
};

struct pcs_device {
	struct resource *res;
	void *base;
	void *saved_vals;
	unsigned int size;
	struct device *dev;
	struct device_node *np;
	struct pinctrl_dev *pctl;
	unsigned int flags;
	struct property *missing_nr_pinctrl_cells;
	struct pcs_soc_data socdata;
	raw_spinlock_t lock;
	struct mutex mutex;
	unsigned int width;
	unsigned int fmask;
	unsigned int fshift;
	unsigned int foff;
	unsigned int fmax;
	bool bits_per_mux;
	unsigned int bits_per_pin;
	struct pcs_data pins;
	struct list_head gpiofuncs;
	struct list_head irqs;
	struct irq_chip chip;
	struct irq_domain *domain;
	struct pinctrl_desc desc;
	unsigned int (*read)(void *);
	void (*write)(unsigned int, void *);
};

struct pcs_interrupt {
	void *reg;
	irq_hw_number_t hwirq;
	unsigned int irq;
	struct list_head node;
};

struct pcs_func_vals {
	void *reg;
	unsigned int val;
	unsigned int mask;
};

struct pcs_conf_vals;

struct pcs_function {
	const char *name;
	struct pcs_func_vals *vals;
	unsigned int nvals;
	const char **pgnames;
	int npgnames;
	struct pcs_conf_vals *conf;
	int nconfs;
	struct list_head node;
};

struct pcs_conf_vals {
	enum pin_config_param param;
	unsigned int val;
	unsigned int enable;
	unsigned int disable;
	unsigned int mask;
};

struct pcs_pdata {
	int irq;
	void (*rearm)();
};

struct mtk_drive_desc {
	u8 min;
	u8 max;
	u8 step;
	u8 scal;
};

struct mtk_pin_field {
	u8 index;
	u32 offset;
	u32 mask;
	u8 bitpos;
	u8 next;
};

struct gpio_array {
	struct gpio_desc **desc;
	unsigned int size;
	struct gpio_chip *chip;
	unsigned long *get_mask;
	unsigned long *set_mask;
	unsigned long invert_mask[0];
};

struct pwm_device;

struct pwm_state;

typedef void (*btf_trace_pwm_apply)(void *, struct pwm_device *, const struct pwm_state *, int);

enum pwm_polarity {
	PWM_POLARITY_NORMAL = 0,
	PWM_POLARITY_INVERSED = 1,
};

struct pwm_args {
	u64 period;
	enum pwm_polarity polarity;
};

struct pwm_state {
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	bool usage_power;
};

struct pwm_chip;

struct pwm_device {
	const char *label;
	unsigned long flags;
	unsigned int hwpwm;
	unsigned int pwm;
	struct pwm_chip *chip;
	struct pwm_args args;
	struct pwm_state state;
	struct pwm_state last;
};

struct pwm_ops;

struct pwm_chip {
	struct device *dev;
	const struct pwm_ops *ops;
	struct module *owner;
	int base;
	unsigned int npwm;
	struct pwm_device * (*of_xlate)(struct pwm_chip *, const struct of_phandle_args *);
	unsigned int of_pwm_n_cells;
	struct list_head list;
	struct pwm_device *pwms;
};

struct pwm_capture;

struct pwm_ops {
	int (*request)(struct pwm_chip *, struct pwm_device *);
	void (*free)(struct pwm_chip *, struct pwm_device *);
	int (*capture)(struct pwm_chip *, struct pwm_device *, struct pwm_capture *, unsigned long);
	int (*apply)(struct pwm_chip *, struct pwm_device *, const struct pwm_state *);
	int (*get_state)(struct pwm_chip *, struct pwm_device *, struct pwm_state *);
};

struct pwm_capture {
	unsigned int period;
	unsigned int duty_cycle;
};

typedef void (*btf_trace_pwm_get)(void *, struct pwm_device *, const struct pwm_state *, int);

enum {
	PWMF_REQUESTED = 0,
	PWMF_EXPORTED = 1,
};

struct pwm_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
	unsigned int period;
	enum pwm_polarity polarity;
	const char *module;
};

struct trace_event_raw_pwm {
	struct trace_entry ent;
	struct pwm_device *pwm;
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_pwm {};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

enum {
	RCAR_PCI_ACCESS_READ = 0,
	RCAR_PCI_ACCESS_WRITE = 1,
};

struct rcar_pcie {
	struct device *dev;
	void *base;
};

struct rcar_msi {
	unsigned long used[1];
	struct irq_domain *domain;
	struct mutex map_lock;
	spinlock_t mask_lock;
	int irq1;
	int irq2;
};

struct rcar_pcie_host {
	struct rcar_pcie pcie;
	struct phy *phy;
	struct clk *bus_clk;
	struct rcar_msi msi;
	int (*phy_init_fn)(struct rcar_pcie_host *);
};

struct al_pcie_acpi {
	void *dbi_base;
};

struct display_timing;

struct display_timings {
	unsigned int num_timings;
	unsigned int native_mode;
	struct display_timing **timings;
};

struct timing_entry {
	u32 min;
	u32 typ;
	u32 max;
};

struct display_timing {
	struct timing_entry pixelclock;
	struct timing_entry hactive;
	struct timing_entry hfront_porch;
	struct timing_entry hback_porch;
	struct timing_entry hsync_len;
	struct timing_entry vactive;
	struct timing_entry vfront_porch;
	struct timing_entry vback_porch;
	struct timing_entry vsync_len;
	enum display_flags flags;
};

typedef u32 (*acpi_osd_handler)(void *);

struct acpi_ioremap {
	struct list_head list;
	void *virt;
	acpi_physical_address phys;
	acpi_size size;
	union {
		unsigned long refcount;
		struct rcu_work rwork;
	} track;
};

typedef void (*acpi_osd_exec_callback)(void *);

struct acpi_os_dpc {
	acpi_osd_exec_callback function;
	void *context;
	struct work_struct work;
};

struct acpi_hp_work {
	struct work_struct work;
	struct acpi_device *adev;
	u32 src;
};

struct acpi_predefined_names {
	const char *name;
	u8 type;
	char *val;
};

typedef enum {
	OSL_GLOBAL_LOCK_HANDLER = 0,
	OSL_NOTIFY_HANDLER = 1,
	OSL_GPE_HANDLER = 2,
	OSL_DEBUGGER_MAIN_THREAD = 3,
	OSL_DEBUGGER_EXEC_THREAD = 4,
	OSL_EC_POLL_HANDLER = 5,
	OSL_EC_BURST_HANDLER = 6,
} acpi_execute_type;

struct acpi_hardware_id {
	struct list_head list;
	const char *id;
};

struct acpi_data_node {
	const char *name;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct fwnode_handle *parent;
	struct acpi_device_data data;
	struct list_head sibling;
	struct kobject kobj;
	struct completion kobj_done;
};

struct acpi_device_properties {
	const guid_t *guid;
	union acpi_object *properties;
	struct list_head list;
	void **bufs;
};

typedef acpi_status (*acpi_repair_function)(struct acpi_evaluate_info *, union acpi_operand_object **);

struct acpi_repair_info {
	char name[4];
	acpi_repair_function repair_function;
};

struct acpi_rsconvert_info {
	u8 opcode;
	u8 resource_offset;
	u8 aml_offset;
	u8 value;
};

struct aml_resource_small_header {
	u8 descriptor_type;
};

struct aml_resource_large_header {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_irq {
	u8 descriptor_type;
	u16 irq_mask;
	u8 flags;
} __attribute__((packed));

struct aml_resource_dma {
	u8 descriptor_type;
	u8 dma_channel_mask;
	u8 flags;
};

struct aml_resource_start_dependent {
	u8 descriptor_type;
	u8 flags;
};

struct aml_resource_end_dependent {
	u8 descriptor_type;
};

struct aml_resource_io {
	u8 descriptor_type;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u8 alignment;
	u8 address_length;
};

struct aml_resource_fixed_io {
	u8 descriptor_type;
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct aml_resource_fixed_dma {
	u8 descriptor_type;
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct aml_resource_vendor_small {
	u8 descriptor_type;
};

struct aml_resource_end_tag {
	u8 descriptor_type;
	u8 checksum;
};

struct aml_resource_memory24 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_generic_register {
	u8 descriptor_type;
	u16 resource_length;
	u8 address_space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct aml_resource_vendor_large {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_fixed_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address16 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_address32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
} __attribute__((packed));

struct aml_resource_extended_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u8 revision_ID;
	u8 reserved;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
	u64 type_specific;
} __attribute__((packed));

struct aml_resource_extended_irq {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u8 interrupt_count;
	union {
		u32 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u32 interrupts[0];
		};
	};
} __attribute__((packed));

struct aml_resource_gpio {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 connection_type;
	u16 flags;
	u16 int_flags;
	u8 pin_config;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_i2c_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u16 slave_address;
} __attribute__((packed));

struct aml_resource_spi_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
} __attribute__((packed));

struct aml_resource_uart_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 default_baud_rate;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u8 parity;
	u8 lines_enabled;
} __attribute__((packed));

struct aml_resource_csi2_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_common_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_pin_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config;
	u16 function_number;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 pin_table_offset;
	u16 label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 function_number;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_clock_input {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 frequency_divisor;
	u32 frequency_numerator;
} __attribute__((packed));

struct aml_resource_address {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
} __attribute__((packed));

union aml_resource {
	u8 descriptor_type;
	struct aml_resource_small_header small_header;
	struct aml_resource_large_header large_header;
	struct aml_resource_irq irq;
	struct aml_resource_dma dma;
	struct aml_resource_start_dependent start_dpf;
	struct aml_resource_end_dependent end_dpf;
	struct aml_resource_io io;
	struct aml_resource_fixed_io fixed_io;
	struct aml_resource_fixed_dma fixed_dma;
	struct aml_resource_vendor_small vendor_small;
	struct aml_resource_end_tag end_tag;
	struct aml_resource_memory24 memory24;
	struct aml_resource_generic_register generic_reg;
	struct aml_resource_vendor_large vendor_large;
	struct aml_resource_memory32 memory32;
	struct aml_resource_fixed_memory32 fixed_memory32;
	struct aml_resource_address16 address16;
	struct aml_resource_address32 address32;
	struct aml_resource_address64 address64;
	struct aml_resource_extended_address64 ext_address64;
	struct aml_resource_extended_irq extended_irq;
	struct aml_resource_gpio gpio;
	struct aml_resource_i2c_serialbus i2c_serial_bus;
	struct aml_resource_spi_serialbus spi_serial_bus;
	struct aml_resource_uart_serialbus uart_serial_bus;
	struct aml_resource_csi2_serialbus csi2_serial_bus;
	struct aml_resource_common_serialbus common_serial_bus;
	struct aml_resource_pin_function pin_function;
	struct aml_resource_pin_config pin_config;
	struct aml_resource_pin_group pin_group;
	struct aml_resource_pin_group_function pin_group_function;
	struct aml_resource_pin_group_config pin_group_config;
	struct aml_resource_clock_input clock_input;
	struct aml_resource_address address;
	u32 dword_item;
	u16 word_item;
	u8 byte_item;
};

struct acpi_fan_fif {
	u8 revision;
	u8 fine_grain_ctrl;
	u8 step_size;
	u8 low_speed_notification;
};

struct acpi_fan_fps;

struct acpi_fan {
	bool acpi4;
	struct acpi_fan_fif fif;
	struct acpi_fan_fps *fps;
	int fps_count;
	struct thermal_cooling_device *cdev;
	struct device_attribute fst_speed;
	struct device_attribute fine_grain_control;
};

struct acpi_fan_fps {
	u64 control;
	u64 trip_point;
	u64 speed;
	u64 noise_level;
	u64 power;
	char name[20];
	struct device_attribute dev_attr;
};

struct acpi_fan_fst {
	u64 revision;
	u64 control;
	u64 speed;
};

enum vc5_model {
	IDT_VC5_5P49V5923 = 0,
	IDT_VC5_5P49V5925 = 1,
	IDT_VC5_5P49V5933 = 2,
	IDT_VC5_5P49V5935 = 3,
	IDT_VC6_5P49V60 = 4,
	IDT_VC6_5P49V6901 = 5,
	IDT_VC6_5P49V6965 = 6,
	IDT_VC6_5P49V6975 = 7,
};

struct vc5_chip_info {
	const enum vc5_model model;
	const unsigned int clk_fod_cnt;
	const unsigned int clk_out_cnt;
	const u32 flags;
	const unsigned long vco_max;
};

struct vc5_driver_data;

struct vc5_hw_data {
	struct clk_hw hw;
	struct vc5_driver_data *vc5;
	u32 div_int;
	u32 div_frc;
	unsigned int num;
};

struct vc5_out_data {
	struct clk_hw hw;
	struct vc5_driver_data *vc5;
	unsigned int num;
	unsigned int clk_output_cfg0;
	unsigned int clk_output_cfg0_mask;
};

struct vc5_driver_data {
	struct i2c_client *client;
	struct regmap *regmap;
	const struct vc5_chip_info *chip_info;
	struct clk *pin_xin;
	struct clk *pin_clkin;
	unsigned char clk_mux_ins;
	struct clk_hw clk_mux;
	struct clk_hw clk_mul;
	struct clk_hw clk_pfd;
	struct vc5_hw_data clk_pll;
	struct vc5_hw_data clk_fod[4];
	struct vc5_out_data clk_out[5];
};

struct clk_fracn_gppll {
	struct clk_hw hw;
	void *base;
	const struct imx_fracn_gppll_rate_table *rate_table;
	int rate_count;
	u32 flags;
};

struct clk_divider_gate {
	struct clk_divider divider;
	u32 cached_val;
};

struct clk_gate2 {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 cgr_val;
	u8 cgr_mask;
	u8 flags;
	spinlock_t *lock;
	unsigned int *share_count;
};

struct fhctl_offset {
	u32 offset_hp_en;
	u32 offset_clk_con;
	u32 offset_rst_con;
	u32 offset_slope0;
	u32 offset_slope1;
	u32 offset_cfg;
	u32 offset_updnlmt;
	u32 offset_dds;
	u32 offset_dvfs;
	u32 offset_mon;
};

struct mtk_fh;

struct fh_operation {
	int (*hopping)(struct mtk_fh *, unsigned int, unsigned int);
	int (*ssc_enable)(struct mtk_fh *, u32);
};

struct mtk_clk_pll {
	struct clk_hw hw;
	void *base_addr;
	void *pd_addr;
	void *pwr_addr;
	void *tuner_addr;
	void *tuner_en_addr;
	void *pcw_addr;
	void *pcw_chg_addr;
	void *en_addr;
	const struct mtk_pll_data *data;
};

struct fh_pll_regs {
	void *reg_hp_en;
	void *reg_clk_con;
	void *reg_rst_con;
	void *reg_slope0;
	void *reg_slope1;
	void *reg_cfg;
	void *reg_updnlmt;
	void *reg_dds;
	void *reg_dvfs;
	void *reg_mon;
};

struct mtk_pllfh_data;

struct mtk_fh {
	struct mtk_clk_pll clk_pll;
	struct fh_pll_regs regs;
	struct mtk_pllfh_data *pllfh_data;
	const struct fh_operation *ops;
	spinlock_t *lock;
};

struct fh_pll_state {
	void *base;
	u32 fh_enable;
	u32 ssc_rate;
};

struct fh_pll_data {
	int pll_id;
	int fh_id;
	int fh_ver;
	u32 fhx_offset;
	u32 dds_mask;
	u32 slope0_value;
	u32 slope1_value;
	u32 sfstrx_en;
	u32 frddsx_en;
	u32 fhctlx_en;
	u32 tgl_org;
	u32 dvfs_tri;
	u32 pcwchg;
	u32 dt_val;
	u32 df_val;
	u32 updnlmt_shft;
	u32 msk_frddsx_dys;
	u32 msk_frddsx_dts;
};

struct mtk_pllfh_data {
	struct fh_pll_state state;
	const struct fh_pll_data data;
};

enum fhctl_variant {
	FHCTL_PLLFH_V1 = 0,
	FHCTL_PLLFH_V2 = 1,
};

struct meson_aoclk_data {
	const unsigned int reset_reg;
	const int num_reset;
	const unsigned int *reset;
	const int num_clks;
	struct clk_regmap___2 **clks;
	struct meson_clk_hw_data hw_clks;
};

struct meson_clk_dualdiv_param {
	unsigned int n1;
	unsigned int n2;
	unsigned int m1;
	unsigned int m2;
	unsigned int dual;
};

enum clk_ids___3 {
	LAST_DT_CORE_CLK___3 = 30,
	CLK_EXTAL___3 = 31,
	CLK_EXTALR___3 = 32,
	CLK_MAIN___3 = 33,
	CLK_PLL0___2 = 34,
	CLK_PLL1___3 = 35,
	CLK_PLL3___2 = 36,
	CLK_PLL1_DIV2___3 = 37,
	CLK_PLL1_DIV4___2 = 38,
	MOD_CLK_BASE___3 = 39,
};

enum r8a77970_clk_types {
	CLK_TYPE_R8A77970_SD0H = 23,
	CLK_TYPE_R8A77970_SD0 = 24,
};

struct tegra_sync_source_initdata {
	char *name;
	unsigned long rate;
	unsigned long max_rate;
	int clk_id;
};

struct tegra_audio_clk_initdata {
	char *gate_name;
	char *mux_name;
	u32 offset;
	int gate_clk_id;
	int mux_clk_id;
};

struct tegra_audio2x_clk_initdata {
	char *parent;
	char *gate_name;
	char *name_2x;
	char *div_name;
	int clk_id;
	int clk_num;
	u8 div_offset;
};

enum clk_id {
	tegra_clk_actmon = 0,
	tegra_clk_adx = 1,
	tegra_clk_adx1 = 2,
	tegra_clk_afi = 3,
	tegra_clk_amx = 4,
	tegra_clk_amx1 = 5,
	tegra_clk_apb2ape = 6,
	tegra_clk_ahbdma = 7,
	tegra_clk_apbdma = 8,
	tegra_clk_apbif = 9,
	tegra_clk_ape = 10,
	tegra_clk_audio0 = 11,
	tegra_clk_audio0_2x = 12,
	tegra_clk_audio0_mux = 13,
	tegra_clk_audio1 = 14,
	tegra_clk_audio1_2x = 15,
	tegra_clk_audio1_mux = 16,
	tegra_clk_audio2 = 17,
	tegra_clk_audio2_2x = 18,
	tegra_clk_audio2_mux = 19,
	tegra_clk_audio3 = 20,
	tegra_clk_audio3_2x = 21,
	tegra_clk_audio3_mux = 22,
	tegra_clk_audio4 = 23,
	tegra_clk_audio4_2x = 24,
	tegra_clk_audio4_mux = 25,
	tegra_clk_bsea = 26,
	tegra_clk_bsev = 27,
	tegra_clk_cclk_g = 28,
	tegra_clk_cclk_lp = 29,
	tegra_clk_cilab = 30,
	tegra_clk_cilcd = 31,
	tegra_clk_cile = 32,
	tegra_clk_clk_32k = 33,
	tegra_clk_clk72Mhz = 34,
	tegra_clk_clk72Mhz_8 = 35,
	tegra_clk_clk_m = 36,
	tegra_clk_osc = 37,
	tegra_clk_osc_div2 = 38,
	tegra_clk_osc_div4 = 39,
	tegra_clk_cml0 = 40,
	tegra_clk_cml1 = 41,
	tegra_clk_csi = 42,
	tegra_clk_csite = 43,
	tegra_clk_csite_8 = 44,
	tegra_clk_csus = 45,
	tegra_clk_cve = 46,
	tegra_clk_dam0 = 47,
	tegra_clk_dam1 = 48,
	tegra_clk_dam2 = 49,
	tegra_clk_d_audio = 50,
	tegra_clk_dbgapb = 51,
	tegra_clk_dds = 52,
	tegra_clk_dfll_ref = 53,
	tegra_clk_dfll_soc = 54,
	tegra_clk_disp1 = 55,
	tegra_clk_disp1_8 = 56,
	tegra_clk_disp2 = 57,
	tegra_clk_disp2_8 = 58,
	tegra_clk_dp2 = 59,
	tegra_clk_dpaux = 60,
	tegra_clk_dpaux1 = 61,
	tegra_clk_dsialp = 62,
	tegra_clk_dsia_mux = 63,
	tegra_clk_dsiblp = 64,
	tegra_clk_dsib_mux = 65,
	tegra_clk_dtv = 66,
	tegra_clk_emc = 67,
	tegra_clk_entropy = 68,
	tegra_clk_entropy_8 = 69,
	tegra_clk_epp = 70,
	tegra_clk_epp_8 = 71,
	tegra_clk_extern1 = 72,
	tegra_clk_extern2 = 73,
	tegra_clk_extern3 = 74,
	tegra_clk_fuse = 75,
	tegra_clk_fuse_burn = 76,
	tegra_clk_gpu = 77,
	tegra_clk_gr2d = 78,
	tegra_clk_gr2d_8 = 79,
	tegra_clk_gr3d = 80,
	tegra_clk_gr3d_8 = 81,
	tegra_clk_hclk = 82,
	tegra_clk_hda = 83,
	tegra_clk_hda_8 = 84,
	tegra_clk_hda2codec_2x = 85,
	tegra_clk_hda2codec_2x_8 = 86,
	tegra_clk_hda2hdmi = 87,
	tegra_clk_hdmi = 88,
	tegra_clk_hdmi_audio = 89,
	tegra_clk_host1x = 90,
	tegra_clk_host1x_8 = 91,
	tegra_clk_host1x_9 = 92,
	tegra_clk_hsic_trk = 93,
	tegra_clk_i2c1 = 94,
	tegra_clk_i2c2 = 95,
	tegra_clk_i2c3 = 96,
	tegra_clk_i2c4 = 97,
	tegra_clk_i2c5 = 98,
	tegra_clk_i2c6 = 99,
	tegra_clk_i2cslow = 100,
	tegra_clk_i2s0 = 101,
	tegra_clk_i2s0_sync = 102,
	tegra_clk_i2s1 = 103,
	tegra_clk_i2s1_sync = 104,
	tegra_clk_i2s2 = 105,
	tegra_clk_i2s2_sync = 106,
	tegra_clk_i2s3 = 107,
	tegra_clk_i2s3_sync = 108,
	tegra_clk_i2s4 = 109,
	tegra_clk_i2s4_sync = 110,
	tegra_clk_isp = 111,
	tegra_clk_isp_8 = 112,
	tegra_clk_isp_9 = 113,
	tegra_clk_ispb = 114,
	tegra_clk_kbc = 115,
	tegra_clk_kfuse = 116,
	tegra_clk_la = 117,
	tegra_clk_maud = 118,
	tegra_clk_mipi = 119,
	tegra_clk_mipibif = 120,
	tegra_clk_mipi_cal = 121,
	tegra_clk_mpe = 122,
	tegra_clk_mselect = 123,
	tegra_clk_msenc = 124,
	tegra_clk_ndflash = 125,
	tegra_clk_ndflash_8 = 126,
	tegra_clk_ndspeed = 127,
	tegra_clk_ndspeed_8 = 128,
	tegra_clk_nor = 129,
	tegra_clk_nvdec = 130,
	tegra_clk_nvenc = 131,
	tegra_clk_nvjpg = 132,
	tegra_clk_owr = 133,
	tegra_clk_owr_8 = 134,
	tegra_clk_pcie = 135,
	tegra_clk_pclk = 136,
	tegra_clk_pll_a = 137,
	tegra_clk_pll_a_out0 = 138,
	tegra_clk_pll_a1 = 139,
	tegra_clk_pll_c = 140,
	tegra_clk_pll_c2 = 141,
	tegra_clk_pll_c3 = 142,
	tegra_clk_pll_c4 = 143,
	tegra_clk_pll_c4_out0 = 144,
	tegra_clk_pll_c4_out1 = 145,
	tegra_clk_pll_c4_out2 = 146,
	tegra_clk_pll_c4_out3 = 147,
	tegra_clk_pll_c_out1 = 148,
	tegra_clk_pll_d = 149,
	tegra_clk_pll_d2 = 150,
	tegra_clk_pll_d2_out0 = 151,
	tegra_clk_pll_d_out0 = 152,
	tegra_clk_pll_dp = 153,
	tegra_clk_pll_e_out0 = 154,
	tegra_clk_pll_g_ref = 155,
	tegra_clk_pll_m = 156,
	tegra_clk_pll_m_out1 = 157,
	tegra_clk_pll_mb = 158,
	tegra_clk_pll_p = 159,
	tegra_clk_pll_p_out1 = 160,
	tegra_clk_pll_p_out2 = 161,
	tegra_clk_pll_p_out2_int = 162,
	tegra_clk_pll_p_out3 = 163,
	tegra_clk_pll_p_out4 = 164,
	tegra_clk_pll_p_out4_cpu = 165,
	tegra_clk_pll_p_out5 = 166,
	tegra_clk_pll_p_out_hsio = 167,
	tegra_clk_pll_p_out_xusb = 168,
	tegra_clk_pll_p_out_cpu = 169,
	tegra_clk_pll_p_out_adsp = 170,
	tegra_clk_pll_ref = 171,
	tegra_clk_pll_re_out = 172,
	tegra_clk_pll_re_vco = 173,
	tegra_clk_pll_u = 174,
	tegra_clk_pll_u_out = 175,
	tegra_clk_pll_u_out1 = 176,
	tegra_clk_pll_u_out2 = 177,
	tegra_clk_pll_u_12m = 178,
	tegra_clk_pll_u_480m = 179,
	tegra_clk_pll_u_48m = 180,
	tegra_clk_pll_u_60m = 181,
	tegra_clk_pll_x = 182,
	tegra_clk_pll_x_out0 = 183,
	tegra_clk_pwm = 184,
	tegra_clk_qspi = 185,
	tegra_clk_rtc = 186,
	tegra_clk_sata = 187,
	tegra_clk_sata_8 = 188,
	tegra_clk_sata_cold = 189,
	tegra_clk_sata_oob = 190,
	tegra_clk_sata_oob_8 = 191,
	tegra_clk_sbc1 = 192,
	tegra_clk_sbc1_8 = 193,
	tegra_clk_sbc1_9 = 194,
	tegra_clk_sbc2 = 195,
	tegra_clk_sbc2_8 = 196,
	tegra_clk_sbc2_9 = 197,
	tegra_clk_sbc3 = 198,
	tegra_clk_sbc3_8 = 199,
	tegra_clk_sbc3_9 = 200,
	tegra_clk_sbc4 = 201,
	tegra_clk_sbc4_8 = 202,
	tegra_clk_sbc4_9 = 203,
	tegra_clk_sbc5 = 204,
	tegra_clk_sbc5_8 = 205,
	tegra_clk_sbc6 = 206,
	tegra_clk_sbc6_8 = 207,
	tegra_clk_sclk = 208,
	tegra_clk_sdmmc_legacy = 209,
	tegra_clk_sdmmc1 = 210,
	tegra_clk_sdmmc1_8 = 211,
	tegra_clk_sdmmc1_9 = 212,
	tegra_clk_sdmmc2 = 213,
	tegra_clk_sdmmc2_8 = 214,
	tegra_clk_sdmmc3 = 215,
	tegra_clk_sdmmc3_8 = 216,
	tegra_clk_sdmmc3_9 = 217,
	tegra_clk_sdmmc4 = 218,
	tegra_clk_sdmmc4_8 = 219,
	tegra_clk_se = 220,
	tegra_clk_se_10 = 221,
	tegra_clk_soc_therm = 222,
	tegra_clk_soc_therm_8 = 223,
	tegra_clk_sor0 = 224,
	tegra_clk_sor0_out = 225,
	tegra_clk_sor1 = 226,
	tegra_clk_sor1_out = 227,
	tegra_clk_spdif = 228,
	tegra_clk_spdif_2x = 229,
	tegra_clk_spdif_in = 230,
	tegra_clk_spdif_in_8 = 231,
	tegra_clk_spdif_in_sync = 232,
	tegra_clk_spdif_mux = 233,
	tegra_clk_spdif_out = 234,
	tegra_clk_timer = 235,
	tegra_clk_trace = 236,
	tegra_clk_tsec = 237,
	tegra_clk_tsec_8 = 238,
	tegra_clk_tsecb = 239,
	tegra_clk_tsensor = 240,
	tegra_clk_tvdac = 241,
	tegra_clk_tvo = 242,
	tegra_clk_uarta = 243,
	tegra_clk_uarta_8 = 244,
	tegra_clk_uartb = 245,
	tegra_clk_uartb_8 = 246,
	tegra_clk_uartc = 247,
	tegra_clk_uartc_8 = 248,
	tegra_clk_uartd = 249,
	tegra_clk_uartd_8 = 250,
	tegra_clk_uarte = 251,
	tegra_clk_uarte_8 = 252,
	tegra_clk_uartape = 253,
	tegra_clk_usb2 = 254,
	tegra_clk_usb2_hsic_trk = 255,
	tegra_clk_usb2_trk = 256,
	tegra_clk_usb3 = 257,
	tegra_clk_usbd = 258,
	tegra_clk_vcp = 259,
	tegra_clk_vde = 260,
	tegra_clk_vde_8 = 261,
	tegra_clk_vfir = 262,
	tegra_clk_vi = 263,
	tegra_clk_vi_8 = 264,
	tegra_clk_vi_9 = 265,
	tegra_clk_vi_10 = 266,
	tegra_clk_vi_i2c = 267,
	tegra_clk_vic03 = 268,
	tegra_clk_vic03_8 = 269,
	tegra_clk_vim2_clk = 270,
	tegra_clk_vimclk_sync = 271,
	tegra_clk_vi_sensor = 272,
	tegra_clk_vi_sensor_8 = 273,
	tegra_clk_vi_sensor_9 = 274,
	tegra_clk_vi_sensor2 = 275,
	tegra_clk_vi_sensor2_8 = 276,
	tegra_clk_xusb_dev = 277,
	tegra_clk_xusb_dev_src = 278,
	tegra_clk_xusb_dev_src_8 = 279,
	tegra_clk_xusb_falcon_src = 280,
	tegra_clk_xusb_falcon_src_8 = 281,
	tegra_clk_xusb_fs_src = 282,
	tegra_clk_xusb_gate = 283,
	tegra_clk_xusb_host = 284,
	tegra_clk_xusb_host_src = 285,
	tegra_clk_xusb_host_src_8 = 286,
	tegra_clk_xusb_hs_src = 287,
	tegra_clk_xusb_hs_src_4 = 288,
	tegra_clk_xusb_ss = 289,
	tegra_clk_xusb_ss_src = 290,
	tegra_clk_xusb_ss_src_8 = 291,
	tegra_clk_xusb_ss_div2 = 292,
	tegra_clk_xusb_ssp_src = 293,
	tegra_clk_sclk_mux = 294,
	tegra_clk_sor_safe = 295,
	tegra_clk_cec = 296,
	tegra_clk_ispa = 297,
	tegra_clk_dmic1 = 298,
	tegra_clk_dmic2 = 299,
	tegra_clk_dmic3 = 300,
	tegra_clk_dmic1_sync_clk = 301,
	tegra_clk_dmic2_sync_clk = 302,
	tegra_clk_dmic3_sync_clk = 303,
	tegra_clk_dmic1_sync_clk_mux = 304,
	tegra_clk_dmic2_sync_clk_mux = 305,
	tegra_clk_dmic3_sync_clk_mux = 306,
	tegra_clk_iqc1 = 307,
	tegra_clk_iqc2 = 308,
	tegra_clk_pll_a_out_adsp = 309,
	tegra_clk_pll_a_out0_out_adsp = 310,
	tegra_clk_adsp = 311,
	tegra_clk_adsp_neon = 312,
	tegra_clk_max = 313,
};

struct pdiv_map;

struct div_nmp;

struct tegra_clk_pll_freq_table;

struct tegra_clk_pll;

struct tegra_clk_pll_params {
	unsigned long input_min;
	unsigned long input_max;
	unsigned long cf_min;
	unsigned long cf_max;
	unsigned long vco_min;
	unsigned long vco_max;
	u32 base_reg;
	u32 misc_reg;
	u32 lock_reg;
	u32 lock_mask;
	u32 lock_enable_bit_idx;
	u32 iddq_reg;
	u32 iddq_bit_idx;
	u32 reset_reg;
	u32 reset_bit_idx;
	u32 sdm_din_reg;
	u32 sdm_din_mask;
	u32 sdm_ctrl_reg;
	u32 sdm_ctrl_en_mask;
	u32 ssc_ctrl_reg;
	u32 ssc_ctrl_en_mask;
	u32 aux_reg;
	u32 dyn_ramp_reg;
	u32 ext_misc_reg[6];
	u32 pmc_divnm_reg;
	u32 pmc_divp_reg;
	u32 flags;
	int stepa_shift;
	int stepb_shift;
	int lock_delay;
	int max_p;
	bool defaults_set;
	const struct pdiv_map *pdiv_tohw;
	struct div_nmp *div_nmp;
	struct tegra_clk_pll_freq_table *freq_table;
	unsigned long fixed_rate;
	u16 mdiv_default;
	u32 (*round_p_to_pdiv)(u32, u32 *);
	void (*set_gain)(struct tegra_clk_pll_freq_table *);
	int (*calc_rate)(struct clk_hw *, struct tegra_clk_pll_freq_table *, unsigned long, unsigned long);
	unsigned long (*adjust_vco)(struct tegra_clk_pll_params *, unsigned long);
	void (*set_defaults)(struct tegra_clk_pll *);
	int (*dyn_ramp)(struct tegra_clk_pll *, struct tegra_clk_pll_freq_table *);
	int (*pre_rate_change)();
	void (*post_rate_change)();
};

struct pdiv_map {
	u8 pdiv;
	u8 hw_val;
};

struct div_nmp {
	u8 divn_shift;
	u8 divn_width;
	u8 divm_shift;
	u8 divm_width;
	u8 divp_shift;
	u8 divp_width;
	u8 override_divn_shift;
	u8 override_divm_shift;
	u8 override_divp_shift;
};

struct tegra_clk_pll_freq_table {
	unsigned long input_rate;
	unsigned long output_rate;
	u32 n;
	u32 m;
	u8 p;
	u8 cpcon;
	u16 sdm_data;
};

struct tegra_clk_pll {
	struct clk_hw hw;
	void *clk_base;
	void *pmc;
	spinlock_t *lock;
	struct tegra_clk_pll_params *params;
};

struct tegra_audio_clk_info {
	char *name;
	struct tegra_clk_pll_params *pll_params;
	int clk_id;
	char *parent;
};

struct tegra210_domain_mbist_war {
	void (*handle_lvl2_ovr)(struct tegra210_domain_mbist_war *);
	const u32 lvl2_offset;
	const u32 lvl2_mask;
	const unsigned int num_clks;
	const unsigned int *clk_init_data;
	struct clk_bulk_data *clks;
};

struct utmi_clk_param {
	u32 osc_frequency;
	u8 enable_delay_count;
	u16 stable_count;
	u8 active_delay_count;
	u16 xtal_freq_count;
};

struct tegra_clk_frac_div {
	struct clk_hw hw;
	void *reg;
	u8 flags;
	u8 shift;
	u8 width;
	u8 frac_width;
	spinlock_t *lock;
};

struct tegra_clk_periph_gate {
	u32 magic;
	struct clk_hw hw;
	void *clk_base;
	u8 flags;
	int clk_num;
	int *enable_refcnt;
	const struct tegra_clk_periph_regs *regs;
};

struct tegra_clk_periph {
	u32 magic;
	struct clk_hw hw;
	struct clk_mux mux;
	struct tegra_clk_frac_div divider;
	struct tegra_clk_periph_gate gate;
	const struct clk_ops *mux_ops;
	const struct clk_ops *div_ops;
	const struct clk_ops *gate_ops;
};

struct tegra_periph_init_data {
	const char *name;
	int clk_id;
	union {
		const char * const *parent_names;
		const char *parent_name;
	} p;
	int num_parents;
	struct tegra_clk_periph periph;
	u32 offset;
	const char *con_id;
	const char *dev_id;
	unsigned long flags;
};

struct cpu_clk_suspend_context {
	u32 clk_csite_src;
};

struct zynqmp_clk_gate {
	struct clk_hw hw;
	u8 flags;
	u32 clk_id;
};

struct clock_topology {
	u32 type;
	u32 flag;
	u32 type_flag;
	u8 custom_type_flag;
};

struct zynqmp_clk_mux {
	struct clk_hw hw;
	u8 flags;
	u32 clk_id;
};

struct of_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct qman_hwerr_txt {
	u32 mask;
	const char *txt;
};

struct qman_error_info_mdata {
	u16 addr_mask;
	u16 bits;
	const char *txt;
};

enum qm_memory {
	qm_memory_fqd = 0,
	qm_memory_pfdr = 1,
};

enum qm_wq_class {
	qm_wq_portal = 0,
	qm_wq_pool = 1,
	qm_wq_fman0 = 2,
	qm_wq_fman1 = 3,
	qm_wq_caam = 4,
	qm_wq_pme = 5,
	qm_wq_first = 0,
	qm_wq_last = 5,
};

enum qm_dc_portal {
	qm_dc_portal_fman0 = 0,
	qm_dc_portal_fman1 = 1,
};

struct qm_ecir {
	u32 info;
};

struct qm_eadr {
	u32 info;
};

struct qm_ecir2 {
	u32 info;
};

struct tcs_request {
	enum rpmh_state state;
	u32 wait_for_compl;
	u32 num_cmds;
	struct tcs_cmd *cmds;
};

struct rpmh_request {
	struct tcs_request msg;
	struct tcs_cmd cmd[16];
	struct completion *completion;
	const struct device *dev;
	bool needs_free;
};

struct rsc_drv;

struct tcs_group {
	struct rsc_drv *drv;
	int type;
	u32 mask;
	u32 offset;
	int num_tcs;
	int ncpt;
	const struct tcs_request *req[3];
	unsigned long slots[1];
};

struct rpmh_ctrlr {
	struct list_head cache;
	spinlock_t cache_lock;
	bool dirty;
	struct list_head batch_cache;
};

struct rsc_ver {
	u32 major;
	u32 minor;
};

struct rsc_drv {
	const char *name;
	void *base;
	void *tcs_base;
	int id;
	int num_tcs;
	struct notifier_block rsc_pm;
	struct notifier_block genpd_nb;
	atomic_t cpus_in_pm;
	struct tcs_group tcs[4];
	unsigned long tcs_in_use[1];
	spinlock_t lock;
	wait_queue_head_t tcs_wait;
	struct rpmh_ctrlr client;
	struct device *dev;
	struct rsc_ver ver;
	u32 *regs;
};

struct cache_req___2 {
	u32 addr;
	u32 sleep_val;
	u32 wake_val;
	struct list_head list;
};

struct batch_cache_req {
	struct list_head list;
	int count;
	struct rpmh_request rpm_msgs[0];
};

struct exynos_pmu_data;

struct exynos_pmu_context {
	struct device *dev;
	const struct exynos_pmu_data *pmu_data;
};

enum sys_powerdown {
	SYS_AFTR = 0,
	SYS_LPA = 1,
	SYS_SLEEP = 2,
	NUM_SYS_POWERDOWN = 3,
};

struct exynos_pmu_conf;

struct exynos_pmu_data {
	const struct exynos_pmu_conf *pmu_config;
	const struct exynos_pmu_conf *pmu_config_extra;
	void (*pmu_init)();
	void (*powerdown_conf)(enum sys_powerdown);
	void (*powerdown_conf_extra)(enum sys_powerdown);
};

struct exynos_pmu_conf {
	unsigned int offset;
	u8 val[3];
};

struct meson_secure_pwrc_domain_desc;

struct meson_secure_pwrc_domain_data {
	unsigned int count;
	struct meson_secure_pwrc_domain_desc *domains;
};

struct meson_secure_pwrc_domain;

struct meson_secure_pwrc_domain_desc {
	unsigned int index;
	unsigned int parent;
	unsigned int flags;
	char *name;
	bool (*is_off)(struct meson_secure_pwrc_domain *);
};

struct meson_secure_pwrc;

struct meson_secure_pwrc_domain {
	struct generic_pm_domain base;
	unsigned int index;
	unsigned int parent;
	struct meson_secure_pwrc *pwrc;
};

struct meson_sm_firmware;

struct meson_secure_pwrc {
	struct meson_secure_pwrc_domain *domains;
	struct genpd_onecell_data xlate;
	struct meson_sm_firmware *fw;
};

enum {
	SM_EFUSE_READ = 0,
	SM_EFUSE_WRITE = 1,
	SM_EFUSE_USER_MAX = 2,
	SM_GET_CHIP_ID = 3,
	SM_A1_PWRC_SET = 4,
	SM_A1_PWRC_GET = 5,
};

struct scp_ctrl_reg {
	int pwr_sta_offs;
	int pwr_sta2nd_offs;
};

struct scp_domain_data;

struct scp_subdomain;

struct scp_soc_data {
	const struct scp_domain_data *domains;
	int num_domains;
	const struct scp_subdomain *subdomains;
	int num_subdomains;
	const struct scp_ctrl_reg regs;
	bool bus_prot_reg_update;
};

enum clk_id___2 {
	CLK_NONE = 0,
	CLK_MM = 1,
	CLK_MFG = 2,
	CLK_VENC = 3,
	CLK_VENC_LT = 4,
	CLK_ETHIF = 5,
	CLK_VDEC = 6,
	CLK_HIFSEL = 7,
	CLK_JPGDEC = 8,
	CLK_AUDIO = 9,
	CLK_MAX = 10,
};

struct scp_domain_data {
	const char *name;
	u32 sta_mask;
	int ctl_offs;
	u32 sram_pdn_bits;
	u32 sram_pdn_ack_bits;
	u32 bus_prot_mask;
	enum clk_id___2 clk_id[3];
	u8 caps;
};

struct scp_subdomain {
	int origin;
	int subdomain;
};

struct scp;

struct scp_domain {
	struct generic_pm_domain genpd;
	struct scp *scp;
	struct clk *clk[3];
	const struct scp_domain_data *data;
	struct regulator *supply;
};

struct scp {
	struct scp_domain *domains;
	struct genpd_onecell_data pd_data;
	struct device *dev;
	void *base;
	struct regmap *infracfg;
	struct scp_ctrl_reg ctrl_reg;
	bool bus_prot_reg_update;
};

struct physdev_pci_device {
	uint16_t seg;
	uint8_t bus;
	uint8_t devfn;
};

struct physdev_dbgp_op {
	uint8_t op;
	uint8_t bus;
	union {
		struct physdev_pci_device pci;
	} u;
};

struct rohm_dvs_config {
	uint64_t level_map;
	unsigned int run_reg;
	unsigned int run_mask;
	unsigned int run_on_mask;
	unsigned int idle_reg;
	unsigned int idle_mask;
	unsigned int idle_on_mask;
	unsigned int suspend_reg;
	unsigned int suspend_mask;
	unsigned int suspend_on_mask;
	unsigned int lpsr_reg;
	unsigned int lpsr_mask;
	unsigned int lpsr_on_mask;
	unsigned int snvs_reg;
	unsigned int snvs_mask;
	unsigned int snvs_on_mask;
};

struct reg_init {
	unsigned int reg;
	unsigned int mask;
	unsigned int val;
};

struct bd718xx_regulator_data {
	struct regulator_desc desc;
	const struct rohm_dvs_config dvs;
	const struct reg_init init;
	const struct reg_init *additional_inits;
	int additional_init_amnt;
};

enum {
	BD718XX_REG_REV = 0,
	BD718XX_REG_SWRESET = 1,
	BD718XX_REG_I2C_DEV = 2,
	BD718XX_REG_PWRCTRL0 = 3,
	BD718XX_REG_PWRCTRL1 = 4,
	BD718XX_REG_BUCK1_CTRL = 5,
	BD718XX_REG_BUCK2_CTRL = 6,
	BD718XX_REG_1ST_NODVS_BUCK_CTRL = 9,
	BD718XX_REG_2ND_NODVS_BUCK_CTRL = 10,
	BD718XX_REG_3RD_NODVS_BUCK_CTRL = 11,
	BD718XX_REG_4TH_NODVS_BUCK_CTRL = 12,
	BD718XX_REG_BUCK1_VOLT_RUN = 13,
	BD718XX_REG_BUCK1_VOLT_IDLE = 14,
	BD718XX_REG_BUCK1_VOLT_SUSP = 15,
	BD718XX_REG_BUCK2_VOLT_RUN = 16,
	BD718XX_REG_BUCK2_VOLT_IDLE = 17,
	BD718XX_REG_1ST_NODVS_BUCK_VOLT = 20,
	BD718XX_REG_2ND_NODVS_BUCK_VOLT = 21,
	BD718XX_REG_3RD_NODVS_BUCK_VOLT = 22,
	BD718XX_REG_4TH_NODVS_BUCK_VOLT = 23,
	BD718XX_REG_LDO1_VOLT = 24,
	BD718XX_REG_LDO2_VOLT = 25,
	BD718XX_REG_LDO3_VOLT = 26,
	BD718XX_REG_LDO4_VOLT = 27,
	BD718XX_REG_LDO5_VOLT = 28,
	BD718XX_REG_LDO6_VOLT = 29,
	BD718XX_REG_TRANS_COND0 = 31,
	BD718XX_REG_TRANS_COND1 = 32,
	BD718XX_REG_VRFAULTEN = 33,
	BD718XX_REG_MVRFLTMASK0 = 34,
	BD718XX_REG_MVRFLTMASK1 = 35,
	BD718XX_REG_MVRFLTMASK2 = 36,
	BD718XX_REG_RCVCFG = 37,
	BD718XX_REG_RCVNUM = 38,
	BD718XX_REG_PWRONCONFIG0 = 39,
	BD718XX_REG_PWRONCONFIG1 = 40,
	BD718XX_REG_RESETSRC = 41,
	BD718XX_REG_MIRQ = 42,
	BD718XX_REG_IRQ = 43,
	BD718XX_REG_IN_MON = 44,
	BD718XX_REG_POW_STATE = 45,
	BD718XX_REG_OUT32K = 46,
	BD718XX_REG_REGLOCK = 47,
	BD718XX_REG_OTPVER = 255,
	BD718XX_MAX_REGISTER = 256,
};

enum {
	BD718XX_BUCK1 = 0,
	BD718XX_BUCK2 = 1,
	BD718XX_BUCK3 = 2,
	BD718XX_BUCK4 = 3,
	BD718XX_BUCK5 = 4,
	BD718XX_BUCK6 = 5,
	BD718XX_BUCK7 = 6,
	BD718XX_BUCK8 = 7,
	BD718XX_LDO1 = 8,
	BD718XX_LDO2 = 9,
	BD718XX_LDO3 = 10,
	BD718XX_LDO4 = 11,
	BD718XX_LDO5 = 12,
	BD718XX_LDO6 = 13,
	BD718XX_LDO7 = 14,
	BD718XX_REGULATOR_AMOUNT = 15,
};

struct mt6359_regulator_info {
	struct regulator_desc desc;
	u32 status_reg;
	u32 qi;
	u32 modeset_reg;
	u32 modeset_mask;
	u32 lp_mode_reg;
	u32 lp_mode_mask;
};

enum {
	MT6359_ID_VS1 = 0,
	MT6359_ID_VGPU11 = 1,
	MT6359_ID_VMODEM = 2,
	MT6359_ID_VPU = 3,
	MT6359_ID_VCORE = 4,
	MT6359_ID_VS2 = 5,
	MT6359_ID_VPA = 6,
	MT6359_ID_VPROC2 = 7,
	MT6359_ID_VPROC1 = 8,
	MT6359_ID_VCORE_SSHUB = 9,
	MT6359_ID_VGPU11_SSHUB = 9,
	MT6359_ID_VAUD18 = 10,
	MT6359_ID_VSIM1 = 11,
	MT6359_ID_VIBR = 12,
	MT6359_ID_VRF12 = 13,
	MT6359_ID_VUSB = 14,
	MT6359_ID_VSRAM_PROC2 = 15,
	MT6359_ID_VIO18 = 16,
	MT6359_ID_VCAMIO = 17,
	MT6359_ID_VCN18 = 18,
	MT6359_ID_VFE28 = 19,
	MT6359_ID_VCN13 = 20,
	MT6359_ID_VCN33_1_BT = 21,
	MT6359_ID_VCN33_1_WIFI = 22,
	MT6359_ID_VAUX18 = 23,
	MT6359_ID_VSRAM_OTHERS = 24,
	MT6359_ID_VEFUSE = 25,
	MT6359_ID_VXO22 = 26,
	MT6359_ID_VRFCK = 27,
	MT6359_ID_VBIF28 = 28,
	MT6359_ID_VIO28 = 29,
	MT6359_ID_VEMC = 30,
	MT6359_ID_VCN33_2_BT = 31,
	MT6359_ID_VCN33_2_WIFI = 32,
	MT6359_ID_VA12 = 33,
	MT6359_ID_VA09 = 34,
	MT6359_ID_VRF18 = 35,
	MT6359_ID_VSRAM_MD = 36,
	MT6359_ID_VUFS = 37,
	MT6359_ID_VM18 = 38,
	MT6359_ID_VBBCK = 39,
	MT6359_ID_VSRAM_PROC1 = 40,
	MT6359_ID_VSIM2 = 41,
	MT6359_ID_VSRAM_OTHERS_SSHUB = 42,
	MT6359_ID_RG_MAX = 43,
};

struct rzg2l_usbphy_ctrl_priv {
	struct reset_controller_dev rcdev;
	struct reset_control *rstc;
	void *base;
	spinlock_t lock;
};

struct of_serial_info {
	struct clk *clk;
	struct reset_control *rst;
	int type;
	int line;
};

enum serdev_parity {
	SERDEV_PARITY_NONE = 0,
	SERDEV_PARITY_EVEN = 1,
	SERDEV_PARITY_ODD = 2,
};

struct serdev_device;

struct serdev_device_driver {
	struct device_driver driver;
	int (*probe)(struct serdev_device *);
	void (*remove)(struct serdev_device *);
};

struct serdev_controller;

struct serdev_device_ops;

struct serdev_device {
	struct device dev;
	int nr;
	struct serdev_controller *ctrl;
	const struct serdev_device_ops *ops;
	struct completion write_comp;
	struct mutex write_lock;
};

struct serdev_controller_ops;

struct serdev_controller {
	struct device dev;
	unsigned int nr;
	struct serdev_device *serdev;
	const struct serdev_controller_ops *ops;
};

struct serdev_controller_ops {
	int (*write_buf)(struct serdev_controller *, const unsigned char *, size_t);
	void (*write_flush)(struct serdev_controller *);
	int (*write_room)(struct serdev_controller *);
	int (*open)(struct serdev_controller *);
	void (*close)(struct serdev_controller *);
	void (*set_flow_control)(struct serdev_controller *, bool);
	int (*set_parity)(struct serdev_controller *, enum serdev_parity);
	unsigned int (*set_baudrate)(struct serdev_controller *, unsigned int);
	void (*wait_until_sent)(struct serdev_controller *, long);
	int (*get_tiocm)(struct serdev_controller *);
	int (*set_tiocm)(struct serdev_controller *, unsigned int, unsigned int);
	int (*break_ctl)(struct serdev_controller *, unsigned int);
};

struct serdev_device_ops {
	int (*receive_buf)(struct serdev_device *, const unsigned char *, size_t);
	void (*write_wakeup)(struct serdev_device *);
};

struct acpi_serdev_lookup {
	acpi_handle device_handle;
	acpi_handle controller_handle;
	int n;
	int index;
};

struct iova {
	struct rb_node node;
	unsigned long pfn_hi;
	unsigned long pfn_lo;
};

struct iova_rcache;

struct iova_domain {
	spinlock_t iova_rbtree_lock;
	struct rb_root rbroot;
	struct rb_node *cached_node;
	struct rb_node *cached32_node;
	unsigned long granule;
	unsigned long start_pfn;
	unsigned long dma_32bit_pfn;
	unsigned long max32_alloc_size;
	struct iova anchor;
	struct iova_rcache *rcaches;
	struct hlist_node cpuhp_dead;
};

enum iommu_dma_cookie_type {
	IOMMU_DMA_IOVA_COOKIE = 0,
	IOMMU_DMA_MSI_COOKIE = 1,
};

enum iommu_dma_queue_type {
	IOMMU_DMA_OPTS_PER_CPU_QUEUE = 0,
	IOMMU_DMA_OPTS_SINGLE_QUEUE = 1,
};

struct iommu_dma_options {
	enum iommu_dma_queue_type qt;
	size_t fq_size;
	unsigned int fq_timeout;
};

struct iova_fq;

struct iommu_dma_cookie {
	enum iommu_dma_cookie_type type;
	union {
		struct {
			struct iova_domain iovad;
			union {
				struct iova_fq *single_fq;
				struct iova_fq __attribute__((btf_type_tag("percpu"))) *percpu_fq;
			};
			atomic64_t fq_flush_start_cnt;
			atomic64_t fq_flush_finish_cnt;
			struct timer_list fq_timer;
			atomic_t fq_timer_on;
		};
		dma_addr_t msi_iova;
	};
	struct list_head msi_page_list;
	struct iommu_domain *fq_domain;
	struct iommu_dma_options options;
	struct mutex mutex;
};

struct iova_fq_entry {
	unsigned long iova_pfn;
	unsigned long pages;
	struct list_head freelist;
	u64 counter;
};

struct iova_fq {
	spinlock_t lock;
	unsigned int head;
	unsigned int tail;
	unsigned int mod_mask;
	struct iova_fq_entry entries[0];
};

enum iommu_resv_type {
	IOMMU_RESV_DIRECT = 0,
	IOMMU_RESV_DIRECT_RELAXABLE = 1,
	IOMMU_RESV_RESERVED = 2,
	IOMMU_RESV_MSI = 3,
	IOMMU_RESV_SW_MSI = 4,
};

struct iommu_dma_msi_page {
	struct list_head list;
	dma_addr_t iova;
	phys_addr_t phys;
};

struct iommu_resv_region {
	struct list_head list;
	phys_addr_t start;
	size_t length;
	int prot;
	enum iommu_resv_type type;
	void (*free)(struct device *, struct iommu_resv_region *);
};

struct dma_sgt_handle {
	struct sg_table sgt;
	struct page **pages;
};

struct swnode {
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	int id;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
	unsigned int managed: 1;
};

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct sunxi_rsb_device;

struct sunxi_rsb_driver {
	struct device_driver driver;
	int (*probe)(struct sunxi_rsb_device *);
	void (*remove)(struct sunxi_rsb_device *);
};

struct sunxi_rsb;

struct sunxi_rsb_device {
	struct device dev;
	struct sunxi_rsb *rsb;
	int irq;
	u8 rtaddr;
	u16 hwaddr;
};

struct axp20x_dev {
	struct device *dev;
	int irq;
	unsigned long irq_flags;
	struct regmap *regmap;
	struct regmap_irq_chip_data *regmap_irqc;
	long variant;
	int nr_cells;
	const struct mfd_cell *cells;
	const struct regmap_config *regmap_cfg;
	const struct regmap_irq_chip *regmap_irq_chip;
};

struct hi655x_pmic {
	struct device *dev;
	struct regmap *regmap;
	struct gpio_desc *gpio;
	unsigned int ver;
	struct regmap_irq_chip_data *irq_data;
};

enum scsi_pr_type {
	SCSI_PR_WRITE_EXCLUSIVE = 1,
	SCSI_PR_EXCLUSIVE_ACCESS = 3,
	SCSI_PR_WRITE_EXCLUSIVE_REG_ONLY = 5,
	SCSI_PR_EXCLUSIVE_ACCESS_REG_ONLY = 6,
	SCSI_PR_WRITE_EXCLUSIVE_ALL_REGS = 7,
	SCSI_PR_EXCLUSIVE_ACCESS_ALL_REGS = 8,
};

enum sas_ha_state {
	SAS_HA_REGISTERED = 0,
	SAS_HA_DRAINING = 1,
	SAS_HA_ATA_EH_ACTIVE = 2,
	SAS_HA_FROZEN = 3,
	SAS_HA_RESUMING = 4,
};

enum phy_event {
	PHYE_LOSS_OF_SIGNAL = 0,
	PHYE_OOB_DONE = 1,
	PHYE_OOB_ERROR = 2,
	PHYE_SPINUP_HOLD = 3,
	PHYE_RESUME_TIMEOUT = 4,
	PHYE_SHUTDOWN = 5,
	PHY_NUM_EVENTS = 6,
};

enum port_event {
	PORTE_BYTES_DMAED = 0,
	PORTE_BROADCAST_RCVD = 1,
	PORTE_LINK_RESET_ERR = 2,
	PORTE_TIMER_EVENT = 3,
	PORTE_HARD_RESET = 4,
	PORT_NUM_EVENTS = 5,
};

struct sas_phy_data {
	struct sas_phy *phy;
	struct mutex event_lock;
	int hard_reset;
	int reset_result;
	struct sas_work reset_work;
	int enable;
	int enable_result;
	struct sas_work enable_work;
};

struct mtdblk_dev {
	struct mtd_blktrans_dev mbd;
	int count;
	struct mutex cache_mutex;
	unsigned char *cache_data;
	unsigned long cache_offset;
	unsigned int cache_size;
	enum {
		STATE_EMPTY = 0,
		STATE_CLEAN = 1,
		STATE_DIRTY = 2,
	} cache_state;
};

struct s3c64xx_spi_port_config {
	int fifo_lvl_mask[12];
	int rx_lvl_offset;
	int tx_st_done;
	int quirks;
	int clk_div;
	bool high_speed;
	bool clk_from_cmu;
	bool clk_ioclk;
	bool has_loopback;
};

struct s3c64xx_spi_dma_data {
	struct dma_chan *ch;
	dma_cookie_t cookie;
	enum dma_transfer_direction direction;
};

struct s3c64xx_spi_info;

struct s3c64xx_spi_driver_data {
	void *regs;
	struct clk *clk;
	struct clk *src_clk;
	struct clk *ioclk;
	struct platform_device *pdev;
	struct spi_controller *host;
	struct s3c64xx_spi_info *cntrlr_info;
	spinlock_t lock;
	unsigned long sfr_start;
	struct completion xfer_completion;
	unsigned int state;
	unsigned int cur_mode;
	unsigned int cur_bpw;
	unsigned int cur_speed;
	struct s3c64xx_spi_dma_data rx_dma;
	struct s3c64xx_spi_dma_data tx_dma;
	const struct s3c64xx_spi_port_config *port_conf;
	unsigned int port_id;
};

struct s3c64xx_spi_info {
	int src_clk_nr;
	int num_cs;
	bool no_cs;
	bool polling;
	int (*cfg_gpio)();
};

struct s3c64xx_spi_csinfo {
	u8 fb_delay;
};

struct rtl821x_priv {
	u16 phycr1;
	u16 phycr2;
	bool has_phycr2;
	struct clk *clk;
};

struct mdio_gpio_info {
	struct mdiobb_ctrl ctrl;
	struct gpio_desc *mdc;
	struct gpio_desc *mdio;
	struct gpio_desc *mdo;
};

struct mdio_gpio_platform_data {
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
};

struct xgbe_stats {
	char stat_string[32];
	int stat_size;
	int stat_offset;
};

struct muram_info {
	struct gen_pool *pool;
	void *vbase;
	size_t size;
	phys_addr_t pbase;
};

enum fman_dma_aid_mode {
	FMAN_DMA_AID_OUT_PORT_ID = 0,
	FMAN_DMA_AID_OUT_TNUM = 1,
};

enum fman_event_modules {
	FMAN_MOD_MAC = 0,
	FMAN_MOD_FMAN_CTRL = 1,
	FMAN_MOD_DUMMY_LAST = 2,
};

enum fman_intr_type {
	FMAN_INTR_TYPE_ERR = 0,
	FMAN_INTR_TYPE_NORMAL = 1,
};

enum fman_inter_module_event {
	FMAN_EV_ERR_MAC0 = 0,
	FMAN_EV_ERR_MAC1 = 1,
	FMAN_EV_ERR_MAC2 = 2,
	FMAN_EV_ERR_MAC3 = 3,
	FMAN_EV_ERR_MAC4 = 4,
	FMAN_EV_ERR_MAC5 = 5,
	FMAN_EV_ERR_MAC6 = 6,
	FMAN_EV_ERR_MAC7 = 7,
	FMAN_EV_ERR_MAC8 = 8,
	FMAN_EV_ERR_MAC9 = 9,
	FMAN_EV_MAC0 = 10,
	FMAN_EV_MAC1 = 11,
	FMAN_EV_MAC2 = 12,
	FMAN_EV_MAC3 = 13,
	FMAN_EV_MAC4 = 14,
	FMAN_EV_MAC5 = 15,
	FMAN_EV_MAC6 = 16,
	FMAN_EV_MAC7 = 17,
	FMAN_EV_MAC8 = 18,
	FMAN_EV_MAC9 = 19,
	FMAN_EV_FMAN_CTRL_0 = 20,
	FMAN_EV_FMAN_CTRL_1 = 21,
	FMAN_EV_FMAN_CTRL_2 = 22,
	FMAN_EV_FMAN_CTRL_3 = 23,
	FMAN_EV_CNT = 24,
};

enum fman_port_type {
	FMAN_PORT_TYPE_TX = 0,
	FMAN_PORT_TYPE_RX = 1,
};

struct fman_fpm_regs {
	u32 fmfp_tnc;
	u32 fmfp_prc;
	u32 fmfp_brkc;
	u32 fmfp_mxd;
	u32 fmfp_dist1;
	u32 fmfp_dist2;
	u32 fm_epi;
	u32 fm_rie;
	u32 fmfp_fcev[4];
	u32 res0030[4];
	u32 fmfp_cee[4];
	u32 res0050[4];
	u32 fmfp_tsc1;
	u32 fmfp_tsc2;
	u32 fmfp_tsp;
	u32 fmfp_tsf;
	u32 fm_rcr;
	u32 fmfp_extc;
	u32 fmfp_ext1;
	u32 fmfp_ext2;
	u32 fmfp_drd[16];
	u32 fmfp_dra;
	u32 fm_ip_rev_1;
	u32 fm_ip_rev_2;
	u32 fm_rstc;
	u32 fm_cld;
	u32 fm_npi;
	u32 fmfp_exte;
	u32 fmfp_ee;
	u32 fmfp_cev[4];
	u32 res00f0[4];
	u32 fmfp_ps[50];
	u32 res01c8[14];
	u32 fmfp_clfabc;
	u32 fmfp_clfcc;
	u32 fmfp_clfaval;
	u32 fmfp_clfbval;
	u32 fmfp_clfcval;
	u32 fmfp_clfamsk;
	u32 fmfp_clfbmsk;
	u32 fmfp_clfcmsk;
	u32 fmfp_clfamc;
	u32 fmfp_clfbmc;
	u32 fmfp_clfcmc;
	u32 fmfp_decceh;
	u32 res0230[116];
	u32 fmfp_ts[128];
	u32 res0600[640];
};

struct fman_bmi_regs {
	u32 fmbm_init;
	u32 fmbm_cfg1;
	u32 fmbm_cfg2;
	u32 res000c[5];
	u32 fmbm_ievr;
	u32 fmbm_ier;
	u32 fmbm_ifr;
	u32 res002c[5];
	u32 fmbm_arb[8];
	u32 res0060[12];
	u32 fmbm_dtc[3];
	u32 res009c;
	u32 fmbm_dcv[12];
	u32 fmbm_dcm[12];
	u32 fmbm_gde;
	u32 fmbm_pp[63];
	u32 res0200;
	u32 fmbm_pfs[63];
	u32 res0300;
	u32 fmbm_spliodn[63];
};

struct fman_qmi_regs {
	u32 fmqm_gc;
	u32 res0004;
	u32 fmqm_eie;
	u32 fmqm_eien;
	u32 fmqm_eif;
	u32 fmqm_ie;
	u32 fmqm_ien;
	u32 fmqm_if;
	u32 fmqm_gs;
	u32 fmqm_ts;
	u32 fmqm_etfc;
	u32 fmqm_dtfc;
	u32 fmqm_dc0;
	u32 fmqm_dc1;
	u32 fmqm_dc2;
	u32 fmqm_dc3;
	u32 fmqm_dfdc;
	u32 fmqm_dfcc;
	u32 fmqm_dffc;
	u32 fmqm_dcc;
	u32 res0050[7];
	u32 fmqm_tapc;
	u32 fmqm_dmcvc;
	u32 fmqm_difdcc;
	u32 fmqm_da1v;
	u32 res007c;
	u32 fmqm_dtc;
	u32 fmqm_efddd;
	u32 res0088[2];
	struct {
		u32 fmqm_dtcfg1;
		u32 fmqm_dtval1;
		u32 fmqm_dtm1;
		u32 fmqm_dtc1;
		u32 fmqm_dtcfg2;
		u32 fmqm_dtval2;
		u32 fmqm_dtm2;
		u32 res001c;
	} dbg_traps[3];
	u8 res00f0[784];
};

struct fman_dma_regs {
	u32 fmdmsr;
	u32 fmdmmr;
	u32 fmdmtr;
	u32 fmdmhy;
	u32 fmdmsetr;
	u32 fmdmtah;
	u32 fmdmtal;
	u32 fmdmtcid;
	u32 fmdmra;
	u32 fmdmrd;
	u32 fmdmwcr;
	u32 fmdmebcr;
	u32 fmdmccqdr;
	u32 fmdmccqvr1;
	u32 fmdmccqvr2;
	u32 fmdmcqvr3;
	u32 fmdmcqvr4;
	u32 fmdmcqvr5;
	u32 fmdmsefrc;
	u32 fmdmsqfrc;
	u32 fmdmssrc;
	u32 fmdmdcr;
	u32 fmdmemsr;
	u32 res005c;
	u32 fmdmplr[32];
	u32 res00e0[968];
};

struct fman_hwp_regs {
	u32 res0000[529];
	u32 fmprrpimac;
	u32 res[494];
};

struct fman_rev_info {
	u8 major;
	u8 minor;
};

struct fman_state_struct {
	u8 fm_id;
	u16 fm_clk_freq;
	struct fman_rev_info rev_info;
	bool enabled_time_stamp;
	u8 count1_micro_bit;
	u8 total_num_of_tasks;
	u8 accumulated_num_of_tasks;
	u32 accumulated_fifo_size;
	u8 accumulated_num_of_open_dmas;
	u8 accumulated_num_of_deq_tnums;
	u32 exceptions;
	u32 extra_fifo_pool_size;
	u8 extra_tasks_pool_size;
	u8 extra_open_dmas_pool_size;
	u16 port_mfl[10];
	u16 mac_mfl[10];
	u32 fm_iram_size;
	u32 dma_thresh_max_commq;
	u32 dma_thresh_max_buf;
	u32 max_num_of_open_dmas;
	u32 qmi_max_num_of_tnums;
	u32 qmi_def_tnums_thresh;
	u32 bmi_max_num_of_tasks;
	u32 bmi_max_fifo_size;
	u32 fm_port_num_of_cg;
	u32 num_of_rx_ports;
	u32 total_fifo_size;
	u32 qman_channel_base;
	u32 num_of_qman_channels;
	struct resource *res;
};

struct fman_cfg {
	u8 disp_limit_tsh;
	u8 prs_disp_tsh;
	u8 plcr_disp_tsh;
	u8 kg_disp_tsh;
	u8 bmi_disp_tsh;
	u8 qmi_enq_disp_tsh;
	u8 qmi_deq_disp_tsh;
	u8 fm_ctl1_disp_tsh;
	u8 fm_ctl2_disp_tsh;
	int dma_cache_override;
	enum fman_dma_aid_mode dma_aid_mode;
	u32 dma_axi_dbg_num_of_beats;
	u32 dma_cam_num_of_entries;
	u32 dma_watchdog;
	u8 dma_comm_qtsh_asrt_emer;
	u32 dma_write_buf_tsh_asrt_emer;
	u32 dma_read_buf_tsh_asrt_emer;
	u8 dma_comm_qtsh_clr_emer;
	u32 dma_write_buf_tsh_clr_emer;
	u32 dma_read_buf_tsh_clr_emer;
	u32 dma_sos_emergency;
	int dma_dbg_cnt_mode;
	int catastrophic_err;
	int dma_err;
	u32 exceptions;
	u16 clk_freq;
	u32 cam_base_addr;
	u32 fifo_base_addr;
	u32 total_fifo_size;
	u32 total_num_of_tasks;
	u32 qmi_def_tnums_thresh;
};

struct fman_iram_regs {
	u32 iadd;
	u32 idata;
	u32 itcfg;
	u32 iready;
};

struct fman_port_init_params {
	u8 port_id;
	enum fman_port_type port_type;
	u16 port_speed;
	u16 liodn_offset;
	u8 num_of_tasks;
	u8 num_of_extra_tasks;
	u8 num_of_open_dmas;
	u8 num_of_extra_open_dmas;
	u32 size_of_fifo;
	u32 extra_size_of_fifo;
	u8 deq_pipeline_depth;
	u16 max_frame_length;
	u16 liodn_base;
};

struct enetc_mdio_priv {
	struct enetc_hw *hw;
	int mdio_base;
};

struct e1000_stats {
	char stat_string[32];
	int type;
	int sizeof_stat;
	int stat_offset;
};

enum {
	NETDEV_STATS = 0,
	E1000_STATS = 1,
};

struct ave_private;

struct ave_soc_data {
	bool is_desc_64bit;
	const char *clock_names[4];
	const char *reset_names[2];
	int (*get_pinmode)(struct ave_private *, phy_interface_t, u32);
};

struct ave_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
	u64 errors;
	u64 dropped;
	u64 collisions;
	u64 fifo_errors;
};

struct ave_desc;

struct ave_desc_info {
	u32 ndesc;
	u32 daddr;
	u32 proc_idx;
	u32 done_idx;
	struct ave_desc *desc;
};

struct ave_private {
	void *base;
	int irq;
	int phy_id;
	unsigned int desc_size;
	u32 msg_enable;
	int nclks;
	struct clk *clk[4];
	int nrsts;
	struct reset_control *rst[2];
	phy_interface_t phy_mode;
	struct phy_device *phydev;
	struct mii_bus *mdio;
	struct regmap *regmap;
	unsigned int pinmode_mask;
	unsigned int pinmode_val;
	u32 wolopts;
	struct ave_stats stats_rx;
	struct ave_stats stats_tx;
	struct net_device *ndev;
	struct napi_struct napi_rx;
	struct napi_struct napi_tx;
	struct ave_desc_info rx;
	struct ave_desc_info tx;
	int pause_auto;
	int pause_rx;
	int pause_tx;
	const struct ave_soc_data *data;
};

struct ave_desc {
	struct sk_buff *skbs;
	dma_addr_t skbs_dma;
	size_t skbs_dmalen;
};

enum desc_id {
	AVE_DESCID_RX = 0,
	AVE_DESCID_TX = 1,
};

enum desc_state {
	AVE_DESC_RX_PERMIT = 0,
	AVE_DESC_RX_SUSPEND = 1,
	AVE_DESC_START = 2,
	AVE_DESC_STOP = 3,
};

struct usb_dev_cap_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
};

struct phy_devm {
	struct usb_phy *phy;
	struct notifier_block *nb;
};

struct dwc3_meson_g12a;

struct dwc3_meson_g12a_drvdata {
	bool otg_phy_host_port_disable;
	struct clk_bulk_data *clks;
	int num_clks;
	const char * const *phy_names;
	int num_phys;
	int (*setup_regmaps)(struct dwc3_meson_g12a *, void *);
	int (*usb2_init_phy)(struct dwc3_meson_g12a *, int, enum phy_mode);
	int (*set_phy_mode)(struct dwc3_meson_g12a *, int, enum phy_mode);
	int (*usb_init)(struct dwc3_meson_g12a *);
	int (*usb_post_init)(struct dwc3_meson_g12a *);
};

struct dwc3_meson_g12a {
	struct device *dev;
	struct regmap *u2p_regmap[3];
	struct regmap *usb_glue_regmap;
	struct reset_control *reset;
	struct phy *phys[3];
	enum usb_dr_mode otg_mode;
	enum phy_mode otg_phy_mode;
	unsigned int usb2_ports;
	unsigned int usb3_ports;
	struct regulator *vbus;
	struct usb_role_switch_desc switch_desc;
	struct usb_role_switch *role_switch;
	const struct dwc3_meson_g12a_drvdata *drvdata;
};

struct isp1760_memory_layout {
	unsigned int blocks[3];
	unsigned int blocks_size[3];
	unsigned int slot_num;
	unsigned int payload_blocks;
	unsigned int payload_area_size;
};

enum isp1760_ctrl_state {
	ISP1760_CTRL_SETUP = 0,
	ISP1760_CTRL_DATA_IN = 1,
	ISP1760_CTRL_DATA_OUT = 2,
	ISP1760_CTRL_STATUS = 3,
};

enum isp176x_host_controller_fields {
	PORT_OWNER = 0,
	PORT_POWER = 1,
	PORT_LSTATUS = 2,
	PORT_RESET = 3,
	PORT_SUSPEND = 4,
	PORT_RESUME = 5,
	PORT_PE = 6,
	PORT_CSC = 7,
	PORT_CONNECT = 8,
	HCS_PPC = 9,
	HCS_N_PORTS = 10,
	HCC_ISOC_CACHE = 11,
	HCC_ISOC_THRES = 12,
	CMD_LRESET = 13,
	CMD_RESET = 14,
	CMD_RUN = 15,
	STS_PCD = 16,
	HC_FRINDEX = 17,
	FLAG_CF = 18,
	HC_ISO_PTD_DONEMAP = 19,
	HC_ISO_PTD_SKIPMAP = 20,
	HC_ISO_PTD_LASTPTD = 21,
	HC_INT_PTD_DONEMAP = 22,
	HC_INT_PTD_SKIPMAP = 23,
	HC_INT_PTD_LASTPTD = 24,
	HC_ATL_PTD_DONEMAP = 25,
	HC_ATL_PTD_SKIPMAP = 26,
	HC_ATL_PTD_LASTPTD = 27,
	ALL_ATX_RESET = 28,
	HW_ANA_DIGI_OC = 29,
	HW_DEV_DMA = 30,
	HW_COMN_IRQ = 31,
	HW_COMN_DMA = 32,
	HW_DATA_BUS_WIDTH = 33,
	HW_DACK_POL_HIGH = 34,
	HW_DREQ_POL_HIGH = 35,
	HW_INTR_HIGH_ACT = 36,
	HW_INTF_LOCK = 37,
	HW_INTR_EDGE_TRIG = 38,
	HW_GLOBAL_INTR_EN = 39,
	HC_CHIP_ID_HIGH = 40,
	HC_CHIP_ID_LOW = 41,
	HC_CHIP_REV = 42,
	HC_SCRATCH = 43,
	SW_RESET_RESET_ATX = 44,
	SW_RESET_RESET_HC = 45,
	SW_RESET_RESET_ALL = 46,
	ISO_BUF_FILL = 47,
	INT_BUF_FILL = 48,
	ATL_BUF_FILL = 49,
	MEM_BANK_SEL = 50,
	MEM_START_ADDR = 51,
	HC_DATA = 52,
	HC_INTERRUPT = 53,
	HC_INT_IRQ_ENABLE = 54,
	HC_ATL_IRQ_ENABLE = 55,
	HC_ISO_IRQ_MASK_OR = 56,
	HC_INT_IRQ_MASK_OR = 57,
	HC_ATL_IRQ_MASK_OR = 58,
	HC_ISO_IRQ_MASK_AND = 59,
	HC_INT_IRQ_MASK_AND = 60,
	HC_ATL_IRQ_MASK_AND = 61,
	HW_OTG_DISABLE = 62,
	HW_SW_SEL_HC_DC = 63,
	HW_VBUS_DRV = 64,
	HW_SEL_CP_EXT = 65,
	HW_DM_PULLDOWN = 66,
	HW_DP_PULLDOWN = 67,
	HW_DP_PULLUP = 68,
	HW_HC_2_DIS = 69,
	HW_OTG_DISABLE_CLEAR = 70,
	HW_SW_SEL_HC_DC_CLEAR = 71,
	HW_VBUS_DRV_CLEAR = 72,
	HW_SEL_CP_EXT_CLEAR = 73,
	HW_DM_PULLDOWN_CLEAR = 74,
	HW_DP_PULLDOWN_CLEAR = 75,
	HW_DP_PULLUP_CLEAR = 76,
	HW_HC_2_DIS_CLEAR = 77,
	HC_FIELD_MAX = 78,
};

enum isp176x_device_controller_fields {
	DC_DEVEN = 0,
	DC_DEVADDR = 1,
	DC_VBUSSTAT = 2,
	DC_SFRESET = 3,
	DC_GLINTENA = 4,
	DC_CDBGMOD_ACK = 5,
	DC_DDBGMODIN_ACK = 6,
	DC_DDBGMODOUT_ACK = 7,
	DC_INTPOL = 8,
	DC_IEPRXTX_7 = 9,
	DC_IEPRXTX_6 = 10,
	DC_IEPRXTX_5 = 11,
	DC_IEPRXTX_4 = 12,
	DC_IEPRXTX_3 = 13,
	DC_IEPRXTX_2 = 14,
	DC_IEPRXTX_1 = 15,
	DC_IEPRXTX_0 = 16,
	DC_IEP0SETUP = 17,
	DC_IEVBUS = 18,
	DC_IEHS_STA = 19,
	DC_IERESM = 20,
	DC_IESUSP = 21,
	DC_IEBRST = 22,
	DC_EP0SETUP = 23,
	DC_ENDPIDX = 24,
	DC_EPDIR = 25,
	DC_CLBUF = 26,
	DC_VENDP = 27,
	DC_DSEN = 28,
	DC_STATUS = 29,
	DC_STALL = 30,
	DC_BUFLEN = 31,
	DC_FFOSZ = 32,
	DC_EPENABLE = 33,
	DC_ENDPTYP = 34,
	DC_FRAMENUM = 35,
	DC_UFRAMENUM = 36,
	DC_CHIP_ID_HIGH = 37,
	DC_CHIP_ID_LOW = 38,
	DC_SCRATCH = 39,
	DC_FIELD_MAX = 40,
};

struct isp1760_memory_chunk {
	unsigned int start;
	unsigned int size;
	unsigned int free;
};

struct regmap_field;

struct isp1760_slotinfo;

struct isp1760_hcd {
	struct usb_hcd *hcd;
	void *base;
	struct regmap *regs;
	struct regmap_field *fields[78];
	bool is_isp1763;
	const struct isp1760_memory_layout *memory_layout;
	spinlock_t lock;
	struct isp1760_slotinfo *atl_slots;
	int atl_done_map;
	struct isp1760_slotinfo *int_slots;
	int int_done_map;
	struct isp1760_memory_chunk memory_pool[56];
	struct list_head qh_list[3];
	unsigned int periodic_size;
	unsigned int i_thresh;
	unsigned long reset_done;
	unsigned long next_statechange;
};

struct isp1760_qh;

struct isp1760_qtd;

struct isp1760_slotinfo {
	struct isp1760_qh *qh;
	struct isp1760_qtd *qtd;
	unsigned long timestamp;
};

struct isp1760_udc;

struct isp1760_ep {
	struct isp1760_udc *udc;
	struct usb_ep ep;
	struct list_head queue;
	unsigned int addr;
	unsigned int maxpacket;
	char name[7];
	const struct usb_endpoint_descriptor *desc;
	bool rx_pending;
	bool halted;
	bool wedged;
};

struct isp1760_device;

struct isp1760_udc {
	struct isp1760_device *isp;
	int irq;
	char *irqname;
	struct regmap *regs;
	struct regmap_field *fields[40];
	struct usb_gadget_driver *driver;
	struct usb_gadget gadget;
	spinlock_t lock;
	struct timer_list vbus_timer;
	struct isp1760_ep ep[15];
	enum isp1760_ctrl_state ep0_state;
	u8 ep0_dir;
	u16 ep0_length;
	bool connected;
	bool is_isp1763;
	unsigned int devstatus;
};

struct isp1760_device {
	struct device *dev;
	unsigned int devflags;
	struct gpio_desc *rst_gpio;
	struct isp1760_hcd hcd;
	struct isp1760_udc udc;
};

struct exynos_ehci_hcd {
	struct clk *clk;
	struct device_node *of_node;
	struct phy *phy[3];
	bool legacy_phy;
};

struct alps_protocol_info {
	u16 version;
	u8 byte0;
	u8 mask0;
	unsigned int flags;
};

struct alps_model_info {
	u8 signature[3];
	struct alps_protocol_info protocol_info;
};

struct alps_nibble_commands {
	int command;
	unsigned char data;
};

enum V7_PACKET_ID {
	V7_PACKET_ID_IDLE = 0,
	V7_PACKET_ID_TWO = 1,
	V7_PACKET_ID_MULTI = 2,
	V7_PACKET_ID_NEW = 3,
	V7_PACKET_ID_UNKNOWN = 4,
};

enum SS4_PACKET_ID {
	SS4_PACKET_ID_IDLE = 0,
	SS4_PACKET_ID_ONE = 1,
	SS4_PACKET_ID_TWO = 2,
	SS4_PACKET_ID_MULTI = 3,
	SS4_PACKET_ID_STICK = 4,
};

struct alps_fields {
	unsigned int x_map;
	unsigned int y_map;
	unsigned int fingers;
	int pressure;
	struct input_mt_pos st;
	struct input_mt_pos mt[4];
	unsigned int first_mp: 1;
	unsigned int is_mp: 1;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int ts_left: 1;
	unsigned int ts_right: 1;
	unsigned int ts_middle: 1;
};

struct alps_data {
	struct psmouse *psmouse;
	struct input_dev *dev2;
	struct input_dev *dev3;
	char phys2[32];
	char phys3[32];
	struct delayed_work dev3_register_work;
	const struct alps_nibble_commands *nibble_commands;
	int addr_command;
	u16 proto_version;
	u8 byte0;
	u8 mask0;
	u8 dev_id[3];
	u8 fw_ver[3];
	int flags;
	int x_max;
	int y_max;
	int x_bits;
	int y_bits;
	unsigned int x_res;
	unsigned int y_res;
	int (*hw_init)(struct psmouse *);
	void (*process_packet)(struct psmouse *);
	int (*decode_fields)(struct alps_fields *, unsigned char *, struct psmouse *);
	void (*set_abs_params)(struct alps_data *, struct input_dev *);
	int prev_fin;
	int multi_packet;
	int second_touch;
	unsigned char multi_data[6];
	struct alps_fields f;
	u8 quirks;
	struct timer_list timer;
};

struct alps_bitmap_point {
	int start_bit;
	int num_bits;
};

enum lpi2c_imx_mode {
	STANDARD = 0,
	FAST = 1,
	FAST_PLUS = 2,
	HS = 3,
	ULTRA_FAST = 4,
};

enum lpi2c_imx_pincfg {
	TWO_PIN_OD = 0,
	TWO_PIN_OO = 1,
	TWO_PIN_PP = 2,
	FOUR_PIN_PP = 3,
};

struct lpi2c_imx_struct {
	struct i2c_adapter adapter;
	int num_clks;
	struct clk_bulk_data *clks;
	void *base;
	__u8 *rx_buf;
	__u8 *tx_buf;
	struct completion complete;
	unsigned int msglen;
	unsigned int delivered;
	unsigned int block_data;
	unsigned int bitrate;
	unsigned int txfifosize;
	unsigned int rxfifosize;
	enum lpi2c_imx_mode mode;
};

struct kvm_ptp_clock {
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info caps;
};

struct system_counterval_t {
	u64 cycles;
	struct clocksource *cs;
};

enum regfield_ids {
	VER_MAJOR = 0,
	VER_MINOR = 1,
	VER_STEP = 2,
	TSENS_EN = 3,
	TSENS_SW_RST = 4,
	SENSOR_EN = 5,
	CODE_OR_TEMP = 6,
	TRDY = 7,
	INT_EN = 8,
	LAST_TEMP_0 = 9,
	LAST_TEMP_1 = 10,
	LAST_TEMP_2 = 11,
	LAST_TEMP_3 = 12,
	LAST_TEMP_4 = 13,
	LAST_TEMP_5 = 14,
	LAST_TEMP_6 = 15,
	LAST_TEMP_7 = 16,
	LAST_TEMP_8 = 17,
	LAST_TEMP_9 = 18,
	LAST_TEMP_10 = 19,
	LAST_TEMP_11 = 20,
	LAST_TEMP_12 = 21,
	LAST_TEMP_13 = 22,
	LAST_TEMP_14 = 23,
	LAST_TEMP_15 = 24,
	VALID_0 = 25,
	VALID_1 = 26,
	VALID_2 = 27,
	VALID_3 = 28,
	VALID_4 = 29,
	VALID_5 = 30,
	VALID_6 = 31,
	VALID_7 = 32,
	VALID_8 = 33,
	VALID_9 = 34,
	VALID_10 = 35,
	VALID_11 = 36,
	VALID_12 = 37,
	VALID_13 = 38,
	VALID_14 = 39,
	VALID_15 = 40,
	LOWER_STATUS_0 = 41,
	LOWER_STATUS_1 = 42,
	LOWER_STATUS_2 = 43,
	LOWER_STATUS_3 = 44,
	LOWER_STATUS_4 = 45,
	LOWER_STATUS_5 = 46,
	LOWER_STATUS_6 = 47,
	LOWER_STATUS_7 = 48,
	LOWER_STATUS_8 = 49,
	LOWER_STATUS_9 = 50,
	LOWER_STATUS_10 = 51,
	LOWER_STATUS_11 = 52,
	LOWER_STATUS_12 = 53,
	LOWER_STATUS_13 = 54,
	LOWER_STATUS_14 = 55,
	LOWER_STATUS_15 = 56,
	LOW_INT_STATUS_0 = 57,
	LOW_INT_STATUS_1 = 58,
	LOW_INT_STATUS_2 = 59,
	LOW_INT_STATUS_3 = 60,
	LOW_INT_STATUS_4 = 61,
	LOW_INT_STATUS_5 = 62,
	LOW_INT_STATUS_6 = 63,
	LOW_INT_STATUS_7 = 64,
	LOW_INT_STATUS_8 = 65,
	LOW_INT_STATUS_9 = 66,
	LOW_INT_STATUS_10 = 67,
	LOW_INT_STATUS_11 = 68,
	LOW_INT_STATUS_12 = 69,
	LOW_INT_STATUS_13 = 70,
	LOW_INT_STATUS_14 = 71,
	LOW_INT_STATUS_15 = 72,
	LOW_INT_CLEAR_0 = 73,
	LOW_INT_CLEAR_1 = 74,
	LOW_INT_CLEAR_2 = 75,
	LOW_INT_CLEAR_3 = 76,
	LOW_INT_CLEAR_4 = 77,
	LOW_INT_CLEAR_5 = 78,
	LOW_INT_CLEAR_6 = 79,
	LOW_INT_CLEAR_7 = 80,
	LOW_INT_CLEAR_8 = 81,
	LOW_INT_CLEAR_9 = 82,
	LOW_INT_CLEAR_10 = 83,
	LOW_INT_CLEAR_11 = 84,
	LOW_INT_CLEAR_12 = 85,
	LOW_INT_CLEAR_13 = 86,
	LOW_INT_CLEAR_14 = 87,
	LOW_INT_CLEAR_15 = 88,
	LOW_INT_MASK_0 = 89,
	LOW_INT_MASK_1 = 90,
	LOW_INT_MASK_2 = 91,
	LOW_INT_MASK_3 = 92,
	LOW_INT_MASK_4 = 93,
	LOW_INT_MASK_5 = 94,
	LOW_INT_MASK_6 = 95,
	LOW_INT_MASK_7 = 96,
	LOW_INT_MASK_8 = 97,
	LOW_INT_MASK_9 = 98,
	LOW_INT_MASK_10 = 99,
	LOW_INT_MASK_11 = 100,
	LOW_INT_MASK_12 = 101,
	LOW_INT_MASK_13 = 102,
	LOW_INT_MASK_14 = 103,
	LOW_INT_MASK_15 = 104,
	LOW_THRESH_0 = 105,
	LOW_THRESH_1 = 106,
	LOW_THRESH_2 = 107,
	LOW_THRESH_3 = 108,
	LOW_THRESH_4 = 109,
	LOW_THRESH_5 = 110,
	LOW_THRESH_6 = 111,
	LOW_THRESH_7 = 112,
	LOW_THRESH_8 = 113,
	LOW_THRESH_9 = 114,
	LOW_THRESH_10 = 115,
	LOW_THRESH_11 = 116,
	LOW_THRESH_12 = 117,
	LOW_THRESH_13 = 118,
	LOW_THRESH_14 = 119,
	LOW_THRESH_15 = 120,
	UPPER_STATUS_0 = 121,
	UPPER_STATUS_1 = 122,
	UPPER_STATUS_2 = 123,
	UPPER_STATUS_3 = 124,
	UPPER_STATUS_4 = 125,
	UPPER_STATUS_5 = 126,
	UPPER_STATUS_6 = 127,
	UPPER_STATUS_7 = 128,
	UPPER_STATUS_8 = 129,
	UPPER_STATUS_9 = 130,
	UPPER_STATUS_10 = 131,
	UPPER_STATUS_11 = 132,
	UPPER_STATUS_12 = 133,
	UPPER_STATUS_13 = 134,
	UPPER_STATUS_14 = 135,
	UPPER_STATUS_15 = 136,
	UP_INT_STATUS_0 = 137,
	UP_INT_STATUS_1 = 138,
	UP_INT_STATUS_2 = 139,
	UP_INT_STATUS_3 = 140,
	UP_INT_STATUS_4 = 141,
	UP_INT_STATUS_5 = 142,
	UP_INT_STATUS_6 = 143,
	UP_INT_STATUS_7 = 144,
	UP_INT_STATUS_8 = 145,
	UP_INT_STATUS_9 = 146,
	UP_INT_STATUS_10 = 147,
	UP_INT_STATUS_11 = 148,
	UP_INT_STATUS_12 = 149,
	UP_INT_STATUS_13 = 150,
	UP_INT_STATUS_14 = 151,
	UP_INT_STATUS_15 = 152,
	UP_INT_CLEAR_0 = 153,
	UP_INT_CLEAR_1 = 154,
	UP_INT_CLEAR_2 = 155,
	UP_INT_CLEAR_3 = 156,
	UP_INT_CLEAR_4 = 157,
	UP_INT_CLEAR_5 = 158,
	UP_INT_CLEAR_6 = 159,
	UP_INT_CLEAR_7 = 160,
	UP_INT_CLEAR_8 = 161,
	UP_INT_CLEAR_9 = 162,
	UP_INT_CLEAR_10 = 163,
	UP_INT_CLEAR_11 = 164,
	UP_INT_CLEAR_12 = 165,
	UP_INT_CLEAR_13 = 166,
	UP_INT_CLEAR_14 = 167,
	UP_INT_CLEAR_15 = 168,
	UP_INT_MASK_0 = 169,
	UP_INT_MASK_1 = 170,
	UP_INT_MASK_2 = 171,
	UP_INT_MASK_3 = 172,
	UP_INT_MASK_4 = 173,
	UP_INT_MASK_5 = 174,
	UP_INT_MASK_6 = 175,
	UP_INT_MASK_7 = 176,
	UP_INT_MASK_8 = 177,
	UP_INT_MASK_9 = 178,
	UP_INT_MASK_10 = 179,
	UP_INT_MASK_11 = 180,
	UP_INT_MASK_12 = 181,
	UP_INT_MASK_13 = 182,
	UP_INT_MASK_14 = 183,
	UP_INT_MASK_15 = 184,
	UP_THRESH_0 = 185,
	UP_THRESH_1 = 186,
	UP_THRESH_2 = 187,
	UP_THRESH_3 = 188,
	UP_THRESH_4 = 189,
	UP_THRESH_5 = 190,
	UP_THRESH_6 = 191,
	UP_THRESH_7 = 192,
	UP_THRESH_8 = 193,
	UP_THRESH_9 = 194,
	UP_THRESH_10 = 195,
	UP_THRESH_11 = 196,
	UP_THRESH_12 = 197,
	UP_THRESH_13 = 198,
	UP_THRESH_14 = 199,
	UP_THRESH_15 = 200,
	CRITICAL_STATUS_0 = 201,
	CRITICAL_STATUS_1 = 202,
	CRITICAL_STATUS_2 = 203,
	CRITICAL_STATUS_3 = 204,
	CRITICAL_STATUS_4 = 205,
	CRITICAL_STATUS_5 = 206,
	CRITICAL_STATUS_6 = 207,
	CRITICAL_STATUS_7 = 208,
	CRITICAL_STATUS_8 = 209,
	CRITICAL_STATUS_9 = 210,
	CRITICAL_STATUS_10 = 211,
	CRITICAL_STATUS_11 = 212,
	CRITICAL_STATUS_12 = 213,
	CRITICAL_STATUS_13 = 214,
	CRITICAL_STATUS_14 = 215,
	CRITICAL_STATUS_15 = 216,
	CRIT_INT_STATUS_0 = 217,
	CRIT_INT_STATUS_1 = 218,
	CRIT_INT_STATUS_2 = 219,
	CRIT_INT_STATUS_3 = 220,
	CRIT_INT_STATUS_4 = 221,
	CRIT_INT_STATUS_5 = 222,
	CRIT_INT_STATUS_6 = 223,
	CRIT_INT_STATUS_7 = 224,
	CRIT_INT_STATUS_8 = 225,
	CRIT_INT_STATUS_9 = 226,
	CRIT_INT_STATUS_10 = 227,
	CRIT_INT_STATUS_11 = 228,
	CRIT_INT_STATUS_12 = 229,
	CRIT_INT_STATUS_13 = 230,
	CRIT_INT_STATUS_14 = 231,
	CRIT_INT_STATUS_15 = 232,
	CRIT_INT_CLEAR_0 = 233,
	CRIT_INT_CLEAR_1 = 234,
	CRIT_INT_CLEAR_2 = 235,
	CRIT_INT_CLEAR_3 = 236,
	CRIT_INT_CLEAR_4 = 237,
	CRIT_INT_CLEAR_5 = 238,
	CRIT_INT_CLEAR_6 = 239,
	CRIT_INT_CLEAR_7 = 240,
	CRIT_INT_CLEAR_8 = 241,
	CRIT_INT_CLEAR_9 = 242,
	CRIT_INT_CLEAR_10 = 243,
	CRIT_INT_CLEAR_11 = 244,
	CRIT_INT_CLEAR_12 = 245,
	CRIT_INT_CLEAR_13 = 246,
	CRIT_INT_CLEAR_14 = 247,
	CRIT_INT_CLEAR_15 = 248,
	CRIT_INT_MASK_0 = 249,
	CRIT_INT_MASK_1 = 250,
	CRIT_INT_MASK_2 = 251,
	CRIT_INT_MASK_3 = 252,
	CRIT_INT_MASK_4 = 253,
	CRIT_INT_MASK_5 = 254,
	CRIT_INT_MASK_6 = 255,
	CRIT_INT_MASK_7 = 256,
	CRIT_INT_MASK_8 = 257,
	CRIT_INT_MASK_9 = 258,
	CRIT_INT_MASK_10 = 259,
	CRIT_INT_MASK_11 = 260,
	CRIT_INT_MASK_12 = 261,
	CRIT_INT_MASK_13 = 262,
	CRIT_INT_MASK_14 = 263,
	CRIT_INT_MASK_15 = 264,
	CRIT_THRESH_0 = 265,
	CRIT_THRESH_1 = 266,
	CRIT_THRESH_2 = 267,
	CRIT_THRESH_3 = 268,
	CRIT_THRESH_4 = 269,
	CRIT_THRESH_5 = 270,
	CRIT_THRESH_6 = 271,
	CRIT_THRESH_7 = 272,
	CRIT_THRESH_8 = 273,
	CRIT_THRESH_9 = 274,
	CRIT_THRESH_10 = 275,
	CRIT_THRESH_11 = 276,
	CRIT_THRESH_12 = 277,
	CRIT_THRESH_13 = 278,
	CRIT_THRESH_14 = 279,
	CRIT_THRESH_15 = 280,
	WDOG_BARK_STATUS = 281,
	WDOG_BARK_CLEAR = 282,
	WDOG_BARK_MASK = 283,
	WDOG_BARK_COUNT = 284,
	CC_MON_STATUS = 285,
	CC_MON_CLEAR = 286,
	CC_MON_MASK = 287,
	MIN_STATUS_0 = 288,
	MIN_STATUS_1 = 289,
	MIN_STATUS_2 = 290,
	MIN_STATUS_3 = 291,
	MIN_STATUS_4 = 292,
	MIN_STATUS_5 = 293,
	MIN_STATUS_6 = 294,
	MIN_STATUS_7 = 295,
	MIN_STATUS_8 = 296,
	MIN_STATUS_9 = 297,
	MIN_STATUS_10 = 298,
	MIN_STATUS_11 = 299,
	MIN_STATUS_12 = 300,
	MIN_STATUS_13 = 301,
	MIN_STATUS_14 = 302,
	MIN_STATUS_15 = 303,
	MAX_STATUS_0 = 304,
	MAX_STATUS_1 = 305,
	MAX_STATUS_2 = 306,
	MAX_STATUS_3 = 307,
	MAX_STATUS_4 = 308,
	MAX_STATUS_5 = 309,
	MAX_STATUS_6 = 310,
	MAX_STATUS_7 = 311,
	MAX_STATUS_8 = 312,
	MAX_STATUS_9 = 313,
	MAX_STATUS_10 = 314,
	MAX_STATUS_11 = 315,
	MAX_STATUS_12 = 316,
	MAX_STATUS_13 = 317,
	MAX_STATUS_14 = 318,
	MAX_STATUS_15 = 319,
	MAX_REGFIELDS = 320,
};

enum tsens_ver {
	VER_0 = 0,
	VER_0_1 = 1,
	VER_1_X = 2,
	VER_2_X = 3,
};

enum tsens_irq_type {
	LOWER = 0,
	UPPER = 1,
	CRITICAL = 2,
};

struct tsens_context {
	int threshold;
	int control;
};

struct tsens_priv;

struct tsens_sensor {
	struct tsens_priv *priv;
	struct thermal_zone_device *tzd;
	int offset;
	unsigned int hw_id;
	int slope;
	u32 status;
	int p1_calib_offset;
	int p2_calib_offset;
};

struct tsens_features;

struct tsens_ops;

struct tsens_priv {
	struct device *dev;
	u32 num_sensors;
	struct regmap *tm_map;
	struct regmap *srot_map;
	u32 tm_offset;
	spinlock_t ul_lock;
	struct regmap_field *rf[320];
	struct tsens_context ctx;
	struct tsens_features *feat;
	const struct reg_field *fields;
	const struct tsens_ops *ops;
	struct dentry *debug_root;
	struct dentry *debug;
	struct tsens_sensor sensor[0];
};

struct tsens_features {
	unsigned int ver_major;
	unsigned int crit_int: 1;
	unsigned int combo_int: 1;
	unsigned int adc: 1;
	unsigned int srot_split: 1;
	unsigned int has_watchdog: 1;
	unsigned int max_sensors;
	int trip_min_temp;
	int trip_max_temp;
};

struct tsens_ops {
	int (*init)(struct tsens_priv *);
	int (*calibrate)(struct tsens_priv *);
	int (*get_temp)(const struct tsens_sensor *, int *);
	int (*enable)(struct tsens_priv *, int);
	void (*disable)(struct tsens_priv *);
	int (*suspend)(struct tsens_priv *);
	int (*resume)(struct tsens_priv *);
};

struct tsens_single_value {
	u8 idx;
	u8 shift;
	u8 blob;
};

struct tsens_irq_data {
	u32 up_viol;
	int up_thresh;
	u32 up_irq_mask;
	u32 up_irq_clear;
	u32 low_viol;
	int low_thresh;
	u32 low_irq_mask;
	u32 low_irq_clear;
	u32 crit_viol;
	u32 crit_thresh;
	u32 crit_irq_mask;
	u32 crit_irq_clear;
};

struct tsens_legacy_calibration_format {
	unsigned int base_len;
	unsigned int base_shift;
	unsigned int sp_len;
	struct tsens_single_value mode;
	struct tsens_single_value invalid;
	struct tsens_single_value base[2];
	struct tsens_single_value sp[0];
};

struct tsens_plat_data {
	const u32 num_sensors;
	const struct tsens_ops *ops;
	unsigned int *hw_ids;
	struct tsens_features *feat;
	const struct reg_field *fields;
};

struct edac_device_ctl_info;

struct ctl_info_attribute {
	struct attribute attr;
	ssize_t (*show)(struct edac_device_ctl_info *, char *);
	ssize_t (*store)(struct edac_device_ctl_info *, const char *, size_t);
};

struct edac_device_counter {
	u32 ue_count;
	u32 ce_count;
};

struct edac_dev_sysfs_attribute;

struct edac_device_instance;

struct edac_device_block;

struct edac_dev_sysfs_block_attribute;

struct edac_device_ctl_info {
	struct list_head link;
	struct module *owner;
	int dev_idx;
	int log_ue;
	int log_ce;
	int panic_on_ue;
	unsigned int poll_msec;
	unsigned long delay;
	struct edac_dev_sysfs_attribute *sysfs_attributes;
	struct bus_type *edac_subsys;
	int op_state;
	struct delayed_work work;
	void (*edac_check)(struct edac_device_ctl_info *);
	struct device *dev;
	const char *mod_name;
	const char *ctl_name;
	const char *dev_name;
	void *pvt_info;
	unsigned long start_time;
	struct completion removal_complete;
	char name[32];
	u32 nr_instances;
	struct edac_device_instance *instances;
	struct edac_device_block *blocks;
	struct edac_dev_sysfs_block_attribute *attribs;
	struct edac_device_counter counters;
	struct kobject kobj;
};

struct edac_dev_sysfs_attribute {
	struct attribute attr;
	ssize_t (*show)(struct edac_device_ctl_info *, char *);
	ssize_t (*store)(struct edac_device_ctl_info *, const char *, size_t);
};

struct edac_device_instance {
	struct edac_device_ctl_info *ctl;
	char name[35];
	struct edac_device_counter counters;
	u32 nr_blocks;
	struct edac_device_block *blocks;
	struct kobject kobj;
};

struct edac_device_block {
	struct edac_device_instance *instance;
	char name[32];
	struct edac_device_counter counters;
	int nr_attribs;
	struct edac_dev_sysfs_block_attribute *block_attributes;
	struct kobject kobj;
};

struct edac_dev_sysfs_block_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
	struct edac_device_block *block;
	unsigned int value;
};

struct instance_attribute {
	struct attribute attr;
	ssize_t (*show)(struct edac_device_instance *, char *);
	ssize_t (*store)(struct edac_device_instance *, const char *, size_t);
};

struct qcom_cpufreq_data {
	void *base;
	struct mutex throttle_lock;
	int throttle_irq;
	char irq_name[15];
	bool cancel_throttle;
	struct delayed_work throttle_work;
	struct cpufreq_policy *policy;
	struct clk_hw cpu_clk;
	bool per_core_dcvs;
};

struct qcom_cpufreq_soc_data {
	u32 reg_enable;
	u32 reg_domain_state;
	u32 reg_dcvs_ctrl;
	u32 reg_freq_lut;
	u32 reg_volt_lut;
	u32 reg_intr_clr;
	u32 reg_current_vote;
	u32 reg_perf_state;
	u8 lut_row_size;
};

struct sdio_device_id;

struct sdio_driver {
	char *name;
	const struct sdio_device_id *id_table;
	int (*probe)(struct sdio_func *, const struct sdio_device_id *);
	void (*remove)(struct sdio_func *);
	struct device_driver drv;
};

struct sdio_device_id {
	__u8 class;
	__u16 vendor;
	__u16 device;
	kernel_ulong_t driver_data;
};

struct hi3798cv200_priv {
	struct clk *sample_clk;
	struct clk *drive_clk;
};

typedef void (*btf_trace_ufshcd_clk_gating)(void *, const char *, int);

typedef void (*btf_trace_ufshcd_clk_scaling)(void *, const char *, const char *, const char *, u32, u32);

typedef void (*btf_trace_ufshcd_auto_bkops_state)(void *, const char *, const char *);

typedef void (*btf_trace_ufshcd_profile_hibern8)(void *, const char *, const char *, s64, int);

typedef void (*btf_trace_ufshcd_profile_clk_gating)(void *, const char *, const char *, s64, int);

typedef void (*btf_trace_ufshcd_profile_clk_scaling)(void *, const char *, const char *, s64, int);

typedef void (*btf_trace_ufshcd_system_suspend)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_system_resume)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_runtime_suspend)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_runtime_resume)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_init)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_wl_suspend)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_wl_resume)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_wl_runtime_suspend)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_wl_runtime_resume)(void *, const char *, int, s64, int, int);

enum ufs_trace_str_t {
	UFS_CMD_SEND = 0,
	UFS_CMD_COMP = 1,
	UFS_DEV_COMP = 2,
	UFS_QUERY_SEND = 3,
	UFS_QUERY_COMP = 4,
	UFS_QUERY_ERR = 5,
	UFS_TM_SEND = 6,
	UFS_TM_COMP = 7,
	UFS_TM_ERR = 8,
};

typedef void (*btf_trace_ufshcd_command)(void *, struct scsi_device *, enum ufs_trace_str_t, unsigned int, u32, u32, int, u32, u64, u8, u8);

typedef void (*btf_trace_ufshcd_uic_command)(void *, const char *, enum ufs_trace_str_t, u32, u32, u32, u32);

enum ufs_trace_tsf_t {
	UFS_TSF_CDB = 0,
	UFS_TSF_OSF = 1,
	UFS_TSF_TM_INPUT = 2,
	UFS_TSF_TM_OUTPUT = 3,
};

typedef void (*btf_trace_ufshcd_upiu)(void *, const char *, enum ufs_trace_str_t, void *, void *, enum ufs_trace_tsf_t);

typedef void (*btf_trace_ufshcd_exception_event)(void *, const char *, u16);

struct ufs_pm_lvl_states {
	enum ufs_dev_pwr_mode dev_state;
	enum uic_link_state link_state;
};

struct ufs_dev_quirk {
	u16 wmanufacturerid;
	const u8 *model;
	unsigned int quirk;
};

struct ufs_ref_clk {
	unsigned long freq_hz;
	enum ufs_ref_clk_freq val;
};

enum {
	REG_CONTROLLER_CAPABILITIES = 0,
	REG_MCQCAP = 4,
	REG_UFS_VERSION = 8,
	REG_CONTROLLER_DEV_ID = 16,
	REG_CONTROLLER_PROD_ID = 20,
	REG_AUTO_HIBERNATE_IDLE_TIMER = 24,
	REG_INTERRUPT_STATUS = 32,
	REG_INTERRUPT_ENABLE = 36,
	REG_CONTROLLER_STATUS = 48,
	REG_CONTROLLER_ENABLE = 52,
	REG_UIC_ERROR_CODE_PHY_ADAPTER_LAYER = 56,
	REG_UIC_ERROR_CODE_DATA_LINK_LAYER = 60,
	REG_UIC_ERROR_CODE_NETWORK_LAYER = 64,
	REG_UIC_ERROR_CODE_TRANSPORT_LAYER = 68,
	REG_UIC_ERROR_CODE_DME = 72,
	REG_UTP_TRANSFER_REQ_INT_AGG_CONTROL = 76,
	REG_UTP_TRANSFER_REQ_LIST_BASE_L = 80,
	REG_UTP_TRANSFER_REQ_LIST_BASE_H = 84,
	REG_UTP_TRANSFER_REQ_DOOR_BELL = 88,
	REG_UTP_TRANSFER_REQ_LIST_CLEAR = 92,
	REG_UTP_TRANSFER_REQ_LIST_RUN_STOP = 96,
	REG_UTP_TASK_REQ_LIST_BASE_L = 112,
	REG_UTP_TASK_REQ_LIST_BASE_H = 116,
	REG_UTP_TASK_REQ_DOOR_BELL = 120,
	REG_UTP_TASK_REQ_LIST_CLEAR = 124,
	REG_UTP_TASK_REQ_LIST_RUN_STOP = 128,
	REG_UIC_COMMAND = 144,
	REG_UIC_COMMAND_ARG_1 = 148,
	REG_UIC_COMMAND_ARG_2 = 152,
	REG_UIC_COMMAND_ARG_3 = 156,
	UFSHCI_REG_SPACE_SIZE = 160,
	REG_UFS_CCAP = 256,
	REG_UFS_CRYPTOCAP = 260,
	REG_UFS_MEM_CFG = 768,
	REG_UFS_MCQ_CFG = 896,
	REG_UFS_ESILBA = 900,
	REG_UFS_ESIUBA = 904,
	UFSHCI_CRYPTO_REG_SPACE_SIZE = 1024,
};

enum ufs_unipro_ver {
	UFS_UNIPRO_VER_RESERVED = 0,
	UFS_UNIPRO_VER_1_40 = 1,
	UFS_UNIPRO_VER_1_41 = 2,
	UFS_UNIPRO_VER_1_6 = 3,
	UFS_UNIPRO_VER_1_61 = 4,
	UFS_UNIPRO_VER_1_8 = 5,
	UFS_UNIPRO_VER_MAX = 6,
	UFS_UNIPRO_VER_MASK = 15,
};

enum ufshcd_quirks {
	UFSHCD_QUIRK_BROKEN_INTR_AGGR = 1,
	UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS = 2,
	UFSHCD_QUIRK_BROKEN_LCC = 4,
	UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP = 8,
	UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE = 16,
	UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION = 32,
	UFSHCI_QUIRK_BROKEN_REQ_LIST_CLR = 64,
	UFSHCI_QUIRK_SKIP_RESET_INTR_AGGR = 128,
	UFSHCI_QUIRK_BROKEN_HCE = 256,
	UFSHCD_QUIRK_PRDT_BYTE_GRAN = 512,
	UFSHCD_QUIRK_BROKEN_OCS_FATAL_ERROR = 1024,
	UFSHCD_QUIRK_BROKEN_AUTO_HIBERN8 = 2048,
	UFSHCI_QUIRK_SKIP_MANUAL_WB_FLUSH_CTRL = 4096,
	UFSHCD_QUIRK_SKIP_DEF_UNIPRO_TIMEOUT_SETTING = 8192,
	UFSHCD_QUIRK_BROKEN_UIC_CMD = 32768,
	UFSHCD_QUIRK_SKIP_PH_CONFIGURATION = 65536,
	UFSHCD_QUIRK_BROKEN_64BIT_ADDRESS = 131072,
	UFSHCD_QUIRK_HIBERN_FASTAUTO = 262144,
	UFSHCD_QUIRK_REINIT_AFTER_MAX_GEAR_SWITCH = 524288,
	UFSHCD_QUIRK_MCQ_BROKEN_INTR = 1048576,
	UFSHCD_QUIRK_MCQ_BROKEN_RTC = 2097152,
};

enum flag_idn {
	QUERY_FLAG_IDN_FDEVICEINIT = 1,
	QUERY_FLAG_IDN_PERMANENT_WPE = 2,
	QUERY_FLAG_IDN_PWR_ON_WPE = 3,
	QUERY_FLAG_IDN_BKOPS_EN = 4,
	QUERY_FLAG_IDN_LIFE_SPAN_MODE_ENABLE = 5,
	QUERY_FLAG_IDN_PURGE_ENABLE = 6,
	QUERY_FLAG_IDN_RESERVED2 = 7,
	QUERY_FLAG_IDN_FPHYRESOURCEREMOVAL = 8,
	QUERY_FLAG_IDN_BUSY_RTC = 9,
	QUERY_FLAG_IDN_RESERVED3 = 10,
	QUERY_FLAG_IDN_PERMANENTLY_DISABLE_FW_UPDATE = 11,
	QUERY_FLAG_IDN_WB_EN = 14,
	QUERY_FLAG_IDN_WB_BUFF_FLUSH_EN = 15,
	QUERY_FLAG_IDN_WB_BUFF_FLUSH_DURING_HIBERN8 = 16,
	QUERY_FLAG_IDN_HPB_RESET = 17,
	QUERY_FLAG_IDN_HPB_EN = 18,
};

enum {
	UPIU_QUERY_FUNC_STANDARD_READ_REQUEST = 1,
	UPIU_QUERY_FUNC_STANDARD_WRITE_REQUEST = 129,
};

enum attr_idn {
	QUERY_ATTR_IDN_BOOT_LU_EN = 0,
	QUERY_ATTR_IDN_MAX_HPB_SINGLE_CMD = 1,
	QUERY_ATTR_IDN_POWER_MODE = 2,
	QUERY_ATTR_IDN_ACTIVE_ICC_LVL = 3,
	QUERY_ATTR_IDN_OOO_DATA_EN = 4,
	QUERY_ATTR_IDN_BKOPS_STATUS = 5,
	QUERY_ATTR_IDN_PURGE_STATUS = 6,
	QUERY_ATTR_IDN_MAX_DATA_IN = 7,
	QUERY_ATTR_IDN_MAX_DATA_OUT = 8,
	QUERY_ATTR_IDN_DYN_CAP_NEEDED = 9,
	QUERY_ATTR_IDN_REF_CLK_FREQ = 10,
	QUERY_ATTR_IDN_CONF_DESC_LOCK = 11,
	QUERY_ATTR_IDN_MAX_NUM_OF_RTT = 12,
	QUERY_ATTR_IDN_EE_CONTROL = 13,
	QUERY_ATTR_IDN_EE_STATUS = 14,
	QUERY_ATTR_IDN_SECONDS_PASSED = 15,
	QUERY_ATTR_IDN_CNTX_CONF = 16,
	QUERY_ATTR_IDN_CORR_PRG_BLK_NUM = 17,
	QUERY_ATTR_IDN_RESERVED2 = 18,
	QUERY_ATTR_IDN_RESERVED3 = 19,
	QUERY_ATTR_IDN_FFU_STATUS = 20,
	QUERY_ATTR_IDN_PSA_STATE = 21,
	QUERY_ATTR_IDN_PSA_DATA_SIZE = 22,
	QUERY_ATTR_IDN_REF_CLK_GATING_WAIT_TIME = 23,
	QUERY_ATTR_IDN_CASE_ROUGH_TEMP = 24,
	QUERY_ATTR_IDN_HIGH_TEMP_BOUND = 25,
	QUERY_ATTR_IDN_LOW_TEMP_BOUND = 26,
	QUERY_ATTR_IDN_WB_FLUSH_STATUS = 28,
	QUERY_ATTR_IDN_AVAIL_WB_BUFF_SIZE = 29,
	QUERY_ATTR_IDN_WB_BUFF_LIFE_TIME_EST = 30,
	QUERY_ATTR_IDN_CURR_WB_BUFF_SIZE = 31,
	QUERY_ATTR_IDN_EXT_IID_EN = 42,
	QUERY_ATTR_IDN_TIMESTAMP = 48,
};

enum desc_idn {
	QUERY_DESC_IDN_DEVICE = 0,
	QUERY_DESC_IDN_CONFIGURATION = 1,
	QUERY_DESC_IDN_UNIT = 2,
	QUERY_DESC_IDN_RFU_0 = 3,
	QUERY_DESC_IDN_INTERCONNECT = 4,
	QUERY_DESC_IDN_STRING = 5,
	QUERY_DESC_IDN_RFU_1 = 6,
	QUERY_DESC_IDN_GEOMETRY = 7,
	QUERY_DESC_IDN_POWER = 8,
	QUERY_DESC_IDN_HEALTH = 9,
	QUERY_DESC_IDN_MAX = 10,
};

enum desc_header_offset {
	QUERY_DESC_LENGTH_OFFSET = 0,
	QUERY_DESC_DESC_TYPE_OFFSET = 1,
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

enum ufs_hs_gear_tag {
	UFS_HS_DONT_CHANGE = 0,
	UFS_HS_G1 = 1,
	UFS_HS_G2 = 2,
	UFS_HS_G3 = 3,
	UFS_HS_G4 = 4,
	UFS_HS_G5 = 5,
};

enum {
	FAST_MODE = 1,
	SLOW_MODE = 2,
	FASTAUTO_MODE = 4,
	SLOWAUTO_MODE = 5,
	UNCHANGED = 7,
};

enum {
	UFSHCD_EH_IN_PROGRESS = 1,
};

enum utp_ocs {
	OCS_SUCCESS = 0,
	OCS_INVALID_CMD_TABLE_ATTR = 1,
	OCS_INVALID_PRDT_ATTR = 2,
	OCS_MISMATCH_DATA_BUF_SIZE = 3,
	OCS_MISMATCH_RESP_UPIU_SIZE = 4,
	OCS_PEER_COMM_FAILURE = 5,
	OCS_ABORTED = 6,
	OCS_FATAL_ERROR = 7,
	OCS_DEVICE_FATAL_ERROR = 8,
	OCS_INVALID_CRYPTO_CONFIG = 9,
	OCS_GENERAL_CRYPTO_ERROR = 10,
	OCS_INVALID_COMMAND_STATUS = 15,
};

enum {
	UTP_CMD_TYPE_SCSI = 0,
	UTP_CMD_TYPE_UFS = 1,
	UTP_CMD_TYPE_DEV_MANAGE = 2,
};

enum {
	UTP_CMD_TYPE_UFS_STORAGE = 1,
};

enum {
	MASK_OCS = 15,
};

enum {
	UFS_UPIU_REPORT_LUNS_WLUN = 129,
	UFS_UPIU_UFS_DEVICE_WLUN = 208,
	UFS_UPIU_BOOT_WLUN = 176,
	UFS_UPIU_RPMB_WLUN = 196,
};

enum {
	MASK_TRANSFER_REQUESTS_SLOTS = 31,
	MASK_TASK_MANAGEMENT_REQUEST_SLOTS = 458752,
	MASK_EHSLUTRD_SUPPORTED = 4194304,
	MASK_AUTO_HIBERN8_SUPPORT = 8388608,
	MASK_64_ADDRESSING_SUPPORT = 16777216,
	MASK_OUT_OF_ORDER_DATA_DELIVERY_SUPPORT = 33554432,
	MASK_UIC_DME_TEST_MODE_SUPPORT = 67108864,
	MASK_CRYPTO_SUPPORT = 268435456,
	MASK_MCQ_SUPPORT = 1073741824,
};

enum {
	UFS_ABORT_TASK = 1,
	UFS_ABORT_TASK_SET = 2,
	UFS_CLEAR_TASK_SET = 4,
	UFS_LOGICAL_RESET = 8,
	UFS_QUERY_TASK = 128,
	UFS_QUERY_TASK_SET = 129,
};

enum {
	UPIU_TASK_MANAGEMENT_FUNC_COMPL = 0,
	UPIU_TASK_MANAGEMENT_FUNC_NOT_SUPPORTED = 4,
	UPIU_TASK_MANAGEMENT_FUNC_SUCCEEDED = 8,
	UPIU_TASK_MANAGEMENT_FUNC_FAILED = 5,
	UPIU_INCORRECT_LOGICAL_UNIT_NO = 9,
};

enum {
	UFSHCD_MAX_CHANNEL = 0,
	UFSHCD_MAX_ID = 1,
	UFSHCD_CMD_PER_LUN = 31,
	UFSHCD_CAN_QUEUE = 31,
};

enum ufshcd_caps {
	UFSHCD_CAP_CLK_GATING = 1,
	UFSHCD_CAP_HIBERN8_WITH_CLK_GATING = 2,
	UFSHCD_CAP_CLK_SCALING = 4,
	UFSHCD_CAP_AUTO_BKOPS_SUSPEND = 8,
	UFSHCD_CAP_INTR_AGGR = 16,
	UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND = 32,
	UFSHCD_CAP_RPM_AUTOSUSPEND = 64,
	UFSHCD_CAP_WB_EN = 128,
	UFSHCD_CAP_CRYPTO = 256,
	UFSHCD_CAP_AGGR_POWER_COLLAPSE = 512,
	UFSHCD_CAP_DEEPSLEEP = 1024,
	UFSHCD_CAP_TEMP_NOTIF = 2048,
	UFSHCD_CAP_WB_WITH_CLK_SCALING = 4096,
};

enum {
	PWR_OK = 0,
	PWR_LOCAL = 1,
	PWR_REMOTE = 2,
	PWR_BUSY = 3,
	PWR_ERROR_CAP = 4,
	PWR_FATAL_ERROR = 5,
};

enum {
	INTERRUPT_MASK_ALL_VER_10 = 200703,
	INTERRUPT_MASK_RW_VER_10 = 196608,
	INTERRUPT_MASK_ALL_VER_11 = 204799,
	INTERRUPT_MASK_ALL_VER_21 = 466943,
};

enum {
	UPIU_RSP_FLAG_UNDERFLOW = 32,
	UPIU_RSP_FLAG_OVERFLOW = 64,
};

enum upiu_response_transaction {
	UPIU_TRANSACTION_NOP_IN = 32,
	UPIU_TRANSACTION_RESPONSE = 33,
	UPIU_TRANSACTION_DATA_IN = 34,
	UPIU_TRANSACTION_TASK_RSP = 36,
	UPIU_TRANSACTION_READY_XFER = 49,
	UPIU_TRANSACTION_QUERY_RSP = 54,
	UPIU_TRANSACTION_REJECT_UPIU = 63,
};

enum {
	WB_BUF_MODE_LU_DEDICATED = 0,
	WB_BUF_MODE_SHARED = 1,
};

enum {
	UFSHCD_UIC_DL_PA_INIT_ERROR = 1,
	UFSHCD_UIC_DL_NAC_RECEIVED_ERROR = 2,
	UFSHCD_UIC_DL_TCx_REPLAY_ERROR = 4,
	UFSHCD_UIC_NL_ERROR = 8,
	UFSHCD_UIC_TL_ERROR = 16,
	UFSHCD_UIC_DME_ERROR = 32,
	UFSHCD_UIC_PA_GENERIC_ERROR = 64,
};

enum utp_data_direction {
	UTP_NO_DATA_TRANSFER = 0,
	UTP_HOST_TO_DEVICE = 1,
	UTP_DEVICE_TO_HOST = 2,
};

enum {
	UPIU_CMD_FLAGS_NONE = 0,
	UPIU_CMD_FLAGS_CP = 4,
	UPIU_CMD_FLAGS_WRITE = 32,
	UPIU_CMD_FLAGS_READ = 64,
};

enum {
	MASK_TM_SERVICE_RESP = 255,
};

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

enum {
	UFSHCD_POLL_FROM_INTERRUPT_CONTEXT = -1,
};

enum ufs_pwm_gear_tag {
	UFS_PWM_DONT_CHANGE = 0,
	UFS_PWM_G1 = 1,
	UFS_PWM_G2 = 2,
	UFS_PWM_G3 = 3,
	UFS_PWM_G4 = 4,
	UFS_PWM_G5 = 5,
	UFS_PWM_G6 = 6,
	UFS_PWM_G7 = 7,
};

enum ufs_lanes {
	UFS_LANE_DONT_CHANGE = 0,
	UFS_LANE_1 = 1,
	UFS_LANE_2 = 2,
};

enum geometry_desc_param {
	GEOMETRY_DESC_PARAM_LEN = 0,
	GEOMETRY_DESC_PARAM_TYPE = 1,
	GEOMETRY_DESC_PARAM_DEV_CAP = 4,
	GEOMETRY_DESC_PARAM_MAX_NUM_LUN = 12,
	GEOMETRY_DESC_PARAM_SEG_SIZE = 13,
	GEOMETRY_DESC_PARAM_ALLOC_UNIT_SIZE = 17,
	GEOMETRY_DESC_PARAM_MIN_BLK_SIZE = 18,
	GEOMETRY_DESC_PARAM_OPT_RD_BLK_SIZE = 19,
	GEOMETRY_DESC_PARAM_OPT_WR_BLK_SIZE = 20,
	GEOMETRY_DESC_PARAM_MAX_IN_BUF_SIZE = 21,
	GEOMETRY_DESC_PARAM_MAX_OUT_BUF_SIZE = 22,
	GEOMETRY_DESC_PARAM_RPMB_RW_SIZE = 23,
	GEOMETRY_DESC_PARAM_DYN_CAP_RSRC_PLC = 24,
	GEOMETRY_DESC_PARAM_DATA_ORDER = 25,
	GEOMETRY_DESC_PARAM_MAX_NUM_CTX = 26,
	GEOMETRY_DESC_PARAM_TAG_UNIT_SIZE = 27,
	GEOMETRY_DESC_PARAM_TAG_RSRC_SIZE = 28,
	GEOMETRY_DESC_PARAM_SEC_RM_TYPES = 29,
	GEOMETRY_DESC_PARAM_MEM_TYPES = 30,
	GEOMETRY_DESC_PARAM_SCM_MAX_NUM_UNITS = 32,
	GEOMETRY_DESC_PARAM_SCM_CAP_ADJ_FCTR = 36,
	GEOMETRY_DESC_PARAM_NPM_MAX_NUM_UNITS = 38,
	GEOMETRY_DESC_PARAM_NPM_CAP_ADJ_FCTR = 42,
	GEOMETRY_DESC_PARAM_ENM1_MAX_NUM_UNITS = 44,
	GEOMETRY_DESC_PARAM_ENM1_CAP_ADJ_FCTR = 48,
	GEOMETRY_DESC_PARAM_ENM2_MAX_NUM_UNITS = 50,
	GEOMETRY_DESC_PARAM_ENM2_CAP_ADJ_FCTR = 54,
	GEOMETRY_DESC_PARAM_ENM3_MAX_NUM_UNITS = 56,
	GEOMETRY_DESC_PARAM_ENM3_CAP_ADJ_FCTR = 60,
	GEOMETRY_DESC_PARAM_ENM4_MAX_NUM_UNITS = 62,
	GEOMETRY_DESC_PARAM_ENM4_CAP_ADJ_FCTR = 66,
	GEOMETRY_DESC_PARAM_OPT_LOG_BLK_SIZE = 68,
	GEOMETRY_DESC_PARAM_HPB_REGION_SIZE = 72,
	GEOMETRY_DESC_PARAM_HPB_NUMBER_LU = 73,
	GEOMETRY_DESC_PARAM_HPB_SUBREGION_SIZE = 74,
	GEOMETRY_DESC_PARAM_HPB_MAX_ACTIVE_REGS = 75,
	GEOMETRY_DESC_PARAM_WB_MAX_ALLOC_UNITS = 79,
	GEOMETRY_DESC_PARAM_WB_MAX_WB_LUNS = 83,
	GEOMETRY_DESC_PARAM_WB_BUFF_CAP_ADJ = 84,
	GEOMETRY_DESC_PARAM_WB_SUP_RED_TYPE = 85,
	GEOMETRY_DESC_PARAM_WB_SUP_WB_TYPE = 86,
};

enum device_desc_param {
	DEVICE_DESC_PARAM_LEN = 0,
	DEVICE_DESC_PARAM_TYPE = 1,
	DEVICE_DESC_PARAM_DEVICE_TYPE = 2,
	DEVICE_DESC_PARAM_DEVICE_CLASS = 3,
	DEVICE_DESC_PARAM_DEVICE_SUB_CLASS = 4,
	DEVICE_DESC_PARAM_PRTCL = 5,
	DEVICE_DESC_PARAM_NUM_LU = 6,
	DEVICE_DESC_PARAM_NUM_WLU = 7,
	DEVICE_DESC_PARAM_BOOT_ENBL = 8,
	DEVICE_DESC_PARAM_DESC_ACCSS_ENBL = 9,
	DEVICE_DESC_PARAM_INIT_PWR_MODE = 10,
	DEVICE_DESC_PARAM_HIGH_PR_LUN = 11,
	DEVICE_DESC_PARAM_SEC_RMV_TYPE = 12,
	DEVICE_DESC_PARAM_SEC_LU = 13,
	DEVICE_DESC_PARAM_BKOP_TERM_LT = 14,
	DEVICE_DESC_PARAM_ACTVE_ICC_LVL = 15,
	DEVICE_DESC_PARAM_SPEC_VER = 16,
	DEVICE_DESC_PARAM_MANF_DATE = 18,
	DEVICE_DESC_PARAM_MANF_NAME = 20,
	DEVICE_DESC_PARAM_PRDCT_NAME = 21,
	DEVICE_DESC_PARAM_SN = 22,
	DEVICE_DESC_PARAM_OEM_ID = 23,
	DEVICE_DESC_PARAM_MANF_ID = 24,
	DEVICE_DESC_PARAM_UD_OFFSET = 26,
	DEVICE_DESC_PARAM_UD_LEN = 27,
	DEVICE_DESC_PARAM_RTT_CAP = 28,
	DEVICE_DESC_PARAM_FRQ_RTC = 29,
	DEVICE_DESC_PARAM_UFS_FEAT = 31,
	DEVICE_DESC_PARAM_FFU_TMT = 32,
	DEVICE_DESC_PARAM_Q_DPTH = 33,
	DEVICE_DESC_PARAM_DEV_VER = 34,
	DEVICE_DESC_PARAM_NUM_SEC_WPA = 36,
	DEVICE_DESC_PARAM_PSA_MAX_DATA = 37,
	DEVICE_DESC_PARAM_PSA_TMT = 41,
	DEVICE_DESC_PARAM_PRDCT_REV = 42,
	DEVICE_DESC_PARAM_HPB_VER = 64,
	DEVICE_DESC_PARAM_HPB_CONTROL = 66,
	DEVICE_DESC_PARAM_EXT_UFS_FEATURE_SUP = 79,
	DEVICE_DESC_PARAM_WB_PRESRV_USRSPC_EN = 83,
	DEVICE_DESC_PARAM_WB_TYPE = 84,
	DEVICE_DESC_PARAM_WB_SHARED_ALLOC_UNITS = 85,
};

enum {
	UFS_DEV_LOW_TEMP_NOTIF = 16,
	UFS_DEV_HIGH_TEMP_NOTIF = 32,
	UFS_DEV_EXT_TEMP_NOTIF = 64,
	UFS_DEV_HPB_SUPPORT = 128,
	UFS_DEV_WRITE_BOOSTER_SUP = 256,
	UFS_DEV_EXT_IID_SUP = 65536,
};

enum unit_desc_param {
	UNIT_DESC_PARAM_LEN = 0,
	UNIT_DESC_PARAM_TYPE = 1,
	UNIT_DESC_PARAM_UNIT_INDEX = 2,
	UNIT_DESC_PARAM_LU_ENABLE = 3,
	UNIT_DESC_PARAM_BOOT_LUN_ID = 4,
	UNIT_DESC_PARAM_LU_WR_PROTECT = 5,
	UNIT_DESC_PARAM_LU_Q_DEPTH = 6,
	UNIT_DESC_PARAM_PSA_SENSITIVE = 7,
	UNIT_DESC_PARAM_MEM_TYPE = 8,
	UNIT_DESC_PARAM_DATA_RELIABILITY = 9,
	UNIT_DESC_PARAM_LOGICAL_BLK_SIZE = 10,
	UNIT_DESC_PARAM_LOGICAL_BLK_COUNT = 11,
	UNIT_DESC_PARAM_ERASE_BLK_SIZE = 19,
	UNIT_DESC_PARAM_PROVISIONING_TYPE = 23,
	UNIT_DESC_PARAM_PHY_MEM_RSRC_CNT = 24,
	UNIT_DESC_PARAM_CTX_CAPABILITIES = 32,
	UNIT_DESC_PARAM_LARGE_UNIT_SIZE_M1 = 34,
	UNIT_DESC_PARAM_HPB_LU_MAX_ACTIVE_RGNS = 35,
	UNIT_DESC_PARAM_HPB_PIN_RGN_START_OFF = 37,
	UNIT_DESC_PARAM_HPB_NUM_PIN_RGNS = 39,
	UNIT_DESC_PARAM_WB_BUF_ALLOC_UNITS = 41,
};

enum {
	MASK_EE_STATUS = 65535,
	MASK_EE_DYNCAP_EVENT = 1,
	MASK_EE_SYSPOOL_EVENT = 2,
	MASK_EE_URGENT_BKOPS = 4,
	MASK_EE_TOO_HIGH_TEMP = 8,
	MASK_EE_TOO_LOW_TEMP = 16,
	MASK_EE_WRITEBOOSTER_EVENT = 32,
	MASK_EE_PERFORMANCE_THROTTLING = 64,
};

enum {
	PA_HS_MODE_A = 1,
	PA_HS_MODE_B = 2,
};

enum power_desc_param_offset {
	PWR_DESC_LEN = 0,
	PWR_DESC_TYPE = 1,
	PWR_DESC_ACTIVE_LVLS_VCC_0 = 2,
	PWR_DESC_ACTIVE_LVLS_VCCQ_0 = 34,
	PWR_DESC_ACTIVE_LVLS_VCCQ2_0 = 66,
};

enum {
	UFSHCD_NANO_AMP = 0,
	UFSHCD_MICRO_AMP = 1,
	UFSHCD_MILI_AMP = 2,
	UFSHCD_AMP = 3,
};

enum {
	UPIU_COMMAND_SET_TYPE_SCSI = 0,
	UPIU_COMMAND_SET_TYPE_UFS = 1,
	UPIU_COMMAND_SET_TYPE_QUERY = 2,
};

enum ufs_lu_wp_type {
	UFS_LU_NO_WP = 0,
	UFS_LU_POWER_ON_WP = 1,
	UFS_LU_PERM_WP = 2,
};

enum rpmb_unit_desc_param {
	RPMB_UNIT_DESC_PARAM_LEN = 0,
	RPMB_UNIT_DESC_PARAM_TYPE = 1,
	RPMB_UNIT_DESC_PARAM_UNIT_INDEX = 2,
	RPMB_UNIT_DESC_PARAM_LU_ENABLE = 3,
	RPMB_UNIT_DESC_PARAM_BOOT_LUN_ID = 4,
	RPMB_UNIT_DESC_PARAM_LU_WR_PROTECT = 5,
	RPMB_UNIT_DESC_PARAM_LU_Q_DEPTH = 6,
	RPMB_UNIT_DESC_PARAM_PSA_SENSITIVE = 7,
	RPMB_UNIT_DESC_PARAM_MEM_TYPE = 8,
	RPMB_UNIT_DESC_PARAM_REGION_EN = 9,
	RPMB_UNIT_DESC_PARAM_LOGICAL_BLK_SIZE = 10,
	RPMB_UNIT_DESC_PARAM_LOGICAL_BLK_COUNT = 11,
	RPMB_UNIT_DESC_PARAM_REGION0_SIZE = 19,
	RPMB_UNIT_DESC_PARAM_REGION1_SIZE = 20,
	RPMB_UNIT_DESC_PARAM_REGION2_SIZE = 21,
	RPMB_UNIT_DESC_PARAM_REGION3_SIZE = 22,
	RPMB_UNIT_DESC_PARAM_PROVISIONING_TYPE = 23,
	RPMB_UNIT_DESC_PARAM_PHY_MEM_RSRC_CNT = 24,
};

enum {
	MASK_EXT_IID_SUPPORT = 1024,
};

enum {
	TASK_REQ_UPIU_SIZE_DWORDS = 8,
	TASK_RSP_UPIU_SIZE_DWORDS = 8,
	ALIGNED_UPIU_SIZE = 512,
};

struct ufs_clk_info {
	struct list_head list;
	struct clk *clk;
	const char *name;
	u32 max_freq;
	u32 min_freq;
	u32 curr_freq;
	bool keep_link_active;
	bool enabled;
};

struct trace_event_raw_ufshcd_clk_gating {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	int state;
	char __data[0];
};

struct trace_event_raw_ufshcd_clk_scaling {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_state;
	u32 __data_loc_clk;
	u32 prev_state;
	u32 curr_state;
	char __data[0];
};

struct trace_event_raw_ufshcd_auto_bkops_state {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_state;
	char __data[0];
};

struct trace_event_raw_ufshcd_profiling_template {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_profile_info;
	s64 time_us;
	int err;
	char __data[0];
};

struct trace_event_raw_ufshcd_template {
	struct trace_entry ent;
	s64 usecs;
	int err;
	u32 __data_loc_dev_name;
	int dev_state;
	int link_state;
	char __data[0];
};

struct trace_event_raw_ufshcd_command {
	struct trace_entry ent;
	struct scsi_device *sdev;
	enum ufs_trace_str_t str_t;
	unsigned int tag;
	u32 doorbell;
	u32 hwq_id;
	u32 intr;
	u64 lba;
	int transfer_len;
	u8 opcode;
	u8 group_id;
	char __data[0];
};

struct trace_event_raw_ufshcd_uic_command {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	enum ufs_trace_str_t str_t;
	u32 cmd;
	u32 arg1;
	u32 arg2;
	u32 arg3;
	char __data[0];
};

struct trace_event_raw_ufshcd_upiu {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	enum ufs_trace_str_t str_t;
	unsigned char hdr[12];
	unsigned char tsf[16];
	enum ufs_trace_tsf_t tsf_t;
	char __data[0];
};

struct trace_event_raw_ufshcd_exception_event {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u16 status;
	char __data[0];
};

struct utp_upiu_query_v4_0 {
	__u8 opcode;
	__u8 idn;
	__u8 index;
	__u8 selector;
	__u8 osf3;
	__u8 osf4;
	__be16 osf5;
	__be32 osf6;
	__be32 osf7;
	__be32 reserved;
};

struct trace_event_data_offsets_ufshcd_clk_gating {
	u32 dev_name;
};

struct trace_event_data_offsets_ufshcd_clk_scaling {
	u32 dev_name;
	u32 state;
	u32 clk;
};

struct trace_event_data_offsets_ufshcd_auto_bkops_state {
	u32 dev_name;
	u32 state;
};

struct trace_event_data_offsets_ufshcd_profiling_template {
	u32 dev_name;
	u32 profile_info;
};

struct trace_event_data_offsets_ufshcd_template {
	u32 dev_name;
};

struct trace_event_data_offsets_ufshcd_uic_command {
	u32 dev_name;
};

struct trace_event_data_offsets_ufshcd_upiu {
	u32 dev_name;
};

struct trace_event_data_offsets_ufshcd_exception_event {
	u32 dev_name;
};

struct trace_event_data_offsets_ufshcd_command {};

struct uc_string_id {
	u8 len;
	u8 type;
	wchar_t uc[0];
};

struct scm_legacy_response {
	__le32 len;
	__le32 buf_offset;
	__le32 is_complete;
};

struct scm_legacy_command {
	__le32 len;
	__le32 buf_offset;
	__le32 resp_hdr_offset;
	__le32 id;
	__le32 buf[0];
};

struct arm_smccc_args {
	unsigned long args[8];
};

struct qcom_scm_desc {
	u32 svc;
	u32 cmd;
	u32 arginfo;
	u64 args[10];
	u32 owner;
};

struct qcom_scm_res {
	u64 result[3];
};

typedef int (*of_init_fn_1_ret)(struct device_node *);

struct apple_key_translation {
	u16 from;
	u16 to;
	u8 flags;
};

struct apple_non_apple_keyboard {
	char *name;
};

struct apple_sc_backlight;

struct apple_sc {
	struct hid_device *hdev;
	unsigned long quirks;
	unsigned int fn_on;
	unsigned int fn_found;
	unsigned long pressed_numlock[12];
	struct timer_list battery_timer;
	struct apple_sc_backlight *backlight;
};

struct apple_sc_backlight {
	struct led_classdev cdev;
	struct hid_device *hdev;
	unsigned short backlight_off;
	unsigned short backlight_on_min;
	unsigned short backlight_on_max;
};

struct apple_backlight_config_report {
	u8 report_id;
	u8 version;
	u16 backlight_off;
	u16 backlight_on_min;
	u16 backlight_on_max;
};

struct apple_backlight_set_report {
	u8 report_id;
	u8 version;
	u16 backlight;
	u16 rate;
};

enum ec_status {
	EC_RES_SUCCESS = 0,
	EC_RES_INVALID_COMMAND = 1,
	EC_RES_ERROR = 2,
	EC_RES_INVALID_PARAM = 3,
	EC_RES_ACCESS_DENIED = 4,
	EC_RES_INVALID_RESPONSE = 5,
	EC_RES_INVALID_VERSION = 6,
	EC_RES_INVALID_CHECKSUM = 7,
	EC_RES_IN_PROGRESS = 8,
	EC_RES_UNAVAILABLE = 9,
	EC_RES_TIMEOUT = 10,
	EC_RES_OVERFLOW = 11,
	EC_RES_INVALID_HEADER = 12,
	EC_RES_REQUEST_TRUNCATED = 13,
	EC_RES_RESPONSE_TOO_BIG = 14,
	EC_RES_BUS_ERROR = 15,
	EC_RES_BUSY = 16,
	EC_RES_INVALID_HEADER_VERSION = 17,
	EC_RES_INVALID_HEADER_CRC = 18,
	EC_RES_INVALID_DATA_CRC = 19,
	EC_RES_DUP_UNAVAILABLE = 20,
};

enum ec_mkbp_event {
	EC_MKBP_EVENT_KEY_MATRIX = 0,
	EC_MKBP_EVENT_HOST_EVENT = 1,
	EC_MKBP_EVENT_SENSOR_FIFO = 2,
	EC_MKBP_EVENT_BUTTON = 3,
	EC_MKBP_EVENT_SWITCH = 4,
	EC_MKBP_EVENT_FINGERPRINT = 5,
	EC_MKBP_EVENT_SYSRQ = 6,
	EC_MKBP_EVENT_HOST_EVENT64 = 7,
	EC_MKBP_EVENT_CEC_EVENT = 8,
	EC_MKBP_EVENT_CEC_MESSAGE = 9,
	EC_MKBP_EVENT_PCHG = 12,
	EC_MKBP_EVENT_COUNT = 13,
};

enum motionsense_command {
	MOTIONSENSE_CMD_DUMP = 0,
	MOTIONSENSE_CMD_INFO = 1,
	MOTIONSENSE_CMD_EC_RATE = 2,
	MOTIONSENSE_CMD_SENSOR_ODR = 3,
	MOTIONSENSE_CMD_SENSOR_RANGE = 4,
	MOTIONSENSE_CMD_KB_WAKE_ANGLE = 5,
	MOTIONSENSE_CMD_DATA = 6,
	MOTIONSENSE_CMD_FIFO_INFO = 7,
	MOTIONSENSE_CMD_FIFO_FLUSH = 8,
	MOTIONSENSE_CMD_FIFO_READ = 9,
	MOTIONSENSE_CMD_PERFORM_CALIB = 10,
	MOTIONSENSE_CMD_SENSOR_OFFSET = 11,
	MOTIONSENSE_CMD_LIST_ACTIVITIES = 12,
	MOTIONSENSE_CMD_SET_ACTIVITY = 13,
	MOTIONSENSE_CMD_LID_ANGLE = 14,
	MOTIONSENSE_CMD_FIFO_INT_ENABLE = 15,
	MOTIONSENSE_CMD_SPOOF = 16,
	MOTIONSENSE_CMD_TABLET_MODE_LID_ANGLE = 17,
	MOTIONSENSE_CMD_SENSOR_SCALE = 18,
	MOTIONSENSE_NUM_CMDS = 19,
};

enum {
	EC_MSG_TX_HEADER_BYTES = 3,
	EC_MSG_TX_TRAILER_BYTES = 1,
	EC_MSG_TX_PROTO_BYTES = 4,
	EC_MSG_RX_PROTO_BYTES = 3,
	EC_PROTO2_MSG_BYTES = 256,
	EC_MAX_MSG_BYTES = 65536,
};

enum ec_comms_status {
	EC_COMMS_STATUS_PROCESSING = 1,
};

struct ec_motion_sense_activity {
	uint8_t sensor_num;
	uint8_t activity;
	uint8_t enable;
	uint8_t reserved;
	uint16_t parameters[3];
};

struct ec_params_motion_sense {
	uint8_t cmd;
	union {
		struct {
			uint8_t max_sensor_count;
		} dump;
		struct {
			int16_t data;
		} kb_wake_angle;
		struct {
			uint8_t sensor_num;
		} info;
		struct {
			uint8_t sensor_num;
		} info_3;
		struct {
			uint8_t sensor_num;
		} data;
		struct {
			uint8_t sensor_num;
		} fifo_flush;
		struct {
			uint8_t sensor_num;
		} perform_calib;
		struct {
			uint8_t sensor_num;
		} list_activities;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} ec_rate;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} sensor_odr;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} sensor_range;
		struct {
			uint8_t sensor_num;
			uint16_t flags;
			int16_t temp;
			int16_t offset[3];
		} __attribute__((packed)) sensor_offset;
		struct {
			uint8_t sensor_num;
			uint16_t flags;
			int16_t temp;
			uint16_t scale[3];
		} __attribute__((packed)) sensor_scale;
		struct {
			uint32_t max_data_vector;
		} fifo_read;
		struct ec_motion_sense_activity set_activity;
		struct {
			int8_t enable;
		} fifo_int_enable;
		struct {
			uint8_t sensor_id;
			uint8_t spoof_enable;
			uint8_t reserved;
			int16_t components[3];
		} __attribute__((packed)) spoof;
		struct {
			int16_t lid_angle;
			int16_t hys_degree;
		} tablet_mode_threshold;
	};
} __attribute__((packed));

struct ec_response_motion_sensor_data {
	uint8_t flags;
	uint8_t sensor_num;
	union {
		int16_t data[3];
		struct {
			uint16_t reserved;
			uint32_t timestamp;
		} __attribute__((packed));
		struct {
			uint8_t activity;
			uint8_t state;
			int16_t add_info[2];
		};
	};
};

struct ec_response_motion_sense_fifo_data {
	uint32_t number_data;
	struct ec_response_motion_sensor_data data[0];
};

struct ec_response_motion_sense {
	union {
		struct {
			uint8_t module_flags;
			uint8_t sensor_count;
			struct {
				struct {} __empty_sensor;
				struct ec_response_motion_sensor_data sensor[0];
			};
		} dump;
		struct {
			uint8_t type;
			uint8_t location;
			uint8_t chip;
		} info;
		struct {
			uint8_t type;
			uint8_t location;
			uint8_t chip;
			uint32_t min_frequency;
			uint32_t max_frequency;
			uint32_t fifo_max_event_count;
		} info_3;
		struct ec_response_motion_sensor_data data;
		struct {
			int32_t ret;
		} ec_rate;
		struct {
			int32_t ret;
		} sensor_odr;
		struct {
			int32_t ret;
		} sensor_range;
		struct {
			int32_t ret;
		} kb_wake_angle;
		struct {
			int32_t ret;
		} fifo_int_enable;
		struct {
			int32_t ret;
		} spoof;
		struct {
			int16_t temp;
			int16_t offset[3];
		} sensor_offset;
		struct {
			int16_t temp;
			int16_t offset[3];
		} perform_calib;
		struct {
			int16_t temp;
			uint16_t scale[3];
		} sensor_scale;
		struct ec_response_motion_sense_fifo_info fifo_info;
		struct ec_response_motion_sense_fifo_info fifo_flush;
		struct ec_response_motion_sense_fifo_data fifo_read;
		struct {
			uint16_t reserved;
			uint32_t enabled;
			uint32_t disabled;
		} __attribute__((packed)) list_activities;
		struct {
			uint16_t value;
		} lid_angle;
		struct {
			uint16_t lid_angle;
			uint16_t hys_degree;
		} tablet_mode_threshold;
	};
};

struct ec_host_request {
	uint8_t struct_version;
	uint8_t checksum;
	uint16_t command;
	uint8_t command_version;
	uint8_t reserved;
	uint16_t data_len;
};

struct ec_response_get_protocol_info {
	uint32_t protocol_versions;
	uint16_t max_request_packet_size;
	uint16_t max_response_packet_size;
	uint32_t flags;
};

struct ec_params_hello {
	uint32_t in_data;
};

struct ec_response_hello {
	uint32_t out_data;
};

struct ec_params_get_cmd_versions {
	uint8_t cmd;
};

struct ec_response_get_cmd_versions {
	uint32_t version_mask;
};

struct ec_response_host_event_mask {
	uint32_t mask;
};

struct ec_response_get_comms_status {
	uint32_t flags;
};

struct ec_response_get_features {
	uint32_t flags[2];
};

struct cros_ec_debugfs;

struct cros_ec_dev {
	struct device class_dev;
	struct cros_ec_device *ec_dev;
	struct device *dev;
	struct cros_ec_debugfs *debug_info;
	bool has_kb_wake_angle;
	u16 cmd_offset;
	struct ec_response_get_features features;
};

struct virtqueue;

typedef void vq_callback_t(struct virtqueue *);

struct virtio_device;

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, vq_callback_t **, const char * const *, const bool *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	void (*synchronize_cbs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
	int (*disable_vq_and_reset)(struct virtqueue *);
	int (*enable_vq_after_reset)(struct virtqueue *);
};

struct vringh_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_enabled;
	bool config_change_pending;
	spinlock_t config_lock;
	spinlock_t vqs_list_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
};

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	unsigned int num_max;
	bool reset;
	void *priv;
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct rproc_subdev {
	struct list_head node;
	int (*prepare)(struct rproc_subdev *);
	int (*start)(struct rproc_subdev *);
	void (*stop)(struct rproc_subdev *, bool);
	void (*unprepare)(struct rproc_subdev *);
};

struct rproc_vdev;

struct rproc_vring {
	void *va;
	int num;
	u32 da;
	u32 align;
	int notifyid;
	struct rproc_vdev *rvdev;
	struct virtqueue *vq;
};

struct rproc_vdev {
	struct rproc_subdev subdev;
	struct platform_device *pdev;
	unsigned int id;
	struct list_head node;
	struct rproc *rproc;
	struct rproc_vring vring[2];
	u32 rsc_offset;
	u32 index;
};

struct rproc_vdev_data {
	u32 rsc_offset;
	unsigned int id;
	u32 index;
	struct fw_rsc_vdev *rsc;
};

struct pcm_format_data {
	unsigned char width;
	unsigned char phys;
	signed char le;
	signed char signd;
	unsigned char silence[8];
};

enum hdmi_audio_coding_type {
	HDMI_AUDIO_CODING_TYPE_STREAM = 0,
	HDMI_AUDIO_CODING_TYPE_PCM = 1,
	HDMI_AUDIO_CODING_TYPE_AC3 = 2,
	HDMI_AUDIO_CODING_TYPE_MPEG1 = 3,
	HDMI_AUDIO_CODING_TYPE_MP3 = 4,
	HDMI_AUDIO_CODING_TYPE_MPEG2 = 5,
	HDMI_AUDIO_CODING_TYPE_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_DTS = 7,
	HDMI_AUDIO_CODING_TYPE_ATRAC = 8,
	HDMI_AUDIO_CODING_TYPE_DSD = 9,
	HDMI_AUDIO_CODING_TYPE_EAC3 = 10,
	HDMI_AUDIO_CODING_TYPE_DTS_HD = 11,
	HDMI_AUDIO_CODING_TYPE_MLP = 12,
	HDMI_AUDIO_CODING_TYPE_DST = 13,
	HDMI_AUDIO_CODING_TYPE_WMA_PRO = 14,
	HDMI_AUDIO_CODING_TYPE_CXT = 15,
};

typedef int snd_pcm_hw_param_t;

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);

struct bpf_stab {
	struct bpf_map map;
	struct sock **sks;
	struct sk_psock_progs progs;
	spinlock_t lock;
	long: 64;
	long: 64;
};

struct bpf_shtab_bucket;

struct bpf_shtab {
	struct bpf_map map;
	struct bpf_shtab_bucket *buckets;
	u32 buckets_num;
	u32 elem_size;
	struct sk_psock_progs progs;
	atomic_t count;
	long: 64;
};

struct bpf_shtab_bucket {
	struct hlist_head head;
	spinlock_t lock;
};

struct bpf_shtab_elem {
	struct callback_head rcu;
	u32 hash;
	struct sock *sk;
	struct hlist_node node;
	u8 key[0];
};

struct sock_map_seq_info {
	struct bpf_map *map;
	struct sock *sk;
	u32 index;
};

struct bpf_iter__sockmap {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		struct sock *sk;
	};
};

struct sock_hash_seq_info {
	struct bpf_map *map;
	struct bpf_shtab *htab;
	u32 bucket_id;
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	ETHTOOL_A_LINKMODES_LANES = 9,
	ETHTOOL_A_LINKMODES_RATE_MATCHING = 10,
	__ETHTOOL_A_LINKMODES_CNT = 11,
	ETHTOOL_A_LINKMODES_MAX = 10,
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct link_mode_info {
	int speed;
	u8 lanes;
	u8 duplex;
};

enum ethtool_podl_pse_admin_state {
	ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN = 1,
	ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED = 2,
	ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED = 3,
};

enum ethtool_podl_pse_pw_d_status {
	ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN = 1,
	ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED = 2,
	ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING = 3,
	ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING = 4,
	ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP = 5,
	ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE = 6,
	ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR = 7,
};

enum {
	ETHTOOL_A_PSE_UNSPEC = 0,
	ETHTOOL_A_PSE_HEADER = 1,
	ETHTOOL_A_PODL_PSE_ADMIN_STATE = 2,
	ETHTOOL_A_PODL_PSE_ADMIN_CONTROL = 3,
	ETHTOOL_A_PODL_PSE_PW_D_STATUS = 4,
	__ETHTOOL_A_PSE_CNT = 5,
	ETHTOOL_A_PSE_MAX = 4,
};

struct pse_control_status {
	enum ethtool_podl_pse_admin_state podl_admin_state;
	enum ethtool_podl_pse_pw_d_status podl_pw_status;
};

struct pse_reply_data {
	struct ethnl_reply_data base;
	struct pse_control_status status;
};

struct pse_control_config {
	enum ethtool_podl_pse_admin_state admin_cotrol;
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
	TCP_ACK_DEFERRED = 6,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
	ICSK_ACK_NOMEM = 32,
};

struct tcp_ao_key;

struct tcp_md5sig_key;

struct tcp_key {
	union {
		struct {
			struct tcp_ao_key *ao_key;
			char *traffic_key;
			u32 sne;
			u8 rcv_next;
		};
		struct tcp_md5sig_key *md5_key;
	};
	enum {
		TCP_KEY_NONE = 0,
		TCP_KEY_MD5 = 1,
		TCP_KEY_AO = 2,
	} type;
};

union tcp_ao_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_ao_key {
	struct hlist_node node;
	union tcp_ao_addr addr;
	u8 key[80];
	unsigned int tcp_sigpool_id;
	unsigned int digest_size;
	int l3index;
	u8 prefixlen;
	u8 family;
	u8 keylen;
	u8 keyflags;
	u8 sndid;
	u8 rcvid;
	u8 maclen;
	struct callback_head rcu;
	atomic64_t pkt_good;
	atomic64_t pkt_bad;
	u8 traffic_keys[0];
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	u8 flags;
	union tcp_ao_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct tcp_ao_hdr {
	u8 kind;
	u8 length;
	u8 keyid;
	u8 rnext_keyid;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	int bucket;
	int offset;
	int sbucket;
	int num;
	loff_t last_pos;
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
};

struct bpf_tcp_iter_state {
	struct tcp_iter_state state;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
};

struct inet_diag_req_v2;

struct inet_diag_msg;

struct inet_diag_handler {
	void (*dump)(struct sk_buff *, struct netlink_callback *, const struct inet_diag_req_v2 *);
	int (*dump_one)(struct netlink_callback *, const struct inet_diag_req_v2 *);
	void (*idiag_get_info)(struct sock *, struct inet_diag_msg *, void *);
	int (*idiag_get_aux)(struct sock *, bool, struct sk_buff *);
	size_t (*idiag_get_aux_size)(struct sock *, bool);
	int (*destroy)(struct sk_buff *, const struct inet_diag_req_v2 *);
	__u16 idiag_type;
	__u16 idiag_info_size;
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

struct inet_diag_sockid {
	__be16 idiag_sport;
	__be16 idiag_dport;
	__be32 idiag_src[4];
	__be32 idiag_dst[4];
	__u32 idiag_if;
	__u32 idiag_cookie[2];
};

struct inet_diag_req_v2 {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u8 idiag_ext;
	__u8 pad;
	__u32 idiag_states;
	struct inet_diag_sockid id;
};

struct inet_diag_msg {
	__u8 idiag_family;
	__u8 idiag_state;
	__u8 idiag_timer;
	__u8 idiag_retrans;
	struct inet_diag_sockid id;
	__u32 idiag_expires;
	__u32 idiag_rqueue;
	__u32 idiag_wqueue;
	__u32 idiag_uid;
	__u32 idiag_inode;
};

enum {
	INET_DIAG_NONE = 0,
	INET_DIAG_MEMINFO = 1,
	INET_DIAG_INFO = 2,
	INET_DIAG_VEGASINFO = 3,
	INET_DIAG_CONG = 4,
	INET_DIAG_TOS = 5,
	INET_DIAG_TCLASS = 6,
	INET_DIAG_SKMEMINFO = 7,
	INET_DIAG_SHUTDOWN = 8,
	INET_DIAG_DCTCPINFO = 9,
	INET_DIAG_PROTOCOL = 10,
	INET_DIAG_SKV6ONLY = 11,
	INET_DIAG_LOCALS = 12,
	INET_DIAG_PEERS = 13,
	INET_DIAG_PAD = 14,
	INET_DIAG_MARK = 15,
	INET_DIAG_BBRINFO = 16,
	INET_DIAG_CLASS_ID = 17,
	INET_DIAG_MD5SIG = 18,
	INET_DIAG_ULP_INFO = 19,
	INET_DIAG_SK_BPF_STORAGES = 20,
	INET_DIAG_CGROUP_ID = 21,
	INET_DIAG_SOCKOPT = 22,
	__INET_DIAG_MAX = 23,
};

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
	__u32 tcpi_rcv_wnd;
	__u32 tcpi_rehash;
	__u16 tcpi_total_rto;
	__u16 tcpi_total_rto_recoveries;
	__u32 tcpi_total_rto_time;
};

enum devlink_resource_unit {
	DEVLINK_RESOURCE_UNIT_ENTRY = 0,
};

struct devlink_resource_size_params {
	u64 size_min;
	u64 size_max;
	u64 size_granularity;
	enum devlink_resource_unit unit;
};

typedef u64 devlink_resource_occ_get_t(void *);

struct devlink_resource {
	const char *name;
	u64 id;
	u64 size;
	u64 size_new;
	bool size_valid;
	struct devlink_resource *parent;
	struct devlink_resource_size_params size_params;
	struct list_head list;
	struct list_head resource_list;
	devlink_resource_occ_get_t *occ_get;
	void *occ_get_priv;
};

struct svc_pool_map {
	int count;
	int mode;
	unsigned int npools;
	unsigned int *pool_to;
	unsigned int *to_pool;
};

enum {
	SVC_POOL_AUTO = -1,
	SVC_POOL_GLOBAL = 0,
	SVC_POOL_PERCPU = 1,
	SVC_POOL_PERNODE = 2,
};

enum rpc_reply_stat {
	RPC_MSG_ACCEPTED = 0,
	RPC_MSG_DENIED = 1,
};

enum rpc_reject_stat {
	RPC_MISMATCH = 0,
	RPC_AUTH_ERROR = 1,
};

struct rps_map;

struct rps_dev_flow_table;

struct netdev_rx_queue {
	struct xdp_rxq_info xdp_rxq;
	struct rps_map __attribute__((btf_type_tag("rcu"))) *rps_map;
	struct rps_dev_flow_table __attribute__((btf_type_tag("rcu"))) *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct xsk_buff_pool *pool;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct sockaddr_xdp {
	__u16 sxdp_family;
	__u16 sxdp_flags;
	__u32 sxdp_ifindex;
	__u32 sxdp_queue_id;
	__u32 sxdp_shared_umem_fd;
};

struct xdp_ring_offset_v1 {
	__u64 producer;
	__u64 consumer;
	__u64 desc;
};

struct parsed_desc {
	u32 mb;
	u32 valid;
};

struct xdp_umem_reg {
	__u64 addr;
	__u64 len;
	__u32 chunk_size;
	__u32 headroom;
	__u32 flags;
};

struct xdp_statistics {
	__u64 rx_dropped;
	__u64 rx_invalid_descs;
	__u64 tx_invalid_descs;
	__u64 rx_ring_full;
	__u64 rx_fill_ring_empty_descs;
	__u64 tx_ring_empty_descs;
};

struct xdp_ring_offset {
	__u64 producer;
	__u64 consumer;
	__u64 desc;
	__u64 flags;
};

struct xdp_mmap_offsets {
	struct xdp_ring_offset rx;
	struct xdp_ring_offset tx;
	struct xdp_ring_offset fr;
	struct xdp_ring_offset cr;
};

struct xdp_mmap_offsets_v1 {
	struct xdp_ring_offset_v1 rx;
	struct xdp_ring_offset_v1 tx;
	struct xdp_ring_offset_v1 fr;
	struct xdp_ring_offset_v1 cr;
};

struct xdp_options {
	__u32 flags;
};

struct prev_kprobe {
	struct kprobe *kp;
	unsigned int status;
};

struct kprobe_ctlblk {
	unsigned int kprobe_status;
	unsigned long saved_irqflag;
	struct prev_kprobe prev_kprobe;
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	BPF_LINK_TYPE_PERF_EVENT = 7,
	BPF_LINK_TYPE_KPROBE_MULTI = 8,
	BPF_LINK_TYPE_STRUCT_OPS = 9,
	BPF_LINK_TYPE_NETFILTER = 10,
	BPF_LINK_TYPE_TCX = 11,
	BPF_LINK_TYPE_UPROBE_MULTI = 12,
	BPF_LINK_TYPE_NETKIT = 13,
	MAX_BPF_LINK_TYPE = 14,
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

struct bpf_plt {
	u32 insn_ldr;
	u32 insn_br;
	u64 target;
};

struct jit_ctx {
	const struct bpf_prog *prog;
	int idx;
	int epilogue_offset;
	int *offset;
	int exentry_idx;
	__le32 *image;
	u32 stack_size;
	int fpb_offset;
};

struct bpf_binary_header {
	u32 size;
	long: 0;
	u8 image[0];
};

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

struct bpf_tramp_link;

struct bpf_tramp_links {
	struct bpf_tramp_link *links[38];
	int nr_links;
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	struct work_struct work;
};

struct bpf_tramp_link {
	struct bpf_link link;
	struct hlist_node tramp_hlist;
	u64 cookie;
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
	int (*update_map)(struct bpf_link *, struct bpf_map *, struct bpf_map *);
};

struct bpf_tramp_run_ctx;

typedef u64 (*bpf_trampoline_enter_t)(struct bpf_prog *, struct bpf_tramp_run_ctx *);

struct bpf_tramp_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
	struct bpf_run_ctx *saved_run_ctx;
};

typedef void (*bpf_trampoline_exit_t)(struct bpf_prog *, u64, struct bpf_tramp_run_ctx *);

struct arm64_jit_data {
	struct bpf_binary_header *header;
	u8 *image;
	struct jit_ctx ctx;
};

struct kvm_irq_routing_irqchip {
	__u32 irqchip;
	__u32 pin;
};

struct kvm_irq_routing_msi {
	__u32 address_lo;
	__u32 address_hi;
	__u32 data;
	union {
		__u32 pad;
		__u32 devid;
	};
};

struct kvm_irq_routing_s390_adapter {
	__u64 ind_addr;
	__u64 summary_addr;
	__u64 ind_offset;
	__u32 summary_offset;
	__u32 adapter_id;
};

struct kvm_irq_routing_hv_sint {
	__u32 vcpu;
	__u32 sint;
};

struct kvm_irq_routing_xen_evtchn {
	__u32 port;
	__u32 vcpu;
	__u32 priority;
};

struct kvm_irq_routing_entry {
	__u32 gsi;
	__u32 type;
	__u32 flags;
	__u32 pad;
	union {
		struct kvm_irq_routing_irqchip irqchip;
		struct kvm_irq_routing_msi msi;
		struct kvm_irq_routing_s390_adapter adapter;
		struct kvm_irq_routing_hv_sint hv_sint;
		struct kvm_irq_routing_xen_evtchn xen_evtchn;
		__u32 pad[8];
	} u;
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
	IRQS_SYSFS = 16384,
};

struct dma_coherent_mem {
	void *virt_base;
	dma_addr_t device_base;
	unsigned long pfn_base;
	int size;
	unsigned long *bitmap;
	spinlock_t spinlock;
	bool use_dev_dma_pfn_offset;
};

typedef u32 note_buf_t[106];

struct ftrace_graph_ent;

typedef int (*trace_func_graph_ent_t)(struct ftrace_graph_ent *);

struct ftrace_graph_ret;

typedef void (*trace_func_graph_ret_t)(struct ftrace_graph_ret *);

struct fgraph_ops {
	trace_func_graph_ent_t entryfunc;
	trace_func_graph_ret_t retfunc;
};

struct ftrace_graph_ent {
	unsigned long func;
	int depth;
} __attribute__((packed));

struct ftrace_graph_ret {
	unsigned long func;
	unsigned long retval;
	int depth;
	unsigned int overrun;
	unsigned long long calltime;
	unsigned long long rettime;
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_USER_STACK = 12,
	TRACE_BLK = 13,
	TRACE_BPUTS = 14,
	TRACE_HWLAT = 15,
	TRACE_OSNOISE = 16,
	TRACE_TIMERLAT = 17,
	TRACE_RAW_DATA = 18,
	TRACE_FUNC_REPEATS = 19,
	__TRACE_LAST_TYPE = 20,
};

enum {
	TRACE_FTRACE_BIT = 0,
	TRACE_FTRACE_NMI_BIT = 1,
	TRACE_FTRACE_IRQ_BIT = 2,
	TRACE_FTRACE_SIRQ_BIT = 3,
	TRACE_FTRACE_TRANSITION_BIT = 4,
	TRACE_INTERNAL_BIT = 5,
	TRACE_INTERNAL_NMI_BIT = 6,
	TRACE_INTERNAL_IRQ_BIT = 7,
	TRACE_INTERNAL_SIRQ_BIT = 8,
	TRACE_INTERNAL_TRANSITION_BIT = 9,
	TRACE_BRANCH_BIT = 10,
	TRACE_IRQ_BIT = 11,
	TRACE_GRAPH_BIT = 12,
	TRACE_GRAPH_DEPTH_START_BIT = 13,
	TRACE_GRAPH_DEPTH_END_BIT = 14,
	TRACE_GRAPH_NOTRACE_BIT = 15,
	TRACE_RECORD_RECURSION_BIT = 16,
};

enum {
	FTRACE_HASH_FL_MOD = 1,
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_IRQS_NOSUPPORT = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
	TRACE_FLAG_BH_OFF = 128,
};

enum {
	FLAGS_FILL_FULL = 268435456,
	FLAGS_FILL_START = 536870912,
	FLAGS_FILL_END = 805306368,
};

struct fgraph_cpu_data {
	pid_t last_pid;
	int depth;
	int depth_irq;
	int ignore;
	unsigned long enter_funcs[50];
};

struct ftrace_graph_ent_entry {
	struct trace_entry ent;
	struct ftrace_graph_ent graph_ent;
};

struct ftrace_graph_ret_entry {
	struct trace_entry ent;
	struct ftrace_graph_ret ret;
};

struct ftrace_func_entry {
	struct hlist_node hlist;
	unsigned long ip;
	unsigned long direct;
};

struct fgraph_data {
	struct fgraph_cpu_data __attribute__((btf_type_tag("percpu"))) *cpu_data;
	struct ftrace_graph_ent_entry ent;
	struct ftrace_graph_ret_entry ret;
	int failed;
	int cpu;
	long: 0;
} __attribute__((packed));

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, unsigned long, int);

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned long ip;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
};

struct cgroup_iter_priv {
	struct cgroup_subsys_state *start_css;
	bool visited_all;
	bool terminate;
	int order;
};

struct bpf_iter__cgroup {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct cgroup *cgroup;
	};
};

struct bpf_iter_css {
	__u64 __opaque[3];
};

struct bpf_iter_css_kern {
	struct cgroup_subsys_state *start;
	struct cgroup_subsys_state *pos;
	unsigned int flags;
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
};

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	spinlock_t free_lock;
	swp_entry_t *slots_ret;
	int n_ret;
};

typedef void (*btf_trace_ksm_start_scan)(void *, int, u32);

typedef void (*btf_trace_ksm_stop_scan)(void *, int, u32);

typedef void (*btf_trace_ksm_enter)(void *, void *);

typedef void (*btf_trace_ksm_exit)(void *, void *);

typedef void (*btf_trace_ksm_merge_one_page)(void *, unsigned long, void *, void *, int);

typedef void (*btf_trace_ksm_merge_with_ksm_page)(void *, void *, unsigned long, void *, void *, int);

typedef void (*btf_trace_ksm_remove_ksm_page)(void *, unsigned long);

typedef void (*btf_trace_ksm_remove_rmap_item)(void *, unsigned long, void *, void *);

struct mm_slot {
	struct hlist_node hash;
	struct list_head mm_node;
	struct mm_struct *mm;
};

struct ksm_rmap_item;

struct ksm_mm_slot {
	struct mm_slot slot;
	struct ksm_rmap_item *rmap_list;
};

typedef u8 rmap_age_t;

struct ksm_stable_node;

struct ksm_rmap_item {
	struct ksm_rmap_item *rmap_list;
	union {
		struct anon_vma *anon_vma;
		int nid;
	};
	struct mm_struct *mm;
	unsigned long address;
	unsigned int oldchecksum;
	rmap_age_t age;
	rmap_age_t remaining_skips;
	union {
		struct rb_node node;
		struct {
			struct ksm_stable_node *head;
			struct hlist_node hlist;
		};
	};
};

struct ksm_stable_node {
	union {
		struct rb_node node;
		struct {
			struct list_head *head;
			struct {
				struct hlist_node hlist_dup;
				struct list_head list;
			};
		};
	};
	struct hlist_head hlist;
	union {
		unsigned long kpfn;
		unsigned long chain_prune_time;
	};
	int rmap_hlist_len;
	int nid;
};

struct ksm_scan {
	struct ksm_mm_slot *mm_slot;
	unsigned long address;
	struct ksm_rmap_item **rmap_list;
	unsigned long seqnr;
};

enum get_ksm_page_flags {
	GET_KSM_PAGE_NOLOCK = 0,
	GET_KSM_PAGE_LOCK = 1,
	GET_KSM_PAGE_TRYLOCK = 2,
};

struct trace_event_raw_ksm_scan_template {
	struct trace_entry ent;
	int seq;
	u32 rmap_entries;
	char __data[0];
};

struct trace_event_raw_ksm_enter_exit_template {
	struct trace_entry ent;
	void *mm;
	char __data[0];
};

struct trace_event_raw_ksm_merge_one_page {
	struct trace_entry ent;
	unsigned long pfn;
	void *rmap_item;
	void *mm;
	int err;
	char __data[0];
};

struct trace_event_raw_ksm_merge_with_ksm_page {
	struct trace_entry ent;
	void *ksm_page;
	unsigned long pfn;
	void *rmap_item;
	void *mm;
	int err;
	char __data[0];
};

struct trace_event_raw_ksm_remove_ksm_page {
	struct trace_entry ent;
	unsigned long pfn;
	char __data[0];
};

struct trace_event_raw_ksm_remove_rmap_item {
	struct trace_entry ent;
	unsigned long pfn;
	void *rmap_item;
	void *mm;
	char __data[0];
};

struct trace_event_data_offsets_ksm_scan_template {};

struct trace_event_data_offsets_ksm_enter_exit_template {};

struct trace_event_data_offsets_ksm_merge_one_page {};

struct trace_event_data_offsets_ksm_merge_with_ksm_page {};

struct trace_event_data_offsets_ksm_remove_ksm_page {};

struct trace_event_data_offsets_ksm_remove_rmap_item {};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page;

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[8];
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

typedef struct {
	unsigned long fds_bits[16];
} __kernel_fd_set;

typedef __kernel_fd_set fd_set;

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

struct compat_sel_arg_struct {
	compat_ulong_t n;
	compat_uptr_t inp;
	compat_uptr_t outp;
	compat_uptr_t exp;
	compat_uptr_t tvp;
};

typedef struct {
	unsigned long *in;
	unsigned long *out;
	unsigned long *ex;
	unsigned long *res_in;
	unsigned long *res_out;
	unsigned long *res_ex;
} fd_set_bits;

struct sigset_argpack {
	sigset_t __attribute__((btf_type_tag("user"))) *p;
	size_t size;
};

struct compat_sigset_argpack {
	compat_uptr_t p;
	compat_size_t size;
};

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_TRAPNO = 4,
	SIL_FAULT_MCEERR = 5,
	SIL_FAULT_BNDERR = 6,
	SIL_FAULT_PKUERR = 7,
	SIL_FAULT_PERF_EVENT = 8,
	SIL_CHLD = 9,
	SIL_RT = 10,
	SIL_SYS = 11,
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signalfd_ctx {
	sigset_t sigmask;
};

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_release_folio)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_invalidate_folio)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_dio_rw_queued)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_iter_dstmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_iter_srcmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_writepage_map)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_iter)(void *, struct iomap_iter *, const void *, unsigned long);

typedef void (*btf_trace_iomap_dio_rw_begin)(void *, struct kiocb *, struct iov_iter *, unsigned int, size_t);

typedef void (*btf_trace_iomap_dio_complete)(void *, struct kiocb *, int, ssize_t);

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	int nr_pages;
	char __data[0];
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t size;
	loff_t offset;
	u64 length;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_iter {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t pos;
	u64 length;
	unsigned int flags;
	const void *ops;
	unsigned long caller;
	char __data[0];
};

struct trace_event_raw_iomap_dio_rw_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t isize;
	loff_t pos;
	size_t count;
	size_t done_before;
	int ki_flags;
	unsigned int dio_flags;
	bool aio;
	char __data[0];
};

struct trace_event_raw_iomap_dio_complete {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t isize;
	loff_t pos;
	int ki_flags;
	bool aio;
	int error;
	ssize_t ret;
	char __data[0];
};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_iter {};

struct trace_event_data_offsets_iomap_dio_rw_begin {};

struct trace_event_data_offsets_iomap_dio_complete {};

enum {
	Opt_uid___3 = 0,
	Opt_gid___3 = 1,
	Opt_mode___2 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err___4 = 6,
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

struct ext4_fsmap_head;

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

struct ext2_group_desc {
	__le32 bg_block_bitmap;
	__le32 bg_inode_bitmap;
	__le32 bg_inode_table;
	__le16 bg_free_blocks_count;
	__le16 bg_free_inodes_count;
	__le16 bg_used_dirs_count;
	__le16 bg_pad;
	__le32 bg_reserved[3];
};

typedef int ext2_grpblk_t;

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, tid_t, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, tid_t, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, tid_t, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, tid_t, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, tid_t, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, tid_t, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, unsigned long, unsigned long);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, blk_opf_t);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, unsigned long);

typedef void (*btf_trace_jbd2_shrink_count)(void *, journal_t *, unsigned long, unsigned long);

typedef void (*btf_trace_jbd2_shrink_scan_enter)(void *, journal_t *, unsigned long, unsigned long);

typedef void (*btf_trace_jbd2_shrink_scan_exit)(void *, journal_t *, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_jbd2_shrink_checkpoint_list)(void *, journal_t *, tid_t, tid_t, tid_t, unsigned long, tid_t);

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	tid_t transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	tid_t transaction;
	tid_t head;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned long wait;
	unsigned long request_delay;
	unsigned long running;
	unsigned long locked;
	unsigned long flushing;
	unsigned long logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned long chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	unsigned long block_nr;
	unsigned long freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	blk_opf_t write_flags;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	unsigned long stall_ms;
	char __data[0];
};

struct trace_event_raw_jbd2_journal_shrink {
	struct trace_entry ent;
	dev_t dev;
	unsigned long nr_to_scan;
	unsigned long count;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned long nr_to_scan;
	unsigned long nr_shrunk;
	unsigned long count;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_checkpoint_list {
	struct trace_entry ent;
	dev_t dev;
	tid_t first_tid;
	tid_t tid;
	tid_t last_tid;
	unsigned long nr_freed;
	tid_t next_tid;
	char __data[0];
};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

struct trace_event_data_offsets_jbd2_journal_shrink {};

struct trace_event_data_offsets_jbd2_shrink_scan_exit {};

struct trace_event_data_offsets_jbd2_shrink_checkpoint_list {};

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

enum {
	LK_STATE_IN_USE = 0,
	NFS_DELEGATED_STATE = 1,
	NFS_OPEN_STATE = 2,
	NFS_O_RDONLY_STATE = 3,
	NFS_O_WRONLY_STATE = 4,
	NFS_O_RDWR_STATE = 5,
	NFS_STATE_RECLAIM_REBOOT = 6,
	NFS_STATE_RECLAIM_NOGRACE = 7,
	NFS_STATE_POSIX_LOCKS = 8,
	NFS_STATE_RECOVERY_FAILED = 9,
	NFS_STATE_MAY_NOTIFY_LOCK = 10,
	NFS_STATE_CHANGE_WAIT = 11,
	NFS_CLNT_DST_SSC_COPY_STATE = 12,
	NFS_CLNT_SRC_SSC_COPY_STATE = 13,
	NFS_SRV_SSC_COPY_STATE = 14,
};

enum {
	NFS_OWNER_RECLAIM_REBOOT = 0,
	NFS_OWNER_RECLAIM_NOGRACE = 1,
};

struct nfs4_setclientid_res {
	u64 clientid;
	nfs4_verifier confirm;
};

typedef void (*rpc_action)(struct rpc_task *);

struct bl_dev_msg {
	int32_t status;
	uint32_t major;
	uint32_t minor;
};

struct nfs_netns_client;

struct nfs_net {
	struct cache_detail *nfs_dns_resolve;
	struct rpc_pipe *bl_device_pipe;
	struct bl_dev_msg bl_mount_reply;
	wait_queue_head_t bl_wq;
	struct mutex bl_mutex;
	struct list_head nfs_client_list;
	struct list_head nfs_volume_list;
	struct idr cb_ident_idr;
	unsigned short nfs_callback_tcpport;
	unsigned short nfs_callback_tcpport6;
	int cb_users[3];
	struct nfs_netns_client *nfs_client;
	spinlock_t nfs_client_lock;
	ktime_t boot_time;
	struct proc_dir_entry *proc_nfsfs;
};

enum p9_qid_t {
	P9_QTDIR = 128,
	P9_QTAPPEND = 64,
	P9_QTEXCL = 32,
	P9_QTMOUNT = 16,
	P9_QTAUTH = 8,
	P9_QTTMP = 4,
	P9_QTSYMLINK = 2,
	P9_QTLINK = 1,
	P9_QTFILE = 0,
};

struct dotl_openflag_map {
	int open_flag;
	int dotl_flag;
};

struct dotl_iattr_map {
	int iattr_valid;
	int p9_iattr_valid;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	unsigned long shm_nattch;
	unsigned long shm_segsz;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct ucounts *mlock_ucounts;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	struct ipc_namespace *ns;
	long: 64;
	long: 64;
	long: 64;
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	unsigned short shm_nattch;
	unsigned short shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shared_policy {
	struct rb_root root;
	rwlock_t lock;
};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	unsigned long flags;
	unsigned long alloced;
	unsigned long swapped;
	union {
		struct offset_ctx dir_offsets;
		struct {
			struct list_head shrinklist;
			struct list_head swaplist;
		};
	};
	struct timespec64 i_crtime;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	unsigned long fallocend;
	unsigned int fsflags;
	atomic_t stop_eviction;
	struct inode vfs_inode;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	__kernel_size_t shm_segsz;
	long shm_atime;
	long shm_dtime;
	long shm_ctime;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	unsigned long shm_nattch;
	unsigned long __unused4;
	unsigned long __unused5;
};

struct shminfo64 {
	unsigned long shmmax;
	unsigned long shmmin;
	unsigned long shmmni;
	unsigned long shmseg;
	unsigned long shmall;
	unsigned long __unused1;
	unsigned long __unused2;
	unsigned long __unused3;
	unsigned long __unused4;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct compat_shmid64_ds {
	struct compat_ipc64_perm shm_perm;
	compat_size_t shm_segsz;
	compat_ulong_t shm_atime;
	compat_ulong_t shm_atime_high;
	compat_ulong_t shm_dtime;
	compat_ulong_t shm_dtime_high;
	compat_ulong_t shm_ctime;
	compat_ulong_t shm_ctime_high;
	compat_pid_t shm_cpid;
	compat_pid_t shm_lpid;
	compat_ulong_t shm_nattch;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct compat_shmid_ds {
	struct compat_ipc_perm shm_perm;
	int shm_segsz;
	old_time32_t shm_atime;
	old_time32_t shm_dtime;
	old_time32_t shm_ctime;
	compat_ipc_pid_t shm_cpid;
	compat_ipc_pid_t shm_lpid;
	unsigned short shm_nattch;
	unsigned short shm_unused;
	compat_uptr_t shm_unused2;
	compat_uptr_t shm_unused3;
};

struct compat_shm_info {
	compat_int_t used_ids;
	compat_ulong_t shm_tot;
	compat_ulong_t shm_rss;
	compat_ulong_t shm_swp;
	compat_ulong_t swap_attempts;
	compat_ulong_t swap_successes;
};

struct compat_shminfo64 {
	compat_ulong_t shmmax;
	compat_ulong_t shmmin;
	compat_ulong_t shmmni;
	compat_ulong_t shmseg;
	compat_ulong_t shmall;
	compat_ulong_t __unused1;
	compat_ulong_t __unused2;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct rand_data;

struct jitterentropy {
	spinlock_t jent_lock;
	struct rand_data *entropy_collector;
	struct crypto_shash *tfm;
	struct shash_desc *sdesc;
};

enum bfqq_expiration {
	BFQQE_TOO_IDLE = 0,
	BFQQE_BUDGET_TIMEOUT = 1,
	BFQQE_BUDGET_EXHAUSTED = 2,
	BFQQE_NO_MORE_REQUESTS = 3,
	BFQQE_PREEMPTED = 4,
};

enum blkg_rwstat_type {
	BLKG_RWSTAT_READ = 0,
	BLKG_RWSTAT_WRITE = 1,
	BLKG_RWSTAT_SYNC = 2,
	BLKG_RWSTAT_ASYNC = 3,
	BLKG_RWSTAT_DISCARD = 4,
	BLKG_RWSTAT_NR = 5,
	BLKG_RWSTAT_TOTAL = 5,
};

struct bfq_sched_data;

struct bfq_queue;

struct bfq_entity {
	struct rb_node rb_node;
	bool on_st_or_in_serv;
	u64 start;
	u64 finish;
	struct rb_root *tree;
	u64 min_start;
	int service;
	int budget;
	int allocated;
	int dev_weight;
	int weight;
	int new_weight;
	int orig_weight;
	struct bfq_entity *parent;
	struct bfq_sched_data *my_sched_data;
	struct bfq_sched_data *sched_data;
	int prio_changed;
	bool in_groups_with_pending_reqs;
	struct bfq_queue *last_bfqq_created;
};

struct bfq_service_tree {
	struct rb_root active;
	struct rb_root idle;
	struct bfq_entity *first_idle;
	struct bfq_entity *last_idle;
	u64 vtime;
	unsigned long wsum;
};

struct bfq_sched_data {
	struct bfq_entity *in_service_entity;
	struct bfq_entity *next_in_service;
	struct bfq_service_tree service_tree[3];
	unsigned long bfq_class_idle_last_service;
};

struct blkg_rwstat {
	struct percpu_counter cpu_cnt[5];
	atomic64_t aux_cnt[5];
};

struct bfqg_stats {
	struct blkg_rwstat bytes;
	struct blkg_rwstat ios;
};

struct bfq_data;

struct bfq_group {
	struct blkg_policy_data pd;
	char blkg_path[128];
	refcount_t ref;
	struct bfq_entity entity;
	struct bfq_sched_data sched_data;
	struct bfq_data *bfqd;
	struct bfq_queue *async_bfqq[128];
	struct bfq_queue *async_idle_bfqq[8];
	struct bfq_entity *my_entity;
	int active_entities;
	int num_queues_with_pending_reqs;
	struct rb_root rq_pos_tree;
	struct bfqg_stats stats;
};

struct bfq_ttime {
	u64 last_end_request;
	u64 ttime_total;
	unsigned long ttime_samples;
	u64 ttime_mean;
};

struct bfq_weight_counter;

struct bfq_io_cq;

struct bfq_queue {
	int ref;
	int stable_ref;
	struct bfq_data *bfqd;
	unsigned short ioprio;
	unsigned short ioprio_class;
	unsigned short new_ioprio;
	unsigned short new_ioprio_class;
	u64 last_serv_time_ns;
	unsigned int inject_limit;
	unsigned long decrease_time_jif;
	struct bfq_queue *new_bfqq;
	struct rb_node pos_node;
	struct rb_root *pos_root;
	struct rb_root sort_list;
	struct request *next_rq;
	int queued[2];
	int meta_pending;
	struct list_head fifo;
	struct bfq_entity entity;
	struct bfq_weight_counter *weight_counter;
	int max_budget;
	unsigned long budget_timeout;
	int dispatched;
	unsigned long flags;
	struct list_head bfqq_list;
	struct bfq_ttime ttime;
	u64 io_start_time;
	u64 tot_idle_time;
	u32 seek_history;
	struct hlist_node burst_list_node;
	sector_t last_request_pos;
	unsigned int requests_within_timer;
	pid_t pid;
	struct bfq_io_cq *bic;
	unsigned long wr_cur_max_time;
	unsigned long soft_rt_next_start;
	unsigned long last_wr_start_finish;
	unsigned int wr_coeff;
	unsigned long last_idle_bklogged;
	unsigned long service_from_backlogged;
	unsigned long service_from_wr;
	unsigned long wr_start_at_switch_to_srt;
	unsigned long split_time;
	unsigned long first_IO_time;
	unsigned long creation_time;
	struct bfq_queue *waker_bfqq;
	struct bfq_queue *tentative_waker_bfqq;
	unsigned int num_waker_detections;
	u64 waker_detection_started;
	struct hlist_node woken_list_node;
	struct hlist_head woken_list;
	unsigned int actuator_idx;
};

struct bfq_data {
	struct request_queue *queue;
	struct list_head dispatch;
	struct bfq_group *root_group;
	struct rb_root_cached queue_weights_tree;
	unsigned int num_groups_with_pending_reqs;
	unsigned int busy_queues[3];
	int wr_busy_queues;
	int queued;
	int tot_rq_in_driver;
	int rq_in_driver[8];
	bool nonrot_with_queueing;
	int max_rq_in_driver;
	int hw_tag_samples;
	int hw_tag;
	int budgets_assigned;
	struct hrtimer idle_slice_timer;
	struct bfq_queue *in_service_queue;
	sector_t last_position;
	sector_t in_serv_last_pos;
	u64 last_completion;
	struct bfq_queue *last_completed_rq_bfqq;
	struct bfq_queue *last_bfqq_created;
	u64 last_empty_occupied_ns;
	bool wait_dispatch;
	struct request *waited_rq;
	bool rqs_injected;
	u64 first_dispatch;
	u64 last_dispatch;
	ktime_t last_budget_start;
	ktime_t last_idling_start;
	unsigned long last_idling_start_jiffies;
	int peak_rate_samples;
	u32 sequential_samples;
	u64 tot_sectors_dispatched;
	u32 last_rq_max_size;
	u64 delta_from_first;
	u32 peak_rate;
	int bfq_max_budget;
	struct list_head active_list[8];
	struct list_head idle_list;
	u64 bfq_fifo_expire[2];
	unsigned int bfq_back_penalty;
	unsigned int bfq_back_max;
	u32 bfq_slice_idle;
	int bfq_user_max_budget;
	unsigned int bfq_timeout;
	bool strict_guarantees;
	unsigned long last_ins_in_burst;
	unsigned long bfq_burst_interval;
	int burst_size;
	struct bfq_entity *burst_parent_entity;
	unsigned long bfq_large_burst_thresh;
	bool large_burst;
	struct hlist_head burst_list;
	bool low_latency;
	unsigned int bfq_wr_coeff;
	unsigned int bfq_wr_rt_max_time;
	unsigned int bfq_wr_min_idle_time;
	unsigned long bfq_wr_min_inter_arr_async;
	unsigned int bfq_wr_max_softrt_rate;
	u64 rate_dur_prod;
	struct bfq_queue oom_bfqq;
	spinlock_t lock;
	struct bfq_io_cq *bio_bic;
	struct bfq_queue *bio_bfqq;
	unsigned int word_depths[4];
	unsigned int full_depth_shift;
	unsigned int num_actuators;
	sector_t sector[8];
	sector_t nr_sectors[8];
	struct blk_independent_access_range ia_ranges[8];
	unsigned int actuator_load_threshold;
};

struct bfq_iocq_bfqq_data {
	bool saved_has_short_ttime;
	bool saved_IO_bound;
	u64 saved_io_start_time;
	u64 saved_tot_idle_time;
	bool saved_in_large_burst;
	bool was_in_burst_list;
	unsigned int saved_weight;
	unsigned long saved_wr_coeff;
	unsigned long saved_last_wr_start_finish;
	unsigned long saved_service_from_wr;
	unsigned long saved_wr_start_at_switch_to_srt;
	unsigned int saved_wr_cur_max_time;
	struct bfq_ttime saved_ttime;
	u64 saved_last_serv_time_ns;
	unsigned int saved_inject_limit;
	unsigned long saved_decrease_time_jif;
	struct bfq_queue *stable_merge_bfqq;
	bool stably_merged;
};

struct bfq_io_cq {
	struct io_cq icq;
	struct bfq_queue *bfqq[16];
	int ioprio;
	uint64_t blkcg_serial_nr;
	struct bfq_iocq_bfqq_data bfqq_data[8];
	unsigned int requests;
};

struct bfq_weight_counter {
	unsigned int weight;
	unsigned int num_active;
	struct rb_node weights_node;
};

struct bfq_group_data {
	struct blkcg_policy_data pd;
	unsigned int weight;
};

struct blkg_rwstat_sample {
	u64 cnt[5];
};

struct io_shutdown {
	struct file *file;
	int how;
};

struct compat_msghdr;

struct user_msghdr;

struct io_sr_msg {
	struct file *file;
	union {
		struct compat_msghdr __attribute__((btf_type_tag("user"))) *umsg_compat;
		struct user_msghdr __attribute__((btf_type_tag("user"))) *umsg;
		void __attribute__((btf_type_tag("user"))) *buf;
	};
	unsigned int len;
	unsigned int done_io;
	unsigned int msg_flags;
	u16 flags;
	u16 addr_len;
	u16 buf_group;
	void __attribute__((btf_type_tag("user"))) *addr;
	void __attribute__((btf_type_tag("user"))) *msg_control;
	struct io_kiocb *notif;
};

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct user_msghdr {
	void __attribute__((btf_type_tag("user"))) *msg_name;
	int msg_namelen;
	struct iovec __attribute__((btf_type_tag("user"))) *msg_iov;
	__kernel_size_t msg_iovlen;
	void __attribute__((btf_type_tag("user"))) *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

struct io_accept {
	struct file *file;
	struct sockaddr __attribute__((btf_type_tag("user"))) *addr;
	int __attribute__((btf_type_tag("user"))) *addr_len;
	int flags;
	u32 file_slot;
	unsigned long nofile;
};

struct io_socket {
	struct file *file;
	int domain;
	int type;
	int protocol;
	int flags;
	u32 file_slot;
	unsigned long nofile;
};

struct io_connect {
	struct file *file;
	struct sockaddr __attribute__((btf_type_tag("user"))) *addr;
	int addr_len;
	bool in_progress;
	bool seen_econnaborted;
};

struct io_async_msghdr {
	union {
		struct iovec fast_iov[8];
		struct {
			struct iovec fast_iov_one;
			__kernel_size_t controllen;
			int namelen;
			__kernel_size_t payloadlen;
		};
		struct io_cache_entry cache;
	};
	struct iovec *free_iov;
	struct sockaddr __attribute__((btf_type_tag("user"))) *uaddr;
	struct msghdr msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_notif_data {
	struct file *file;
	struct ubuf_info uarg;
	unsigned long account_pages;
	bool zc_report;
	bool zc_used;
	bool zc_copied;
};

struct io_uring_recvmsg_out {
	__u32 namelen;
	__u32 controllen;
	__u32 payloadlen;
	__u32 flags;
};

struct io_recvmsg_multishot_hdr {
	struct io_uring_recvmsg_out msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_async_connect {
	struct __kernel_sockaddr_storage address;
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		unsigned long sc_segments;
		unsigned long dissimilarity;
	} wrong_shortcut;
};

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

typedef enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 10,
	ZSTD_error_version_unsupported = 12,
	ZSTD_error_frameParameter_unsupported = 14,
	ZSTD_error_frameParameter_windowTooLarge = 16,
	ZSTD_error_corruption_detected = 20,
	ZSTD_error_checksum_wrong = 22,
	ZSTD_error_dictionary_corrupted = 30,
	ZSTD_error_dictionary_wrong = 32,
	ZSTD_error_dictionaryCreation_failed = 34,
	ZSTD_error_parameter_unsupported = 40,
	ZSTD_error_parameter_outOfBound = 42,
	ZSTD_error_tableLog_tooLarge = 44,
	ZSTD_error_maxSymbolValue_tooLarge = 46,
	ZSTD_error_maxSymbolValue_tooSmall = 48,
	ZSTD_error_stage_wrong = 60,
	ZSTD_error_init_missing = 62,
	ZSTD_error_memory_allocation = 64,
	ZSTD_error_workSpace_tooSmall = 66,
	ZSTD_error_dstSize_tooSmall = 70,
	ZSTD_error_srcSize_wrong = 72,
	ZSTD_error_dstBuffer_null = 74,
	ZSTD_error_frameIndex_tooLarge = 100,
	ZSTD_error_seekableIO = 102,
	ZSTD_error_dstBuffer_wrong = 104,
	ZSTD_error_srcBuffer_wrong = 105,
	ZSTD_error_maxCode = 120,
} ZSTD_ErrorCode;

typedef ZSTD_DCtx ZSTD_DStream;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

typedef ZSTD_ErrorCode zstd_error_code;

typedef ZSTD_DCtx zstd_dctx;

typedef ZSTD_DStream zstd_dstream;

typedef ZSTD_outBuffer zstd_out_buffer;

typedef ZSTD_inBuffer zstd_in_buffer;

typedef ZSTD_frameHeader zstd_frame_header;

typedef ZSTD_ErrorCode ERR_enum;

struct rdists {
	struct {
		raw_spinlock_t rd_lock;
		void *rd_base;
		struct page *pend_page;
		phys_addr_t phys_base;
		u64 flags;
		cpumask_t *vpe_table_mask;
		void *vpe_l1_base;
	} *rdist;
	phys_addr_t prop_table_pa;
	void *prop_table_va;
	u64 flags;
	u32 gicd_typer;
	u32 gicd_typer2;
	int cpuhp_memreserve_state;
	bool has_vlpis;
	bool has_rvpeid;
	bool has_direct_lpi;
	bool has_vpend_valid_dirty;
};

struct gic_quirk {
	const char *desc;
	const char *compatible;
	const char *property;
	bool (*init)(void *);
	u32 iidr;
	u32 mask;
};

struct event_lpi_map {
	unsigned long *lpi_map;
	u16 *col_map;
	irq_hw_number_t lpi_base;
	int nr_lpis;
	raw_spinlock_t vlpi_lock;
	struct its_vm *vm;
	struct its_vlpi_map *vlpi_maps;
	int nr_vlpis;
};

struct its_node;

struct its_device {
	struct list_head entry;
	struct its_node *its;
	struct event_lpi_map event_map;
	void *itt;
	u32 nr_ites;
	u32 device_id;
	bool shared;
};

struct its_baser {
	void *base;
	u64 val;
	u32 order;
	u32 psz;
};

struct its_cmd_block;

struct its_collection;

struct its_node {
	raw_spinlock_t lock;
	struct mutex dev_alloc_lock;
	struct list_head entry;
	void *base;
	void *sgir_base;
	phys_addr_t phys_base;
	struct its_cmd_block *cmd_base;
	struct its_cmd_block *cmd_write;
	struct its_baser tables[8];
	struct its_collection *collections;
	struct fwnode_handle *fwnode_handle;
	u64 (*get_msi_base)(struct its_device *);
	u64 typer;
	u64 cbaser_save;
	u32 ctlr_save;
	u32 mpidr;
	struct list_head its_device_list;
	u64 flags;
	unsigned long list_nr;
	int numa_node;
	unsigned int msi_domain_flags;
	u32 pre_its_base;
	int vlpi_redist_offset;
};

struct its_cmd_block {
	union {
		u64 raw_cmd[4];
		__le64 raw_cmd_le[4];
	};
};

struct its_collection {
	u64 target_address;
	u16 col_id;
};

struct cpu_lpi_count {
	atomic_t managed;
	atomic_t unmanaged;
};

struct its_srat_map {
	u32 numa_node;
	u32 its_id;
};

enum its_vcpu_info_cmd_type {
	MAP_VLPI = 0,
	GET_VLPI = 1,
	PROP_UPDATE_VLPI = 2,
	PROP_UPDATE_AND_INV_VLPI = 3,
	SCHEDULE_VPE = 4,
	DESCHEDULE_VPE = 5,
	COMMIT_VPE = 6,
	INVALL_VPE = 7,
	PROP_UPDATE_VSGI = 8,
};

enum acpi_srat_type {
	ACPI_SRAT_TYPE_CPU_AFFINITY = 0,
	ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1,
	ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2,
	ACPI_SRAT_TYPE_GICC_AFFINITY = 3,
	ACPI_SRAT_TYPE_GIC_ITS_AFFINITY = 4,
	ACPI_SRAT_TYPE_GENERIC_AFFINITY = 5,
	ACPI_SRAT_TYPE_GENERIC_PORT_AFFINITY = 6,
	ACPI_SRAT_TYPE_RESERVED = 7,
};

struct lpi_range {
	struct list_head entry;
	u32 base_id;
	u32 span;
};

struct acpi_srat_gic_its_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u16 reserved;
	u32 its_id;
} __attribute__((packed));

struct acpi_madt_generic_translator {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 translation_id;
	u64 base_address;
	u32 reserved2;
} __attribute__((packed));

struct its_cmd_desc {
	union {
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_inv_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_clear_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_int_cmd;
		struct {
			struct its_device *dev;
			int valid;
		} its_mapd_cmd;
		struct {
			struct its_collection *col;
			int valid;
		} its_mapc_cmd;
		struct {
			struct its_device *dev;
			u32 phys_id;
			u32 event_id;
		} its_mapti_cmd;
		struct {
			struct its_device *dev;
			struct its_collection *col;
			u32 event_id;
		} its_movi_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_discard_cmd;
		struct {
			struct its_collection *col;
		} its_invall_cmd;
		struct {
			struct its_vpe *vpe;
		} its_vinvall_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_collection *col;
			bool valid;
		} its_vmapp_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_device *dev;
			u32 virt_id;
			u32 event_id;
			bool db_enabled;
		} its_vmapti_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_device *dev;
			u32 event_id;
			bool db_enabled;
		} its_vmovi_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_collection *col;
			u16 seq_num;
			u16 its_list;
		} its_vmovp_cmd;
		struct {
			struct its_vpe *vpe;
		} its_invdb_cmd;
		struct {
			struct its_vpe *vpe;
			u8 sgi;
			u8 priority;
			bool enable;
			bool group;
			bool clear;
		} its_vsgi_cmd;
	};
};

struct its_cmd_info {
	enum its_vcpu_info_cmd_type cmd_type;
	union {
		struct its_vlpi_map *map;
		u8 config;
		bool req_db;
		struct {
			bool g0en;
			bool g1en;
		};
		struct {
			u8 priority;
			bool group;
		};
	};
};

typedef struct its_collection * (*its_cmd_builder_t)(struct its_node *, struct its_cmd_block *, struct its_cmd_desc *);

typedef struct its_vpe * (*its_cmd_vbuilder_t)(struct its_node *, struct its_cmd_block *, struct its_cmd_desc *);

struct brcm_usb_init_params;

struct brcm_usb_init_ops {
	void (*init_ipp)(struct brcm_usb_init_params *);
	void (*init_common)(struct brcm_usb_init_params *);
	void (*init_eohci)(struct brcm_usb_init_params *);
	void (*init_xhci)(struct brcm_usb_init_params *);
	void (*uninit_common)(struct brcm_usb_init_params *);
	void (*uninit_eohci)(struct brcm_usb_init_params *);
	void (*uninit_xhci)(struct brcm_usb_init_params *);
	int (*get_dual_select)(struct brcm_usb_init_params *);
	void (*set_dual_select)(struct brcm_usb_init_params *);
};

struct brcm_usb_init_params {
	void *regs[6];
	int ioc;
	int ipp;
	int supported_port_modes;
	int port_mode;
	u32 family_id;
	u32 product_id;
	int selected_family;
	const char *family_name;
	const u32 *usb_reg_bits_map;
	const struct brcm_usb_init_ops *ops;
	struct regmap *syscon_piarbctl;
	bool wake_enabled;
};

enum brcmusb_reg_sel {
	BRCM_REGS_CTRL = 0,
	BRCM_REGS_XHCI_EC = 1,
	BRCM_REGS_XHCI_GBL = 2,
	BRCM_REGS_USB_PHY = 3,
	BRCM_REGS_USB_MDIO = 4,
	BRCM_REGS_BDC_EC = 5,
	BRCM_REGS_MAX = 6,
};

struct imx8mq_usb_phy {
	struct phy *phy;
	struct clk *clk;
	void *base;
	struct regulator *vbus;
	u32 pcs_tx_swing_full;
	u32 pcs_tx_deemph_3p5db;
	u32 tx_vref_tune;
	u32 tx_rise_tune;
	u32 tx_preemp_amp_tune;
	u32 tx_vboost_level;
	u32 comp_dis_tune;
};

enum rockchip_pinctrl_type {
	PX30 = 0,
	RV1108 = 1,
	RV1126 = 2,
	RK2928 = 3,
	RK3066B = 4,
	RK3128 = 5,
	RK3188 = 6,
	RK3288 = 7,
	RK3308 = 8,
	RK3368 = 9,
	RK3399 = 10,
	RK3568 = 11,
	RK3588 = 12,
};

struct rockchip_pin_bank;

struct rockchip_mux_recalced_data;

struct rockchip_mux_route_data;

struct rockchip_pin_ctrl {
	struct rockchip_pin_bank *pin_banks;
	u32 nr_banks;
	u32 nr_pins;
	char *label;
	enum rockchip_pinctrl_type type;
	int grf_mux_offset;
	int pmu_mux_offset;
	int grf_drv_offset;
	int pmu_drv_offset;
	struct rockchip_mux_recalced_data *iomux_recalced;
	u32 niomux_recalced;
	struct rockchip_mux_route_data *iomux_routes;
	u32 niomux_routes;
	int (*pull_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
	int (*drv_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
	int (*schmitt_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
};

struct rockchip_iomux {
	int type;
	int offset;
};

enum rockchip_pin_drv_type {
	DRV_TYPE_IO_DEFAULT = 0,
	DRV_TYPE_IO_1V8_OR_3V0 = 1,
	DRV_TYPE_IO_1V8_ONLY = 2,
	DRV_TYPE_IO_1V8_3V0_AUTO = 3,
	DRV_TYPE_IO_3V3_ONLY = 4,
	DRV_TYPE_MAX = 5,
};

struct rockchip_drv {
	enum rockchip_pin_drv_type drv_type;
	int offset;
};

enum rockchip_pin_pull_type {
	PULL_TYPE_IO_DEFAULT = 0,
	PULL_TYPE_IO_1V8_ONLY = 1,
	PULL_TYPE_MAX = 2,
};

struct rockchip_pinctrl;

struct rockchip_gpio_regs;

struct rockchip_pin_bank {
	struct device *dev;
	void *reg_base;
	struct regmap *regmap_pull;
	struct clk *clk;
	struct clk *db_clk;
	int irq;
	u32 saved_masks;
	u32 pin_base;
	u8 nr_pins;
	char *name;
	u8 bank_num;
	struct rockchip_iomux iomux[4];
	struct rockchip_drv drv[4];
	enum rockchip_pin_pull_type pull_type[4];
	bool valid;
	struct device_node *of_node;
	struct rockchip_pinctrl *drvdata;
	struct irq_domain *domain;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range grange;
	raw_spinlock_t slock;
	const struct rockchip_gpio_regs *gpio_regs;
	u32 gpio_type;
	u32 toggle_edge_mode;
	u32 recalced_mask;
	u32 route_mask;
	struct list_head deferred_pins;
	struct mutex deferred_lock;
};

struct rockchip_pin_group;

struct rockchip_pmx_func;

struct rockchip_pinctrl {
	struct regmap *regmap_base;
	int reg_size;
	struct regmap *regmap_pull;
	struct regmap *regmap_pmu;
	struct device *dev;
	struct rockchip_pin_ctrl *ctrl;
	struct pinctrl_desc pctl;
	struct pinctrl_dev *pctl_dev;
	struct rockchip_pin_group *groups;
	unsigned int ngroups;
	struct rockchip_pmx_func *functions;
	unsigned int nfunctions;
};

struct rockchip_pin_config;

struct rockchip_pin_group {
	const char *name;
	unsigned int npins;
	unsigned int *pins;
	struct rockchip_pin_config *data;
};

struct rockchip_pin_config {
	unsigned int func;
	unsigned long *configs;
	unsigned int nconfigs;
};

struct rockchip_pmx_func {
	const char *name;
	const char **groups;
	u8 ngroups;
};

struct rockchip_gpio_regs {
	u32 port_dr;
	u32 port_ddr;
	u32 int_en;
	u32 int_mask;
	u32 int_type;
	u32 int_polarity;
	u32 int_bothedge;
	u32 int_status;
	u32 int_rawstatus;
	u32 debounce;
	u32 dbclk_div_en;
	u32 dbclk_div_con;
	u32 port_eoi;
	u32 ext_port;
	u32 version_id;
};

struct rockchip_mux_recalced_data {
	u8 num;
	u8 pin;
	u32 reg;
	u8 bit;
	u8 mask;
};

enum rockchip_mux_route_location {
	ROCKCHIP_ROUTE_SAME = 0,
	ROCKCHIP_ROUTE_PMU = 1,
	ROCKCHIP_ROUTE_GRF = 2,
};

struct rockchip_mux_route_data {
	u8 bank_num;
	u8 pin;
	u8 func;
	enum rockchip_mux_route_location route_location;
	u32 route_offset;
	u32 route_val;
};

struct rockchip_pin_deferred {
	struct list_head head;
	unsigned int pin;
	enum pin_config_param param;
	u32 arg;
};

enum meson_reg_type {
	MESON_REG_PULLEN = 0,
	MESON_REG_PULL = 1,
	MESON_REG_DIR = 2,
	MESON_REG_OUT = 3,
	MESON_REG_IN = 4,
	MESON_REG_DS = 5,
	MESON_NUM_REG = 6,
};

enum meson_pinconf_drv {
	MESON_PINCONF_DRV_500UA = 0,
	MESON_PINCONF_DRV_2500UA = 1,
	MESON_PINCONF_DRV_3000UA = 2,
	MESON_PINCONF_DRV_4000UA = 3,
};

enum ioctrl_regs___2 {
	POCCTRL = 0,
	TDSELCTRL___2 = 1,
};

struct sh_pfc_pin_range {
	u16 start;
	u16 end;
};

enum ioctrl_regs___3 {
	POCCTRL0___2 = 0,
	POCCTRL2___2 = 1,
	TDSELCTRL___3 = 2,
};

enum {
	GP_LAST___2 = 205,
	PIN_DU_DOTCLKIN0 = 206,
	PIN_FSCLKST_N___2 = 207,
	PIN_MLB_REF = 208,
	PIN_PRESETOUT_N___2 = 209,
	PIN_TCK___2 = 210,
	PIN_TDI___2 = 211,
	PIN_TMS___2 = 212,
	PIN_TRST_N___2 = 213,
	PIN_VDDQ_AVB0___2 = 214,
};

struct stm32_desc_function {
	const char *name;
	const unsigned char num;
};

struct stm32_desc_pin {
	struct pinctrl_pin_desc pin;
	const struct stm32_desc_function functions[18];
	const unsigned int pkg;
};

struct stm32_pinctrl_group;

struct stm32_gpio_bank;

struct stm32_pinctrl_match_data;

struct stm32_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl_dev;
	struct pinctrl_desc pctl_desc;
	struct stm32_pinctrl_group *groups;
	unsigned int ngroups;
	const char **grp_names;
	struct stm32_gpio_bank *banks;
	unsigned int nbanks;
	const struct stm32_pinctrl_match_data *match_data;
	struct irq_domain *domain;
	struct regmap *regmap;
	struct regmap_field *irqmux[16];
	struct hwspinlock *hwlock;
	struct stm32_desc_pin *pins;
	u32 npins;
	u32 pkg;
	u16 irqmux_map;
	spinlock_t irqmux_lock;
};

struct stm32_pinctrl_group {
	const char *name;
	unsigned long config;
	unsigned int pin;
};

struct stm32_gpio_bank {
	void *base;
	struct clk *clk;
	struct reset_control *rstc;
	spinlock_t lock;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range range;
	struct fwnode_handle *fwnode;
	struct irq_domain *domain;
	u32 bank_nr;
	u32 bank_ioport_nr;
	u32 pin_backup[16];
	u8 irq_type[16];
	bool secure_control;
};

struct stm32_pinctrl_match_data {
	const struct stm32_desc_pin *pins;
	const unsigned int npins;
	bool secure_control;
};

enum gpio_v2_line_flag {
	GPIO_V2_LINE_FLAG_USED = 1,
	GPIO_V2_LINE_FLAG_ACTIVE_LOW = 2,
	GPIO_V2_LINE_FLAG_INPUT = 4,
	GPIO_V2_LINE_FLAG_OUTPUT = 8,
	GPIO_V2_LINE_FLAG_EDGE_RISING = 16,
	GPIO_V2_LINE_FLAG_EDGE_FALLING = 32,
	GPIO_V2_LINE_FLAG_OPEN_DRAIN = 64,
	GPIO_V2_LINE_FLAG_OPEN_SOURCE = 128,
	GPIO_V2_LINE_FLAG_BIAS_PULL_UP = 256,
	GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN = 512,
	GPIO_V2_LINE_FLAG_BIAS_DISABLED = 1024,
	GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME = 2048,
	GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE = 4096,
};

enum gpio_v2_line_changed_type {
	GPIO_V2_LINE_CHANGED_REQUESTED = 1,
	GPIO_V2_LINE_CHANGED_RELEASED = 2,
	GPIO_V2_LINE_CHANGED_CONFIG = 3,
};

enum gpio_v2_line_attr_id {
	GPIO_V2_LINE_ATTR_ID_FLAGS = 1,
	GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES = 2,
	GPIO_V2_LINE_ATTR_ID_DEBOUNCE = 3,
};

enum gpio_v2_line_event_id {
	GPIO_V2_LINE_EVENT_RISING_EDGE = 1,
	GPIO_V2_LINE_EVENT_FALLING_EDGE = 2,
};

enum hte_edge {
	HTE_EDGE_NO_SETUP = 1,
	HTE_RISING_EDGE_TS = 2,
	HTE_FALLING_EDGE_TS = 4,
};

enum hte_return {
	HTE_CB_HANDLED = 0,
	HTE_RUN_SECOND_CB = 1,
};

struct gpioevent_data {
	__u64 timestamp;
	__u32 id;
};

struct lineevent_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *desc;
	u32 eflags;
	int irq;
	wait_queue_head_t wait;
	struct notifier_block device_unregistered_nb;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpioevent_data *type;
			const struct gpioevent_data *const_type;
			char (*rectype)[0];
			struct gpioevent_data *ptr;
			const struct gpioevent_data *ptr_const;
		};
		struct gpioevent_data buf[16];
	} events;
	u64 timestamp;
};

struct linereq;

struct line {
	struct gpio_desc *desc;
	struct linereq *req;
	unsigned int irq;
	u64 edflags;
	u64 timestamp_ns;
	u32 req_seqno;
	u32 line_seqno;
	struct delayed_work work;
	unsigned int sw_debounced;
	unsigned int level;
	struct hte_ts_desc hdesc;
	int raw_level;
	u32 total_discard_seq;
	u32 last_seqno;
};

struct gpio_v2_line_event {
	__u64 timestamp_ns;
	__u32 id;
	__u32 offset;
	__u32 seqno;
	__u32 line_seqno;
	__u32 padding[6];
};

struct linereq {
	struct gpio_device *gdev;
	const char *label;
	u32 num_lines;
	wait_queue_head_t wait;
	struct notifier_block device_unregistered_nb;
	u32 event_buffer_size;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_event *type;
			const struct gpio_v2_line_event *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_event *ptr;
			const struct gpio_v2_line_event *ptr_const;
		};
		struct gpio_v2_line_event buf[0];
	} events;
	atomic_t seqno;
	struct mutex config_mutex;
	struct line lines[0];
};

struct gpio_v2_line_attribute {
	__u32 id;
	__u32 padding;
	union {
		__u64 flags;
		__u64 values;
		__u32 debounce_period_us;
	};
};

struct gpio_v2_line_info {
	char name[32];
	char consumer[32];
	__u32 offset;
	__u32 num_attrs;
	__u64 flags;
	struct gpio_v2_line_attribute attrs[10];
	__u32 padding[4];
};

struct gpio_v2_line_info_changed {
	struct gpio_v2_line_info info;
	__u64 timestamp_ns;
	__u32 event_type;
	__u32 padding[5];
};

struct gpio_chardev_data {
	struct gpio_device *gdev;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_info_changed *type;
			const struct gpio_v2_line_info_changed *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_info_changed *ptr;
			const struct gpio_v2_line_info_changed *ptr_const;
		};
		struct gpio_v2_line_info_changed buf[32];
	} events;
	struct notifier_block lineinfo_changed_nb;
	struct notifier_block device_unregistered_nb;
	unsigned long *watched_lines;
	atomic_t watch_abi_version;
};

typedef ssize_t (*read_fn)(struct file *, char __attribute__((btf_type_tag("user"))) *, size_t, loff_t *);

struct gpioline_info {
	__u32 line_offset;
	__u32 flags;
	char name[32];
	char consumer[32];
};

struct gpioline_info_changed {
	struct gpioline_info info;
	__u64 timestamp;
	__u32 event_type;
	__u32 padding[5];
};

typedef __poll_t (*poll_fn)(struct file *, struct poll_table_struct *);

typedef long (*ioctl_fn)(struct file *, unsigned int, unsigned long);

struct gpio_v2_line_config_attribute {
	struct gpio_v2_line_attribute attr;
	__u64 mask;
};

struct gpio_v2_line_config {
	__u64 flags;
	__u32 num_attrs;
	__u32 padding[5];
	struct gpio_v2_line_config_attribute attrs[10];
};

struct gpio_v2_line_request {
	__u32 offsets[64];
	char consumer[32];
	struct gpio_v2_line_config config;
	__u32 num_lines;
	__u32 event_buffer_size;
	__u32 padding[5];
	__s32 fd;
};

struct gpiochip_info {
	char name[32];
	char label[32];
	__u32 lines;
};

struct gpioevent_request {
	__u32 lineoffset;
	__u32 handleflags;
	__u32 eventflags;
	char consumer_label[32];
	int fd;
};

struct gpiohandle_request {
	__u32 lineoffsets[64];
	__u32 flags;
	__u8 default_values[64];
	char consumer_label[32];
	__u32 lines;
	int fd;
};

struct linehandle_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *descs[64];
	u32 num_descs;
};

struct gpiohandle_data {
	__u8 values[64];
};

struct gpiohandle_config {
	__u32 flags;
	__u8 default_values[64];
	__u32 padding[4];
};

typedef enum hte_return (*hte_ts_cb_t)(struct hte_ts_data *, void *);

typedef enum hte_return (*hte_ts_sec_cb_t)(void *);

struct gpio_v2_line_values {
	__u64 bits;
	__u64 mask;
};

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

struct pci_reset_fn_method {
	int (*reset_fn)(struct pci_dev *, bool);
	char *name;
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct pci_devres {
	unsigned int enabled: 1;
	unsigned int pinned: 1;
	unsigned int orig_intx: 1;
	unsigned int restore_intx: 1;
	unsigned int mwi: 1;
	u32 region_mask;
};

struct linux_logo {
	int type;
	unsigned int width;
	unsigned int height;
	unsigned int clutsize;
	const unsigned char *clut;
	const unsigned char *data;
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

typedef u32 compat_caddr_t;

struct fb_cmap32 {
	u32 start;
	u32 len;
	compat_caddr_t red;
	compat_caddr_t green;
	compat_caddr_t blue;
	compat_caddr_t transp;
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 __attribute__((btf_type_tag("user"))) *red;
	__u16 __attribute__((btf_type_tag("user"))) *green;
	__u16 __attribute__((btf_type_tag("user"))) *blue;
	__u16 __attribute__((btf_type_tag("user"))) *transp;
};

struct fb_fix_screeninfo32 {
	char id[16];
	compat_caddr_t smem_start;
	u32 smem_len;
	u32 type;
	u32 type_aux;
	u32 visual;
	u16 xpanstep;
	u16 ypanstep;
	u16 ywrapstep;
	u32 line_length;
	compat_caddr_t mmio_start;
	u32 mmio_len;
	u32 accel;
	u16 reserved[3];
};

struct pci_osc_bit_struct {
	u32 bit;
	char *desc;
};

enum acpi_bridge_type {
	ACPI_BRIDGE_TYPE_PCIE = 1,
	ACPI_BRIDGE_TYPE_CXL = 2,
};

struct acpi_device_physical_node {
	unsigned int node_id;
	struct list_head node;
	struct device *dev;
	bool put_online: 1;
};

struct acpi_pci_root_ops;

struct acpi_pci_root_info {
	struct acpi_pci_root *root;
	struct acpi_device *bridge;
	struct acpi_pci_root_ops *ops;
	struct list_head resources;
	char name[16];
};

struct acpi_pci_root_ops {
	struct pci_ops *pci_ops;
	int (*init_info)(struct acpi_pci_root_info *);
	void (*release_info)(struct acpi_pci_root_info *);
	int (*prepare_resources)(struct acpi_pci_root_info *);
};

struct acpi_osc_context {
	char *uuid_str;
	int rev;
	struct acpi_buffer cap;
	struct acpi_buffer ret;
};

struct acpi_device_walk_info {
	struct acpi_table_desc *table_desc;
	struct acpi_evaluate_info *evaluate_info;
	u32 device_count;
	u32 num_STA;
	u32 num_INI;
};

typedef acpi_status (*acpi_pkg_callback)(u8, union acpi_operand_object *, union acpi_generic_state *, void *);

enum {
	ACPI_RSC_INITGET = 0,
	ACPI_RSC_INITSET = 1,
	ACPI_RSC_FLAGINIT = 2,
	ACPI_RSC_1BITFLAG = 3,
	ACPI_RSC_2BITFLAG = 4,
	ACPI_RSC_3BITFLAG = 5,
	ACPI_RSC_6BITFLAG = 6,
	ACPI_RSC_ADDRESS = 7,
	ACPI_RSC_BITMASK = 8,
	ACPI_RSC_BITMASK16 = 9,
	ACPI_RSC_COUNT = 10,
	ACPI_RSC_COUNT16 = 11,
	ACPI_RSC_COUNT_GPIO_PIN = 12,
	ACPI_RSC_COUNT_GPIO_RES = 13,
	ACPI_RSC_COUNT_GPIO_VEN = 14,
	ACPI_RSC_COUNT_SERIAL_RES = 15,
	ACPI_RSC_COUNT_SERIAL_VEN = 16,
	ACPI_RSC_DATA8 = 17,
	ACPI_RSC_EXIT_EQ = 18,
	ACPI_RSC_EXIT_LE = 19,
	ACPI_RSC_EXIT_NE = 20,
	ACPI_RSC_LENGTH = 21,
	ACPI_RSC_MOVE_GPIO_PIN = 22,
	ACPI_RSC_MOVE_GPIO_RES = 23,
	ACPI_RSC_MOVE_SERIAL_RES = 24,
	ACPI_RSC_MOVE_SERIAL_VEN = 25,
	ACPI_RSC_MOVE8 = 26,
	ACPI_RSC_MOVE16 = 27,
	ACPI_RSC_MOVE32 = 28,
	ACPI_RSC_MOVE64 = 29,
	ACPI_RSC_SET8 = 30,
	ACPI_RSC_SOURCE = 31,
	ACPI_RSC_SOURCEX = 32,
};

typedef u16 acpi_rs_length;

typedef u32 acpi_rsdesc_size;

struct acpi_power_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_lpi_states_array {
	unsigned int size;
	unsigned int composite_states_size;
	struct acpi_lpi_state *entries;
	struct acpi_lpi_state *composite_states[8];
};

struct tegra_ahb {
	void *regs;
	struct device *dev;
	u32 ctx[0];
};

struct clk_pwm {
	struct clk_hw hw;
	struct pwm_device *pwm;
	u32 fixed_rate;
};

struct clk_fractional_divider {
	struct clk_hw hw;
	void *reg;
	u8 mshift;
	u8 mwidth;
	u8 nshift;
	u8 nwidth;
	u8 flags;
	void (*approximation)(struct clk_hw *, unsigned long, unsigned long *, unsigned long *, unsigned long *);
	spinlock_t *lock;
};

struct imx93_clk_gate {
	struct clk_hw hw;
	void *reg;
	u32 bit_idx;
	u32 val;
	u32 mask;
	spinlock_t *lock;
	unsigned int *share_count;
};

struct clk_pll14xx {
	struct clk_hw hw;
	void *base;
	enum imx_pll14xx_type type;
	const struct imx_pll14xx_rate_table *rate_table;
	int rate_count;
};

struct imx8qxp_lpcg_data;

struct imx8qxp_ss_lpcg {
	const struct imx8qxp_lpcg_data *lpcg;
	u8 num_lpcg;
	u8 num_max;
};

struct imx8qxp_lpcg_data {
	int id;
	char *name;
	char *parent;
	unsigned long flags;
	u32 offset;
	u8 bit_idx;
	bool hw_gate;
};

struct clk_rpmh_desc {
	struct clk_hw **clks;
	size_t num_clks;
};

struct clk_rpmh {
	struct clk_hw hw;
	const char *res_name;
	u8 div;
	u32 res_addr;
	u32 res_on_val;
	u32 state;
	u32 aggr_state;
	u32 last_sent_aggr_state;
	u32 valid_state_mask;
	u32 unit;
	struct device *dev;
	struct clk_rpmh *peer;
};

struct cpg_mssr_priv {
	struct reset_controller_dev rcdev;
	struct device *dev;
	void *base;
	enum clk_reg_layout reg_layout;
	spinlock_t rmw_lock;
	struct device_node *np;
	unsigned int num_core_clks;
	unsigned int num_mod_clks;
	unsigned int last_dt_core_clk;
	struct raw_notifier_head notifiers;
	const u16 *status_regs;
	const u16 *control_regs;
	const u16 *reset_regs;
	const u16 *reset_clear_regs;
	struct {
		u32 mask;
		u32 val;
	} smstpcr_saved[30];
	struct clk *clks[0];
};

struct cpg_mssr_clk_domain {
	struct generic_pm_domain genpd;
	unsigned int num_core_pm_clks;
	unsigned int core_pm_clks[0];
};

enum clk_types {
	CLK_TYPE_IN = 0,
	CLK_TYPE_FF = 1,
	CLK_TYPE_DIV6P1 = 2,
	CLK_TYPE_DIV6_RO = 3,
	CLK_TYPE_FR = 4,
	CLK_TYPE_CUSTOM = 5,
};

struct mstp_clock {
	struct clk_hw hw;
	u32 index;
	struct cpg_mssr_priv *priv;
};

enum {
	PLL_LOCK_DONE = 0,
	PLL_DIV_S = 1,
	PLL_MOD_EN = 2,
	PLL_SDM_EN = 3,
	PLL_REFIN = 4,
	PLL_IBIAS = 5,
	PLL_N = 6,
	PLL_NINT = 7,
	PLL_KINT = 8,
	PLL_PREDIV = 9,
	PLL_POSTDIV = 10,
	PLL_FACT_MAX = 11,
};

struct clk_bit_field;

struct sprd_pll {
	u32 regs_num;
	const u64 *itable;
	const struct clk_bit_field *factors;
	u16 udelay;
	u16 k1;
	u16 k2;
	u16 fflag;
	u64 fvco;
	struct sprd_clk_common common;
};

struct clk_bit_field {
	u8 shift;
	u8 width;
};

struct reg_cfg {
	u32 val;
	u32 msk;
};

struct tegra_sdmmc_mux {
	struct clk_hw hw;
	void *reg;
	spinlock_t *lock;
	const struct clk_ops *gate_ops;
	struct tegra_clk_periph_gate gate;
	u8 div_flags;
};

enum tegra_super_gen {
	gen4 = 4,
	gen5 = 5,
};

struct tegra_super_gen_info {
	enum tegra_super_gen gen;
	const char **sclk_parents;
	const char **cclk_g_parents;
	const char **cclk_lp_parents;
	int num_sclk_parents;
	int num_cclk_g_parents;
	int num_cclk_lp_parents;
};

enum {
	CMD_CLK_GET_RATE = 1,
	CMD_CLK_SET_RATE = 2,
	CMD_CLK_ROUND_RATE = 3,
	CMD_CLK_GET_PARENT = 4,
	CMD_CLK_SET_PARENT = 5,
	CMD_CLK_IS_ENABLED = 6,
	CMD_CLK_ENABLE = 7,
	CMD_CLK_DISABLE = 8,
	CMD_CLK_PROPERTIES = 9,
	CMD_CLK_POSSIBLE_PARENTS = 10,
	CMD_CLK_NUM_POSSIBLE_PARENTS = 11,
	CMD_CLK_GET_POSSIBLE_PARENT = 12,
	CMD_CLK_RESET_REFCOUNTS = 13,
	CMD_CLK_GET_ALL_INFO = 14,
	CMD_CLK_GET_MAX_CLK_ID = 15,
	CMD_CLK_GET_FMAX_AT_VMIN = 16,
	CMD_CLK_MAX = 17,
};

struct tegra_bpmp_clk {
	struct clk_hw hw;
	struct tegra_bpmp *bpmp;
	unsigned int id;
	unsigned int num_parents;
	unsigned int *parents;
};

struct tegra_bpmp_clk_message {
	unsigned int cmd;
	unsigned int id;
	struct {
		const void *data;
		size_t size;
	} tx;
	struct {
		void *data;
		size_t size;
		int ret;
	} rx;
};

struct cmd_clk_get_rate_request {};

typedef s64 int64_t;

struct cmd_clk_set_rate_request {
	int32_t unused;
	int64_t rate;
} __attribute__((packed));

struct cmd_clk_round_rate_request {
	int32_t unused;
	int64_t rate;
} __attribute__((packed));

struct cmd_clk_get_parent_request {};

struct cmd_clk_set_parent_request {
	uint32_t parent_id;
};

struct cmd_clk_enable_request {};

struct cmd_clk_disable_request {};

struct cmd_clk_is_enabled_request {};

struct cmd_clk_properties_request {};

struct cmd_clk_possible_parents_request {};

struct cmd_clk_num_possible_parents_request {};

struct cmd_clk_get_possible_parent_request {
	uint8_t parent_idx;
};

struct cmd_clk_get_all_info_request {};

struct cmd_clk_get_max_clk_id_request {};

struct cmd_clk_get_fmax_at_vmin_request {};

struct mrq_clk_request {
	uint32_t cmd_and_id;
	union {
		struct cmd_clk_get_rate_request clk_get_rate;
		struct cmd_clk_set_rate_request clk_set_rate;
		struct cmd_clk_round_rate_request clk_round_rate;
		struct cmd_clk_get_parent_request clk_get_parent;
		struct cmd_clk_set_parent_request clk_set_parent;
		struct cmd_clk_enable_request clk_enable;
		struct cmd_clk_disable_request clk_disable;
		struct cmd_clk_is_enabled_request clk_is_enabled;
		struct cmd_clk_properties_request clk_properties;
		struct cmd_clk_possible_parents_request clk_possible_parents;
		struct cmd_clk_num_possible_parents_request clk_num_possible_parents;
		struct cmd_clk_get_possible_parent_request clk_get_possible_parent;
		struct cmd_clk_get_all_info_request clk_get_all_info;
		struct cmd_clk_get_max_clk_id_request clk_get_max_clk_id;
		struct cmd_clk_get_fmax_at_vmin_request clk_get_fmax_at_vmin;
	};
};

struct tegra_bpmp_message {
	unsigned int mrq;
	struct {
		const void *data;
		size_t size;
	} tx;
	struct {
		void *data;
		size_t size;
		int ret;
	} rx;
	unsigned long flags;
};

struct cmd_clk_get_max_clk_id_response {
	uint32_t max_id;
};

struct tegra_bpmp_clk_info {
	unsigned int id;
	char name[40];
	unsigned int parents[16];
	unsigned int num_parents;
	unsigned long flags;
};

struct cmd_clk_get_all_info_response {
	uint32_t flags;
	uint32_t parent;
	uint32_t parents[16];
	uint8_t num_parents;
	uint8_t name[40];
} __attribute__((packed));

struct cmd_clk_get_rate_response {
	int64_t rate;
};

struct cmd_clk_get_parent_response {
	uint32_t parent_id;
};

struct cmd_clk_is_enabled_response {
	int32_t state;
};

struct cmd_clk_round_rate_response {
	int64_t rate;
};

struct cmd_clk_set_parent_response {
	uint32_t parent_id;
};

struct cmd_clk_set_rate_response {
	int64_t rate;
};

struct mv_xor_v2_descriptor;

struct mv_xor_v2_sw_desc;

struct mv_xor_v2_device {
	spinlock_t lock;
	void *dma_base;
	void *glob_base;
	struct clk *clk;
	struct clk *reg_clk;
	struct tasklet_struct irq_tasklet;
	struct list_head free_sw_desc;
	struct dma_device dmadev;
	struct dma_chan dmachan;
	dma_addr_t hw_desq;
	struct mv_xor_v2_descriptor *hw_desq_virt;
	struct mv_xor_v2_sw_desc *sw_desq;
	int desc_size;
	unsigned int npendings;
	unsigned int hw_queue_idx;
	unsigned int irq;
};

struct mv_xor_v2_descriptor {
	u16 desc_id;
	u16 flags;
	u32 crc32_result;
	u32 desc_ctrl;
	u32 buff_size;
	u32 fill_pattern_src_addr[4];
	u32 data_buff_addr[12];
	u32 reserved[12];
};

struct mv_xor_v2_sw_desc {
	int idx;
	struct dma_async_tx_descriptor async_tx;
	struct mv_xor_v2_descriptor hw_desc;
	struct list_head free_list;
};

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

struct meson_msr;

struct meson_msr_id {
	struct meson_msr *priv;
	unsigned int id;
	const char *name;
};

struct meson_msr {
	struct regmap *regmap;
	struct meson_msr_id msr_table[128];
};

struct k3_ring;

struct k3_ring_ops {
	int (*push_tail)(struct k3_ring *, void *);
	int (*push_head)(struct k3_ring *, void *);
	int (*pop_tail)(struct k3_ring *, void *);
	int (*pop_head)(struct k3_ring *, void *);
};

enum k3_ring_size {
	K3_RINGACC_RING_ELSIZE_4 = 0,
	K3_RINGACC_RING_ELSIZE_8 = 1,
	K3_RINGACC_RING_ELSIZE_16 = 2,
	K3_RINGACC_RING_ELSIZE_32 = 3,
	K3_RINGACC_RING_ELSIZE_64 = 4,
	K3_RINGACC_RING_ELSIZE_128 = 5,
	K3_RINGACC_RING_ELSIZE_256 = 6,
	K3_RINGACC_RING_ELSIZE_INVALID = 7,
};

enum k3_ring_mode {
	K3_RINGACC_RING_MODE_RING = 0,
	K3_RINGACC_RING_MODE_MESSAGE = 1,
	K3_RINGACC_RING_MODE_CREDENTIALS = 2,
	K3_RINGACC_RING_MODE_INVALID = 3,
};

struct k3_ring_state {
	u32 free;
	u32 occ;
	u32 windex;
	u32 rindex;
	u32 tdown_complete: 1;
};

struct k3_ring_rt_regs;

struct k3_ring_fifo_regs;

struct k3_ringacc_proxy_target_regs;

struct k3_ringacc;

struct k3_ring {
	struct k3_ring_rt_regs *rt;
	struct k3_ring_fifo_regs *fifos;
	struct k3_ringacc_proxy_target_regs *proxy;
	dma_addr_t ring_mem_dma;
	void *ring_mem_virt;
	struct k3_ring_ops *ops;
	u32 size;
	enum k3_ring_size elm_size;
	enum k3_ring_mode mode;
	u32 flags;
	struct k3_ring_state state;
	u32 ring_id;
	struct k3_ringacc *parent;
	u32 use_count;
	int proxy_id;
	struct device *dma_dev;
	u32 asel;
};

struct k3_ring_rt_regs {
	u32 resv_16[4];
	u32 db;
	u32 resv_4[1];
	u32 occ;
	u32 indx;
	u32 hwocc;
	u32 hwindx;
};

struct k3_ring_fifo_regs {
	u32 head_data[128];
	u32 tail_data[128];
	u32 peek_head_data[128];
	u32 peek_tail_data[128];
};

struct k3_ringacc_proxy_target_regs {
	u32 control;
	u32 status;
	u8 resv_512[504];
	u32 data[128];
};

struct k3_ringacc_proxy_gcfg_regs;

struct k3_ringacc_ops;

struct k3_ringacc {
	struct device *dev;
	struct k3_ringacc_proxy_gcfg_regs *proxy_gcfg;
	void *proxy_target_base;
	u32 num_rings;
	unsigned long *rings_inuse;
	struct ti_sci_resource *rm_gp_range;
	bool dma_ring_reset_quirk;
	u32 num_proxies;
	unsigned long *proxy_inuse;
	struct k3_ring *rings;
	struct list_head list;
	struct mutex req_lock;
	const struct ti_sci_handle *tisci;
	const struct ti_sci_rm_ringacc_ops *tisci_ring_ops;
	u32 tisci_dev_id;
	const struct k3_ringacc_ops *ops;
	bool dma_rings;
};

struct k3_ringacc_proxy_gcfg_regs {
	u32 revision;
	u32 config;
};

struct k3_ringacc_ops {
	int (*init)(struct platform_device *, struct k3_ringacc *);
};

struct ringacc_match_data {
	struct k3_ringacc_ops ops;
};

struct k3_ringacc_soc_data {
	unsigned int dma_ring_reset_quirk: 1;
};

enum k3_ringacc_access_mode {
	K3_RINGACC_ACCESS_MODE_PUSH_HEAD = 0,
	K3_RINGACC_ACCESS_MODE_POP_HEAD = 1,
	K3_RINGACC_ACCESS_MODE_PUSH_TAIL = 2,
	K3_RINGACC_ACCESS_MODE_POP_TAIL = 3,
	K3_RINGACC_ACCESS_MODE_PEEK_HEAD = 4,
	K3_RINGACC_ACCESS_MODE_PEEK_TAIL = 5,
};

enum k3_ringacc_proxy_access_mode {
	PROXY_ACCESS_MODE_HEAD = 0,
	PROXY_ACCESS_MODE_TAIL = 1,
	PROXY_ACCESS_MODE_PEEK_HEAD = 2,
	PROXY_ACCESS_MODE_PEEK_TAIL = 3,
};

struct k3_ring_cfg {
	u32 size;
	enum k3_ring_size elm_size;
	enum k3_ring_mode mode;
	u32 flags;
	struct device *dma_dev;
	u32 asel;
};

struct k3_ringacc_init_data {
	const struct ti_sci_handle *tisci;
	u32 tisci_dev_id;
	u32 num_rings;
};

struct rpmpd;

struct rpmpd_desc {
	struct rpmpd **rpmpds;
	size_t num_pds;
	unsigned int max_state;
};

struct rpmpd {
	struct generic_pm_domain pd;
	struct generic_pm_domain *parent;
	struct rpmpd *peer;
	const bool active_only;
	unsigned int corner;
	bool enabled;
	const int res_type;
	const int res_id;
	struct qcom_smd_rpm *rpm;
	unsigned int max_state;
	__le32 key;
	bool state_synced;
};

struct rpmpd_req {
	__le32 key;
	__le32 nbytes;
	__le32 value;
};

struct balloon_stats {
	unsigned long current_pages;
	unsigned long target_pages;
	unsigned long target_unpopulated;
	unsigned long balloon_low;
	unsigned long balloon_high;
	unsigned long total_pages;
	unsigned long schedule_delay;
	unsigned long max_schedule_delay;
	unsigned long retry_count;
	unsigned long max_retry_count;
};

enum bp_state {
	BP_DONE = 0,
	BP_WAIT = 1,
	BP_EAGAIN = 2,
	BP_ECANCELED = 3,
};

typedef int mhp_t;

typedef void (*online_page_callback_t)(struct page *, unsigned int);

enum regulator_get_type {
	NORMAL_GET = 0,
	EXCLUSIVE_GET = 1,
	OPTIONAL_GET = 2,
	MAX_GET_TYPE = 3,
};

struct regulator_voltage {
	int min_uV;
	int max_uV;
};

struct regulator {
	struct device *dev;
	struct list_head list;
	unsigned int always_on: 1;
	unsigned int bypass: 1;
	unsigned int device_link: 1;
	int uA_load;
	unsigned int enable_count;
	unsigned int deferred_disables;
	struct regulator_voltage voltage[5];
	const char *supply_name;
	struct device_attribute dev_attr;
	struct regulator_dev *rdev;
	struct dentry *debugfs;
};

struct regulator_bulk_devres {
	struct regulator_bulk_data *consumers;
	int num_consumers;
};

struct regulator_supply_alias_match {
	struct device *dev;
	const char *id;
};

struct regulator_irq_data;

struct regulator_irq_desc {
	const char *name;
	int fatal_cnt;
	int reread_ms;
	int irq_off_ms;
	bool skip_off;
	bool high_prio;
	void *data;
	int (*die)(struct regulator_irq_data *);
	int (*map_event)(int, struct regulator_irq_data *, unsigned long *);
	int (*renable)(struct regulator_irq_data *);
};

struct regulator_err_state;

struct regulator_irq_data {
	struct regulator_err_state *states;
	int num_states;
	void *data;
	long opaque;
};

struct regulator_err_state {
	struct regulator_dev *rdev;
	unsigned long notifs;
	unsigned long errors;
	int possible_errs;
};

struct regulator_notifier_match {
	struct regulator *regulator;
	struct notifier_block *nb;
};

enum hi6220_reset_ctrl_type {
	PERIPHERAL = 0,
	MEDIA = 1,
	AO = 2,
};

struct hi6220_reset_data {
	struct reset_controller_dev rc_dev;
	struct regmap *regmap;
};

struct uniphier_glue_reset_soc_data {
	int nclks;
	const char * const *clock_names;
	int nrsts;
	const char * const *reset_names;
};

struct reset_simple_data {
	spinlock_t lock;
	void *membase;
	struct reset_controller_dev rcdev;
	bool active_low;
	bool status_active_low;
	unsigned int reset_us;
};

struct uniphier_glue_reset_priv {
	struct clk_bulk_data clk[2];
	struct reset_control_bulk_data rst[2];
	struct reset_simple_data rdata;
	const struct uniphier_glue_reset_soc_data *data;
};

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct interval {
	uint32_t first;
	uint32_t last;
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
	ESapc = 13,
	ESpm = 14,
	ESdcs = 15,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

struct tiocl_selection {
	unsigned short xs;
	unsigned short ys;
	unsigned short xe;
	unsigned short ye;
	unsigned short sel_mode;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char __attribute__((btf_type_tag("user"))) *data;
};

struct vc_draw_region {
	unsigned long from;
	unsigned long to;
	int x;
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

struct serial_private;

struct pciserial_board;

struct pci_serial_quirk {
	u32 vendor;
	u32 device;
	u32 subvendor;
	u32 subdevice;
	int (*probe)(struct pci_dev *);
	int (*init)(struct pci_dev *);
	int (*setup)(struct serial_private *, const struct pciserial_board *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct serial_private {
	struct pci_dev *dev;
	unsigned int nr;
	struct pci_serial_quirk *quirk;
	const struct pciserial_board *board;
	int line[0];
};

struct pciserial_board {
	unsigned int flags;
	unsigned int num_ports;
	unsigned int base_baud;
	unsigned int uart_offset;
	unsigned int reg_shift;
	unsigned int first_offset;
};

struct timedia_struct {
	int num;
	const unsigned short *ids;
};

enum pci_board_num_t {
	pbn_default = 0,
	pbn_b0_1_115200 = 1,
	pbn_b0_2_115200 = 2,
	pbn_b0_4_115200 = 3,
	pbn_b0_5_115200 = 4,
	pbn_b0_8_115200 = 5,
	pbn_b0_1_921600 = 6,
	pbn_b0_2_921600 = 7,
	pbn_b0_4_921600 = 8,
	pbn_b0_2_1130000 = 9,
	pbn_b0_4_1152000 = 10,
	pbn_b0_4_1250000 = 11,
	pbn_b0_2_1843200 = 12,
	pbn_b0_4_1843200 = 13,
	pbn_b0_1_15625000 = 14,
	pbn_b0_bt_1_115200 = 15,
	pbn_b0_bt_2_115200 = 16,
	pbn_b0_bt_4_115200 = 17,
	pbn_b0_bt_8_115200 = 18,
	pbn_b0_bt_1_460800 = 19,
	pbn_b0_bt_2_460800 = 20,
	pbn_b0_bt_4_460800 = 21,
	pbn_b0_bt_1_921600 = 22,
	pbn_b0_bt_2_921600 = 23,
	pbn_b0_bt_4_921600 = 24,
	pbn_b0_bt_8_921600 = 25,
	pbn_b1_1_115200 = 26,
	pbn_b1_2_115200 = 27,
	pbn_b1_4_115200 = 28,
	pbn_b1_8_115200 = 29,
	pbn_b1_16_115200 = 30,
	pbn_b1_1_921600 = 31,
	pbn_b1_2_921600 = 32,
	pbn_b1_4_921600 = 33,
	pbn_b1_8_921600 = 34,
	pbn_b1_2_1250000 = 35,
	pbn_b1_bt_1_115200 = 36,
	pbn_b1_bt_2_115200 = 37,
	pbn_b1_bt_4_115200 = 38,
	pbn_b1_bt_2_921600 = 39,
	pbn_b1_1_1382400 = 40,
	pbn_b1_2_1382400 = 41,
	pbn_b1_4_1382400 = 42,
	pbn_b1_8_1382400 = 43,
	pbn_b2_1_115200 = 44,
	pbn_b2_2_115200 = 45,
	pbn_b2_4_115200 = 46,
	pbn_b2_8_115200 = 47,
	pbn_b2_1_460800 = 48,
	pbn_b2_4_460800 = 49,
	pbn_b2_8_460800 = 50,
	pbn_b2_16_460800 = 51,
	pbn_b2_1_921600 = 52,
	pbn_b2_4_921600 = 53,
	pbn_b2_8_921600 = 54,
	pbn_b2_8_1152000 = 55,
	pbn_b2_bt_1_115200 = 56,
	pbn_b2_bt_2_115200 = 57,
	pbn_b2_bt_4_115200 = 58,
	pbn_b2_bt_2_921600 = 59,
	pbn_b2_bt_4_921600 = 60,
	pbn_b3_2_115200 = 61,
	pbn_b3_4_115200 = 62,
	pbn_b3_8_115200 = 63,
	pbn_b4_bt_2_921600 = 64,
	pbn_b4_bt_4_921600 = 65,
	pbn_b4_bt_8_921600 = 66,
	pbn_panacom = 67,
	pbn_panacom2 = 68,
	pbn_panacom4 = 69,
	pbn_plx_romulus = 70,
	pbn_oxsemi = 71,
	pbn_oxsemi_1_15625000 = 72,
	pbn_oxsemi_2_15625000 = 73,
	pbn_oxsemi_4_15625000 = 74,
	pbn_oxsemi_8_15625000 = 75,
	pbn_intel_i960 = 76,
	pbn_sgi_ioc3 = 77,
	pbn_computone_4 = 78,
	pbn_computone_6 = 79,
	pbn_computone_8 = 80,
	pbn_sbsxrsio = 81,
	pbn_pasemi_1682M = 82,
	pbn_ni8430_2 = 83,
	pbn_ni8430_4 = 84,
	pbn_ni8430_8 = 85,
	pbn_ni8430_16 = 86,
	pbn_ADDIDATA_PCIe_1_3906250 = 87,
	pbn_ADDIDATA_PCIe_2_3906250 = 88,
	pbn_ADDIDATA_PCIe_4_3906250 = 89,
	pbn_ADDIDATA_PCIe_8_3906250 = 90,
	pbn_ce4100_1_115200 = 91,
	pbn_omegapci = 92,
	pbn_NETMOS9900_2s_115200 = 93,
	pbn_brcm_trumanage = 94,
	pbn_fintek_4 = 95,
	pbn_fintek_8 = 96,
	pbn_fintek_12 = 97,
	pbn_fintek_F81504A = 98,
	pbn_fintek_F81508A = 99,
	pbn_fintek_F81512A = 100,
	pbn_wch382_2 = 101,
	pbn_wch384_4 = 102,
	pbn_wch384_8 = 103,
	pbn_sunix_pci_1s = 104,
	pbn_sunix_pci_2s = 105,
	pbn_sunix_pci_4s = 106,
	pbn_sunix_pci_8s = 107,
	pbn_sunix_pci_16s = 108,
	pbn_titan_1_4000000 = 109,
	pbn_titan_2_4000000 = 110,
	pbn_titan_4_4000000 = 111,
	pbn_titan_8_4000000 = 112,
	pbn_moxa_2 = 113,
	pbn_moxa_4 = 114,
	pbn_moxa_8 = 115,
};

struct f815xxa_data {
	spinlock_t lock;
	int idx;
};

struct arm_smmu_device;

struct arm_smmu_domain;

struct arm_smmu_impl {
	u32 (*read_reg)(struct arm_smmu_device *, int, int);
	void (*write_reg)(struct arm_smmu_device *, int, int, u32);
	u64 (*read_reg64)(struct arm_smmu_device *, int, int);
	void (*write_reg64)(struct arm_smmu_device *, int, int, u64);
	int (*cfg_probe)(struct arm_smmu_device *);
	int (*reset)(struct arm_smmu_device *);
	int (*init_context)(struct arm_smmu_domain *, struct io_pgtable_cfg *, struct device *);
	void (*tlb_sync)(struct arm_smmu_device *, int, int, int);
	int (*def_domain_type)(struct device *);
	irqreturn_t (*global_fault)(int, void *);
	irqreturn_t (*context_fault)(int, void *);
	int (*alloc_context_bank)(struct arm_smmu_domain *, struct arm_smmu_device *, struct device *, int);
	void (*write_s2cr)(struct arm_smmu_device *, int);
	void (*write_sctlr)(struct arm_smmu_device *, int, u32);
	void (*probe_finalize)(struct arm_smmu_device *, struct device *);
};

enum arm_smmu_arch_version {
	ARM_SMMU_V1 = 0,
	ARM_SMMU_V1_64K = 1,
	ARM_SMMU_V2 = 2,
};

enum arm_smmu_implementation {
	GENERIC_SMMU = 0,
	ARM_MMU500 = 1,
	CAVIUM_SMMUV2 = 2,
	QCOM_SMMUV2 = 3,
};

struct arm_smmu_cb;

struct arm_smmu_smr;

struct arm_smmu_s2cr;

struct arm_smmu_device {
	struct device *dev;
	void *base;
	phys_addr_t ioaddr;
	unsigned int numpage;
	unsigned int pgshift;
	u32 features;
	enum arm_smmu_arch_version version;
	enum arm_smmu_implementation model;
	const struct arm_smmu_impl *impl;
	u32 num_context_banks;
	u32 num_s2_context_banks;
	unsigned long context_map[2];
	struct arm_smmu_cb *cbs;
	atomic_t irptndx;
	u32 num_mapping_groups;
	u16 streamid_mask;
	u16 smr_mask_mask;
	struct arm_smmu_smr *smrs;
	struct arm_smmu_s2cr *s2crs;
	struct mutex stream_map_mutex;
	unsigned long va_size;
	unsigned long ipa_size;
	unsigned long pa_size;
	unsigned long pgsize_bitmap;
	int num_context_irqs;
	int num_clks;
	unsigned int *irqs;
	struct clk_bulk_data *clks;
	spinlock_t global_sync_lock;
	struct iommu_device iommu;
};

struct arm_smmu_cfg;

struct arm_smmu_cb {
	u64 ttbr[2];
	u32 tcr[2];
	u32 mair[2];
	struct arm_smmu_cfg *cfg;
};

enum arm_smmu_cbar_type {
	CBAR_TYPE_S2_TRANS = 0,
	CBAR_TYPE_S1_TRANS_S2_BYPASS = 1,
	CBAR_TYPE_S1_TRANS_S2_FAULT = 2,
	CBAR_TYPE_S1_TRANS_S2_TRANS = 3,
};

enum arm_smmu_context_fmt {
	ARM_SMMU_CTX_FMT_NONE = 0,
	ARM_SMMU_CTX_FMT_AARCH64 = 1,
	ARM_SMMU_CTX_FMT_AARCH32_L = 2,
	ARM_SMMU_CTX_FMT_AARCH32_S = 3,
};

struct arm_smmu_cfg {
	u8 cbndx;
	u8 irptndx;
	union {
		u16 asid;
		u16 vmid;
	};
	enum arm_smmu_cbar_type cbar;
	enum arm_smmu_context_fmt fmt;
	bool flush_walk_prefer_tlbiasid;
};

struct arm_smmu_smr {
	u16 mask;
	u16 id;
	bool valid;
	bool pinned;
};

enum arm_smmu_s2cr_type {
	S2CR_TYPE_TRANS = 0,
	S2CR_TYPE_BYPASS = 1,
	S2CR_TYPE_FAULT = 2,
};

enum arm_smmu_s2cr_privcfg {
	S2CR_PRIVCFG_DEFAULT = 0,
	S2CR_PRIVCFG_DIPAN = 1,
	S2CR_PRIVCFG_UNPRIV = 2,
	S2CR_PRIVCFG_PRIV = 3,
};

struct arm_smmu_s2cr {
	struct iommu_group *group;
	int count;
	enum arm_smmu_s2cr_type type;
	enum arm_smmu_s2cr_privcfg privcfg;
	u8 cbndx;
};

enum arm_smmu_domain_stage {
	ARM_SMMU_DOMAIN_S1 = 0,
	ARM_SMMU_DOMAIN_S2 = 1,
	ARM_SMMU_DOMAIN_NESTED = 2,
	ARM_SMMU_DOMAIN_BYPASS = 3,
};

struct arm_smmu_domain {
	struct arm_smmu_device *smmu;
	struct io_pgtable_ops *pgtbl_ops;
	unsigned long pgtbl_quirks;
	const struct iommu_flush_ops *flush_ops;
	struct arm_smmu_cfg cfg;
	enum arm_smmu_domain_stage stage;
	struct mutex init_mutex;
	spinlock_t cb_lock;
	struct iommu_domain domain;
};

struct nvidia_smmu {
	struct arm_smmu_device smmu;
	void *bases[2];
	unsigned int num_instances;
	struct tegra_mc *mc;
};

enum genpd_notication {
	GENPD_NOTIFY_PRE_OFF = 0,
	GENPD_NOTIFY_OFF = 1,
	GENPD_NOTIFY_PRE_ON = 2,
	GENPD_NOTIFY_ON = 3,
};

struct gpd_link {
	struct generic_pm_domain *parent;
	struct list_head parent_node;
	struct generic_pm_domain *child;
	struct list_head child_node;
	unsigned int performance_state;
	unsigned int prev_performance_state;
};

struct of_genpd_provider {
	struct list_head link;
	struct device_node *node;
	genpd_xlate_t xlate;
	void *data;
};

struct gpd_timing_data;

struct generic_pm_domain_data {
	struct pm_domain_data base;
	struct gpd_timing_data *td;
	struct notifier_block nb;
	struct notifier_block *power_nb;
	int cpu;
	unsigned int performance_state;
	unsigned int default_pstate;
	unsigned int rpm_pstate;
	void *data;
};

struct gpd_timing_data {
	s64 suspend_latency_ns;
	s64 resume_latency_ns;
	s64 effective_constraint_ns;
	ktime_t next_wakeup;
	bool constraint_changed;
	bool cached_suspend_ok;
};

struct of_phandle_iterator {
	const char *cells_name;
	int cell_count;
	const struct device_node *parent;
	const __be32 *list_end;
	const __be32 *phandle_end;
	const __be32 *cur;
	uint32_t cur_count;
	phandle phandle;
	struct device_node *node;
};

enum MFI_STAT {
	MFI_STAT_OK = 0,
	MFI_STAT_INVALID_CMD = 1,
	MFI_STAT_INVALID_DCMD = 2,
	MFI_STAT_INVALID_PARAMETER = 3,
	MFI_STAT_INVALID_SEQUENCE_NUMBER = 4,
	MFI_STAT_ABORT_NOT_POSSIBLE = 5,
	MFI_STAT_APP_HOST_CODE_NOT_FOUND = 6,
	MFI_STAT_APP_IN_USE = 7,
	MFI_STAT_APP_NOT_INITIALIZED = 8,
	MFI_STAT_ARRAY_INDEX_INVALID = 9,
	MFI_STAT_ARRAY_ROW_NOT_EMPTY = 10,
	MFI_STAT_CONFIG_RESOURCE_CONFLICT = 11,
	MFI_STAT_DEVICE_NOT_FOUND = 12,
	MFI_STAT_DRIVE_TOO_SMALL = 13,
	MFI_STAT_FLASH_ALLOC_FAIL = 14,
	MFI_STAT_FLASH_BUSY = 15,
	MFI_STAT_FLASH_ERROR = 16,
	MFI_STAT_FLASH_IMAGE_BAD = 17,
	MFI_STAT_FLASH_IMAGE_INCOMPLETE = 18,
	MFI_STAT_FLASH_NOT_OPEN = 19,
	MFI_STAT_FLASH_NOT_STARTED = 20,
	MFI_STAT_FLUSH_FAILED = 21,
	MFI_STAT_HOST_CODE_NOT_FOUNT = 22,
	MFI_STAT_LD_CC_IN_PROGRESS = 23,
	MFI_STAT_LD_INIT_IN_PROGRESS = 24,
	MFI_STAT_LD_LBA_OUT_OF_RANGE = 25,
	MFI_STAT_LD_MAX_CONFIGURED = 26,
	MFI_STAT_LD_NOT_OPTIMAL = 27,
	MFI_STAT_LD_RBLD_IN_PROGRESS = 28,
	MFI_STAT_LD_RECON_IN_PROGRESS = 29,
	MFI_STAT_LD_WRONG_RAID_LEVEL = 30,
	MFI_STAT_MAX_SPARES_EXCEEDED = 31,
	MFI_STAT_MEMORY_NOT_AVAILABLE = 32,
	MFI_STAT_MFC_HW_ERROR = 33,
	MFI_STAT_NO_HW_PRESENT = 34,
	MFI_STAT_NOT_FOUND = 35,
	MFI_STAT_NOT_IN_ENCL = 36,
	MFI_STAT_PD_CLEAR_IN_PROGRESS = 37,
	MFI_STAT_PD_TYPE_WRONG = 38,
	MFI_STAT_PR_DISABLED = 39,
	MFI_STAT_ROW_INDEX_INVALID = 40,
	MFI_STAT_SAS_CONFIG_INVALID_ACTION = 41,
	MFI_STAT_SAS_CONFIG_INVALID_DATA = 42,
	MFI_STAT_SAS_CONFIG_INVALID_PAGE = 43,
	MFI_STAT_SAS_CONFIG_INVALID_TYPE = 44,
	MFI_STAT_SCSI_DONE_WITH_ERROR = 45,
	MFI_STAT_SCSI_IO_FAILED = 46,
	MFI_STAT_SCSI_RESERVATION_CONFLICT = 47,
	MFI_STAT_SHUTDOWN_FAILED = 48,
	MFI_STAT_TIME_NOT_SET = 49,
	MFI_STAT_WRONG_STATE = 50,
	MFI_STAT_LD_OFFLINE = 51,
	MFI_STAT_PEER_NOTIFICATION_REJECTED = 52,
	MFI_STAT_PEER_NOTIFICATION_FAILED = 53,
	MFI_STAT_RESERVATION_IN_PROGRESS = 54,
	MFI_STAT_I2C_ERRORS_DETECTED = 55,
	MFI_STAT_PCI_ERRORS_DETECTED = 56,
	MFI_STAT_CONFIG_SEQ_MISMATCH = 103,
	MFI_STAT_INVALID_STATUS = 255,
};

enum DCMD_RETURN_STATUS {
	DCMD_SUCCESS = 0,
	DCMD_TIMEOUT = 1,
	DCMD_FAILED = 2,
	DCMD_BUSY = 3,
	DCMD_INIT = 255,
};

enum MR_PERF_MODE {
	MR_BALANCED_PERF_MODE = 0,
	MR_IOPS_PERF_MODE = 1,
	MR_LATENCY_PERF_MODE = 2,
};

enum MFI_CMD_OP {
	MFI_CMD_INIT = 0,
	MFI_CMD_LD_READ = 1,
	MFI_CMD_LD_WRITE = 2,
	MFI_CMD_LD_SCSI_IO = 3,
	MFI_CMD_PD_SCSI_IO = 4,
	MFI_CMD_DCMD = 5,
	MFI_CMD_ABORT = 6,
	MFI_CMD_SMP = 7,
	MFI_CMD_STP = 8,
	MFI_CMD_NVME = 9,
	MFI_CMD_TOOLBOX = 10,
	MFI_CMD_OP_COUNT = 11,
	MFI_CMD_INVALID = 255,
};

enum MR_FW_CRASH_DUMP_STATE {
	UNAVAILABLE = 0,
	AVAILABLE = 1,
	COPYING = 2,
	COPIED = 3,
	COPY_ERROR = 4,
};

enum {
	MEGASAS_HBA_OPERATIONAL = 0,
	MEGASAS_ADPRESET_SM_INFAULT = 1,
	MEGASAS_ADPRESET_SM_FW_RESET_SUCCESS = 2,
	MEGASAS_ADPRESET_SM_OPERATIONAL = 3,
	MEGASAS_HW_CRITICAL_ERROR = 4,
	MEGASAS_ADPRESET_SM_POLLING = 5,
	MEGASAS_ADPRESET_INPROG_SIGN = 3735936685,
};

enum MR_SCSI_CMD_TYPE {
	READ_WRITE_LDIO = 0,
	NON_READ_WRITE_LDIO = 1,
	READ_WRITE_SYSPDIO = 2,
	NON_READ_WRITE_SYSPDIO = 3,
};

enum FW_BOOT_CONTEXT {
	PROBE_CONTEXT = 0,
	OCR_CONTEXT = 1,
};

enum _MR_CRASH_BUF_STATUS {
	MR_CRASH_BUF_TURN_OFF = 0,
	MR_CRASH_BUF_TURN_ON = 1,
};

enum MEGASAS_OCR_CAUSE {
	FW_FAULT_OCR = 0,
	SCSIIO_TIMEOUT_OCR = 1,
	MFI_IO_TIMEOUT_OCR = 2,
};

enum CMD_RET_VALUES {
	REFIRE_CMD = 1,
	COMPLETE_CMD = 2,
	RETURN_CMD = 3,
};

enum MR_PD_TYPE {
	UNKNOWN_DRIVE = 0,
	PARALLEL_SCSI = 1,
	SAS_PD = 2,
	SATA_PD = 3,
	FC_PD = 4,
	NVME_PD = 5,
};

struct MR_LD_TARGET_SYNC {
	u8 targetId;
	u8 reserved;
	__le16 seqNum;
};

struct MR_TM_REPLY {
	char reply[128];
};

struct MR_TM_REQUEST {
	char request[128];
};

struct MR_TASK_MANAGE_REQUEST {
	struct MR_TM_REQUEST TmRequest;
	union {
		struct {
			u32 isTMForLD: 1;
			u32 isTMForPD: 1;
			u32 reserved1: 30;
			u32 reserved2;
		} tmReqFlags;
		struct MR_TM_REPLY TMReply;
	};
};

struct MPI2_SCSI_TASK_MANAGE_REQUEST {
	u16 DevHandle;
	u8 ChainOffset;
	u8 Function;
	u8 Reserved1;
	u8 TaskType;
	u8 Reserved2;
	u8 MsgFlags;
	u8 VP_ID;
	u8 VF_ID;
	u16 Reserved3;
	u8 LUN[8];
	u32 Reserved4[7];
	u16 TaskMID;
	u16 Reserved5;
};

struct MPI2_SCSI_TASK_MANAGE_REPLY {
	u16 DevHandle;
	u8 MsgLength;
	u8 Function;
	u8 ResponseCode;
	u8 TaskType;
	u8 Reserved1;
	u8 MsgFlags;
	u8 VP_ID;
	u8 VF_ID;
	u16 Reserved2;
	u16 Reserved3;
	u16 IOCStatus;
	u32 IOCLogInfo;
	u32 TerminationCount;
	u32 ResponseInfo;
};

struct MPI25_IEEE_SGE_CHAIN64 {
	__le64 Address;
	__le32 Length;
	__le16 Reserved1;
	u8 NextChainOffset;
	u8 Flags;
};

struct MR_PRIV_DEVICE {
	bool is_tm_capable;
	bool tm_busy;
	atomic_t sdev_priv_busy;
	atomic_t r1_ldio_hint;
	u8 interface_type;
	u8 task_abort_tmo;
	u8 target_reset_tmo;
};

union desc_value {
	__le64 word;
	struct {
		__le32 low;
		__le32 high;
	} u;
};

struct ahci_mvebu_plat_data {
	int (*plat_config)(struct ahci_host_priv *);
	unsigned int flags;
};

struct mtd_chip_driver;

struct map_info {
	const char *name;
	unsigned long size;
	resource_size_t phys;
	void *virt;
	void *cached;
	int swap;
	int bankwidth;
	void (*inval_cache)(struct map_info *, unsigned long, ssize_t);
	void (*set_vpp)(struct map_info *, int);
	unsigned long pfow_base;
	unsigned long map_priv_1;
	unsigned long map_priv_2;
	struct device_node *device_node;
	void *fldrv_priv;
	struct mtd_chip_driver *fldrv;
};

struct mtd_chip_driver {
	struct mtd_info * (*probe)(struct map_info *);
	void (*destroy)(struct mtd_info *);
	struct module *module;
	char *name;
	struct list_head list;
};

struct cfi_private;

struct chip_probe {
	char *name;
	int (*probe_chip)(struct map_info *, __u32, unsigned long *, struct cfi_private *);
};

typedef union {
	unsigned long x[1];
} map_word;

typedef enum {
	FL_READY = 0,
	FL_STATUS = 1,
	FL_CFI_QUERY = 2,
	FL_JEDEC_QUERY = 3,
	FL_ERASING = 4,
	FL_ERASE_SUSPENDING = 5,
	FL_ERASE_SUSPENDED = 6,
	FL_WRITING = 7,
	FL_WRITING_TO_BUFFER = 8,
	FL_OTP_WRITE = 9,
	FL_WRITE_SUSPENDING = 10,
	FL_WRITE_SUSPENDED = 11,
	FL_PM_SUSPENDED = 12,
	FL_SYNCING = 13,
	FL_UNLOADING = 14,
	FL_LOCKING = 15,
	FL_UNLOCKING = 16,
	FL_POINT = 17,
	FL_XIP_WHILE_ERASING = 18,
	FL_XIP_WHILE_WRITING = 19,
	FL_SHUTDOWN = 20,
	FL_READING = 21,
	FL_CACHEDPRG = 22,
	FL_RESETTING = 23,
	FL_OTPING = 24,
	FL_PREPARING_ERASE = 25,
	FL_VERIFYING_ERASE = 26,
	FL_UNKNOWN = 27,
} flstate_t;

struct flchip {
	unsigned long start;
	int ref_point_counter;
	flstate_t state;
	flstate_t oldstate;
	unsigned int write_suspended: 1;
	unsigned int erase_suspended: 1;
	unsigned long in_progress_block_addr;
	unsigned long in_progress_block_mask;
	struct mutex mutex;
	wait_queue_head_t wq;
	int word_write_time;
	int buffer_write_time;
	int erase_time;
	int word_write_time_max;
	int buffer_write_time_max;
	int erase_time_max;
	void *priv;
};

struct cfi_ident;

struct cfi_private {
	uint16_t cmdset;
	void *cmdset_priv;
	int interleave;
	int device_type;
	int cfi_mode;
	int addr_unlock1;
	int addr_unlock2;
	struct mtd_info * (*cmdset_setup)(struct map_info *);
	struct cfi_ident *cfiq;
	int mfr;
	int id;
	int numchips;
	map_word sector_erase_cmd;
	unsigned long chipshift;
	const char *im_name;
	unsigned long quirks;
	struct flchip chips[0];
};

struct cfi_ident {
	uint8_t qry[3];
	uint16_t P_ID;
	uint16_t P_ADR;
	uint16_t A_ID;
	uint16_t A_ADR;
	uint8_t VccMin;
	uint8_t VccMax;
	uint8_t VppMin;
	uint8_t VppMax;
	uint8_t WordWriteTimeoutTyp;
	uint8_t BufWriteTimeoutTyp;
	uint8_t BlockEraseTimeoutTyp;
	uint8_t ChipEraseTimeoutTyp;
	uint8_t WordWriteTimeoutMax;
	uint8_t BufWriteTimeoutMax;
	uint8_t BlockEraseTimeoutMax;
	uint8_t ChipEraseTimeoutMax;
	uint8_t DevSize;
	uint16_t InterfaceDesc;
	uint16_t MaxBufWriteSize;
	uint8_t NumEraseRegions;
	uint32_t EraseRegionInfo[0];
} __attribute__((packed));

typedef struct mtd_info *cfi_cmdset_fn_t(struct map_info *, int);

struct mdiobus_devres {
	struct mii_bus *mii;
};

struct iproc_mdiomux_desc {
	void *mux_handle;
	void *base;
	struct device *dev;
	struct mii_bus *mii_bus;
	struct clk *core_clk;
};

struct tgec_regs;

struct eth_hash_t;

struct tgec_cfg;

struct fman_mac {
	struct tgec_regs *regs;
	u64 addr;
	u16 max_speed;
	struct mac_device *dev_id;
	fman_mac_exception_cb *exception_cb;
	fman_mac_exception_cb *event_cb;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	struct tgec_cfg *cfg;
	void *fm;
	struct fman_rev_info fm_rev_info;
	bool allmulti_enabled;
};

struct tgec_regs {
	u32 tgec_id;
	u32 reserved001[1];
	u32 command_config;
	u32 mac_addr_0;
	u32 mac_addr_1;
	u32 maxfrm;
	u32 pause_quant;
	u32 rx_fifo_sections;
	u32 tx_fifo_sections;
	u32 rx_fifo_almost_f_e;
	u32 tx_fifo_almost_f_e;
	u32 hashtable_ctrl;
	u32 mdio_cfg_status;
	u32 mdio_command;
	u32 mdio_data;
	u32 mdio_regaddr;
	u32 status;
	u32 tx_ipg_len;
	u32 mac_addr_2;
	u32 mac_addr_3;
	u32 rx_fifo_ptr_rd;
	u32 rx_fifo_ptr_wr;
	u32 tx_fifo_ptr_rd;
	u32 tx_fifo_ptr_wr;
	u32 imask;
	u32 ievent;
	u32 udp_port;
	u32 type_1588v2;
	u32 reserved070[4];
	u32 tfrm_u;
	u32 tfrm_l;
	u32 rfrm_u;
	u32 rfrm_l;
	u32 rfcs_u;
	u32 rfcs_l;
	u32 raln_u;
	u32 raln_l;
	u32 txpf_u;
	u32 txpf_l;
	u32 rxpf_u;
	u32 rxpf_l;
	u32 rlong_u;
	u32 rlong_l;
	u32 rflr_u;
	u32 rflr_l;
	u32 tvlan_u;
	u32 tvlan_l;
	u32 rvlan_u;
	u32 rvlan_l;
	u32 toct_u;
	u32 toct_l;
	u32 roct_u;
	u32 roct_l;
	u32 ruca_u;
	u32 ruca_l;
	u32 rmca_u;
	u32 rmca_l;
	u32 rbca_u;
	u32 rbca_l;
	u32 terr_u;
	u32 terr_l;
	u32 reserved100[2];
	u32 tuca_u;
	u32 tuca_l;
	u32 tmca_u;
	u32 tmca_l;
	u32 tbca_u;
	u32 tbca_l;
	u32 rdrp_u;
	u32 rdrp_l;
	u32 reoct_u;
	u32 reoct_l;
	u32 rpkt_u;
	u32 rpkt_l;
	u32 trund_u;
	u32 trund_l;
	u32 r64_u;
	u32 r64_l;
	u32 r127_u;
	u32 r127_l;
	u32 r255_u;
	u32 r255_l;
	u32 r511_u;
	u32 r511_l;
	u32 r1023_u;
	u32 r1023_l;
	u32 r1518_u;
	u32 r1518_l;
	u32 r1519x_u;
	u32 r1519x_l;
	u32 trovr_u;
	u32 trovr_l;
	u32 trjbr_u;
	u32 trjbr_l;
	u32 trfrg_u;
	u32 trfrg_l;
	u32 rerr_u;
	u32 rerr_l;
};

struct eth_hash_t {
	u16 size;
	struct list_head *lsts;
};

struct tgec_cfg {
	bool pause_ignore;
	bool promiscuous_mode_enable;
	u16 max_frame_length;
	u16 pause_quant;
	u32 tx_ipg_length;
};

struct eth_hash_entry {
	u64 addr;
	struct list_head node;
};

enum phy_reset_delays {
	PRE_DELAY = 0,
	PULSE = 1,
	POST_DELAY = 2,
	DELAYS_NUM = 3,
};

struct hix5hd2_desc;

struct hix5hd2_desc_sw {
	struct hix5hd2_desc *desc;
	dma_addr_t phys_addr;
	unsigned int count;
	unsigned int size;
};

struct sg_desc;

struct hix5hd2_sg_desc_ring {
	struct sg_desc *desc;
	dma_addr_t phys_addr;
};

struct hix5hd2_priv {
	struct hix5hd2_desc_sw pool[4];
	struct hix5hd2_sg_desc_ring tx_ring;
	void *base;
	void *ctrl_base;
	struct sk_buff *tx_skb[1024];
	struct sk_buff *rx_skb[1024];
	struct device *dev;
	struct net_device *netdev;
	struct device_node *phy_node;
	phy_interface_t phy_mode;
	unsigned long hw_cap;
	unsigned int speed;
	unsigned int duplex;
	struct clk *mac_core_clk;
	struct clk *mac_ifc_clk;
	struct reset_control *mac_core_rst;
	struct reset_control *mac_ifc_rst;
	struct reset_control *phy_rst;
	u32 phy_reset_delays[3];
	struct mii_bus *bus;
	struct napi_struct napi;
	struct work_struct tx_timeout_task;
};

struct hix5hd2_desc {
	__le32 buff_addr;
	__le32 cmd;
	long: 64;
	long: 64;
	long: 64;
};

struct frags_info {
	__le32 addr;
	__le32 size;
};

struct sg_desc {
	__le32 total_len;
	__le32 resvd0;
	__le32 linear_addr;
	__le32 linear_len;
	struct frags_info frags[18];
};

struct hclge_comm_caps_bit_map {
	u16 imp_bit;
	u16 local_bit;
};

struct hclge_cmdq_tx_timeout_map {
	u32 opcode;
	u32 tx_timeout;
};

enum hclge_comm_cmd_state {
	HCLGE_COMM_STATE_CMD_DISABLE = 0,
};

enum HCLGE_COMM_API_CAP_BITS {
	HCLGE_COMM_API_CAP_FLEX_RSS_TBL_B = 0,
};

struct hclge_comm_firmware_compat_cmd {
	__le32 compat;
	u8 rsv[20];
};

struct hclge_comm_query_version_cmd {
	__le32 firmware;
	__le32 hardware;
	__le32 api_caps;
	__le32 caps[3];
};

struct hclge_comm_errcode {
	u32 imp_errcode;
	int common_errno;
};

struct cpsw_sl_dev_id {
	const char *device_id;
	const u16 *regs;
	const u32 control_features;
	const u32 regs_offset;
	const u32 idle_mask;
};

enum cpsw_sl_regs {
	CPSW_SL_IDVER = 0,
	CPSW_SL_MACCONTROL = 1,
	CPSW_SL_MACSTATUS = 2,
	CPSW_SL_SOFT_RESET = 3,
	CPSW_SL_RX_MAXLEN = 4,
	CPSW_SL_BOFFTEST = 5,
	CPSW_SL_RX_PAUSE = 6,
	CPSW_SL_TX_PAUSE = 7,
	CPSW_SL_EMCONTROL = 8,
	CPSW_SL_RX_PRI_MAP = 9,
	CPSW_SL_TX_GAP = 10,
};

struct cpsw_sl {
	struct device *dev;
	void *sl_base;
	const u16 *regs;
	u32 control_features;
	u32 idle_mask;
};

enum {
	VFIO_PCI_BAR0_REGION_INDEX = 0,
	VFIO_PCI_BAR1_REGION_INDEX = 1,
	VFIO_PCI_BAR2_REGION_INDEX = 2,
	VFIO_PCI_BAR3_REGION_INDEX = 3,
	VFIO_PCI_BAR4_REGION_INDEX = 4,
	VFIO_PCI_BAR5_REGION_INDEX = 5,
	VFIO_PCI_ROM_REGION_INDEX = 6,
	VFIO_PCI_CONFIG_REGION_INDEX = 7,
	VFIO_PCI_VGA_REGION_INDEX = 8,
	VFIO_PCI_NUM_REGIONS = 9,
};

struct virqfd;

struct vfio_pci_ioeventfd {
	struct list_head next;
	struct vfio_pci_core_device *vdev;
	struct virqfd *virqfd;
	void *addr;
	uint64_t data;
	loff_t pos;
	int bar;
	int count;
	bool test_mem;
};

struct vfio_pci_vf_token {
	struct mutex lock;
	uuid_t uuid;
	int users;
};

struct virqfd {
	void *opaque;
	struct eventfd_ctx *eventfd;
	int (*handler)(void *, void *);
	void (*thread)(void *, void *);
	void *data;
	struct work_struct inject;
	wait_queue_entry_t wait;
	poll_table pt;
	struct work_struct shutdown;
	struct virqfd **pvirqfd;
};

struct vfio_pci_dummy_resource {
	struct resource resource;
	int index;
	struct list_head res_next;
};

struct vfio_pci_mmap_vma {
	struct vm_area_struct *vma;
	struct list_head vma_next;
};

struct vfio_pci_walk_info {
	int (*fn)(struct pci_dev *, void *);
	void *data;
	struct pci_dev *pdev;
	bool slot;
	int ret;
};

struct vfio_device_info {
	__u32 argsz;
	__u32 flags;
	__u32 num_regions;
	__u32 num_irqs;
	__u32 cap_offset;
	__u32 pad;
};

struct vfio_region_info {
	__u32 argsz;
	__u32 flags;
	__u32 index;
	__u32 cap_offset;
	__u64 size;
	__u64 offset;
};

struct vfio_region_info_cap_type {
	struct vfio_info_cap_header header;
	__u32 type;
	__u32 subtype;
};

struct vfio_irq_info {
	__u32 argsz;
	__u32 flags;
	__u32 index;
	__u32 count;
};

struct vfio_irq_set {
	__u32 argsz;
	__u32 flags;
	__u32 index;
	__u32 start;
	__u32 count;
	__u8 data[0];
};

struct vfio_pci_dependent_device {
	union {
		__u32 group_id;
		__u32 devid;
	};
	__u16 segment;
	__u8 bus;
	__u8 devfn;
};

struct vfio_pci_hot_reset_info {
	__u32 argsz;
	__u32 flags;
	__u32 count;
	struct vfio_pci_dependent_device devices[0];
};

struct vfio_pci_fill_info {
	struct vfio_pci_dependent_device __attribute__((btf_type_tag("user"))) *devices;
	struct vfio_pci_dependent_device __attribute__((btf_type_tag("user"))) *devices_end;
	struct vfio_device *vdev;
	u32 count;
	u32 flags;
};

struct vfio_pci_hot_reset {
	__u32 argsz;
	__u32 flags;
	__u32 count;
	__s32 group_fds[0];
};

struct vfio_device_ioeventfd {
	__u32 argsz;
	__u32 flags;
	__u64 offset;
	__u64 data;
	__s32 fd;
	__u32 reserved;
};

struct vfio_device_info_cap_pci_atomic_comp {
	struct vfio_info_cap_header header;
	__u32 flags;
	__u32 reserved;
};

struct vfio_pci_group_info {
	int count;
	struct file **files;
};

struct vfio_device_low_power_entry_with_wakeup {
	__s32 wakeup_eventfd;
	__u32 reserved;
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = -1,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

struct dwc3_exynos_driverdata {
	const char *clk_names[4];
	int num_clks;
	int suspend_clk_idx;
};

struct dwc3_exynos {
	struct device *dev;
	const char **clk_names;
	struct clk *clks[4];
	int num_clks;
	int suspend_clk_idx;
	struct regulator *vdd33;
	struct regulator *vdd10;
};

struct wrapper_priv_data {
	struct dwc2_hsotg *hsotg;
};

enum xhci_overhead_type {
	LS_OVERHEAD_TYPE = 0,
	FS_OVERHEAD_TYPE = 1,
	HS_OVERHEAD_TYPE = 2,
};

enum xhci_setup_dev {
	SETUP_CONTEXT_ONLY = 0,
	SETUP_CONTEXT_ADDRESS = 1,
};

typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);

struct xhci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
};

struct ci_hdrc_imx_platform_flag {
	unsigned int flags;
};

struct imx_usbmisc_data {
	struct device *dev;
	int index;
	unsigned int disable_oc: 1;
	unsigned int oc_pol_active_low: 1;
	unsigned int oc_pol_configured: 1;
	unsigned int pwr_pol: 1;
	unsigned int evdo: 1;
	unsigned int ulpi: 1;
	unsigned int hsic: 1;
	unsigned int ext_id: 1;
	unsigned int ext_vbus: 1;
	struct usb_phy *usb_phy;
	enum usb_dr_mode available_role;
	int emp_curr_control;
	int dc_vol_level_adjust;
	int rise_fall_time_adjust;
};

struct ci_hdrc_imx_data {
	struct usb_phy *phy;
	struct platform_device *ci_pdev;
	struct clk *clk;
	struct imx_usbmisc_data *usbmisc_data;
	bool supports_runtime_pm;
	bool override_phy_control;
	bool in_lpm;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_hsic_active;
	struct regulator *hsic_pad_regulator;
	bool need_three_clks;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_per;
	struct pm_qos_request pm_qos_req;
	const struct ci_hdrc_imx_platform_flag *plat_data;
};

struct cros_ec_bs_map {
	unsigned int ev_type;
	unsigned int code;
	u8 bit;
	bool inverted;
};

enum ec_mkbp_info_type {
	EC_MKBP_INFO_KBD = 0,
	EC_MKBP_INFO_SUPPORTED = 1,
	EC_MKBP_INFO_CURRENT = 2,
};

struct ec_params_mkbp_info {
	uint8_t info_type;
	uint8_t event_type;
};

struct vivaldi_data {
	u32 function_row_physmap[24];
	unsigned int num_function_row_keys;
};

struct matrix_keymap_data;

struct cros_ec_keyb {
	unsigned int rows;
	unsigned int cols;
	int row_shift;
	const struct matrix_keymap_data *keymap_data;
	bool ghost_filter;
	uint8_t *valid_keys;
	uint8_t *old_kb_state;
	struct device *dev;
	struct cros_ec_device *ec;
	struct input_dev *idev;
	struct input_dev *bs_idev;
	struct notifier_block notifier;
	struct vivaldi_data vdata;
};

struct matrix_keymap_data {
	const uint32_t *keymap;
	unsigned int keymap_size;
};

union ec_response_get_next_data {
	uint8_t key_matrix[13];
	uint32_t host_event;
	uint64_t host_event64;
	struct {
		uint8_t reserved[3];
		struct ec_response_motion_sense_fifo_info info;
	} sensor_fifo;
	uint32_t buttons;
	uint32_t switches;
	uint32_t fp_events;
	uint32_t sysrq;
	uint32_t cec_events;
};

struct xgene_rtc_dev {
	struct rtc_device *rtc;
	void *csr_base;
	struct clk *clk;
	unsigned int irq_wake;
	unsigned int irq_enabled;
};

struct i2c_spec_values {
	unsigned int min_low_ns;
	unsigned int min_su_sta_ns;
	unsigned int max_hd_dat_ns;
	unsigned int min_su_dat_ns;
};

struct mtk_i2c_compatible {
	const struct i2c_adapter_quirks *quirks;
	const u16 *regs;
	unsigned char pmic_i2c: 1;
	unsigned char dcm: 1;
	unsigned char auto_restart: 1;
	unsigned char aux_len_reg: 1;
	unsigned char timing_adjust: 1;
	unsigned char dma_sync: 1;
	unsigned char ltiming_adjust: 1;
	unsigned char apdma_sync: 1;
	unsigned char max_dma_support;
};

enum mtk_trans_op {
	I2C_MASTER_WR = 1,
	I2C_MASTER_RD = 2,
	I2C_MASTER_WRRD = 3,
};

enum i2c_mt65xx_clks {
	I2C_MT65XX_CLK_MAIN = 0,
	I2C_MT65XX_CLK_DMA = 1,
	I2C_MT65XX_CLK_PMIC = 2,
	I2C_MT65XX_CLK_ARB = 3,
	I2C_MT65XX_CLK_MAX = 4,
};

enum I2C_REGS_OFFSET {
	OFFSET_DATA_PORT = 0,
	OFFSET_SLAVE_ADDR = 1,
	OFFSET_INTR_MASK = 2,
	OFFSET_INTR_STAT = 3,
	OFFSET_CONTROL = 4,
	OFFSET_TRANSFER_LEN = 5,
	OFFSET_TRANSAC_LEN = 6,
	OFFSET_DELAY_LEN = 7,
	OFFSET_TIMING = 8,
	OFFSET_START = 9,
	OFFSET_EXT_CONF = 10,
	OFFSET_FIFO_STAT = 11,
	OFFSET_FIFO_THRESH = 12,
	OFFSET_FIFO_ADDR_CLR = 13,
	OFFSET_IO_CONFIG = 14,
	OFFSET_RSV_DEBUG = 15,
	OFFSET_HS = 16,
	OFFSET_SOFTRESET = 17,
	OFFSET_DCM_EN = 18,
	OFFSET_MULTI_DMA = 19,
	OFFSET_PATH_DIR = 20,
	OFFSET_DEBUGSTAT = 21,
	OFFSET_DEBUGCTRL = 22,
	OFFSET_TRANSFER_LEN_AUX = 23,
	OFFSET_CLOCK_DIV = 24,
	OFFSET_LTIMING = 25,
	OFFSET_SCL_HIGH_LOW_RATIO = 26,
	OFFSET_HS_SCL_HIGH_LOW_RATIO = 27,
	OFFSET_SCL_MIS_COMP_POINT = 28,
	OFFSET_STA_STO_AC_TIMING = 29,
	OFFSET_HS_STA_STO_AC_TIMING = 30,
	OFFSET_SDA_TIMING = 31,
};

enum DMA_REGS_OFFSET {
	OFFSET_INT_FLAG = 0,
	OFFSET_INT_EN = 4,
	OFFSET_EN = 8,
	OFFSET_RST = 12,
	OFFSET_CON = 24,
	OFFSET_TX_MEM_ADDR = 28,
	OFFSET_RX_MEM_ADDR = 32,
	OFFSET_TX_LEN = 36,
	OFFSET_RX_LEN = 40,
	OFFSET_TX_4G_MODE = 84,
	OFFSET_RX_4G_MODE = 88,
};

struct i2c_timings {
	u32 bus_freq_hz;
	u32 scl_rise_ns;
	u32 scl_fall_ns;
	u32 scl_int_delay_ns;
	u32 sda_fall_ns;
	u32 sda_hold_ns;
	u32 digital_filter_width_ns;
	u32 analog_filter_cutoff_freq_hz;
};

struct mtk_i2c_ac_timing {
	u16 htiming;
	u16 ltiming;
	u16 hs;
	u16 ext;
	u16 inter_clk_div;
	u16 scl_hl_ratio;
	u16 hs_scl_hl_ratio;
	u16 sta_stop;
	u16 hs_sta_stop;
	u16 sda_timing;
};

struct mtk_i2c {
	struct i2c_adapter adap;
	struct device *dev;
	struct completion msg_complete;
	struct i2c_timings timing_info;
	void *base;
	void *pdmabase;
	struct clk_bulk_data clocks[4];
	bool have_pmic;
	bool use_push_pull;
	u16 irq_stat;
	unsigned int clk_src_div;
	unsigned int speed_hz;
	enum mtk_trans_op op;
	u16 timing_reg;
	u16 high_speed_reg;
	u16 ltiming_reg;
	unsigned char auto_restart;
	bool ignore_restart_irq;
	struct mtk_i2c_ac_timing ac_timing;
	const struct mtk_i2c_compatible *dev_comp;
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

struct psy_get_supplier_prop_data {
	struct power_supply *psy;
	enum power_supply_property psp;
	union power_supply_propval *val;
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
};

struct stm32_iwdg_data {
	bool has_pclk;
	u32 max_prescaler;
};

struct stm32_iwdg {
	struct watchdog_device wdd;
	const struct stm32_iwdg_data *data;
	void *regs;
	struct clk *clk_lsi;
	struct clk *clk_pclk;
	unsigned int rate;
};

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[12];
	unsigned int intervals[8];
	int interval_ptr;
};

struct psci_cpuidle_data {
	u32 *psci_states;
	struct device *dev;
};

struct mmc_driver {
	struct device_driver drv;
	int (*probe)(struct mmc_card *);
	void (*remove)(struct mmc_card *);
	void (*shutdown)(struct mmc_card *);
};

enum mmc_drv_op {
	MMC_DRV_OP_IOCTL = 0,
	MMC_DRV_OP_IOCTL_RPMB = 1,
	MMC_DRV_OP_BOOT_WP = 2,
	MMC_DRV_OP_GET_CARD_STATUS = 3,
	MMC_DRV_OP_GET_EXT_CSD = 4,
};

enum mmc_issued {
	MMC_REQ_STARTED = 0,
	MMC_REQ_BUSY = 1,
	MMC_REQ_FAILED_TO_START = 2,
	MMC_REQ_FINISHED = 3,
};

enum mmc_issue_type {
	MMC_ISSUE_SYNC = 0,
	MMC_ISSUE_DCMD = 1,
	MMC_ISSUE_ASYNC = 2,
	MMC_ISSUE_MAX = 3,
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
};

struct mmc_blk_data;

struct mmc_queue {
	struct mmc_card *card;
	struct mmc_ctx ctx;
	struct blk_mq_tag_set tag_set;
	struct mmc_blk_data *blkdata;
	struct request_queue *queue;
	spinlock_t lock;
	int in_flight[3];
	unsigned int cqe_busy;
	bool busy;
	bool recovery_needed;
	bool in_recovery;
	bool rw_wait;
	bool waiting;
	struct work_struct recovery_work;
	wait_queue_head_t wait;
	struct request *recovery_req;
	struct request *complete_req;
	struct mutex complete_lock;
	struct work_struct complete_work;
};

struct mmc_blk_data {
	struct device *parent;
	struct gendisk *disk;
	struct mmc_queue queue;
	struct list_head part;
	struct list_head rpmbs;
	unsigned int flags;
	struct kref kref;
	unsigned int read_only;
	unsigned int part_type;
	unsigned int reset_done;
	unsigned int part_curr;
	int area_type;
	struct dentry *status_dentry;
	struct dentry *ext_csd_dentry;
};

struct mmc_blk_request {
	struct mmc_request mrq;
	struct mmc_command sbc;
	struct mmc_command cmd;
	struct mmc_command stop;
	struct mmc_data data;
};

struct mmc_queue_req {
	struct mmc_blk_request brq;
	struct scatterlist *sg;
	enum mmc_drv_op drv_op;
	int drv_op_result;
	void *drv_op_data;
	unsigned int ioc_count;
	int retries;
};

struct mmc_ioc_cmd {
	int write_flag;
	int is_acmd;
	__u32 opcode;
	__u32 arg;
	__u32 response[4];
	unsigned int flags;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int postsleep_min_us;
	unsigned int postsleep_max_us;
	unsigned int data_timeout_ns;
	unsigned int cmd_timeout_ms;
	__u32 __pad;
	__u64 data_ptr;
};

struct mmc_ioc_multi_cmd {
	__u64 num_of_cmds;
	struct mmc_ioc_cmd cmds[0];
};

struct mmc_rpmb_data {
	struct device dev;
	struct cdev chrdev;
	int id;
	unsigned int part_index;
	struct mmc_blk_data *md;
	struct list_head node;
};

struct mmc_blk_busy_data {
	struct mmc_card *card;
	u32 status;
};

struct mmc_blk_ioc_data {
	struct mmc_ioc_cmd ic;
	unsigned char *buf;
	u64 buf_bytes;
	struct mmc_rpmb_data *rpmb;
};

struct sdhci_cdns_drv_data {
	int (*init)(struct platform_device *);
	const struct sdhci_pltfm_data pltfm_data;
};

struct sdhci_cdns_phy_cfg {
	const char *property;
	u8 addr;
};

struct sdhci_cdns_phy_param {
	u8 addr;
	u8 data;
};

struct sdhci_cdns_priv {
	void *hrs_addr;
	void *ctl_addr;
	spinlock_t wrlock;
	bool enhanced_strobe;
	void (*priv_writel)(struct sdhci_cdns_priv *, u32, void *);
	struct reset_control *rst_hw;
	unsigned int nr_phy_params;
	struct sdhci_cdns_phy_param phy_params[0];
};

struct syscon_led {
	struct led_classdev cdev;
	struct regmap *map;
	u32 offset;
	u32 mask;
	bool state;
};

struct bcm63138_leds;

struct bcm63138_led {
	struct bcm63138_leds *leds;
	struct led_classdev cdev;
	u32 pin;
	bool active_low;
};

struct bcm63138_leds {
	struct device *dev;
	void *base;
	spinlock_t lock;
};

enum mrq_debug_commands {
	CMD_DEBUG_OPEN_RO = 0,
	CMD_DEBUG_OPEN_WO = 1,
	CMD_DEBUG_READ = 2,
	CMD_DEBUG_WRITE = 3,
	CMD_DEBUG_CLOSE = 4,
	CMD_DEBUG_MAX = 5,
};

enum mrq_debugfs_commands {
	CMD_DEBUGFS_READ = 1,
	CMD_DEBUGFS_WRITE = 2,
	CMD_DEBUGFS_DUMPDIR = 3,
	CMD_DEBUGFS_MAX = 4,
};

struct seqbuf {
	char *buf;
	size_t pos;
	size_t size;
};

struct cmd_debugfs_fileop_request {
	uint32_t fnameaddr;
	uint32_t fnamelen;
	uint32_t dataaddr;
	uint32_t datalen;
};

struct cmd_debugfs_dumpdir_request {
	uint32_t dataaddr;
	uint32_t datalen;
};

struct mrq_debugfs_request {
	uint32_t cmd;
	union {
		struct cmd_debugfs_fileop_request fop;
		struct cmd_debugfs_dumpdir_request dumpdir;
	};
};

struct cmd_debugfs_fileop_response {
	uint32_t reserved;
	uint32_t nbytes;
};

struct cmd_debugfs_dumpdir_response {
	uint32_t reserved;
	uint32_t nbytes;
};

struct mrq_debugfs_response {
	int32_t reserved;
	union {
		struct cmd_debugfs_fileop_response fop;
		struct cmd_debugfs_dumpdir_response dumpdir;
	};
};

struct cmd_debug_fopen_request {
	char name[116];
};

struct cmd_debug_fread_request {
	uint32_t fd;
};

struct cmd_debug_fwrite_request {
	uint32_t fd;
	uint32_t datalen;
	char data[108];
};

struct cmd_debug_fclose_request {
	uint32_t fd;
};

struct mrq_debug_request {
	uint32_t cmd;
	union {
		struct cmd_debug_fopen_request fop;
		struct cmd_debug_fread_request frd;
		struct cmd_debug_fwrite_request fwr;
		struct cmd_debug_fclose_request fcl;
	};
};

struct cmd_debug_fopen_response {
	uint32_t fd;
	uint32_t datalen;
};

struct cmd_debug_fread_response {
	uint32_t readlen;
	char data[116];
};

struct mrq_debug_response {
	union {
		struct cmd_debug_fopen_response fop;
		struct cmd_debug_fread_response frd;
	};
};

enum {
	MAGNITUDE_STRONG = 2,
	MAGNITUDE_WEAK = 3,
	MAGNITUDE_NUM = 4,
};

struct ms_data {
	unsigned long quirks;
	struct hid_device *hdev;
	struct work_struct ff_worker;
	__u8 strong;
	__u8 weak;
	void *output_report_dmabuf;
};

struct xb1s_ff_report {
	__u8 report_id;
	__u8 enable;
	__u8 magnitude[4];
	__u8 duration_10ms;
	__u8 start_delay_10ms;
	__u8 loop_count;
};

struct arm_mhu___2;

struct mhu_db_channel {
	struct arm_mhu___2 *mhu;
	unsigned int pchan;
	unsigned int doorbell;
};

struct mhu_db_link {
	unsigned int irq;
	void *tx_reg;
	void *rx_reg;
};

struct arm_mhu___2 {
	void *base;
	struct mhu_db_link mlink[3];
	struct mbox_controller mbox;
	struct device *dev;
};

struct rpmsg_channel_info {
	char name[32];
	u32 src;
	u32 dst;
};

enum rpmsg_ns_flags {
	RPMSG_NS_CREATE = 0,
	RPMSG_NS_DESTROY = 1,
};

typedef __u32 __rpmsg32;

struct rpmsg_ns_msg {
	char name[32];
	__rpmsg32 addr;
	__rpmsg32 flags;
};

enum mrq_bwmgr_int_cmd {
	CMD_BWMGR_INT_QUERY_ABI = 1,
	CMD_BWMGR_INT_CALC_AND_SET = 2,
	CMD_BWMGR_INT_CAP_SET = 3,
};

struct cmd_bwmgr_int_query_abi_request {
	uint32_t type;
};

struct cmd_bwmgr_int_calc_and_set_request {
	uint32_t client_id;
	uint32_t niso_bw;
	uint32_t iso_bw;
	uint32_t mc_floor;
	uint8_t floor_unit;
} __attribute__((packed));

struct cmd_bwmgr_int_cap_set_request {
	uint64_t rate;
};

struct mrq_bwmgr_int_request {
	uint32_t cmd;
	union {
		struct cmd_bwmgr_int_query_abi_request query_abi;
		struct cmd_bwmgr_int_calc_and_set_request bwmgr_calc_set_req;
		struct cmd_bwmgr_int_cap_set_request bwmgr_cap_set_req;
	};
} __attribute__((packed));

struct cmd_bwmgr_int_calc_and_set_response {
	uint64_t rate;
};

struct mrq_bwmgr_int_response {
	union {
		struct cmd_bwmgr_int_calc_and_set_response bwmgr_calc_set_resp;
	};
};

struct l3cache_event_ops {
	void (*start)(struct perf_event *);
	void (*stop)(struct perf_event *, int);
	void (*update)(struct perf_event *);
};

struct l3cache_pmu {
	struct pmu pmu;
	struct hlist_node node;
	void *regs;
	struct perf_event *events[8];
	unsigned long used_mask[1];
	cpumask_t cpumask;
};

struct optee_rpc_param;

typedef void (*btf_trace_optee_invoke_fn_begin)(void *, struct optee_rpc_param *);

struct optee_rpc_param {
	u32 a0;
	u32 a1;
	u32 a2;
	u32 a3;
	u32 a4;
	u32 a5;
	u32 a6;
	u32 a7;
};

typedef void (*btf_trace_optee_invoke_fn_end)(void *, struct optee_rpc_param *, struct arm_smccc_res *);

struct tee_shm_pool;

struct tee_shm_pool_ops {
	int (*alloc)(struct tee_shm_pool *, struct tee_shm *, size_t, size_t);
	void (*free)(struct tee_shm_pool *, struct tee_shm *);
	void (*destroy_pool)(struct tee_shm_pool *);
};

struct tee_shm_pool {
	const struct tee_shm_pool_ops *ops;
	void *private_data;
};

typedef unsigned int u_int;

struct optee;

struct optee_msg_param;

struct optee_ops {
	int (*do_call_with_arg)(struct tee_context *, struct tee_shm *, u_int);
	int (*to_msg_param)(struct optee *, struct optee_msg_param *, size_t, const struct tee_param *);
	int (*from_msg_param)(struct optee *, struct tee_param *, size_t, const struct optee_msg_param *);
};

typedef void optee_invoke_fn(unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, struct arm_smccc_res *);

struct optee_pcpu;

struct optee_smc {
	optee_invoke_fn *invoke_fn;
	void *memremaped_shm;
	u32 sec_caps;
	unsigned int notif_irq;
	struct optee_pcpu __attribute__((btf_type_tag("percpu"))) *optee_pcpu;
	struct workqueue_struct *notif_pcpu_wq;
	struct work_struct notif_pcpu_work;
	unsigned int notif_cpuhp_state;
};

struct ffa_device;

struct optee_ffa {
	struct ffa_device *ffa_dev;
	struct mutex mutex;
	struct rhashtable global_ids;
};

struct optee_shm_arg_cache {
	u32 flags;
	struct mutex mutex;
	struct list_head shm_args;
};

struct optee_call_queue {
	struct mutex mutex;
	struct list_head waiters;
};

typedef unsigned long u_long;

struct optee_notif {
	u_int max_key;
	spinlock_t lock;
	struct list_head db;
	u_long *bitmap;
};

struct optee_supp {
	struct mutex mutex;
	struct tee_context *ctx;
	int req_id;
	struct list_head reqs;
	struct idr idr;
	struct completion reqs_c;
};

struct optee {
	struct tee_device *supp_teedev;
	struct tee_device *teedev;
	const struct optee_ops *ops;
	struct tee_context *ctx;
	union {
		struct optee_smc smc;
		struct optee_ffa ffa;
	};
	struct optee_shm_arg_cache shm_arg_cache;
	struct optee_call_queue call_queue;
	struct optee_notif notif;
	struct optee_supp supp;
	struct tee_shm_pool *pool;
	unsigned int rpc_param_count;
	bool scan_bus_done;
	struct workqueue_struct *scan_bus_wq;
	struct work_struct scan_bus_work;
};

struct optee_pcpu {
	struct optee *optee;
};

struct optee_msg_param_tmem {
	u64 buf_ptr;
	u64 size;
	u64 shm_ref;
};

struct optee_msg_param_rmem {
	u64 offs;
	u64 size;
	u64 shm_ref;
};

struct optee_msg_param_fmem {
	u32 offs_low;
	u16 offs_high;
	u16 internal_offs;
	u64 size;
	u64 global_id;
};

struct optee_msg_param_value {
	u64 a;
	u64 b;
	u64 c;
};

struct optee_msg_param {
	u64 attr;
	union {
		struct optee_msg_param_tmem tmem;
		struct optee_msg_param_rmem rmem;
		struct optee_msg_param_fmem fmem;
		struct optee_msg_param_value value;
		u8 octets[24];
	} u;
};

struct tee_driver_ops;

struct tee_desc {
	const char *name;
	const struct tee_driver_ops *ops;
	struct module *owner;
	u32 flags;
};

struct tee_driver_ops {
	void (*get_version)(struct tee_device *, struct tee_ioctl_version_data *);
	int (*open)(struct tee_context *);
	void (*release)(struct tee_context *);
	int (*open_session)(struct tee_context *, struct tee_ioctl_open_session_arg *, struct tee_param *);
	int (*close_session)(struct tee_context *, u32);
	int (*invoke_func)(struct tee_context *, struct tee_ioctl_invoke_arg *, struct tee_param *);
	int (*cancel_req)(struct tee_context *, u32, u32);
	int (*supp_recv)(struct tee_context *, u32 *, u32 *, struct tee_param *);
	int (*supp_send)(struct tee_context *, u32, u32, struct tee_param *);
	int (*shm_register)(struct tee_context *, struct tee_shm *, struct page **, size_t, unsigned long);
	int (*shm_unregister)(struct tee_context *, struct tee_shm *);
};

struct trace_event_raw_optee_invoke_fn_begin {
	struct trace_entry ent;
	void *param;
	u32 args[8];
	char __data[0];
};

struct trace_event_raw_optee_invoke_fn_end {
	struct trace_entry ent;
	void *param;
	unsigned long rets[4];
	char __data[0];
};

struct optee_smc_call_get_os_revision_result {
	unsigned long major;
	unsigned long minor;
	unsigned long build_id;
	unsigned long reserved1;
};

struct optee_smc_calls_revision_result {
	unsigned long major;
	unsigned long minor;
	unsigned long reserved0;
	unsigned long reserved1;
};

struct optee_smc_exchange_capabilities_result {
	unsigned long status;
	unsigned long capabilities;
	unsigned long max_notif_value;
	unsigned long data;
};

struct optee_smc_get_shm_config_result {
	unsigned long status;
	unsigned long start;
	unsigned long size;
	unsigned long settings;
};

struct optee_smc_disable_shm_cache_result {
	unsigned long status;
	unsigned long shm_upper32;
	unsigned long shm_lower32;
	unsigned long reserved0;
};

struct optee_call_waiter {
	struct list_head list_node;
	struct completion c;
};

struct optee_msg_arg {
	u32 cmd;
	u32 func;
	u32 session;
	u32 cancel_id;
	u32 pad;
	u32 ret;
	u32 ret_origin;
	u32 num_params;
	struct optee_msg_param params[0];
};

struct optee_call_ctx {
	void *pages_list;
	size_t num_entries;
};

struct trace_event_data_offsets_optee_invoke_fn_begin {};

struct trace_event_data_offsets_optee_invoke_fn_end {};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

enum xps_map_type {
	XPS_CPUS = 0,
	XPS_RXQS = 1,
	XPS_MAPS_MAX = 2,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

struct sock_diag_handler {
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum {
	INET_DIAG_BC_NOP = 0,
	INET_DIAG_BC_JMP = 1,
	INET_DIAG_BC_S_GE = 2,
	INET_DIAG_BC_S_LE = 3,
	INET_DIAG_BC_D_GE = 4,
	INET_DIAG_BC_D_LE = 5,
	INET_DIAG_BC_AUTO = 6,
	INET_DIAG_BC_S_COND = 7,
	INET_DIAG_BC_D_COND = 8,
	INET_DIAG_BC_DEV_COND = 9,
	INET_DIAG_BC_MARK_COND = 10,
	INET_DIAG_BC_S_EQ = 11,
	INET_DIAG_BC_D_EQ = 12,
	INET_DIAG_BC_CGROUP_COND = 13,
};

struct inet_diag_hostcond {
	__u8 family;
	__u8 prefix_len;
	int port;
	__be32 addr[0];
};

struct inet_diag_markcond {
	__u32 mark;
	__u32 mask;
};

struct bpf_sk_storage_diag;

struct inet_diag_dump_data {
	struct nlattr *req_nlas[4];
	struct bpf_sk_storage_diag *bpf_stg_diag;
};

struct inet_diag_entry {
	const __be32 *saddr;
	const __be32 *daddr;
	u16 sport;
	u16 dport;
	u16 family;
	u16 userlocks;
	u32 ifindex;
	u32 mark;
	u64 cgroup_id;
};

struct inet_diag_bc_op {
	unsigned char code;
	unsigned char yes;
	unsigned short no;
};

struct inet_diag_req {
	__u8 idiag_family;
	__u8 idiag_src_len;
	__u8 idiag_dst_len;
	__u8 idiag_ext;
	struct inet_diag_sockid id;
	__u32 idiag_states;
	__u32 idiag_dbs;
};

struct inet_diag_sockopt {
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 unused: 5;
};

struct inet_diag_meminfo {
	__u32 idiag_rmem;
	__u32 idiag_wmem;
	__u32 idiag_fmem;
	__u32 idiag_tmem;
};

enum dbg_active_el {
	DBG_ACTIVE_EL0 = 0,
	DBG_ACTIVE_EL1 = 1,
};

typedef void (*btf_trace_vgic_update_irq_pending)(void *, unsigned long, __u32, bool);

struct vgic_global {
	enum vgic_type type;
	phys_addr_t vcpu_base;
	void *vcpu_base_va;
	void *vcpu_hyp_va;
	void *vctrl_base;
	void *vctrl_hyp;
	int nr_lr;
	unsigned int maint_irq;
	int max_gic_vcpus;
	bool can_emulate_gicv2;
	bool has_gicv4;
	bool has_gicv4_1;
	bool no_hw_deactivation;
	struct static_key_false gicv3_cpuif;
	u32 ich_vtr_el2;
};

struct trace_event_raw_vgic_update_irq_pending {
	struct trace_entry ent;
	unsigned long vcpu_id;
	__u32 irq;
	bool level;
	char __data[0];
};

struct trace_event_data_offsets_vgic_update_irq_pending {};

enum exception_type {
	except_type_sync = 0,
	except_type_irq = 128,
	except_type_fiq = 256,
	except_type_serror = 384,
};

struct platform_hibernation_ops {
	int (*begin)(pm_message_t);
	void (*end)();
	int (*pre_snapshot)();
	void (*finish)();
	int (*prepare)();
	int (*enter)();
	void (*leave)();
	int (*pre_restore)();
	void (*restore_cleanup)();
	void (*recover)();
};

enum {
	HIBERNATION_INVALID = 0,
	HIBERNATION_PLATFORM = 1,
	HIBERNATION_SHUTDOWN = 2,
	HIBERNATION_REBOOT = 3,
	HIBERNATION_SUSPEND = 4,
	HIBERNATION_TEST_RESUME = 5,
	__HIBERNATION_AFTER_LAST = 6,
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

struct cma {
	unsigned long base_pfn;
	unsigned long count;
	unsigned long *bitmap;
	unsigned int order_per_bit;
	spinlock_t lock;
	char name[64];
	bool reserve_pages_on_error;
};

enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE = 0,
	NOHZ_MODE_LOWRES = 1,
	NOHZ_MODE_HIGHRES = 2,
};

struct tick_sched {
	unsigned int inidle: 1;
	unsigned int tick_stopped: 1;
	unsigned int idle_active: 1;
	unsigned int do_timer_last: 1;
	unsigned int got_idle_tick: 1;
	unsigned int stalled_jiffies;
	unsigned long last_tick_jiffies;
	struct hrtimer sched_timer;
	ktime_t last_tick;
	ktime_t next_tick;
	unsigned long idle_jiffies;
	ktime_t idle_waketime;
	seqcount_t idle_sleeptime_seq;
	ktime_t idle_entrytime;
	enum tick_nohz_mode nohz_mode;
	unsigned long last_jiffies;
	u64 timer_expires_base;
	u64 timer_expires;
	u64 next_timer;
	ktime_t idle_expires;
	unsigned long idle_calls;
	unsigned long idle_sleeps;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	atomic_t tick_dep_mask;
	unsigned long check_clocks;
};

enum rdmacg_resource_type {
	RDMACG_RESOURCE_HCA_HANDLE = 0,
	RDMACG_RESOURCE_HCA_OBJECT = 1,
	RDMACG_RESOURCE_MAX = 2,
};

enum rdmacg_file_type {
	RDMACG_RESOURCE_TYPE_MAX = 0,
	RDMACG_RESOURCE_TYPE_STAT = 1,
};

struct rdmacg_resource {
	int max;
	int usage;
};

struct rdmacg_resource_pool {
	struct rdmacg_device *device;
	struct rdmacg_resource resources[2];
	struct list_head cg_node;
	struct list_head dev_node;
	u64 usage_sum;
	int num_max_cnt;
};

struct idmap_key {
	bool map_up;
	u32 id;
	u32 count;
};

struct trace_export {
	struct trace_export __attribute__((btf_type_tag("rcu"))) *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char *saved_cmdlines;
};

struct ftrace_stack {
	unsigned long calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
	ETT_EVENT_EPROBE = 64,
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
	EVENT_FILE_FL_FREED_BIT = 11,
};

enum die_val {
	DIE_UNUSED = 0,
	DIE_OOPS = 1,
};

struct err_info {
	const char **errs;
	u8 type;
	u16 pos;
	u64 ts;
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char *cmd;
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

struct func_repeats_entry {
	struct trace_entry ent;
	unsigned long ip;
	unsigned long parent_ip;
	u16 count;
	u16 top_delta_ts;
	u32 bottom_delta_ts;
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct partial_page;

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	unsigned long private;
};

struct print_entry {
	struct trace_entry ent;
	unsigned long ip;
	char buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	unsigned long ip;
	const char *str;
};

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

struct ftrace_entry {
	struct trace_entry ent;
	unsigned long ip;
	unsigned long parent_ip;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	unsigned long caller[0];
};

struct bprint_entry {
	struct trace_entry ent;
	unsigned long ip;
	const char *fmt;
	u32 buf[0];
};

struct trace_min_max_param {
	struct mutex *lock;
	u64 *val;
	u64 *min;
	u64 *max;
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int read;
};

struct bpf_mprog_cp {
	struct bpf_link *link;
};

struct bpf_mprog_bundle {
	struct bpf_mprog_entry a;
	struct bpf_mprog_entry b;
	struct bpf_mprog_cp cp_items[64];
	struct bpf_prog *ref;
	atomic64_t revision;
	u32 count;
};

struct bpf_tuple {
	struct bpf_prog *prog;
	struct bpf_link *link;
};

struct cgroup_lsm_atype {
	u32 attach_btf_id;
	int refcnt;
};

enum {
	BPF_F_SYSCTL_BASE_NAME = 1,
};

typedef u64 (*btf_bpf_get_local_storage)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_retval)();

typedef u64 (*btf_bpf_set_retval)(int);

typedef u64 (*btf_bpf_sysctl_get_name)(struct bpf_sysctl_kern *, char *, size_t, u64);

typedef u64 (*btf_bpf_sysctl_get_current_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_get_new_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_set_new_value)(struct bpf_sysctl_kern *, const char *, size_t);

typedef u64 (*btf_bpf_get_netns_cookie_sockopt)(struct bpf_sockopt_kern *);

struct bpf_cgroup_link;

struct bpf_prog_list {
	struct hlist_node node;
	struct bpf_prog *prog;
	struct bpf_cgroup_link *link;
	struct bpf_cgroup_storage *storage[2];
};

struct bpf_cgroup_link {
	struct bpf_link link;
	struct cgroup *cgroup;
	enum bpf_attach_type type;
};

struct bpf_cg_run_ctx {
	struct bpf_run_ctx run_ctx;
	const struct bpf_prog_array_item *prog_item;
	int retval;
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

struct bpf_sockopt_buf {
	u8 data[32];
};

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, unsigned long, unsigned long, unsigned long, int, bool);

typedef void (*btf_trace_mark_victim)(void *, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short oom_score_adj;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	unsigned long reclaimable;
	unsigned long available;
	unsigned long min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_mark_victim {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_compact_retry {};

struct memory_dev_type;

struct node_memory_type_map {
	struct memory_dev_type *memtype;
	int map_count;
};

struct memory_dev_type {
	struct list_head tier_sibling;
	struct list_head list;
	int adistance;
	nodemask_t nodes;
	struct kref kref;
};

struct demotion_nodes {
	nodemask_t preferred;
};

struct node_hmem_attrs {
	unsigned int read_bandwidth;
	unsigned int write_bandwidth;
	unsigned int read_latency;
	unsigned int write_latency;
};

struct stat {
	unsigned long st_dev;
	unsigned long st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	unsigned int st_uid;
	unsigned int st_gid;
	unsigned long st_rdev;
	unsigned long __pad1;
	long st_size;
	int st_blksize;
	int __pad2;
	long st_blocks;
	long st_atime;
	unsigned long st_atime_nsec;
	long st_mtime;
	unsigned long st_mtime_nsec;
	long st_ctime;
	unsigned long st_ctime_nsec;
	unsigned int __unused4;
	unsigned int __unused5;
};

typedef u64 compat_u64;

typedef s64 compat_s64;

struct stat64 {
	compat_u64 st_dev;
	unsigned char __pad0[4];
	compat_ulong_t __st_ino;
	compat_uint_t st_mode;
	compat_uint_t st_nlink;
	compat_ulong_t st_uid;
	compat_ulong_t st_gid;
	compat_u64 st_rdev;
	unsigned char __pad3[4];
	compat_s64 st_size;
	compat_ulong_t st_blksize;
	compat_u64 st_blocks;
	compat_ulong_t st_atime;
	compat_ulong_t st_atime_nsec;
	compat_ulong_t st_mtime;
	compat_ulong_t st_mtime_nsec;
	compat_ulong_t st_ctime;
	compat_ulong_t st_ctime_nsec;
	compat_u64 st_ino;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u32 stx_dio_mem_align;
	__u32 stx_dio_offset_align;
	__u64 __spare3[12];
};

typedef u32 compat_dev_t;

typedef u32 compat_ino_t;

typedef u16 __compat_uid16_t;

typedef u16 __compat_gid16_t;

struct compat_stat {
	compat_dev_t st_dev;
	compat_ino_t st_ino;
	compat_mode_t st_mode;
	compat_ushort_t st_nlink;
	__compat_uid16_t st_uid;
	__compat_gid16_t st_gid;
	compat_dev_t st_rdev;
	compat_off_t st_size;
	compat_off_t st_blksize;
	compat_off_t st_blocks;
	old_time32_t st_atime;
	compat_ulong_t st_atime_nsec;
	old_time32_t st_mtime;
	compat_ulong_t st_mtime_nsec;
	old_time32_t st_ctime;
	compat_ulong_t st_ctime_nsec;
	compat_ulong_t __unused4[2];
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lock *, struct file_lock *);

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	unsigned long i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	unsigned long i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_pid;
	unsigned int fl_flags;
	unsigned char fl_type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lock *fl;
	unsigned long i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned long fl_break_time;
	unsigned long fl_downgrade_time;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	unsigned long i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct flock64 {
	short l_type;
	short l_whence;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_leases_conflict {};

struct locks_iterator {
	int li_cpu;
	loff_t li_pos;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

struct ext4_attr {
	struct attribute attr;
	short attr_id;
	short attr_ptr;
	unsigned short attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_sra_exceeded_retry_limit = 5,
	attr_inode_readahead = 6,
	attr_trigger_test_error = 7,
	attr_first_error_time = 8,
	attr_last_error_time = 9,
	attr_feature = 10,
	attr_pointer_ui = 11,
	attr_pointer_ul = 12,
	attr_pointer_u64 = 13,
	attr_pointer_u8 = 14,
	attr_pointer_string = 15,
	attr_pointer_atomic = 16,
	attr_journal_task = 17,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
};

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	unsigned long head_block;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

enum hugetlbfs_size_type {
	NO_SIZE = 0,
	SIZE_STD = 1,
	SIZE_PERCENT = 2,
};

enum hugetlb_param {
	Opt_gid___4 = 0,
	Opt_min_size = 1,
	Opt_mode___3 = 2,
	Opt_nr_inodes = 3,
	Opt_pagesize = 4,
	Opt_size = 5,
	Opt_uid___4 = 6,
};

struct hugetlbfs_inode_info {
	struct inode vfs_inode;
	unsigned int seals;
};

struct resv_map {
	struct kref refs;
	spinlock_t lock;
	struct list_head regions;
	long adds_in_progress;
	struct list_head region_cache;
	long region_cache_count;
	struct rw_semaphore rw_sema;
	struct page_counter *reservation_counter;
	unsigned long pages_per_hpage;
	struct cgroup_subsys_state *css;
};

struct hugetlb_vma_lock {
	struct kref refs;
	struct rw_semaphore rw_sema;
	struct vm_area_struct *vma;
};

struct hugetlbfs_fs_context {
	struct hstate *hstate;
	unsigned long long max_size_opt;
	unsigned long long min_size_opt;
	long max_hpages;
	long nr_inodes;
	long min_hpages;
	enum hugetlbfs_size_type max_val_type;
	enum hugetlbfs_size_type min_val_type;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

typedef void (*btf_trace_nlmclnt_test)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_lock)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_unlock)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_grant)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

struct trace_event_raw_nlmclnt_lock_event {
	struct trace_entry ent;
	u32 oh;
	u32 svid;
	u32 fh;
	unsigned long status;
	u64 start;
	u64 len;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_data_offsets_nlmclnt_lock_event {
	u32 addr;
};

enum {
	Opt_uid___5 = 0,
	Opt_gid___5 = 1,
	Opt_mode___4 = 2,
	Opt_err___5 = 3,
};

struct debugfs_cancellation {
	struct list_head list;
	void (*cancel)(struct dentry *, void *);
	void *cancel_data;
};

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	union {
		debugfs_automount_t automount;
		struct {
			refcount_t active_users;
			struct completion active_users_drained;
			struct mutex cancellations_mtx;
			struct list_head cancellations;
		};
	};
};

struct debugfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

struct debugfs_fs_info {
	struct debugfs_mount_opts mount_opts;
};

enum key_lookup_flag {
	KEY_LOOKUP_CREATE = 1,
	KEY_LOOKUP_PARTIAL = 2,
	KEY_LOOKUP_ALL = 3,
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char __attribute__((btf_type_tag("user"))) *hashname;
	char __attribute__((btf_type_tag("user"))) *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct drbg_state;

struct drbg_state_ops {
	int (*update)(struct drbg_state *, struct list_head *, int);
	int (*generate)(struct drbg_state *, unsigned char *, unsigned int, struct list_head *);
	int (*crypto_init)(struct drbg_state *);
	int (*crypto_fini)(struct drbg_state *);
};

enum drbg_seed_state {
	DRBG_SEED_STATE_UNSEEDED = 0,
	DRBG_SEED_STATE_PARTIAL = 1,
	DRBG_SEED_STATE_FULL = 2,
};

struct drbg_string {
	const unsigned char *buf;
	size_t len;
	struct list_head list;
};

struct skcipher_request;

struct drbg_core;

struct drbg_state {
	struct mutex drbg_mutex;
	unsigned char *V;
	unsigned char *Vbuf;
	unsigned char *C;
	unsigned char *Cbuf;
	size_t reseed_ctr;
	size_t reseed_threshold;
	unsigned char *scratchpad;
	unsigned char *scratchpadbuf;
	void *priv_data;
	struct crypto_skcipher *ctr_handle;
	struct skcipher_request *ctr_req;
	__u8 *outscratchpadbuf;
	__u8 *outscratchpad;
	struct crypto_wait ctr_wait;
	struct scatterlist sg_in;
	struct scatterlist sg_out;
	enum drbg_seed_state seeded;
	unsigned long last_seed_time;
	bool pr;
	bool fips_primed;
	unsigned char *prev;
	struct crypto_rng *jent;
	const struct drbg_state_ops *d_ops;
	const struct drbg_core *core;
	struct drbg_string test_data;
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	void *__ctx[0];
};

typedef uint32_t drbg_flag_t;

struct drbg_core {
	drbg_flag_t flags;
	__u8 statelen;
	__u8 blocklen_bytes;
	char cra_name[128];
	char backend_cra_name[128];
};

enum drbg_prefixes {
	DRBG_PREFIX0 = 0,
	DRBG_PREFIX1 = 1,
	DRBG_PREFIX2 = 2,
	DRBG_PREFIX3 = 3,
};

struct sdesc {
	struct shash_desc shash;
	char ctx[0];
};

struct uuidcmp {
	const char *uuid;
	int len;
};

struct io_rsrc_update {
	struct file *file;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct io_uring_rsrc_update2 {
	__u32 offset;
	__u32 resv;
	__u64 data;
	__u64 tags;
	__u32 nr;
	__u32 resv2;
};

struct io_uring_rsrc_register {
	__u32 nr;
	__u32 flags;
	__u64 resv2;
	__u64 data;
	__u64 tags;
};

struct v2m_data {
	struct list_head entry;
	struct fwnode_handle *fwnode;
	struct resource res;
	void *base;
	u32 spi_start;
	u32 nr_spis;
	u32 spi_offset;
	unsigned long *bm;
	u32 flags;
};

struct acpi_madt_generic_msi_frame {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 msi_frame_id;
	u64 base_address;
	u32 flags;
	u16 spi_count;
	u16 spi_base;
};

struct pdc_pin_region {
	u32 pin_base;
	u32 parent_base;
	u32 cnt;
};

enum pdc_irq_config_bits {
	PDC_LEVEL_LOW = 0,
	PDC_EDGE_FALLING = 2,
	PDC_LEVEL_HIGH = 4,
	PDC_EDGE_RISING = 6,
	PDC_EDGE_DUAL = 7,
};

enum {
	ARB_TIMER = 0,
	ARB_BP_CAP_CLR = 1,
	ARB_BP_CAP_HI_ADDR = 2,
	ARB_BP_CAP_ADDR = 3,
	ARB_BP_CAP_STATUS = 4,
	ARB_BP_CAP_MASTER = 5,
	ARB_ERR_CAP_CLR = 6,
	ARB_ERR_CAP_HI_ADDR = 7,
	ARB_ERR_CAP_ADDR = 8,
	ARB_ERR_CAP_STATUS = 9,
	ARB_ERR_CAP_MASTER = 10,
};

struct brcmstb_gisb_arb_device {
	void *base;
	const int *gisb_offsets;
	bool big_endian;
	struct mutex lock;
	struct list_head next;
	u32 valid_mask;
	const char *master_names[32];
	u32 saved_timeout;
};

struct sun4i_usb_phy_cfg {
	int num_phys;
	int hsic_index;
	u32 disc_thresh;
	u32 hci_phy_ctl_clear;
	u8 phyctl_offset;
	bool dedicated_clocks;
	bool phy0_dual_route;
	bool needs_phy2_siddq;
	bool siddq_in_base;
	bool poll_vbusen;
	int missing_phys;
};

struct sun4i_usb_phy {
	struct phy *phy;
	void *pmu;
	struct regulator *vbus;
	struct reset_control *reset;
	struct clk *clk;
	struct clk *clk2;
	bool regulator_on;
	int index;
};

struct sun4i_usb_phy_data {
	void *base;
	const struct sun4i_usb_phy_cfg *cfg;
	enum usb_dr_mode dr_mode;
	spinlock_t reg_lock;
	struct sun4i_usb_phy phys[4];
	struct extcon_dev *extcon;
	bool phy0_init;
	struct gpio_desc *id_det_gpio;
	struct gpio_desc *vbus_det_gpio;
	struct power_supply *vbus_power_supply;
	struct notifier_block vbus_power_nb;
	bool vbus_power_nb_registered;
	bool force_session_end;
	int id_det_irq;
	int vbus_det_irq;
	int id_det;
	int vbus_det;
	struct delayed_work detect;
};

struct rcar_gen3_phy {
	struct phy *phy;
	spinlock_t lock;
	void *base;
};

struct msm_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctrl;
	struct gpio_chip chip;
	struct pinctrl_desc desc;
	struct notifier_block restart_nb;
	int irq;
	bool intr_target_use_scm;
	raw_spinlock_t lock;
	unsigned long dual_edge_irqs[5];
	unsigned long enabled_irqs[5];
	unsigned long skip_wake_irqs[5];
	unsigned long disabled_for_mux[5];
	unsigned long ever_gpio[5];
	const struct msm_pinctrl_soc_data *soc;
	void *regs[4];
	u32 phys_base[4];
};

enum {
	PINMUX_TYPE_NONE = 0,
	PINMUX_TYPE_FUNCTION = 1,
	PINMUX_TYPE_GPIO = 2,
	PINMUX_TYPE_OUTPUT = 3,
	PINMUX_TYPE_INPUT = 4,
};

struct sh_pfc_pin_config;

struct sh_pfc_pinctrl {
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctl_desc;
	struct sh_pfc *pfc;
	struct pinctrl_pin_desc *pins;
	struct sh_pfc_pin_config *configs;
};

struct sh_pfc_pin_config {
	u16 gpio_enabled: 1;
	u16 mux_mark: 15;
};

enum of_gpio_flags {
	OF_GPIO_ACTIVE_LOW = 1,
	OF_GPIO_SINGLE_ENDED = 2,
	OF_GPIO_OPEN_DRAIN = 4,
	OF_GPIO_TRANSITORY = 8,
	OF_GPIO_PULL_UP = 16,
	OF_GPIO_PULL_DOWN = 32,
	OF_GPIO_PULL_DISABLE = 64,
};

typedef struct gpio_desc * (*of_find_gpio_quirk)(struct device_node *, const char *, unsigned int, enum of_gpio_flags *);

struct of_rename_gpio {
	const char *con_id;
	const char *legacy_id;
	const char *compatible;
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_PULL_DISABLE = 64,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

struct of_mm_gpio_chip {
	struct gpio_chip gc;
	void (*save_regs)(struct of_mm_gpio_chip *);
	void *regs;
};

struct pcie_pme_service_data {
	spinlock_t lock;
	struct pcie_device *srv;
	struct work_struct work;
	bool noirq;
};

struct tegra_pcie_port_soc;

struct tegra_pcie_soc {
	unsigned int num_ports;
	const struct tegra_pcie_port_soc *ports;
	unsigned int msi_base_shift;
	unsigned long afi_pex2_ctrl;
	u32 pads_pll_ctl;
	u32 tx_ref_sel;
	u32 pads_refclk_cfg0;
	u32 pads_refclk_cfg1;
	u32 update_fc_threshold;
	bool has_pex_clkreq_en;
	bool has_pex_bias_ctrl;
	bool has_intr_prsnt_sense;
	bool has_cml_clk;
	bool has_gen2;
	bool force_pca_enable;
	bool program_uphy;
	bool update_clamp_threshold;
	bool program_deskew_time;
	bool update_fc_timer;
	bool has_cache_bars;
	struct {
		struct {
			u32 rp_ectl_2_r1;
			u32 rp_ectl_4_r1;
			u32 rp_ectl_5_r1;
			u32 rp_ectl_6_r1;
			u32 rp_ectl_2_r2;
			u32 rp_ectl_4_r2;
			u32 rp_ectl_5_r2;
			u32 rp_ectl_6_r2;
		} regs;
		bool enable;
	} ectl;
};

struct tegra_pcie_port_soc {
	struct {
		u8 turnoff_bit;
		u8 ack_bit;
	} pme;
};

struct tegra_pcie;

struct tegra_pcie_port {
	struct tegra_pcie *pcie;
	struct device_node *np;
	struct list_head list;
	struct resource regs;
	void *base;
	unsigned int index;
	unsigned int lanes;
	struct phy **phys;
	struct gpio_desc *reset_gpio;
};

struct tegra_msi {
	unsigned long used[4];
	struct irq_domain *domain;
	struct mutex map_lock;
	spinlock_t mask_lock;
	void *virt;
	dma_addr_t phys;
	int irq;
};

struct tegra_pcie {
	struct device *dev;
	void *pads;
	void *afi;
	void *cfg;
	int irq;
	struct resource cs;
	struct clk *pex_clk;
	struct clk *afi_clk;
	struct clk *pll_e;
	struct clk *cml_clk;
	struct reset_control *pex_rst;
	struct reset_control *afi_rst;
	struct reset_control *pcie_xrst;
	bool legacy_phy;
	struct phy *phy;
	struct tegra_msi msi;
	struct list_head ports;
	u32 xbar_config;
	struct regulator_bulk_data *supplies;
	unsigned int num_supplies;
	const struct tegra_pcie_soc *soc;
	struct dentry *debugfs;
};

struct tegra194_pcie_ecam {
	void *config_base;
	void *iatu_base;
	void *dbi_base;
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct fb_event {
	struct fb_info *info;
	void *data;
};

enum acpi_irq_model_id {
	ACPI_IRQ_MODEL_PIC = 0,
	ACPI_IRQ_MODEL_IOAPIC = 1,
	ACPI_IRQ_MODEL_IOSAPIC = 2,
	ACPI_IRQ_MODEL_PLATFORM = 3,
	ACPI_IRQ_MODEL_GIC = 4,
	ACPI_IRQ_MODEL_LPIC = 5,
	ACPI_IRQ_MODEL_COUNT = 6,
};

struct acpi_pci_link_irq {
	u32 active;
	u8 triggering;
	u8 polarity;
	u8 resource_type;
	u8 possible_count;
	u32 possible[16];
	u8 initialized: 1;
	u8 reserved: 7;
};

struct acpi_pci_link {
	struct list_head list;
	struct acpi_device *device;
	struct acpi_pci_link_irq irq;
	int refcnt;
};

enum {
	AML_FIELD_UPDATE_PRESERVE = 0,
	AML_FIELD_UPDATE_WRITE_AS_ONES = 32,
	AML_FIELD_UPDATE_WRITE_AS_ZEROS = 64,
};

struct acpi_address_range {
	struct acpi_address_range *next;
	struct acpi_namespace_node *region_node;
	acpi_physical_address start_address;
	acpi_physical_address end_address;
};

struct acpi_interface_info {
	char *name;
	struct acpi_interface_info *next;
	u8 flags;
	u8 value;
};

typedef u32 (*acpi_interface_handler)(acpi_string, u32);

struct acpi_pld_info {
	u8 revision;
	u8 ignore_color;
	u8 red;
	u8 green;
	u8 blue;
	u16 width;
	u16 height;
	u8 user_visible;
	u8 dock;
	u8 lid;
	u8 panel;
	u8 vertical_position;
	u8 horizontal_position;
	u8 shape;
	u8 group_orientation;
	u8 group_token;
	u8 group_position;
	u8 bay;
	u8 ejectable;
	u8 ospm_eject_required;
	u8 cabinet_number;
	u8 card_cage_number;
	u8 reference;
	u8 rotation;
	u8 order;
	u8 reserved;
	u16 vertical_offset;
	u16 horizontal_offset;
};

enum acpi_cedt_type {
	ACPI_CEDT_TYPE_CHBS = 0,
	ACPI_CEDT_TYPE_CFMWS = 1,
	ACPI_CEDT_TYPE_CXIMS = 2,
	ACPI_CEDT_TYPE_RDPAS = 3,
	ACPI_CEDT_TYPE_RESERVED = 4,
};

struct acpi_table_srat {
	struct acpi_table_header header;
	u32 table_revision;
	u64 reserved;
};

struct acpi_srat_cpu_affinity {
	struct acpi_subtable_header header;
	u8 proximity_domain_lo;
	u8 apic_id;
	u32 flags;
	u8 local_sapic_eid;
	u8 proximity_domain_hi[3];
	u32 clock_domain;
};

struct acpi_srat_mem_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u16 reserved;
	u64 base_address;
	u64 length;
	u32 reserved1;
	u32 flags;
	u64 reserved2;
} __attribute__((packed));

struct acpi_srat_x2apic_cpu_affinity {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 proximity_domain;
	u32 apic_id;
	u32 flags;
	u32 clock_domain;
	u32 reserved2;
};

struct acpi_srat_gicc_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u32 acpi_processor_uid;
	u32 flags;
	u32 clock_domain;
} __attribute__((packed));

struct acpi_srat_generic_affinity {
	struct acpi_subtable_header header;
	u8 reserved;
	u8 device_handle_type;
	u32 proximity_domain;
	u8 device_handle[16];
	u32 flags;
	u32 reserved1;
};

struct acpi_table_slit {
	struct acpi_table_header header;
	u64 locality_count;
	u8 entry[0];
} __attribute__((packed));

struct acpi_cedt_cfmws {
	struct acpi_cedt_header header;
	u32 reserved1;
	u64 base_hpa;
	u64 window_size;
	u8 interleave_ways;
	u8 interleave_arithmetic;
	u16 reserved2;
	u32 granularity;
	u16 restrictions;
	u16 qtg_id;
	u32 interleave_targets[0];
} __attribute__((packed));

typedef int (*acpi_tbl_entry_handler_arg)(union acpi_subtable_headers *, void *, const unsigned long);

struct acpi_subtable_proc {
	int id;
	acpi_tbl_entry_handler handler;
	acpi_tbl_entry_handler_arg handler_arg;
	void *arg;
	int count;
};

struct apei_resources {
	struct list_head iomem;
	struct list_head ioport;
};

struct apei_res {
	struct list_head list;
	unsigned long start;
	unsigned long end;
};

struct apei_exec_ins_type;

struct acpi_whea_header;

struct apei_exec_context {
	u32 ip;
	u64 value;
	u64 var1;
	u64 var2;
	u64 src_base;
	u64 dst_base;
	struct apei_exec_ins_type *ins_table;
	u32 instructions;
	struct acpi_whea_header *action_table;
	u32 entries;
};

typedef int (*apei_exec_ins_func_t)(struct apei_exec_context *, struct acpi_whea_header *);

struct apei_exec_ins_type {
	u32 flags;
	apei_exec_ins_func_t run;
};

struct acpi_whea_header {
	u8 action;
	u8 instruction;
	u8 flags;
	u8 reserved;
	struct acpi_generic_address register_region;
	u64 value;
	u64 mask;
};

typedef int (*apei_exec_entry_func_t)(struct apei_exec_context *, struct acpi_whea_header *, void *);

struct clk_plldig {
	struct clk_hw hw;
	void *regs;
	unsigned int vco_freq;
};

struct owl_divider_hw {
	u32 reg;
	u8 shift;
	u8 width;
	u8 div_flags;
	struct clk_div_table *table;
};

struct owl_clk_common {
	struct regmap *regmap;
	struct clk_hw hw;
};

struct owl_divider {
	struct owl_divider_hw div_hw;
	struct owl_clk_common common;
};

struct owl_clk_desc {
	struct owl_clk_common **clks;
	unsigned long num_clks;
	struct clk_hw_onecell_data *hw_clks;
	const struct owl_reset_map *resets;
	unsigned long num_resets;
	struct regmap *regmap;
};

struct clk_pll_table;

struct owl_pll_hw {
	u32 reg;
	u32 bfreq;
	u8 bit_idx;
	u8 shift;
	u8 width;
	u8 min_mul;
	u8 max_mul;
	u8 delay;
	const struct clk_pll_table *table;
};

struct owl_pll {
	struct owl_pll_hw pll_hw;
	struct owl_clk_common common;
};

struct clk_pll_table {
	unsigned int val;
	unsigned long rate;
};

struct owl_mux_hw {
	u32 reg;
	u8 shift;
	u8 width;
};

struct owl_mux {
	struct owl_mux_hw mux_hw;
	struct owl_clk_common common;
};

struct owl_gate_hw {
	u32 reg;
	u8 bit_idx;
	u8 gate_flags;
};

struct owl_gate {
	struct owl_gate_hw gate_hw;
	struct owl_clk_common common;
};

struct clk_factor_table;

struct owl_factor_hw {
	u32 reg;
	u8 shift;
	u8 width;
	u8 fct_flags;
	struct clk_factor_table *table;
};

union owl_rate {
	struct owl_divider_hw div_hw;
	struct owl_factor_hw factor_hw;
	struct clk_fixed_factor fix_fact_hw;
};

struct owl_composite {
	struct owl_mux_hw mux_hw;
	struct owl_gate_hw gate_hw;
	union owl_rate rate;
	const struct clk_ops *fix_fact_ops;
	struct owl_clk_common common;
};

struct clk_factor_table {
	unsigned int val;
	unsigned int mul;
	unsigned int div;
};

struct meson_clk_dualdiv_data {
	struct parm n1;
	struct parm n2;
	struct parm m1;
	struct parm m2;
	struct parm dual;
	const struct meson_clk_dualdiv_param *table;
};

enum clk_ids___4 {
	LAST_DT_CORE_CLK___4 = 46,
	CLK_EXTAL___4 = 47,
	CLK_EXTALR___4 = 48,
	CLK_MAIN___4 = 49,
	CLK_PLL0___3 = 50,
	CLK_PLL1___4 = 51,
	CLK_PLL2___2 = 52,
	CLK_PLL3___3 = 53,
	CLK_PLL4___2 = 54,
	CLK_PLL1_DIV2___4 = 55,
	CLK_PLL1_DIV4___3 = 56,
	CLK_S0___2 = 57,
	CLK_S1___3 = 58,
	CLK_S2___2 = 59,
	CLK_S3___3 = 60,
	CLK_SDSRC___3 = 61,
	CLK_RPCSRC___3 = 62,
	CLK_RINT___2 = 63,
	MOD_CLK_BASE___4 = 64,
};

struct sprd_clk_desc {
	struct sprd_clk_common **clk_clks;
	unsigned long num_clk_clks;
	struct clk_hw_onecell_data *hw_clks;
};

struct sprd_div_internal {
	s32 offset;
	u8 shift;
	u8 width;
};

struct sprd_comp {
	struct sprd_mux_ssel mux;
	struct sprd_div_internal div;
	struct sprd_clk_common common;
};

struct sprd_div {
	struct sprd_div_internal div;
	struct sprd_clk_common common;
};

struct cpu_clk_suspend_context___2 {
	u32 clk_csite_src;
	u32 cclkg_burst;
	u32 cclkg_divider;
};

struct visconti_pll_rate_table;

struct visconti_pll_info {
	unsigned int id;
	const char *name;
	const char *parent;
	unsigned long base_reg;
	const struct visconti_pll_rate_table *rate_table;
};

struct visconti_pll_rate_table {
	unsigned long rate;
	unsigned int dacen;
	unsigned int dsmen;
	unsigned int refdiv;
	unsigned long intin;
	unsigned long fracin;
	unsigned int postdiv1;
	unsigned int postdiv2;
};

struct visconti_pll_provider {
	void *reg_base;
	struct device_node *node;
	struct clk_hw_onecell_data clk_data;
};

enum topology_type {
	TYPE_INVALID = 0,
	TYPE_MUX = 1,
	TYPE_PLL = 2,
	TYPE_FIXEDFACTOR = 3,
	TYPE_DIV1 = 4,
	TYPE_DIV2 = 5,
	TYPE_GATE = 6,
};

enum pm_query_id {
	PM_QID_INVALID = 0,
	PM_QID_CLOCK_GET_NAME = 1,
	PM_QID_CLOCK_GET_TOPOLOGY = 2,
	PM_QID_CLOCK_GET_FIXEDFACTOR_PARAMS = 3,
	PM_QID_CLOCK_GET_PARENTS = 4,
	PM_QID_CLOCK_GET_ATTRIBUTES = 5,
	PM_QID_PINCTRL_GET_NUM_PINS = 6,
	PM_QID_PINCTRL_GET_NUM_FUNCTIONS = 7,
	PM_QID_PINCTRL_GET_NUM_FUNCTION_GROUPS = 8,
	PM_QID_PINCTRL_GET_FUNCTION_NAME = 9,
	PM_QID_PINCTRL_GET_FUNCTION_GROUPS = 10,
	PM_QID_PINCTRL_GET_PIN_GROUPS = 11,
	PM_QID_CLOCK_GET_NUM_CLOCKS = 12,
	PM_QID_CLOCK_GET_MAX_DIVISOR = 13,
};

struct zynqmp_clk_divider {
	struct clk_hw hw;
	u8 flags;
	bool is_frac;
	u32 clk_id;
	u32 div_type;
	u16 max_div;
};

struct zynqmp_pm_query_data {
	u32 qid;
	u32 arg1;
	u32 arg2;
	u32 arg3;
};

struct admac_data;

struct admac_tx;

struct admac_chan {
	unsigned int no;
	struct admac_data *host;
	struct dma_chan chan;
	struct tasklet_struct tasklet;
	u32 carveout;
	spinlock_t lock;
	struct admac_tx *current_tx;
	int nperiod_acks;
	struct list_head submitted;
	struct list_head issued;
	struct list_head to_free;
};

struct admac_sram {
	u32 size;
	u32 allocated;
};

struct admac_data {
	struct dma_device dma;
	struct device *dev;
	void *base;
	struct reset_control *rstc;
	struct mutex cache_alloc_lock;
	struct admac_sram txcache;
	struct admac_sram rxcache;
	int irq;
	int irq_index;
	int nchannels;
	struct admac_chan channels[0];
};

struct admac_tx {
	struct dma_async_tx_descriptor tx;
	bool cyclic;
	dma_addr_t buf_addr;
	dma_addr_t buf_end;
	size_t buf_len;
	size_t period_len;
	size_t submitted_pos;
	size_t reclaimed_pos;
	struct list_head node;
};

struct hidma_dev;

struct hidma_desc;

struct hidma_chan {
	bool paused;
	bool allocated;
	char dbg_name[16];
	u32 dma_sig;
	dma_cookie_t last_success;
	struct hidma_dev *dmadev;
	struct hidma_desc *running;
	struct dma_chan chan;
	struct list_head free;
	struct list_head prepared;
	struct list_head queued;
	struct list_head active;
	struct list_head completed;
	spinlock_t lock;
};

struct hidma_lldev;

struct hidma_dev {
	int irq;
	int chidx;
	u32 nr_descriptors;
	int msi_virqbase;
	struct hidma_lldev *lldev;
	void *dev_trca;
	struct resource *trca_resource;
	void *dev_evca;
	struct resource *evca_resource;
	spinlock_t lock;
	struct dma_device ddev;
	struct dentry *debugfs;
	struct device_attribute *chid_attrs;
	struct tasklet_struct task;
};

struct hidma_tre;

struct hidma_lldev {
	bool msi_support;
	bool initialized;
	u8 trch_state;
	u8 evch_state;
	u8 chidx;
	u32 nr_tres;
	spinlock_t lock;
	struct hidma_tre *trepool;
	struct device *dev;
	void *trca;
	void *evca;
	struct hidma_tre **pending_tre_list;
	atomic_t pending_tre_count;
	void *tre_ring;
	dma_addr_t tre_dma;
	u32 tre_ring_size;
	u32 tre_processed_off;
	void *evre_ring;
	dma_addr_t evre_dma;
	u32 evre_ring_size;
	u32 evre_processed_off;
	u32 tre_write_offset;
	struct tasklet_struct task;
	struct {
		union {
			struct __kfifo kfifo;
			struct hidma_tre **type;
			const struct hidma_tre **const_type;
			char (*rectype)[0];
			struct hidma_tre **ptr;
			struct hidma_tre * const *ptr_const;
		};
		struct hidma_tre *buf[0];
	} handoff_fifo;
};

struct hidma_tre {
	atomic_t allocated;
	bool queued;
	u16 status;
	u32 idx;
	u32 dma_sig;
	const char *dev_name;
	void (*callback)(void *);
	void *data;
	struct hidma_lldev *lldev;
	u32 tre_local[9];
	u32 tre_index;
	u32 int_flags;
	u8 err_info;
	u8 err_code;
};

struct hidma_desc {
	struct dma_async_tx_descriptor desc;
	struct list_head node;
	u32 tre_ch;
};

enum tegra_platform {
	TEGRA_PLATFORM_SILICON = 0,
	TEGRA_PLATFORM_QT = 1,
	TEGRA_PLATFORM_SYSTEM_FPGA = 2,
	TEGRA_PLATFORM_UNIT_FPGA = 3,
	TEGRA_PLATFORM_ASIM_QT = 4,
	TEGRA_PLATFORM_ASIM_LINSIM = 5,
	TEGRA_PLATFORM_DSIM_ASIM_LINSIM = 6,
	TEGRA_PLATFORM_VERIFICATION_SIMULATION = 7,
	TEGRA_PLATFORM_VDK = 8,
	TEGRA_PLATFORM_VSP = 9,
	TEGRA_PLATFORM_MAX = 10,
};

enum {
	THRESHOLD_INDEX_0 = 0,
	THRESHOLD_INDEX_1 = 1,
	THRESHOLD_INDEX_COUNT = 2,
};

struct tegra_sku_info {
	int sku_id;
	int cpu_process_id;
	int cpu_speedo_id;
	int cpu_speedo_value;
	int cpu_iddq_value;
	int soc_process_id;
	int soc_speedo_id;
	int soc_speedo_value;
	int gpu_process_id;
	int gpu_speedo_id;
	int gpu_speedo_value;
	enum tegra_revision revision;
	enum tegra_platform platform;
};

struct tegra_cbb_error {
	const char *code;
	const char *source;
	const char *desc;
};

struct tegra194_cbb_aperture;

struct tegra194_cbb_userbits;

struct tegra194_cbb_noc_data {
	const char *name;
	bool erd_mask_inband_err;
	const char * const *master_id;
	unsigned int max_aperture;
	const struct tegra194_cbb_aperture *noc_aperture;
	const char * const *routeid_initflow;
	const char * const *routeid_targflow;
	void (*parse_routeid)(struct tegra194_cbb_aperture *, u64);
	void (*parse_userbits)(struct tegra194_cbb_userbits *, u32);
};

struct tegra194_cbb_aperture {
	u8 initflow;
	u8 targflow;
	u8 targ_subrange;
	u8 init_mapping;
	u32 init_localaddress;
	u8 targ_mapping;
	u32 targ_localaddress;
	u16 seqid;
};

struct tegra194_cbb_userbits {
	u8 axcache;
	u8 non_mod;
	u8 axprot;
	u8 falconsec;
	u8 grpsec;
	u8 vqc;
	u8 mstr_id;
	u8 axi_id;
};

struct tegra194_axi2apb_bridge;

struct tegra194_cbb {
	struct tegra_cbb base;
	const struct tegra194_cbb_noc_data *noc;
	struct resource *res;
	void *regs;
	unsigned int num_intr;
	unsigned int sec_irq;
	unsigned int nonsec_irq;
	u32 errlog0;
	u32 errlog1;
	u32 errlog2;
	u32 errlog3;
	u32 errlog4;
	u32 errlog5;
	struct tegra194_axi2apb_bridge *bridges;
	unsigned int num_bridges;
};

struct tegra194_axi2apb_bridge {
	struct resource res;
	void *base;
};

struct tegra194_cbb_packet_header {
	bool lock;
	u8 opc;
	u8 errcode;
	u16 len1;
	bool format;
};

struct scmi_power_proto_ops {
	int (*num_domains_get)(const struct scmi_protocol_handle *);
	const char * (*name_get)(const struct scmi_protocol_handle *, u32);
	int (*state_set)(const struct scmi_protocol_handle *, u32, u32);
	int (*state_get)(const struct scmi_protocol_handle *, u32, u32 *);
};

struct scmi_pm_domain {
	struct generic_pm_domain genpd;
	const struct scmi_protocol_handle *ph;
	const char *name;
	u32 domain;
};

struct rockchip_pmu_info;

struct rockchip_pmu {
	struct device *dev;
	struct regmap *regmap;
	const struct rockchip_pmu_info *info;
	struct mutex mutex;
	struct genpd_onecell_data genpd_data;
	struct generic_pm_domain *domains[0];
};

struct rockchip_domain_info;

struct rockchip_pmu_info {
	u32 pwr_offset;
	u32 status_offset;
	u32 req_offset;
	u32 idle_offset;
	u32 ack_offset;
	u32 mem_pwr_offset;
	u32 chain_status_offset;
	u32 mem_status_offset;
	u32 repair_status_offset;
	u32 core_pwrcnt_offset;
	u32 gpu_pwrcnt_offset;
	unsigned int core_power_transition_time;
	unsigned int gpu_power_transition_time;
	int num_domains;
	const struct rockchip_domain_info *domain_info;
};

struct rockchip_domain_info {
	const char *name;
	int pwr_mask;
	int status_mask;
	int req_mask;
	int idle_mask;
	int ack_mask;
	bool active_wakeup;
	int pwr_w_mask;
	int req_w_mask;
	int mem_status_mask;
	int repair_status_mask;
	u32 pwr_offset;
	u32 mem_offset;
	u32 req_offset;
};

struct rockchip_pm_domain {
	struct generic_pm_domain genpd;
	const struct rockchip_domain_info *info;
	struct rockchip_pmu *pmu;
	int num_qos;
	struct regmap **qos_regmap;
	u32 *qos_save_regs[5];
	int num_clks;
	struct clk_bulk_data *clks;
};

struct map_ring_valloc;

struct xenbus_ring_ops {
	int (*map)(struct xenbus_device *, struct map_ring_valloc *, grant_ref_t *, unsigned int, void **);
	int (*unmap)(struct xenbus_device *, void *);
};

struct xenbus_map_node;

struct map_ring_valloc {
	struct xenbus_map_node *node;
	unsigned long addrs[16];
	phys_addr_t phys_addrs[16];
	struct gnttab_map_grant_ref map[16];
	struct gnttab_unmap_grant_ref unmap[16];
	unsigned int idx;
};

struct xenbus_map_node {
	struct list_head next;
	union {
		struct {
			struct vm_struct *area;
		} pv;
		struct {
			struct page *pages[16];
			unsigned long addrs[16];
			void *addr;
		} hvm;
	};
	grant_handle_t handles[16];
	unsigned int nr_handles;
};

struct evtchn_alloc_unbound {
	domid_t dom;
	domid_t remote_dom;
	evtchn_port_t port;
};

struct unmap_ring_hvm {
	unsigned int idx;
	unsigned long addrs[16];
};

enum {
	AXP22X_DCDC1 = 0,
	AXP22X_DCDC2 = 1,
	AXP22X_DCDC3 = 2,
	AXP22X_DCDC4 = 3,
	AXP22X_DCDC5 = 4,
	AXP22X_DC1SW = 5,
	AXP22X_DC5LDO = 6,
	AXP22X_ALDO1 = 7,
	AXP22X_ALDO2 = 8,
	AXP22X_ALDO3 = 9,
	AXP22X_ELDO1 = 10,
	AXP22X_ELDO2 = 11,
	AXP22X_ELDO3 = 12,
	AXP22X_DLDO1 = 13,
	AXP22X_DLDO2 = 14,
	AXP22X_DLDO3 = 15,
	AXP22X_DLDO4 = 16,
	AXP22X_RTC_LDO = 17,
	AXP22X_LDO_IO0 = 18,
	AXP22X_LDO_IO1 = 19,
	AXP22X_REG_ID_MAX = 20,
};

enum {
	AXP15060_DCDC1 = 0,
	AXP15060_DCDC2 = 1,
	AXP15060_DCDC3 = 2,
	AXP15060_DCDC4 = 3,
	AXP15060_DCDC5 = 4,
	AXP15060_DCDC6 = 5,
	AXP15060_ALDO1 = 6,
	AXP15060_ALDO2 = 7,
	AXP15060_ALDO3 = 8,
	AXP15060_ALDO4 = 9,
	AXP15060_ALDO5 = 10,
	AXP15060_BLDO1 = 11,
	AXP15060_BLDO2 = 12,
	AXP15060_BLDO3 = 13,
	AXP15060_BLDO4 = 14,
	AXP15060_BLDO5 = 15,
	AXP15060_CLDO1 = 16,
	AXP15060_CLDO2 = 17,
	AXP15060_CLDO3 = 18,
	AXP15060_CLDO4 = 19,
	AXP15060_CPUSLDO = 20,
	AXP15060_SW = 21,
	AXP15060_RTC_LDO = 22,
	AXP15060_REG_ID_MAX = 23,
};

enum axp20x_variants {
	AXP152_ID = 0,
	AXP192_ID = 1,
	AXP202_ID = 2,
	AXP209_ID = 3,
	AXP221_ID = 4,
	AXP223_ID = 5,
	AXP288_ID = 6,
	AXP313A_ID = 7,
	AXP803_ID = 8,
	AXP806_ID = 9,
	AXP809_ID = 10,
	AXP813_ID = 11,
	AXP15060_ID = 12,
	NR_AXP20X_VARIANTS = 13,
};

enum {
	AXP20X_LDO1 = 0,
	AXP20X_LDO2 = 1,
	AXP20X_LDO3 = 2,
	AXP20X_LDO4 = 3,
	AXP20X_LDO5 = 4,
	AXP20X_DCDC2 = 5,
	AXP20X_DCDC3 = 6,
	AXP20X_REG_ID_MAX = 7,
};

enum {
	AXP313A_DCDC1 = 0,
	AXP313A_DCDC2 = 1,
	AXP313A_DCDC3 = 2,
	AXP313A_ALDO1 = 3,
	AXP313A_DLDO1 = 4,
	AXP313A_RTC_LDO = 5,
	AXP313A_REG_ID_MAX = 6,
};

enum {
	AXP803_DCDC1 = 0,
	AXP803_DCDC2 = 1,
	AXP803_DCDC3 = 2,
	AXP803_DCDC4 = 3,
	AXP803_DCDC5 = 4,
	AXP803_DCDC6 = 5,
	AXP803_DC1SW = 6,
	AXP803_ALDO1 = 7,
	AXP803_ALDO2 = 8,
	AXP803_ALDO3 = 9,
	AXP803_DLDO1 = 10,
	AXP803_DLDO2 = 11,
	AXP803_DLDO3 = 12,
	AXP803_DLDO4 = 13,
	AXP803_ELDO1 = 14,
	AXP803_ELDO2 = 15,
	AXP803_ELDO3 = 16,
	AXP803_FLDO1 = 17,
	AXP803_FLDO2 = 18,
	AXP803_RTC_LDO = 19,
	AXP803_LDO_IO0 = 20,
	AXP803_LDO_IO1 = 21,
	AXP803_REG_ID_MAX = 22,
};

enum {
	AXP806_DCDCA = 0,
	AXP806_DCDCB = 1,
	AXP806_DCDCC = 2,
	AXP806_DCDCD = 3,
	AXP806_DCDCE = 4,
	AXP806_ALDO1 = 5,
	AXP806_ALDO2 = 6,
	AXP806_ALDO3 = 7,
	AXP806_BLDO1 = 8,
	AXP806_BLDO2 = 9,
	AXP806_BLDO3 = 10,
	AXP806_BLDO4 = 11,
	AXP806_CLDO1 = 12,
	AXP806_CLDO2 = 13,
	AXP806_CLDO3 = 14,
	AXP806_SW = 15,
	AXP806_REG_ID_MAX = 16,
};

enum {
	AXP809_DCDC1 = 0,
	AXP809_DCDC2 = 1,
	AXP809_DCDC3 = 2,
	AXP809_DCDC4 = 3,
	AXP809_DCDC5 = 4,
	AXP809_DC1SW = 5,
	AXP809_DC5LDO = 6,
	AXP809_ALDO1 = 7,
	AXP809_ALDO2 = 8,
	AXP809_ALDO3 = 9,
	AXP809_ELDO1 = 10,
	AXP809_ELDO2 = 11,
	AXP809_ELDO3 = 12,
	AXP809_DLDO1 = 13,
	AXP809_DLDO2 = 14,
	AXP809_RTC_LDO = 15,
	AXP809_LDO_IO0 = 16,
	AXP809_LDO_IO1 = 17,
	AXP809_SW = 18,
	AXP809_REG_ID_MAX = 19,
};

enum {
	AXP813_DCDC1 = 0,
	AXP813_DCDC2 = 1,
	AXP813_DCDC3 = 2,
	AXP813_DCDC4 = 3,
	AXP813_DCDC5 = 4,
	AXP813_DCDC6 = 5,
	AXP813_DCDC7 = 6,
	AXP813_ALDO1 = 7,
	AXP813_ALDO2 = 8,
	AXP813_ALDO3 = 9,
	AXP813_DLDO1 = 10,
	AXP813_DLDO2 = 11,
	AXP813_DLDO3 = 12,
	AXP813_DLDO4 = 13,
	AXP813_ELDO1 = 14,
	AXP813_ELDO2 = 15,
	AXP813_ELDO3 = 16,
	AXP813_FLDO1 = 17,
	AXP813_FLDO2 = 18,
	AXP813_FLDO3 = 19,
	AXP813_RTC_LDO = 20,
	AXP813_LDO_IO0 = 21,
	AXP813_LDO_IO1 = 22,
	AXP813_SW = 23,
	AXP813_REG_ID_MAX = 24,
};

struct mt6357_regulator_info {
	struct regulator_desc desc;
	u32 da_vsel_reg;
	u32 da_vsel_mask;
};

enum {
	MT6357_ID_VCORE = 0,
	MT6357_ID_VMODEM = 1,
	MT6357_ID_VPA = 2,
	MT6357_ID_VPROC = 3,
	MT6357_ID_VS1 = 4,
	MT6357_ID_VAUX18 = 5,
	MT6357_ID_VAUD28 = 6,
	MT6357_ID_VCAMA = 7,
	MT6357_ID_VCAMD = 8,
	MT6357_ID_VCAMIO = 9,
	MT6357_ID_VCN18 = 10,
	MT6357_ID_VCN28 = 11,
	MT6357_ID_VCN33_BT = 12,
	MT6357_ID_VCN33_WIFI = 13,
	MT6357_ID_VDRAM = 14,
	MT6357_ID_VEFUSE = 15,
	MT6357_ID_VEMC = 16,
	MT6357_ID_VFE28 = 17,
	MT6357_ID_VIBR = 18,
	MT6357_ID_VIO18 = 19,
	MT6357_ID_VIO28 = 20,
	MT6357_ID_VLDO28 = 21,
	MT6357_ID_VMC = 22,
	MT6357_ID_VMCH = 23,
	MT6357_ID_VRF12 = 24,
	MT6357_ID_VRF18 = 25,
	MT6357_ID_VSIM1 = 26,
	MT6357_ID_VSIM2 = 27,
	MT6357_ID_VSRAM_OTHERS = 28,
	MT6357_ID_VSRAM_PROC = 29,
	MT6357_ID_VUSB33 = 30,
	MT6357_ID_VXO22 = 31,
	MT6357_ID_RG_MAX = 32,
};

struct uniphier_regulator_soc_data {
	int nclks;
	const char * const *clock_names;
	int nrsts;
	const char * const *reset_names;
	const struct regulator_desc *desc;
	const struct regmap_config *regconf;
};

struct uniphier_regulator_priv {
	struct clk_bulk_data clk[2];
	struct reset_control *rst[2];
	const struct uniphier_regulator_soc_data *data;
};

enum tty_flow_change {
	TTY_FLOW_NO_CHANGE = 0,
	TTY_THROTTLE_SAFE = 1,
	TTY_UNTHROTTLE_SAFE = 2,
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct termio {
	unsigned short c_iflag;
	unsigned short c_oflag;
	unsigned short c_cflag;
	unsigned short c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct owl_uart_port {
	struct uart_port port;
	struct clk *clk;
};

struct owl_uart_info {
	unsigned int tx_fifosize;
};

struct dart_io_pgtable {
	struct io_pgtable iop;
	int tbl_bits;
	int bits_per_level;
	void *pgd[4];
};

typedef u64 dart_iopte;

struct probe;

struct kobj_map {
	struct probe *probes[255];
	struct mutex *lock;
};

struct probe {
	struct probe *next;
	dev_t dev;
	unsigned long range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct regmap_irq_chip_data {
	struct mutex lock;
	struct irq_chip irq_chip;
	struct regmap *map;
	const struct regmap_irq_chip *chip;
	int irq_base;
	struct irq_domain *domain;
	int irq;
	int wake_count;
	void *status_reg_buf;
	unsigned int *main_status_buf;
	unsigned int *status_buf;
	unsigned int *mask_buf;
	unsigned int *mask_buf_def;
	unsigned int *wake_buf;
	unsigned int *type_buf;
	unsigned int *type_buf_def;
	unsigned int **config_buf;
	unsigned int irq_reg_stride;
	unsigned int (*get_irq_reg)(struct regmap_irq_chip_data *, unsigned int, int);
	unsigned int clear_status: 1;
};

struct dma_fence;

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	unsigned long flags;
	struct kref refcount;
	int error;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long (*wait)(struct dma_fence *, bool, long);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
	void (*set_deadline)(struct dma_fence *, ktime_t);
};

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	u32 timeline;
};

struct hisi_hba;

struct hisi_sas_device;

struct hisi_sas_dq;

struct hisi_sas_slot;

struct hisi_sas_hw {
	int (*hw_init)(struct hisi_hba *);
	int (*interrupt_preinit)(struct hisi_hba *);
	void (*setup_itct)(struct hisi_hba *, struct hisi_sas_device *);
	int (*slot_index_alloc)(struct hisi_hba *, struct domain_device *);
	struct hisi_sas_device * (*alloc_dev)(struct domain_device *);
	void (*sl_notify_ssp)(struct hisi_hba *, int);
	void (*start_delivery)(struct hisi_sas_dq *);
	void (*prep_ssp)(struct hisi_hba *, struct hisi_sas_slot *);
	void (*prep_smp)(struct hisi_hba *, struct hisi_sas_slot *);
	void (*prep_stp)(struct hisi_hba *, struct hisi_sas_slot *);
	void (*prep_abort)(struct hisi_hba *, struct hisi_sas_slot *);
	void (*phys_init)(struct hisi_hba *);
	void (*phy_start)(struct hisi_hba *, int);
	void (*phy_disable)(struct hisi_hba *, int);
	void (*phy_hard_reset)(struct hisi_hba *, int);
	void (*get_events)(struct hisi_hba *, int);
	void (*phy_set_linkrate)(struct hisi_hba *, int, struct sas_phy_linkrates *);
	enum sas_linkrate (*phy_get_max_linkrate)();
	int (*clear_itct)(struct hisi_hba *, struct hisi_sas_device *);
	void (*free_device)(struct hisi_sas_device *);
	int (*get_wideport_bitmap)(struct hisi_hba *, int);
	void (*dereg_device)(struct hisi_hba *, struct domain_device *);
	int (*soft_reset)(struct hisi_hba *);
	u32 (*get_phys_state)(struct hisi_hba *);
	int (*write_gpio)(struct hisi_hba *, u8, u8, u8, u8 *);
	void (*wait_cmds_complete_timeout)(struct hisi_hba *, int, int);
	int (*debugfs_snapshot_regs)(struct hisi_hba *);
	int complete_hdr_size;
	const struct scsi_host_template *sht;
};

struct hisi_sas_cq {
	struct hisi_hba *hisi_hba;
	const struct cpumask *irq_mask;
	int rd_point;
	int id;
	int irq_no;
	spinlock_t poll_lock;
};

struct hisi_sas_dq {
	struct hisi_hba *hisi_hba;
	struct list_head list;
	spinlock_t lock;
	int wr_point;
	int id;
};

struct hisi_sas_debugfs_fifo {
	u32 signal_sel;
	u32 dump_msk;
	u32 dump_mode;
	u32 trigger;
	u32 trigger_msk;
	u32 trigger_mode;
	u32 rd_data[32];
};

struct hisi_sas_port;

struct hisi_sas_phy {
	struct work_struct works[3];
	struct hisi_hba *hisi_hba;
	struct hisi_sas_port *port;
	struct asd_sas_phy sas_phy;
	struct sas_identify identify;
	struct completion *reset_completion;
	struct timer_list timer;
	spinlock_t lock;
	u64 port_id;
	u64 frame_rcvd_size;
	u8 frame_rcvd[32];
	u8 phy_attached;
	u8 in_reset;
	u8 reserved[2];
	u32 phy_type;
	u32 code_violation_err_count;
	enum sas_linkrate minimum_linkrate;
	enum sas_linkrate maximum_linkrate;
	int enable;
	int wait_phyup_cnt;
	atomic_t down_cnt;
	struct hisi_sas_debugfs_fifo fifo;
};

struct hisi_sas_port {
	struct asd_sas_port sas_port;
	u8 port_attached;
	u8 id;
};

enum dev_status {
	HISI_SAS_DEV_INIT = 0,
	HISI_SAS_DEV_NORMAL = 1,
	HISI_SAS_DEV_NCQ_ERR = 2,
};

struct hisi_sas_device {
	struct hisi_hba *hisi_hba;
	struct domain_device *sas_device;
	struct completion *completion;
	struct hisi_sas_dq *dq;
	struct list_head list;
	enum sas_device_type dev_type;
	enum dev_status dev_status;
	int device_id;
	int sata_idx;
	spinlock_t lock;
};

struct hisi_sas_debugfs_regs {
	struct hisi_hba *hisi_hba;
	u32 *data;
};

struct hisi_sas_debugfs_port {
	struct hisi_sas_phy *phy;
	u32 *data;
};

struct hisi_sas_debugfs_cq {
	struct hisi_sas_cq *cq;
	void *complete_hdr;
};

struct hisi_sas_cmd_hdr;

struct hisi_sas_debugfs_dq {
	struct hisi_sas_dq *dq;
	struct hisi_sas_cmd_hdr *hdr;
};

struct hisi_sas_iost;

struct hisi_sas_debugfs_iost {
	struct hisi_sas_iost *iost;
};

struct hisi_sas_itct;

struct hisi_sas_debugfs_itct {
	struct hisi_sas_itct *itct;
};

struct hisi_sas_iost_itct_cache;

struct hisi_sas_debugfs_iost_cache {
	struct hisi_sas_iost_itct_cache *cache;
};

struct hisi_sas_debugfs_itct_cache {
	struct hisi_sas_iost_itct_cache *cache;
};

struct hisi_sas_initial_fis;

struct hisi_sas_breakpoint;

struct hisi_hba {
	struct sas_ha_struct *p;
	struct platform_device *platform_dev;
	struct pci_dev *pci_dev;
	struct device *dev;
	int prot_mask;
	void *regs;
	void *sgpio_regs;
	struct regmap *ctrl;
	u32 ctrl_reset_reg;
	u32 ctrl_reset_sts_reg;
	u32 ctrl_clock_ena_reg;
	u32 refclk_frequency_mhz;
	u8 sas_addr[8];
	int *irq_map;
	int n_phy;
	spinlock_t lock;
	struct semaphore sem;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int slot_index_count;
	int last_slot_index;
	int last_dev_id;
	unsigned long *slot_index_tags;
	unsigned long reject_stp_links_msk;
	struct sas_ha_struct sha;
	struct Scsi_Host *shost;
	struct hisi_sas_cq cq[32];
	struct hisi_sas_dq dq[32];
	struct hisi_sas_phy phy[9];
	struct hisi_sas_port port[9];
	int queue_count;
	struct hisi_sas_device devices[1024];
	struct hisi_sas_cmd_hdr *cmd_hdr[32];
	dma_addr_t cmd_hdr_dma[32];
	void *complete_hdr[32];
	dma_addr_t complete_hdr_dma[32];
	struct hisi_sas_initial_fis *initial_fis;
	dma_addr_t initial_fis_dma;
	struct hisi_sas_itct *itct;
	dma_addr_t itct_dma;
	struct hisi_sas_iost *iost;
	dma_addr_t iost_dma;
	struct hisi_sas_breakpoint *breakpoint;
	dma_addr_t breakpoint_dma;
	struct hisi_sas_breakpoint *sata_breakpoint;
	dma_addr_t sata_breakpoint_dma;
	struct hisi_sas_slot *slot_info;
	unsigned long flags;
	const struct hisi_sas_hw *hw;
	unsigned long sata_dev_bitmap[16];
	struct work_struct rst_work;
	u32 phy_state;
	u32 intr_coal_ticks;
	u32 intr_coal_count;
	int cq_nvecs;
	enum sas_linkrate debugfs_bist_linkrate;
	int debugfs_bist_code_mode;
	int debugfs_bist_phy_no;
	int debugfs_bist_mode;
	u32 debugfs_bist_cnt;
	int debugfs_bist_enable;
	u32 debugfs_bist_ffe[72];
	u32 debugfs_bist_fixed_code[2];
	struct hisi_sas_debugfs_regs debugfs_regs[150];
	struct hisi_sas_debugfs_port debugfs_port_reg[450];
	struct hisi_sas_debugfs_cq debugfs_cq[1600];
	struct hisi_sas_debugfs_dq debugfs_dq[1600];
	struct hisi_sas_debugfs_iost debugfs_iost[50];
	struct hisi_sas_debugfs_itct debugfs_itct[50];
	struct hisi_sas_debugfs_iost_cache debugfs_iost_cache[50];
	struct hisi_sas_debugfs_itct_cache debugfs_itct_cache[50];
	u64 debugfs_timestamp[50];
	int debugfs_dump_index;
	struct dentry *debugfs_dir;
	struct dentry *debugfs_dump_dentry;
	struct dentry *debugfs_bist_dentry;
	struct dentry *debugfs_fifo_dentry;
	int iopoll_q_cnt;
};

struct hisi_sas_cmd_hdr {
	__le32 dw0;
	__le32 dw1;
	__le32 dw2;
	__le32 transfer_tags;
	__le32 data_transfer_len;
	__le32 first_burst_num;
	__le32 sg_len;
	__le32 dw7;
	__le64 cmd_table_addr;
	__le64 sts_buffer_addr;
	__le64 prd_table_addr;
	__le64 dif_prd_table_addr;
};

struct hisi_sas_err_record {
	u32 data[4];
};

struct hisi_sas_initial_fis {
	struct hisi_sas_err_record err_record;
	struct dev_to_host_fis fis;
	u32 rsvd[3];
};

struct hisi_sas_itct {
	__le64 qw0;
	__le64 sas_addr;
	__le64 qw2;
	__le64 qw3;
	__le64 qw4_15[12];
};

struct hisi_sas_iost {
	__le64 qw0;
	__le64 qw1;
	__le64 qw2;
	__le64 qw3;
};

struct hisi_sas_breakpoint {
	u8 data[128];
};

struct hisi_sas_slot {
	struct list_head entry;
	struct list_head delivery;
	struct sas_task *task;
	struct hisi_sas_port *port;
	u64 n_elem;
	u64 n_elem_dif;
	int dlvry_queue;
	int dlvry_queue_slot;
	int cmplt_queue;
	int cmplt_queue_slot;
	int abort;
	int ready;
	int device_id;
	void *cmd_hdr;
	dma_addr_t cmd_hdr_dma;
	struct timer_list internal_abort_timer;
	bool is_internal;
	struct sas_tmf_task *tmf;
	void *buf;
	dma_addr_t buf_dma;
	u16 idx;
};

struct hisi_sas_iost_itct_cache {
	u32 data[10];
};

struct signal_attenuation_s;

struct sig_atten_lu_s {
	const struct signal_attenuation_s *att;
	u32 sas_phy_ctrl;
};

struct signal_attenuation_s {
	u32 de_emphasis;
	u32 preshoot;
	u32 boost;
};

struct hisi_sas_hw_error {
	u32 irq_msk;
	u32 msk;
	int shift;
	const char *msg;
	int reg;
	const struct hisi_sas_hw_error *sub;
};

enum {
	HISI_SAS_PHY_PHY_UPDOWN = 0,
	HISI_SAS_PHY_CHNL_INT = 1,
	HISI_SAS_PHY_INT_NR = 2,
};

enum {
	PORT_TYPE_SAS = 2,
	PORT_TYPE_SATA = 1,
};

enum hisi_sas_phy_event {
	HISI_PHYE_PHY_UP = 0,
	HISI_PHYE_LINK_RESET = 1,
	HISI_PHYE_PHY_UP_PM = 2,
	HISI_PHYES_NUM = 3,
};

enum {
	TRANS_TX_FAIL_BASE = 0,
	TRANS_RX_FAIL_BASE = 32,
	DMA_TX_ERR_BASE = 64,
	SIPC_RX_ERR_BASE = 80,
	DMA_RX_ERR_BASE = 96,
	TRANS_TX_OPEN_FAIL_WITH_IT_NEXUS_LOSS = 0,
	TRANS_TX_ERR_PHY_NOT_ENABLE = 1,
	TRANS_TX_OPEN_CNX_ERR_WRONG_DESTINATION = 2,
	TRANS_TX_OPEN_CNX_ERR_ZONE_VIOLATION = 3,
	TRANS_TX_OPEN_CNX_ERR_BY_OTHER = 4,
	RESERVED0 = 5,
	TRANS_TX_OPEN_CNX_ERR_AIP_TIMEOUT = 6,
	TRANS_TX_OPEN_CNX_ERR_STP_RESOURCES_BUSY = 7,
	TRANS_TX_OPEN_CNX_ERR_PROTOCOL_NOT_SUPPORTED = 8,
	TRANS_TX_OPEN_CNX_ERR_CONNECTION_RATE_NOT_SUPPORTED = 9,
	TRANS_TX_OPEN_CNX_ERR_BAD_DESTINATION = 10,
	TRANS_TX_OPEN_CNX_ERR_BREAK_RCVD = 11,
	TRANS_TX_OPEN_CNX_ERR_LOW_PHY_POWER = 12,
	TRANS_TX_OPEN_CNX_ERR_PATHWAY_BLOCKED = 13,
	TRANS_TX_OPEN_CNX_ERR_OPEN_TIMEOUT = 14,
	TRANS_TX_OPEN_CNX_ERR_NO_DESTINATION = 15,
	TRANS_TX_OPEN_RETRY_ERR_THRESHOLD_REACHED = 16,
	TRANS_TX_ERR_FRAME_TXED = 17,
	TRANS_TX_ERR_WITH_BREAK_TIMEOUT = 18,
	TRANS_TX_ERR_WITH_BREAK_REQUEST = 19,
	TRANS_TX_ERR_WITH_BREAK_RECEVIED = 20,
	TRANS_TX_ERR_WITH_CLOSE_TIMEOUT = 21,
	TRANS_TX_ERR_WITH_CLOSE_NORMAL = 22,
	TRANS_TX_ERR_WITH_CLOSE_PHYDISALE = 23,
	TRANS_TX_ERR_WITH_CLOSE_DWS_TIMEOUT = 24,
	TRANS_TX_ERR_WITH_CLOSE_COMINIT = 25,
	TRANS_TX_ERR_WITH_NAK_RECEVIED = 26,
	TRANS_TX_ERR_WITH_ACK_NAK_TIMEOUT = 27,
	TRANS_TX_ERR_WITH_CREDIT_TIMEOUT = 28,
	TRANS_TX_ERR_WITH_IPTT_CONFLICT = 29,
	TRANS_TX_ERR_WITH_OPEN_BY_DES_OR_OTHERS = 30,
	TRANS_TX_ERR_WITH_WAIT_RECV_TIMEOUT = 31,
	TRANS_RX_ERR_WITH_RXFRAME_CRC_ERR = 32,
	TRANS_RX_ERR_WITH_RXFIS_8B10B_DISP_ERR = 33,
	TRANS_RX_ERR_WITH_RXFRAME_HAVE_ERRPRM = 34,
	TRANS_RX_ERR_WITH_RXFIS_DECODE_ERROR = 35,
	TRANS_RX_ERR_WITH_RXFIS_CRC_ERR = 36,
	TRANS_RX_ERR_WITH_RXFRAME_LENGTH_OVERRUN = 37,
	TRANS_RX_ERR_WITH_RXFIS_RX_SYNCP = 38,
	TRANS_RX_ERR_WITH_LINK_BUF_OVERRUN = 39,
	TRANS_RX_ERR_WITH_BREAK_TIMEOUT = 40,
	TRANS_RX_ERR_WITH_BREAK_REQUEST = 41,
	TRANS_RX_ERR_WITH_BREAK_RECEVIED = 42,
	RESERVED1 = 43,
	TRANS_RX_ERR_WITH_CLOSE_NORMAL = 44,
	TRANS_RX_ERR_WITH_CLOSE_PHY_DISABLE = 45,
	TRANS_RX_ERR_WITH_CLOSE_DWS_TIMEOUT = 46,
	TRANS_RX_ERR_WITH_CLOSE_COMINIT = 47,
	TRANS_RX_ERR_WITH_DATA_LEN0 = 48,
	TRANS_RX_ERR_WITH_BAD_HASH = 49,
	TRANS_RX_XRDY_WLEN_ZERO_ERR = 50,
	TRANS_RX_SSP_FRM_LEN_ERR = 51,
	RESERVED2 = 52,
	RESERVED3 = 53,
	RESERVED4 = 54,
	RESERVED5 = 55,
	TRANS_RX_ERR_WITH_BAD_FRM_TYPE = 56,
	TRANS_RX_SMP_FRM_LEN_ERR = 57,
	TRANS_RX_SMP_RESP_TIMEOUT_ERR = 58,
	RESERVED6 = 59,
	RESERVED7 = 60,
	RESERVED8 = 61,
	RESERVED9 = 62,
	TRANS_RX_R_ERR = 63,
	DMA_TX_DIF_CRC_ERR = 64,
	DMA_TX_DIF_APP_ERR = 65,
	DMA_TX_DIF_RPP_ERR = 66,
	DMA_TX_DATA_SGL_OVERFLOW = 67,
	DMA_TX_DIF_SGL_OVERFLOW = 68,
	DMA_TX_UNEXP_XFER_ERR = 69,
	DMA_TX_UNEXP_RETRANS_ERR = 70,
	DMA_TX_XFER_LEN_OVERFLOW = 71,
	DMA_TX_XFER_OFFSET_ERR = 72,
	DMA_TX_RAM_ECC_ERR = 73,
	DMA_TX_DIF_LEN_ALIGN_ERR = 74,
	DMA_TX_MAX_ERR_CODE = 75,
	SIPC_RX_FIS_STATUS_ERR_BIT_VLD = 80,
	SIPC_RX_PIO_WRSETUP_STATUS_DRQ_ERR = 81,
	SIPC_RX_FIS_STATUS_BSY_BIT_ERR = 82,
	SIPC_RX_WRSETUP_LEN_ODD_ERR = 83,
	SIPC_RX_WRSETUP_LEN_ZERO_ERR = 84,
	SIPC_RX_WRDATA_LEN_NOT_MATCH_ERR = 85,
	SIPC_RX_NCQ_WRSETUP_OFFSET_ERR = 86,
	SIPC_RX_NCQ_WRSETUP_AUTO_ACTIVE_ERR = 87,
	SIPC_RX_SATA_UNEXP_FIS_ERR = 88,
	SIPC_RX_WRSETUP_ESTATUS_ERR = 89,
	SIPC_RX_DATA_UNDERFLOW_ERR = 90,
	SIPC_RX_MAX_ERR_CODE = 91,
	DMA_RX_DIF_CRC_ERR = 96,
	DMA_RX_DIF_APP_ERR = 97,
	DMA_RX_DIF_RPP_ERR = 98,
	DMA_RX_DATA_SGL_OVERFLOW = 99,
	DMA_RX_DIF_SGL_OVERFLOW = 100,
	DMA_RX_DATA_LEN_OVERFLOW = 101,
	DMA_RX_DATA_LEN_UNDERFLOW = 102,
	DMA_RX_DATA_OFFSET_ERR = 103,
	RESERVED10 = 104,
	DMA_RX_SATA_FRAME_TYPE_ERR = 105,
	DMA_RX_RESP_BUF_OVERFLOW = 106,
	DMA_RX_UNEXP_RETRANS_RESP_ERR = 107,
	DMA_RX_UNEXP_NORM_RESP_ERR = 108,
	DMA_RX_UNEXP_RDFRAME_ERR = 109,
	DMA_RX_PIO_DATA_LEN_ERR = 110,
	DMA_RX_RDSETUP_STATUS_ERR = 111,
	DMA_RX_RDSETUP_STATUS_DRQ_ERR = 112,
	DMA_RX_RDSETUP_STATUS_BSY_ERR = 113,
	DMA_RX_RDSETUP_LEN_ODD_ERR = 114,
	DMA_RX_RDSETUP_LEN_ZERO_ERR = 115,
	DMA_RX_RDSETUP_LEN_OVER_ERR = 116,
	DMA_RX_RDSETUP_OFFSET_ERR = 117,
	DMA_RX_RDSETUP_ACTIVE_ERR = 118,
	DMA_RX_RDSETUP_ESTATUS_ERR = 119,
	DMA_RX_RAM_ECC_ERR = 120,
	DMA_RX_UNKNOWN_FRM_ERR = 121,
	DMA_RX_MAX_ERR_CODE = 122,
};

enum hisi_sas_dev_type {
	HISI_SAS_DEV_TYPE_STP = 0,
	HISI_SAS_DEV_TYPE_SSP = 1,
	HISI_SAS_DEV_TYPE_SATA = 2,
};

enum sas_gpio_reg_type {
	SAS_GPIO_REG_CFG = 0,
	SAS_GPIO_REG_RX = 1,
	SAS_GPIO_REG_RX_GP = 2,
	SAS_GPIO_REG_TX = 3,
	SAS_GPIO_REG_TX_GP = 4,
};

struct sas_identify_frame {
	u8 frame_type: 4;
	u8 dev_type: 3;
	u8 _un0: 1;
	u8 _un1;
	union {
		struct {
			u8 _un20: 1;
			u8 smp_iport: 1;
			u8 stp_iport: 1;
			u8 ssp_iport: 1;
			u8 _un247: 4;
		};
		u8 initiator_bits;
	};
	union {
		struct {
			u8 _un30: 1;
			u8 smp_tport: 1;
			u8 stp_tport: 1;
			u8 ssp_tport: 1;
			u8 _un347: 4;
		};
		u8 target_bits;
	};
	u8 _un4_11[8];
	u8 sas_addr[8];
	u8 phy_id;
	u8 _un21_27[7];
	__be32 crc;
};

struct ssp_response_iu {
	u8 _r_a[10];
	u8 datapres: 2;
	u8 _r_b: 6;
	u8 status;
	u32 _r_c;
	__be32 sense_data_len;
	__be32 response_data_len;
	union {
		struct {
			struct {} __empty_resp_data;
			u8 resp_data[0];
		};
		struct {
			struct {} __empty_sense_data;
			u8 sense_data[0];
		};
	};
};

struct hisi_sas_sge {
	__le64 addr;
	__le32 page_ctrl_0;
	__le32 page_ctrl_1;
	__le32 data_len;
	__le32 data_off;
};

struct hisi_sas_sge_page {
	struct hisi_sas_sge sge[124];
};

struct hisi_sas_complete_v2_hdr {
	__le32 dw0;
	__le32 dw1;
	__le32 act;
	__le32 dw3;
};

struct hisi_sas_status_buffer {
	struct hisi_sas_err_record err;
	u8 iu[1024];
};

struct hisi_sas_err_record_v2 {
	__le32 trans_tx_fail_type;
	__le32 trans_rx_fail_type;
	__le16 dma_tx_err_type;
	__le16 sipc_rx_err_type;
	__le32 dma_rx_err_type;
};

struct phylink {
	struct net_device *netdev;
	const struct phylink_mac_ops *mac_ops;
	struct phylink_config *config;
	struct phylink_pcs *pcs;
	struct device *dev;
	unsigned int old_link_state: 1;
	unsigned long phylink_disable_state;
	struct phy_device *phydev;
	phy_interface_t link_interface;
	u8 cfg_link_an_mode;
	u8 cur_link_an_mode;
	u8 link_port;
	unsigned long supported[2];
	struct phylink_link_state link_config;
	phy_interface_t cur_interface;
	struct gpio_desc *link_gpio;
	unsigned int link_irq;
	struct timer_list link_poll;
	void (*get_fixed_state)(struct net_device *, struct phylink_link_state *);
	struct mutex state_mutex;
	struct phylink_link_state phy_state;
	struct work_struct resolve;
	unsigned int pcs_neg_mode;
	unsigned int pcs_state;
	bool mac_link_dropped;
	bool using_mac_select_pcs;
	struct sfp_bus *sfp_bus;
	bool sfp_may_have_phy;
	unsigned long sfp_interfaces[1];
	unsigned long sfp_support[2];
	u8 sfp_port;
};

enum {
	PHYLINK_DISABLE_STOPPED = 0,
	PHYLINK_DISABLE_LINK = 1,
	PHYLINK_DISABLE_MAC_WOL = 2,
	PCS_STATE_DOWN = 0,
	PCS_STATE_STARTING = 1,
	PCS_STATE_STARTED = 2,
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct mdio_mux_mmioreg_state {
	void *mux_handle;
	phys_addr_t phys;
	unsigned int iosize;
	unsigned int mask;
};

enum {
	TC_MQPRIO_HW_OFFLOAD_NONE = 0,
	TC_MQPRIO_HW_OFFLOAD_TCS = 1,
	__TC_MQPRIO_HW_OFFLOAD_MAX = 2,
};

enum rcb_int_flag {
	RCB_INT_FLAG_TX = 1,
	RCB_INT_FLAG_RX = 2,
	RCB_INT_FLAG_MAX = 4,
};

struct hnae_vf_cb {
	u8 port_index;
	struct hns_mac_cb *mac_cb;
	struct dsaf_device *dsaf_dev;
	struct hnae_handle ae_handle;
};

struct hclge_mac_speed_map {
	u32 speed_drv;
	u32 speed_fw;
};

struct hclge_link_mode_bmap {
	u16 support_bit;
	enum ethtool_link_mode_bit_indices link_mode;
};

struct hclge_mac_mgr_tbl_entry_cmd {
	u8 flags;
	u8 resp_code;
	__le16 vlan_tag;
	u8 mac_addr[6];
	__le16 rsv1;
	__le16 ethter_type;
	__le16 egress_port;
	__le16 egress_queue;
	u8 sw_port_id_aware;
	u8 rsv2;
	u8 i_port_bitmap;
	u8 i_port_direction;
	u8 rsv3[2];
};

struct hclge_speed_bit_map {
	u32 speed;
	u32 speed_bit;
};

enum HCLGE_FD_KEY_OPT {
	KEY_OPT_U8 = 0,
	KEY_OPT_LE16 = 1,
	KEY_OPT_LE32 = 2,
	KEY_OPT_MAC = 3,
	KEY_OPT_IP = 4,
	KEY_OPT_VNI = 5,
};

struct key_info {
	u8 key_type;
	u8 key_length;
	enum HCLGE_FD_KEY_OPT key_opt;
	int offset;
	int moffset;
};

struct hclge_comm_stats_str {
	char desc[32];
	u32 stats_num;
	unsigned long offset;
};

enum HCLGE_VPORT_STATE {
	HCLGE_VPORT_STATE_ALIVE = 0,
	HCLGE_VPORT_STATE_MAC_TBL_CHANGE = 1,
	HCLGE_VPORT_STATE_PROMISC_CHANGE = 2,
	HCLGE_VPORT_STATE_VLAN_FLTR_CHANGE = 3,
	HCLGE_VPORT_STATE_INITED = 4,
	HCLGE_VPORT_STATE_MAX = 5,
};

enum HCLGE_MAC_NODE_STATE {
	HCLGE_MAC_TO_ADD = 0,
	HCLGE_MAC_TO_DEL = 1,
	HCLGE_MAC_ACTIVE = 2,
};

enum HCLGE_MAC_ADDR_TYPE {
	HCLGE_MAC_ADDR_UC = 0,
	HCLGE_MAC_ADDR_MC = 1,
};

enum HCLGE_MAC_DUPLEX {
	HCLGE_MAC_HALF = 0,
	HCLGE_MAC_FULL = 1,
};

enum HCLGE_MAC_SPEED {
	HCLGE_MAC_SPEED_UNKNOWN = 0,
	HCLGE_MAC_SPEED_10M = 10,
	HCLGE_MAC_SPEED_100M = 100,
	HCLGE_MAC_SPEED_1G = 1000,
	HCLGE_MAC_SPEED_10G = 10000,
	HCLGE_MAC_SPEED_25G = 25000,
	HCLGE_MAC_SPEED_40G = 40000,
	HCLGE_MAC_SPEED_50G = 50000,
	HCLGE_MAC_SPEED_100G = 100000,
	HCLGE_MAC_SPEED_200G = 200000,
};

enum hclge_mac_vlan_tbl_opcode {
	HCLGE_MAC_VLAN_ADD = 0,
	HCLGE_MAC_VLAN_UPDATE = 1,
	HCLGE_MAC_VLAN_REMOVE = 2,
	HCLGE_MAC_VLAN_LKUP = 3,
};

enum hclge_mac_vlan_add_resp_code {
	HCLGE_ADD_UC_OVERFLOW = 2,
	HCLGE_ADD_MC_OVERFLOW = 3,
};

enum HCLGE_FD_USER_DEF_LAYER {
	HCLGE_FD_USER_DEF_NONE = 0,
	HCLGE_FD_USER_DEF_L2 = 1,
	HCLGE_FD_USER_DEF_L3 = 2,
	HCLGE_FD_USER_DEF_L4 = 3,
};

enum HCLGE_FD_NODE_STATE {
	HCLGE_FD_TO_ADD = 0,
	HCLGE_FD_TO_DEL = 1,
	HCLGE_FD_ACTIVE = 2,
	HCLGE_FD_DELETED = 3,
};

enum hclge_vlan_fltr_cap {
	HCLGE_VLAN_FLTR_DEF = 0,
	HCLGE_VLAN_FLTR_CAN_MDF = 1,
};

enum HCLGE_FIRMWARE_MAC_SPEED {
	HCLGE_FW_MAC_SPEED_1G = 0,
	HCLGE_FW_MAC_SPEED_10G = 1,
	HCLGE_FW_MAC_SPEED_25G = 2,
	HCLGE_FW_MAC_SPEED_40G = 3,
	HCLGE_FW_MAC_SPEED_50G = 4,
	HCLGE_FW_MAC_SPEED_100G = 5,
	HCLGE_FW_MAC_SPEED_10M = 6,
	HCLGE_FW_MAC_SPEED_100M = 7,
	HCLGE_FW_MAC_SPEED_200G = 8,
};

enum hclge_evt_cause {
	HCLGE_VECTOR0_EVENT_RST = 0,
	HCLGE_VECTOR0_EVENT_MBX = 1,
	HCLGE_VECTOR0_EVENT_ERR = 2,
	HCLGE_VECTOR0_EVENT_PTP = 3,
	HCLGE_VECTOR0_EVENT_OTHER = 4,
};

enum {
	IFLA_VF_LINK_STATE_AUTO = 0,
	IFLA_VF_LINK_STATE_ENABLE = 1,
	IFLA_VF_LINK_STATE_DISABLE = 2,
	__IFLA_VF_LINK_STATE_MAX = 3,
};

enum HCLGE_FD_MODE {
	HCLGE_FD_MODE_DEPTH_2K_WIDTH_400B_STAGE_1 = 0,
	HCLGE_FD_MODE_DEPTH_1K_WIDTH_400B_STAGE_2 = 1,
	HCLGE_FD_MODE_DEPTH_4K_WIDTH_200B_STAGE_1 = 2,
	HCLGE_FD_MODE_DEPTH_2K_WIDTH_200B_STAGE_2 = 3,
};

enum HCLGE_FD_STAGE {
	HCLGE_FD_STAGE_1 = 0,
	HCLGE_FD_STAGE_2 = 1,
	MAX_STAGE_NUM = 2,
};

enum HCLGE_FD_KEY_TYPE {
	HCLGE_FD_KEY_BASE_ON_PTYPE = 0,
	HCLGE_FD_KEY_BASE_ON_TUPLE = 1,
};

enum HCLGE_FD_TUPLE {
	OUTER_DST_MAC = 0,
	OUTER_SRC_MAC = 1,
	OUTER_VLAN_TAG_FST = 2,
	OUTER_VLAN_TAG_SEC = 3,
	OUTER_ETH_TYPE = 4,
	OUTER_L2_RSV = 5,
	OUTER_IP_TOS = 6,
	OUTER_IP_PROTO = 7,
	OUTER_SRC_IP = 8,
	OUTER_DST_IP = 9,
	OUTER_L3_RSV = 10,
	OUTER_SRC_PORT = 11,
	OUTER_DST_PORT = 12,
	OUTER_L4_RSV = 13,
	OUTER_TUN_VNI = 14,
	OUTER_TUN_FLOW_ID = 15,
	INNER_DST_MAC = 16,
	INNER_SRC_MAC = 17,
	INNER_VLAN_TAG_FST = 18,
	INNER_VLAN_TAG_SEC = 19,
	INNER_ETH_TYPE = 20,
	INNER_L2_RSV = 21,
	INNER_IP_TOS = 22,
	INNER_IP_PROTO = 23,
	INNER_SRC_IP = 24,
	INNER_DST_IP = 25,
	INNER_L3_RSV = 26,
	INNER_SRC_PORT = 27,
	INNER_DST_PORT = 28,
	INNER_L4_RSV = 29,
	MAX_TUPLE = 30,
};

enum HCLGE_FD_META_DATA {
	PACKET_TYPE_ID = 0,
	IP_FRAGEMENT = 1,
	ROCE_TYPE = 2,
	NEXT_KEY = 3,
	VLAN_NUMBER = 4,
	SRC_VPORT = 5,
	DST_VPORT = 6,
	TUNNEL_PACKET = 7,
	MAX_META_DATA = 8,
};

enum HCLGE_VPORT_NEED_NOTIFY {
	HCLGE_VPORT_NEED_NOTIFY_RESET = 0,
	HCLGE_VPORT_NEED_NOTIFY_VF_VLAN = 1,
};

enum HLCGE_PORT_TYPE {
	HOST_PORT = 0,
	NETWORK_PORT = 1,
};

enum hclge_mac_vlan_cfg_sel {
	HCLGE_MAC_VLAN_NIC_SEL = 0,
	HCLGE_MAC_VLAN_ROCE_SEL = 1,
};

enum HCLGE_FD_ACTION {
	HCLGE_FD_ACTION_SELECT_QUEUE = 0,
	HCLGE_FD_ACTION_DROP_PACKET = 1,
	HCLGE_FD_ACTION_SELECT_TC = 2,
};

enum HCLGE_FD_PACKET_TYPE {
	NIC_PACKET = 0,
	ROCE_PACKET = 1,
};

enum hclge_led_status {
	HCLGE_LED_OFF = 0,
	HCLGE_LED_ON = 1,
	HCLGE_LED_NO_CHANGE = 255,
};

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_NUM_OF_VLANS = 28,
	FLOW_DISSECTOR_KEY_PPPOE = 29,
	FLOW_DISSECTOR_KEY_L2TPV3 = 30,
	FLOW_DISSECTOR_KEY_CFM = 31,
	FLOW_DISSECTOR_KEY_IPSEC = 32,
	FLOW_DISSECTOR_KEY_MAX = 33,
};

struct hclge_reset_cmd {
	u8 mac_func_reset;
	u8 fun_reset_vfid;
	u8 fun_reset_rcb;
	u8 rsv;
	__le16 fun_reset_rcb_vqid_start;
	__le16 fun_reset_rcb_vqid_num;
	u8 fun_reset_rcb_return_status;
	u8 rsv1[15];
};

struct hclge_ctrl_vector_chain_cmd {
	u8 int_vector_id_l;
	u8 int_cause_num;
	__le16 tqp_type_and_id[10];
	u8 vfid;
	u8 int_vector_id_h;
};

struct hclge_vport_vlan_cfg {
	struct list_head node;
	int hd_tbl_status;
	u16 vlan_id;
};

struct hclge_tx_buff_alloc_cmd {
	__le16 tx_pkt_buff[8];
	u8 tx_buff_rsv[8];
};

struct hclge_rx_priv_buff_cmd {
	__le16 buf_num[8];
	__le16 shared_buf;
	u8 rsv[6];
};

struct hclge_priv_wl {
	__le16 high;
	__le16 low;
};

struct hclge_rx_priv_wl_buf {
	struct hclge_priv_wl tc_wl[4];
};

struct hclge_rx_com_thrd {
	struct hclge_priv_wl com_thrd[4];
};

struct hclge_rx_com_wl {
	struct hclge_priv_wl com_wl;
};

struct hclge_config_mac_speed_dup_cmd {
	u8 speed_dup;
	u8 mac_change_fec_en;
	u8 rsv[4];
	u8 lane_num;
	u8 rsv1[17];
};

struct hclge_promisc_cfg_cmd {
	u8 promisc;
	u8 vf_id;
	u8 extend_promisc;
	u8 rsv0[21];
};

struct hclge_mac_node {
	struct list_head node;
	enum HCLGE_MAC_NODE_STATE state;
	u8 mac_addr[6];
};

struct hclge_vlan_filter_ctrl_cmd {
	u8 vlan_type;
	u8 vlan_fe;
	u8 rsv1[2];
	u8 vf_id;
	u8 rsv2[19];
};

struct hclge_port_vlan_filter_bypass_cmd {
	u8 bypass_state;
	u8 rsv1[3];
	u8 vf_id;
	u8 rsv2[19];
};

struct hclge_vlan_filter_vf_cfg_cmd {
	__le16 vlan_id;
	u8 resp_code;
	u8 rsv;
	u8 vlan_cfg;
	u8 rsv1[3];
	u8 vf_bitmap[16];
};

struct hclge_vlan_filter_pf_cfg_cmd {
	u8 vlan_offset;
	u8 vlan_cfg;
	u8 rsv[2];
	u8 vlan_offset_bitmap[20];
};

struct hclge_fd_user_def_info {
	enum HCLGE_FD_USER_DEF_LAYER layer;
	u16 data;
	u16 data_mask;
	u16 offset;
};

struct hclge_fd_rule_tuples {
	u8 src_mac[6];
	u8 dst_mac[6];
	u32 src_ip[4];
	u32 dst_ip[4];
	u16 src_port;
	u16 dst_port;
	u16 vlan_tag1;
	u16 ether_proto;
	u16 l2_user_def;
	u16 l3_user_def;
	u32 l4_user_def;
	u8 ip_tos;
	u8 ip_proto;
};

struct hclge_fd_rule {
	struct hlist_node rule_node;
	struct hclge_fd_rule_tuples tuples;
	struct hclge_fd_rule_tuples tuples_mask;
	u32 unused_tuple;
	u32 flow_type;
	union {
		struct {
			unsigned long cookie;
			u8 tc;
		} cls_flower;
		struct {
			u16 flow_id;
		} arfs;
		struct {
			struct hclge_fd_user_def_info user_def;
		} ep;
	};
	u16 queue_id;
	u16 vf_id;
	u16 location;
	enum HCLGE_FD_ACTIVE_RULE_TYPE rule_type;
	enum HCLGE_FD_NODE_STATE state;
	u8 action;
};

struct hclge_vport_vtag_rx_cfg_cmd {
	u8 vport_vlan_cfg;
	u8 vf_offset;
	u8 rsv1[6];
	u8 vf_bitmap[8];
	u8 rsv2[8];
};

struct hclge_vport_vtag_tx_cfg_cmd {
	u8 vport_vlan_cfg;
	u8 vf_offset;
	u8 rsv1[2];
	__le16 def_vlan_tag1;
	__le16 def_vlan_tag2;
	u8 vf_bitmap[8];
	u8 rsv2[8];
};

struct hclge_config_max_frm_size_cmd {
	__le16 max_frm_size;
	u8 min_frm_size;
	u8 rsv[21];
};

struct hclge_cfg_com_tqp_queue_cmd {
	__le16 tqp_id;
	__le16 stream_id;
	u8 enable;
	u8 rsv[19];
};

struct hclge_reset_tqp_queue_cmd {
	__le16 tqp_id;
	u8 reset_req;
	u8 ready_to_reset;
	u8 rsv[20];
};

struct hclge_func_status_cmd {
	__le32 vf_rst_state[4];
	u8 pf_state;
	u8 mac_id;
	u8 rsv1;
	u8 pf_cnt_in_mac;
	u8 pf_num;
	u8 vf_num;
	u8 rsv[2];
};

struct hclge_pf_res_cmd {
	__le16 tqp_num;
	__le16 buf_size;
	__le16 msixcap_localid_ba_nic;
	__le16 msixcap_localid_number_nic;
	__le16 pf_intr_vector_number_roce;
	__le16 pf_own_fun_number;
	__le16 tx_buf_size;
	__le16 dv_buf_size;
	__le16 ext_tqp_num;
	u8 rsv[6];
};

struct hclge_dev_specs_0_cmd {
	__le32 rsv0;
	__le32 mac_entry_num;
	__le32 mng_entry_num;
	__le16 rss_ind_tbl_size;
	__le16 rss_key_size;
	__le16 int_ql_max;
	u8 max_non_tso_bd_num;
	u8 rsv1;
	__le32 max_tm_rate;
};

struct hclge_dev_specs_1_cmd {
	__le16 max_frm_size;
	__le16 max_qset_num;
	__le16 max_int_gl;
	u8 rsv0[2];
	__le16 umv_size;
	__le16 mc_mac_size;
	u8 rsv1[6];
	u8 tnl_num;
	u8 rsv2[5];
};

struct hclge_cfg_param_cmd {
	__le32 offset;
	__le32 rsv;
	__le32 param[4];
};

struct hclge_tqp_map_cmd {
	__le16 tqp_id;
	u8 tqp_vf;
	u8 tqp_flag;
	__le16 tqp_vid;
	u8 rsv[18];
};

struct hclge_umv_spc_alc_cmd {
	u8 allocate;
	u8 rsv1[3];
	__le32 space_size;
	u8 rsv2[16];
};

struct hclge_config_auto_neg_cmd {
	__le32 cfg_an_cmd_flag;
	u8 rsv[20];
};

struct hclge_config_fec_cmd {
	u8 fec_mode;
	u8 default_config;
	u8 rsv[22];
};

struct hclge_config_mac_mode_cmd {
	__le32 txrx_pad_fcs_loop_en;
	u8 rsv[20];
};

struct hclge_common_lb_cmd {
	u8 mask;
	u8 enable;
	u8 result;
	u8 rsv[21];
};

struct hclge_cfg_tso_status_cmd {
	__le16 tso_mss_min;
	__le16 tso_mss_max;
	u8 rsv[20];
};

struct hclge_cfg_gro_status_cmd {
	u8 gro_en;
	u8 rsv[23];
};

struct hclge_rx_vlan_type_cfg_cmd {
	__le16 ot_fst_vlan_type;
	__le16 ot_sec_vlan_type;
	__le16 in_fst_vlan_type;
	__le16 in_sec_vlan_type;
	u8 rsv[16];
};

struct hclge_tx_vlan_type_cfg_cmd {
	__le16 ot_vlan_type;
	__le16 in_vlan_type;
	u8 rsv[20];
};

struct hclge_get_fd_mode_cmd {
	u8 mode;
	u8 enable;
	u8 rsv[22];
};

struct hclge_get_fd_allocation_cmd {
	__le32 stage1_entry_num;
	__le32 stage2_entry_num;
	__le16 stage1_counter_num;
	__le16 stage2_counter_num;
	u8 rsv[12];
};

struct hclge_set_fd_key_config_cmd {
	u8 stage;
	u8 key_select;
	u8 inner_sipv6_word_en;
	u8 inner_dipv6_word_en;
	u8 outer_sipv6_word_en;
	u8 outer_dipv6_word_en;
	u8 rsv1[2];
	__le32 tuple_mask;
	__le32 meta_data_mask;
	u8 rsv2[8];
};

struct hclge_sfp_info_cmd {
	__le32 speed;
	u8 query_type;
	u8 active_fec;
	u8 autoneg;
	u8 autoneg_ability;
	__le32 speed_ability;
	__le32 module_type;
	u8 fec_ability;
	u8 lane_num;
	u8 rsv[6];
};

struct hclge_vf_rst_cmd {
	u8 dest_vfid;
	u8 vf_rst;
	u8 rsv[22];
};

struct hclge_pf_rst_sync_cmd {
	u8 all_vf_ready;
	u8 rsv[23];
};

struct hclge_mac_vlan_switch_cmd {
	u8 roce_sel;
	u8 rsv1[3];
	__le32 func_id;
	u8 switch_param;
	u8 rsv2[3];
	u8 param_mask;
	u8 rsv3[11];
};

struct hclge_wol_cfg_cmd {
	__le32 wake_on_lan_mode;
	u8 sopass[6];
	u8 sopass_size;
	u8 rsv[13];
};

struct hclge_pf_rst_done_cmd {
	u8 pf_rst_done;
	u8 rsv[23];
};

struct hclge_link_status_cmd {
	u8 status;
	u8 rsv[23];
};

struct hclge_fd_tcam_config_1_cmd {
	u8 stage;
	u8 xy_sel;
	u8 port_info;
	u8 rsv1[1];
	__le32 index;
	u8 entry_vld;
	u8 rsv2[7];
	u8 tcam_data[8];
};

struct hclge_fd_tcam_config_2_cmd {
	u8 tcam_data[24];
};

struct hclge_fd_tcam_config_3_cmd {
	u8 tcam_data[20];
	u8 rsv[4];
};

struct hclge_fd_user_def_cfg_cmd {
	__le16 ol2_cfg;
	__le16 l2_cfg;
	__le16 ol3_cfg;
	__le16 l3_cfg;
	__le16 ol4_cfg;
	__le16 l4_cfg;
	u8 rsv[12];
};

struct hclge_fd_ad_config_cmd {
	u8 stage;
	u8 rsv1[3];
	__le32 index;
	__le64 ad_data;
	u8 rsv2[8];
};

struct hclge_query_fec_stats_cmd {
	__le32 rs_fec_corr_blocks;
	__le32 rs_fec_uncorr_blocks;
	__le32 rs_fec_error_blocks;
	u8 base_r_lane_num;
	u8 rsv[3];
	__le32 base_r_fec_corr_blocks;
	__le32 base_r_fec_uncorr_blocks;
};

struct hclge_query_wol_supported_cmd {
	__le32 supported_wake_mode;
	u8 rsv[20];
};

struct hclge_set_led_state_cmd {
	u8 rsv1[3];
	u8 locate_led_config;
	u8 rsv2[20];
};

struct hclge_sfp_info_bd0_cmd {
	__le16 offset;
	__le16 read_len;
	u8 data[20];
};

struct hclge_phy_link_ksetting_0_cmd {
	__le32 speed;
	u8 duplex;
	u8 autoneg;
	u8 eth_tp_mdix;
	u8 eth_tp_mdix_ctrl;
	u8 port;
	u8 transceiver;
	u8 phy_address;
	u8 rsv;
	__le32 supported;
	__le32 advertising;
	__le32 lp_advertising;
};

struct hclge_phy_link_ksetting_1_cmd {
	u8 master_slave_cfg;
	u8 master_slave_state;
	u8 rsv[22];
};

struct hclge_waterline {
	u32 low;
	u32 high;
};

struct hclge_priv_buf {
	struct hclge_waterline wl;
	u32 buf_size;
	u32 tx_buf_size;
	u32 enable;
};

struct hclge_tc_thrd {
	u32 low;
	u32 high;
};

struct hclge_shared_buf {
	struct hclge_waterline self;
	struct hclge_tc_thrd tc_thrd[8];
	u32 buf_size;
};

struct hclge_pkt_buf_alloc {
	struct hclge_priv_buf priv_buf[8];
	struct hclge_shared_buf s_buf;
};

struct hclge_mac_vlan_tbl_entry_cmd {
	u8 flags;
	u8 resp_code;
	__le16 vlan_tag;
	__le32 mac_addr_hi32;
	__le16 mac_addr_lo16;
	__le16 rsv1;
	u8 entry_type;
	u8 mc_mac_en;
	__le16 egress_port;
	__le16 egress_queue;
	u8 rsv2[6];
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_dissector_key_eth_addrs;

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct hclge_cfg {
	u8 tc_num;
	u8 vlan_fliter_cap;
	u16 tqp_desc_num;
	u16 rx_buf_len;
	u16 vf_rss_size_max;
	u16 pf_rss_size_max;
	u8 phy_addr;
	u8 media_type;
	u8 mac_addr[6];
	u8 default_speed;
	u32 numa_node_map;
	u32 tx_spare_buf_size;
	u16 speed_ability;
	u16 umv_space;
};

struct hclge_fd_ad_data {
	u16 ad_id;
	u8 drop_packet;
	u8 forward_to_direct_queue;
	u16 queue_id;
	u8 use_counter;
	u8 counter_id;
	u8 use_next_stage;
	u8 write_rule_id_to_bd;
	u8 next_input_key;
	u16 rule_id;
	u16 tc_size;
	u8 override_tc;
};

struct mii_if_info {
	int phy_id;
	int advertising;
	int phy_id_mask;
	int reg_num_mask;
	unsigned int full_duplex: 1;
	unsigned int force_media: 1;
	unsigned int supports_gmii: 1;
	struct net_device *dev;
	int (*mdio_read)(struct net_device *, int, int);
	void (*mdio_write)(struct net_device *, int, int, int);
};

struct smc91x_platdata {
	unsigned long flags;
	unsigned char leda;
	unsigned char ledb;
	bool pxa_u16_align4;
};

struct smc_local {
	struct sk_buff *pending_tx_skb;
	struct tasklet_struct tx_task;
	struct gpio_desc *power_gpio;
	struct gpio_desc *reset_gpio;
	int version;
	int tcr_cur_mode;
	int rcr_cur_mode;
	int rpc_cur_mode;
	int ctl_rfduplx;
	int ctl_rspeed;
	u32 msg_enable;
	u32 phy_type;
	struct mii_if_info mii;
	struct work_struct phy_configure;
	struct net_device *dev;
	int work_pending;
	spinlock_t lock;
	struct dma_chan *dma_chan;
	void *base;
	void *datacs;
	int io_shift;
	bool half_word_align4;
	struct smc91x_platdata cfg;
};

struct usb_conn_info {
	struct device *dev;
	struct usb_role_switch *role_sw;
	enum usb_role last_role;
	struct regulator *vbus;
	struct delayed_work dw_det;
	unsigned long debounce_jiffies;
	struct gpio_desc *id_gpiod;
	struct gpio_desc *vbus_gpiod;
	int id_irq;
	int vbus_irq;
	struct power_supply_desc desc;
	struct power_supply *charger;
	bool initial_detection;
};

struct ulpi_info {
	unsigned int id;
	char *name;
};

struct usb_ehci_pdata {
	int caps_offset;
	unsigned int has_tt: 1;
	unsigned int has_synopsys_hc_bug: 1;
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int no_io_watchdog: 1;
	unsigned int reset_on_resume: 1;
	unsigned int dma_mask_64: 1;
	unsigned int spurious_oc: 1;
	int (*power_on)(struct platform_device *);
	void (*power_off)(struct platform_device *);
	void (*power_suspend)(struct platform_device *);
	int (*pre_setup)(struct usb_hcd *);
};

struct ehci_platform_priv {
	struct clk *clks[4];
	struct reset_control *rsts;
	bool reset_on_resume;
	bool quirk_poll;
	struct timer_list poll_timer;
	struct delayed_work poll_work;
};

struct swoc_info {
	__u8 rev;
	__u8 reserved[8];
	__u16 LinuxSKU;
	__u16 LinuxVer;
	__u8 reserved2[47];
} __attribute__((packed));

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

union input_seq_state {
	struct {
		unsigned short pos;
		bool mutex_acquired;
	};
	void *p;
};

struct input_devres {
	struct input_dev *input;
};

typedef void (*btf_trace_smbus_write)(void *, const struct i2c_adapter *, u16, unsigned short, char, u8, int, const union i2c_smbus_data *);

typedef void (*btf_trace_smbus_read)(void *, const struct i2c_adapter *, u16, unsigned short, char, u8, int);

typedef void (*btf_trace_smbus_reply)(void *, const struct i2c_adapter *, u16, unsigned short, char, u8, int, const union i2c_smbus_data *, int);

typedef void (*btf_trace_smbus_result)(void *, const struct i2c_adapter *, u16, unsigned short, char, u8, int, int);

struct trace_event_raw_smbus_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 flags;
	__u16 addr;
	__u8 command;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 read_write;
	__u8 command;
	__s16 res;
	__u32 protocol;
	char __data[0];
};

struct trace_event_data_offsets_smbus_write {};

struct trace_event_data_offsets_smbus_read {};

struct trace_event_data_offsets_smbus_reply {};

struct trace_event_data_offsets_smbus_result {};

struct tegra_i2c_hw_feature {
	bool has_continue_xfer_support;
	bool has_per_pkt_xfer_complete_irq;
	bool has_config_load_reg;
	u32 clk_divisor_hs_mode;
	u32 clk_divisor_std_mode;
	u32 clk_divisor_fast_mode;
	u32 clk_divisor_fast_plus_mode;
	bool has_multi_master_mode;
	bool has_slcg_override_reg;
	bool has_mst_fifo;
	const struct i2c_adapter_quirks *quirks;
	bool supports_bus_clear;
	bool has_apb_dma;
	u32 tlow_std_mode;
	u32 thigh_std_mode;
	u32 tlow_fast_fastplus_mode;
	u32 thigh_fast_fastplus_mode;
	u32 setup_hold_time_std_mode;
	u32 setup_hold_time_fast_fast_plus_mode;
	u32 setup_hold_time_hs_mode;
	bool has_interface_timing_reg;
};

enum msg_end_type {
	MSG_END_STOP = 0,
	MSG_END_REPEAT_START = 1,
	MSG_END_CONTINUE = 2,
};

struct tegra_i2c_dev {
	struct device *dev;
	struct i2c_adapter adapter;
	const struct tegra_i2c_hw_feature *hw;
	struct reset_control *rst;
	unsigned int cont_id;
	unsigned int irq;
	phys_addr_t base_phys;
	void *base;
	struct clk_bulk_data clocks[2];
	unsigned int nclocks;
	struct clk *div_clk;
	struct i2c_timings timings;
	struct completion msg_complete;
	size_t msg_buf_remaining;
	unsigned int msg_len;
	int msg_err;
	u8 *msg_buf;
	struct completion dma_complete;
	struct dma_chan *dma_chan;
	unsigned int dma_buf_size;
	struct device *dma_dev;
	dma_addr_t dma_phys;
	void *dma_buf;
	bool multimaster_mode;
	bool atomic_mode;
	bool dma_mode;
	bool msg_read;
	bool is_dvc;
	bool is_vi;
};

struct bq27xxx_dm_reg {
	u8 subclass_id;
	u8 offset;
	u8 bytes;
	u16 min;
	u16 max;
};

enum bq27xxx_chip {
	BQ27000 = 1,
	BQ27010 = 2,
	BQ2750X = 3,
	BQ2751X = 4,
	BQ2752X = 5,
	BQ27500 = 6,
	BQ27510G1 = 7,
	BQ27510G2 = 8,
	BQ27510G3 = 9,
	BQ27520G1 = 10,
	BQ27520G2 = 11,
	BQ27520G3 = 12,
	BQ27520G4 = 13,
	BQ27521 = 14,
	BQ27530 = 15,
	BQ27531 = 16,
	BQ27541 = 17,
	BQ27542 = 18,
	BQ27546 = 19,
	BQ27742 = 20,
	BQ27545 = 21,
	BQ27411 = 22,
	BQ27421 = 23,
	BQ27425 = 24,
	BQ27426 = 25,
	BQ27441 = 26,
	BQ27621 = 27,
	BQ27Z561 = 28,
	BQ28Z610 = 29,
	BQ34Z100 = 30,
	BQ78Z100 = 31,
};

enum bq27xxx_reg_index {
	BQ27XXX_REG_CTRL = 0,
	BQ27XXX_REG_TEMP = 1,
	BQ27XXX_REG_INT_TEMP = 2,
	BQ27XXX_REG_VOLT = 3,
	BQ27XXX_REG_AI = 4,
	BQ27XXX_REG_FLAGS = 5,
	BQ27XXX_REG_TTE = 6,
	BQ27XXX_REG_TTF = 7,
	BQ27XXX_REG_TTES = 8,
	BQ27XXX_REG_TTECP = 9,
	BQ27XXX_REG_NAC = 10,
	BQ27XXX_REG_RC = 11,
	BQ27XXX_REG_FCC = 12,
	BQ27XXX_REG_CYCT = 13,
	BQ27XXX_REG_AE = 14,
	BQ27XXX_REG_SOC = 15,
	BQ27XXX_REG_DCAP = 16,
	BQ27XXX_REG_AP = 17,
	BQ27XXX_DM_CTRL = 18,
	BQ27XXX_DM_CLASS = 19,
	BQ27XXX_DM_BLOCK = 20,
	BQ27XXX_DM_DATA = 21,
	BQ27XXX_DM_CKSUM = 22,
	BQ27XXX_REG_MAX = 23,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5,
	POWER_SUPPLY_HEALTH_COLD = 6,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 9,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 10,
	POWER_SUPPLY_HEALTH_WARM = 11,
	POWER_SUPPLY_HEALTH_COOL = 12,
	POWER_SUPPLY_HEALTH_HOT = 13,
	POWER_SUPPLY_HEALTH_NO_BATTERY = 14,
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

enum bq27xxx_dm_reg_id {
	BQ27XXX_DM_DESIGN_CAPACITY = 0,
	BQ27XXX_DM_DESIGN_ENERGY = 1,
	BQ27XXX_DM_TERMINATE_VOLTAGE = 2,
};

struct bq27xxx_device_info;

struct bq27xxx_access_methods {
	int (*read)(struct bq27xxx_device_info *, u8, bool);
	int (*write)(struct bq27xxx_device_info *, u8, int, bool);
	int (*read_bulk)(struct bq27xxx_device_info *, u8, u8 *, int);
	int (*write_bulk)(struct bq27xxx_device_info *, u8, u8 *, int);
};

struct bq27xxx_reg_cache {
	int temperature;
	int time_to_empty;
	int time_to_empty_avg;
	int time_to_full;
	int charge_full;
	int cycle_count;
	int capacity;
	int energy;
	int flags;
	int health;
};

struct bq27xxx_device_info {
	struct device *dev;
	int id;
	enum bq27xxx_chip chip;
	u32 opts;
	const char *name;
	struct bq27xxx_dm_reg *dm_regs;
	u32 unseal_key;
	struct bq27xxx_access_methods bus;
	struct bq27xxx_reg_cache cache;
	int charge_design_full;
	bool removed;
	unsigned long last_update;
	union power_supply_propval last_status;
	struct delayed_work work;
	struct power_supply *bat;
	struct list_head list;
	struct mutex lock;
	u8 *regs;
};

struct bq27xxx_dm_buf {
	u8 class;
	u8 block;
	u8 data[32];
	bool has_data;
	bool dirty;
};

struct armada_thermal_priv;

struct armada_thermal_data {
	void (*init)(struct platform_device *, struct armada_thermal_priv *);
	s64 coef_b;
	s64 coef_m;
	u32 coef_div;
	bool inverted;
	bool signed_sample;
	unsigned int temp_shift;
	unsigned int temp_mask;
	unsigned int thresh_shift;
	unsigned int hyst_shift;
	unsigned int hyst_mask;
	u32 is_valid_bit;
	unsigned int syscon_control0_off;
	unsigned int syscon_control1_off;
	unsigned int syscon_status_off;
	unsigned int dfx_irq_cause_off;
	unsigned int dfx_irq_mask_off;
	unsigned int dfx_overheat_irq;
	unsigned int dfx_server_irq_mask_off;
	unsigned int dfx_server_irq_en;
	unsigned int cpu_nr;
};

struct armada_thermal_priv {
	struct device *dev;
	struct regmap *syscon;
	char zone_name[20];
	struct mutex update_lock;
	struct armada_thermal_data *data;
	struct thermal_zone_device *overheat_sensor;
	int interrupt_source;
	int current_channel;
	long current_threshold;
	long current_hysteresis;
};

enum drvtype {
	LEGACY = 0,
	SYSCON = 1,
};

struct armada_drvdata {
	enum drvtype type;
	union {
		struct armada_thermal_priv *priv;
		struct thermal_zone_device *tz;
	} data;
};

struct armada_thermal_sensor {
	struct armada_thermal_priv *priv;
	int id;
};

struct bcm2835_wdt {
	void *base;
	spinlock_t lock;
};

struct edac_pci_dev_attribute {
	struct attribute attr;
	void *value;
	ssize_t (*show)(void *, char *);
	ssize_t (*store)(void *, const char *, size_t);
};

struct edac_pci_ctl_info;

struct instance_attribute___2 {
	struct attribute attr;
	ssize_t (*show)(struct edac_pci_ctl_info *, char *);
	ssize_t (*store)(struct edac_pci_ctl_info *, const char *, size_t);
};

struct edac_pci_counter {
	atomic_t pe_count;
	atomic_t npe_count;
};

struct edac_pci_ctl_info {
	struct list_head link;
	int pci_idx;
	struct bus_type *edac_subsys;
	int op_state;
	struct delayed_work work;
	void (*edac_check)(struct edac_pci_ctl_info *);
	struct device *dev;
	const char *mod_name;
	const char *ctl_name;
	const char *dev_name;
	void *pvt_info;
	unsigned long start_time;
	struct completion complete;
	char name[32];
	struct edac_pci_counter counters;
	struct kobject kobj;
};

typedef void (*pci_parity_check_fn_t)(struct pci_dev *);

struct esdhc_soc_data {
	u32 flags;
};

enum wp_types {
	ESDHC_WP_NONE = 0,
	ESDHC_WP_CONTROLLER = 1,
	ESDHC_WP_GPIO = 2,
};

enum cd_types {
	ESDHC_CD_NONE = 0,
	ESDHC_CD_CONTROLLER = 1,
	ESDHC_CD_GPIO = 2,
	ESDHC_CD_PERMANENT = 3,
};

struct esdhc_platform_data {
	enum wp_types wp_type;
	enum cd_types cd_type;
	int max_bus_width;
	unsigned int delay_line;
	unsigned int tuning_step;
	unsigned int tuning_start_tap;
	unsigned int strobe_dll_delay_target;
};

struct pltfm_imx_data {
	u32 scratchpad;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_100mhz;
	struct pinctrl_state *pins_200mhz;
	const struct esdhc_soc_data *socdata;
	struct esdhc_platform_data boarddata;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_per;
	unsigned int actual_clock;
	unsigned int init_card_type;
	enum {
		NO_CMD_PENDING = 0,
		MULTIBLK_IN_PROCESS = 1,
		WAIT_FOR_INT = 2,
	} multiblock_status;
	u32 is_ddr;
	struct pm_qos_request pm_qos_req;
};

struct scmi_requested_dev {
	const struct scmi_device_id *id_table;
	struct list_head node;
};

enum qcom_scm_convention {
	SMC_CONVENTION_UNKNOWN = 0,
	SMC_CONVENTION_LEGACY = 1,
	SMC_CONVENTION_ARM_32 = 2,
	SMC_CONVENTION_ARM_64 = 3,
};

struct arm_smccc_quirk {
	int id;
	union {
		unsigned long a6;
	} state;
};

enum sh_tmu_model {
	SH_TMU = 0,
	SH_TMU_SH3 = 1,
};

struct sh_tmu_device;

struct sh_tmu_channel {
	struct sh_tmu_device *tmu;
	unsigned int index;
	void *base;
	int irq;
	unsigned long periodic;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device ced;
	struct clocksource cs;
	bool cs_enabled;
	unsigned int enable_count;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sh_tmu_device {
	struct platform_device *pdev;
	void *mapbase;
	struct clk *clk;
	unsigned long rate;
	enum sh_tmu_model model;
	raw_spinlock_t lock;
	struct sh_tmu_channel *channels;
	unsigned int num_channels;
	bool has_clockevent;
	bool has_clocksource;
};

struct sh_timer_config {
	unsigned int channels_mask;
};

struct of_bus {
	const char *name;
	const char *addresses;
	int (*match)(struct device_node *);
	void (*count_cells)(struct device_node *, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int, int);
	int (*translate)(__be32 *, u64, int);
	int flag_cells;
	unsigned int (*get_flags)(const __be32 *);
};

enum smd_channel_state {
	SMD_CHANNEL_CLOSED = 0,
	SMD_CHANNEL_OPENING = 1,
	SMD_CHANNEL_OPENED = 2,
	SMD_CHANNEL_FLUSHING = 3,
	SMD_CHANNEL_CLOSING = 4,
	SMD_CHANNEL_RESET = 5,
	SMD_CHANNEL_RESET_OPENING = 6,
};

struct qcom_smd_edge {
	struct device dev;
	const char *name;
	struct device_node *of_node;
	unsigned int edge_id;
	unsigned int remote_pid;
	int irq;
	struct regmap *ipc_regmap;
	int ipc_offset;
	int ipc_bit;
	struct mbox_client mbox_client;
	struct mbox_chan *mbox_chan;
	struct list_head channels;
	spinlock_t channels_lock;
	unsigned long allocated[2];
	unsigned int smem_available;
	wait_queue_head_t new_channel_event;
	struct work_struct scan_work;
	struct work_struct state_work;
};

struct qcom_smd_endpoint;

struct smd_channel_info_pair;

struct smd_channel_info_word_pair;

struct qcom_smd_channel {
	struct qcom_smd_edge *edge;
	struct qcom_smd_endpoint *qsept;
	bool registered;
	char *name;
	enum smd_channel_state state;
	enum smd_channel_state remote_state;
	wait_queue_head_t state_change_event;
	struct smd_channel_info_pair *info;
	struct smd_channel_info_word_pair *info_word;
	spinlock_t tx_lock;
	wait_queue_head_t fblockread_event;
	void *tx_fifo;
	void *rx_fifo;
	int fifo_size;
	void *bounce_buffer;
	spinlock_t recv_lock;
	int pkt_size;
	void *drvdata;
	struct list_head list;
};

struct qcom_smd_endpoint {
	struct rpmsg_endpoint ept;
	struct qcom_smd_channel *qsch;
};

struct smd_channel_info {
	__le32 state;
	u8 fDSR;
	u8 fCTS;
	u8 fCD;
	u8 fRI;
	u8 fHEAD;
	u8 fTAIL;
	u8 fSTATE;
	u8 fBLOCKREADINTR;
	__le32 tail;
	__le32 head;
};

struct smd_channel_info_pair {
	struct smd_channel_info tx;
	struct smd_channel_info rx;
};

struct smd_channel_info_word {
	__le32 state;
	__le32 fDSR;
	__le32 fCTS;
	__le32 fCD;
	__le32 fRI;
	__le32 fHEAD;
	__le32 fTAIL;
	__le32 fSTATE;
	__le32 fBLOCKREADINTR;
	__le32 tail;
	__le32 head;
};

struct smd_channel_info_word_pair {
	struct smd_channel_info_word tx;
	struct smd_channel_info_word rx;
};

struct qcom_smd_device {
	struct rpmsg_device rpdev;
	struct qcom_smd_edge *edge;
};

struct qcom_smd_alloc_entry {
	u8 name[20];
	__le32 cid;
	__le32 flags;
	__le32 ref_count;
};

enum armpmu_attr_groups {
	ARMPMU_ATTR_GROUP_COMMON = 0,
	ARMPMU_ATTR_GROUP_EVENTS = 1,
	ARMPMU_ATTR_GROUP_FORMATS = 2,
	ARMPMU_ATTR_GROUP_CAPS = 3,
	ARMPMU_NR_ATTR_GROUPS = 4,
};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

typedef int (*armpmu_init_fn)(struct arm_pmu *);

struct pmu_probe_info {
	unsigned int cpuid;
	unsigned int mask;
	armpmu_init_fn init;
};

struct armv8pmu_probe_info {
	struct arm_pmu *pmu;
	bool present;
};

struct optee_shm_arg_entry {
	struct list_head list_node;
	struct tee_shm *shm;
	unsigned long map[1];
};

struct optee_session {
	struct list_head list_node;
	u32 session_id;
};

struct optee_context_data {
	struct mutex mutex;
	struct list_head sess_list;
};

struct snd_soc_jack_pin {
	struct list_head list;
	const char *pin;
	int mask;
	bool invert;
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

enum {
	LWT_BPF_UNSPEC = 0,
	LWT_BPF_IN = 1,
	LWT_BPF_OUT = 2,
	LWT_BPF_XMIT = 3,
	LWT_BPF_XMIT_HEADROOM = 4,
	__LWT_BPF_MAX = 5,
};

enum {
	LWT_BPF_PROG_UNSPEC = 0,
	LWT_BPF_PROG_FD = 1,
	LWT_BPF_PROG_NAME = 2,
	__LWT_BPF_PROG_MAX = 3,
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
	BPF_FLOW_DISSECTOR_CONTINUE = 129,
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 256,
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct bpf_lwt_prog {
	struct bpf_prog *prog;
	char *name;
};

struct bpf_lwt {
	struct bpf_lwt_prog in;
	struct bpf_lwt_prog out;
	struct bpf_lwt_prog xmit;
	int family;
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

enum nf_hook_ops_type {
	NF_HOOK_OP_UNDEFINED = 0,
	NF_HOOK_OP_NF_TABLES = 1,
	NF_HOOK_OP_BPF = 2,
};

enum nf_ip_hook_priorities {
	NF_IP_PRI_FIRST = -2147483648,
	NF_IP_PRI_RAW_BEFORE_DEFRAG = -450,
	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
	NF_IP_PRI_RAW = -300,
	NF_IP_PRI_SELINUX_FIRST = -225,
	NF_IP_PRI_CONNTRACK = -200,
	NF_IP_PRI_MANGLE = -150,
	NF_IP_PRI_NAT_DST = -100,
	NF_IP_PRI_FILTER = 0,
	NF_IP_PRI_SECURITY = 50,
	NF_IP_PRI_NAT_SRC = 100,
	NF_IP_PRI_SELINUX_LAST = 225,
	NF_IP_PRI_CONNTRACK_HELPER = 300,
	NF_IP_PRI_CONNTRACK_CONFIRM = 2147483647,
	NF_IP_PRI_LAST = 2147483647,
};

struct nf_hook_ops {
	nf_hookfn *hook;
	struct net_device *dev;
	void *priv;
	u8 pf;
	enum nf_hook_ops_type hook_ops_type: 8;
	unsigned int hooknum;
	int priority;
};

struct nf_defrag_hook;

struct bpf_nf_link {
	struct bpf_link link;
	struct nf_hook_ops hook_ops;
	struct net *net;
	u32 dead;
	const struct nf_defrag_hook *defrag_hook;
};

struct nf_defrag_hook {
	struct module *owner;
	int (*enable)(struct net *);
	void (*disable)(struct net *);
};

typedef void devlink_rel_notify_cb_t(struct devlink *, u32);

typedef void devlink_rel_cleanup_cb_t(struct devlink *, u32, u32);

struct devlink_rel {
	u32 index;
	refcount_t refcount;
	u32 devlink_index;
	struct {
		u32 devlink_index;
		u32 obj_index;
		devlink_rel_notify_cb_t *notify_cb;
		devlink_rel_cleanup_cb_t *cleanup_cb;
		struct work_struct notify_work;
	} nested_in;
};

typedef void (*btf_trace_devlink_hwmsg)(void *, const struct devlink *, bool, unsigned long, const u8 *, size_t);

typedef void (*btf_trace_devlink_hwerr)(void *, const struct devlink *, int, const char *);

typedef void (*btf_trace_devlink_health_report)(void *, const struct devlink *, const char *, const char *);

typedef void (*btf_trace_devlink_health_recover_aborted)(void *, const struct devlink *, const char *, bool, u64);

typedef void (*btf_trace_devlink_health_reporter_state_update)(void *, const struct devlink *, const char *, bool);

typedef void (*btf_trace_devlink_trap_report)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);

struct trace_event_raw_devlink_hwmsg {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	bool incoming;
	unsigned long type;
	u32 __data_loc_buf;
	size_t len;
	char __data[0];
};

struct trace_event_raw_devlink_hwerr {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	int err;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_recover_aborted {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	bool health_state;
	u64 time_since_last_recover;
	char __data[0];
};

struct trace_event_raw_devlink_health_reporter_state_update {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u8 new_state;
	char __data[0];
};

struct trace_event_raw_devlink_trap_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_trap_name;
	u32 __data_loc_trap_group_name;
	char input_dev_name[16];
	char __data[0];
};

struct trace_event_data_offsets_devlink_hwmsg {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 buf;
};

struct trace_event_data_offsets_devlink_hwerr {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_recover_aborted {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_health_reporter_state_update {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_health_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_trap_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 trap_name;
	u32 trap_group_name;
};

struct cache_queue {
	struct list_head list;
	int reader;
};

struct cache_request {
	struct cache_queue q;
	struct cache_head *item;
	char *buf;
	int len;
	int readers;
};

struct thread_deferred_req {
	struct cache_deferred_req handle;
	struct completion completion;
};

struct rpc_inode {
	struct inode vfs_inode;
	void *private;
	struct rpc_pipe *pipe;
	wait_queue_head_t waitq;
};

struct cache_reader {
	struct cache_queue q;
	int offset;
};

struct handshake_req;

typedef void (*btf_trace_handshake_submit)(void *, const struct net *, const struct handshake_req *, const struct sock *);

struct handshake_proto;

struct handshake_req {
	struct list_head hr_list;
	struct rhash_head hr_rhash;
	unsigned long hr_flags;
	const struct handshake_proto *hr_proto;
	struct sock *hr_sk;
	void (*hr_odestruct)(struct sock *);
	char hr_priv[0];
};

struct handshake_proto {
	int hp_handler_class;
	size_t hp_privsize;
	unsigned long hp_flags;
	int (*hp_accept)(struct handshake_req *, struct genl_info *, int);
	void (*hp_done)(struct handshake_req *, unsigned int, struct genl_info *);
	void (*hp_destroy)(struct handshake_req *);
};

typedef void (*btf_trace_handshake_submit_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cancel)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_cancel_none)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_cancel_busy)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_destruct)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_complete)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_notify_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_accept)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_accept_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_done)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_done_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_tls_contenttype)(void *, const struct sock *, unsigned char);

typedef void (*btf_trace_tls_alert_send)(void *, const struct sock *, unsigned char, unsigned char);

typedef void (*btf_trace_tls_alert_recv)(void *, const struct sock *, unsigned char, unsigned char);

struct trace_event_raw_handshake_event_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_error_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int err;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_complete {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int status;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_fd_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int fd;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_tls_contenttype {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	unsigned int netns_ino;
	unsigned long type;
	char __data[0];
};

struct trace_event_raw_handshake_alert_class {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	unsigned int netns_ino;
	unsigned long level;
	unsigned long description;
	char __data[0];
};

struct trace_event_data_offsets_handshake_event_class {};

struct trace_event_data_offsets_handshake_fd_class {};

struct trace_event_data_offsets_handshake_error_class {};

struct trace_event_data_offsets_handshake_alert_class {};

struct trace_event_data_offsets_handshake_complete {};

struct trace_event_data_offsets_tls_contenttype {};

struct efi_smbios_protocol;

typedef struct efi_smbios_protocol efi_smbios_protocol_t;

struct efi_smbios_protocol {
	efi_status_t (*add)(efi_smbios_protocol_t *, efi_handle_t, u16 *, struct efi_smbios_record *);
	efi_status_t (*update_string)(efi_smbios_protocol_t *, u16 *, unsigned long *, u8 *);
	efi_status_t (*remove)(efi_smbios_protocol_t *, u16);
	efi_status_t (*get_next)(efi_smbios_protocol_t *, u16 *, u8 *, struct efi_smbios_record **, efi_handle_t *);
	u8 major_version;
	u8 minor_version;
};

enum gic_type {
	GIC_V2 = 0,
	GIC_V3 = 1,
};

struct gic_kvm_info {
	enum gic_type type;
	struct resource vcpu;
	unsigned int maint_irq;
	bool no_maint_irq_mask;
	struct resource vctrl;
	bool has_v4;
	bool has_v4_1;
	bool no_hw_deactivation;
};

struct xen_p2m_entry {
	unsigned long pfn;
	unsigned long mfn;
	unsigned long nr_pages;
	struct rb_node rbnode_phys;
};

enum {
	MAX_IORES_LEVEL = 5,
};

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t (*alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
	void *alignf_data;
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
	IRQTF_READY = 4,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 0,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_MOVE_PCNTXT = 16384,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQ_NO_DEBUG = 2097152,
	_IRQF_MODIFY_MASK = 2096911,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

struct rchan_percpu_buf_dispatcher {
	struct rchan_buf *buf;
	struct dentry *dentry;
};

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_idle_miss)(void *, unsigned int, unsigned int, bool);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_guest_halt_poll_ns)(void *, bool, unsigned int, unsigned int);

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_idle_miss {
	struct trace_entry ent;
	u32 cpu_id;
	u32 state;
	bool below;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_raw_guest_halt_poll_ns {
	struct trace_entry ent;
	bool grow;
	unsigned int new;
	unsigned int old;
	char __data[0];
};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
};

struct trace_event_data_offsets_clock {
	u32 name;
};

struct trace_event_data_offsets_power_domain {
	u32 name;
};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_cpu_idle_miss {};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	u32 driver;
	u32 parent;
	u32 pm_ops;
};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_guest_halt_poll_ns {};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

enum {
	BPF_MAX_TRAMP_LINKS = 38,
};

struct bpf_shim_tramp_link {
	struct bpf_tramp_link link;
	struct bpf_trampoline *trampoline;
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long tgt_addr;
	struct module *tgt_mod;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

typedef __kernel_rwf_t rwf_t;

struct prepend_buffer {
	char *buf;
	int len;
};

struct mnt_idmap {
	struct user_namespace *owner;
	refcount_t count;
};

enum fanotify_event_type {
	FANOTIFY_EVENT_TYPE_FID = 0,
	FANOTIFY_EVENT_TYPE_FID_NAME = 1,
	FANOTIFY_EVENT_TYPE_PATH = 2,
	FANOTIFY_EVENT_TYPE_PATH_PERM = 3,
	FANOTIFY_EVENT_TYPE_OVERFLOW = 4,
	FANOTIFY_EVENT_TYPE_FS_ERROR = 5,
	__FANOTIFY_EVENT_TYPE_NUM = 6,
};

enum {
	FAN_EVENT_INIT = 0,
	FAN_EVENT_REPORTED = 1,
	FAN_EVENT_ANSWERED = 2,
	FAN_EVENT_CANCELED = 3,
};

struct fanotify_event {
	struct fsnotify_event fse;
	struct hlist_node merge_list;
	u32 mask;
	struct {
		unsigned int type: 3;
		unsigned int hash: 29;
	};
	struct pid *pid;
};

struct fanotify_info {
	u8 dir_fh_totlen;
	u8 dir2_fh_totlen;
	u8 file_fh_totlen;
	u8 name_len;
	u8 name2_len;
	u8 pad[3];
	unsigned char buf[0];
};

struct fanotify_name_event {
	struct fanotify_event fae;
	__kernel_fsid_t fsid;
	struct fanotify_info info;
};

struct fanotify_fh {
	u8 type;
	u8 len;
	u8 flags;
	u8 pad;
	unsigned char buf[0];
};

struct fanotify_fid_event {
	struct fanotify_event fae;
	__kernel_fsid_t fsid;
	struct {
		struct fanotify_fh object_fh;
		unsigned char _inline_fh_buf[12];
	};
};

struct fanotify_error_event {
	struct fanotify_event fae;
	s32 error;
	u32 err_count;
	__kernel_fsid_t fsid;
	struct {
		struct fanotify_fh object_fh;
		unsigned char _inline_fh_buf[128];
	};
};

struct fanotify_path_event {
	struct fanotify_event fae;
	struct path path;
};

struct fanotify_perm_event {
	struct fanotify_event fae;
	struct path path;
	u32 response;
	unsigned short state;
	int fd;
	union {
		struct fanotify_response_info_header hdr;
		struct fanotify_response_info_audit_rule audit_rule;
	};
};

struct fanotify_event_metadata {
	__u32 event_len;
	__u8 vers;
	__u8 reserved;
	__u16 metadata_len;
	__u64 mask;
	__s32 fd;
	__s32 pid;
};

struct fanotify_event_info_header {
	__u8 info_type;
	__u8 pad;
	__u16 len;
};

struct fanotify_event_info_pidfd {
	struct fanotify_event_info_header hdr;
	__s32 pidfd;
};

struct fanotify_event_info_error {
	struct fanotify_event_info_header hdr;
	__s32 error;
	__u32 error_count;
};

struct fanotify_response {
	__s32 fd;
	__u32 response;
};

struct fanotify_event_info_fid {
	struct fanotify_event_info_header hdr;
	__kernel_fsid_t fsid;
	unsigned char handle[0];
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	void (*submit_io)(const struct iomap_iter *, struct bio *, loff_t);
	struct bio_set *bio_set;
};

enum {
	NFS_DEVICEID_INVALID = 0,
	NFS_DEVICEID_UNAVAILABLE = 1,
	NFS_DEVICEID_NOCACHE = 2,
};

enum stripetype4 {
	STRIPE_SPARSE = 1,
	STRIPE_DENSE = 2,
};

struct nfs4_file_layout_dsaddr;

struct nfs4_filelayout_segment {
	struct pnfs_layout_segment generic_hdr;
	u32 stripe_type;
	u32 commit_through_mds;
	u32 stripe_unit;
	u32 first_stripe_index;
	u64 pattern_offset;
	struct nfs4_deviceid deviceid;
	struct nfs4_file_layout_dsaddr *dsaddr;
	unsigned int num_fh;
	struct nfs_fh **fh_array;
};

struct nfs4_file_layout_dsaddr {
	struct nfs4_deviceid_node id_node;
	u32 stripe_count;
	u8 *stripe_indices;
	u32 ds_num;
	struct nfs4_pnfs_ds *ds_list[0];
};

struct nfs4_filelayout {
	struct pnfs_layout_hdr generic_hdr;
	struct pnfs_ds_commit_info commit_info;
};

struct user_key_payload {
	struct callback_head rcu;
	unsigned short datalen;
	long: 0;
	char data[0];
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	__CRYPTOA_MAX = 3,
};

struct rtattr {
	unsigned short rta_len;
	unsigned short rta_type;
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
	bool test_started;
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

struct skcipher_alg_common {
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	struct crypto_alg base;
};

struct crypto_lskcipher;

struct lskcipher_alg {
	int (*setkey)(struct crypto_lskcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct crypto_lskcipher *, const u8 *, u8 *, unsigned int, u8 *, bool);
	int (*decrypt)(struct crypto_lskcipher *, const u8 *, u8 *, unsigned int, u8 *, bool);
	int (*init)(struct crypto_lskcipher *);
	void (*exit)(struct crypto_lskcipher *);
	struct skcipher_alg_common co;
};

struct lskcipher_instance {
	void (*free)(struct lskcipher_instance *);
	union {
		struct {
			char head[56];
			struct crypto_instance base;
		} s;
		struct lskcipher_alg alg;
	};
};

struct crypto_lskcipher {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct crypto_lskcipher_spawn {
	struct crypto_spawn base;
};

struct parsed_partitions {
	struct gendisk *disk;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

typedef struct {
	struct folio *v;
} Sector;

struct bd_holder_disk {
	struct list_head list;
	struct kobject *holder_dir;
	int refcnt;
};

struct io_uring_rsrc_update {
	__u32 offset;
	__u32 resv;
	__u64 data;
};

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

struct xz_dec_lzma2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

struct cs_data {
	u32 enable_mask;
	u16 slow_cfg;
	u16 fast_cfg;
};

struct ebi2_xmem_prop {
	const char *prop;
	u32 max;
	bool slowreg;
	u16 shift;
};

struct id_to_type {
	u32 id;
	int type;
};

enum brcm_family_type {
	BRCM_FAMILY_3390A0 = 0,
	BRCM_FAMILY_4908 = 1,
	BRCM_FAMILY_7250B0 = 2,
	BRCM_FAMILY_7271A0 = 3,
	BRCM_FAMILY_7364A0 = 4,
	BRCM_FAMILY_7366C0 = 5,
	BRCM_FAMILY_74371A0 = 6,
	BRCM_FAMILY_7439B0 = 7,
	BRCM_FAMILY_7445D0 = 8,
	BRCM_FAMILY_7260A0 = 9,
	BRCM_FAMILY_7278A0 = 10,
	BRCM_FAMILY_COUNT = 11,
};

enum {
	USB_CTRL_SETUP_SCB1_EN_SELECTOR = 0,
	USB_CTRL_SETUP_SCB2_EN_SELECTOR = 1,
	USB_CTRL_SETUP_SS_EHCI64BIT_EN_SELECTOR = 2,
	USB_CTRL_SETUP_STRAP_IPP_SEL_SELECTOR = 3,
	USB_CTRL_SETUP_OC3_DISABLE_PORT0_SELECTOR = 4,
	USB_CTRL_SETUP_OC3_DISABLE_PORT1_SELECTOR = 5,
	USB_CTRL_SETUP_OC3_DISABLE_SELECTOR = 6,
	USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_SELECTOR = 7,
	USB_CTRL_USB_PM_BDC_SOFT_RESETB_SELECTOR = 8,
	USB_CTRL_USB_PM_XHC_SOFT_RESETB_SELECTOR = 9,
	USB_CTRL_USB_PM_USB_PWRDN_SELECTOR = 10,
	USB_CTRL_USB30_CTL1_XHC_SOFT_RESETB_SELECTOR = 11,
	USB_CTRL_USB30_CTL1_USB3_IOC_SELECTOR = 12,
	USB_CTRL_USB30_CTL1_USB3_IPP_SELECTOR = 13,
	USB_CTRL_USB_DEVICE_CTL1_PORT_MODE_SELECTOR = 14,
	USB_CTRL_USB_PM_SOFT_RESET_SELECTOR = 15,
	USB_CTRL_SETUP_CC_DRD_MODE_ENABLE_SELECTOR = 16,
	USB_CTRL_SETUP_STRAP_CC_DRD_MODE_ENABLE_SEL_SELECTOR = 17,
	USB_CTRL_USB_PM_USB20_HC_RESETB_SELECTOR = 18,
	USB_CTRL_SETUP_ENDIAN_SELECTOR = 19,
	USB_CTRL_SELECTOR_COUNT = 20,
};

enum bcm_usb_phy_version {
	BCM_SR_USB_COMBO_PHY = 0,
	BCM_SR_USB_HS_PHY = 1,
};

enum bcm_usb_phy_type {
	USB_HS_PHY = 0,
	USB_SS_PHY = 1,
};

enum bcm_usb_phy_reg {
	PLL_CTRL = 0,
	PHY_CTRL = 1,
	PHY_PLL_CTRL = 2,
};

enum bcm_usb_phy_ctrl_bits {
	CORERDY = 0,
	PHY_RESETB = 1,
	PHY_PCTL = 2,
};

enum pll_ctrl_bits {
	PLL_RESETB = 0,
	SSPLL_SUSPEND_EN = 1,
	PLL_SEQ_START = 2,
	PLL_LOCK = 3,
};

struct bcm_usb_phy_cfg {
	uint32_t type;
	uint32_t version;
	void *regs;
	struct phy *phy;
	const u8 *offset;
};

struct uniphier_u3hsphy_param {
	struct {
		int reg_no;
		int msb;
		int lsb;
	} field;
	u8 value;
};

struct uniphier_u3hsphy_priv;

struct uniphier_u3hsphy_trim_param;

struct uniphier_u3hsphy_soc_data {
	bool is_legacy;
	int nparams;
	const struct uniphier_u3hsphy_param param[4];
	u32 config0;
	u32 config1;
	void (*trim_func)(struct uniphier_u3hsphy_priv *, u32 *, struct uniphier_u3hsphy_trim_param *);
};

struct uniphier_u3hsphy_priv {
	struct device *dev;
	void *base;
	struct clk *clk;
	struct clk *clk_parent;
	struct clk *clk_ext;
	struct clk *clk_parent_gio;
	struct reset_control *rst;
	struct reset_control *rst_parent;
	struct reset_control *rst_parent_gio;
	struct regulator *vbus;
	const struct uniphier_u3hsphy_soc_data *data;
};

struct uniphier_u3hsphy_trim_param {
	unsigned int rterm;
	unsigned int sel_t;
	unsigned int hs_i;
};

enum iproc_pinconf_ctrl_type {
	IOCTRL_TYPE_AON = 1,
	IOCTRL_TYPE_CDRU = 2,
	IOCTRL_TYPE_INVALID = 3,
};

enum iproc_pinconf_param {
	IPROC_PINCONF_DRIVE_STRENGTH = 0,
	IPROC_PINCONF_BIAS_DISABLE = 1,
	IPROC_PINCONF_BIAS_PULL_UP = 2,
	IPROC_PINCONF_BIAS_PULL_DOWN = 3,
	IPROC_PINCON_MAX = 4,
};

struct iproc_gpio {
	struct device *dev;
	void *base;
	void *io_ctrl;
	enum iproc_pinconf_ctrl_type io_ctrl_type;
	raw_spinlock_t lock;
	struct gpio_chip gc;
	unsigned int num_banks;
	bool pinmux_is_supported;
	enum pin_config_param *pinconf_disable;
	unsigned int nr_pinconf_disable;
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctldesc;
};

enum ioctrl_regs___4 {
	POC0 = 0,
	POC1 = 1,
	POC2 = 2,
	POC4 = 3,
	POC5 = 4,
	POC6 = 5,
	POC7 = 6,
	POC8 = 7,
	POC9 = 8,
	TD1SEL0 = 9,
};

enum tegra_pinconf_param {
	TEGRA_PINCONF_PARAM_PULL = 0,
	TEGRA_PINCONF_PARAM_TRISTATE = 1,
	TEGRA_PINCONF_PARAM_ENABLE_INPUT = 2,
	TEGRA_PINCONF_PARAM_OPEN_DRAIN = 3,
	TEGRA_PINCONF_PARAM_LOCK = 4,
	TEGRA_PINCONF_PARAM_IORESET = 5,
	TEGRA_PINCONF_PARAM_RCV_SEL = 6,
	TEGRA_PINCONF_PARAM_HIGH_SPEED_MODE = 7,
	TEGRA_PINCONF_PARAM_SCHMITT = 8,
	TEGRA_PINCONF_PARAM_LOW_POWER_MODE = 9,
	TEGRA_PINCONF_PARAM_DRIVE_DOWN_STRENGTH = 10,
	TEGRA_PINCONF_PARAM_DRIVE_UP_STRENGTH = 11,
	TEGRA_PINCONF_PARAM_SLEW_RATE_FALLING = 12,
	TEGRA_PINCONF_PARAM_SLEW_RATE_RISING = 13,
	TEGRA_PINCONF_PARAM_DRIVE_TYPE = 14,
};

struct cfg_param {
	const char *property;
	enum tegra_pinconf_param param;
};

struct tegra_pinctrl_soc_data;

struct tegra_function;

struct tegra_pmx {
	struct device *dev;
	struct pinctrl_dev *pctl;
	const struct tegra_pinctrl_soc_data *soc;
	struct tegra_function *functions;
	const char **group_pins;
	struct pinctrl_gpio_range gpio_range;
	struct pinctrl_desc desc;
	int nbanks;
	void **regs;
	u32 *backup_regs;
};

struct tegra_pingroup;

struct tegra_pinctrl_soc_data {
	unsigned int ngpios;
	const char *gpio_compatible;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const char * const *functions;
	unsigned int nfunctions;
	const struct tegra_pingroup *groups;
	unsigned int ngroups;
	bool hsm_in_mux;
	bool schmitt_in_mux;
	bool drvtype_in_mux;
	bool sfsel_in_mux;
};

struct tegra_pingroup {
	const char *name;
	const unsigned int *pins;
	u8 npins;
	u8 funcs[4];
	s32 mux_reg;
	s32 pupd_reg;
	s32 tri_reg;
	s32 drv_reg;
	u32 mux_bank: 2;
	u32 pupd_bank: 2;
	u32 tri_bank: 2;
	u32 drv_bank: 2;
	s32 mux_bit: 6;
	s32 pupd_bit: 6;
	s32 tri_bit: 6;
	s32 einput_bit: 6;
	s32 odrain_bit: 6;
	s32 lock_bit: 6;
	s32 ioreset_bit: 6;
	s32 rcv_sel_bit: 6;
	s32 hsm_bit: 6;
	long: 2;
	s32 sfsel_bit: 6;
	s32 schmitt_bit: 6;
	s32 lpmd_bit: 6;
	s32 drvdn_bit: 6;
	s32 drvup_bit: 6;
	int: 2;
	s32 slwr_bit: 6;
	s32 slwf_bit: 6;
	s32 lpdr_bit: 6;
	s32 drvtype_bit: 6;
	s32 drvdn_width: 6;
	long: 2;
	s32 drvup_width: 6;
	s32 slwr_width: 6;
	s32 slwf_width: 6;
	u32 parked_bitmask;
};

struct tegra_function {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct max732x_platform_data {
	unsigned int gpio_base;
};

struct max732x_chip {
	struct gpio_chip gpio_chip;
	struct i2c_client *client;
	struct i2c_client *client_dummy;
	struct i2c_client *client_group_a;
	struct i2c_client *client_group_b;
	unsigned int mask_group_a;
	unsigned int dir_input;
	unsigned int dir_output;
	struct mutex lock;
	uint8_t reg_out[2];
};

struct tps65219_gpio {
	struct gpio_chip gpio_chip;
	struct tps65219 *tps;
};

struct hpx_type0 {
	u32 revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 enable_serr;
	u8 enable_perr;
};

enum hpx_type3_cfg_loc {
	HPX_CFG_PCICFG = 0,
	HPX_CFG_PCIE_CAP = 1,
	HPX_CFG_PCIE_CAP_EXT = 2,
	HPX_CFG_VEND_CAP = 3,
	HPX_CFG_DVSEC = 4,
	HPX_CFG_MAX = 5,
};

enum hpx_type3_fn_type {
	HPX_FN_NORMAL = 1,
	HPX_FN_SRIOV_PHYS = 2,
	HPX_FN_SRIOV_VIRT = 4,
};

struct hpx_type2 {
	u32 revision;
	u32 unc_err_mask_and;
	u32 unc_err_mask_or;
	u32 unc_err_sever_and;
	u32 unc_err_sever_or;
	u32 cor_err_mask_and;
	u32 cor_err_mask_or;
	u32 adv_err_cap_and;
	u32 adv_err_cap_or;
	u16 pci_exp_devctl_and;
	u16 pci_exp_devctl_or;
	u16 pci_exp_lnkctl_and;
	u16 pci_exp_lnkctl_or;
	u32 sec_unc_err_sever_and;
	u32 sec_unc_err_sever_or;
	u32 sec_unc_err_mask_and;
	u32 sec_unc_err_mask_or;
};

struct hpx_type1 {
	u32 revision;
	u8 max_mem_read;
	u8 avg_max_split;
	u16 tot_max_split;
};

struct hpx_type3 {
	u16 device_type;
	u16 function_type;
	u16 config_space_location;
	u16 pci_exp_cap_id;
	u16 pci_exp_cap_ver;
	u16 pci_exp_vendor_id;
	u16 dvsec_id;
	u16 dvsec_rev;
	u16 match_offset;
	u32 match_mask_and;
	u32 match_value;
	u16 reg_offset;
	u32 reg_mask_and;
	u32 reg_mask_or;
};

enum pcie_kirin_phy_type {
	PCIE_KIRIN_INTERNAL_PHY = 0,
	PCIE_KIRIN_EXTERNAL_PHY = 1,
};

struct kirin_pcie_data {
	enum pcie_kirin_phy_type phy_type;
};

struct kirin_pcie {
	enum pcie_kirin_phy_type type;
	struct dw_pcie *pci;
	struct regmap *apb;
	struct phy *phy;
	void *phy_priv;
	int gpio_id_dwc_perst;
	int num_slots;
	int gpio_id_reset[3];
	const char *reset_names[3];
	int n_gpio_clkreq;
	int gpio_id_clkreq[3];
	const char *clkreq_names[3];
};

struct hi3660_pcie_phy {
	struct device *dev;
	void *base;
	struct regmap *crgctrl;
	struct regmap *sysctrl;
	struct clk *apb_sys_clk;
	struct clk *apb_phy_clk;
	struct clk *phy_ref_clk;
	struct clk *aclk;
	struct clk *aux_clk;
};

struct acpi_irq_parse_one_ctx {
	int rc;
	unsigned int index;
	unsigned long *res_flags;
	struct irq_fwspec *fwspec;
};

struct devm_clk_state {
	struct clk *clk;
	void (*exit)(struct clk *);
};

struct clk_bulk_devres {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct fsl_sai_clk {
	struct clk_divider div;
	struct clk_gate gate;
	spinlock_t lock;
};

enum gdsc_status {
	GDSC_OFF = 0,
	GDSC_ON = 1,
};

struct gdsc_desc {
	struct device *dev;
	struct gdsc **scs;
	size_t num;
};

struct usb2_clock_sel_priv {
	void *base;
	struct clk_hw hw;
	struct clk_bulk_data clks[2];
	struct reset_control *rsts;
	bool extal;
	bool xtal;
};

struct tegra_clk_sync_source {
	struct clk_hw hw;
	unsigned long rate;
	unsigned long max_rate;
};

struct tegra_clk_periph_fixed {
	struct clk_hw hw;
	void *base;
	const struct tegra_clk_periph_regs *regs;
	unsigned int mul;
	unsigned int div;
	unsigned int num;
};

struct tegra_clk_super_mux {
	struct clk_hw hw;
	void *reg;
	struct tegra_clk_frac_div frac_div;
	const struct clk_ops *div_ops;
	u8 width;
	u8 flags;
	u8 div2_index;
	u8 pllx_index;
	spinlock_t *lock;
};

enum {
	DOWN___2 = 0,
	UP___2 = 1,
};

struct rail_alignment {
	int offset_uv;
	int step_uv;
};

struct cvb_coefficients {
	int c0;
	int c1;
	int c2;
};

struct cvb_table_freq_entry {
	unsigned long freq;
	struct cvb_coefficients coefficients;
};

struct cvb_cpu_dfll_data {
	u32 tune0_low;
	u32 tune0_high;
	u32 tune1;
	unsigned int tune_high_min_millivolts;
};

struct cvb_table {
	int speedo_id;
	int process_id;
	int min_millivolts;
	int max_millivolts;
	int speedo_scale;
	int voltage_scale;
	struct cvb_table_freq_entry entries[40];
	struct cvb_cpu_dfll_data cpu_dfll_data;
};

enum pll_mode {
	PLL_MODE_INT = 0,
	PLL_MODE_FRAC = 1,
	PLL_MODE_ERROR = 2,
};

struct zynqmp_pll {
	struct clk_hw hw;
	u32 clk_id;
	bool set_pll_mode;
};

enum clk_type {
	CLK_TYPE_OUTPUT = 0,
	CLK_TYPE_EXTERNAL = 1,
};

struct clock_parent {
	char name[50];
	int id;
	u32 flag;
};

struct zynqmp_clock {
	char clk_name[50];
	u32 valid;
	enum clk_type type;
	struct clock_topology node[6];
	u32 num_nodes;
	struct clock_parent parent[100];
	u32 num_parents;
	u32 clk_id;
};

struct name_resp {
	char name[16];
};

struct attr_resp {
	u32 attr[1];
};

struct topology_resp {
	u32 topology[3];
};

struct parents_resp {
	u32 parents[3];
};

struct hidma_mgmt_dev;

struct hidma_mgmt_fileinfo {
	char *name;
	int mode;
	int (*get)(struct hidma_mgmt_dev *);
	int (*set)(struct hidma_mgmt_dev *, u64);
};

struct hidma_mgmt_dev {
	u8 hw_version_major;
	u8 hw_version_minor;
	u32 max_wr_xactions;
	u32 max_rd_xactions;
	u32 max_write_request;
	u32 max_read_request;
	u32 dma_channels;
	u32 chreset_timeout_cycles;
	u32 hw_version;
	u32 *priority;
	u32 *weight;
	void *virtaddr;
	resource_size_t addrsize;
	struct kobject **chroots;
	struct platform_device *pdev;
};

struct hidma_chan_attr {
	struct hidma_mgmt_dev *mdev;
	int index;
	struct kobj_attribute attr;
};

struct rcpm {
	unsigned int wakeup_cells;
	void *ippdexpcr_base;
	bool little_endian;
};

struct owl_sps_domain_info;

struct owl_sps_info {
	unsigned int num_domains;
	const struct owl_sps_domain_info *domains;
};

struct owl_sps_domain_info {
	const char *name;
	int pwr_bit;
	int ack_bit;
	unsigned int genpd_flags;
};

struct owl_sps;

struct owl_sps_domain {
	struct generic_pm_domain genpd;
	const struct owl_sps_domain_info *info;
	struct owl_sps *sps;
};

struct owl_sps {
	struct device *dev;
	const struct owl_sps_info *info;
	void *base;
	struct genpd_onecell_data genpd_data;
	struct generic_pm_domain *domains[0];
};

struct imx93_blk_ctrl_domain_data;

struct imx93_blk_ctrl_data {
	const struct imx93_blk_ctrl_domain_data *domains;
	int num_domains;
	const char * const *clk_names;
	int num_clks;
	const struct regmap_access_table *reg_access_table;
};

struct imx93_blk_ctrl_qos {
	u32 reg;
	u32 cfg_off;
	u32 default_prio;
	u32 cfg_prio;
};

struct imx93_blk_ctrl_domain_data {
	const char *name;
	const char * const *clk_names;
	int num_clks;
	u32 rst_mask;
	u32 clk_mask;
	int num_qos;
	struct imx93_blk_ctrl_qos qos[4];
};

struct imx93_blk_ctrl;

struct imx93_blk_ctrl_domain {
	struct generic_pm_domain genpd;
	const struct imx93_blk_ctrl_domain_data *data;
	struct clk_bulk_data clks[4];
	struct imx93_blk_ctrl *bc;
};

struct imx93_blk_ctrl {
	struct device *dev;
	struct regmap *regmap;
	int num_clks;
	struct clk_bulk_data clks[4];
	struct imx93_blk_ctrl_domain *domains;
	struct genpd_onecell_data onecell_data;
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
};

enum virtio_balloon_vq {
	VIRTIO_BALLOON_VQ_INFLATE = 0,
	VIRTIO_BALLOON_VQ_DEFLATE = 1,
	VIRTIO_BALLOON_VQ_STATS = 2,
	VIRTIO_BALLOON_VQ_FREE_PAGE = 3,
	VIRTIO_BALLOON_VQ_REPORTING = 4,
	VIRTIO_BALLOON_VQ_MAX = 5,
};

enum virtio_balloon_config_read {
	VIRTIO_BALLOON_CONFIG_READ_CMD_ID = 0,
};

typedef __u32 __virtio32;

typedef __u16 __virtio16;

typedef __u64 __virtio64;

struct virtio_balloon_stat {
	__virtio16 tag;
	__virtio64 val;
} __attribute__((packed));

struct page_reporting_dev_info {
	int (*report)(struct page_reporting_dev_info *, struct scatterlist *, unsigned int);
	struct delayed_work work;
	atomic_t state;
	unsigned int order;
};

struct virtio_balloon {
	struct virtio_device *vdev;
	struct virtqueue *inflate_vq;
	struct virtqueue *deflate_vq;
	struct virtqueue *stats_vq;
	struct virtqueue *free_page_vq;
	struct workqueue_struct *balloon_wq;
	struct work_struct report_free_page_work;
	struct work_struct update_balloon_stats_work;
	struct work_struct update_balloon_size_work;
	spinlock_t stop_update_lock;
	bool stop_update;
	unsigned long config_read_bitmap;
	struct list_head free_page_list;
	spinlock_t free_page_list_lock;
	unsigned long num_free_page_blocks;
	u32 cmd_id_received_cache;
	__virtio32 cmd_id_active;
	__virtio32 cmd_id_stop;
	wait_queue_head_t acked;
	unsigned int num_pages;
	struct balloon_dev_info vb_dev_info;
	struct mutex balloon_lock;
	unsigned int num_pfns;
	__virtio32 pfns[256];
	struct virtio_balloon_stat stats[10];
	struct shrinker *shrinker;
	struct notifier_block oom_nb;
	struct virtqueue *reporting_vq;
	struct page_reporting_dev_info pr_dev_info;
};

struct privcmd_buf_private;

struct privcmd_buf_vma_private {
	struct privcmd_buf_private *file_priv;
	struct list_head list;
	unsigned int users;
	unsigned int n_pages;
	struct page *pages[0];
};

struct privcmd_buf_private {
	struct mutex lock;
	struct list_head list;
};

struct rpm_regulator_data {
	const char *name;
	u32 type;
	u32 id;
	const struct regulator_desc *desc;
	const char *supply;
};

struct qcom_rpm_reg {
	struct device *dev;
	struct qcom_smd_rpm *rpm;
	u32 type;
	u32 id;
	struct regulator_desc desc;
	int is_enabled;
	int uV;
	u32 load;
	unsigned int enabled_updated: 1;
	unsigned int uv_updated: 1;
	unsigned int load_updated: 1;
};

struct rpm_regulator_req {
	__le32 key;
	__le32 nbytes;
	__le32 value;
};

struct hi3660_reset_controller {
	struct reset_controller_dev rst;
	struct regmap *map;
};

struct sysrq_key_op {
	void (* const handler)(u8);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	unsigned long key_down[12];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	unsigned long reset_keybit[12];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct omap8250_dma_params;

struct omap8250_platdata {
	struct omap8250_dma_params *dma_params;
	u8 habit;
};

struct omap8250_dma_params {
	u32 rx_size;
	u8 rx_trigger;
	u8 tx_trigger;
};

struct omap8250_priv {
	void *membase;
	int line;
	u8 habit;
	u8 mdr1;
	u8 mdr3;
	u8 efr;
	u8 scr;
	u8 wer;
	u8 xon;
	u8 xoff;
	u8 delayed_restore;
	u16 quot;
	u8 tx_trigger;
	u8 rx_trigger;
	atomic_t active;
	bool is_suspending;
	int wakeirq;
	int wakeups_enabled;
	u32 latency;
	u32 calc_latency;
	struct pm_qos_request pm_qos_request;
	struct work_struct qos_work;
	struct uart_8250_dma omap8250_dma;
	spinlock_t rx_dma_lock;
	bool rx_dma_broken;
	bool throttled;
};

struct ports_driver_data {
	struct dentry *debugfs_dir;
	struct list_head portdevs;
	struct list_head consoles;
};

struct console___2 {
	struct list_head list;
	struct hvc_struct *hvc;
	struct winsize ws;
	u32 vtermno;
};

struct port_stats {
	unsigned long bytes_sent;
	unsigned long bytes_received;
	unsigned long bytes_discarded;
};

struct ports_device;

struct port_buffer;

struct port {
	struct list_head list;
	struct ports_device *portdev;
	struct port_buffer *inbuf;
	spinlock_t inbuf_lock;
	spinlock_t outvq_lock;
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct dentry *debugfs_file;
	struct port_stats stats;
	struct console___2 cons;
	struct cdev *cdev;
	struct device *dev;
	struct kref kref;
	wait_queue_head_t waitqueue;
	char *name;
	struct fasync_struct *async_queue;
	u32 id;
	bool outvq_full;
	bool host_connected;
	bool guest_connected;
};

struct virtio_console_control {
	__virtio32 id;
	__virtio16 event;
	__virtio16 value;
};

struct ports_device {
	struct list_head list;
	struct work_struct control_work;
	struct work_struct config_work;
	struct list_head ports;
	spinlock_t ports_lock;
	spinlock_t c_ivq_lock;
	spinlock_t c_ovq_lock;
	u32 max_nr_ports;
	struct virtio_device *vdev;
	struct virtqueue *c_ivq;
	struct virtqueue *c_ovq;
	struct virtio_console_control cpkt;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
	int chr_major;
};

struct port_buffer {
	char *buf;
	size_t size;
	size_t len;
	size_t offset;
	dma_addr_t dma;
	struct device *dev;
	struct list_head list;
	unsigned int sgpages;
	struct scatterlist sg[0];
};

struct sg_list {
	unsigned int n;
	unsigned int size;
	size_t len;
	struct scatterlist *sg;
};

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void __attribute__((btf_type_tag("user"))) *userptr;
		struct file *file;
		void *data;
	} u;
	void (*splice_eof)(struct splice_desc *);
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
};

struct class_interface {
	struct list_head node;
	const struct class *class;
	int (*add_dev)(struct device *);
	void (*remove_dev)(struct device *);
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

struct fwnode_link {
	struct fwnode_handle *supplier;
	struct list_head s_hook;
	struct fwnode_handle *consumer;
	struct list_head c_hook;
	u8 flags;
};

struct class_dir {
	struct kobject kobj;
	const struct class *class;
};

struct root_device {
	struct device dev;
	struct module *owner;
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	const struct bus_type *bus;
	struct device *dev_root;
	struct kset glue_dirs;
	const struct class *class;
	struct lock_class_key lock_key;
};

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct regcache_rbtree_node {
	void *block;
	unsigned long *cache_present;
	unsigned int base_reg;
	unsigned int blklen;
	struct rb_node node;
};

struct regcache_rbtree_ctx {
	struct rb_root root;
	struct regcache_rbtree_node *cached_rbnode;
};

enum rz_mtu3_channels {
	RZ_MTU3_CHAN_0 = 0,
	RZ_MTU3_CHAN_1 = 1,
	RZ_MTU3_CHAN_2 = 2,
	RZ_MTU3_CHAN_3 = 3,
	RZ_MTU3_CHAN_4 = 4,
	RZ_MTU3_CHAN_5 = 5,
	RZ_MTU3_CHAN_6 = 6,
	RZ_MTU3_CHAN_7 = 7,
	RZ_MTU3_CHAN_8 = 8,
	RZ_MTU_NUM_CHANNELS = 9,
};

struct rz_mtu3_channel {
	struct device *dev;
	unsigned int channel_number;
	struct mutex lock;
	bool is_busy;
};

struct rz_mtu3 {
	struct clk *clk;
	struct rz_mtu3_channel channels[9];
	void *priv_data;
};

struct rz_mtu3_priv {
	void *mmio;
	struct reset_control *rstc;
	spinlock_t lock;
};

struct dma_buf_list {
	struct list_head head;
	struct mutex lock;
};

enum dma_resv_usage {
	DMA_RESV_USAGE_KERNEL = 0,
	DMA_RESV_USAGE_WRITE = 1,
	DMA_RESV_USAGE_READ = 2,
	DMA_RESV_USAGE_BOOKKEEP = 3,
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	struct dma_resv_list __attribute__((btf_type_tag("rcu"))) *fences;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 num_fences;
	u32 max_fences;
	struct dma_fence __attribute__((btf_type_tag("rcu"))) *table[0];
};

struct dma_buf;

struct dma_buf_attach_ops;

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_buf_ops;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	unsigned int vmapping_counter;
	struct iosys_map vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_in;
	struct dma_buf_poll_cb_t cb_out;
};

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	int (*vmap)(struct dma_buf *, struct iosys_map *);
	void (*vunmap)(struct dma_buf *, struct iosys_map *);
};

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct dma_buf_import_sync_file {
	__u32 flags;
	__s32 fd;
};

struct dma_fence_unwrap {
	struct dma_fence *chain;
	struct dma_fence *array;
	unsigned int index;
};

struct dma_buf_export_sync_file {
	__u32 flags;
	__s32 fd;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	unsigned long flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct dma_resv_iter {
	struct dma_resv *obj;
	enum dma_resv_usage usage;
	struct dma_fence *fence;
	enum dma_resv_usage fence_usage;
	unsigned int index;
	struct dma_resv_list *fences;
	unsigned int num_fences;
	bool is_restarted;
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct dma_buf_sync {
	__u64 flags;
};

enum {
	SAS_DATAPRES_NO_DATA = 0,
	SAS_DATAPRES_RESPONSE_DATA = 1,
	SAS_DATAPRES_SENSE_DATA = 2,
};

enum scsi_host_guard_type {
	SHOST_DIX_GUARD_CRC = 1,
	SHOST_DIX_GUARD_IP = 2,
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

struct ceva_ahci_priv {
	struct platform_device *ahci_pdev;
	u32 pp2c[2];
	u32 pp3c[2];
	u32 pp4c[2];
	u32 pp5c[2];
	u32 axicc;
	bool is_cci_enabled;
	int flags;
	struct reset_control *rst;
};

enum spi_nor_read_command_index {
	SNOR_CMD_READ = 0,
	SNOR_CMD_READ_FAST = 1,
	SNOR_CMD_READ_1_1_1_DTR = 2,
	SNOR_CMD_READ_1_1_2 = 3,
	SNOR_CMD_READ_1_2_2 = 4,
	SNOR_CMD_READ_2_2_2 = 5,
	SNOR_CMD_READ_1_2_2_DTR = 6,
	SNOR_CMD_READ_1_1_4 = 7,
	SNOR_CMD_READ_1_4_4 = 8,
	SNOR_CMD_READ_4_4_4 = 9,
	SNOR_CMD_READ_1_4_4_DTR = 10,
	SNOR_CMD_READ_1_1_8 = 11,
	SNOR_CMD_READ_1_8_8 = 12,
	SNOR_CMD_READ_8_8_8 = 13,
	SNOR_CMD_READ_1_8_8_DTR = 14,
	SNOR_CMD_READ_8_8_8_DTR = 15,
	SNOR_CMD_READ_MAX = 16,
};

enum spi_nor_pp_command_index {
	SNOR_CMD_PP = 0,
	SNOR_CMD_PP_1_1_4 = 1,
	SNOR_CMD_PP_1_4_4 = 2,
	SNOR_CMD_PP_4_4_4 = 3,
	SNOR_CMD_PP_1_1_8 = 4,
	SNOR_CMD_PP_1_8_8 = 5,
	SNOR_CMD_PP_8_8_8 = 6,
	SNOR_CMD_PP_8_8_8_DTR = 7,
	SNOR_CMD_PP_MAX = 8,
};

struct spi_nor_erase_command {
	struct list_head list;
	u32 count;
	u32 size;
	u8 opcode;
};

struct phylib_stubs {
	int (*hwtstamp_get)(struct phy_device *, struct kernel_hwtstamp_config *);
	int (*hwtstamp_set)(struct phy_device *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct phy_led {
	struct list_head list;
	struct phy_device *phydev;
	struct led_classdev led_cdev;
	u8 index;
};

struct dsaf_drv_mac_single_dest_entry {
	u8 addr[6];
	u16 in_vlan_id;
	u8 in_port_num;
	u8 port_num;
	u8 rsv[6];
};

struct e1000_opt_list {
	int i;
	char *str;
};

struct e1000_option {
	enum {
		enable_option = 0,
		range_option = 1,
		list_option = 2,
	} type;
	const char *name;
	const char *err;
	int def;
	union {
		struct {
			int min;
			int max;
		} r;
		struct {
			int nr;
			const struct e1000_opt_list *p;
		} l;
	} arg;
};

enum igb_tx_buf_type {
	IGB_TYPE_SKB = 0,
	IGB_TYPE_XDP = 1,
};

enum e1000_mac_type___2 {
	e1000_undefined___2 = 0,
	e1000_82575 = 1,
	e1000_82576 = 2,
	e1000_82580 = 3,
	e1000_i350 = 4,
	e1000_i354 = 5,
	e1000_i210 = 6,
	e1000_i211 = 7,
	e1000_num_macs___2 = 8,
};

enum e1000_phy_type___2 {
	e1000_phy_unknown___2 = 0,
	e1000_phy_none___2 = 1,
	e1000_phy_m88___3 = 2,
	e1000_phy_igp___3 = 3,
	e1000_phy_igp_2___2 = 4,
	e1000_phy_gg82563___2 = 5,
	e1000_phy_igp_3___2 = 6,
	e1000_phy_ife___2 = 7,
	e1000_phy_82580 = 8,
	e1000_phy_i210 = 9,
	e1000_phy_bcm54616 = 10,
};

enum e1000_nvm_type___2 {
	e1000_nvm_unknown___2 = 0,
	e1000_nvm_none___2 = 1,
	e1000_nvm_eeprom_spi___2 = 2,
	e1000_nvm_flash_hw___2 = 3,
	e1000_nvm_invm = 4,
	e1000_nvm_flash_sw___2 = 5,
};

enum e1000_bus_type {
	e1000_bus_type_unknown___2 = 0,
	e1000_bus_type_pci___2 = 1,
	e1000_bus_type_pcix___2 = 2,
	e1000_bus_type_pci_express = 3,
	e1000_bus_type_reserved___2 = 4,
};

enum e1000_bus_speed {
	e1000_bus_speed_unknown___2 = 0,
	e1000_bus_speed_33___2 = 1,
	e1000_bus_speed_66___2 = 2,
	e1000_bus_speed_100___2 = 3,
	e1000_bus_speed_120___2 = 4,
	e1000_bus_speed_133___2 = 5,
	e1000_bus_speed_2500 = 6,
	e1000_bus_speed_5000 = 7,
	e1000_bus_speed_reserved___2 = 8,
};

enum e1000_state_t___2 {
	__IGB_TESTING = 0,
	__IGB_RESETTING = 1,
	__IGB_DOWN = 2,
	__IGB_PTP_TX_IN_PROGRESS = 3,
};

struct e1000_hw___3;

struct e1000_mac_operations___2 {
	s32 (*check_for_link)(struct e1000_hw___3 *);
	s32 (*reset_hw)(struct e1000_hw___3 *);
	s32 (*init_hw)(struct e1000_hw___3 *);
	bool (*check_mng_mode)(struct e1000_hw___3 *);
	s32 (*setup_physical_interface)(struct e1000_hw___3 *);
	void (*rar_set)(struct e1000_hw___3 *, u8 *, u32);
	s32 (*read_mac_addr)(struct e1000_hw___3 *);
	s32 (*get_speed_and_duplex)(struct e1000_hw___3 *, u16 *, u16 *);
	s32 (*acquire_swfw_sync)(struct e1000_hw___3 *, u16);
	void (*release_swfw_sync)(struct e1000_hw___3 *, u16);
	s32 (*get_thermal_sensor_data)(struct e1000_hw___3 *);
	s32 (*init_thermal_sensor_thresh)(struct e1000_hw___3 *);
	void (*write_vfta)(struct e1000_hw___3 *, u32, u32);
};

struct e1000_thermal_diode_data {
	u8 location;
	u8 temp;
	u8 caution_thresh;
	u8 max_op_thresh;
};

struct e1000_thermal_sensor_data {
	struct e1000_thermal_diode_data sensor[3];
};

struct e1000_mac_info___2 {
	struct e1000_mac_operations___2 ops;
	u8 addr[6];
	u8 perm_addr[6];
	enum e1000_mac_type___2 type;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	u32 mc_filter_type;
	u32 txcw;
	u16 mta_reg_count;
	u16 uta_reg_count;
	u32 mta_shadow[128];
	u16 rar_entry_count;
	u8 forced_speed_duplex;
	bool adaptive_ifs;
	bool arc_subsystem_valid;
	bool asf_firmware_present;
	bool autoneg;
	bool autoneg_failed;
	bool disable_hw_init_bits;
	bool get_link_status;
	bool ifs_params_forced;
	bool in_ifs_mode;
	bool report_tx_early;
	bool serdes_has_link;
	bool tx_pkt_filtering;
	struct e1000_thermal_sensor_data thermal_sensor_data;
};

struct e1000_fc_info___2 {
	u32 high_water;
	u32 low_water;
	u16 pause_time;
	bool send_xon;
	bool strict_ieee;
	enum e1000_fc_mode current_mode;
	enum e1000_fc_mode requested_mode;
};

struct e1000_phy_operations___2 {
	s32 (*acquire)(struct e1000_hw___3 *);
	s32 (*check_polarity)(struct e1000_hw___3 *);
	s32 (*check_reset_block)(struct e1000_hw___3 *);
	s32 (*force_speed_duplex)(struct e1000_hw___3 *);
	s32 (*get_cfg_done)(struct e1000_hw___3 *);
	s32 (*get_cable_length)(struct e1000_hw___3 *);
	s32 (*get_phy_info)(struct e1000_hw___3 *);
	s32 (*read_reg)(struct e1000_hw___3 *, u32, u16 *);
	void (*release)(struct e1000_hw___3 *);
	s32 (*reset)(struct e1000_hw___3 *);
	s32 (*set_d0_lplu_state)(struct e1000_hw___3 *, bool);
	s32 (*set_d3_lplu_state)(struct e1000_hw___3 *, bool);
	s32 (*write_reg)(struct e1000_hw___3 *, u32, u16);
	s32 (*read_i2c_byte)(struct e1000_hw___3 *, u8, u8, u8 *);
	s32 (*write_i2c_byte)(struct e1000_hw___3 *, u8, u8, u8);
};

struct e1000_phy_info___3 {
	struct e1000_phy_operations___2 ops;
	enum e1000_phy_type___2 type;
	enum e1000_1000t_rx_status local_rx;
	enum e1000_1000t_rx_status remote_rx;
	enum e1000_ms_type ms_type;
	enum e1000_ms_type original_ms_type;
	enum e1000_rev_polarity cable_polarity;
	enum e1000_smart_speed smart_speed;
	u32 addr;
	u32 id;
	u32 reset_delay_us;
	u32 revision;
	enum e1000_media_type media_type;
	u16 autoneg_advertised;
	u16 autoneg_mask;
	u16 cable_length;
	u16 max_cable_length;
	u16 min_cable_length;
	u16 pair_length[4];
	u8 mdix;
	bool disable_polarity_correction;
	bool is_mdix;
	bool polarity_correction;
	bool reset_disable;
	bool speed_downgraded;
	bool autoneg_wait_to_complete;
};

struct e1000_nvm_operations___2 {
	s32 (*acquire)(struct e1000_hw___3 *);
	s32 (*read)(struct e1000_hw___3 *, u16, u16, u16 *);
	void (*release)(struct e1000_hw___3 *);
	s32 (*write)(struct e1000_hw___3 *, u16, u16, u16 *);
	s32 (*update)(struct e1000_hw___3 *);
	s32 (*validate)(struct e1000_hw___3 *);
	s32 (*valid_led_default)(struct e1000_hw___3 *, u16 *);
};

struct e1000_nvm_info___2 {
	struct e1000_nvm_operations___2 ops;
	enum e1000_nvm_type___2 type;
	enum e1000_nvm_override override;
	u32 flash_bank_size;
	u32 flash_base_addr;
	u16 word_size;
	u16 delay_usec;
	u16 address_bits;
	u16 opcode_bits;
	u16 page_size;
};

struct e1000_bus_info___2 {
	enum e1000_bus_type type;
	enum e1000_bus_speed speed;
	enum e1000_bus_width width;
	u32 snoop;
	u16 func;
	u16 pci_cmd_word;
};

struct e1000_mbx_operations {
	s32 (*init_params)(struct e1000_hw___3 *);
	s32 (*read)(struct e1000_hw___3 *, u32 *, u16, u16, bool);
	s32 (*write)(struct e1000_hw___3 *, u32 *, u16, u16);
	s32 (*read_posted)(struct e1000_hw___3 *, u32 *, u16, u16);
	s32 (*write_posted)(struct e1000_hw___3 *, u32 *, u16, u16);
	s32 (*check_for_msg)(struct e1000_hw___3 *, u16);
	s32 (*check_for_ack)(struct e1000_hw___3 *, u16);
	s32 (*check_for_rst)(struct e1000_hw___3 *, u16);
	s32 (*unlock)(struct e1000_hw___3 *, u16);
};

struct e1000_mbx_stats {
	u32 msgs_tx;
	u32 msgs_rx;
	u32 acks;
	u32 reqs;
	u32 rsts;
};

struct e1000_mbx_info {
	struct e1000_mbx_operations ops;
	struct e1000_mbx_stats stats;
	u32 timeout;
	u32 usec_delay;
	u16 size;
};

struct e1000_sfp_flags {
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e10_base_bx10: 1;
	u8 e10_base_px: 1;
};

struct e1000_dev_spec_82575 {
	bool sgmii_active;
	bool global_device_reset;
	bool eee_disable;
	bool clear_semaphore_once;
	struct e1000_sfp_flags eth_flags;
	bool module_plugged;
	u8 media_port;
	bool media_changed;
	bool mas_capable;
};

struct e1000_hw___3 {
	void *back;
	u8 *hw_addr;
	u8 *flash_address;
	unsigned long io_base;
	struct e1000_mac_info___2 mac;
	struct e1000_fc_info___2 fc;
	struct e1000_phy_info___3 phy;
	struct e1000_nvm_info___2 nvm;
	struct e1000_bus_info___2 bus;
	struct e1000_mbx_info mbx;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	union {
		struct e1000_dev_spec_82575 _82575;
	} dev_spec;
	u16 device_id;
	u16 subsystem_vendor_id;
	u16 subsystem_device_id;
	u16 vendor_id;
	u8 revision_id;
};

struct e1000_hw_stats___3 {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorc;
	u64 gotc;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 tor;
	u64 tot;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
	u64 cbtmpc;
	u64 htdpmc;
	u64 cbrdpc;
	u64 cbrmpc;
	u64 rpthc;
	u64 hgptc;
	u64 htcbdpc;
	u64 hgorc;
	u64 hgotc;
	u64 lenerrs;
	u64 scvpc;
	u64 hrmpc;
	u64 doosync;
	u64 o2bgptc;
	u64 o2bspc;
	u64 b2ospc;
	u64 b2ogprc;
};

struct igb_tx_queue_stats {
	u64 packets;
	u64 bytes;
	u64 restart_queue;
	u64 restart_queue2;
};

struct igb_rx_queue_stats {
	u64 packets;
	u64 bytes;
	u64 drops;
	u64 csum_err;
	u64 alloc_failed;
};

struct igb_q_vector;

struct igb_tx_buffer;

struct igb_rx_buffer;

struct igb_ring {
	struct igb_q_vector *q_vector;
	struct net_device *netdev;
	struct bpf_prog *xdp_prog;
	struct device *dev;
	union {
		struct igb_tx_buffer *tx_buffer_info;
		struct igb_rx_buffer *rx_buffer_info;
	};
	void *desc;
	unsigned long flags;
	void *tail;
	dma_addr_t dma;
	unsigned int size;
	u16 count;
	u8 queue_index;
	u8 reg_idx;
	bool launchtime_enable;
	bool cbs_enable;
	s32 idleslope;
	s32 sendslope;
	s32 hicredit;
	s32 locredit;
	u16 next_to_clean;
	u16 next_to_use;
	u16 next_to_alloc;
	union {
		struct {
			struct igb_tx_queue_stats tx_stats;
			struct u64_stats_sync tx_syncp;
			struct u64_stats_sync tx_syncp2;
		};
		struct {
			struct sk_buff *skb;
			struct igb_rx_queue_stats rx_stats;
			struct u64_stats_sync rx_syncp;
		};
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct e1000_info___2 {
	s32 (*get_invariants)(struct e1000_hw___3 *);
	struct e1000_mac_operations___2 *mac_ops;
	const struct e1000_phy_operations___2 *phy_ops;
	struct e1000_nvm_operations___2 *nvm_ops;
};

struct vf_mac_filter {
	struct list_head l;
	int vf;
	bool free;
	u8 vf_mac[6];
};

struct vf_data_storage;

struct hwmon_buff;

struct igb_mac_addr;

struct igb_adapter {
	unsigned long active_vlans[64];
	struct net_device *netdev;
	struct bpf_prog *xdp_prog;
	unsigned long state;
	unsigned int flags;
	unsigned int num_q_vectors;
	struct msix_entry msix_entries[10];
	u32 rx_itr_setting;
	u32 tx_itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	u16 tx_work_limit;
	u32 tx_timeout_count;
	int num_tx_queues;
	struct igb_ring *tx_ring[16];
	int num_rx_queues;
	struct igb_ring *rx_ring[16];
	u32 max_frame_size;
	u32 min_frame_size;
	struct timer_list watchdog_timer;
	struct timer_list phy_info_timer;
	u16 mng_vlan_id;
	u32 bd_number;
	u32 wol;
	u32 en_mng_pt;
	u16 link_speed;
	u16 link_duplex;
	u8 *io_addr;
	struct work_struct reset_task;
	struct work_struct watchdog_task;
	bool fc_autoneg;
	u8 tx_timeout_factor;
	struct timer_list blink_timer;
	unsigned long led_status;
	struct pci_dev *pdev;
	spinlock_t stats64_lock;
	struct rtnl_link_stats64 stats64;
	struct e1000_hw___3 hw;
	struct e1000_hw_stats___3 stats;
	struct e1000_phy_info___3 phy_info;
	u32 test_icr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct igb_ring test_tx_ring;
	struct igb_ring test_rx_ring;
	int msg_enable;
	struct igb_q_vector *q_vector[8];
	u32 eims_enable_mask;
	u32 eims_other;
	u16 tx_ring_count;
	u16 rx_ring_count;
	unsigned int vfs_allocated_count;
	struct vf_data_storage *vf_data;
	int vf_rate_link_speed;
	u32 rss_queues;
	u32 wvbr;
	u32 *shadow_vfta;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_caps;
	struct delayed_work ptp_overflow_work;
	struct work_struct ptp_tx_work;
	struct sk_buff *ptp_tx_skb;
	struct hwtstamp_config tstamp_config;
	unsigned long ptp_tx_start;
	unsigned long last_rx_ptp_check;
	unsigned long last_rx_timestamp;
	unsigned int ptp_flags;
	spinlock_t tmreg_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	u32 tx_hwtstamp_timeouts;
	u32 tx_hwtstamp_skipped;
	u32 rx_hwtstamp_cleared;
	bool pps_sys_wrap_on;
	struct ptp_pin_desc sdp_config[4];
	struct {
		struct timespec64 start;
		struct timespec64 period;
	} perout[2];
	char fw_version[32];
	struct hwmon_buff *igb_hwmon_buff;
	bool ets;
	struct i2c_algo_bit_data i2c_algo;
	struct i2c_adapter i2c_adap;
	struct i2c_client *i2c_client;
	u32 rss_indir_tbl_init;
	u8 rss_indir_tbl[128];
	unsigned long link_check_timeout;
	int copper_tries;
	struct e1000_info___2 ei;
	u16 eee_advert;
	struct hlist_head nfc_filter_list;
	struct hlist_head cls_flower_list;
	unsigned int nfc_filter_count;
	spinlock_t nfc_lock;
	bool etype_bitmap[3];
	struct igb_mac_addr *mac_table;
	struct vf_mac_filter vf_macs;
	struct vf_mac_filter *vf_mac_list;
	spinlock_t vfs_lock;
	long: 64;
	long: 64;
	long: 64;
};

struct igb_ring_container {
	struct igb_ring *ring;
	unsigned int total_bytes;
	unsigned int total_packets;
	u16 work_limit;
	u8 count;
	u8 itr;
};

struct igb_q_vector {
	struct igb_adapter *adapter;
	int cpu;
	u32 eims_value;
	u16 itr_val;
	u8 set_itr;
	void *itr_register;
	struct igb_ring_container rx;
	struct igb_ring_container tx;
	struct napi_struct napi;
	struct callback_head rcu;
	char name[25];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct igb_ring ring[0];
};

union e1000_adv_tx_desc;

struct igb_tx_buffer {
	union e1000_adv_tx_desc *next_to_watch;
	unsigned long time_stamp;
	enum igb_tx_buf_type type;
	union {
		struct sk_buff *skb;
		struct xdp_frame *xdpf;
	};
	unsigned int bytecount;
	u16 gso_segs;
	__be16 protocol;
	dma_addr_t dma;
	__u32 len;
	u32 tx_flags;
};

union e1000_adv_tx_desc {
	struct {
		__le64 buffer_addr;
		__le32 cmd_type_len;
		__le32 olinfo_status;
	} read;
	struct {
		__le64 rsvd;
		__le32 nxtseq_seed;
		__le32 status;
	} wb;
};

struct igb_rx_buffer {
	dma_addr_t dma;
	struct page *page;
	__u32 page_offset;
	__u16 pagecnt_bias;
};

struct vf_data_storage {
	unsigned char vf_mac_addresses[6];
	u16 vf_mc_hashes[30];
	u16 num_vf_mc_hashes;
	u32 flags;
	unsigned long last_nack;
	u16 pf_vlan;
	u16 pf_qos;
	u16 tx_rate;
	bool spoofchk_enabled;
	bool trusted;
};

struct hwmon_attr {
	struct device_attribute dev_attr;
	struct e1000_hw___3 *hw;
	struct e1000_thermal_diode_data *sensor;
	char name[12];
};

struct hwmon_buff {
	struct attribute_group group;
	const struct attribute_group *groups[2];
	struct attribute *attrs[13];
	struct hwmon_attr hwmon_list[12];
	unsigned int n_hwmon;
};

struct igb_mac_addr {
	u8 addr[6];
	u8 queue;
	u8 state;
};

struct ale_control_info {
	const char *name;
	int offset;
	int port_offset;
	int shift;
	int port_shift;
	int bits;
};

struct ale_entry_fld;

struct cpsw_ale_dev_id {
	const char *dev_id;
	u32 features;
	u32 tbl_entries;
	u32 major_ver_mask;
	bool nu_switch_ale;
	const struct ale_entry_fld *vlan_entry_tbl;
};

struct ale_entry_fld {
	u8 start_bit;
	u8 num_bits;
	u8 flags;
};

enum {
	ALE_ENT_VID_MEMBER_LIST = 0,
	ALE_ENT_VID_UNREG_MCAST_MSK = 1,
	ALE_ENT_VID_REG_MCAST_MSK = 2,
	ALE_ENT_VID_FORCE_UNTAGGED_MSK = 3,
	ALE_ENT_VID_UNREG_MCAST_IDX = 4,
	ALE_ENT_VID_REG_MCAST_IDX = 5,
	ALE_ENT_VID_LAST = 6,
};

enum cpsw_ale_control {
	ALE_ENABLE = 0,
	ALE_CLEAR = 1,
	ALE_AGEOUT = 2,
	ALE_P0_UNI_FLOOD = 3,
	ALE_VLAN_NOLEARN = 4,
	ALE_NO_PORT_VLAN = 5,
	ALE_OUI_DENY = 6,
	ALE_BYPASS = 7,
	ALE_RATE_LIMIT_TX = 8,
	ALE_VLAN_AWARE = 9,
	ALE_AUTH_ENABLE = 10,
	ALE_RATE_LIMIT = 11,
	ALE_PORT_STATE = 12,
	ALE_PORT_DROP_UNTAGGED = 13,
	ALE_PORT_DROP_UNKNOWN_VLAN = 14,
	ALE_PORT_NOLEARN = 15,
	ALE_PORT_NO_SA_UPDATE = 16,
	ALE_PORT_UNKNOWN_VLAN_MEMBER = 17,
	ALE_PORT_UNKNOWN_MCAST_FLOOD = 18,
	ALE_PORT_UNKNOWN_REG_MCAST_FLOOD = 19,
	ALE_PORT_UNTAGGED_EGRESS = 20,
	ALE_PORT_MACONLY = 21,
	ALE_PORT_MACONLY_CAF = 22,
	ALE_PORT_BCAST_LIMIT = 23,
	ALE_PORT_MCAST_LIMIT = 24,
	ALE_DEFAULT_THREAD_ID = 25,
	ALE_DEFAULT_THREAD_ENABLE = 26,
	ALE_NUM_CONTROLS = 27,
};

enum {
	CPSW_ALE_F_STATUS_REG = 1,
	CPSW_ALE_F_HW_AUTOAGING = 2,
	CPSW_ALE_F_COUNT = 3,
};

struct cpsw_ale_params {
	struct device *dev;
	void *ale_regs;
	unsigned long ale_ageout;
	unsigned long ale_entries;
	unsigned long ale_ports;
	bool nu_switch_ale;
	u32 major_ver_mask;
	const char *dev_id;
	unsigned long bus_freq;
};

struct cpsw_ale {
	struct cpsw_ale_params params;
	struct timer_list timer;
	unsigned long ageout;
	u32 version;
	u32 features;
	u32 port_mask_bits;
	u32 port_num_bits;
	u32 vlan_field_bits;
	unsigned long *p0_untag_vid_mask;
	const struct ale_entry_fld *vlan_entry_tbl;
};

enum snoop_when {
	SUBMIT = 0,
	COMPLETE = 1,
};

struct usb_dev_state {
	struct list_head list;
	struct usb_device *dev;
	struct file *file;
	spinlock_t lock;
	struct list_head async_pending;
	struct list_head async_completed;
	struct list_head memory_list;
	wait_queue_head_t wait;
	wait_queue_head_t wait_for_resume;
	unsigned int discsignr;
	struct pid *disc_pid;
	const struct cred *cred;
	sigval_t disccontext;
	unsigned long ifclaimed;
	u32 disabled_bulk_eps;
	unsigned long interface_allowed_mask;
	int not_yet_resumed;
	bool suspend_allowed;
	bool privileges_dropped;
};

struct usb_memory;

struct async {
	struct list_head asynclist;
	struct usb_dev_state *ps;
	struct pid *pid;
	const struct cred *cred;
	unsigned int signr;
	unsigned int ifnum;
	void __attribute__((btf_type_tag("user"))) *userbuffer;
	void __attribute__((btf_type_tag("user"))) *userurb;
	sigval_t userurb_sigval;
	struct urb *urb;
	struct usb_memory *usbm;
	unsigned int mem_usage;
	int status;
	u8 bulk_addr;
	u8 bulk_status;
};

struct usb_memory {
	struct list_head memlist;
	int vma_use_count;
	int urb_use_count;
	u32 size;
	void *mem;
	dma_addr_t dma_handle;
	unsigned long vm_start;
	struct usb_dev_state *ps;
};

struct usbdevfs_iso_packet_desc {
	unsigned int length;
	unsigned int actual_length;
	unsigned int status;
};

struct usbdevfs_urb {
	unsigned char type;
	unsigned char endpoint;
	int status;
	unsigned int flags;
	void __attribute__((btf_type_tag("user"))) *buffer;
	int buffer_length;
	int actual_length;
	int start_frame;
	union {
		int number_of_packets;
		unsigned int stream_id;
	};
	int error_count;
	unsigned int signr;
	void __attribute__((btf_type_tag("user"))) *usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_urb32 {
	unsigned char type;
	unsigned char endpoint;
	compat_int_t status;
	compat_uint_t flags;
	compat_caddr_t buffer;
	compat_int_t buffer_length;
	compat_int_t actual_length;
	compat_int_t start_frame;
	compat_int_t number_of_packets;
	compat_int_t error_count;
	compat_uint_t signr;
	compat_caddr_t usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_setinterface {
	unsigned int interface;
	unsigned int altsetting;
};

struct usbdevfs_bulktransfer32 {
	compat_uint_t ep;
	compat_uint_t len;
	compat_uint_t timeout;
	compat_caddr_t data;
};

struct usbdevfs_bulktransfer {
	unsigned int ep;
	unsigned int len;
	unsigned int timeout;
	void __attribute__((btf_type_tag("user"))) *data;
};

struct usbdevfs_getdriver {
	unsigned int interface;
	char driver[256];
};

struct usbdevfs_disconnect_claim {
	unsigned int interface;
	unsigned int flags;
	char driver[256];
};

struct usbdevfs_disconnectsignal32 {
	compat_int_t signr;
	compat_caddr_t context;
};

struct usbdevfs_ctrltransfer32 {
	u8 bRequestType;
	u8 bRequest;
	u16 wValue;
	u16 wIndex;
	u16 wLength;
	u32 timeout;
	compat_caddr_t data;
};

struct usbdevfs_ctrltransfer {
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	__u32 timeout;
	void __attribute__((btf_type_tag("user"))) *data;
};

struct usbdevfs_disconnectsignal {
	unsigned int signr;
	void __attribute__((btf_type_tag("user"))) *context;
};

struct usbdevfs_ioctl32 {
	s32 ifno;
	s32 ioctl_code;
	compat_caddr_t data;
};

struct usbdevfs_ioctl {
	int ifno;
	int ioctl_code;
	void __attribute__((btf_type_tag("user"))) *data;
};

struct usbdevfs_connectinfo {
	unsigned int devnum;
	unsigned char slow;
};

struct usbdevfs_conninfo_ex {
	__u32 size;
	__u32 busnum;
	__u32 devnum;
	__u32 speed;
	__u8 num_ports;
	__u8 ports[7];
};

struct usbdevfs_streams {
	unsigned int num_streams;
	unsigned int num_eps;
	unsigned char eps[0];
};

struct dwc3_imx8mp {
	struct device *dev;
	struct platform_device *dwc3;
	void *hsio_blk_base;
	void *glue_base;
	struct clk *hsio_clk;
	struct clk *suspend_clk;
	int irq;
	bool pm_suspended;
	bool wakeup_pending;
};

enum ssusb_uwk_vers {
	SSUSB_UWK_V1 = 1,
	SSUSB_UWK_V2 = 2,
	SSUSB_UWK_V1_1 = 101,
	SSUSB_UWK_V1_2 = 102,
};

enum mtu3_dr_force_mode {
	MTU3_DR_FORCE_NONE = 0,
	MTU3_DR_FORCE_HOST = 1,
	MTU3_DR_FORCE_DEVICE = 2,
};

struct urb_priv___2 {
	struct ed *ed;
	u16 length;
	u16 td_cnt;
	struct list_head pending;
	struct td *td[0];
};

typedef struct urb_priv___2 urb_priv_t;

struct debug_buffer {
	ssize_t (*fill_func)(struct debug_buffer *);
	struct ohci_hcd *ohci;
	struct mutex mutex;
	size_t count;
	char *page;
};

enum usb3503_mode {
	USB3503_MODE_UNKNOWN = 0,
	USB3503_MODE_HUB = 1,
	USB3503_MODE_STANDBY = 2,
	USB3503_MODE_BYPASS = 3,
};

struct usb3503 {
	enum usb3503_mode mode;
	struct regmap *regmap;
	struct device *dev;
	struct clk *clk;
	u8 port_off_mask;
	struct gpio_desc *bypass;
	struct gpio_desc *intn;
	struct gpio_desc *reset;
	struct gpio_desc *connect;
	bool secondary_ref_clk;
};

struct usb3503_platform_data {
	enum usb3503_mode initial_mode;
	u8 port_off_mask;
};

struct ci_hdrc_usb2_priv {
	struct platform_device *ci_pdev;
	struct clk *clk;
};

struct trackpoint_attr_data {
	size_t field_offset;
	u8 command;
	u8 mask;
	bool inverted;
	u8 power_on_default;
};

struct psmouse_attribute {
	struct device_attribute dattr;
	void *data;
	ssize_t (*show)(struct psmouse *, void *, char *);
	ssize_t (*set)(struct psmouse *, void *, const char *, size_t);
	bool protect;
};

struct trackpoint_data {
	u8 variant_id;
	u8 firmware_id;
	u8 sensitivity;
	u8 speed;
	u8 inertia;
	u8 reach;
	u8 draghys;
	u8 mindrag;
	u8 thresh;
	u8 upthresh;
	u8 ztime;
	u8 jenks;
	u8 drift_time;
	bool press_to_select;
	bool skipback;
	bool ext_dev;
};

struct s3c_rtc;

struct s3c_rtc_data {
	bool needs_src_clk;
	void (*irq_handler)(struct s3c_rtc *, int);
	void (*enable)(struct s3c_rtc *);
	void (*disable)(struct s3c_rtc *);
};

struct s3c_rtc {
	struct device *dev;
	struct rtc_device *rtc;
	void *base;
	struct clk *rtc_clk;
	struct clk *rtc_src_clk;
	bool alarm_enabled;
	const struct s3c_rtc_data *data;
	int irq_alarm;
	spinlock_t alarm_lock;
	bool wake_en;
};

enum imx_i2c_type {
	IMX1_I2C = 0,
	IMX21_I2C = 1,
	VF610_I2C = 2,
};

struct imx_i2c_clk_pair;

struct imx_i2c_hwdata {
	enum imx_i2c_type devtype;
	unsigned int regshift;
	struct imx_i2c_clk_pair *clk_div;
	unsigned int ndivs;
	unsigned int i2sr_clr_opcode;
	unsigned int i2cr_ien_opcode;
	bool has_err007805;
};

struct imx_i2c_clk_pair {
	u16 div;
	u16 val;
};

struct imx_i2c_dma;

struct imx_i2c_struct {
	struct i2c_adapter adapter;
	struct clk *clk;
	struct notifier_block clk_change_nb;
	void *base;
	wait_queue_head_t queue;
	unsigned long i2csr;
	unsigned int disable_delay;
	int stopped;
	unsigned int ifdr;
	unsigned int cur_clk;
	unsigned int bitrate;
	const struct imx_i2c_hwdata *hwdata;
	struct i2c_bus_recovery_info rinfo;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_pins_default;
	struct pinctrl_state *pinctrl_pins_gpio;
	struct imx_i2c_dma *dma;
	struct i2c_client *slave;
	enum i2c_slave_event last_slave_event;
	spinlock_t slave_lock;
	struct hrtimer slave_timer;
};

struct imx_i2c_dma {
	struct dma_chan *chan_tx;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_using;
	struct completion cmd_complete;
	dma_addr_t dma_buf;
	unsigned int dma_len;
	enum dma_transfer_direction dma_transfer_dir;
	enum dma_data_direction dma_data_dir;
};

struct imxi2c_platform_data {
	u32 bitrate;
};

struct ptp_vclock {
	struct ptp_clock *pclock;
	struct ptp_clock_info info;
	struct ptp_clock *clock;
	struct hlist_node vclock_hash_node;
	struct cyclecounter cc;
	struct timecounter tc;
	struct mutex lock;
};

struct uniphier_tm_soc_data {
	u32 map_base;
	u32 block_base;
	u32 tmod_setup_addr;
};

struct uniphier_tm_dev {
	struct regmap *regmap;
	struct device *dev;
	bool alert_en[3];
	struct thermal_zone_device *tz_dev;
	const struct uniphier_tm_soc_data *data;
};

struct mtk_cpufreq_platform_data {
	int min_volt_shift;
	int max_volt_shift;
	int proc_max_volt;
	int sram_min_volt;
	int sram_max_volt;
	bool ccifreq_supported;
};

struct mtk_cpu_dvfs_info {
	struct cpumask cpus;
	struct device *cpu_dev;
	struct device *cci_dev;
	struct regulator *proc_reg;
	struct regulator *sram_reg;
	struct clk *cpu_clk;
	struct clk *inter_clk;
	struct list_head list_head;
	int intermediate_voltage;
	bool need_voltage_tracking;
	int vproc_on_boot;
	int pre_vproc;
	struct mutex reg_lock;
	struct notifier_block opp_nb;
	unsigned int opp_cpu;
	unsigned long current_freq;
	const struct mtk_cpufreq_platform_data *soc_data;
	int vtrack_max;
	bool ccifreq_bound;
};

struct mmc_gpio {
	struct gpio_desc *ro_gpio;
	struct gpio_desc *cd_gpio;
	irqreturn_t (*cd_gpio_isr)(int, void *);
	char *ro_label;
	char *cd_label;
	u32 cd_debounce_delay_ms;
	int cd_irq;
};

struct renesas_sdhi_quirks {
	bool hs400_disabled;
	bool hs400_4taps;
	bool fixed_addr_mode;
	bool dma_one_rx_only;
	bool manual_tap_correction;
	bool old_info1_layout;
	u32 hs400_bad_taps;
	const u8 (*hs400_calib_table)[32];
};

struct tmio_mmc_host;

struct tmio_mmc_data;

struct tmio_mmc_dma_ops {
	void (*start)(struct tmio_mmc_host *, struct mmc_data *);
	void (*enable)(struct tmio_mmc_host *, bool);
	void (*request)(struct tmio_mmc_host *, struct tmio_mmc_data *);
	void (*release)(struct tmio_mmc_host *);
	void (*abort)(struct tmio_mmc_host *);
	void (*dataend)(struct tmio_mmc_host *);
	void (*end)(struct tmio_mmc_host *);
	bool (*dma_irq)(struct tmio_mmc_host *);
};

struct tmio_mmc_host {
	void *ctl;
	struct mmc_command *cmd;
	struct mmc_request *mrq;
	struct mmc_data *data;
	struct mmc_host *mmc;
	struct mmc_host_ops ops;
	void (*set_pwr)(struct platform_device *, int);
	struct scatterlist *sg_ptr;
	struct scatterlist *sg_orig;
	unsigned int sg_len;
	unsigned int sg_off;
	unsigned int bus_shift;
	struct platform_device *pdev;
	struct tmio_mmc_data *pdata;
	bool dma_on;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_tx;
	struct tasklet_struct dma_issue;
	struct scatterlist bounce_sg;
	u8 *bounce_buf;
	struct delayed_work delayed_reset_work;
	struct work_struct done;
	u32 sdcard_irq_mask;
	u32 sdio_irq_mask;
	unsigned int clk_cache;
	u32 sdcard_irq_setbit_mask;
	u32 sdcard_irq_mask_all;
	spinlock_t lock;
	unsigned long last_req_ts;
	struct mutex ios_lock;
	bool native_hotplug;
	bool sdio_irq_enabled;
	int (*clk_enable)(struct tmio_mmc_host *);
	void (*set_clock)(struct tmio_mmc_host *, unsigned int);
	void (*clk_disable)(struct tmio_mmc_host *);
	int (*multi_io_quirk)(struct mmc_card *, unsigned int, int);
	int (*write16_hook)(struct tmio_mmc_host *, int);
	void (*reset)(struct tmio_mmc_host *, bool);
	bool (*check_retune)(struct tmio_mmc_host *, struct mmc_request *);
	void (*fixup_request)(struct tmio_mmc_host *, struct mmc_request *);
	unsigned int (*get_timeout_cycles)(struct tmio_mmc_host *);
	const struct tmio_mmc_dma_ops *dma_ops;
};

struct tmio_mmc_data {
	void *chan_priv_tx;
	void *chan_priv_rx;
	unsigned int hclk;
	unsigned long capabilities;
	unsigned long capabilities2;
	unsigned long flags;
	u32 ocr_mask;
	dma_addr_t dma_rx_offset;
	unsigned int max_blk_count;
	unsigned short max_segs;
	void (*set_pwr)(struct platform_device *, int);
	void (*set_clk_div)(struct platform_device *, int);
};

struct renesas_sdhi_of_data;

struct renesas_sdhi_of_data_with_quirks {
	const struct renesas_sdhi_of_data *of_data;
	const struct renesas_sdhi_quirks *quirks;
};

struct renesas_sdhi_scc;

struct renesas_sdhi_of_data {
	unsigned long tmio_flags;
	u32 tmio_ocr_mask;
	unsigned long capabilities;
	unsigned long capabilities2;
	enum dma_slave_buswidth dma_buswidth;
	dma_addr_t dma_rx_offset;
	unsigned int bus_shift;
	int scc_offset;
	struct renesas_sdhi_scc *taps;
	int taps_num;
	unsigned int max_blk_count;
	unsigned short max_segs;
	unsigned long sdhi_flags;
};

struct renesas_sdhi_scc {
	unsigned long clk_rate;
	u32 tap;
	u32 tap_hs400_4tap;
};

enum renesas_sdhi_dma_cookie {
	COOKIE_UNMAPPED___2 = 0,
	COOKIE_PRE_MAPPED___2 = 1,
	COOKIE_MAPPED___2 = 2,
};

struct renesas_sdhi_dma {
	unsigned long end_flags;
	enum dma_slave_buswidth dma_buswidth;
	bool (*filter)(struct dma_chan *, void *);
	void (*enable)(struct tmio_mmc_host *, bool);
	struct completion dma_dataend;
	struct tasklet_struct dma_complete;
};

struct renesas_sdhi {
	struct clk *clk;
	struct clk *clkh;
	struct clk *clk_cd;
	struct tmio_mmc_data mmc_data;
	struct renesas_sdhi_dma dma_priv;
	const struct renesas_sdhi_quirks *quirks;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_uhs;
	void *scc_ctl;
	u32 scc_tappos;
	u32 scc_tappos_hs400;
	const u8 *adjust_hs400_calib_table;
	bool needs_adjust_hs400;
	unsigned long taps[1];
	unsigned long smpcmp[1];
	unsigned int tap_num;
	unsigned int tap_set;
	struct reset_control *rstc;
};

enum xenon_variant {
	XENON_A3700 = 0,
	XENON_AP806 = 1,
	XENON_AP807 = 2,
	XENON_CP110 = 3,
};

struct xenon_emmc_phy_regs;

struct xenon_priv {
	unsigned char tuning_count;
	u8 sdhc_id;
	unsigned int init_card_type;
	unsigned char bus_width;
	unsigned char timing;
	unsigned int clock;
	struct clk *axi_clk;
	int phy_type;
	void *phy_params;
	struct xenon_emmc_phy_regs *emmc_phy_regs;
	bool restore_needed;
	enum xenon_variant hw_version;
};

enum scpi_power_domain_state {
	SCPI_PD_STATE_ON = 0,
	SCPI_PD_STATE_OFF = 3,
};

struct scpi_pm_domain {
	struct generic_pm_domain genpd;
	struct scpi_ops *ops;
	u32 domain;
};

struct scu_wakeup {
	u32 mask;
	u32 wakeup_src;
	bool valid;
};

struct imx_sc_msg_irq_get_status {
	struct imx_sc_rpc_msg hdr;
	union {
		struct {
			u16 resource;
			u8 group;
			u8 reserved;
		} req;
		struct {
			u32 status;
		} resp;
	} data;
};

struct imx_sc_msg_irq_enable {
	struct imx_sc_rpc_msg hdr;
	u32 mask;
	u16 resource;
	u8 group;
	u8 enable;
};

struct rk_timer {
	void *base;
	void *ctrl;
	struct clk *clk;
	struct clk *pclk;
	u32 freq;
	int irq;
};

struct rk_clkevt {
	struct clock_event_device ce;
	struct rk_timer timer;
	long: 64;
	long: 64;
	long: 64;
};

struct acpi_probe_entry;

typedef bool (*acpi_probe_entry_validate_subtbl)(struct acpi_subtable_header *, struct acpi_probe_entry *);

struct acpi_probe_entry {
	__u8 id[5];
	__u8 type;
	acpi_probe_entry_validate_subtbl subtable_valid;
	union {
		acpi_tbl_table_handler probe_table;
		acpi_tbl_entry_handler probe_subtbl;
	};
	kernel_ulong_t driver_data;
};

enum arch_timer_erratum_match_type {
	ate_match_dt = 0,
	ate_match_local_cap_id = 1,
	ate_match_acpi_oem_info = 2,
};

struct arch_timer_erratum_workaround {
	enum arch_timer_erratum_match_type match_type;
	const void *id;
	const char *desc;
	u64 (*read_cntpct_el0)();
	u64 (*read_cntvct_el0)();
	int (*set_next_event_phys)(unsigned long, struct clock_event_device *);
	int (*set_next_event_virt)(unsigned long, struct clock_event_device *);
	bool disable_compat_vdso;
};

struct ate_acpi_oem_info {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
};

struct arch_timer {
	void *base;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device evt;
};

enum arch_timer_reg {
	ARCH_TIMER_REG_CTRL = 0,
	ARCH_TIMER_REG_CVAL = 1,
};

enum cpu_pm_event {
	CPU_PM_ENTER = 0,
	CPU_PM_ENTER_FAILED = 1,
	CPU_PM_EXIT = 2,
	CPU_CLUSTER_PM_ENTER = 3,
	CPU_CLUSTER_PM_ENTER_FAILED = 4,
	CPU_CLUSTER_PM_EXIT = 5,
};

enum arch_timer_spi_nr {
	ARCH_TIMER_PHYS_SPI = 0,
	ARCH_TIMER_VIRT_SPI = 1,
	ARCH_TIMER_MAX_TIMER_SPI = 2,
};

typedef bool (*ate_match_fn_t)(const struct arch_timer_erratum_workaround *, const void *);

struct alias_prop {
	struct list_head link;
	const char *alias;
	struct device_node *np;
	int id;
	char stem[0];
};

struct rproc_dump_segment {
	struct list_head node;
	dma_addr_t da;
	size_t size;
	void *priv;
	void (*dump)(struct rproc *, struct rproc_dump_segment *, void *, size_t, size_t);
	loff_t offset;
};

struct rproc_coredump_state {
	struct rproc *rproc;
	void *header;
	struct completion dump_done;
};

enum mtk_smi_type {
	MTK_SMI_GEN1 = 0,
	MTK_SMI_GEN2 = 1,
	MTK_SMI_GEN2_SUB_COMM = 2,
};

struct mtk_smi_reg_pair;

struct mtk_smi_common_plat {
	enum mtk_smi_type type;
	bool has_gals;
	u32 bus_sel;
	const struct mtk_smi_reg_pair *init;
};

struct mtk_smi_reg_pair {
	unsigned int offset;
	u32 value;
};

struct mtk_smi_larb_gen {
	int port_in_larb[33];
	int (*config_port)(struct device *);
	unsigned int larb_direct_to_common_mask;
	unsigned int flags_general;
	const u8 (*ostd)[32];
};

enum iommu_atf_cmd {
	IOMMU_ATF_CMD_CONFIG_SMI_LARB = 0,
	IOMMU_ATF_CMD_CONFIG_INFRA_IOMMU = 1,
	IOMMU_ATF_CMD_MAX = 2,
};

struct mtk_smi {
	struct device *dev;
	unsigned int clk_num;
	struct clk_bulk_data clks[4];
	struct clk *clk_async;
	union {
		void *smi_ao_base;
		void *base;
	};
	struct device *smi_common_dev;
	const struct mtk_smi_common_plat *plat;
};

struct mtk_smi_larb {
	struct mtk_smi smi;
	void *base;
	struct device *smi_common_dev;
	const struct mtk_smi_larb_gen *larb_gen;
	int larbid;
	u32 *mmu;
	unsigned char *bank;
};

struct mtk_smi_larb_iommu {
	struct device *dev;
	unsigned int mmu;
	unsigned char bank[32];
};

struct tee_device {
	char name[32];
	const struct tee_desc *desc;
	int id;
	unsigned int flags;
	struct device dev;
	struct cdev cdev;
	size_t num_users;
	struct completion c_no_users;
	struct mutex mutex;
	struct idr idr;
	struct tee_shm_pool *pool;
};

struct tee_ioctl_buf_data {
	__u64 buf_ptr;
	__u64 buf_len;
};

struct tee_ioctl_shm_register_data {
	__u64 addr;
	__u64 length;
	__u32 flags;
	__s32 id;
};

struct tee_iocl_supp_recv_arg {
	__u32 func;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_iocl_supp_send_arg {
	__u32 ret;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_ioctl_close_session_arg {
	__u32 session;
};

struct tee_ioctl_cancel_arg {
	__u32 cancel_id;
	__u32 session;
};

struct tee_ioctl_shm_alloc_data {
	__u64 size;
	__u32 flags;
	__s32 id;
};

struct match_dev_data {
	struct tee_ioctl_version_data *vers;
	const void *data;
	int (*match)(struct tee_ioctl_version_data *, const void *);
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

struct compat_ifmap {
	compat_ulong_t mem_start;
	compat_ulong_t mem_end;
	unsigned short base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct compat_if_settings {
	unsigned int type;
	unsigned int size;
	compat_uptr_t ifs_ifsu;
};

struct compat_ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short ifru_flags;
		compat_int_t ifru_ivalue;
		compat_int_t ifru_mtu;
		struct compat_ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		compat_caddr_t ifru_data;
		struct compat_if_settings ifru_settings;
	} ifr_ifru;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct ifconf {
	int ifc_len;
	union {
		char __attribute__((btf_type_tag("user"))) *ifcu_buf;
		struct ifreq __attribute__((btf_type_tag("user"))) *ifcu_req;
	} ifc_ifcu;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

struct percpu_free_defer {
	struct callback_head rcu;
	void __attribute__((btf_type_tag("percpu"))) *ptr;
};

struct gro_cells {
	struct gro_cell __attribute__((btf_type_tag("percpu"))) *cells;
};

enum offload_act_command {
	FLOW_ACT_REPLACE = 0,
	FLOW_ACT_DESTROY = 1,
	FLOW_ACT_STATS = 2,
};

enum {
	TCA_ROOT_UNSPEC = 0,
	TCA_ROOT_TAB = 1,
	TCA_ROOT_FLAGS = 2,
	TCA_ROOT_COUNT = 3,
	TCA_ROOT_TIME_DELTA = 4,
	TCA_ROOT_EXT_WARN_MSG = 5,
	__TCA_ROOT_MAX = 6,
};

struct tc_act_pernet_id {
	struct list_head list;
	unsigned int id;
};

struct tcamsg {
	unsigned char tca_family;
	unsigned char tca__pad1;
	unsigned short tca__pad2;
};

struct flow_offload_action {
	struct netlink_ext_ack *extack;
	enum offload_act_command command;
	enum flow_action_id id;
	u32 index;
	unsigned long cookie;
	struct flow_stats stats;
	struct flow_action action;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct tc_action_net {
	struct tcf_idrinfo *idrinfo;
	const struct tc_action_ops *ops;
};

enum {
	ETHTOOL_A_MODULE_UNSPEC = 0,
	ETHTOOL_A_MODULE_HEADER = 1,
	ETHTOOL_A_MODULE_POWER_MODE_POLICY = 2,
	ETHTOOL_A_MODULE_POWER_MODE = 3,
	__ETHTOOL_A_MODULE_CNT = 4,
	ETHTOOL_A_MODULE_MAX = 3,
};

struct module_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_module_power_mode_params power;
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
};

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);

enum ip_conntrack_info {
	IP_CT_ESTABLISHED = 0,
	IP_CT_RELATED = 1,
	IP_CT_NEW = 2,
	IP_CT_IS_REPLY = 3,
	IP_CT_ESTABLISHED_REPLY = 3,
	IP_CT_RELATED_REPLY = 4,
	IP_CT_NUMBER = 5,
	IP_CT_UNTRACKED = 7,
};

enum sctp_conntrack {
	SCTP_CONNTRACK_NONE = 0,
	SCTP_CONNTRACK_CLOSED = 1,
	SCTP_CONNTRACK_COOKIE_WAIT = 2,
	SCTP_CONNTRACK_COOKIE_ECHOED = 3,
	SCTP_CONNTRACK_ESTABLISHED = 4,
	SCTP_CONNTRACK_SHUTDOWN_SENT = 5,
	SCTP_CONNTRACK_SHUTDOWN_RECD = 6,
	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,
	SCTP_CONNTRACK_HEARTBEAT_SENT = 8,
	SCTP_CONNTRACK_HEARTBEAT_ACKED = 9,
	SCTP_CONNTRACK_MAX = 10,
};

enum ip_conntrack_status {
	IPS_EXPECTED_BIT = 0,
	IPS_EXPECTED = 1,
	IPS_SEEN_REPLY_BIT = 1,
	IPS_SEEN_REPLY = 2,
	IPS_ASSURED_BIT = 2,
	IPS_ASSURED = 4,
	IPS_CONFIRMED_BIT = 3,
	IPS_CONFIRMED = 8,
	IPS_SRC_NAT_BIT = 4,
	IPS_SRC_NAT = 16,
	IPS_DST_NAT_BIT = 5,
	IPS_DST_NAT = 32,
	IPS_NAT_MASK = 48,
	IPS_SEQ_ADJUST_BIT = 6,
	IPS_SEQ_ADJUST = 64,
	IPS_SRC_NAT_DONE_BIT = 7,
	IPS_SRC_NAT_DONE = 128,
	IPS_DST_NAT_DONE_BIT = 8,
	IPS_DST_NAT_DONE = 256,
	IPS_NAT_DONE_MASK = 384,
	IPS_DYING_BIT = 9,
	IPS_DYING = 512,
	IPS_FIXED_TIMEOUT_BIT = 10,
	IPS_FIXED_TIMEOUT = 1024,
	IPS_TEMPLATE_BIT = 11,
	IPS_TEMPLATE = 2048,
	IPS_UNTRACKED_BIT = 12,
	IPS_UNTRACKED = 4096,
	IPS_NAT_CLASH_BIT = 12,
	IPS_NAT_CLASH = 4096,
	IPS_HELPER_BIT = 13,
	IPS_HELPER = 8192,
	IPS_OFFLOAD_BIT = 14,
	IPS_OFFLOAD = 16384,
	IPS_HW_OFFLOAD_BIT = 15,
	IPS_HW_OFFLOAD = 32768,
	IPS_UNCHANGEABLE_MASK = 56313,
	__IPS_MAX_BIT = 16,
};

union nf_inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

union nf_conntrack_man_proto {
	__be16 all;
	struct {
		__be16 port;
	} tcp;
	struct {
		__be16 port;
	} udp;
	struct {
		__be16 id;
	} icmp;
	struct {
		__be16 port;
	} dccp;
	struct {
		__be16 port;
	} sctp;
	struct {
		__be16 key;
	} gre;
};

typedef u16 u_int16_t;

struct nf_conntrack_man {
	union nf_inet_addr u3;
	union nf_conntrack_man_proto u;
	u_int16_t l3num;
};

struct nf_conntrack_tuple {
	struct nf_conntrack_man src;
	struct {
		union nf_inet_addr u3;
		union {
			__be16 all;
			struct {
				__be16 port;
			} tcp;
			struct {
				__be16 port;
			} udp;
			struct {
				u_int8_t type;
				u_int8_t code;
			} icmp;
			struct {
				__be16 port;
			} dccp;
			struct {
				__be16 port;
			} sctp;
			struct {
				__be16 key;
			} gre;
		} u;
		u_int8_t protonum;
		struct {} __nfct_hash_offsetend;
		u_int8_t dir;
	} dst;
};

struct nf_conntrack_tuple_hash {
	struct hlist_nulls_node hnnode;
	struct nf_conntrack_tuple tuple;
};

typedef u64 u_int64_t;

struct nf_ct_dccp {
	u_int8_t role[2];
	u_int8_t state;
	u_int8_t last_pkt;
	u_int8_t last_dir;
	u_int64_t handshake_seq;
};

struct ip_ct_sctp {
	enum sctp_conntrack state;
	__be32 vtag[2];
	u8 init[2];
	u8 last_dir;
	u8 flags;
};

typedef u32 u_int32_t;

struct ip_ct_tcp_state {
	u_int32_t td_end;
	u_int32_t td_maxend;
	u_int32_t td_maxwin;
	u_int32_t td_maxack;
	u_int8_t td_scale;
	u_int8_t flags;
};

struct ip_ct_tcp {
	struct ip_ct_tcp_state seen[2];
	u_int8_t state;
	u_int8_t last_dir;
	u_int8_t retrans;
	u_int8_t last_index;
	u_int32_t last_seq;
	u_int32_t last_ack;
	u_int32_t last_end;
	u_int16_t last_win;
	u_int8_t last_wscale;
	u_int8_t last_flags;
};

struct nf_ct_udp {
	unsigned long stream_ts;
};

struct nf_ct_gre {
	unsigned int stream_timeout;
	unsigned int timeout;
};

union nf_conntrack_proto {
	struct nf_ct_dccp dccp;
	struct ip_ct_sctp sctp;
	struct ip_ct_tcp tcp;
	struct nf_ct_udp udp;
	struct nf_ct_gre gre;
	unsigned int tmpl_padto;
};

struct nf_ct_ext;

struct nf_conn {
	struct nf_conntrack ct_general;
	spinlock_t lock;
	u32 timeout;
	struct nf_conntrack_tuple_hash tuplehash[2];
	unsigned long status;
	possible_net_t ct_net;
	struct hlist_node nat_bysource;
	struct {} __nfct_init_offset;
	struct nf_conn *master;
	struct nf_ct_ext *ext;
	union nf_conntrack_proto proto;
};

enum devlink_dpipe_match_type {
	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT = 0,
};

enum devlink_dpipe_action_type {
	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY = 0,
};

struct devlink_dpipe_table_ops;

struct devlink_dpipe_table {
	void *priv;
	struct list_head list;
	const char *name;
	bool counters_enabled;
	bool counter_control_extern;
	bool resource_valid;
	u64 resource_id;
	u64 resource_units;
	struct devlink_dpipe_table_ops *table_ops;
	struct callback_head rcu;
};

struct devlink_dpipe_dump_ctx;

struct devlink_dpipe_table_ops {
	int (*actions_dump)(void *, struct sk_buff *);
	int (*matches_dump)(void *, struct sk_buff *);
	int (*entries_dump)(void *, bool, struct devlink_dpipe_dump_ctx *);
	int (*counters_set_update)(void *, bool);
	u64 (*size_get)(void *);
};

struct devlink_dpipe_dump_ctx {
	struct genl_info *info;
	enum devlink_command cmd;
	struct sk_buff *skb;
	struct nlattr *nest;
	void *hdr;
};

struct devlink_dpipe_value;

struct devlink_dpipe_entry {
	u64 index;
	struct devlink_dpipe_value *match_values;
	unsigned int match_values_count;
	struct devlink_dpipe_value *action_values;
	unsigned int action_values_count;
	u64 counter;
	bool counter_valid;
};

struct devlink_dpipe_action;

struct devlink_dpipe_match;

struct devlink_dpipe_value {
	union {
		struct devlink_dpipe_action *action;
		struct devlink_dpipe_match *match;
	};
	unsigned int mapping_value;
	bool mapping_valid;
	unsigned int value_size;
	void *value;
	void *mask;
};

struct devlink_dpipe_action {
	enum devlink_dpipe_action_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_match {
	enum devlink_dpipe_match_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct svc_xpt_user {
	struct list_head list;
	void (*callback)(struct svc_xpt_user *);
};

struct wchan_info {
	unsigned long pc;
	int count;
};

struct kvm_stats_header {
	__u32 flags;
	__u32 name_size;
	__u32 num_desc;
	__u32 id_offset;
	__u32 desc_offset;
	__u32 data_offset;
};

struct sve_state_reg_region {
	unsigned int koffset;
	unsigned int klen;
	unsigned int upad;
};

typedef u64 hfn_t;

typedef hfn_t kvm_pfn_t;

struct kvm_regs {
	struct user_pt_regs regs;
	__u64 sp_el1;
	__u64 elr_el1;
	__u64 spsr[5];
	long: 64;
	struct user_fpsimd_state fp_regs;
};

struct kvm_sregs {};

struct kvm_vcpu_events {
	struct {
		__u8 serror_pending;
		__u8 serror_has_esr;
		__u8 ext_dabt_pending;
		__u8 pad[5];
		__u64 serror_esr;
	} exception;
	__u32 reserved[12];
};

struct kvm_fpu {};

struct kvm_translation {
	__u64 linear_address;
	__u64 physical_address;
	__u8 valid;
	__u8 writeable;
	__u8 usermode;
	__u8 pad[5];
};

struct kvm_guest_debug {
	__u32 control;
	__u32 pad;
	struct kvm_guest_debug_arch arch;
};

struct kvm_arm_copy_mte_tags {
	__u64 guest_ipa;
	__u64 length;
	void __attribute__((btf_type_tag("user"))) *addr;
	__u64 flags;
	__u64 reserved[2];
};

struct sha1_state {
	u32 state[5];
	u64 count;
	u8 buffer[64];
};

struct sha1_ce_state {
	struct sha1_state sst;
	u32 finalize;
};

typedef void sha1_block_fn(struct sha1_state *, const u8 *, int);

struct user_event_mm {
	struct list_head mms_link;
	struct list_head enablers;
	struct mm_struct *mm;
	struct user_event_mm *next;
	refcount_t refcnt;
	refcount_t tasks;
	struct rcu_work put_rwork;
};

struct waitid_info;

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

typedef void (*btf_trace_rcu_grace_period)(void *, const char *, unsigned long, const char *);

typedef void (*btf_trace_rcu_future_grace_period)(void *, const char *, unsigned long, unsigned long, u8, int, int, const char *);

typedef void (*btf_trace_rcu_grace_period_init)(void *, const char *, unsigned long, u8, int, int, unsigned long);

typedef void (*btf_trace_rcu_exp_grace_period)(void *, const char *, unsigned long, const char *);

typedef void (*btf_trace_rcu_exp_funnel_lock)(void *, const char *, u8, int, int, const char *);

typedef void (*btf_trace_rcu_preempt_task)(void *, const char *, int, unsigned long);

typedef void (*btf_trace_rcu_unlock_preempted_task)(void *, const char *, unsigned long, int);

typedef void (*btf_trace_rcu_quiescent_state_report)(void *, const char *, unsigned long, unsigned long, unsigned long, u8, int, int, int);

typedef void (*btf_trace_rcu_fqs)(void *, const char *, unsigned long, int, const char *);

typedef void (*btf_trace_rcu_stall_warning)(void *, const char *, const char *);

typedef void (*btf_trace_rcu_dyntick)(void *, const char *, long, long, int);

typedef void (*btf_trace_rcu_callback)(void *, const char *, struct callback_head *, long);

typedef void (*btf_trace_rcu_segcb_stats)(void *, struct rcu_segcblist *, const char *);

typedef void (*btf_trace_rcu_kvfree_callback)(void *, const char *, struct callback_head *, unsigned long, long);

typedef void (*btf_trace_rcu_batch_start)(void *, const char *, long, long);

typedef void (*btf_trace_rcu_invoke_callback)(void *, const char *, struct callback_head *);

typedef void (*btf_trace_rcu_invoke_kvfree_callback)(void *, const char *, struct callback_head *, unsigned long);

typedef void (*btf_trace_rcu_invoke_kfree_bulk_callback)(void *, const char *, unsigned long, void **);

typedef void (*btf_trace_rcu_batch_end)(void *, const char *, int, char, char, char, char);

typedef void (*btf_trace_rcu_torture_read)(void *, const char *, struct callback_head *, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_rcu_barrier)(void *, const char *, const char *, int, int, unsigned long);

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)(struct list_head *);

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_tasks_percpu;

struct rcu_tasks {
	struct rcuwait cbs_wait;
	raw_spinlock_t cbs_gbl_lock;
	struct mutex tasks_gp_mutex;
	int gp_state;
	int gp_sleep;
	int init_fract;
	unsigned long gp_jiffies;
	unsigned long gp_start;
	unsigned long tasks_gp_seq;
	unsigned long n_ipis;
	unsigned long n_ipis_fails;
	struct task_struct *kthread_ptr;
	unsigned long lazy_jiffies;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	struct rcu_tasks_percpu __attribute__((btf_type_tag("percpu"))) *rtpcpu;
	int percpu_enqueue_shift;
	int percpu_enqueue_lim;
	int percpu_dequeue_lim;
	unsigned long percpu_dequeue_gpseq;
	struct mutex barrier_q_mutex;
	atomic_t barrier_q_count;
	struct completion barrier_q_completion;
	unsigned long barrier_q_seq;
	char *name;
	char *kname;
};

struct rcu_tasks_percpu {
	struct rcu_segcblist cblist;
	raw_spinlock_t lock;
	unsigned long rtp_jiffies;
	unsigned long rtp_n_lock_retries;
	struct timer_list lazy_timer;
	unsigned int urgent_gp;
	struct work_struct rtp_work;
	struct irq_work rtp_irq_work;
	struct callback_head barrier_q_head;
	struct list_head rtp_blkd_tasks;
	int cpu;
	struct rcu_tasks *rtpp;
};

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long gp_seq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_future_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long gp_seq;
	long gp_seq_req;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period_init {
	struct trace_entry ent;
	const char *rcuname;
	long gp_seq;
	u8 level;
	int grplo;
	int grphi;
	unsigned long qsmask;
	char __data[0];
};

struct trace_event_raw_rcu_exp_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long gpseq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_exp_funnel_lock {
	struct trace_entry ent;
	const char *rcuname;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_preempt_task {
	struct trace_entry ent;
	const char *rcuname;
	long gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_unlock_preempted_task {
	struct trace_entry ent;
	const char *rcuname;
	long gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_quiescent_state_report {
	struct trace_entry ent;
	const char *rcuname;
	long gp_seq;
	unsigned long mask;
	unsigned long qsmask;
	u8 level;
	int grplo;
	int grphi;
	u8 gp_tasks;
	char __data[0];
};

struct trace_event_raw_rcu_fqs {
	struct trace_entry ent;
	const char *rcuname;
	long gp_seq;
	int cpu;
	const char *qsevent;
	char __data[0];
};

struct trace_event_raw_rcu_stall_warning {
	struct trace_entry ent;
	const char *rcuname;
	const char *msg;
	char __data[0];
};

struct trace_event_raw_rcu_dyntick {
	struct trace_entry ent;
	const char *polarity;
	long oldnesting;
	long newnesting;
	int dynticks;
	char __data[0];
};

struct trace_event_raw_rcu_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	long qlen;
	char __data[0];
};

struct trace_event_raw_rcu_segcb_stats {
	struct trace_entry ent;
	const char *ctx;
	unsigned long gp_seq[4];
	long seglen[4];
	char __data[0];
};

struct trace_event_raw_rcu_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	unsigned long offset;
	long qlen;
	char __data[0];
};

struct trace_event_raw_rcu_batch_start {
	struct trace_entry ent;
	const char *rcuname;
	long qlen;
	long blimit;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	unsigned long offset;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kfree_bulk_callback {
	struct trace_entry ent;
	const char *rcuname;
	unsigned long nr_records;
	void **p;
	char __data[0];
};

struct trace_event_raw_rcu_batch_end {
	struct trace_entry ent;
	const char *rcuname;
	int callbacks_invoked;
	char cb;
	char nr;
	char iit;
	char risk;
	char __data[0];
};

struct trace_event_raw_rcu_torture_read {
	struct trace_entry ent;
	char rcutorturename[8];
	struct callback_head *rhp;
	unsigned long secs;
	unsigned long c_old;
	unsigned long c;
	char __data[0];
};

struct trace_event_raw_rcu_barrier {
	struct trace_entry ent;
	const char *rcuname;
	const char *s;
	int cpu;
	int cnt;
	unsigned long done;
	char __data[0];
};

struct trc_stall_chk_rdr {
	int nesting;
	int ipi_to_cpu;
	u8 needqs;
};

struct trace_event_data_offsets_rcu_utilization {};

struct trace_event_data_offsets_rcu_grace_period {};

struct trace_event_data_offsets_rcu_future_grace_period {};

struct trace_event_data_offsets_rcu_grace_period_init {};

struct trace_event_data_offsets_rcu_exp_grace_period {};

struct trace_event_data_offsets_rcu_exp_funnel_lock {};

struct trace_event_data_offsets_rcu_preempt_task {};

struct trace_event_data_offsets_rcu_unlock_preempted_task {};

struct trace_event_data_offsets_rcu_quiescent_state_report {};

struct trace_event_data_offsets_rcu_fqs {};

struct trace_event_data_offsets_rcu_stall_warning {};

struct trace_event_data_offsets_rcu_dyntick {};

struct trace_event_data_offsets_rcu_callback {};

struct trace_event_data_offsets_rcu_segcb_stats {};

struct trace_event_data_offsets_rcu_kvfree_callback {};

struct trace_event_data_offsets_rcu_batch_start {};

struct trace_event_data_offsets_rcu_invoke_callback {};

struct trace_event_data_offsets_rcu_invoke_kvfree_callback {};

struct trace_event_data_offsets_rcu_invoke_kfree_bulk_callback {};

struct trace_event_data_offsets_rcu_batch_end {};

struct trace_event_data_offsets_rcu_torture_read {};

struct trace_event_data_offsets_rcu_barrier {};

enum freezer_state_flags {
	CGROUP_FREEZER_ONLINE = 1,
	CGROUP_FREEZING_SELF = 2,
	CGROUP_FREEZING_PARENT = 4,
	CGROUP_FROZEN = 8,
	CGROUP_FREEZING = 6,
};

struct freezer {
	struct cgroup_subsys_state css;
	unsigned int state;
};

struct tp_transition_snapshot {
	unsigned long rcu;
	unsigned long srcu;
	bool ongoing;
};

enum tp_func_state {
	TP_FUNC_0 = 0,
	TP_FUNC_1 = 1,
	TP_FUNC_2 = 2,
	TP_FUNC_N = 3,
};

enum tp_transition_sync {
	TP_TRANSITION_SYNC_1_0_1 = 0,
	TP_TRANSITION_SYNC_N_2_1 = 1,
	_NR_TP_TRANSITION_SYNC = 2,
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

struct tracer_stat;

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

typedef void (*btf_trace_error_report_end)(void *, enum error_detector, unsigned long);

struct trace_event_raw_error_report_template {
	struct trace_entry ent;
	enum error_detector error_detector;
	unsigned long id;
	char __data[0];
};

struct trace_event_data_offsets_error_report_template {};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct xol_area {
	wait_queue_head_t wq;
	atomic_t slot_count;
	unsigned long *bitmap;
	struct vm_special_mapping xol_mapping;
	struct page *pages[2];
	unsigned long vaddr;
};

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct uprobe_consumer *consumers;
	struct inode *inode;
	loff_t offset;
	loff_t ref_ctr_offset;
	unsigned long flags;
	struct arch_uprobe arch;
};

typedef __le32 uprobe_opcode_t;

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct *mm;
};

struct __uprobe_key {
	struct inode *inode;
	loff_t offset;
};

struct map_info___2 {
	struct map_info___2 *next;
	struct mm_struct *mm;
	unsigned long vaddr;
};

typedef void (*btf_trace_mmap_lock_start_locking)(void *, struct mm_struct *, const char *, bool);

typedef void (*btf_trace_mmap_lock_released)(void *, struct mm_struct *, const char *, bool);

typedef void (*btf_trace_mmap_lock_acquire_returned)(void *, struct mm_struct *, const char *, bool, bool);

struct memcg_path {
	local_lock_t lock;
	char __attribute__((btf_type_tag("rcu"))) *buf;
	local_t buf_idx;
};

struct trace_event_raw_mmap_lock {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	char __data[0];
};

struct trace_event_raw_mmap_lock_acquire_returned {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	bool success;
	char __data[0];
};

struct trace_event_data_offsets_mmap_lock {
	u32 memcg_path;
};

struct trace_event_data_offsets_mmap_lock_acquire_returned {
	u32 memcg_path;
};

struct mempolicy_operations {
	int (*create)(struct mempolicy *, const nodemask_t *);
	void (*rebind)(struct mempolicy *, const nodemask_t *);
};

enum {
	MPOL_DEFAULT = 0,
	MPOL_PREFERRED = 1,
	MPOL_BIND = 2,
	MPOL_INTERLEAVE = 3,
	MPOL_LOCAL = 4,
	MPOL_PREFERRED_MANY = 5,
	MPOL_MAX = 6,
};

struct sp_node {
	struct rb_node nd;
	unsigned long start;
	unsigned long end;
	struct mempolicy *policy;
};

struct migration_mpol {
	struct mempolicy *pol;
	unsigned long ilx;
};

struct queue_pages {
	struct list_head *pagelist;
	unsigned long flags;
	nodemask_t *nmask;
	unsigned long start;
	unsigned long end;
	struct vm_area_struct *first;
	struct folio *large;
	long nr_failed;
};

struct nodemask_scratch {
	nodemask_t mask1;
	nodemask_t mask2;
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
	FSCONFIG_CMD_CREATE_EXCL = 8,
};

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct map_files_info {
	unsigned long start;
	unsigned long end;
	fmode_t mode;
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

struct msdos_dir_entry {
	__u8 name[11];
	__u8 attr;
	__u8 lcase;
	__u8 ctime_cs;
	__le16 ctime;
	__le16 cdate;
	__le16 adate;
	__le16 starthi;
	__le16 time;
	__le16 date;
	__le16 start;
	__le32 size;
};

struct fat_slot_info {
	loff_t i_pos;
	loff_t slot_off;
	int nr_slots;
	struct msdos_dir_entry *de;
	struct buffer_head *bh;
};

struct msdos_dir_slot {
	__u8 id;
	__u8 name0_4[10];
	__u8 attr;
	__u8 reserved;
	__u8 alias_checksum;
	__u8 name5_10[12];
	__le16 start;
	__u8 name11_12[4];
};

struct shortname_info {
	unsigned char lower: 1;
	unsigned char upper: 1;
	unsigned char valid: 1;
};

struct nfs4_secinfo4 {
	u32 flavor;
	struct rpcsec_gss_info flavor_info;
};

struct nfs4_secinfo_flavors {
	unsigned int num_flavors;
	struct nfs4_secinfo4 flavors[0];
};

enum integrity_status {
	INTEGRITY_PASS = 0,
	INTEGRITY_PASS_IMMUTABLE = 1,
	INTEGRITY_FAIL = 2,
	INTEGRITY_FAIL_IMMUTABLE = 3,
	INTEGRITY_NOLABEL = 4,
	INTEGRITY_NOXATTRS = 5,
	INTEGRITY_UNKNOWN = 6,
};

struct ima_digest_data;

struct integrity_iint_cache {
	struct rb_node rb_node;
	struct mutex mutex;
	struct inode *inode;
	u64 version;
	unsigned long flags;
	unsigned long measured_pcrs;
	unsigned long atomic_flags;
	unsigned long real_ino;
	dev_t real_dev;
	enum integrity_status ima_file_status: 4;
	enum integrity_status ima_mmap_status: 4;
	enum integrity_status ima_bprm_status: 4;
	enum integrity_status ima_read_status: 4;
	enum integrity_status ima_creds_status: 4;
	enum integrity_status evm_status: 4;
	struct ima_digest_data *ima_hash;
};

struct ima_digest_data {
	u8 algo;
	u8 length;
	union {
		struct {
			u8 unused;
			u8 type;
		} sha1;
		struct {
			u8 type;
			u8 algo;
		} ng;
		u8 data[2];
	} xattr;
	u8 digest[0];
};

struct crypto_sig {
	struct crypto_tfm base;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	struct {
		struct rtattr attr;
		struct crypto_attr_alg data;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
};

enum dd_prio {
	DD_RT_PRIO = 0,
	DD_BE_PRIO = 1,
	DD_IDLE_PRIO = 2,
	DD_PRIO_MAX = 2,
};

enum dd_data_dir {
	DD_READ = 0,
	DD_WRITE = 1,
};

struct io_stats_per_prio {
	uint32_t inserted;
	uint32_t merged;
	uint32_t dispatched;
	atomic_t completed;
};

struct dd_per_prio {
	struct list_head dispatch;
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	sector_t latest_pos[2];
	struct io_stats_per_prio stats;
};

struct deadline_data {
	struct dd_per_prio per_prio[3];
	enum dd_data_dir last_dir;
	unsigned int batching;
	unsigned int starved;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	u32 async_depth;
	int prio_aging_expire;
	spinlock_t lock;
	spinlock_t zone_lock;
};

struct epoll_event {
	__poll_t events;
	__u64 data;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t;

struct barrett_ctx_s {
	MPI m;
	int m_copied;
	int k;
	MPI y;
	MPI r1;
	MPI r2;
	MPI r3;
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
	DEVM_IOREMAP_NP = 3,
};

struct pcim_iomap_devres {
	void *table[6];
};

struct arch_io_reserve_memtype_wc_devres {
	resource_size_t start;
	resource_size_t size;
};

struct partition_affinity;

struct partition_desc {
	int nr_parts;
	struct partition_affinity *parts;
	struct irq_domain *domain;
	struct irq_desc *chained_desc;
	unsigned long *bitmap;
	struct irq_domain_ops ops;
};

struct partition_affinity {
	cpumask_t mask;
	void *partition_id;
};

enum sysc_soc {
	SOC_UNKNOWN = 0,
	SOC_2420 = 1,
	SOC_2430 = 2,
	SOC_3430 = 3,
	SOC_AM35 = 4,
	SOC_3630 = 5,
	SOC_4430 = 6,
	SOC_4460 = 7,
	SOC_4470 = 8,
	SOC_5430 = 9,
	SOC_AM3 = 10,
	SOC_AM4 = 11,
	SOC_DRA7 = 12,
};

struct sysc_soc_info {
	unsigned long general_purpose: 1;
	enum sysc_soc soc;
	struct mutex list_lock;
	struct list_head disabled_modules;
	struct list_head restored_modules;
	struct notifier_block nb;
};

struct sysc_dts_quirk {
	const char *name;
	u32 mask;
};

struct sysc_revision_quirk {
	const char *name;
	u32 base;
	int rev_offset;
	int sysc_offset;
	int syss_offset;
	u32 revision;
	u32 revision_mask;
	u32 quirks;
};

enum ti_sysc_module_type {
	TI_SYSC_OMAP2 = 0,
	TI_SYSC_OMAP2_TIMER = 1,
	TI_SYSC_OMAP3_SHAM = 2,
	TI_SYSC_OMAP3_AES = 3,
	TI_SYSC_OMAP4 = 4,
	TI_SYSC_OMAP4_TIMER = 5,
	TI_SYSC_OMAP4_SIMPLE = 6,
	TI_SYSC_OMAP34XX_SR = 7,
	TI_SYSC_OMAP36XX_SR = 8,
	TI_SYSC_OMAP4_SR = 9,
	TI_SYSC_OMAP4_MCASP = 10,
	TI_SYSC_OMAP4_USB_HOST_FS = 11,
	TI_SYSC_DRA7_MCAN = 12,
	TI_SYSC_PRUSS = 13,
};

struct sysc_regbits;

struct sysc_capabilities {
	const enum ti_sysc_module_type type;
	const u32 sysc_mask;
	const struct sysc_regbits *regbits;
	const u32 mod_quirks;
};

struct sysc_regbits {
	s8 midle_shift;
	s8 clkact_shift;
	s8 sidle_shift;
	s8 enwkup_shift;
	s8 srst_shift;
	s8 autoidle_shift;
	s8 dmadisable_shift;
	s8 emufree_shift;
};

enum sysc_registers {
	SYSC_REVISION = 0,
	SYSC_SYSCONFIG = 1,
	SYSC_SYSSTATUS = 2,
	SYSC_MAX_REGS = 3,
};

enum sysc_clocks {
	SYSC_FCK = 0,
	SYSC_ICK = 1,
	SYSC_OPTFCK0 = 2,
	SYSC_OPTFCK1 = 3,
	SYSC_OPTFCK2 = 4,
	SYSC_OPTFCK3 = 5,
	SYSC_OPTFCK4 = 6,
	SYSC_OPTFCK5 = 7,
	SYSC_OPTFCK6 = 8,
	SYSC_OPTFCK7 = 9,
	SYSC_MAX_CLOCKS = 10,
};

struct sysc_address {
	unsigned long base;
	struct list_head node;
};

struct sysc_config {
	u32 sysc_val;
	u32 syss_mask;
	u8 midlemodes;
	u8 sidlemodes;
	u8 srst_udelay;
	u32 quirks;
};

struct ti_sysc_cookie {
	void *data;
	void *clkdm;
};

struct ti_sysc_module_data;

struct sysc {
	struct device *dev;
	u64 module_pa;
	u32 module_size;
	void *module_va;
	int offsets[3];
	struct ti_sysc_module_data *mdata;
	struct clk **clocks;
	const char **clock_roles;
	int nr_clocks;
	struct reset_control *rsts;
	const char *legacy_mode;
	const struct sysc_capabilities *cap;
	struct sysc_config cfg;
	struct ti_sysc_cookie cookie;
	const char *name;
	u32 revision;
	u32 sysconfig;
	unsigned int reserved: 1;
	unsigned int enabled: 1;
	unsigned int needs_resume: 1;
	unsigned int child_needs_resume: 1;
	struct delayed_work idle_work;
	void (*pre_reset_quirk)(struct sysc *);
	void (*post_reset_quirk)(struct sysc *);
	void (*reset_done_quirk)(struct sysc *);
	void (*module_enable_quirk)(struct sysc *);
	void (*module_disable_quirk)(struct sysc *);
	void (*module_unlock_quirk)(struct sysc *);
	void (*module_lock_quirk)(struct sysc *);
};

struct ti_sysc_module_data {
	const char *name;
	u64 module_pa;
	u32 module_size;
	int *offsets;
	int nr_offsets;
	const struct sysc_capabilities *cap;
	struct sysc_config *cfg;
};

struct sysc_module {
	struct sysc *ddata;
	struct list_head node;
};

struct ti_sysc_platform_data {
	struct of_dev_auxdata *auxdata;
	bool (*soc_type_gp)();
	int (*init_clockdomain)(struct device *, struct clk *, struct clk *, struct ti_sysc_cookie *);
	void (*clkdm_deny_idle)(struct device *, const struct ti_sysc_cookie *);
	void (*clkdm_allow_idle)(struct device *, const struct ti_sysc_cookie *);
	int (*init_module)(struct device *, const struct ti_sysc_module_data *, struct ti_sysc_cookie *);
	int (*enable_module)(struct device *, const struct ti_sysc_cookie *);
	int (*idle_module)(struct device *, const struct ti_sysc_cookie *);
	int (*shutdown_module)(struct device *, const struct ti_sysc_cookie *);
};

struct tegra_xusb_usb2_lane {
	struct tegra_xusb_lane base;
	u32 hs_curr_level_offset;
	bool powered_on;
};

struct tegra_xusb_usb2_pad {
	struct tegra_xusb_pad base;
	struct clk *clk;
	unsigned int enable;
	struct mutex lock;
};

struct tegra124_xusb_fuse_calibration {
	u32 hs_curr_level[3];
	u32 hs_iref_cap;
	u32 hs_term_range_adj;
	u32 hs_squelch_level;
};

struct tegra124_xusb_padctl {
	struct tegra_xusb_padctl base;
	struct tegra124_xusb_fuse_calibration fuse;
};

struct tegra_xusb_ulpi_lane {
	struct tegra_xusb_lane base;
};

struct tegra_xusb_ulpi_pad {
	struct tegra_xusb_pad base;
};

struct tegra_xusb_hsic_lane {
	struct tegra_xusb_lane base;
	u32 strobe_trim;
	u32 rx_strobe_trim;
	u32 rx_data_trim;
	u32 tx_rtune_n;
	u32 tx_rtune_p;
	u32 tx_rslew_n;
	u32 tx_rslew_p;
	bool auto_term;
};

struct tegra_xusb_hsic_pad {
	struct tegra_xusb_pad base;
	struct regulator *supply;
	struct clk *clk;
};

struct tegra_xusb_pcie_lane {
	struct tegra_xusb_lane base;
};

struct tegra_xusb_pcie_pad {
	struct tegra_xusb_pad base;
	struct reset_control *rst;
	struct clk *pll;
	bool enable;
};

struct tegra_xusb_sata_lane {
	struct tegra_xusb_lane base;
};

struct tegra_xusb_sata_pad {
	struct tegra_xusb_pad base;
	struct reset_control *rst;
	struct clk *pll;
	bool enable;
};

enum ioctrl_regs___5 {
	POCCTRL0___3 = 0,
	POCCTRL1___2 = 1,
	POCCTRL2___3 = 2,
	POCCTRL3 = 3,
	TDSELCTRL___4 = 4,
};

enum {
	GP_LAST___3 = 174,
	PIN_DCUTCK_LPDCLK = 175,
	PIN_DCUTDI_LPDI = 176,
	PIN_DCUTMS = 177,
	PIN_DCUTRST_N = 178,
	PIN_DU_DOTCLKIN___2 = 179,
	PIN_EXTALR___2 = 180,
	PIN_FSCLKST = 181,
	PIN_FSCLKST_N___3 = 182,
	PIN_PRESETOUT_N___3 = 183,
	PIN_VDDQ_AVB = 184,
	PIN_VDDQ_GE = 185,
};

struct rzv2m_dedicated_configs;

struct rzv2m_pinctrl_data {
	const char * const *port_pins;
	const u32 *port_pin_configs;
	const struct rzv2m_dedicated_configs *dedicated_pins;
	unsigned int n_port_pins;
	unsigned int n_dedicated_pins;
};

struct rzv2m_dedicated_configs {
	const char *name;
	u32 config;
};

struct rzv2m_pinctrl {
	struct pinctrl_dev *pctl;
	struct pinctrl_desc desc;
	struct pinctrl_pin_desc *pins;
	const struct rzv2m_pinctrl_data *data;
	void *base;
	struct device *dev;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range gpio_range;
	spinlock_t lock;
	struct mutex mutex;
};

struct mxc_gpio_hwdata {
	unsigned int dr_reg;
	unsigned int gdir_reg;
	unsigned int psr_reg;
	unsigned int icr1_reg;
	unsigned int icr2_reg;
	unsigned int imr_reg;
	unsigned int isr_reg;
	int edge_sel_reg;
	unsigned int low_level;
	unsigned int high_level;
	unsigned int rise_edge;
	unsigned int fall_edge;
};

struct mxc_gpio_reg_saved {
	u32 icr1;
	u32 icr2;
	u32 imr;
	u32 gdir;
	u32 edge_sel;
	u32 dr;
};

struct mxc_gpio_port {
	struct list_head node;
	void *base;
	struct clk *clk;
	int irq;
	int irq_high;
	void (*mx_irq_handler)(struct irq_desc *);
	struct irq_domain *domain;
	struct gpio_chip gc;
	struct device *dev;
	u32 both_edges;
	struct mxc_gpio_reg_saved gpio_saved_reg;
	bool power_off;
	u32 wakeup_pads;
	bool is_pad_wakeup;
	u32 pad_type[32];
	const struct mxc_gpio_hwdata *hwdata;
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

struct armada8k_pcie {
	struct dw_pcie *pci;
	struct clk *clk;
	struct clk *clk_reg;
	struct phy *phy[4];
	unsigned int phy_count;
};

enum si_type {
	SI_TYPE_INVALID = 0,
	SI_KCS = 1,
	SI_SMIC = 2,
	SI_BT = 3,
	SI_TYPE_MAX = 4,
};

struct ipmi_dmi_info {
	enum si_type si_type;
	unsigned int space;
	unsigned long addr;
	u8 slave_addr;
	struct ipmi_dmi_info *next;
};

enum dmi_device_type {
	DMI_DEV_TYPE_ANY = 0,
	DMI_DEV_TYPE_OTHER = 1,
	DMI_DEV_TYPE_UNKNOWN = 2,
	DMI_DEV_TYPE_VIDEO = 3,
	DMI_DEV_TYPE_SCSI = 4,
	DMI_DEV_TYPE_ETHERNET = 5,
	DMI_DEV_TYPE_TOKENRING = 6,
	DMI_DEV_TYPE_SOUND = 7,
	DMI_DEV_TYPE_PATA = 8,
	DMI_DEV_TYPE_SATA = 9,
	DMI_DEV_TYPE_SAS = 10,
	DMI_DEV_TYPE_IPMI = -1,
	DMI_DEV_TYPE_OEM_STRING = -2,
	DMI_DEV_TYPE_DEV_ONBOARD = -3,
	DMI_DEV_TYPE_DEV_SLOT = -4,
};

enum ipmi_addr_space {
	IPMI_IO_ADDR_SPACE = 0,
	IPMI_MEM_ADDR_SPACE = 1,
};

enum ipmi_plat_interface_type {
	IPMI_PLAT_IF_SI = 0,
	IPMI_PLAT_IF_SSIF = 1,
};

enum ipmi_addr_src {
	SI_INVALID = 0,
	SI_HOTMOD = 1,
	SI_HARDCODED = 2,
	SI_SPMI = 3,
	SI_ACPI = 4,
	SI_SMBIOS = 5,
	SI_PCI = 6,
	SI_DEVICETREE = 7,
	SI_PLATFORM = 8,
	SI_LAST = 9,
};

struct dmi_header {
	u8 type;
	u8 length;
	u16 handle;
};

struct dmi_device {
	struct list_head list;
	int type;
	const char *name;
	void *device_data;
};

struct ipmi_plat_data {
	enum ipmi_plat_interface_type iftype;
	unsigned int type;
	unsigned int space;
	unsigned long addr;
	unsigned int regspacing;
	unsigned int regsize;
	unsigned int regshift;
	unsigned int irq;
	unsigned int slave_addr;
	enum ipmi_addr_src addr_source;
};

struct irq_override_cmp {
	const struct dmi_system_id *system;
	unsigned char irq;
	unsigned char triggering;
	unsigned char polarity;
	unsigned char shareable;
	bool override;
};

struct res_proc_context {
	struct list_head *list;
	int (*preproc)(struct acpi_resource *, void *);
	void *preproc_data;
	int count;
	int error;
};

struct resource_win {
	struct resource res;
	resource_size_t offset;
};

struct acpi_pkg_info {
	u8 *free_space;
	acpi_size length;
	u32 object_space;
	u32 num_packages;
};

struct cs2000_priv {
	struct clk_hw hw;
	struct i2c_client *client;
	struct clk *clk_in;
	struct clk *ref_clk;
	struct regmap *regmap;
	bool dynamic_mode;
	bool lf_ratio;
	bool clk_skip;
	unsigned long saved_rate;
	unsigned long saved_parent_rate;
};

struct clk_fixup_mux {
	struct clk_mux mux;
	const struct clk_ops *ops;
	void (*fixup)(u32 *);
};

enum imx_pllv1_type {
	IMX_PLLV1_IMX1 = 0,
	IMX_PLLV1_IMX21 = 1,
	IMX_PLLV1_IMX25 = 2,
	IMX_PLLV1_IMX27 = 3,
	IMX_PLLV1_IMX31 = 4,
	IMX_PLLV1_IMX35 = 5,
};

struct clk_pllv1 {
	struct clk_hw hw;
	void *base;
	enum imx_pllv1_type type;
};

struct clk_cpu_8996_pmux {
	u32 reg;
	struct notifier_block nb;
	struct clk_regmap clkr;
};

enum _pmux_input {
	SMUX_INDEX = 0,
	PLL_INDEX = 1,
	ACD_INDEX = 2,
	ALT_INDEX = 3,
	NUM_OF_PMUX_INPUTS = 4,
};

struct rpc_clock {
	struct clk_divider div;
	struct clk_gate gate;
	struct cpg_simple_notifier csn;
};

struct rpcd2_clock {
	struct clk_fixed_factor fixed;
	struct clk_gate gate;
};

struct pll_out_data {
	char *div_name;
	char *pll_out_name;
	u32 offset;
	int clk_id;
	u8 div_shift;
	u8 div_flags;
	u8 rst_shift;
	spinlock_t *lock;
};

struct udma_dev;

struct udma_tisci_rm;

struct k3_udma_glue_common {
	struct device *dev;
	struct device chan_dev;
	struct udma_dev *udmax;
	const struct udma_tisci_rm *tisci_rm;
	struct k3_ringacc *ringacc;
	u32 src_thread;
	u32 dst_thread;
	u32 hdesc_size;
	bool epib;
	u32 psdata_size;
	u32 swdata_size;
	u32 atype_asel;
	struct psil_endpoint_config *ep_config;
};

struct udma_tchan;

struct k3_udma_glue_tx_channel {
	struct k3_udma_glue_common common;
	struct udma_tchan *udma_tchanx;
	int udma_tchan_id;
	struct k3_ring *ringtx;
	struct k3_ring *ringtxcq;
	bool psil_paired;
	int virq;
	atomic_t free_pkts;
	bool tx_pause_on_err;
	bool tx_filt_einfo;
	bool tx_filt_pswords;
	bool tx_supr_tdpkt;
	int udma_tflow_id;
};

struct udma_tisci_rm {
	const struct ti_sci_handle *tisci;
	const struct ti_sci_rm_udmap_ops *tisci_udmap_ops;
	u32 tisci_dev_id;
	const struct ti_sci_rm_psil_ops *tisci_psil_ops;
	u32 tisci_navss_dev_id;
	struct ti_sci_resource *rm_ranges[5];
};

struct cppi5_desc_hdr_t {
	u32 pkt_info0;
	u32 pkt_info1;
	u32 pkt_info2;
	u32 src_dst_tag;
};

struct udma_rchan;

struct k3_udma_glue_rx_flow;

struct k3_udma_glue_rx_channel {
	struct k3_udma_glue_common common;
	struct udma_rchan *udma_rchanx;
	int udma_rchan_id;
	bool remote;
	bool psil_paired;
	u32 swdata_size;
	int flow_id_base;
	struct k3_udma_glue_rx_flow *flows;
	u32 flow_num;
	u32 flows_ready;
};

struct udma_rflow;

struct k3_udma_glue_rx_flow {
	struct udma_rflow *udma_rflow;
	int udma_rflow_id;
	struct k3_ring *ringrx;
	struct k3_ring *ringrxfdq;
	int virq;
};

struct k3_udma_glue_rx_flow_cfg;

struct k3_udma_glue_rx_channel_cfg {
	u32 swdata_size;
	int flow_id_base;
	int flow_id_num;
	bool flow_id_use_rxchan_id;
	bool remote;
	struct k3_udma_glue_rx_flow_cfg *def_flow_cfg;
};

struct k3_udma_glue_rx_flow_cfg {
	struct k3_ring_cfg rx_cfg;
	struct k3_ring_cfg rxfdq_cfg;
	int ring_rxq_id;
	int ring_rxfdq0_id;
	bool rx_error_handling;
	int src_tag_lo_sel;
};

struct k3_udma_glue_tx_channel_cfg {
	struct k3_ring_cfg tx_cfg;
	struct k3_ring_cfg txcq_cfg;
	bool tx_pause_on_err;
	bool tx_filt_einfo;
	bool tx_filt_pswords;
	bool tx_supr_tdpkt;
	u32 swdata_size;
};

struct cppi5_host_desc_t {
	struct cppi5_desc_hdr_t hdr;
	u64 next_desc;
	u64 buf_ptr;
	u32 buf_info1;
	u32 org_buf_len;
	u64 org_buf_ptr;
	u32 epib[0];
};

struct rockchip_iodomain;

struct rockchip_iodomain_supply;

struct rockchip_iodomain_soc_data {
	int grf_offset;
	const char *supply_names[16];
	void (*init)(struct rockchip_iodomain *);
	int (*write)(struct rockchip_iodomain_supply *, int);
};

struct rockchip_iodomain_supply {
	struct rockchip_iodomain *iod;
	struct regulator *reg;
	struct notifier_block nb;
	int idx;
};

struct rockchip_iodomain {
	struct device *dev;
	struct regmap *grf;
	const struct rockchip_iodomain_soc_data *soc_data;
	struct rockchip_iodomain_supply supplies[16];
	int (*write)(struct rockchip_iodomain_supply *, int);
};

struct pre_voltage_change_data {
	unsigned long old_uV;
	unsigned long min_uV;
	unsigned long max_uV;
};

enum mrq_pg_cmd {
	CMD_PG_QUERY_ABI = 0,
	CMD_PG_SET_STATE = 1,
	CMD_PG_GET_STATE = 2,
	CMD_PG_GET_NAME = 3,
	CMD_PG_GET_MAX_ID = 4,
};

enum pg_states {
	PG_STATE_OFF = 0,
	PG_STATE_ON = 1,
	PG_STATE_RUNNING = 2,
};

struct tegra_powergate {
	struct generic_pm_domain genpd;
	struct tegra_bpmp *bpmp;
	unsigned int id;
};

struct cmd_pg_get_state_response {
	uint32_t state;
};

struct cmd_pg_get_name_response {
	uint8_t name[40];
};

struct cmd_pg_get_max_id_response {
	uint32_t max_id;
};

struct mrq_pg_response {
	union {
		struct cmd_pg_get_state_response get_state;
		struct cmd_pg_get_name_response get_name;
		struct cmd_pg_get_max_id_response get_max_id;
	};
};

struct cmd_pg_query_abi_request {
	uint32_t type;
};

struct cmd_pg_set_state_request {
	uint32_t state;
};

struct mrq_pg_request {
	uint32_t cmd;
	uint32_t id;
	union {
		struct cmd_pg_query_abi_request query_abi;
		struct cmd_pg_set_state_request set_state;
	};
};

struct tegra_powergate_info {
	unsigned int id;
	char *name;
};

typedef uint32_t XENSTORE_RING_IDX;

struct xenstore_domain_interface {
	char req[1024];
	char rsp[1024];
	XENSTORE_RING_IDX req_cons;
	XENSTORE_RING_IDX req_prod;
	XENSTORE_RING_IDX rsp_cons;
	XENSTORE_RING_IDX rsp_prod;
	uint32_t server_features;
	uint32_t connection;
	uint32_t error;
};

struct pfuze_regulator {
	struct regulator_desc desc;
	unsigned char stby_reg;
	unsigned char stby_mask;
	bool sw_reg;
};

enum chips {
	PFUZE100 = 0,
	PFUZE200 = 1,
	PFUZE3000 = 3,
	PFUZE3001 = 49,
};

struct pfuze_chip {
	int chip_id;
	int flags;
	struct regmap *regmap;
	struct device *dev;
	struct pfuze_regulator regulator_descs[16];
	struct regulator_dev *regulators[16];
	struct pfuze_regulator *pfuze_regulators;
};

struct ma35d1_reset_data {
	struct reset_controller_dev rcdev;
	struct notifier_block restart_handler;
	void *base;
	spinlock_t lock;
};

struct pericom8250 {
	void *virt;
	unsigned int nr;
	int line[0];
};

struct hisi_rng {
	void *base;
	struct hwrng rng;
};

struct cavium_smmu {
	struct arm_smmu_device smmu;
	u32 id_base;
};

struct dev_pin_info {
	struct pinctrl *p;
	struct pinctrl_state *default_state;
	struct pinctrl_state *init_state;
	struct pinctrl_state *sleep_state;
	struct pinctrl_state *idle_state;
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

struct rk808_reg_data {
	int addr;
	int mask;
	int value;
};

enum {
	RK805_ID = 32848,
	RK806_ID = 32864,
	RK808_ID = 0,
	RK809_ID = 32912,
	RK817_ID = 33136,
	RK818_ID = 33152,
};

struct rk808 {
	struct device *dev;
	struct regmap_irq_chip_data *irq_data;
	struct regmap *regmap;
	long variant;
	const struct regmap_config *regmap_cfg;
	const struct regmap_irq_chip *regmap_irq_chip;
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 2500,
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	enum scsi_disposition (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct megasas_mgmt_info {
	u16 count;
	struct megasas_instance *instance[1024];
	int max_index;
};

enum DCMD_TIMEOUT_ACTION {
	INITIATE_OCR = 0,
	KILL_ADAPTER = 1,
	IGNORE_TIMEOUT = 2,
};

enum MEGASAS_LD_TARGET_ID_STATUS {
	LD_TARGET_ID_INITIAL = 0,
	LD_TARGET_ID_ACTIVE = 1,
	LD_TARGET_ID_DELETED = 2,
};

enum MR_EVT_LOCALE {
	MR_EVT_LOCALE_LD = 1,
	MR_EVT_LOCALE_PD = 2,
	MR_EVT_LOCALE_ENCL = 4,
	MR_EVT_LOCALE_BBU = 8,
	MR_EVT_LOCALE_SAS = 16,
	MR_EVT_LOCALE_CTRL = 32,
	MR_EVT_LOCALE_CONFIG = 64,
	MR_EVT_LOCALE_CLUSTER = 128,
	MR_EVT_LOCALE_ALL = 65535,
};

enum MR_EVT_CLASS {
	MR_EVT_CLASS_DEBUG = -2,
	MR_EVT_CLASS_PROGRESS = -1,
	MR_EVT_CLASS_INFO = 0,
	MR_EVT_CLASS_WARNING = 1,
	MR_EVT_CLASS_CRITICAL = 2,
	MR_EVT_CLASS_FATAL = 3,
	MR_EVT_CLASS_DEAD = 4,
};

enum mfi_evt_class {
	MFI_EVT_CLASS_DEBUG = -2,
	MFI_EVT_CLASS_PROGRESS = -1,
	MFI_EVT_CLASS_INFO = 0,
	MFI_EVT_CLASS_WARNING = 1,
	MFI_EVT_CLASS_CRITICAL = 2,
	MFI_EVT_CLASS_FATAL = 3,
	MFI_EVT_CLASS_DEAD = 4,
};

enum MR_LD_QUERY_TYPE {
	MR_LD_QUERY_TYPE_ALL = 0,
	MR_LD_QUERY_TYPE_EXPOSED_TO_HOST = 1,
	MR_LD_QUERY_TYPE_USED_TGT_IDS = 2,
	MR_LD_QUERY_TYPE_CLUSTER_ACCESS = 3,
	MR_LD_QUERY_TYPE_CLUSTER_LOCALE = 4,
};

enum MR_PD_STATE {
	MR_PD_STATE_UNCONFIGURED_GOOD = 0,
	MR_PD_STATE_UNCONFIGURED_BAD = 1,
	MR_PD_STATE_HOT_SPARE = 2,
	MR_PD_STATE_OFFLINE = 16,
	MR_PD_STATE_FAILED = 17,
	MR_PD_STATE_REBUILD = 20,
	MR_PD_STATE_ONLINE = 24,
	MR_PD_STATE_COPYBACK = 32,
	MR_PD_STATE_SYSTEM = 64,
};

enum MR_PD_QUERY_TYPE {
	MR_PD_QUERY_TYPE_ALL = 0,
	MR_PD_QUERY_TYPE_STATE = 1,
	MR_PD_QUERY_TYPE_POWER_STATE = 2,
	MR_PD_QUERY_TYPE_MEDIA_TYPE = 3,
	MR_PD_QUERY_TYPE_SPEED = 4,
	MR_PD_QUERY_TYPE_EXPOSED_TO_HOST = 5,
};

struct megasas_init_queue_info {
	__le32 init_flags;
	__le32 reply_queue_entries;
	__le32 reply_queue_start_phys_addr_lo;
	__le32 reply_queue_start_phys_addr_hi;
	__le32 producer_index_phys_addr_lo;
	__le32 producer_index_phys_addr_hi;
	__le32 consumer_index_phys_addr_lo;
	__le32 consumer_index_phys_addr_hi;
};

struct IOV_111 {
	u8 maxVFsSupported;
	u8 numVFsEnabled;
	u8 requestorId;
	u8 reserved[5];
};

struct megasas_iocpacket {
	u16 host_no;
	u16 __pad1;
	u32 sgl_off;
	u32 sge_count;
	u32 sense_off;
	u32 sense_len;
	union {
		u8 raw[128];
		struct megasas_header hdr;
	} frame;
	struct iovec sgl[16];
} __attribute__((packed));

struct megasas_evt_log_info {
	__le32 newest_seq_num;
	__le32 oldest_seq_num;
	__le32 clear_seq_num;
	__le32 shutdown_seq_num;
	__le32 boot_seq_num;
};

struct compat_megasas_iocpacket {
	u16 host_no;
	u16 __pad1;
	u32 sgl_off;
	u32 sge_count;
	u32 sense_off;
	u32 sense_len;
	union {
		u8 raw[128];
		struct megasas_header hdr;
	} frame;
	struct compat_iovec sgl[16];
};

struct megasas_aen {
	u16 host_no;
	u16 __pad1;
	u32 seq_num;
	u32 class_locale_word;
};

struct cfi_pri_intelext {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint32_t FeatureSupport;
	uint8_t SuspendCmdSupport;
	uint16_t BlkStatusRegMask;
	uint8_t VccOptimal;
	uint8_t VppOptimal;
	uint8_t NumProtectionFields;
	uint16_t ProtRegAddr;
	uint8_t FactProtRegSize;
	uint8_t UserProtRegSize;
	uint8_t extra[0];
} __attribute__((packed));

struct cfi_extquery {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
};

typedef void (*btf_trace_spmi_write_begin)(void *, u8, u8, u16, u8, const u8 *);

typedef void (*btf_trace_spmi_write_end)(void *, u8, u8, u16, int);

typedef void (*btf_trace_spmi_read_begin)(void *, u8, u8, u16);

typedef void (*btf_trace_spmi_read_end)(void *, u8, u8, u16, int, u8, const u8 *);

typedef void (*btf_trace_spmi_cmd)(void *, u8, u8, int);

struct trace_event_raw_spmi_write_begin {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	u8 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_spmi_write_end {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	int ret;
	char __data[0];
};

struct trace_event_raw_spmi_read_begin {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	char __data[0];
};

struct trace_event_raw_spmi_read_end {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	int ret;
	u8 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_spmi_cmd {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	int ret;
	char __data[0];
};

struct spmi_device;

struct spmi_driver {
	struct device_driver driver;
	int (*probe)(struct spmi_device *);
	void (*remove)(struct spmi_device *);
	void (*shutdown)(struct spmi_device *);
};

struct spmi_device {
	struct device dev;
	struct spmi_controller *ctrl;
	u8 usid;
};

struct trace_event_data_offsets_spmi_write_begin {
	u32 buf;
};

struct trace_event_data_offsets_spmi_read_end {
	u32 buf;
};

struct trace_event_data_offsets_spmi_write_end {};

struct trace_event_data_offsets_spmi_read_begin {};

struct trace_event_data_offsets_spmi_cmd {};

struct mux_control;

struct mdio_mux_multiplexer_state {
	struct mux_control *muxc;
	bool do_deselect;
	void *mux_handle;
};

struct bcm4908_enet_dma_ring_bd;

struct bcm4908_enet_dma_ring_slot;

struct bcm4908_enet_dma_ring {
	int is_tx;
	int read_idx;
	int write_idx;
	int length;
	u16 cfg_block;
	u16 st_ram_block;
	struct napi_struct napi;
	union {
		void *cpu_addr;
		struct bcm4908_enet_dma_ring_bd *buf_desc;
	};
	dma_addr_t dma_addr;
	struct bcm4908_enet_dma_ring_slot *slots;
};

struct bcm4908_enet_dma_ring_bd {
	__le32 ctl;
	__le32 addr;
};

struct bcm4908_enet_dma_ring_slot {
	union {
		void *buf;
		struct sk_buff *skb;
	};
	unsigned int len;
	dma_addr_t dma_addr;
};

struct bcm4908_enet {
	struct device *dev;
	struct net_device *netdev;
	void *base;
	int irq_tx;
	struct bcm4908_enet_dma_ring tx_ring;
	struct bcm4908_enet_dma_ring rx_ring;
};

typedef void (*btf_trace_dpaa2_tx_fd)(void *, struct net_device *, const struct dpaa2_fd *);

typedef void (*btf_trace_dpaa2_tx_xsk_fd)(void *, struct net_device *, const struct dpaa2_fd *);

typedef void (*btf_trace_dpaa2_rx_fd)(void *, struct net_device *, const struct dpaa2_fd *);

typedef void (*btf_trace_dpaa2_rx_xsk_fd)(void *, struct net_device *, const struct dpaa2_fd *);

typedef void (*btf_trace_dpaa2_tx_conf_fd)(void *, struct net_device *, const struct dpaa2_fd *);

typedef void (*btf_trace_dpaa2_eth_buf_seed)(void *, struct net_device *, void *, size_t, dma_addr_t, size_t, u16);

typedef void (*btf_trace_dpaa2_xsk_buf_seed)(void *, struct net_device *, void *, size_t, dma_addr_t, size_t, u16);

struct dpaa2_eth_dist_fields {
	u64 rxnfc_field;
	enum net_prot cls_prot;
	int cls_field;
	int size;
	u64 id;
};

enum dpaa2_fd_format {
	dpaa2_fd_single = 0,
	dpaa2_fd_list = 1,
	dpaa2_fd_sg = 2,
};

enum dpaa2_eth_swa_type {
	DPAA2_ETH_SWA_SINGLE = 0,
	DPAA2_ETH_SWA_SG = 1,
	DPAA2_ETH_SWA_XDP = 2,
	DPAA2_ETH_SWA_XSK = 3,
	DPAA2_ETH_SWA_SW_TSO = 4,
};

enum dpni_congestion_unit {
	DPNI_CONGESTION_UNIT_BYTES = 0,
	DPNI_CONGESTION_UNIT_FRAMES = 1,
};

enum dpni_congestion_point {
	DPNI_CP_QUEUE = 0,
	DPNI_CP_GROUP = 1,
};

enum dpni_queue_type {
	DPNI_QUEUE_RX = 0,
	DPNI_QUEUE_TX = 1,
	DPNI_QUEUE_TX_CONFIRM = 2,
	DPNI_QUEUE_RX_ERR = 3,
};

enum dpaa2_eth_rx_dist {
	DPAA2_ETH_RX_DIST_HASH = 0,
	DPAA2_ETH_RX_DIST_CLS = 1,
};

enum dpkg_extract_type {
	DPKG_EXTRACT_FROM_HDR = 0,
	DPKG_EXTRACT_FROM_DATA = 1,
	DPKG_EXTRACT_FROM_PARSE = 3,
};

enum dpkg_extract_from_hdr_type {
	DPKG_FROM_HDR = 0,
	DPKG_FROM_FIELD = 1,
	DPKG_FULL_FIELD = 2,
};

enum dpni_dist_mode {
	DPNI_DIST_MODE_NONE = 0,
	DPNI_DIST_MODE_HASH = 1,
	DPNI_DIST_MODE_FS = 2,
};

enum dpni_fs_miss_action {
	DPNI_FS_MISS_DROP = 0,
	DPNI_FS_MISS_EXPLICIT_FLOWID = 1,
	DPNI_FS_MISS_HASH = 2,
};

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
	NAPIF_STATE_PREFER_BUSY_POLL = 128,
	NAPIF_STATE_THREADED = 256,
	NAPIF_STATE_SCHED_THREADED = 512,
};

enum dpni_error_action {
	DPNI_ERROR_ACTION_DISCARD = 0,
	DPNI_ERROR_ACTION_CONTINUE = 1,
	DPNI_ERROR_ACTION_SEND_TO_ERROR_QUEUE = 2,
};

enum dpni_dest {
	DPNI_DEST_NONE = 0,
	DPNI_DEST_DPIO = 1,
	DPNI_DEST_DPCON = 2,
};

enum tc_tbf_command {
	TC_TBF_REPLACE = 0,
	TC_TBF_DESTROY = 1,
	TC_TBF_STATS = 2,
	TC_TBF_GRAFT = 3,
};

enum dpni_offload {
	DPNI_OFF_RX_L3_CSUM = 0,
	DPNI_OFF_RX_L4_CSUM = 1,
	DPNI_OFF_TX_L3_CSUM = 2,
	DPNI_OFF_TX_L4_CSUM = 3,
};

struct dpaa2_eth_swa {
	enum dpaa2_eth_swa_type type;
	union {
		struct {
			struct sk_buff *skb;
			int sgt_size;
		} single;
		struct {
			struct sk_buff *skb;
			struct scatterlist *scl;
			int num_sg;
			int sgt_size;
		} sg;
		struct {
			int dma_size;
			struct xdp_frame *xdpf;
		} xdp;
		struct {
			struct xdp_buff *xdp_buff;
			int sgt_size;
		} xsk;
		struct {
			struct sk_buff *skb;
			int num_sg;
			int sgt_size;
			int is_last_fd;
		} tso;
	};
};

struct dpaa2_sg_entry {
	__le64 addr;
	__le32 len;
	__le16 bpid;
	__le16 format_offset;
};

struct trace_event_raw_dpaa2_eth_fd {
	struct trace_entry ent;
	u64 fd_addr;
	u32 fd_len;
	u16 fd_offset;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_dpaa2_eth_buf {
	struct trace_entry ent;
	void *vaddr;
	size_t size;
	dma_addr_t dma_addr;
	size_t map_size;
	u16 bpid;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_dpaa2_eth_fd {
	u32 name;
};

struct trace_event_data_offsets_dpaa2_eth_buf {
	u32 name;
};

struct dpaa2_faead {
	__le32 conf_fqid;
	__le32 ctrl;
};

struct dpni_taildrop {
	char enable;
	enum dpni_congestion_unit units;
	u32 threshold;
};

struct dpbp_attr {
	int id;
	u16 bpid;
};

struct dpni_rx_dist_cfg {
	u16 dist_size;
	u64 key_cfg_iova;
	u8 enable;
	u8 tc;
	u16 fs_miss_flow_id;
};

struct dpni_fs_tbl_cfg {
	enum dpni_fs_miss_action miss_action;
	u16 default_flow_id;
};

struct dpni_rx_tc_dist_cfg {
	u16 dist_size;
	enum dpni_dist_mode dist_mode;
	u64 key_cfg_iova;
	struct dpni_fs_tbl_cfg fs_cfg;
};

struct dpkg_mask {
	u8 mask;
	u8 offset;
};

struct dpkg_extract {
	enum dpkg_extract_type type;
	union {
		struct {
			enum net_prot prot;
			enum dpkg_extract_from_hdr_type type;
			u32 field;
			u8 size;
			u8 offset;
			u8 hdr_index;
		} from_hdr;
		struct {
			u8 size;
			u8 offset;
		} from_data;
		struct {
			u8 size;
			u8 offset;
		} from_parse;
	} extract;
	u8 num_of_byte_masks;
	struct dpkg_mask masks[4];
};

struct dpkg_profile_cfg {
	u8 num_extracts;
	struct dpkg_extract extracts[10];
};

struct dpni_buffer_layout {
	u32 options;
	int pass_timestamp;
	int pass_parser_result;
	int pass_frame_status;
	u16 private_data_size;
	u16 data_align;
	u16 data_head_room;
	u16 data_tail_room;
};

struct dpni_qos_tbl_cfg {
	u64 key_cfg_iova;
	int discard_on_miss;
	u8 default_tc;
};

struct dpni_queue {
	struct {
		u16 id;
		enum dpni_dest type;
		char hold_active;
		u8 priority;
	} destination;
	u64 user_context;
	struct {
		u64 value;
		char stash_control;
	} flc;
};

struct dpni_queue_id {
	u32 fqid;
	u16 qdbin;
};

struct dpni_pools_cfg {
	u8 num_dpbp;
	u8 pool_options;
	struct {
		int dpbp_id;
		u8 priority_mask;
		u16 buffer_size;
		int backup_pool;
	} pools[8];
};

struct dpni_error_cfg {
	u32 errors;
	enum dpni_error_action error_action;
	int set_frame_annotation;
};

struct ptp_tstamp {
	u16 sec_msb;
	u32 sec_lsb;
	u32 nsec;
};

struct dpaa2_fas {
	u8 reserved;
	u8 ppid;
	__le16 ifpid;
	__le32 status;
};

struct dpaa2_fapr {
	__le32 faf_lo;
	__le16 faf_ext;
	__le16 nxt_hdr;
	__le64 faf_hi;
	u8 last_ethertype_offset;
	u8 vlan_tci_offset_n;
	u8 vlan_tci_offset_1;
	u8 llc_snap_offset;
	u8 eth_offset;
	u8 ip1_pid_offset;
	u8 shim_offset_2;
	u8 shim_offset_1;
	u8 l5_offset;
	u8 l4_offset;
	u8 gre_offset;
	u8 l3_offset_n;
	u8 l3_offset_1;
	u8 mpls_offset_n;
	u8 mpls_offset_1;
	u8 pppoe_offset;
	__le16 running_sum;
	__le16 gross_running_sum;
	u8 ipv6_frag_offset;
	u8 nxt_hdr_offset;
	u8 routing_hdr_offset_2;
	u8 routing_hdr_offset_1;
	u8 reserved[5];
	u8 ip_proto_offset_n;
	u8 nxt_hdr_frag_offset;
	u8 parse_error_code;
};

struct common {
	u8 verb;
	u8 reserved[63];
};

struct dq {
	u8 verb;
	u8 stat;
	__le16 seqnum;
	__le16 oprid;
	u8 reserved;
	u8 tok;
	__le32 fqid;
	u32 reserved2;
	__le32 fq_byte_cnt;
	__le32 fq_frm_cnt;
	__le64 fqd_ctx;
	u8 fd[32];
};

struct scn {
	u8 verb;
	u8 stat;
	u8 state;
	u8 reserved;
	__le32 rid_tok;
	__le64 ctx;
};

struct dpaa2_dq {
	union {
		struct common common;
		struct dq dq;
		struct scn scn;
	};
};

struct dpni_single_step_cfg {
	u8 en;
	u8 ch_update;
	u16 offset;
	u32 peer_delay;
	u32 ptp_onestep_reg_base;
};

struct tc_tbf_qopt_offload_replace_params {
	struct psched_ratecfg rate;
	u32 max_size;
	struct gnet_stats_queue *qstats;
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_sync *bstats;
	struct gnet_stats_queue *qstats;
};

struct tc_tbf_qopt_offload {
	enum tc_tbf_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_tbf_qopt_offload_replace_params replace_params;
		struct tc_qopt_offload_stats stats;
		u32 child_handle;
	};
};

struct dpni_tx_shaping_cfg {
	u32 rate_limit;
	u16 max_burst_size;
};

enum {
	e1000_igp_cable_length_10 = 10,
	e1000_igp_cable_length_20 = 20,
	e1000_igp_cable_length_30 = 30,
	e1000_igp_cable_length_40 = 40,
	e1000_igp_cable_length_50 = 50,
	e1000_igp_cable_length_60 = 60,
	e1000_igp_cable_length_70 = 70,
	e1000_igp_cable_length_80 = 80,
	e1000_igp_cable_length_90 = 90,
	e1000_igp_cable_length_100 = 100,
	e1000_igp_cable_length_110 = 110,
	e1000_igp_cable_length_115 = 115,
	e1000_igp_cable_length_120 = 120,
	e1000_igp_cable_length_130 = 130,
	e1000_igp_cable_length_140 = 140,
	e1000_igp_cable_length_150 = 150,
	e1000_igp_cable_length_160 = 160,
	e1000_igp_cable_length_170 = 170,
	e1000_igp_cable_length_180 = 180,
};

enum e1000_mng_mode {
	e1000_mng_mode_none = 0,
	e1000_mng_mode_asf = 1,
	e1000_mng_mode_pt = 2,
	e1000_mng_mode_ipmi = 3,
	e1000_mng_mode_host_if_only = 4,
};

struct e1000_host_mng_command_header {
	u8 command_id;
	u8 checksum;
	u16 reserved1;
	u16 reserved2;
	u16 command_length;
};

struct am65_cpsw_soc_pdata {
	u32 quirks_dis;
};

enum devlink_param_type {
	DEVLINK_PARAM_TYPE_U8 = 0,
	DEVLINK_PARAM_TYPE_U16 = 1,
	DEVLINK_PARAM_TYPE_U32 = 2,
	DEVLINK_PARAM_TYPE_STRING = 3,
	DEVLINK_PARAM_TYPE_BOOL = 4,
};

struct devlink_param {
	u32 id;
	const char *name;
	bool generic;
	enum devlink_param_type type;
	unsigned long supported_cmodes;
	int (*get)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*set)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*validate)(struct devlink *, u32, union devlink_param_value, struct netlink_ext_ack *);
};

struct am65_cpsw_pdata {
	u32 quirks;
	u64 extra_modes;
	enum k3_ring_mode fdqring_mode;
	const char *ale_dev_id;
};

enum tc_taprio_qopt_cmd {
	TAPRIO_CMD_REPLACE = 0,
	TAPRIO_CMD_DESTROY = 1,
	TAPRIO_CMD_STATS = 2,
	TAPRIO_CMD_QUEUE_STATS = 3,
};

enum {
	CPSW_SL_CTL_FULLDUPLEX = 1,
	CPSW_SL_CTL_LOOPBACK = 2,
	CPSW_SL_CTL_MTEST = 4,
	CPSW_SL_CTL_RX_FLOW_EN = 8,
	CPSW_SL_CTL_TX_FLOW_EN = 16,
	CPSW_SL_CTL_GMII_EN = 32,
	CPSW_SL_CTL_TX_PACE = 64,
	CPSW_SL_CTL_GIG = 128,
	CPSW_SL_CTL_XGIG = 256,
	CPSW_SL_CTL_TX_SHORT_GAP_EN = 1024,
	CPSW_SL_CTL_CMD_IDLE = 2048,
	CPSW_SL_CTL_CRC_TYPE = 4096,
	CPSW_SL_CTL_XGMII_EN = 8192,
	CPSW_SL_CTL_IFCTL_A = 32768,
	CPSW_SL_CTL_IFCTL_B = 65536,
	CPSW_SL_CTL_GIG_FORCE = 131072,
	CPSW_SL_CTL_EXT_EN = 262144,
	CPSW_SL_CTL_EXT_EN_RX_FLO = 524288,
	CPSW_SL_CTL_EXT_EN_TX_FLO = 1048576,
	CPSW_SL_CTL_TX_SG_LIM_EN = 2097152,
	CPSW_SL_CTL_RX_CEF_EN = 4194304,
	CPSW_SL_CTL_RX_CSF_EN = 8388608,
	CPSW_SL_CTL_RX_CMF_EN = 16777216,
	CPSW_SL_CTL_EXT_EN_XGIG = 33554432,
	CPSW_SL_CTL_FUNCS_COUNT = 33554433,
};

enum cpsw_ale_port_state {
	ALE_PORT_STATE_DISABLE = 0,
	ALE_PORT_STATE_BLOCK = 1,
	ALE_PORT_STATE_LEARN = 2,
	ALE_PORT_STATE_FORWARD = 3,
};

enum {
	K3_UDMA_GLUE_SRC_TAG_LO_KEEP = 0,
	K3_UDMA_GLUE_SRC_TAG_LO_USE_FLOW_REG = 1,
	K3_UDMA_GLUE_SRC_TAG_LO_USE_REMOTE_FLOW_ID = 2,
	K3_UDMA_GLUE_SRC_TAG_LO_USE_REMOTE_SRC_TAG = 4,
};

enum cpsw_devlink_param_id {
	AM65_CPSW_DEVLINK_PARAM_ID_BASE = 16,
	AM65_CPSW_DL_PARAM_SWITCH_MODE = 17,
};

struct am65_cpsw_port;

struct am65_cpsw_ndev_stats;

struct am65_cpsw_ndev_priv {
	u32 msg_enable;
	struct am65_cpsw_port *port;
	struct am65_cpsw_ndev_stats __attribute__((btf_type_tag("percpu"))) *stats;
	bool offload_fwd_mark;
};

struct am65_cpsw_slave_data {
	bool mac_only;
	struct cpsw_sl *mac_sl;
	struct device_node *phy_node;
	phy_interface_t phy_if;
	struct phy *ifphy;
	struct phy *serdes_phy;
	bool rx_pause;
	bool tx_pause;
	u8 mac_addr[6];
	int port_vlan;
	struct phylink *phylink;
	struct phylink_config phylink_config;
};

struct am65_cpsw_ale_ratelimit {
	unsigned long cookie;
	u64 rate_packet_ps;
};

struct am65_cpsw_est;

struct am65_cpsw_qos {
	struct am65_cpsw_est *est_admin;
	struct am65_cpsw_est *est_oper;
	ktime_t link_down_time;
	int link_speed;
	struct am65_cpsw_ale_ratelimit ale_bc_ratelimit;
	struct am65_cpsw_ale_ratelimit ale_mc_ratelimit;
};

struct am65_cpsw_common;

struct am65_cpsw_port {
	struct am65_cpsw_common *common;
	struct net_device *ndev;
	const char *name;
	u32 port_id;
	void *port_base;
	void *sgmii_base;
	void *stat_base;
	void *fetch_ram_base;
	bool disabled;
	struct am65_cpsw_slave_data slave;
	bool tx_ts_enabled;
	bool rx_ts_enabled;
	struct am65_cpsw_qos qos;
	struct devlink_port devlink_port;
	u32 vid_context;
};

struct am65_cpsw_host {
	struct am65_cpsw_common *common;
	void *port_base;
	void *stat_base;
	u32 vid_context;
};

struct k3_cppi_desc_pool;

struct am65_cpsw_tx_chn {
	struct device *dma_dev;
	struct napi_struct napi_tx;
	struct am65_cpsw_common *common;
	struct k3_cppi_desc_pool *desc_pool;
	struct k3_udma_glue_tx_channel *tx_chn;
	spinlock_t lock;
	int irq;
	u32 id;
	u32 descs_num;
	char tx_chn_name[128];
	u32 rate_mbps;
};

struct am65_cpsw_rx_chn {
	struct device *dev;
	struct device *dma_dev;
	struct k3_cppi_desc_pool *desc_pool;
	struct k3_udma_glue_rx_channel *rx_chn;
	u32 descs_num;
	int irq;
};

struct am65_cpts;

struct am65_cpsw_common {
	struct device *dev;
	struct device *mdio_dev;
	struct am65_cpsw_pdata pdata;
	void *ss_base;
	void *cpsw_base;
	u32 port_num;
	struct am65_cpsw_host host;
	struct am65_cpsw_port *ports;
	u32 disabled_ports_mask;
	struct net_device *dma_ndev;
	int usage_count;
	struct cpsw_ale *ale;
	int tx_ch_num;
	u32 tx_ch_rate_msk;
	u32 rx_flow_id_base;
	struct am65_cpsw_tx_chn tx_chns[8];
	struct completion tdown_complete;
	atomic_t tdown_cnt;
	struct am65_cpsw_rx_chn rx_chns;
	struct napi_struct napi_rx;
	bool rx_irq_disabled;
	u32 nuss_ver;
	u32 cpsw_ver;
	unsigned long bus_freq;
	bool pf_p0_rx_ptype_rrobin;
	struct am65_cpts *cpts;
	int est_enabled;
	bool is_emac_mode;
	u16 br_members;
	int default_vlan;
	struct devlink *devlink;
	struct net_device *hw_bridge_dev;
	struct notifier_block am65_cpsw_netdevice_nb;
	unsigned char switch_id[32];
	u32 *ale_context;
};

struct tc_taprio_qopt_stats {
	u64 window_drops;
	u64 tx_overruns;
};

struct tc_taprio_qopt_queue_stats {
	int queue;
	struct tc_taprio_qopt_stats stats;
};

struct tc_taprio_sched_entry {
	u8 command;
	u32 gate_mask;
	u32 interval;
};

struct tc_taprio_qopt_offload {
	enum tc_taprio_qopt_cmd cmd;
	union {
		struct tc_taprio_qopt_stats stats;
		struct tc_taprio_qopt_queue_stats queue_stats;
		struct {
			struct tc_mqprio_qopt_offload mqprio;
			struct netlink_ext_ack *extack;
			ktime_t base_time;
			u64 cycle_time;
			u64 cycle_time_extension;
			u32 max_sdu[16];
			size_t num_entries;
			struct tc_taprio_sched_entry entries[0];
		};
	};
};

struct am65_cpsw_est {
	int buf;
	struct tc_taprio_qopt_offload taprio;
};

struct am65_cpsw_ndev_stats {
	u64 tx_packets;
	u64 tx_bytes;
	u64 rx_packets;
	u64 rx_bytes;
	struct u64_stats_sync syncp;
};

struct am65_cpsw_devlink {
	struct am65_cpsw_common *common;
};

struct usb_phy_roothub {
	struct phy *phy;
	struct list_head list;
};

struct dwc3_am62 {
	struct device *dev;
	void *usbss;
	struct clk *usb2_refclk;
	int rate_code;
	struct regmap *syscon;
	unsigned int offset;
	unsigned int vbus_divider;
	u32 wakeup_stat;
};

struct ehci_tt {
	u16 bandwidth[8];
	struct list_head tt_list;
	struct list_head ps_list;
	struct usb_tt *usb_tt;
	int tt_port;
};

struct ehci_iso_packet {
	u64 bufp;
	__le32 transaction;
	u8 cross;
	u32 buf1;
};

struct ehci_iso_sched {
	struct list_head td_list;
	unsigned int span;
	unsigned int first_packet;
	struct ehci_iso_packet packet[0];
};

struct ehci_ci_priv {
	struct regulator *reg_vbus;
	bool enabled;
};

struct ci_hdrc_dma_aligned_buffer {
	void *original_buffer;
	u8 data[0];
};

struct usb_role_switch {
	struct device dev;
	struct mutex lock;
	enum usb_role role;
	struct device *usb2_port;
	struct device *usb3_port;
	struct device *udc;
	usb_role_switch_set_t set;
	usb_role_switch_get_t get;
	bool allow_userspace_control;
};

typedef void * (*devcon_match_fn_t)(const struct fwnode_handle *, const char *, void *);

struct cytp_data {
	int fw_version;
	int pkt_size;
	int mode;
	int tp_min_pressure;
	int tp_max_pressure;
	int tp_width;
	int tp_high;
	int tp_max_abs_x;
	int tp_max_abs_y;
	int tp_res_x;
	int tp_res_y;
	int tp_metrics_supported;
};

struct cytp_contact {
	int x;
	int y;
	int z;
};

struct cytp_report_data {
	int contact_cnt;
	struct cytp_contact contacts[2];
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int tap: 1;
};

struct dw_i2c_dev {
	struct device *dev;
	struct regmap *map;
	struct regmap *sysmap;
	void *base;
	void *ext;
	struct completion cmd_complete;
	struct clk *clk;
	struct clk *pclk;
	struct reset_control *rst;
	struct i2c_client *slave;
	u32 (*get_clk_rate_khz)(struct dw_i2c_dev *);
	int cmd_err;
	struct i2c_msg *msgs;
	int msgs_num;
	int msg_write_idx;
	u32 tx_buf_len;
	u8 *tx_buf;
	int msg_read_idx;
	u32 rx_buf_len;
	u8 *rx_buf;
	int msg_err;
	unsigned int status;
	unsigned int abort_source;
	int irq;
	u32 flags;
	struct i2c_adapter adapter;
	u32 functionality;
	u32 master_cfg;
	u32 slave_cfg;
	unsigned int tx_fifo_depth;
	unsigned int rx_fifo_depth;
	int rx_outstanding;
	struct i2c_timings timings;
	u32 sda_hold_time;
	u16 ss_hcnt;
	u16 ss_lcnt;
	u16 fs_hcnt;
	u16 fs_lcnt;
	u16 fp_hcnt;
	u16 fp_lcnt;
	u16 hs_hcnt;
	u16 hs_lcnt;
	int (*acquire_lock)();
	void (*release_lock)();
	int semaphore_idx;
	bool shared_with_punit;
	void (*disable)(struct dw_i2c_dev *);
	int (*init)(struct dw_i2c_dev *);
	int (*set_sda_hold_time)(struct dw_i2c_dev *);
	int mode;
	struct i2c_bus_recovery_info rinfo;
};

enum rcar_i2c_type {
	I2C_RCAR_GEN1 = 0,
	I2C_RCAR_GEN2 = 1,
	I2C_RCAR_GEN3 = 2,
};

struct rcar_i2c_priv {
	u32 flags;
	void *io;
	struct i2c_adapter adap;
	struct i2c_msg *msg;
	int msgs_left;
	struct clk *clk;
	wait_queue_head_t wait;
	int pos;
	u32 icccr;
	u16 schd;
	u16 scld;
	u8 recovery_icmcr;
	enum rcar_i2c_type devtype;
	struct i2c_client *slave;
	struct resource *res;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	struct scatterlist sg;
	enum dma_data_direction dma_direction;
	struct reset_control *rstc;
	int irq;
	struct i2c_client *host_notify_client;
};

struct scmi_sensor_info;

struct scmi_sensor_reading;

struct scmi_sensor_proto_ops {
	int (*count_get)(const struct scmi_protocol_handle *);
	const struct scmi_sensor_info * (*info_get)(const struct scmi_protocol_handle *, u32);
	int (*trip_point_config)(const struct scmi_protocol_handle *, u32, u8, u64);
	int (*reading_get)(const struct scmi_protocol_handle *, u32, u64 *);
	int (*reading_get_timestamped)(const struct scmi_protocol_handle *, u32, u8, struct scmi_sensor_reading *);
	int (*config_get)(const struct scmi_protocol_handle *, u32, u32 *);
	int (*config_set)(const struct scmi_protocol_handle *, u32, u32);
};

struct scmi_sensor_intervals_info {
	bool segmented;
	unsigned int count;
	unsigned int *desc;
	unsigned int prealloc_pool[16];
};

struct scmi_range_attrs {
	long long min_range;
	long long max_range;
};

struct scmi_sensor_axis_info;

struct scmi_sensor_info {
	unsigned int id;
	unsigned int type;
	int scale;
	unsigned int num_trip_points;
	bool async;
	bool update;
	bool timestamped;
	int tstamp_scale;
	unsigned int num_axis;
	struct scmi_sensor_axis_info *axis;
	struct scmi_sensor_intervals_info intervals;
	unsigned int sensor_config;
	char name[64];
	bool extended_scalar_attrs;
	unsigned int sensor_power;
	unsigned int resolution;
	int exponent;
	struct scmi_range_attrs scalar_attrs;
};

struct scmi_sensor_axis_info {
	unsigned int id;
	unsigned int type;
	int scale;
	char name[64];
	bool extended_attrs;
	unsigned int resolution;
	int exponent;
	struct scmi_range_attrs attrs;
};

struct scmi_sensor_reading {
	long long value;
	unsigned long long timestamp;
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

struct hwmon_ops;

struct hwmon_channel_info;

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info * const *info;
};

struct hwmon_ops {
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long);
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

enum scmi_sensor_class {
	NONE = 0,
	UNSPEC = 1,
	TEMPERATURE_C = 2,
	TEMPERATURE_F = 3,
	TEMPERATURE_K = 4,
	VOLTAGE = 5,
	CURRENT = 6,
	POWER = 7,
	ENERGY = 8,
	CHARGE = 9,
	VOLTAMPERE = 10,
	NITS = 11,
	LUMENS = 12,
	LUX = 13,
	CANDELAS = 14,
	KPA = 15,
	PSI = 16,
	NEWTON = 17,
	CFM = 18,
	RPM = 19,
	HERTZ = 20,
	SECS = 21,
	MINS = 22,
	HOURS = 23,
	DAYS = 24,
	WEEKS = 25,
	MILS = 26,
	INCHES = 27,
	FEET = 28,
	CUBIC_INCHES = 29,
	CUBIC_FEET = 30,
	METERS = 31,
	CUBIC_CM = 32,
	CUBIC_METERS = 33,
	LITERS = 34,
	FLUID_OUNCES = 35,
	RADIANS = 36,
	STERADIANS = 37,
	REVOLUTIONS = 38,
	CYCLES = 39,
	GRAVITIES = 40,
	OUNCES = 41,
	POUNDS = 42,
	FOOT_POUNDS = 43,
	OUNCE_INCHES = 44,
	GAUSS = 45,
	GILBERTS = 46,
	HENRIES = 47,
	FARADS = 48,
	OHMS = 49,
	SIEMENS = 50,
	MOLES = 51,
	BECQUERELS = 52,
	PPM = 53,
	DECIBELS = 54,
	DBA = 55,
	DBC = 56,
	GRAYS = 57,
	SIEVERTS = 58,
	COLOR_TEMP_K = 59,
	BITS = 60,
	BYTES = 61,
	WORDS = 62,
	DWORDS = 63,
	QWORDS = 64,
	PERCENTAGE = 65,
	PASCALS = 66,
	COUNTS = 67,
	GRAMS = 68,
	NEWTON_METERS = 69,
	HITS = 70,
	MISSES = 71,
	RETRIES = 72,
	OVERRUNS = 73,
	UNDERRUNS = 74,
	COLLISIONS = 75,
	PACKETS = 76,
	MESSAGES = 77,
	CHARS = 78,
	ERRORS = 79,
	CORRECTED_ERRS = 80,
	UNCORRECTABLE_ERRS = 81,
	SQ_MILS = 82,
	SQ_INCHES = 83,
	SQ_FEET = 84,
	SQ_CM = 85,
	SQ_METERS = 86,
	RADIANS_SEC = 87,
	BPM = 88,
	METERS_SEC_SQUARED = 89,
	METERS_SEC = 90,
	CUBIC_METERS_SEC = 91,
	MM_MERCURY = 92,
	RADIANS_SEC_SQUARED = 93,
	OEM_UNIT = 255,
};

struct scmi_thermal_sensor {
	const struct scmi_protocol_handle *ph;
	const struct scmi_sensor_info *info;
};

struct scmi_sensors {
	const struct scmi_protocol_handle *ph;
	const struct scmi_sensor_info **info[10];
};

struct meson_mmc_data {
	unsigned int tx_delay_mask;
	unsigned int rx_delay_mask;
	unsigned int always_on;
	unsigned int adjust;
	unsigned int irq_sdio_sleep;
};

struct sd_emmc_desc;

struct meson_host {
	struct device *dev;
	const struct meson_mmc_data *data;
	struct mmc_host *mmc;
	struct mmc_command *cmd;
	void *regs;
	struct clk *mux_clk;
	struct clk *mmc_clk;
	unsigned long req_rate;
	bool ddr;
	bool dram_access_quirk;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_clk_gate;
	unsigned int bounce_buf_size;
	void *bounce_buf;
	void *bounce_iomem_buf;
	dma_addr_t bounce_dma_addr;
	struct sd_emmc_desc *descs;
	dma_addr_t descs_dma_addr;
	int irq;
	bool needs_pre_post_req;
	spinlock_t lock;
};

struct sd_emmc_desc {
	u32 cmd_cfg;
	u32 cmd_arg;
	u32 cmd_data;
	u32 cmd_resp;
};

enum ufshcd_mcq_opr {
	OPR_SQD = 0,
	OPR_SQIS = 1,
	OPR_CQD = 2,
	OPR_CQIS = 3,
	OPR_MAX = 4,
};

enum {
	REG_CQIS = 0,
	REG_CQIE = 4,
};

enum {
	REG_SQATTR = 0,
	REG_SQLBA = 4,
	REG_SQUBA = 8,
	REG_SQDAO = 12,
	REG_SQISAO = 16,
	REG_CQATTR = 32,
	REG_CQLBA = 36,
	REG_CQUBA = 40,
	REG_CQDAO = 44,
	REG_CQISAO = 48,
};

enum {
	REG_SQHP = 0,
	REG_SQTP = 4,
	REG_SQRTC = 8,
	REG_SQCTI = 12,
	REG_SQRTS = 16,
};

enum {
	REG_CQHP = 0,
	REG_CQTP = 4,
};

enum {
	SQ_START = 0,
	SQ_STOP = 1,
	SQ_ICU = 2,
};

enum {
	SQ_STS = 1,
	SQ_CUS = 2,
};

struct simplefb_platform_data {
	u32 width;
	u32 height;
	u32 stride;
	const char *format;
};

enum scmi_voltage_level_mode {
	SCMI_VOLTAGE_LEVEL_SET_AUTO = 0,
	SCMI_VOLTAGE_LEVEL_SET_SYNC = 1,
};

struct scmi_voltage_info;

struct scmi_voltage_proto_ops {
	int (*num_domains_get)(const struct scmi_protocol_handle *);
	const struct scmi_voltage_info * (*info_get)(const struct scmi_protocol_handle *, u32);
	int (*config_set)(const struct scmi_protocol_handle *, u32, u32);
	int (*config_get)(const struct scmi_protocol_handle *, u32, u32 *);
	int (*level_set)(const struct scmi_protocol_handle *, u32, enum scmi_voltage_level_mode, s32);
	int (*level_get)(const struct scmi_protocol_handle *, u32, s32 *);
};

struct scmi_voltage_info {
	unsigned int id;
	bool segmented;
	bool negative_volts_allowed;
	bool async_level_set;
	char name[64];
	unsigned int num_levels;
	int *levels_uv;
};

enum scmi_voltage_protocol_cmd {
	VOLTAGE_DOMAIN_ATTRIBUTES = 3,
	VOLTAGE_DESCRIBE_LEVELS = 4,
	VOLTAGE_CONFIG_SET = 5,
	VOLTAGE_CONFIG_GET = 6,
	VOLTAGE_LEVEL_SET = 7,
	VOLTAGE_LEVEL_GET = 8,
	VOLTAGE_DOMAIN_NAME_GET = 9,
};

struct voltage_info {
	unsigned int version;
	unsigned int num_domains;
	struct scmi_voltage_info *domains;
};

struct scmi_msg_resp_domain_attributes {
	__le32 attr;
	u8 name[16];
};

struct scmi_volt_ipriv {
	struct device *dev;
	struct scmi_voltage_info *v;
};

struct scmi_msg_cmd_describe_levels {
	__le32 domain_id;
	__le32 level_index;
};

struct scmi_msg_resp_describe_levels {
	__le32 flags;
	__le32 voltage[0];
};

struct scmi_msg_cmd_config_set {
	__le32 domain_id;
	__le32 config;
};

struct scmi_msg_cmd_level_set {
	__le32 domain_id;
	__le32 flags;
	__le32 voltage_level;
};

struct scmi_resp_voltage_level_set_complete {
	__le32 domain_id;
	__le32 voltage_level;
};

struct efi_memory_map_data {
	phys_addr_t phys_map;
	unsigned long size;
	unsigned long desc_version;
	unsigned long desc_size;
	unsigned long flags;
};

struct efi_memory_map {
	phys_addr_t phys_map;
	void *map;
	void *map_end;
	int nr_map;
	unsigned long desc_version;
	unsigned long desc_size;
	unsigned long flags;
};

typedef struct {
	u64 length;
	u64 data;
} efi_capsule_block_desc_t;

struct dw_apb_timer {
	void *base;
	unsigned long freq;
	int irq;
};

struct dw_apb_clock_event_device {
	struct clock_event_device ced;
	struct dw_apb_timer timer;
	void (*eoi)(struct dw_apb_timer *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dw_apb_clocksource {
	struct dw_apb_timer timer;
	struct clocksource cs;
};

struct ec_params_reboot_ec {
	uint8_t cmd;
	uint8_t flags;
};

struct ec_response_get_version {
	char version_string_ro[32];
	char version_string_rw[32];
	char reserved[32];
	uint32_t current_image;
};

struct ec_response_get_chip_info {
	char vendor[32];
	char name[32];
	char revision[32];
};

struct ec_response_board_version {
	uint16_t board_version;
};

struct ec_response_flash_info {
	uint32_t flash_size;
	uint32_t write_block_size;
	uint32_t erase_block_size;
	uint32_t protect_block_size;
};

struct apple_mbox_hw {
	unsigned int control_full;
	unsigned int control_empty;
	unsigned int a2i_control;
	unsigned int a2i_send0;
	unsigned int a2i_send1;
	unsigned int i2a_control;
	unsigned int i2a_recv0;
	unsigned int i2a_recv1;
	bool has_irq_controls;
	unsigned int irq_enable;
	unsigned int irq_ack;
	unsigned int irq_bit_recv_not_empty;
	unsigned int irq_bit_send_empty;
};

struct apple_mbox {
	void *regs;
	const struct apple_mbox_hw *hw;
	int irq_recv_not_empty;
	int irq_send_empty;
	struct mbox_chan chan;
	struct device *dev;
	struct mbox_controller controller;
	spinlock_t rx_lock;
};

struct apple_mbox_msg {
	u64 msg0;
	u32 msg1;
};

struct imx_bus {
	struct devfreq_dev_profile profile;
	struct devfreq *devfreq;
	struct clk *clk;
	struct platform_device *icc_pdev;
};

enum meson_sar_adc_chan7_mux_sel {
	CHAN7_MUX_VSS = 0,
	CHAN7_MUX_VDD_DIV4 = 1,
	CHAN7_MUX_VDD_DIV2 = 2,
	CHAN7_MUX_VDD_MUL3_DIV4 = 3,
	CHAN7_MUX_VDD = 4,
	CHAN7_MUX_CH7_INPUT = 7,
};

struct meson_sar_adc_param;

struct meson_sar_adc_data {
	const struct meson_sar_adc_param *param;
	const char *name;
};

enum meson_sar_adc_vref_sel {
	VREF_CALIBATION_VOLTAGE = 0,
	VREF_VDDA = 1,
};

struct meson_sar_adc_param {
	bool has_bl30_integration;
	unsigned long clock_rate;
	u32 bandgap_reg;
	unsigned int resolution;
	const struct regmap_config *regmap_config;
	u8 temperature_trimming_bits;
	unsigned int temperature_multiplier;
	unsigned int temperature_divider;
	u8 disable_ring_counter;
	bool has_reg11;
	bool has_vref_select;
	u8 vref_select;
	u8 cmv_select;
	u8 adc_eoc;
	enum meson_sar_adc_vref_sel vref_volatge;
};

enum iio_chan_info_enum {
	IIO_CHAN_INFO_RAW = 0,
	IIO_CHAN_INFO_PROCESSED = 1,
	IIO_CHAN_INFO_SCALE = 2,
	IIO_CHAN_INFO_OFFSET = 3,
	IIO_CHAN_INFO_CALIBSCALE = 4,
	IIO_CHAN_INFO_CALIBBIAS = 5,
	IIO_CHAN_INFO_PEAK = 6,
	IIO_CHAN_INFO_PEAK_SCALE = 7,
	IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW = 8,
	IIO_CHAN_INFO_AVERAGE_RAW = 9,
	IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY = 10,
	IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY = 11,
	IIO_CHAN_INFO_SAMP_FREQ = 12,
	IIO_CHAN_INFO_FREQUENCY = 13,
	IIO_CHAN_INFO_PHASE = 14,
	IIO_CHAN_INFO_HARDWAREGAIN = 15,
	IIO_CHAN_INFO_HYSTERESIS = 16,
	IIO_CHAN_INFO_HYSTERESIS_RELATIVE = 17,
	IIO_CHAN_INFO_INT_TIME = 18,
	IIO_CHAN_INFO_ENABLE = 19,
	IIO_CHAN_INFO_CALIBHEIGHT = 20,
	IIO_CHAN_INFO_CALIBWEIGHT = 21,
	IIO_CHAN_INFO_DEBOUNCE_COUNT = 22,
	IIO_CHAN_INFO_DEBOUNCE_TIME = 23,
	IIO_CHAN_INFO_CALIBEMISSIVITY = 24,
	IIO_CHAN_INFO_OVERSAMPLING_RATIO = 25,
	IIO_CHAN_INFO_THERMOCOUPLE_TYPE = 26,
	IIO_CHAN_INFO_CALIBAMBIENT = 27,
	IIO_CHAN_INFO_ZEROPOINT = 28,
};

enum meson_sar_adc_avg_mode {
	NO_AVERAGING = 0,
	MEAN_AVERAGING = 1,
	MEDIAN_AVERAGING = 2,
};

enum meson_sar_adc_num_samples {
	ONE_SAMPLE = 0,
	TWO_SAMPLES = 1,
	FOUR_SAMPLES = 2,
	EIGHT_SAMPLES = 3,
};

enum meson_sar_adc_channel_index {
	NUM_CHAN_0 = 0,
	NUM_CHAN_1 = 1,
	NUM_CHAN_2 = 2,
	NUM_CHAN_3 = 3,
	NUM_CHAN_4 = 4,
	NUM_CHAN_5 = 5,
	NUM_CHAN_6 = 6,
	NUM_CHAN_7 = 7,
	NUM_CHAN_TEMP = 8,
	NUM_MUX_0_VSS = 9,
	NUM_MUX_1_VDD_DIV4 = 10,
	NUM_MUX_2_VDD_DIV2 = 11,
	NUM_MUX_3_VDD_MUL3_DIV4 = 12,
	NUM_MUX_4_VDD = 13,
};

struct meson_sar_adc_priv {
	struct regmap *regmap;
	struct regulator *vref;
	const struct meson_sar_adc_param *param;
	struct clk *clkin;
	struct clk *core_clk;
	struct clk *adc_sel_clk;
	struct clk *adc_clk;
	struct clk_gate clk_gate;
	struct clk *adc_div_clk;
	struct clk_divider clk_div;
	struct completion done;
	struct mutex lock;
	int calibbias;
	int calibscale;
	struct regmap *tsc_regmap;
	bool temperature_sensor_calibrated;
	u8 temperature_sensor_coefficient;
	u16 temperature_sensor_adc_val;
	enum meson_sar_adc_chan7_mux_sel chan7_mux_sel;
};

struct imx_icc_node_adj_desc;

struct imx_icc_node_desc {
	const char *name;
	u16 id;
	u16 links[4];
	u16 num_links;
	const struct imx_icc_node_adj_desc *adj;
};

struct imx_icc_node_adj_desc {
	unsigned int bw_mul;
	unsigned int bw_div;
	const char *phandle_name;
	bool main_noc;
};

struct imx_icc_provider {
	void *noc_base;
	struct icc_provider provider;
};

struct imx_icc_noc_setting {
	u32 reg;
	u32 prio_level;
	u32 mode;
	u32 ext_control;
};

struct imx_icc_node {
	const struct imx_icc_node_desc *desc;
	const struct imx_icc_noc_setting *setting;
	struct device *qos_dev;
	struct dev_pm_qos_request qos_req;
	struct imx_icc_provider *imx_provider;
};

struct snd_device;

struct snd_device_ops {
	int (*dev_free)(struct snd_device *);
	int (*dev_register)(struct snd_device *);
	int (*dev_disconnect)(struct snd_device *);
};

enum snd_device_state {
	SNDRV_DEV_BUILD = 0,
	SNDRV_DEV_REGISTERED = 1,
	SNDRV_DEV_DISCONNECTED = 2,
};

enum snd_device_type {
	SNDRV_DEV_LOWLEVEL = 0,
	SNDRV_DEV_INFO = 1,
	SNDRV_DEV_BUS = 2,
	SNDRV_DEV_CODEC = 3,
	SNDRV_DEV_PCM = 4,
	SNDRV_DEV_COMPRESS = 5,
	SNDRV_DEV_RAWMIDI = 6,
	SNDRV_DEV_TIMER = 7,
	SNDRV_DEV_SEQUENCER = 8,
	SNDRV_DEV_HWDEP = 9,
	SNDRV_DEV_JACK = 10,
	SNDRV_DEV_CONTROL = 11,
};

struct snd_device {
	struct list_head list;
	struct snd_card *card;
	enum snd_device_state state;
	enum snd_device_type type;
	void *device_data;
	const struct snd_device_ops *ops;
};

struct snd_ctl_layer_ops {
	struct snd_ctl_layer_ops *next;
	const char *module_name;
	void (*lregister)(struct snd_card *);
	void (*ldisconnect)(struct snd_card *);
	void (*lnotify)(struct snd_card *, unsigned int, struct snd_kcontrol *, unsigned int);
};

enum snd_ctl_add_mode {
	CTL_ADD_EXCLUSIVE = 0,
	CTL_REPLACE = 1,
	CTL_ADD_ON_REPLACE = 2,
};

enum {
	SNDRV_DEVICE_TYPE_CONTROL = 0,
	SNDRV_DEVICE_TYPE_SEQUENCER = 1,
	SNDRV_DEVICE_TYPE_TIMER = 2,
	SNDRV_DEVICE_TYPE_HWDEP = 3,
	SNDRV_DEVICE_TYPE_RAWMIDI = 4,
	SNDRV_DEVICE_TYPE_PCM_PLAYBACK = 5,
	SNDRV_DEVICE_TYPE_PCM_CAPTURE = 6,
	SNDRV_DEVICE_TYPE_COMPRESS = 7,
};

enum sndrv_ctl_event_type {
	SNDRV_CTL_EVENT_ELEM = 0,
	SNDRV_CTL_EVENT_LAST = 0,
};

enum {
	SNDRV_CTL_TLV_OP_READ = 0,
	SNDRV_CTL_TLV_OP_WRITE = 1,
	SNDRV_CTL_TLV_OP_CMD = -1,
};

enum {
	SNDRV_CTL_IOCTL_ELEM_LIST32 = 3225965840,
	SNDRV_CTL_IOCTL_ELEM_INFO32 = 3239073041,
	SNDRV_CTL_IOCTL_ELEM_READ32 = 3267908882,
	SNDRV_CTL_IOCTL_ELEM_WRITE32 = 3267908883,
	SNDRV_CTL_IOCTL_ELEM_ADD32 = 3239073047,
	SNDRV_CTL_IOCTL_ELEM_REPLACE32 = 3239073048,
};

enum {
	SND_CTL_SUBDEV_PCM = 0,
	SND_CTL_SUBDEV_RAWMIDI = 1,
	SND_CTL_SUBDEV_ITEMS = 2,
};

struct snd_kctl_event {
	struct list_head list;
	struct snd_ctl_elem_id id;
	unsigned int mask;
};

typedef int (*snd_kctl_ioctl_func_t)(struct snd_card *, struct snd_ctl_file *, unsigned int, unsigned long);

struct snd_kctl_ioctl {
	struct list_head list;
	snd_kctl_ioctl_func_t fioctl;
};

struct snd_ctl_elem_list {
	unsigned int offset;
	unsigned int space;
	unsigned int used;
	unsigned int count;
	struct snd_ctl_elem_id __attribute__((btf_type_tag("user"))) *pids;
	unsigned char reserved[50];
};

struct snd_ctl_card_info {
	int card;
	int pad;
	unsigned char id[16];
	unsigned char driver[16];
	unsigned char name[32];
	unsigned char longname[80];
	unsigned char reserved_[16];
	unsigned char mixername[80];
	unsigned char components[128];
};

struct snd_ctl_elem_info32 {
	struct snd_ctl_elem_id id;
	s32 type;
	u32 access;
	u32 count;
	s32 owner;
	union {
		struct {
			s32 min;
			s32 max;
			s32 step;
		} integer;
		struct {
			u64 min;
			u64 max;
			u64 step;
		} integer64;
		struct {
			u32 items;
			u32 item;
			char name[64];
			u64 names_ptr;
			u32 names_length;
		} enumerated;
		unsigned char reserved[128];
	} value;
	unsigned char reserved[64];
};

struct snd_ctl_elem_value32 {
	struct snd_ctl_elem_id id;
	unsigned int indirect;
	union {
		s32 integer[128];
		unsigned char data[512];
		s64 integer64[64];
	} value;
	unsigned char reserved[128];
};

struct snd_ctl_elem_list32 {
	u32 offset;
	u32 space;
	u32 used;
	u32 count;
	u32 pids;
	unsigned char reserved[50];
};

struct user_element {
	struct snd_ctl_elem_info info;
	struct snd_card *card;
	char *elem_data;
	unsigned long elem_data_size;
	void *tlv_data;
	unsigned long tlv_data_size;
	void *priv_data;
};

struct snd_ctl_event {
	int type;
	union {
		struct {
			unsigned int mask;
			struct snd_ctl_elem_id id;
		} elem;
		unsigned char data8[60];
	} data;
};

struct snd_ctl_tlv {
	unsigned int numid;
	unsigned int length;
	unsigned int tlv[0];
};

enum {
	SNDRV_PCM_CLASS_GENERIC = 0,
	SNDRV_PCM_CLASS_MULTI = 1,
	SNDRV_PCM_CLASS_MODEM = 2,
	SNDRV_PCM_CLASS_DIGITIZER = 3,
	SNDRV_PCM_CLASS_LAST = 3,
};

struct snd_timer_hardware {
	unsigned int flags;
	unsigned long resolution;
	unsigned long resolution_min;
	unsigned long resolution_max;
	unsigned long ticks;
	int (*open)(struct snd_timer *);
	int (*close)(struct snd_timer *);
	unsigned long (*c_resolution)(struct snd_timer *);
	int (*start)(struct snd_timer *);
	int (*stop)(struct snd_timer *);
	int (*set_period)(struct snd_timer *, unsigned long, unsigned long);
	int (*precise_resolution)(struct snd_timer *, unsigned long *, unsigned long *);
};

struct snd_timer {
	int tmr_class;
	struct snd_card *card;
	struct module *module;
	int tmr_device;
	int tmr_subdevice;
	char id[64];
	char name[80];
	unsigned int flags;
	int running;
	unsigned long sticks;
	void *private_data;
	void (*private_free)(struct snd_timer *);
	struct snd_timer_hardware hw;
	spinlock_t lock;
	struct list_head device_list;
	struct list_head open_list_head;
	struct list_head active_list_head;
	struct list_head ack_list_head;
	struct list_head sack_list_head;
	struct work_struct task_work;
	int max_instances;
	int num_instances;
};

struct snd_pcm_info {
	unsigned int device;
	unsigned int subdevice;
	int stream;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	unsigned char subname[32];
	int dev_class;
	int dev_subclass;
	unsigned int subdevices_count;
	unsigned int subdevices_avail;
	union snd_pcm_sync_id sync;
	unsigned char reserved[64];
};

struct snd_pcm_status64 {
	snd_pcm_state_t state;
	u8 rsvd[4];
	s64 trigger_tstamp_sec;
	s64 trigger_tstamp_nsec;
	s64 tstamp_sec;
	s64 tstamp_nsec;
	snd_pcm_uframes_t appl_ptr;
	snd_pcm_uframes_t hw_ptr;
	snd_pcm_sframes_t delay;
	snd_pcm_uframes_t avail;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t overrange;
	snd_pcm_state_t suspended_state;
	__u32 audio_tstamp_data;
	s64 audio_tstamp_sec;
	s64 audio_tstamp_nsec;
	s64 driver_tstamp_sec;
	s64 driver_tstamp_nsec;
	__u32 audio_tstamp_accuracy;
	unsigned char reserved[20];
};

enum snd_soc_dpcm_link_state {
	SND_SOC_DPCM_LINK_STATE_NEW = 0,
	SND_SOC_DPCM_LINK_STATE_FREE = 1,
};

struct snd_soc_dpcm {
	struct snd_soc_pcm_runtime *be;
	struct snd_soc_pcm_runtime *fe;
	enum snd_soc_dpcm_link_state state;
	struct list_head list_be;
	struct list_head list_fe;
	struct dentry *debugfs_state;
};

struct snd_soc_dapm_widget_list {
	int num_widgets;
	struct snd_soc_dapm_widget *widgets[0];
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[22];
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_INTERVAL_PROBE_TIME_MS = 7,
	NEIGH_VAR_GC_STALETIME = 8,
	NEIGH_VAR_QUEUE_LEN_BYTES = 9,
	NEIGH_VAR_PROXY_QLEN = 10,
	NEIGH_VAR_ANYCAST_DELAY = 11,
	NEIGH_VAR_PROXY_DELAY = 12,
	NEIGH_VAR_LOCKTIME = 13,
	NEIGH_VAR_QUEUE_LEN = 14,
	NEIGH_VAR_RETRANS_TIME_MS = 15,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 16,
	NEIGH_VAR_GC_INTERVAL = 17,
	NEIGH_VAR_GC_THRESH1 = 18,
	NEIGH_VAR_GC_THRESH2 = 19,
	NEIGH_VAR_GC_THRESH3 = 20,
	NEIGH_VAR_MAX = 21,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_DN_TABLE = 2,
	NEIGH_NR_TABLES = 3,
	NEIGH_LINK_TABLE = 3,
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	NDTPA_INTERVAL_PROBE_TIME_MS = 19,
	__NDTPA_MAX = 20,
};

struct neighbour_cb {
	unsigned long sched_next;
	unsigned int flags;
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct ethtool_forced_speed_map {
	u32 speed;
	unsigned long caps[2];
	const u32 *cap_arr;
	u32 arr_size;
};

enum {
	ETHTOOL_A_PHC_VCLOCKS_UNSPEC = 0,
	ETHTOOL_A_PHC_VCLOCKS_HEADER = 1,
	ETHTOOL_A_PHC_VCLOCKS_NUM = 2,
	ETHTOOL_A_PHC_VCLOCKS_INDEX = 3,
	__ETHTOOL_A_PHC_VCLOCKS_CNT = 4,
	ETHTOOL_A_PHC_VCLOCKS_MAX = 3,
};

struct phc_vclocks_reply_data {
	struct ethnl_reply_data base;
	int num;
	int *index;
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

enum {
	TCP_CMSG_INQ = 1,
	TCP_CMSG_TS = 2,
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_MAX_STATES = 13,
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
	TCP_NLA_TTL = 26,
	TCP_NLA_REHASH = 27,
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct ubuf_info_msgzc {
	struct ubuf_info ubuf;
	union {
		struct {
			unsigned long desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	struct mmpin mmp;
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
	__u64 copybuf_address;
	__s32 copybuf_len;
	__u32 flags;
	__u64 msg_control;
	__u64 msg_controllen;
	__u32 msg_flags;
	__u32 reserved;
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

enum xprt_xid_rb_cmp {
	XID_RB_EQUAL = 0,
	XID_RB_LEFT = 1,
	XID_RB_RIGHT = 2,
};

struct rpc_filelist {
	const char *name;
	const struct file_operations *i_fop;
	umode_t mode;
};

enum {
	RPCAUTH_info = 0,
	RPCAUTH_EOF = 1,
};

enum {
	RPCAUTH_lockd = 0,
	RPCAUTH_mount = 1,
	RPCAUTH_nfs = 2,
	RPCAUTH_portmap = 3,
	RPCAUTH_statd = 4,
	RPCAUTH_nfsd4_cb = 5,
	RPCAUTH_cache = 6,
	RPCAUTH_nfsd = 7,
	RPCAUTH_gssd = 8,
	RPCAUTH_RootEOF = 9,
};

enum {
	RPC_PIPEFS_MOUNT = 0,
	RPC_PIPEFS_UMOUNT = 1,
};

struct rpc_pipe_dir_object_ops;

struct rpc_pipe_dir_object {
	struct list_head pdo_head;
	const struct rpc_pipe_dir_object_ops *pdo_ops;
	void *pdo_data;
};

struct rpc_pipe_dir_object_ops {
	int (*create)(struct dentry *, struct rpc_pipe_dir_object *);
	void (*destroy)(struct dentry *, struct rpc_pipe_dir_object *);
};

struct ida_bitmap {
	unsigned long bitmap[16];
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

struct vl_info {
	enum vec_type type;
	const char *name;
	int min_vl;
	int max_vl;
	int max_virtualisable_vl;
	unsigned long vq_map[8];
	unsigned long vq_partial_map[8];
};

struct cpu_fp_state {
	struct user_fpsimd_state *st;
	void *sve_state;
	void *sme_state;
	u64 *svcr;
	unsigned int sve_vl;
	unsigned int sme_vl;
	enum fp_type *fp_type;
	enum fp_type to_save;
};

struct vl_config {
	int __default_vl;
};

struct kvm_vfio_file {
	struct list_head node;
	struct file *file;
};

struct kvm_vfio {
	struct list_head file_list;
	struct mutex lock;
	bool noncoherent;
};

struct hyp_fixmap_slot {
	u64 addr;
	kvm_pte_t *ptep;
};

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

typedef void sha256_block_fn(struct sha256_state *, const u8 *, int);

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)();

struct sd_data {
	struct sched_domain * __attribute__((btf_type_tag("percpu"))) *sd;
	struct sched_domain_shared * __attribute__((btf_type_tag("percpu"))) *sds;
	struct sched_group * __attribute__((btf_type_tag("percpu"))) *sg;
	struct sched_group_capacity * __attribute__((btf_type_tag("percpu"))) *sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
};

struct housekeeping {
	cpumask_var_t cpumasks[9];
	unsigned long flags;
};

struct cpuacct {
	struct cgroup_subsys_state css;
	u64 __attribute__((btf_type_tag("percpu"))) *cpuusage;
	struct kernel_cpustat __attribute__((btf_type_tag("percpu"))) *cpustat;
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sugov_policy;

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	u64 last_update;
	unsigned long util;
	unsigned long bw_dl;
	unsigned long saved_idle_calls;
};

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
};

enum hk_flags {
	HK_FLAG_TIMER = 1,
	HK_FLAG_RCU = 2,
	HK_FLAG_MISC = 4,
	HK_FLAG_SCHED = 8,
	HK_FLAG_TICK = 16,
	HK_FLAG_DOMAIN = 32,
	HK_FLAG_WQ = 64,
	HK_FLAG_MANAGED_IRQ = 128,
	HK_FLAG_KTHREAD = 256,
};

enum cpuacct_stat_index {
	CPUACCT_STAT_USER = 0,
	CPUACCT_STAT_SYSTEM = 1,
	CPUACCT_STAT_NSTATS = 2,
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_GET_REGISTRATIONS = 512,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

struct __cmp_key {
	const struct cpumask *cpus;
	struct cpumask ***masks;
	int node;
	int cpu;
	int w;
};

struct asym_cap_data {
	struct list_head link;
	unsigned long capacity;
	unsigned long cpus[0];
};

struct s_data {
	struct sched_domain * __attribute__((btf_type_tag("percpu"))) *sd;
	struct root_domain *rd;
};

typedef void (*btf_trace_csd_queue_cpu)(void *, const unsigned int, unsigned long, smp_call_func_t, call_single_data_t *);

typedef void (*btf_trace_csd_function_entry)(void *, smp_call_func_t, call_single_data_t *);

typedef void (*btf_trace_csd_function_exit)(void *, smp_call_func_t, call_single_data_t *);

struct call_function_data {
	call_single_data_t __attribute__((btf_type_tag("percpu"))) *csd;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct trace_event_raw_csd_queue_cpu {
	struct trace_entry ent;
	unsigned int cpu;
	void *callsite;
	void *func;
	void *csd;
	char __data[0];
};

struct trace_event_raw_csd_function {
	struct trace_entry ent;
	void *func;
	void *csd;
	char __data[0];
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

struct trace_event_data_offsets_csd_queue_cpu {};

struct trace_event_data_offsets_csd_function {};

enum {
	HASH_SIZE = 128,
};

struct audit_node {
	struct list_head list;
	struct audit_tree *owner;
	unsigned int index;
};

struct audit_chunk {
	struct list_head hash;
	unsigned long key;
	struct fsnotify_mark *mark;
	struct list_head trees;
	int count;
	atomic_long_t refs;
	struct callback_head head;
	struct audit_node owners[0];
};

struct audit_tree {
	refcount_t count;
	int goner;
	struct audit_chunk *root;
	struct list_head chunks;
	struct list_head rules;
	struct list_head list;
	struct list_head same_root;
	struct callback_head head;
	char pathname[0];
};

struct audit_tree_mark {
	struct fsnotify_mark mark;
	struct audit_chunk *chunk;
};

struct event_trigger_data;

struct event_trigger_ops;

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*parse)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct event_trigger_data {
	unsigned long count;
	int ref;
	int flags;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter __attribute__((btf_type_tag("rcu"))) *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct event_trigger_ops {
	void (*trigger)(struct event_trigger_data *, struct trace_buffer *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_data *);
	void (*free)(struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_data *);
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

enum {
	EVENT_TRIGGER_FL_PROBE = 1,
};

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

typedef u64 (*btf_bpf_inode_storage_get)(struct bpf_map *, struct inode *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_inode_storage_delete)(struct bpf_map *, struct inode *);

struct bpf_storage_blob {
	struct bpf_local_storage __attribute__((btf_type_tag("rcu"))) *storage;
};

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, unsigned long, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, unsigned long, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_mm_compaction_fast_isolate_freepages)(void *, unsigned long, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, struct compact_control *, unsigned int);

typedef void (*btf_trace_mm_compaction_begin)(void *, struct compact_control *, unsigned long, unsigned long, bool);

typedef void (*btf_trace_mm_compaction_end)(void *, struct compact_control *, unsigned long, unsigned long, bool, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	unsigned long start_pfn;
	unsigned long end_pfn;
	unsigned long nr_scanned;
	unsigned long nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	unsigned long nr_migrated;
	unsigned long nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	unsigned long zone_start;
	unsigned long migrate_pfn;
	unsigned long free_pfn;
	unsigned long zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	unsigned long zone_start;
	unsigned long migrate_pfn;
	unsigned long free_pfn;
	unsigned long zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	unsigned long gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_kcompactd_wake_template {};

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct node {
	struct device dev;
	struct list_head access_list;
	struct list_head cache_attrs;
	struct device *cache_dev;
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int state;
	unsigned int seq;
	unsigned int next_seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	vfsuid_t dir_vfsuid;
	umode_t dir_mode;
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

struct renamedata {
	struct mnt_idmap *old_mnt_idmap;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct mnt_idmap *new_mnt_idmap;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct inode **delegated_inode;
	unsigned int flags;
};

struct folio_iter {
	struct folio *folio;
	size_t offset;
	size_t length;
	struct folio *_next;
	size_t _seg_count;
	int _i;
};

struct mpage_readpage_args {
	struct bio *bio;
	struct folio *folio;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	unsigned long first_logical_block;
	get_block_t *get_block;
};

struct mpage_data {
	struct bio *bio;
	sector_t last_block_in_bio;
	get_block_t *get_block;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct ext4_system_zone {
	struct rb_node node;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

enum {
	MBE_REFERENCED_B = 0,
	MBE_REUSABLE_B = 1,
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	unsigned long e_flags;
	u64 e_value;
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct nfs4_ssc_client_ops {
	struct file * (*sco_open)(struct vfsmount *, struct nfs_fh *, nfs4_stateid *);
	void (*sco_close)(struct file *);
};

struct nlm_wait {
	struct list_head b_list;
	wait_queue_head_t b_wait;
	struct nlm_host *b_host;
	struct file_lock *b_lock;
	__be32 b_status;
};

struct nlmclnt_initdata {
	const char *hostname;
	const struct sockaddr *address;
	size_t addrlen;
	unsigned short protocol;
	u32 nfs_version;
	int noresvport;
	struct net *net;
	const struct nlmclnt_operations *nlmclnt_ops;
	const struct cred *cred;
};

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long lmask;
	long lval;
};

typedef u32 unicode_t;

enum fscache_cookie_state {
	FSCACHE_COOKIE_STATE_QUIESCENT = 0,
	FSCACHE_COOKIE_STATE_LOOKING_UP = 1,
	FSCACHE_COOKIE_STATE_CREATING = 2,
	FSCACHE_COOKIE_STATE_ACTIVE = 3,
	FSCACHE_COOKIE_STATE_INVALIDATING = 4,
	FSCACHE_COOKIE_STATE_FAILED = 5,
	FSCACHE_COOKIE_STATE_LRU_DISCARDING = 6,
	FSCACHE_COOKIE_STATE_WITHDRAWING = 7,
	FSCACHE_COOKIE_STATE_RELINQUISHING = 8,
	FSCACHE_COOKIE_STATE_DROPPED = 9,
} __attribute__((mode(byte)));

enum p9_perm_t {
	P9_DMDIR = 2147483648,
	P9_DMAPPEND = 1073741824,
	P9_DMEXCL = 536870912,
	P9_DMMOUNT = 268435456,
	P9_DMAUTH = 134217728,
	P9_DMTMP = 67108864,
	P9_DMSYMLINK = 33554432,
	P9_DMLINK = 16777216,
	P9_DMDEVICE = 8388608,
	P9_DMNAMEDPIPE = 2097152,
	P9_DMSOCKET = 1048576,
	P9_DMSETUID = 524288,
	P9_DMSETGID = 262144,
	P9_DMSETVTX = 65536,
};

struct p9_rdir {
	int head;
	int tail;
	uint8_t buf[0];
};

struct p9_dirent {
	struct p9_qid qid;
	u64 d_off;
	unsigned char d_type;
	char d_name[256];
};

enum devcg_behavior {
	DEVCG_DEFAULT_NONE = 0,
	DEVCG_DEFAULT_ALLOW = 1,
	DEVCG_DEFAULT_DENY = 2,
};

struct dev_cgroup {
	struct cgroup_subsys_state css;
	struct list_head exceptions;
	enum devcg_behavior behavior;
};

struct dev_exception_item {
	u32 major;
	u32 minor;
	short type;
	short access;
	struct list_head list;
	struct callback_head rcu;
};

struct chksum_desc_ctx___2 {
	__u16 crc;
};

enum packing_op {
	PACK = 0,
	UNPACK = 1,
};

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

struct mbi_range {
	u32 spi_start;
	u32 nr_spis;
	unsigned long *bm;
};

struct fsl_mc_obj_cmd_open {
	__le32 obj_id;
};

struct phy_meson_axg_mipi_dphy_priv {
	struct device *dev;
	struct regmap *regmap;
	struct clk *clk;
	struct reset_control *reset;
	struct phy *analog;
	struct phy_configure_opts_mipi_dphy config;
};

enum exynos_mipi_phy_id {
	EXYNOS_MIPI_PHY_ID_NONE = -1,
	EXYNOS_MIPI_PHY_ID_CSIS0 = 0,
	EXYNOS_MIPI_PHY_ID_DSIM0 = 1,
	EXYNOS_MIPI_PHY_ID_CSIS1 = 2,
	EXYNOS_MIPI_PHY_ID_DSIM1 = 3,
	EXYNOS_MIPI_PHY_ID_CSIS2 = 4,
	EXYNOS_MIPI_PHYS_NUM = 5,
};

enum exynos_mipi_phy_regmap_id {
	EXYNOS_MIPI_REGMAP_PMU = 0,
	EXYNOS_MIPI_REGMAP_DISP = 1,
	EXYNOS_MIPI_REGMAP_CAM0 = 2,
	EXYNOS_MIPI_REGMAP_CAM1 = 3,
	EXYNOS_MIPI_REGMAPS_NUM = 4,
};

struct exynos_mipi_phy_desc {
	enum exynos_mipi_phy_id coupled_phy_id;
	u32 enable_val;
	unsigned int enable_reg;
	enum exynos_mipi_phy_regmap_id enable_map;
	u32 resetn_val;
	unsigned int resetn_reg;
	enum exynos_mipi_phy_regmap_id resetn_map;
};

struct mipi_phy_device_desc {
	int num_phys;
	int num_regmaps;
	const char *regmap_names[4];
	struct exynos_mipi_phy_desc phys[5];
};

struct video_phy_desc {
	struct phy *phy;
	unsigned int index;
	const struct exynos_mipi_phy_desc *data;
};

struct exynos_mipi_video_phy {
	struct regmap *regmaps[4];
	int num_phys;
	struct video_phy_desc phys[5];
	spinlock_t slock;
};

enum s900_pinconf_pull {
	OWL_PINCONF_PULL_HIZ = 0,
	OWL_PINCONF_PULL_DOWN___2 = 1,
	OWL_PINCONF_PULL_UP___2 = 2,
	OWL_PINCONF_PULL_HOLD = 3,
};

struct gpio_get_config {
	u32 gpio;
	u32 direction;
	u32 polarity;
	u32 term_en;
	u32 term_pull_up;
};

struct rpi_exp_gpio {
	struct gpio_chip gc;
	struct rpi_firmware *fw;
};

struct gpio_set_config {
	u32 gpio;
	u32 direction;
	u32 polarity;
	u32 term_en;
	u32 term_pull_up;
	u32 state;
};

struct gpio_get_set_state {
	u32 gpio;
	u32 state;
};

enum enable_type {
	undefined = -1,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	unsigned long flags;
};

struct thunder_pem_pci {
	u32 ea_entry[3];
	void *pem_reg_base;
};

struct mobiveil_msi {
	struct mutex lock;
	struct irq_domain *msi_domain;
	struct irq_domain *dev_domain;
	phys_addr_t msi_pages_phys;
	int num_of_vectors;
	unsigned long msi_irq_in_use[1];
};

struct mobiveil_rp_ops;

struct mobiveil_root_port {
	void *config_axi_slave_base;
	struct resource *ob_io_res;
	struct mobiveil_rp_ops *ops;
	int irq;
	raw_spinlock_t intx_mask_lock;
	struct irq_domain *intx_domain;
	struct mobiveil_msi msi;
	struct pci_host_bridge *bridge;
};

struct mobiveil_pab_ops;

struct mobiveil_pcie {
	struct platform_device *pdev;
	void *csr_axi_slave_base;
	void *apb_csr_base;
	phys_addr_t pcie_reg_base;
	int apio_wins;
	int ppio_wins;
	int ob_wins_configured;
	int ib_wins_configured;
	const struct mobiveil_pab_ops *ops;
	struct mobiveil_root_port rp;
};

struct mobiveil_pab_ops {
	int (*link_up)(struct mobiveil_pcie *);
};

struct mobiveil_rp_ops {
	int (*interrupt_init)(struct mobiveil_pcie *);
};

struct acpi_create_field_info {
	struct acpi_namespace_node *region_node;
	struct acpi_namespace_node *field_node;
	struct acpi_namespace_node *register_node;
	struct acpi_namespace_node *data_register_node;
	struct acpi_namespace_node *connection_node;
	u8 *resource_buffer;
	u32 bank_value;
	u32 field_bit_position;
	u32 field_bit_length;
	u16 resource_length;
	u16 pin_number_index;
	u8 field_flags;
	u8 attribute;
	u8 field_type;
	u8 access_length;
};

struct tbg_def {
	char *name;
	u32 refdiv_offset;
	u32 fbdiv_offset;
	u32 vcodiv_reg;
	u32 vcodiv_offset;
};

enum {
	P_XO = 0,
	P_GPLL0 = 1,
	P_APSS_PLL_EARLY = 2,
};

enum clk_ids___5 {
	LAST_DT_CORE_CLK___5 = 76,
	CLK_EXTAL___5 = 77,
	CLK_EXTALR___5 = 78,
	CLK_MAIN___5 = 79,
	CLK_PLL1___5 = 80,
	CLK_PLL2___3 = 81,
	CLK_PLL3___4 = 82,
	CLK_PLL4___3 = 83,
	CLK_PLL5___2 = 84,
	CLK_PLL6 = 85,
	CLK_PLL1_DIV2___5 = 86,
	CLK_PLL2_DIV2 = 87,
	CLK_PLL3_DIV2 = 88,
	CLK_PLL4_DIV2 = 89,
	CLK_PLL5_DIV2___2 = 90,
	CLK_PLL5_DIV4___2 = 91,
	CLK_PLL6_DIV2 = 92,
	CLK_S0___3 = 93,
	CLK_S0_VIO = 94,
	CLK_S0_VC = 95,
	CLK_S0_HSC = 96,
	CLK_SASYNCPER = 97,
	CLK_SV_VIP = 98,
	CLK_SV_IR = 99,
	CLK_SDSRC___4 = 100,
	CLK_RPCSRC___4 = 101,
	CLK_VIO = 102,
	CLK_VC = 103,
	CLK_OCO___2 = 104,
	MOD_CLK_BASE___5 = 105,
};

struct socfpga_pll {
	struct clk_gate hw;
};

struct stratix10_pll_clock {
	unsigned int id;
	const char *name;
	const struct clk_parent_data *parent_data;
	u8 num_parents;
	unsigned long flags;
	unsigned long offset;
};

struct tegra_clk_pll_out {
	struct clk_hw hw;
	void *reg;
	u8 enb_bit_idx;
	u8 rst_bit_idx;
	spinlock_t *lock;
	u8 flags;
};

struct dfll_fcpu_data {
	const unsigned long *cpu_max_freq_table;
	unsigned int cpu_max_freq_table_size;
	const struct cvb_table *cpu_cvb_tables;
	unsigned int cpu_cvb_tables_size;
};

struct tegra_dfll_soc_data {
	struct device *dev;
	unsigned long max_freq;
	const struct cvb_table *cvb;
	struct rail_alignment alignment;
	void (*init_clock_trimmers)();
	void (*set_clock_trimmers_high)();
	void (*set_clock_trimmers_low)();
};

enum mv_xor_type {
	XOR_ORION = 0,
	XOR_ARMADA_38X = 1,
	XOR_ARMADA_37XX = 2,
};

enum mv_xor_mode {
	XOR_MODE_IN_REG = 0,
	XOR_MODE_IN_DESC = 1,
};

struct mv_xor_device;

struct mv_xor_chan {
	int pending;
	spinlock_t lock;
	void *mmr_base;
	void *mmr_high_base;
	unsigned int idx;
	int irq;
	struct list_head chain;
	struct list_head free_slots;
	struct list_head allocated_slots;
	struct list_head completed_slots;
	dma_addr_t dma_desc_pool;
	void *dma_desc_pool_virt;
	size_t pool_size;
	struct dma_device dmadev;
	struct dma_chan dmachan;
	int slots_allocated;
	struct tasklet_struct irq_tasklet;
	int op_in_desc;
	char dummy_src[128];
	char dummy_dst[128];
	dma_addr_t dummy_src_addr;
	dma_addr_t dummy_dst_addr;
	u32 saved_config_reg;
	u32 saved_int_mask_reg;
	struct mv_xor_device *xordev;
};

struct mv_xor_device {
	void *xor_base;
	void *xor_high_base;
	struct clk *clk;
	struct mv_xor_chan *channels[2];
	int xor_type;
	u32 win_start[8];
	u32 win_end[8];
};

struct mv_xor_desc_slot {
	struct list_head node;
	struct list_head sg_tx_list;
	enum dma_transaction_type type;
	void *hw_desc;
	u16 idx;
	struct dma_async_tx_descriptor async_tx;
};

struct mv_xor_desc {
	u32 status;
	u32 crc32_result;
	u32 desc_command;
	u32 phy_next_desc;
	u32 byte_count;
	u32 phy_dest_addr;
	u32 phy_src_addr[8];
	u32 reserved0;
	u32 reserved1;
};

struct mv_xor_channel_data;

struct mv_xor_platform_data {
	struct mv_xor_channel_data *channels;
};

struct mv_xor_channel_data {
	dma_cap_mask_t cap_mask;
};

struct bman_hwerr_txt {
	u32 mask;
	const char *txt;
};

struct qcom_smem_state_ops {
	int (*update_bits)(void *, u32, u32);
};

struct qcom_smem_state;

struct smsm_entry;

struct smsm_host;

struct qcom_smsm {
	struct device *dev;
	u32 local_host;
	u32 num_hosts;
	u32 num_entries;
	u32 *local_state;
	u32 *subscription;
	struct qcom_smem_state *state;
	spinlock_t lock;
	struct smsm_entry *entries;
	struct smsm_host *hosts;
};

struct smsm_entry {
	struct qcom_smsm *smsm;
	struct irq_domain *domain;
	unsigned long irq_enabled[1];
	unsigned long irq_rising[1];
	unsigned long irq_falling[1];
	unsigned long last_value;
	u32 *remote_state;
	u32 *subscription;
};

struct smsm_host {
	struct regmap *ipc_regmap;
	int ipc_offset;
	int ipc_bit;
};

struct scmi_perf_domain {
	struct generic_pm_domain genpd;
	const struct scmi_perf_proto_ops *perf_ops;
	const struct scmi_protocol_handle *ph;
	const struct scmi_perf_domain_info *info;
	u32 domain_id;
};

struct xen_bus_type {
	char *root;
	unsigned int levels;
	int (*get_bus_id)(char *, const char *);
	int (*probe)(struct xen_bus_type *, const char *, const char *);
	bool (*otherend_will_handle)(struct xenbus_watch *, const char *, const char *);
	void (*otherend_changed)(struct xenbus_watch *, const char *, const char *);
	struct bus_type bus;
};

typedef void (*btf_trace_regulator_enable)(void *, const char *);

typedef void (*btf_trace_regulator_enable_delay)(void *, const char *);

typedef void (*btf_trace_regulator_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_disable)(void *, const char *);

typedef void (*btf_trace_regulator_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_set_voltage)(void *, const char *, int, int);

typedef void (*btf_trace_regulator_set_voltage_complete)(void *, const char *, unsigned int);

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

struct regulator_coupler {
	struct list_head list;
	int (*attach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*detach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*balance_voltage)(struct regulator_coupler *, struct regulator_dev *, suspend_state_t);
};

struct regulator_enable_gpio {
	struct list_head list;
	struct gpio_desc *gpiod;
	u32 enable_count;
	u32 request_count;
};

enum regulator_active_discharge {
	REGULATOR_ACTIVE_DISCHARGE_DEFAULT = 0,
	REGULATOR_ACTIVE_DISCHARGE_DISABLE = 1,
	REGULATOR_ACTIVE_DISCHARGE_ENABLE = 2,
};

struct trace_event_raw_regulator_basic {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regulator_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	int min;
	int max;
	char __data[0];
};

struct trace_event_raw_regulator_value {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int val;
	char __data[0];
};

struct regulator_map {
	struct list_head list;
	const char *dev_name;
	const char *supply;
	struct regulator_dev *regulator;
};

struct regulator_supply_alias {
	struct list_head list;
	struct device *src_dev;
	const char *src_supply;
	struct device *alias_dev;
	const char *alias_supply;
};

struct trace_event_data_offsets_regulator_basic {
	u32 name;
};

struct trace_event_data_offsets_regulator_range {
	u32 name;
};

struct trace_event_data_offsets_regulator_value {
	u32 name;
};

struct summary_lock_data {
	struct ww_acquire_ctx *ww_ctx;
	struct regulator_dev **new_contended_rdev;
	struct regulator_dev **old_contended_rdev;
};

struct summary_data {
	struct seq_file *s;
	struct regulator_dev *parent;
	int level;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct brcmuart_priv {
	int line;
	struct clk *baud_mux_clk;
	unsigned long default_mux_rate;
	u32 real_rates[4];
	const u32 *rate_table;
	ktime_t char_wait;
	struct uart_port *up;
	struct hrtimer hrt;
	bool shutdown;
	bool dma_enabled;
	struct uart_8250_dma dma;
	void *regs[5];
	dma_addr_t rx_addr;
	void *rx_bufs;
	size_t rx_size;
	int rx_next_buf;
	dma_addr_t tx_addr;
	void *tx_buf;
	size_t tx_size;
	bool tx_running;
	bool rx_running;
	struct dentry *debugfs_dir;
	u64 dma_rx_partial_buf;
	u64 dma_rx_full_buf;
	u32 rx_bad_timeout_late_char;
	u32 rx_bad_timeout_no_char;
	u32 rx_missing_close_timeout;
	u32 rx_err;
	u32 rx_timeout;
	u32 rx_abort;
	u32 saved_mctrl;
};

enum cons_flags {
	CON_PRINTBUFFER = 1,
	CON_CONSDEV = 2,
	CON_ENABLED = 4,
	CON_BOOT = 8,
	CON_ANYTIME = 16,
	CON_BRL = 32,
	CON_EXTENDED = 64,
	CON_SUSPENDED = 128,
	CON_NBCON = 256,
};

struct tegra_tcu {
	struct uart_driver driver;
	struct console console;
	struct uart_port port;
	struct mbox_client tx_client;
	struct mbox_client rx_client;
	struct mbox_chan *tx;
	struct mbox_chan *rx;
};

struct histb_rng_priv {
	struct hwrng rng;
	void *base;
};

struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

enum {
	MMOP_OFFLINE = 0,
	MMOP_ONLINE = 1,
	MMOP_ONLINE_KERNEL = 2,
	MMOP_ONLINE_MOVABLE = 3,
};

struct memory_group;

struct memory_block {
	unsigned long start_section_nr;
	unsigned long state;
	int online_type;
	int nid;
	struct zone *zone;
	struct device dev;
	struct vmem_altmap *altmap;
	struct memory_group *group;
	struct list_head group_next;
	atomic_long_t nr_hwpoison;
};

struct memory_group {
	int nid;
	struct list_head memory_blocks;
	unsigned long present_kernel_pages;
	unsigned long present_movable_pages;
	bool is_dynamic;
	union {
		struct {
			unsigned long max_pages;
		} s;
		struct {
			unsigned long unit_pages;
		} d;
	};
};

typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);

struct for_each_memory_block_cb_data {
	walk_memory_blocks_func_t func;
	void *arg;
};

typedef int (*walk_memory_groups_func_t)(struct memory_group *, void *);

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
	Lo_deleting = 3,
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
	DISK_EVENT_FLAG_BLOCK_ON_EXCL_WRITE = 4,
};

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

struct loop_device {
	int lo_number;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	char lo_file_name[64];
	struct file *lo_backing_file;
	struct block_device *lo_device;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	spinlock_t lo_work_lock;
	struct workqueue_struct *workqueue;
	struct work_struct rootcg_work;
	struct list_head rootcg_cmd_list;
	struct list_head idle_worker_list;
	struct rb_root worker_tree;
	struct timer_list timer;
	bool use_dio;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
	struct mutex lo_mutex;
	bool idr_visible;
};

struct loop_worker {
	struct rb_node rb_node;
	struct work_struct work;
	struct list_head cmd_list;
	struct list_head idle_list;
	struct loop_device *lo;
	struct cgroup_subsys_state *blkcg_css;
	unsigned long last_ran_at;
};

struct loop_cmd {
	struct list_head list_entry;
	bool use_aio;
	atomic_t ref;
	long ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *blkcg_css;
	struct cgroup_subsys_state *memcg_css;
};

struct compat_loop_info {
	compat_int_t lo_number;
	compat_dev_t lo_device;
	compat_ulong_t lo_inode;
	compat_dev_t lo_rdevice;
	compat_int_t lo_offset;
	compat_int_t lo_encrypt_type;
	compat_int_t lo_encrypt_key_size;
	compat_int_t lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	compat_ulong_t lo_init[2];
	char reserved[4];
};

typedef unsigned int __kernel_old_dev_t;

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	unsigned long lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	unsigned long lo_init[2];
	char reserved[4];
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

enum {
	SAS_DEV_GONE = 0,
	SAS_DEV_FOUND = 1,
	SAS_DEV_DESTROY = 2,
	SAS_DEV_EH_PENDING = 3,
	SAS_DEV_LU_RESET = 4,
	SAS_DEV_RESET = 5,
};

enum {
	AHCI_PCI_BAR_STA2X11 = 0,
	AHCI_PCI_BAR_CAVIUM = 0,
	AHCI_PCI_BAR_LOONGSON = 0,
	AHCI_PCI_BAR_ENMOTUS = 2,
	AHCI_PCI_BAR_CAVIUM_GEN5 = 4,
	AHCI_PCI_BAR_STANDARD = 5,
};

enum board_ids {
	board_ahci = 0,
	board_ahci_ign_iferr = 1,
	board_ahci_low_power = 2,
	board_ahci_no_debounce_delay = 3,
	board_ahci_nomsi = 4,
	board_ahci_noncq = 5,
	board_ahci_nosntf = 6,
	board_ahci_yes_fbs = 7,
	board_ahci_al = 8,
	board_ahci_avn = 9,
	board_ahci_mcp65 = 10,
	board_ahci_mcp77 = 11,
	board_ahci_mcp89 = 12,
	board_ahci_mv = 13,
	board_ahci_sb600 = 14,
	board_ahci_sb700 = 15,
	board_ahci_vt8251 = 16,
	board_ahci_pcs7 = 17,
	board_ahci_mcp_linux = 10,
	board_ahci_mcp67 = 10,
	board_ahci_mcp73 = 10,
	board_ahci_mcp79 = 11,
};

struct ahci_em_priv {
	enum sw_activity blink_policy;
	struct timer_list timer;
	unsigned long saved_activity;
	unsigned long activity;
	unsigned long led_state;
	struct ata_link *link;
};

struct ahci_cmd_hdr;

struct ahci_port_priv {
	struct ata_link *active_link;
	struct ahci_cmd_hdr *cmd_slot;
	dma_addr_t cmd_slot_dma;
	void *cmd_tbl;
	dma_addr_t cmd_tbl_dma;
	void *rx_fis;
	dma_addr_t rx_fis_dma;
	unsigned int ncq_saw_d2h: 1;
	unsigned int ncq_saw_dmas: 1;
	unsigned int ncq_saw_sdb: 1;
	spinlock_t lock;
	u32 intr_mask;
	bool fbs_supported;
	bool fbs_enabled;
	int fbs_last_dev;
	struct ahci_em_priv em_priv[15];
	char *irq_desc;
};

struct ahci_cmd_hdr {
	__le32 opts;
	__le32 status;
	__le32 tbl_addr;
	__le32 tbl_addr_hi;
	__le32 reserved[4];
};

struct cfi_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct mtd_info *);
};

typedef int (*varsize_frob_t)(struct map_info *, struct flchip *, unsigned long, int, void *);

enum {
	MICRON_ON_DIE_UNSUPPORTED = 0,
	MICRON_ON_DIE_SUPPORTED = 1,
	MICRON_ON_DIE_MANDATORY = 2,
};

struct nand_onfi_vendor_micron {
	u8 two_plane_read;
	u8 read_cache;
	u8 read_unique_id;
	u8 dq_imped;
	u8 dq_imped_num_settings;
	u8 dq_imped_feat_addr;
	u8 rb_pulldown_strength;
	u8 rb_pulldown_strength_feat_addr;
	u8 rb_pulldown_strength_num_settings;
	u8 otp_mode;
	u8 otp_page_start;
	u8 otp_data_prot_addr;
	u8 otp_num_pages;
	u8 otp_feat_addr;
	u8 read_retry_options;
	u8 reserved[72];
	u8 param_revision;
};

struct micron_on_die_ecc {
	bool forced;
	bool enabled;
	void *rawbuf;
};

struct micron_nand {
	struct micron_on_die_ecc ecc;
};

struct fsl_qspi_devtype_data {
	unsigned int rxfifo;
	unsigned int txfifo;
	int invalid_mstrid;
	unsigned int ahb_buf_size;
	unsigned int quirks;
	bool little_endian;
};

struct fsl_qspi {
	void *iobase;
	void *ahb_addr;
	u32 memmap_phy;
	struct clk *clk;
	struct clk *clk_en;
	struct device *dev;
	struct completion c;
	const struct fsl_qspi_devtype_data *devtype_data;
	struct mutex lock;
	struct pm_qos_request pm_qos_req;
	int selected;
};

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
	void (*shutdown)(struct mdio_device *);
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct trace_event_data_offsets_mdio_access {};

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct dpaa2_faf_error_bit {
	int position;
	enum devlink_trap_generic_id trap_id;
};

struct dpaa2_eth_devlink_priv {
	struct dpaa2_eth_priv *dpaa2_priv;
};

enum hclge_shaper_level {
	HCLGE_SHAPER_LVL_PRI = 0,
	HCLGE_SHAPER_LVL_PG = 1,
	HCLGE_SHAPER_LVL_PORT = 2,
	HCLGE_SHAPER_LVL_QSET = 3,
	HCLGE_SHAPER_LVL_CNT = 4,
	HCLGE_SHAPER_LVL_VF = 0,
	HCLGE_SHAPER_LVL_PF = 1,
};

enum hnae3_tc_map_mode {
	HNAE3_TC_MAP_MODE_PRIO = 0,
	HNAE3_TC_MAP_MODE_DSCP = 1,
};

enum hclge_shap_bucket {
	HCLGE_TM_SHAP_C_BUCKET = 0,
	HCLGE_TM_SHAP_P_BUCKET = 1,
};

struct hclge_pfc_en_cmd {
	u8 tx_rx_en_bitmap;
	u8 pri_en_bitmap;
};

struct hclge_cfg_pause_param_cmd {
	u8 mac_addr[6];
	u8 pause_trans_gap;
	u8 rsvd;
	__le16 pause_trans_time;
	u8 rsvd1[6];
	u8 mac_addr_extra[6];
	u16 rsvd2;
};

struct hclge_port_shapping_cmd {
	__le32 port_shapping_para;
	u8 flag;
	u8 rsvd[3];
	__le32 port_rate;
};

struct hclge_qs_shapping_cmd {
	__le16 qs_id;
	u8 rsvd[2];
	__le32 qs_shapping_para;
	u8 flag;
	u8 rsvd1[3];
	__le32 qs_rate;
};

struct hclge_tm_nodes_cmd {
	u8 pg_base_id;
	u8 pri_base_id;
	__le16 qset_base_id;
	__le16 queue_base_id;
	u8 pg_num;
	u8 pri_num;
	__le16 qset_num;
	__le16 queue_num;
};

struct hclge_qs_to_pri_link_cmd {
	__le16 qs_id;
	__le16 rsvd;
	u8 priority;
	u8 link_vld;
};

struct hclge_qs_sch_mode_cfg_cmd {
	__le16 qs_id;
	u8 rsvd[2];
	u8 sch_mode;
};

struct hclge_qs_weight_cmd {
	__le16 qs_id;
	u8 dwrr;
};

struct hclge_pri_sch_mode_cfg_cmd {
	u8 pri_id;
	u8 rsvd[3];
	u8 sch_mode;
};

struct hclge_priority_weight_cmd {
	u8 pri_id;
	u8 dwrr;
};

struct hclge_pri_shapping_cmd {
	u8 pri_id;
	u8 rsvd[3];
	__le32 pri_shapping_para;
	u8 flag;
	u8 rsvd1[3];
	__le32 pri_rate;
};

struct hclge_nq_to_qs_link_cmd {
	__le16 nq_id;
	__le16 rsvd;
	__le16 qset_id;
};

struct hclge_tqp_tx_queue_tc_cmd {
	__le16 queue_id;
	__le16 rsvd;
	u8 tc_id;
	u8 rev[3];
};

struct hclge_pg_to_pri_link_cmd {
	u8 pg_id;
	u8 rsvd1[3];
	u8 pri_bit_map;
};

struct hclge_pg_weight_cmd {
	u8 pg_id;
	u8 dwrr;
};

struct hclge_pg_shapping_cmd {
	u8 pg_id;
	u8 rsvd[3];
	__le32 pg_shapping_para;
	u8 flag;
	u8 rsvd1[3];
	__le32 pg_rate;
};

struct hclge_ets_tc_weight_cmd {
	u8 tc_weight[8];
	u8 weight_offset;
	u8 rsvd[15];
};

struct hclge_bp_to_qs_map_cmd {
	u8 tc_id;
	u8 rsvd[2];
	u8 qs_group_id;
	__le32 qs_bit_map;
	u32 rsvd1;
};

struct hclge_shaper_ir_para {
	u8 ir_b;
	u8 ir_u;
	u8 ir_s;
};

struct hclge_tm_shaper_para {
	u32 rate;
	u8 ir_b;
	u8 ir_u;
	u8 ir_s;
	u8 bs_b;
	u8 bs_s;
	u8 flag;
};

struct mvneta_statistic {
	unsigned short offset;
	unsigned short type;
	const char name[32];
};

enum mvneta_tx_buf_type {
	MVNETA_TYPE_TSO = 0,
	MVNETA_TYPE_SKB = 1,
	MVNETA_TYPE_XDP_TX = 2,
	MVNETA_TYPE_XDP_NDO = 3,
};

enum mvneta_bm_type {
	MVNETA_BM_FREE = 0,
	MVNETA_BM_LONG = 1,
	MVNETA_BM_SHORT = 2,
};

enum {
	__MVNETA_DOWN = 0,
};

enum {
	TC_MQPRIO_SHAPER_DCB = 0,
	TC_MQPRIO_SHAPER_BW_RATE = 1,
	__TC_MQPRIO_SHAPER_MAX = 2,
};

enum {
	ETHTOOL_STAT_EEE_WAKEUP = 0,
	ETHTOOL_STAT_SKB_ALLOC_ERR = 1,
	ETHTOOL_STAT_REFILL_ERR = 2,
	ETHTOOL_XDP_REDIRECT = 3,
	ETHTOOL_XDP_PASS = 4,
	ETHTOOL_XDP_DROP = 5,
	ETHTOOL_XDP_TX = 6,
	ETHTOOL_XDP_TX_ERR = 7,
	ETHTOOL_XDP_XMIT = 8,
	ETHTOOL_XDP_XMIT_ERR = 9,
	ETHTOOL_MAX_STATS = 10,
};

struct mvneta_pcpu_port;

struct mvneta_pcpu_stats;

struct mvneta_rx_queue;

struct mvneta_tx_queue;

struct mvneta_bm;

struct mvneta_bm_pool;

struct mvneta_port {
	u8 id;
	struct mvneta_pcpu_port __attribute__((btf_type_tag("percpu"))) *ports;
	struct mvneta_pcpu_stats __attribute__((btf_type_tag("percpu"))) *stats;
	unsigned long state;
	int pkt_size;
	void *base;
	struct mvneta_rx_queue *rxqs;
	struct mvneta_tx_queue *txqs;
	struct net_device *dev;
	struct hlist_node node_online;
	struct hlist_node node_dead;
	int rxq_def;
	spinlock_t lock;
	bool is_stopped;
	u32 cause_rx_tx;
	struct napi_struct napi;
	struct bpf_prog *xdp_prog;
	struct clk *clk;
	struct clk *clk_bus;
	u8 mcast_count[256];
	u16 tx_ring_size;
	u16 rx_ring_size;
	phy_interface_t phy_interface;
	struct device_node *dn;
	unsigned int tx_csum_limit;
	struct phylink *phylink;
	struct phylink_config phylink_config;
	struct phylink_pcs phylink_pcs;
	struct phy *comphy;
	struct mvneta_bm *bm_priv;
	struct mvneta_bm_pool *pool_long;
	struct mvneta_bm_pool *pool_short;
	int bm_win_id;
	bool eee_enabled;
	bool eee_active;
	bool tx_lpi_enabled;
	u64 ethtool_stats[42];
	u32 indir[1];
	bool neta_armada3700;
	bool neta_ac5;
	u16 rx_offset_correction;
	const struct mbus_dram_target_info *dram_target_info;
};

struct mvneta_pcpu_port {
	struct mvneta_port *pp;
	struct napi_struct napi;
	u32 cause_rx_tx;
};

struct mvneta_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	u64 xdp_redirect;
	u64 xdp_pass;
	u64 xdp_drop;
	u64 xdp_xmit;
	u64 xdp_xmit_err;
	u64 xdp_tx;
	u64 xdp_tx_err;
};

struct mvneta_ethtool_stats {
	struct mvneta_stats ps;
	u64 skb_alloc_error;
	u64 refill_error;
};

struct mvneta_pcpu_stats {
	struct u64_stats_sync syncp;
	struct mvneta_ethtool_stats es;
	u64 rx_dropped;
	u64 rx_errors;
};

struct mvneta_rx_desc;

struct mvneta_rx_queue {
	u8 id;
	int size;
	u32 pkts_coal;
	u32 time_coal;
	struct page_pool *page_pool;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	void **buf_virt_addr;
	struct mvneta_rx_desc *descs;
	dma_addr_t descs_phys;
	int last_desc;
	int next_desc_to_proc;
	int first_to_refill;
	u32 refill_num;
	long: 64;
	long: 64;
	long: 64;
};

struct mvneta_rx_desc {
	u32 status;
	u16 reserved1;
	u16 data_size;
	u32 buf_phys_addr;
	u32 reserved2;
	u32 buf_cookie;
	u16 reserved3;
	u16 reserved4;
	u32 reserved5;
	u32 reserved6;
};

struct mvneta_tx_buf;

struct mvneta_tx_desc;

struct mvneta_tx_queue {
	u8 id;
	int size;
	int count;
	int pending;
	int tx_stop_threshold;
	int tx_wake_threshold;
	struct mvneta_tx_buf *buf;
	int txq_put_index;
	int txq_get_index;
	u32 done_pkts_coal;
	struct mvneta_tx_desc *descs;
	dma_addr_t descs_phys;
	int last_desc;
	int next_desc_to_proc;
	char *tso_hdrs[32];
	dma_addr_t tso_hdrs_phys[32];
	cpumask_t affinity_mask;
};

struct mvneta_tx_buf {
	enum mvneta_tx_buf_type type;
	union {
		struct xdp_frame *xdpf;
		struct sk_buff *skb;
	};
};

struct mvneta_tx_desc {
	u32 command;
	u16 reserved1;
	u16 data_size;
	u32 buf_phys_addr;
	u32 reserved2;
	u32 reserved3[4];
};

struct mvneta_bm {
	void *reg_base;
	struct clk *clk;
	struct platform_device *pdev;
	struct gen_pool *bppi_pool;
	void *bppi_virt_addr;
	dma_addr_t bppi_phys_addr;
	struct mvneta_bm_pool *bm_pools;
};

struct hwbm_pool {
	int size;
	int frag_size;
	int buf_num;
	int (*construct)(struct hwbm_pool *, void *);
	struct mutex buf_lock;
	void *priv;
};

struct mvneta_bm_pool {
	struct hwbm_pool hwbm_pool;
	u8 id;
	enum mvneta_bm_type type;
	int pkt_size;
	u32 buf_size;
	u32 *virt_addr;
	dma_addr_t phys_addr;
	u8 port_map;
	struct mvneta_bm *priv;
};

struct each_dev_arg {
	void *data;
	int (*fn)(struct usb_device *, void *);
};

struct find_interface_arg {
	int minor;
	struct device_driver *drv;
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	unsigned long flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

struct dwc3_pci {
	struct platform_device *dwc3;
	struct pci_dev *pci;
	guid_t guid;
	unsigned int has_dsm_for_pm: 1;
	struct work_struct wakeup_work;
};

struct xhci_plat_priv {
	const char *firmware_name;
	unsigned long long quirks;
	void (*plat_start)(struct usb_hcd *);
	int (*init_quirk)(struct usb_hcd *);
	int (*suspend_quirk)(struct usb_hcd *);
	int (*resume_quirk)(struct usb_hcd *);
};

enum usb_led_event {
	USB_LED_EVENT_HOST = 0,
	USB_LED_EVENT_GADGET = 1,
};

struct usb_udc {
	struct usb_gadget_driver *driver;
	struct usb_gadget *gadget;
	struct device dev;
	struct list_head list;
	bool vbus;
	bool started;
	bool allow_connect;
	struct work_struct vbus_work;
	struct mutex connect_lock;
};

enum bdc_ep0_state {
	WAIT_FOR_SETUP = 0,
	WAIT_FOR_DATA_START = 1,
	WAIT_FOR_DATA_XMIT = 2,
	WAIT_FOR_STATUS_START = 3,
	WAIT_FOR_STATUS_XMIT = 4,
	STATUS_PENDING = 5,
};

struct bdc_scratchpad {
	dma_addr_t sp_dma;
	void *buff;
	u32 size;
};

struct bdc_sr;

struct srr {
	struct bdc_sr *sr_bds;
	u16 eqp_index;
	u16 dqp_index;
	dma_addr_t dma_addr;
};

struct bdc_req;

struct bd_transfer {
	struct bdc_req *req;
	int start_bdi;
	int next_hwd_bdi;
	int num_bds;
};

struct bdc_ep;

struct bdc_req {
	struct usb_request usb_req;
	struct list_head queue;
	struct bdc_ep *ep;
	struct bd_transfer bd_xfr;
	int epnum;
};

struct bdc {
	struct usb_gadget gadget;
	struct usb_gadget_driver *gadget_driver;
	struct device *dev;
	spinlock_t lock;
	struct phy **phys;
	int num_phys;
	unsigned int num_eps;
	struct bdc_ep **bdc_ep_array;
	void *regs;
	struct bdc_scratchpad scratchpad;
	u32 sp_buff_size;
	struct srr srr;
	struct usb_ctrlrequest setup_pkt;
	struct bdc_req ep0_req;
	struct bdc_req status_req;
	enum bdc_ep0_state ep0_state;
	bool delayed_status;
	bool zlp_needed;
	bool reinit;
	bool pullup;
	u32 devstatus;
	int irq;
	void *mem;
	u32 dev_addr;
	struct dma_pool *bd_table_pool;
	u8 test_mode;
	void (*sr_handler[2])(struct bdc *, struct bdc_sr *);
	void (*sr_xsf_ep0[3])(struct bdc *, struct bdc_sr *);
	unsigned char ep0_response_buff[6];
	struct delayed_work func_wake_notify;
	struct clk *clk;
};

struct bd_table;

struct bd_list {
	struct bd_table **bd_table_array;
	int num_tabs;
	int max_bdi;
	int eqp_bdi;
	int hwd_bdi;
	int num_bds_table;
};

struct bdc_ep {
	struct usb_ep usb_ep;
	struct list_head queue;
	struct bdc *bdc;
	u8 ep_type;
	u8 dir;
	u8 ep_num;
	const struct usb_ss_ep_comp_descriptor *comp_desc;
	const struct usb_endpoint_descriptor *desc;
	unsigned int flags;
	char name[20];
	struct bd_list bd_list;
	bool ignore_next_sr;
};

struct bdc_bd;

struct bd_table {
	struct bdc_bd *start_bd;
	dma_addr_t dma;
};

struct bdc_bd {
	__le32 offset[4];
};

struct bdc_sr {
	__le32 offset[4];
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long, int);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_timer_class {};

struct i2c_dw_semaphore_callbacks {
	int (*probe)(struct dw_i2c_dev *);
	void (*remove)(struct dw_i2c_dev *);
};

enum muxtype {
	pca954x_ismux = 0,
	pca954x_isswi = 1,
};

struct i2c_device_identity {
	u16 manufacturer_id;
	u16 part_id;
	u8 die_revision;
};

struct chip_desc {
	u8 nchans;
	u8 enable;
	u8 has_irq;
	enum muxtype muxtype;
	struct i2c_device_identity id;
};

struct i2c_mux_core {
	struct i2c_adapter *parent;
	struct device *dev;
	unsigned int mux_locked: 1;
	unsigned int arbitrator: 1;
	unsigned int gate: 1;
	void *priv;
	int (*select)(struct i2c_mux_core *, u32);
	int (*deselect)(struct i2c_mux_core *, u32);
	int num_adapters;
	int max_adapters;
	struct i2c_adapter *adapter[0];
};

struct pca954x {
	const struct chip_desc *chip;
	u8 last_chan;
	s32 idle_state;
	struct i2c_client *client;
	struct irq_domain *irq;
	unsigned int irq_mask;
	raw_spinlock_t lock;
	struct regulator *supply;
};

enum pchg_state {
	PCHG_STATE_RESET = 0,
	PCHG_STATE_INITIALIZED = 1,
	PCHG_STATE_ENABLED = 2,
	PCHG_STATE_DETECTED = 3,
	PCHG_STATE_CHARGING = 4,
	PCHG_STATE_FULL = 5,
	PCHG_STATE_DOWNLOAD = 6,
	PCHG_STATE_DOWNLOADING = 7,
	PCHG_STATE_CONNECTED = 8,
	PCHG_STATE_COUNT = 9,
};

enum {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
	POWER_SUPPLY_CHARGE_TYPE_BYPASS = 8,
};

struct port_data;

struct charger_data {
	struct device *dev;
	struct cros_ec_dev *ec_dev;
	struct cros_ec_device *ec_device;
	int num_registered_psy;
	struct port_data *ports[8];
	struct notifier_block notifier;
};

struct port_data {
	int port_number;
	char name[12];
	struct power_supply *psy;
	struct power_supply_desc psy_desc;
	int psy_status;
	int battery_percentage;
	int charge_type;
	struct charger_data *charger;
	unsigned long last_update;
};

struct ec_response_pchg_count {
	uint8_t port_count;
};

struct ec_params_get_cmd_versions_v1 {
	uint16_t cmd;
};

struct ec_response_pchg {
	uint32_t error;
	uint8_t state;
	uint8_t battery_percentage;
	uint8_t unused0;
	uint8_t unused1;
	uint32_t fw_version;
	uint32_t dropped_event_count;
};

struct ec_params_pchg {
	uint8_t port;
};

enum soc_type {
	SOC_ARCH_EXYNOS3250 = 1,
	SOC_ARCH_EXYNOS4210 = 2,
	SOC_ARCH_EXYNOS4412 = 3,
	SOC_ARCH_EXYNOS5250 = 4,
	SOC_ARCH_EXYNOS5260 = 5,
	SOC_ARCH_EXYNOS5420 = 6,
	SOC_ARCH_EXYNOS5420_TRIMINFO = 7,
	SOC_ARCH_EXYNOS5433 = 8,
	SOC_ARCH_EXYNOS7 = 9,
};

struct exynos_tmu_data {
	int id;
	void *base;
	void *base_second;
	int irq;
	enum soc_type soc;
	struct work_struct irq_work;
	struct mutex lock;
	struct clk *clk;
	struct clk *clk_sec;
	struct clk *sclk;
	u32 cal_type;
	u32 efuse_value;
	u32 min_efuse_value;
	u32 max_efuse_value;
	u16 temp_error1;
	u16 temp_error2;
	u8 gain;
	u8 reference_voltage;
	struct regulator *regulator;
	struct thermal_zone_device *tzd;
	unsigned int ntrip;
	bool enabled;
	void (*tmu_set_trip_temp)(struct exynos_tmu_data *, int, u8);
	void (*tmu_set_trip_hyst)(struct exynos_tmu_data *, int, u8, u8);
	void (*tmu_initialize)(struct platform_device *);
	void (*tmu_control)(struct platform_device *, bool);
	int (*tmu_read)(struct exynos_tmu_data *);
	void (*tmu_set_emulation)(struct exynos_tmu_data *, int);
	void (*tmu_clear_irqs)(struct exynos_tmu_data *);
};

struct mmc_op_cond_busy_data {
	struct mmc_host *host;
	u32 ocr;
	struct mmc_command *cmd;
};

struct mmc_busy_data {
	struct mmc_card *card;
	bool retry_crc_err;
	enum mmc_busy_cmd busy_cmd;
};

struct mmc_spi_platform_data;

struct scratch;

struct mmc_spi_host {
	struct mmc_host *mmc;
	struct spi_device *spi;
	unsigned char power_mode;
	u16 powerup_msecs;
	struct mmc_spi_platform_data *pdata;
	struct spi_transfer token;
	struct spi_transfer t;
	struct spi_transfer crc;
	struct spi_transfer early_status;
	struct spi_message m;
	struct spi_transfer status;
	struct spi_message readback;
	struct device *dma_dev;
	struct scratch *data;
	dma_addr_t data_dma;
	void *ones;
	dma_addr_t ones_dma;
};

struct mmc_spi_platform_data {
	int (*init)(struct device *, irqreturn_t (*)(int, void *), void *);
	void (*exit)(struct device *, void *);
	unsigned long caps;
	unsigned long caps2;
	u16 detect_delay;
	u16 powerup_msecs;
	u32 ocr_mask;
	void (*setpower)(struct device *, unsigned int);
};

struct scratch {
	u8 status[29];
	u8 data_token;
	__be16 crc_val;
};

struct sdhci_iproc_data {
	const struct sdhci_pltfm_data *pdata;
	u32 caps;
	u32 caps1;
	u32 mmc_caps;
	bool missing_caps;
};

struct sdhci_iproc_host {
	const struct sdhci_iproc_data *data;
	u32 shadow_cmd;
	u32 shadow_blk;
	bool is_cmd_shadowed;
	bool is_blk_shadowed;
};

struct a4tech_sc {
	unsigned long quirks;
	unsigned int hw_wheel;
	__s32 delayed_value;
};

struct bcm2835_mbox {
	void *regs;
	spinlock_t lock;
	struct mbox_controller controller;
};

struct exynos_adc;

struct exynos_adc_data {
	int num_channels;
	bool needs_sclk;
	bool needs_adc_phy;
	int phy_offset;
	u32 mask;
	void (*init_hw)(struct exynos_adc *);
	void (*exit_hw)(struct exynos_adc *);
	void (*clear_irq)(struct exynos_adc *);
	void (*start_conv)(struct exynos_adc *, unsigned long);
};

struct exynos_adc {
	struct exynos_adc_data *data;
	struct device *dev;
	struct input_dev *input;
	void *regs;
	struct regmap *pmu_map;
	struct clk *clk;
	struct clk *sclk;
	unsigned int irq;
	unsigned int tsirq;
	unsigned int delay;
	struct regulator *vdd;
	struct completion completion;
	u32 value;
	unsigned int version;
	bool ts_enabled;
	bool read_ts;
	u32 ts_x;
	u32 ts_y;
	struct mutex lock;
};

struct s3c2410_ts_mach_info {
	int delay;
	int presc;
	int oversampling_shift;
	void (*cfg_gpio)(struct platform_device *);
};

struct mtk_efuse_pdata {
	bool uses_post_processing;
};

struct mtk_efuse_priv {
	void *base;
};

struct link_ctl_info {
	snd_ctl_elem_type_t type;
	int count;
	int min_val;
	int max_val;
};

struct link_master;

struct link_follower {
	struct list_head list;
	struct link_master *master;
	struct link_ctl_info info;
	int vals[2];
	unsigned int flags;
	struct snd_kcontrol *kctl;
	struct snd_kcontrol follower;
};

struct link_master {
	struct list_head followers;
	struct link_ctl_info info;
	int val;
	unsigned int tlv[4];
	void (*hook)(void *, int);
	void *hook_private_data;
};

enum {
	SNDRV_TIMER_SCLASS_NONE = 0,
	SNDRV_TIMER_SCLASS_APPLICATION = 1,
	SNDRV_TIMER_SCLASS_SEQUENCER = 2,
	SNDRV_TIMER_SCLASS_OSS_SEQUENCER = 3,
	SNDRV_TIMER_SCLASS_LAST = 3,
};

enum {
	SNDRV_TIMER_CLASS_NONE = -1,
	SNDRV_TIMER_CLASS_SLAVE = 0,
	SNDRV_TIMER_CLASS_GLOBAL = 1,
	SNDRV_TIMER_CLASS_CARD = 2,
	SNDRV_TIMER_CLASS_PCM = 3,
	SNDRV_TIMER_CLASS_LAST = 3,
};

struct snd_timer_id {
	int dev_class;
	int dev_sclass;
	int card;
	int device;
	int subdevice;
};

struct snd_soc_jack_zone {
	unsigned int min_mv;
	unsigned int max_mv;
	unsigned int jack_type;
	unsigned int debounce_time;
	struct list_head list;
};

struct snd_soc_jack_gpio {
	unsigned int gpio;
	unsigned int idx;
	struct device *gpiod_dev;
	const char *name;
	int report;
	int invert;
	int debounce_time;
	bool wake;
	struct snd_soc_jack *jack;
	struct delayed_work work;
	struct notifier_block pm_notifier;
	struct gpio_desc *desc;
	void *data;
	int (*jack_status_check)(void *);
};

struct jack_gpio_tbl {
	int count;
	struct snd_soc_jack *jack;
	struct snd_soc_jack_gpio *gpios;
};

struct pcpu_gen_cookie;

struct gen_cookie {
	struct pcpu_gen_cookie __attribute__((btf_type_tag("percpu"))) *local;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct pcpu_gen_cookie {
	local_t nesting;
	u64 last;
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	ETHTOOL_A_LINKSTATE_EXT_DOWN_CNT = 7,
	__ETHTOOL_A_LINKSTATE_CNT = 8,
	ETHTOOL_A_LINKSTATE_MAX = 7,
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	struct ethtool_link_ext_stats link_stats;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct nf_sockopt_ops {
	struct list_head list;
	u_int8_t pf;
	int set_optmin;
	int set_optmax;
	int (*set)(struct sock *, int, sockptr_t, unsigned int);
	int get_optmin;
	int get_optmax;
	int (*get)(struct sock *, int, void __attribute__((btf_type_tag("user"))) *, int *);
	struct module *owner;
};

struct rpc_cred_cache {
	struct hlist_head *hashtable;
	unsigned int hashbits;
	spinlock_t lock;
};

struct gss_pipe;

struct gss_auth {
	struct kref kref;
	struct hlist_node hash;
	struct rpc_auth rpc_auth;
	struct gss_api_mech *mech;
	enum rpc_gss_svc service;
	struct rpc_clnt *client;
	struct net *net;
	netns_tracker ns_tracker;
	struct gss_pipe *gss_pipe[2];
	const char *target_name;
};

struct gss_pipe {
	struct rpc_pipe_dir_object pdo;
	struct rpc_pipe *pipe;
	struct rpc_clnt *clnt;
	const char *name;
	struct kref kref;
};

struct gss_cl_ctx;

struct gss_upcall_msg {
	refcount_t count;
	kuid_t uid;
	const char *service_name;
	struct rpc_pipe_msg msg;
	struct list_head list;
	struct gss_auth *auth;
	struct rpc_pipe *pipe;
	struct rpc_wait_queue rpc_waitqueue;
	wait_queue_head_t waitqueue;
	struct gss_cl_ctx *ctx;
	char databuf[256];
};

struct gss_cl_ctx {
	refcount_t count;
	enum rpc_gss_proc gc_proc;
	u32 gc_seq;
	u32 gc_seq_xmit;
	spinlock_t gc_seq_lock;
	struct gss_ctx *gc_gss_ctx;
	struct xdr_netobj gc_wire_ctx;
	struct xdr_netobj gc_acceptor;
	u32 gc_win;
	unsigned long gc_expiry;
	struct callback_head gc_rcu;
};

struct gss_cred {
	struct rpc_cred gc_base;
	enum rpc_gss_svc gc_service;
	struct gss_cl_ctx __attribute__((btf_type_tag("rcu"))) *gc_ctx;
	struct gss_upcall_msg *gc_upcall;
	const char *gc_principal;
	unsigned long gc_upcall_timestamp;
};

struct gss_alloc_pdo {
	struct rpc_clnt *clnt;
	const char *name;
	const struct rpc_pipe_ops *upcall_ops;
};

struct printf_spec {
	unsigned int type: 8;
	int field_width: 24;
	unsigned int flags: 8;
	unsigned int base: 8;
	int precision: 16;
};

struct page_flags_fields {
	int width;
	int shift;
	int mask;
	const struct printf_spec *spec;
	const char *name;
};

enum format_type {
	FORMAT_TYPE_NONE = 0,
	FORMAT_TYPE_WIDTH = 1,
	FORMAT_TYPE_PRECISION = 2,
	FORMAT_TYPE_CHAR = 3,
	FORMAT_TYPE_STR = 4,
	FORMAT_TYPE_PTR = 5,
	FORMAT_TYPE_PERCENT_CHAR = 6,
	FORMAT_TYPE_INVALID = 7,
	FORMAT_TYPE_LONG_LONG = 8,
	FORMAT_TYPE_ULONG = 9,
	FORMAT_TYPE_LONG = 10,
	FORMAT_TYPE_UBYTE = 11,
	FORMAT_TYPE_BYTE = 12,
	FORMAT_TYPE_USHORT = 13,
	FORMAT_TYPE_SHORT = 14,
	FORMAT_TYPE_UINT = 15,
	FORMAT_TYPE_INT = 16,
	FORMAT_TYPE_SIZE_T = 17,
	FORMAT_TYPE_PTRDIFF = 18,
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long tm_year;
	int tm_wday;
	int tm_yday;
};

struct nmi_ctx {
	u64 hcr;
	unsigned int cnt;
};

struct compat_statfs64 {
	__u32 f_type;
	__u32 f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
} __attribute__((packed));

enum aarch64_reloc_op {
	RELOC_OP_NONE = 0,
	RELOC_OP_ABS = 1,
	RELOC_OP_PREL = 2,
	RELOC_OP_PAGE = 3,
};

enum aarch64_insn_movw_imm_type {
	AARCH64_INSN_IMM_MOVNZ = 0,
	AARCH64_INSN_IMM_MOVKZ = 1,
};

typedef __s64 Elf64_Sxword;

struct elf64_rela {
	Elf64_Addr r_offset;
	Elf64_Xword r_info;
	Elf64_Sxword r_addend;
};

typedef struct elf64_rela Elf64_Rela;

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 1,
	TYPE_MAX = 2,
};

enum hw_breakpoint_ops {
	HW_BREAKPOINT_INSTALL = 0,
	HW_BREAKPOINT_UNINSTALL = 1,
	HW_BREAKPOINT_RESTORE = 2,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

struct acpi_table_fadt {
	struct acpi_table_header header;
	u32 facs;
	u32 dsdt;
	u8 model;
	u8 preferred_profile;
	u16 sci_interrupt;
	u32 smi_command;
	u8 acpi_enable;
	u8 acpi_disable;
	u8 s4_bios_request;
	u8 pstate_control;
	u32 pm1a_event_block;
	u32 pm1b_event_block;
	u32 pm1a_control_block;
	u32 pm1b_control_block;
	u32 pm2_control_block;
	u32 pm_timer_block;
	u32 gpe0_block;
	u32 gpe1_block;
	u8 pm1_event_length;
	u8 pm1_control_length;
	u8 pm2_control_length;
	u8 pm_timer_length;
	u8 gpe0_block_length;
	u8 gpe1_block_length;
	u8 gpe1_base;
	u8 cst_control;
	u16 c2_latency;
	u16 c3_latency;
	u16 flush_size;
	u16 flush_stride;
	u8 duty_offset;
	u8 duty_width;
	u8 day_alarm;
	u8 month_alarm;
	u8 century;
	u16 boot_flags;
	u8 reserved;
	u32 flags;
	struct acpi_generic_address reset_register;
	u8 reset_value;
	u16 arm_boot_flags;
	u8 minor_revision;
	u64 Xfacs;
	u64 Xdsdt;
	struct acpi_generic_address xpm1a_event_block;
	struct acpi_generic_address xpm1b_event_block;
	struct acpi_generic_address xpm1a_control_block;
	struct acpi_generic_address xpm1b_control_block;
	struct acpi_generic_address xpm2_control_block;
	struct acpi_generic_address xpm_timer_block;
	struct acpi_generic_address xgpe0_block;
	struct acpi_generic_address xgpe1_block;
	struct acpi_generic_address sleep_control;
	struct acpi_generic_address sleep_status;
	u64 hypervisor_id;
} __attribute__((packed));

struct kvm_coalesced_mmio_zone {
	__u64 addr;
	__u32 size;
	union {
		__u32 pad;
		__u32 pio;
	};
};

struct kvm_coalesced_mmio_dev {
	struct list_head list;
	struct kvm_io_device___2 dev;
	struct kvm___2 *kvm;
	struct kvm_coalesced_mmio_zone zone;
};

struct unwind_state {
	unsigned long fp;
	unsigned long pc;
	struct llist_node *kr_cur;
	struct task_struct *task;
	struct stack_info stack;
	struct stack_info *stacks;
	int nr_stacks;
};

struct psci_0_1_function_ids {
	u32 cpu_suspend;
	u32 cpu_on;
	u32 cpu_off;
	u32 migrate;
};

struct kvm_host_psci_config {
	u32 version;
	u32 smccc_version;
	struct psci_0_1_function_ids function_ids_0_1;
	bool psci_0_1_cpu_suspend_implemented;
	bool psci_0_1_cpu_on_implemented;
	bool psci_0_1_cpu_off_implemented;
	bool psci_0_1_migrate_implemented;
};

struct psci_boot_args {
	atomic_t lock;
	unsigned long pc;
	unsigned long r0;
};

enum uts_proc {
	UTS_PROC_ARCH = 0,
	UTS_PROC_OSTYPE = 1,
	UTS_PROC_OSRELEASE = 2,
	UTS_PROC_VERSION = 3,
	UTS_PROC_HOSTNAME = 4,
	UTS_PROC_DOMAINNAME = 5,
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct compat_tms {
	compat_clock_t tms_utime;
	compat_clock_t tms_stime;
	compat_clock_t tms_cutime;
	compat_clock_t tms_cstime;
};

struct compat_rlimit {
	compat_ulong_t rlim_cur;
	compat_ulong_t rlim_max;
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

struct getcpu_cache {
	unsigned long blob[16];
};

struct compat_sysinfo {
	s32 uptime;
	u32 loads[3];
	u32 totalram;
	u32 freeram;
	u32 sharedram;
	u32 bufferram;
	u32 totalswap;
	u32 freeswap;
	u16 procs;
	u16 pad;
	u32 totalhigh;
	u32 freehigh;
	u32 mem_unit;
	char _f[8];
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
};

typedef int (*proc_visitor)(struct task_struct *, void *);

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)();
	int (*prepare_late)();
	int (*enter)(suspend_state_t);
	void (*wake)();
	void (*finish)();
	bool (*suspend_again)();
	void (*end)();
	void (*recover)();
};

struct platform_s2idle_ops {
	int (*begin)();
	int (*prepare)();
	int (*prepare_late)();
	void (*check)();
	bool (*wake)();
	void (*restore_early)();
	void (*restore)();
	void (*end)();
};

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

enum suspend_stat_step {
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

enum rcutorture_type {
	RCU_FLAVOR = 0,
	RCU_TASKS_FLAVOR = 1,
	RCU_TASKS_RUDE_FLAVOR = 2,
	RCU_TASKS_TRACING_FLAVOR = 3,
	RCU_TRIVIAL_FLAVOR = 4,
	SRCU_FLAVOR = 5,
	INVALID_RCU_FLAVOR = 6,
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_sect_attr {
	struct bin_attribute battr;
	unsigned long address;
};

struct module_sect_attrs {
	struct attribute_group grp;
	unsigned int nsections;
	struct module_sect_attr attrs[0];
};

struct module_notes_attrs {
	struct kobject *dir;
	unsigned int notes;
	struct bin_attribute attrs[0];
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf64_Ehdr *hdr;
	unsigned long len;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	unsigned long symoffs;
	unsigned long stroffs;
	unsigned long init_typeoffs;
	unsigned long core_typeoffs;
	bool sig_ok;
	unsigned long mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
	} index;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

struct bpf_kfunc_desc {
	struct btf_func_model func_model;
	u32 func_id;
	s32 imm;
	u16 offset;
	unsigned long addr;
};

struct bpf_kfunc_desc_tab {
	struct bpf_kfunc_desc descs[256];
	u32 nr_descs;
};

struct bpf_kfunc_btf {
	struct btf *btf;
	struct module *module;
	u16 offset;
};

struct bpf_kfunc_btf_tab {
	struct bpf_kfunc_btf descs[256];
	u32 nr_descs;
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

enum special_kfunc_type {
	KF_bpf_obj_new_impl = 0,
	KF_bpf_obj_drop_impl = 1,
	KF_bpf_refcount_acquire_impl = 2,
	KF_bpf_list_push_front_impl = 3,
	KF_bpf_list_push_back_impl = 4,
	KF_bpf_list_pop_front = 5,
	KF_bpf_list_pop_back = 6,
	KF_bpf_cast_to_kern_ctx = 7,
	KF_bpf_rdonly_cast = 8,
	KF_bpf_rcu_read_lock = 9,
	KF_bpf_rcu_read_unlock = 10,
	KF_bpf_rbtree_remove = 11,
	KF_bpf_rbtree_add_impl = 12,
	KF_bpf_rbtree_first = 13,
	KF_bpf_dynptr_from_skb = 14,
	KF_bpf_dynptr_from_xdp = 15,
	KF_bpf_dynptr_slice = 16,
	KF_bpf_dynptr_slice_rdwr = 17,
	KF_bpf_dynptr_clone = 18,
	KF_bpf_percpu_obj_new_impl = 19,
	KF_bpf_percpu_obj_drop_impl = 20,
	KF_bpf_throw = 21,
	KF_bpf_iter_css_task_new = 22,
};

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
	STACK_DYNPTR = 4,
	STACK_ITER = 5,
};

enum bpf_access_src {
	ACCESS_DIRECT = 1,
	ACCESS_HELPER = 2,
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

enum {
	REASON_BOUNDS = -1,
	REASON_TYPE = -2,
	REASON_PATHS = -3,
	REASON_LIMIT = -4,
	REASON_STACK = -5,
};

enum kfunc_ptr_arg_type {
	KF_ARG_PTR_TO_CTX = 0,
	KF_ARG_PTR_TO_ALLOC_BTF_ID = 1,
	KF_ARG_PTR_TO_REFCOUNTED_KPTR = 2,
	KF_ARG_PTR_TO_DYNPTR = 3,
	KF_ARG_PTR_TO_ITER = 4,
	KF_ARG_PTR_TO_LIST_HEAD = 5,
	KF_ARG_PTR_TO_LIST_NODE = 6,
	KF_ARG_PTR_TO_BTF_ID = 7,
	KF_ARG_PTR_TO_MEM = 8,
	KF_ARG_PTR_TO_MEM_SIZE = 9,
	KF_ARG_PTR_TO_CALLBACK = 10,
	KF_ARG_PTR_TO_RB_ROOT = 11,
	KF_ARG_PTR_TO_RB_NODE = 12,
	KF_ARG_PTR_TO_NULL = 13,
};

enum {
	KF_ARG_DYNPTR_ID = 0,
	KF_ARG_LIST_HEAD_ID = 1,
	KF_ARG_LIST_NODE_ID = 2,
	KF_ARG_RB_ROOT_ID = 3,
	KF_ARG_RB_NODE_ID = 4,
};

enum {
	BTF_TRACING_TYPE_TASK = 0,
	BTF_TRACING_TYPE_FILE = 1,
	BTF_TRACING_TYPE_VMA = 2,
	MAX_BTF_TRACING_TYPE = 3,
};

enum {
	AT_PKT_END = -1,
	BEYOND_PKT_END = -2,
};

enum {
	BPF_MAX_LOOPS = 8388608,
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

struct bpf_iter_meta__safe_trusted {
	struct seq_file *seq;
};

struct bpf_iter__task__safe_trusted {
	struct bpf_iter_meta *meta;
	struct task_struct *task;
};

struct linux_binprm__safe_trusted {
	struct file *file;
};

struct file__safe_trusted {
	struct inode *f_inode;
};

struct dentry__safe_trusted {
	struct inode *d_inode;
};

struct socket__safe_trusted {
	struct sock *sk;
};

struct task_struct__safe_rcu {
	const cpumask_t *cpus_ptr;
	struct css_set __attribute__((btf_type_tag("rcu"))) *cgroups;
	struct task_struct __attribute__((btf_type_tag("rcu"))) *real_parent;
	struct task_struct *group_leader;
};

struct cgroup__safe_rcu {
	struct kernfs_node *kn;
};

struct css_set__safe_rcu {
	struct cgroup *dfl_cgrp;
};

struct mm_struct__safe_rcu_or_null {
	struct file __attribute__((btf_type_tag("rcu"))) *exe_file;
};

struct sk_buff__safe_rcu_or_null {
	struct sock *sk;
};

struct request_sock__safe_rcu_or_null {
	struct sock *sk;
};

struct bpf_iter;

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *, const struct bpf_prog *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *);
	void (*unreg)(void *);
	int (*update)(void *, void *);
	int (*validate)(void *);
	const struct btf_type *type;
	const struct btf_type *value_type;
	const char *name;
	struct btf_func_model func_models[64];
	u32 type_id;
	u32 value_id;
};

struct bpf_kfunc_call_arg_meta {
	struct btf *btf;
	u32 func_id;
	u32 kfunc_flags;
	const struct btf_type *func_proto;
	const char *func_name;
	u32 ref_obj_id;
	u8 release_regno;
	bool r0_rdonly;
	u32 ret_btf_id;
	u64 r0_size;
	u32 subprogno;
	struct {
		u64 value;
		bool found;
	} arg_constant;
	struct btf *arg_btf;
	u32 arg_btf_id;
	bool arg_owning_ref;
	struct {
		struct btf_field *field;
	} arg_list_head;
	struct {
		struct btf_field *field;
	} arg_rbtree_root;
	struct {
		enum bpf_dynptr_type type;
		u32 id;
		u32 ref_obj_id;
	} initialized_dynptr;
	struct {
		u8 spi;
		u8 frameno;
	} iter;
	u64 mem_size;
};

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	u8 release_regno;
	int regno;
	int access_size;
	int mem_size;
	u64 msize_max_value;
	int ref_obj_id;
	int dynptr_id;
	int map_uid;
	int func_id;
	struct btf *btf;
	u32 btf_id;
	struct btf *ret_btf;
	u32 ret_btf_id;
	u32 subprogno;
	struct btf_field *kptr_field;
};

struct bpf_bprintf_data {
	u32 *bin_args;
	char *buf;
	bool get_bin_args;
	bool get_buf;
};

struct bpf_sanitize_info {
	struct bpf_insn_aux_data aux;
	bool mask_to_left;
};

typedef int (*set_callee_state_fn)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *, int);

enum pgt_entry {
	NORMAL_PMD = 0,
	HPAGE_PMD = 1,
	NORMAL_PUD = 2,
	HPAGE_PUD = 3,
};

struct mmu_notifier_subscriptions {
	struct hlist_head list;
	bool has_itree;
	spinlock_t lock;
	unsigned long invalidate_seq;
	unsigned long active_invalidate_ranges;
	struct rb_root_cached itree;
	wait_queue_head_t wq;
	struct hlist_head deferred_list;
};

struct mmu_interval_notifier_ops;

struct mmu_interval_notifier {
	struct interval_tree_node interval_tree;
	const struct mmu_interval_notifier_ops *ops;
	struct mm_struct *mm;
	struct hlist_node deferred_item;
	unsigned long invalidate_seq;
};

struct mmu_interval_notifier_ops {
	bool (*invalidate)(struct mmu_interval_notifier *, const struct mmu_notifier_range *, unsigned long);
};

typedef void (*btf_trace_mm_khugepaged_scan_pmd)(void *, struct mm_struct *, struct page *, bool, int, int, int, int);

typedef void (*btf_trace_mm_collapse_huge_page)(void *, struct mm_struct *, int, int);

typedef void (*btf_trace_mm_collapse_huge_page_isolate)(void *, struct page *, int, int, bool, int);

typedef void (*btf_trace_mm_collapse_huge_page_swapin)(void *, struct mm_struct *, int, int, int);

typedef void (*btf_trace_mm_khugepaged_scan_file)(void *, struct mm_struct *, struct page *, struct file *, int, int, int);

typedef void (*btf_trace_mm_khugepaged_collapse_file)(void *, struct mm_struct *, struct page *, unsigned long, bool, unsigned long, struct file *, int, int);

struct collapse_control {
	bool is_khugepaged;
	u32 node_load[16];
	nodemask_t alloc_nmask;
};

struct khugepaged_mm_slot;

struct khugepaged_scan {
	struct list_head mm_head;
	struct khugepaged_mm_slot *mm_slot;
	unsigned long address;
};

struct khugepaged_mm_slot {
	struct mm_slot slot;
};

enum transparent_hugepage_flag {
	TRANSPARENT_HUGEPAGE_UNSUPPORTED = 0,
	TRANSPARENT_HUGEPAGE_FLAG = 1,
	TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG = 2,
	TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG = 3,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG = 4,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG = 5,
	TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG = 6,
	TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG = 7,
	TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG = 8,
};

enum scan_result {
	SCAN_FAIL = 0,
	SCAN_SUCCEED = 1,
	SCAN_PMD_NULL = 2,
	SCAN_PMD_NONE = 3,
	SCAN_PMD_MAPPED = 4,
	SCAN_EXCEED_NONE_PTE = 5,
	SCAN_EXCEED_SWAP_PTE = 6,
	SCAN_EXCEED_SHARED_PTE = 7,
	SCAN_PTE_NON_PRESENT = 8,
	SCAN_PTE_UFFD_WP = 9,
	SCAN_PTE_MAPPED_HUGEPAGE = 10,
	SCAN_PAGE_RO = 11,
	SCAN_LACK_REFERENCED_PAGE = 12,
	SCAN_PAGE_NULL = 13,
	SCAN_SCAN_ABORT = 14,
	SCAN_PAGE_COUNT = 15,
	SCAN_PAGE_LRU = 16,
	SCAN_PAGE_LOCK = 17,
	SCAN_PAGE_ANON = 18,
	SCAN_PAGE_COMPOUND = 19,
	SCAN_ANY_PROCESS = 20,
	SCAN_VMA_NULL = 21,
	SCAN_VMA_CHECK = 22,
	SCAN_ADDRESS_RANGE = 23,
	SCAN_DEL_PAGE_LRU = 24,
	SCAN_ALLOC_HUGE_PAGE_FAIL = 25,
	SCAN_CGROUP_CHARGE_FAIL = 26,
	SCAN_TRUNCATED = 27,
	SCAN_PAGE_HAS_PRIVATE = 28,
	SCAN_STORE_FAILED = 29,
	SCAN_COPY_MC = 30,
	SCAN_PAGE_FILLED = 31,
};

enum sgp_type {
	SGP_READ = 0,
	SGP_NOALLOC = 1,
	SGP_CACHE = 2,
	SGP_WRITE = 3,
	SGP_FALLOC = 4,
};

struct trace_event_raw_mm_khugepaged_scan_pmd {
	struct trace_entry ent;
	struct mm_struct *mm;
	unsigned long pfn;
	bool writable;
	int referenced;
	int none_or_zero;
	int status;
	int unmapped;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page {
	struct trace_entry ent;
	struct mm_struct *mm;
	int isolated;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_isolate {
	struct trace_entry ent;
	unsigned long pfn;
	int none_or_zero;
	int referenced;
	bool writable;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_swapin {
	struct trace_entry ent;
	struct mm_struct *mm;
	int swapped_in;
	int referenced;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_khugepaged_scan_file {
	struct trace_entry ent;
	struct mm_struct *mm;
	unsigned long pfn;
	u32 __data_loc_filename;
	int present;
	int swap;
	int result;
	char __data[0];
};

struct trace_event_raw_mm_khugepaged_collapse_file {
	struct trace_entry ent;
	struct mm_struct *mm;
	unsigned long hpfn;
	unsigned long index;
	unsigned long addr;
	bool is_shmem;
	u32 __data_loc_filename;
	int nr;
	int result;
	char __data[0];
};

struct trace_event_data_offsets_mm_khugepaged_scan_file {
	u32 filename;
};

struct trace_event_data_offsets_mm_khugepaged_collapse_file {
	u32 filename;
};

struct trace_event_data_offsets_mm_khugepaged_scan_pmd {};

struct trace_event_data_offsets_mm_collapse_huge_page {};

struct trace_event_data_offsets_mm_collapse_huge_page_isolate {};

struct trace_event_data_offsets_mm_collapse_huge_page_swapin {};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
	struct mount cursor;
};

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	size_t done_before;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
};

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t count;
};

enum shrink_type {
	SHRINK_DESTROY = 0,
	SHRINK_BUSY_STOP = 1,
	SHRINK_BUSY_SKIP = 2,
};

enum open_claim_type4 {
	NFS4_OPEN_CLAIM_NULL = 0,
	NFS4_OPEN_CLAIM_PREVIOUS = 1,
	NFS4_OPEN_CLAIM_DELEGATE_CUR = 2,
	NFS4_OPEN_CLAIM_DELEGATE_PREV = 3,
	NFS4_OPEN_CLAIM_FH = 4,
	NFS4_OPEN_CLAIM_DELEG_CUR_FH = 5,
	NFS4_OPEN_CLAIM_DELEG_PREV_FH = 6,
};

enum createmode4 {
	NFS4_CREATE_UNCHECKED = 0,
	NFS4_CREATE_GUARDED = 1,
	NFS4_CREATE_EXCLUSIVE = 2,
	NFS4_CREATE_EXCLUSIVE4_1 = 3,
};

enum layoutdriver_policy_flags {
	PNFS_LAYOUTRET_ON_SETATTR = 1,
	PNFS_LAYOUTRET_ON_ERROR = 2,
	PNFS_READ_WHOLE_PAGE = 4,
	PNFS_LAYOUTGET_ON_OPEN = 8,
};

struct nfs4_layoutreturn {
	struct nfs4_layoutreturn_args args;
	struct nfs4_layoutreturn_res res;
	const struct cred *cred;
	struct nfs_client *clp;
	struct inode *inode;
	int rpc_status;
	struct nfs4_xdr_opaque_data ld_private;
};

struct nfs4_layoutget_args {
	struct nfs4_sequence_args seq_args;
	__u32 type;
	struct pnfs_layout_range range;
	__u64 minlength;
	__u32 maxcount;
	struct inode *inode;
	struct nfs_open_context *ctx;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data layout;
};

struct nfs4_layoutget {
	struct nfs4_layoutget_args args;
	struct nfs4_layoutget_res res;
	const struct cred *cred;
	struct pnfs_layout_hdr *lo;
	gfp_t gfp_flags;
};

struct nfs4_exception {
	struct nfs4_state *state;
	struct inode *inode;
	nfs4_stateid *stateid;
	long timeout;
	unsigned short retrans;
	unsigned char task_is_privileged: 1;
	unsigned char delay: 1;
	unsigned char recovering: 1;
	unsigned char retry: 1;
	bool interruptible;
};

struct stateowner_id {
	__u64 create_time;
	__u32 uniquifier;
};

struct nfs_openargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct nfs_seqid *seqid;
	int open_flags;
	fmode_t fmode;
	u32 share_access;
	u32 access;
	__u64 clientid;
	struct stateowner_id id;
	union {
		struct {
			struct iattr *attrs;
			nfs4_verifier verifier;
		};
		nfs4_stateid delegation;
		fmode_t delegation_type;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const u32 *bitmask;
	const u32 *open_bitmap;
	enum open_claim_type4 claim;
	enum createmode4 createmode;
	const struct nfs4_label *label;
	umode_t umask;
	struct nfs4_layoutget_args *lg_args;
};

struct nfs_openres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fh fh;
	struct nfs4_change_info cinfo;
	__u32 rflags;
	struct nfs_fattr *f_attr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	fmode_t delegation_type;
	nfs4_stateid delegation;
	unsigned long pagemod_limit;
	__u32 do_recall;
	__u32 attrset[3];
	struct nfs4_string *owner;
	struct nfs4_string *group_owner;
	__u32 access_request;
	__u32 access_supported;
	__u32 access_result;
	struct nfs4_layoutget_res *lg_res;
};

struct nfs_open_confirmargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	nfs4_stateid *stateid;
	struct nfs_seqid *seqid;
};

struct nfs_open_confirmres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs4_opendata {
	struct kref kref;
	struct nfs_openargs o_arg;
	struct nfs_openres o_res;
	struct nfs_open_confirmargs c_arg;
	struct nfs_open_confirmres c_res;
	struct nfs4_string owner_name;
	struct nfs4_string group_name;
	struct nfs4_label *a_label;
	struct nfs_fattr f_attr;
	struct dentry *dir;
	struct dentry *dentry;
	struct nfs4_state_owner *owner;
	struct nfs4_state *state;
	struct iattr attrs;
	struct nfs4_layoutget *lgp;
	unsigned long timestamp;
	bool rpc_done;
	bool file_created;
	bool is_recover;
	bool cancelled;
	int rpc_status;
};

struct nfs42_layoutstat_res {
	struct nfs4_sequence_res seq_res;
	int num_dev;
	int rpc_status;
};

struct nfs42_layoutstat_data {
	struct inode *inode;
	struct nfs42_layoutstat_args args;
	struct nfs42_layoutstat_res res;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	struct request_queue *q;
	busy_tag_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

typedef void (*btf_trace_kyber_latency)(void *, dev_t, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kyber_adjust)(void *, dev_t, const char *, unsigned int);

typedef void (*btf_trace_kyber_throttled)(void *, dev_t, const char *);

enum {
	KYBER_READ = 0,
	KYBER_WRITE = 1,
	KYBER_DISCARD = 2,
	KYBER_OTHER = 3,
	KYBER_NUM_DOMAINS = 4,
};

enum {
	KYBER_TOTAL_LATENCY = 0,
	KYBER_IO_LATENCY = 1,
};

enum {
	KYBER_LATENCY_SHIFT = 2,
	KYBER_GOOD_BUCKETS = 4,
	KYBER_LATENCY_BUCKETS = 8,
};

enum {
	KYBER_ASYNC_PERCENT = 75,
};

struct trace_event_raw_kyber_latency {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char type[8];
	u8 percentile;
	u8 numerator;
	u8 denominator;
	unsigned int samples;
	char __data[0];
};

struct trace_event_raw_kyber_adjust {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	unsigned int depth;
	char __data[0];
};

struct trace_event_raw_kyber_throttled {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char __data[0];
};

struct kyber_cpu_latency {
	atomic_t buckets[48];
};

struct kyber_queue_data {
	struct request_queue *q;
	dev_t dev;
	struct sbitmap_queue domain_tokens[4];
	unsigned int async_depth;
	struct kyber_cpu_latency __attribute__((btf_type_tag("percpu"))) *cpu_latency;
	struct timer_list timer;
	unsigned int latency_buckets[48];
	unsigned long latency_timeout[3];
	int domain_p99[3];
	u64 latency_targets[3];
};

struct kyber_ctx_queue {
	spinlock_t lock;
	struct list_head rq_list[4];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kyber_hctx_data {
	spinlock_t lock;
	struct list_head rqs[4];
	unsigned int cur_domain;
	unsigned int batching;
	struct kyber_ctx_queue *kcqs;
	struct sbitmap kcq_map[4];
	struct sbq_wait domain_wait[4];
	struct sbq_wait_state *domain_ws[4];
	atomic_t wait_index[4];
};

struct flush_kcq_data {
	struct kyber_hctx_data *khd;
	unsigned int sched_domain;
	struct list_head *list;
};

struct trace_event_data_offsets_kyber_latency {};

struct trace_event_data_offsets_kyber_adjust {};

struct trace_event_data_offsets_kyber_throttled {};

struct io_cancel {
	struct file *file;
	u64 addr;
	u32 flags;
	s32 fd;
	u8 opcode;
};

struct io_cancel_data {
	struct io_ring_ctx *ctx;
	union {
		u64 data;
		struct file *file;
	};
	u8 opcode;
	u32 flags;
	int seq;
};

struct io_uring_sync_cancel_reg {
	__u64 addr;
	__s32 fd;
	__u32 flags;
	struct __kernel_timespec timeout;
	__u8 opcode;
	__u8 pad[7];
	__u64 pad2[3];
};

struct genradix_node {
	union {
		struct genradix_node *children[512];
		u8 data[4096];
	};
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

enum blake2s_lengths {
	BLAKE2S_BLOCK_SIZE = 64,
	BLAKE2S_HASH_SIZE = 32,
	BLAKE2S_KEY_SIZE = 32,
	BLAKE2S_128_HASH_SIZE = 16,
	BLAKE2S_160_HASH_SIZE = 20,
	BLAKE2S_224_HASH_SIZE = 28,
	BLAKE2S_256_HASH_SIZE = 32,
};

struct blake2s_state {
	u32 h[8];
	u32 t[2];
	u32 f[2];
	u8 buf[64];
	unsigned int buflen;
	unsigned int outlen;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	unsigned long start_addr;
	unsigned long end_addr;
	unsigned long bits[0];
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	unsigned long offset;
};

struct dprc_cmd_open {
	__le32 container_id;
};

struct dprc_cmd_reset_container {
	__le32 child_container_id;
	__le32 options;
};

struct dprc_cmd_set_irq {
	__le32 irq_val;
	u8 irq_index;
	u8 pad[3];
	__le64 irq_addr;
	__le32 irq_num;
};

struct dprc_cmd_set_irq_enable {
	u8 enable;
	u8 pad[3];
	u8 irq_index;
};

struct dprc_cmd_set_irq_mask {
	__le32 mask;
	u8 irq_index;
};

struct dprc_cmd_get_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dprc_rsp_get_irq_status {
	__le32 status;
};

struct dprc_cmd_clear_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dprc_rsp_get_attributes {
	__le32 container_id;
	__le32 icid;
	__le32 options;
	__le32 portal_id;
};

struct dprc_rsp_get_obj_count {
	__le32 pad;
	__le32 obj_count;
};

struct dprc_cmd_get_obj {
	__le32 obj_index;
};

struct dprc_rsp_get_obj {
	__le32 pad0;
	__le32 id;
	__le16 vendor;
	u8 irq_count;
	u8 region_count;
	__le32 state;
	__le16 version_major;
	__le16 version_minor;
	__le16 flags;
	__le16 pad1;
	u8 type[16];
	u8 label[16];
};

struct dprc_cmd_set_obj_irq {
	__le32 irq_val;
	u8 irq_index;
	u8 pad[3];
	__le64 irq_addr;
	__le32 irq_num;
	__le32 obj_id;
	u8 obj_type[16];
};

struct dprc_cmd_get_obj_region {
	__le32 obj_id;
	__le16 pad0;
	u8 region_index;
	u8 pad1;
	__le64 pad2[2];
	u8 obj_type[16];
};

struct dprc_rsp_get_obj_region {
	__le64 pad0;
	__le64 base_offset;
	__le32 size;
	u8 type;
	u8 pad2[3];
	__le32 flags;
	__le32 pad3;
	__le64 base_addr;
};

struct dprc_cmd_get_connection {
	__le32 ep1_id;
	__le16 ep1_interface_id;
	u8 pad[2];
	u8 ep1_type[16];
};

struct dprc_rsp_get_connection {
	__le64 pad[3];
	__le32 ep2_id;
	__le16 ep2_interface_id;
	__le16 pad1;
	u8 ep2_type[16];
	__le32 state;
};

struct mc_rsp_api_ver {
	__le16 major_ver;
	__le16 minor_ver;
};

struct mc_rsp_create {
	__le32 object_id;
};

struct phy_g12a_mipi_dphy_analog_priv {
	struct phy *phy;
	struct regmap *regmap;
	struct phy_configure_opts_mipi_dphy config;
};

struct rcar_gen3_phy_drv_data {
	const struct phy_ops *phy_usb2_ops;
	bool no_adp_ctrl;
};

enum rcar_gen3_phy_index {
	PHY_INDEX_BOTH_HC = 0,
	PHY_INDEX_OHCI = 1,
	PHY_INDEX_EHCI = 2,
	PHY_INDEX_HSUSB = 3,
};

struct rcar_gen3_chan;

struct rcar_gen3_phy___2 {
	struct phy *phy;
	struct rcar_gen3_chan *ch;
	u32 int_enable_bits;
	bool initialized;
	bool otg_initialized;
	bool powered;
};

struct rcar_gen3_chan {
	void *base;
	struct device *dev;
	struct extcon_dev *extcon;
	struct rcar_gen3_phy___2 rphys[4];
	struct regulator *vbus;
	struct work_struct work;
	struct mutex lock;
	enum usb_dr_mode dr_mode;
	int irq;
	u32 obint_enable_bits;
	bool extcon_host;
	bool is_otg_channel;
	bool uses_otg_pins;
	bool soc_no_adp_ctrl;
};

struct pinctrl_dt_map {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_map *map;
	unsigned int num_maps;
};

enum pmic_gpio_func_index {
	PMIC_GPIO_FUNC_INDEX_NORMAL = 0,
	PMIC_GPIO_FUNC_INDEX_PAIRED = 1,
	PMIC_GPIO_FUNC_INDEX_FUNC1 = 2,
	PMIC_GPIO_FUNC_INDEX_FUNC2 = 3,
	PMIC_GPIO_FUNC_INDEX_FUNC3 = 4,
	PMIC_GPIO_FUNC_INDEX_FUNC4 = 5,
	PMIC_GPIO_FUNC_INDEX_DTEST1 = 6,
	PMIC_GPIO_FUNC_INDEX_DTEST2 = 7,
	PMIC_GPIO_FUNC_INDEX_DTEST3 = 8,
	PMIC_GPIO_FUNC_INDEX_DTEST4 = 9,
};

struct pmic_gpio_state {
	struct device *dev;
	struct regmap *map;
	struct pinctrl_dev *ctrl;
	struct gpio_chip chip;
	u8 usid;
	u8 pid_base;
};

struct pmic_gpio_pad {
	u16 base;
	bool is_enabled;
	bool out_value;
	bool have_buffer;
	bool output_enabled;
	bool input_enabled;
	bool analog_pass;
	bool lv_mv_type;
	unsigned int num_sources;
	unsigned int power_source;
	unsigned int buffer_type;
	unsigned int pullup;
	unsigned int strength;
	unsigned int function;
	unsigned int atest;
	unsigned int dtest_buffer;
};

struct tegra_xusb_padctl_function;

struct tegra_xusb_padctl_lane;

struct tegra_xusb_padctl_soc___2 {
	const struct pinctrl_pin_desc *pins;
	unsigned int num_pins;
	const struct tegra_xusb_padctl_function *functions;
	unsigned int num_functions;
	const struct tegra_xusb_padctl_lane *lanes;
	unsigned int num_lanes;
};

struct tegra_xusb_padctl_function {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct tegra_xusb_padctl_lane {
	const char *name;
	unsigned int offset;
	unsigned int shift;
	unsigned int mask;
	unsigned int iddq;
	const unsigned int *funcs;
	unsigned int num_funcs;
};

enum tegra_xusb_padctl_param {
	TEGRA_XUSB_PADCTL_IDDQ = 0,
};

struct tegra_xusb_padctl_property {
	const char *name;
	enum tegra_xusb_padctl_param param;
};

struct tegra_xusb_padctl___2 {
	struct device *dev;
	void *regs;
	struct mutex lock;
	struct reset_control *rst;
	const struct tegra_xusb_padctl_soc___2 *soc;
	struct pinctrl_dev *pinctrl;
	struct pinctrl_desc desc;
	struct phy_provider *provider;
	struct phy *phys[2];
	unsigned int enable;
};

struct xgene_gpio {
	struct gpio_chip chip;
	void *base;
	spinlock_t lock;
	u32 set_dr_val[3];
};

struct xgene_msi_group;

struct xgene_msi {
	struct device_node *node;
	struct irq_domain *inner_domain;
	struct irq_domain *msi_domain;
	u64 msi_addr;
	void *msi_regs;
	unsigned long *bitmap;
	struct mutex bitmap_lock;
	struct xgene_msi_group *msi_groups;
	int num_cpus;
};

struct xgene_msi_group {
	struct xgene_msi *msi;
	int gic_irq;
	u32 msi_grp;
};

enum hdmi_infoframe_type {
	HDMI_INFOFRAME_TYPE_VENDOR = 129,
	HDMI_INFOFRAME_TYPE_AVI = 130,
	HDMI_INFOFRAME_TYPE_SPD = 131,
	HDMI_INFOFRAME_TYPE_AUDIO = 132,
	HDMI_INFOFRAME_TYPE_DRM = 135,
};

enum hdmi_colorspace {
	HDMI_COLORSPACE_RGB = 0,
	HDMI_COLORSPACE_YUV422 = 1,
	HDMI_COLORSPACE_YUV444 = 2,
	HDMI_COLORSPACE_YUV420 = 3,
	HDMI_COLORSPACE_RESERVED4 = 4,
	HDMI_COLORSPACE_RESERVED5 = 5,
	HDMI_COLORSPACE_RESERVED6 = 6,
	HDMI_COLORSPACE_IDO_DEFINED = 7,
};

enum hdmi_scan_mode {
	HDMI_SCAN_MODE_NONE = 0,
	HDMI_SCAN_MODE_OVERSCAN = 1,
	HDMI_SCAN_MODE_UNDERSCAN = 2,
	HDMI_SCAN_MODE_RESERVED = 3,
};

enum hdmi_colorimetry {
	HDMI_COLORIMETRY_NONE = 0,
	HDMI_COLORIMETRY_ITU_601 = 1,
	HDMI_COLORIMETRY_ITU_709 = 2,
	HDMI_COLORIMETRY_EXTENDED = 3,
};

enum hdmi_picture_aspect {
	HDMI_PICTURE_ASPECT_NONE = 0,
	HDMI_PICTURE_ASPECT_4_3 = 1,
	HDMI_PICTURE_ASPECT_16_9 = 2,
	HDMI_PICTURE_ASPECT_64_27 = 3,
	HDMI_PICTURE_ASPECT_256_135 = 4,
	HDMI_PICTURE_ASPECT_RESERVED = 5,
};

enum hdmi_active_aspect {
	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
	HDMI_ACTIVE_ASPECT_PICTURE = 8,
	HDMI_ACTIVE_ASPECT_4_3 = 9,
	HDMI_ACTIVE_ASPECT_16_9 = 10,
	HDMI_ACTIVE_ASPECT_14_9 = 11,
	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
};

enum hdmi_extended_colorimetry {
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601 = 0,
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709 = 1,
	HDMI_EXTENDED_COLORIMETRY_S_YCC_601 = 2,
	HDMI_EXTENDED_COLORIMETRY_OPYCC_601 = 3,
	HDMI_EXTENDED_COLORIMETRY_OPRGB = 4,
	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM = 5,
	HDMI_EXTENDED_COLORIMETRY_BT2020 = 6,
	HDMI_EXTENDED_COLORIMETRY_RESERVED = 7,
};

enum hdmi_quantization_range {
	HDMI_QUANTIZATION_RANGE_DEFAULT = 0,
	HDMI_QUANTIZATION_RANGE_LIMITED = 1,
	HDMI_QUANTIZATION_RANGE_FULL = 2,
	HDMI_QUANTIZATION_RANGE_RESERVED = 3,
};

enum hdmi_nups {
	HDMI_NUPS_UNKNOWN = 0,
	HDMI_NUPS_HORIZONTAL = 1,
	HDMI_NUPS_VERTICAL = 2,
	HDMI_NUPS_BOTH = 3,
};

enum hdmi_ycc_quantization_range {
	HDMI_YCC_QUANTIZATION_RANGE_LIMITED = 0,
	HDMI_YCC_QUANTIZATION_RANGE_FULL = 1,
};

enum hdmi_content_type {
	HDMI_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_CONTENT_TYPE_PHOTO = 1,
	HDMI_CONTENT_TYPE_CINEMA = 2,
	HDMI_CONTENT_TYPE_GAME = 3,
};

enum hdmi_spd_sdi {
	HDMI_SPD_SDI_UNKNOWN = 0,
	HDMI_SPD_SDI_DSTB = 1,
	HDMI_SPD_SDI_DVDP = 2,
	HDMI_SPD_SDI_DVHS = 3,
	HDMI_SPD_SDI_HDDVR = 4,
	HDMI_SPD_SDI_DVC = 5,
	HDMI_SPD_SDI_DSC = 6,
	HDMI_SPD_SDI_VCD = 7,
	HDMI_SPD_SDI_GAME = 8,
	HDMI_SPD_SDI_PC = 9,
	HDMI_SPD_SDI_BD = 10,
	HDMI_SPD_SDI_SACD = 11,
	HDMI_SPD_SDI_HDDVD = 12,
	HDMI_SPD_SDI_PMP = 13,
};

enum hdmi_audio_sample_size {
	HDMI_AUDIO_SAMPLE_SIZE_STREAM = 0,
	HDMI_AUDIO_SAMPLE_SIZE_16 = 1,
	HDMI_AUDIO_SAMPLE_SIZE_20 = 2,
	HDMI_AUDIO_SAMPLE_SIZE_24 = 3,
};

enum hdmi_audio_sample_frequency {
	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM = 0,
	HDMI_AUDIO_SAMPLE_FREQUENCY_32000 = 1,
	HDMI_AUDIO_SAMPLE_FREQUENCY_44100 = 2,
	HDMI_AUDIO_SAMPLE_FREQUENCY_48000 = 3,
	HDMI_AUDIO_SAMPLE_FREQUENCY_88200 = 4,
	HDMI_AUDIO_SAMPLE_FREQUENCY_96000 = 5,
	HDMI_AUDIO_SAMPLE_FREQUENCY_176400 = 6,
	HDMI_AUDIO_SAMPLE_FREQUENCY_192000 = 7,
};

enum hdmi_audio_coding_type_ext {
	HDMI_AUDIO_CODING_TYPE_EXT_CT = 0,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC = 1,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2 = 2,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND = 3,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC = 4,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2 = 5,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_EXT_DRA = 7,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND = 8,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
};

enum hdmi_3d_structure {
	HDMI_3D_STRUCTURE_INVALID = -1,
	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE = 1,
	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE = 2,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL = 3,
	HDMI_3D_STRUCTURE_L_DEPTH = 4,
	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH = 5,
	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM = 6,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
};

enum hdmi_eotf {
	HDMI_EOTF_TRADITIONAL_GAMMA_SDR = 0,
	HDMI_EOTF_TRADITIONAL_GAMMA_HDR = 1,
	HDMI_EOTF_SMPTE_ST2084 = 2,
	HDMI_EOTF_BT_2100_HLG = 3,
};

enum hdmi_metadata_type {
	HDMI_STATIC_METADATA_TYPE1 = 0,
};

struct hdmi_any_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
};

struct hdmi_avi_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	bool itc;
	unsigned char pixel_repeat;
	enum hdmi_colorspace colorspace;
	enum hdmi_scan_mode scan_mode;
	enum hdmi_colorimetry colorimetry;
	enum hdmi_picture_aspect picture_aspect;
	enum hdmi_active_aspect active_aspect;
	enum hdmi_extended_colorimetry extended_colorimetry;
	enum hdmi_quantization_range quantization_range;
	enum hdmi_nups nups;
	unsigned char video_code;
	enum hdmi_ycc_quantization_range ycc_quantization_range;
	enum hdmi_content_type content_type;
	unsigned short top_bar;
	unsigned short bottom_bar;
	unsigned short left_bar;
	unsigned short right_bar;
};

struct hdmi_spd_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	char vendor[8];
	char product[16];
	enum hdmi_spd_sdi sdi;
};

struct hdmi_audio_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned char channels;
	enum hdmi_audio_coding_type coding_type;
	enum hdmi_audio_sample_size sample_size;
	enum hdmi_audio_sample_frequency sample_frequency;
	enum hdmi_audio_coding_type_ext coding_type_ext;
	unsigned char channel_allocation;
	unsigned char level_shift_value;
	bool downmix_inhibit;
};

struct hdmi_vendor_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned int oui;
	u8 vic;
	enum hdmi_3d_structure s3d_struct;
	unsigned int s3d_ext_data;
};

struct hdmi_drm_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_eotf eotf;
	enum hdmi_metadata_type metadata_type;
	struct {
		u16 x;
		u16 y;
	} display_primaries[3];
	struct {
		u16 x;
		u16 y;
	} white_point;
	u16 max_display_mastering_luminance;
	u16 min_display_mastering_luminance;
	u16 max_cll;
	u16 max_fall;
};

union hdmi_vendor_any_infoframe {
	struct {
		enum hdmi_infoframe_type type;
		unsigned char version;
		unsigned char length;
		unsigned int oui;
	} any;
	struct hdmi_vendor_infoframe hdmi;
};

struct dp_sdp_header {
	u8 HB0;
	u8 HB1;
	u8 HB2;
	u8 HB3;
};

struct dp_sdp {
	struct dp_sdp_header sdp_header;
	u8 db[32];
};

union hdmi_infoframe {
	struct hdmi_any_infoframe any;
	struct hdmi_avi_infoframe avi;
	struct hdmi_spd_infoframe spd;
	union hdmi_vendor_any_infoframe vendor;
	struct hdmi_audio_infoframe audio;
	struct hdmi_drm_infoframe drm;
};

enum {
	KPARAM_MEM = 0,
	KPARAM_WIDTH = 1,
	KPARAM_HEIGHT = 2,
	KPARAM_CNT___2 = 3,
};

struct xenfb_update {
	uint8_t type;
	int32_t x;
	int32_t y;
	int32_t width;
	int32_t height;
};

struct xenfb_resize {
	uint8_t type;
	int32_t width;
	int32_t height;
	int32_t stride;
	int32_t depth;
	int32_t offset;
};

union xenfb_out_event {
	uint8_t type;
	struct xenfb_update update;
	struct xenfb_resize resize;
	char pad[40];
};

struct xenfb_page;

struct xenfb_info {
	unsigned char *fb;
	struct fb_info *fb_info;
	int x1;
	int y1;
	int x2;
	int y2;
	spinlock_t dirty_lock;
	int nr_pages;
	int irq;
	struct xenfb_page *page;
	unsigned long *gfns;
	int update_wanted;
	int feature_resize;
	struct xenfb_resize resize;
	int resize_dpy;
	spinlock_t resize_lock;
	struct xenbus_device *xbdev;
};

struct xenfb_page {
	uint32_t in_cons;
	uint32_t in_prod;
	uint32_t out_cons;
	uint32_t out_prod;
	int32_t width;
	int32_t height;
	uint32_t line_length;
	uint32_t mem_length;
	uint8_t depth;
	unsigned long pd[256];
};

enum {
	AML_FIELD_ACCESS_ANY = 0,
	AML_FIELD_ACCESS_BYTE = 1,
	AML_FIELD_ACCESS_WORD = 2,
	AML_FIELD_ACCESS_DWORD = 3,
	AML_FIELD_ACCESS_QWORD = 4,
	AML_FIELD_ACCESS_BUFFER = 5,
};

typedef u32 acpi_name;

struct acpi_reg_walk_info {
	u32 function;
	u32 reg_run_count;
	acpi_adr_space_type space_id;
};

struct acpi_pcc_info {
	u8 subspace_id;
	u16 length;
	u8 *internal_buffer;
};

struct acpi_ffh_info {
	u64 offset;
	u64 length;
};

enum acpi_return_package_types {
	ACPI_PTYPE1_FIXED = 1,
	ACPI_PTYPE1_VAR = 2,
	ACPI_PTYPE1_OPTION = 3,
	ACPI_PTYPE2 = 4,
	ACPI_PTYPE2_COUNT = 5,
	ACPI_PTYPE2_PKG_COUNT = 6,
	ACPI_PTYPE2_FIXED = 7,
	ACPI_PTYPE2_MIN = 8,
	ACPI_PTYPE2_REV_FIXED = 9,
	ACPI_PTYPE2_FIX_VAR = 10,
	ACPI_PTYPE2_VAR_VAR = 11,
	ACPI_PTYPE2_UUID_PAIR = 12,
	ACPI_PTYPE_CUSTOM = 13,
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
};

struct owl_factor {
	struct owl_factor_hw factor_hw;
	struct owl_clk_common common;
};

struct hisi_reset_controller {
	spinlock_t lock;
	void *membase;
	struct reset_controller_dev rcdev;
};

struct mtk_ref2usb_tx {
	struct clk_hw hw;
	void *base_addr;
};

struct ma35d1_clk_pll {
	struct clk_hw hw;
	u32 id;
	u8 mode;
	void *ctl0_base;
	void *ctl1_base;
	void *ctl2_base;
};

struct pll_freq_tbl;

struct clk_pll {
	u32 l_reg;
	u32 m_reg;
	u32 n_reg;
	u32 config_reg;
	u32 mode_reg;
	u32 status_reg;
	u8 status_bit;
	u8 post_div_width;
	u8 post_div_shift;
	const struct pll_freq_tbl *freq_tbl;
	struct clk_regmap clkr;
};

struct pll_freq_tbl {
	unsigned long freq;
	u16 l;
	u16 m;
	u16 n;
	u32 ibits;
};

enum clk_ids___6 {
	LAST_DT_CORE_CLK___6 = 44,
	CLK_EXTAL___6 = 45,
	CLK_EXTALR___6 = 46,
	CLK_MAIN___6 = 47,
	CLK_PLL0___4 = 48,
	CLK_PLL1___6 = 49,
	CLK_PLL3___5 = 50,
	CLK_PLL4___4 = 51,
	CLK_PLL1_DIV2___6 = 52,
	CLK_PLL1_DIV4___4 = 53,
	CLK_S0___4 = 54,
	CLK_S1___4 = 55,
	CLK_S2___3 = 56,
	CLK_S3___4 = 57,
	CLK_SDSRC___5 = 58,
	CLK_RPCSRC___5 = 59,
	CLK_RINT___3 = 60,
	MOD_CLK_BASE___6 = 61,
};

struct rockchip_mmc_clock {
	struct clk_hw hw;
	void *reg;
	int id;
	int shift;
	int cached_phase;
	struct notifier_block clk_rate_change_nb;
};

struct rockchip_pll_clock {
	unsigned int id;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	unsigned long flags;
	int con_offset;
	int mode_offset;
	int mode_shift;
	int lock_shift;
	enum rockchip_pll_type type;
	u8 pll_flags;
	struct rockchip_pll_rate_table *rate_table;
};

enum rockchip_clk_branch_type {
	branch_composite = 0,
	branch_mux = 1,
	branch_muxgrf = 2,
	branch_divider = 3,
	branch_fraction_divider = 4,
	branch_gate = 5,
	branch_mmc = 6,
	branch_inverter = 7,
	branch_factor = 8,
	branch_ddrclk = 9,
	branch_half_divider = 10,
};

struct rockchip_clk_branch {
	unsigned int id;
	enum rockchip_clk_branch_type branch_type;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	unsigned long flags;
	int muxdiv_offset;
	u8 mux_shift;
	u8 mux_width;
	u8 mux_flags;
	u32 *mux_table;
	int div_offset;
	u8 div_shift;
	u8 div_width;
	u8 div_flags;
	struct clk_div_table *div_table;
	int gate_offset;
	u8 gate_shift;
	u8 gate_flags;
	struct rockchip_clk_branch *child;
};

struct socfpga_periph_clk {
	struct clk_gate hw;
	char *parent_name;
	u32 fixed_div;
	void *div_reg;
	void *bypass_reg;
	u32 width;
	u32 shift;
	u32 bypass_shift;
};

struct stratix10_perip_c_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	const struct clk_parent_data *parent_data;
	u8 num_parents;
	unsigned long flags;
	unsigned long offset;
};

struct n5x_perip_c_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	const char * const *parent_names;
	u8 num_parents;
	unsigned long flags;
	unsigned long offset;
	unsigned long shift;
};

struct stratix10_perip_cnt_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	const struct clk_parent_data *parent_data;
	u8 num_parents;
	unsigned long flags;
	unsigned long offset;
	u8 fixed_divider;
	unsigned long bypass_reg;
	unsigned long bypass_shift;
};

struct stratix10_gate_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	const struct clk_parent_data *parent_data;
	u8 num_parents;
	unsigned long flags;
	unsigned long gate_reg;
	u8 gate_idx;
	unsigned long div_reg;
	u8 div_offset;
	u8 div_width;
	unsigned long bypass_reg;
	u8 bypass_shift;
	u8 fixed_div;
};

struct stratix10_clock_data {
	void *base;
	struct clk_hw_onecell_data clk_data;
};

struct log_header {
	__le32 magic_word;
	char reserved[4];
	__le32 buf_start;
	__le32 buf_length;
	__le32 last_byte;
};

struct console_data {
	void *map_addr;
	struct log_header *hdr;
	void *start_addr;
	void *end_addr;
	void *end_of_data;
	void *cur_ptr;
};

struct imx93_power_domain {
	struct generic_pm_domain genpd;
	struct device *dev;
	void *addr;
	struct clk_bulk_data *clks;
	int num_clks;
	bool init_off;
};

struct fixed_dev_type {
	bool has_enable_clock;
	bool has_performance_state;
};

struct fixed_voltage_config {
	const char *supply_name;
	const char *input_supply;
	int microvolts;
	unsigned int startup_delay;
	unsigned int off_on_delay;
	unsigned int enabled_at_boot: 1;
	struct regulator_init_data *init_data;
};

struct fixed_voltage_data {
	struct regulator_desc desc;
	struct regulator_dev *dev;
	struct clk *enable_clock;
	unsigned int enable_counter;
	int performance_state;
};

struct max77620_regulator_info {
	u8 type;
	u8 fps_addr;
	u8 volt_addr;
	u8 cfg_addr;
	u8 power_mode_mask;
	u8 power_mode_shift;
	u8 remote_sense_addr;
	u8 remote_sense_mask;
	struct regulator_desc desc;
};

enum max77620_regulators {
	MAX77620_REGULATOR_ID_SD0 = 0,
	MAX77620_REGULATOR_ID_SD1 = 1,
	MAX77620_REGULATOR_ID_SD2 = 2,
	MAX77620_REGULATOR_ID_SD3 = 3,
	MAX77620_REGULATOR_ID_SD4 = 4,
	MAX77620_REGULATOR_ID_LDO0 = 5,
	MAX77620_REGULATOR_ID_LDO1 = 6,
	MAX77620_REGULATOR_ID_LDO2 = 7,
	MAX77620_REGULATOR_ID_LDO3 = 8,
	MAX77620_REGULATOR_ID_LDO4 = 9,
	MAX77620_REGULATOR_ID_LDO5 = 10,
	MAX77620_REGULATOR_ID_LDO6 = 11,
	MAX77620_REGULATOR_ID_LDO7 = 12,
	MAX77620_REGULATOR_ID_LDO8 = 13,
	MAX77620_NUM_REGS = 14,
};

enum max77620_regulator_type {
	MAX77620_REGULATOR_TYPE_SD = 0,
	MAX77620_REGULATOR_TYPE_LDO_N = 1,
	MAX77620_REGULATOR_TYPE_LDO_P = 2,
};

struct max77620_regulator_pdata {
	int active_fps_src;
	int active_fps_pd_slot;
	int active_fps_pu_slot;
	int suspend_fps_src;
	int suspend_fps_pd_slot;
	int suspend_fps_pu_slot;
	int current_mode;
	int power_ok;
	int ramp_rate_setting;
};

struct max77620_regulator {
	struct device *dev;
	struct regmap *rmap;
	struct max77620_regulator_info *rinfo[14];
	struct max77620_regulator_pdata reg_pdata[14];
	int enable_power_mode[14];
	int current_power_mode[14];
	int active_fps_src[14];
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct serial_struct32 {
	compat_int_t type;
	compat_int_t line;
	compat_uint_t port;
	compat_int_t irq;
	compat_int_t flags;
	compat_int_t xmit_fifo_size;
	compat_int_t custom_divisor;
	compat_int_t baud_base;
	unsigned short close_delay;
	char io_type;
	char reserved_char;
	compat_int_t hub6;
	unsigned short closing_wait;
	unsigned short closing_wait2;
	compat_uint_t iomem_base;
	unsigned short iomem_reg_shift;
	unsigned int port_high;
	compat_int_t reserved;
};

struct meson_uart_data {
	struct uart_driver *uart_driver;
	bool has_xtal_div2;
};

struct virtrng_info {
	struct hwrng hwrng;
	struct virtqueue *vq;
	char name[25];
	int index;
	bool hwrng_register_done;
	bool hwrng_removed;
	struct completion have_data;
	unsigned int data_avail;
	unsigned int data_idx;
	u8 data[64];
};

struct arm_smmu_match_data {
	enum arm_smmu_arch_version version;
	enum arm_smmu_implementation model;
};

struct acpi_iort_node {
	u8 type;
	u16 length;
	u8 revision;
	u32 identifier;
	u32 mapping_count;
	u32 mapping_offset;
	char node_data[0];
} __attribute__((packed));

struct acpi_iort_smmu {
	u64 base_address;
	u64 span;
	u32 model;
	u32 flags;
	u32 global_interrupt_offset;
	u32 context_interrupt_count;
	u32 context_interrupt_offset;
	u32 pmu_interrupt_count;
	u32 pmu_interrupt_offset;
	u64 interrupts[0];
} __attribute__((packed));

struct iommu_iort_rmr_data {
	struct iommu_resv_region rr;
	const u32 *sids;
	u32 num_sids;
};

struct arm_smmu_master_cfg {
	struct arm_smmu_device *smmu;
	s16 smendx[0];
};

struct regmap_range_node {
	struct rb_node node;
	const char *name;
	struct regmap *map;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regmap_debugfs_node {
	struct regmap *map;
	struct list_head link;
};

struct regmap_debugfs_off_cache {
	struct list_head list;
	off_t min;
	off_t max;
	unsigned int base_reg;
	unsigned int max_reg;
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *);
	void *priv;
};

enum xgene_ahci_version {
	XGENE_AHCI_V1 = 1,
	XGENE_AHCI_V2 = 2,
};

struct xgene_ahci_context {
	struct ahci_host_priv *hpriv;
	struct device *dev;
	u8 last_cmd[2];
	u32 class[2];
	void *csr_core;
	void *csr_diag;
	void *csr_axi;
	void *csr_mux;
};

struct acpi_pnp_device_id {
	u32 length;
	char *string;
};

struct acpi_pnp_device_id_list {
	u32 count;
	u32 list_size;
	struct acpi_pnp_device_id ids[0];
};

struct acpi_device_info {
	u32 info_size;
	u32 name;
	acpi_object_type type;
	u8 param_count;
	u16 valid;
	u8 flags;
	u8 highest_dstates[4];
	u8 lowest_dstates[5];
	u64 address;
	struct acpi_pnp_device_id hardware_id;
	struct acpi_pnp_device_id unique_id;
	struct acpi_pnp_device_id class_code;
	struct acpi_pnp_device_id_list compatible_id_list;
};

struct spansion_nor_params {
	u8 clsr;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

enum {
	IFLA_TUN_UNSPEC = 0,
	IFLA_TUN_OWNER = 1,
	IFLA_TUN_GROUP = 2,
	IFLA_TUN_TYPE = 3,
	IFLA_TUN_PI = 4,
	IFLA_TUN_VNET_HDR = 5,
	IFLA_TUN_PERSIST = 6,
	IFLA_TUN_MULTI_QUEUE = 7,
	IFLA_TUN_NUM_QUEUES = 8,
	IFLA_TUN_NUM_DISABLED_QUEUES = 9,
	__IFLA_TUN_MAX = 10,
};

struct tun_struct;

struct tun_flow_entry {
	struct hlist_node hash_link;
	struct callback_head rcu;
	struct tun_struct *tun;
	u32 rxhash;
	u32 rps_rxhash;
	int queue_index;
	long: 64;
	unsigned long updated;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tap_filter {
	unsigned int count;
	u32 mask[2];
	unsigned char addr[48];
};

struct tun_file;

struct tun_prog;

struct tun_struct {
	struct tun_file __attribute__((btf_type_tag("rcu"))) *tfiles[256];
	unsigned int numqueues;
	unsigned int flags;
	kuid_t owner;
	kgid_t group;
	struct net_device *dev;
	netdev_features_t set_features;
	int align;
	int vnet_hdr_sz;
	int sndbuf;
	struct tap_filter txflt;
	struct sock_fprog fprog;
	bool filter_attached;
	u32 msg_enable;
	spinlock_t lock;
	struct hlist_head flows[1024];
	struct timer_list flow_gc_timer;
	unsigned long ageing_time;
	unsigned int numdisabled;
	struct list_head disabled;
	void *security;
	u32 flow_count;
	u32 rx_batched;
	atomic_long_t rx_frame_errors;
	struct bpf_prog __attribute__((btf_type_tag("rcu"))) *xdp_prog;
	struct tun_prog __attribute__((btf_type_tag("rcu"))) *steering_prog;
	struct tun_prog __attribute__((btf_type_tag("rcu"))) *filter_prog;
	struct ethtool_link_ksettings link_ksettings;
	struct file *file;
	struct ifreq *ifr;
};

struct tun_file {
	struct sock sk;
	long: 64;
	long: 64;
	struct socket socket;
	struct tun_struct __attribute__((btf_type_tag("rcu"))) *tun;
	struct fasync_struct *fasync;
	unsigned int flags;
	union {
		u16 queue_index;
		unsigned int ifindex;
	};
	struct napi_struct napi;
	bool napi_enabled;
	bool napi_frags_enabled;
	struct mutex napi_mutex;
	struct list_head next;
	struct tun_struct *detached;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring tx_ring;
	struct xdp_rxq_info xdp_rxq;
};

struct tun_prog {
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct tun_pi {
	__u16 flags;
	__be16 proto;
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct veth {
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct tun_page {
	struct page *page;
	int count;
};

struct tun_xdp_hdr {
	int buflen;
	struct virtio_net_hdr gso;
};

struct tun_filter {
	__u16 flags;
	__u16 count;
	__u8 addr[0];
};

struct tun_msg_ctl {
	unsigned short type;
	unsigned short num;
	void *ptr;
};

struct xcv {
	void *reg_base;
	struct pci_dev *pdev;
};

enum dpmac_counter_id {
	DPMAC_CNT_ING_FRAME_64 = 0,
	DPMAC_CNT_ING_FRAME_127 = 1,
	DPMAC_CNT_ING_FRAME_255 = 2,
	DPMAC_CNT_ING_FRAME_511 = 3,
	DPMAC_CNT_ING_FRAME_1023 = 4,
	DPMAC_CNT_ING_FRAME_1518 = 5,
	DPMAC_CNT_ING_FRAME_1519_MAX = 6,
	DPMAC_CNT_ING_FRAG = 7,
	DPMAC_CNT_ING_JABBER = 8,
	DPMAC_CNT_ING_FRAME_DISCARD = 9,
	DPMAC_CNT_ING_ALIGN_ERR = 10,
	DPMAC_CNT_EGR_UNDERSIZED = 11,
	DPMAC_CNT_ING_OVERSIZED = 12,
	DPMAC_CNT_ING_VALID_PAUSE_FRAME = 13,
	DPMAC_CNT_EGR_VALID_PAUSE_FRAME = 14,
	DPMAC_CNT_ING_BYTE = 15,
	DPMAC_CNT_ING_MCAST_FRAME = 16,
	DPMAC_CNT_ING_BCAST_FRAME = 17,
	DPMAC_CNT_ING_ALL_FRAME = 18,
	DPMAC_CNT_ING_UCAST_FRAME = 19,
	DPMAC_CNT_ING_ERR_FRAME = 20,
	DPMAC_CNT_EGR_BYTE = 21,
	DPMAC_CNT_EGR_MCAST_FRAME = 22,
	DPMAC_CNT_EGR_BCAST_FRAME = 23,
	DPMAC_CNT_EGR_UCAST_FRAME = 24,
	DPMAC_CNT_EGR_ERR_FRAME = 25,
	DPMAC_CNT_ING_GOOD_FRAME = 26,
	DPMAC_CNT_EGR_GOOD_FRAME = 27,
};

struct dpmac_cmd_open {
	__le32 dpmac_id;
};

struct dpmac_rsp_get_attributes {
	u8 eth_if;
	u8 link_type;
	__le16 id;
	__le32 max_rate;
};

struct dpmac_cmd_set_link_state {
	__le64 options;
	__le32 rate;
	__le32 pad0;
	u8 state;
	u8 pad1[7];
	__le64 supported;
	__le64 advertising;
};

struct dpmac_cmd_get_counter {
	u8 id;
};

struct dpmac_rsp_get_counter {
	__le64 pad;
	__le64 counter;
};

struct dpmac_rsp_get_api_version {
	__le16 major;
	__le16 minor;
};

struct dpmac_cmd_set_protocol {
	u8 eth_if;
};

enum enetc_active_offloads {
	ENETC_F_TX_TSTAMP = 1,
	ENETC_F_TX_ONESTEP_SYNC_TSTAMP = 2,
	ENETC_F_RX_TSTAMP = 256,
	ENETC_F_QBV = 512,
	ENETC_F_QCI = 1024,
	ENETC_F_QBU = 2048,
};

enum enetc_msg_cmd_type {
	ENETC_MSG_CMD_MNG_MAC = 1,
	ENETC_MSG_CMD_MNG_RX_MAC_FILTER = 2,
	ENETC_MSG_CMD_MNG_RX_VLAN_FILTER = 3,
};

enum enetc_msg_cmd_action_type {
	ENETC_MSG_CMD_MNG_ADD = 1,
	ENETC_MSG_CMD_MNG_REMOVE = 2,
};

struct enetc_msg_cmd_header {
	u16 type;
	u16 id;
};

struct enetc_msg_cmd_set_primary_mac {
	struct enetc_msg_cmd_header header;
	struct sockaddr mac;
};

struct psfp_cap {
	u32 max_streamid;
	u32 max_psfp_filter;
	u32 max_psfp_gate;
	u32 max_psfp_gatelist;
	u32 max_psfp_meter;
};

struct enetc_int_vector;

struct enetc_bdr;

struct enetc_bdr_resource;

struct enetc_cls_rule;

struct enetc_ndev_priv {
	struct net_device *ndev;
	struct device *dev;
	struct enetc_si *si;
	int bdr_int_num;
	struct enetc_int_vector *int_vector[2];
	u16 num_rx_rings;
	u16 num_tx_rings;
	u16 rx_bd_count;
	u16 tx_bd_count;
	u16 msg_enable;
	u8 preemptible_tcs;
	enum enetc_active_offloads active_offloads;
	u32 speed;
	struct enetc_bdr **xdp_tx_ring;
	struct enetc_bdr *tx_ring[16];
	struct enetc_bdr *rx_ring[16];
	const struct enetc_bdr_resource *tx_res;
	const struct enetc_bdr_resource *rx_res;
	struct enetc_cls_rule *cls_rules;
	struct psfp_cap psfp_cap;
	unsigned int min_num_stack_tx_queues;
	struct phylink *phylink;
	int ic_mode;
	u32 tx_ictt;
	struct bpf_prog *xdp_prog;
	unsigned long flags;
	struct work_struct tx_onestep_tstamp;
	struct sk_buff_head tx_skbs;
	struct mutex mm_lock;
};

struct enetc_xdp_data {
	struct xdp_rxq_info rxq;
	struct bpf_prog *prog;
	int xdp_tx_in_flight;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct enetc_ring_stats {
	unsigned int packets;
	unsigned int bytes;
	unsigned int rx_alloc_errs;
	unsigned int xdp_drops;
	unsigned int xdp_tx;
	unsigned int xdp_tx_drops;
	unsigned int xdp_redirect;
	unsigned int xdp_redirect_failures;
	unsigned int recycles;
	unsigned int recycle_failures;
	unsigned int win_drop;
};

struct enetc_tx_swbd;

struct enetc_rx_swbd;

struct enetc_bdr {
	struct device *dev;
	struct net_device *ndev;
	void *bd_base;
	union {
		void *tpir;
		void *rcir;
	};
	u16 index;
	u16 prio;
	int bd_count;
	int next_to_use;
	int next_to_clean;
	union {
		struct enetc_tx_swbd *tx_swbd;
		struct enetc_rx_swbd *rx_swbd;
	};
	union {
		void *tcir;
		int next_to_alloc;
	};
	void *idr;
	int buffer_offset;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct enetc_xdp_data xdp;
	struct enetc_ring_stats stats;
	dma_addr_t bd_dma_base;
	u8 tsd_enable;
	bool ext_en;
	char *tso_headers;
	dma_addr_t tso_headers_dma;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct enetc_int_vector {
	void *rbier;
	void *tbier_base;
	void *ricr1;
	unsigned long tx_rings_map;
	int count_tx_rings;
	u32 rx_ictt;
	u16 comp_cnt;
	bool rx_dim_en;
	bool rx_napi_work;
	long: 64;
	long: 64;
	struct napi_struct napi;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dim rx_dim;
	char name[24];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct enetc_bdr rx_ring;
	struct enetc_bdr tx_ring[0];
};

struct enetc_tx_swbd {
	union {
		struct sk_buff *skb;
		struct xdp_frame *xdp_frame;
	};
	dma_addr_t dma;
	struct page *page;
	u16 page_offset;
	u16 len;
	enum dma_data_direction dir;
	u8 is_dma_page: 1;
	u8 check_wb: 1;
	u8 do_twostep_tstamp: 1;
	u8 is_eof: 1;
	u8 is_xdp_tx: 1;
	u8 is_xdp_redirect: 1;
	u8 qbv_en: 1;
};

struct enetc_rx_swbd {
	dma_addr_t dma;
	struct page *page;
	u16 page_offset;
	enum dma_data_direction dir;
	u16 len;
};

struct enetc_bdr_resource {
	struct device *dev;
	size_t bd_count;
	size_t bd_size;
	void *bd_base;
	dma_addr_t bd_dma_base;
	union {
		struct enetc_tx_swbd *tx_swbd;
		struct enetc_rx_swbd *rx_swbd;
	};
	char *tso_headers;
	dma_addr_t tso_headers_dma;
};

struct enetc_cls_rule {
	struct ethtool_rx_flow_spec fs;
	int used;
};

struct enetc_msg_swbd {
	void *vaddr;
	dma_addr_t dma;
	int size;
};

struct hns3_dbg_dentry_info {
	const char *name;
	struct dentry *dentry;
};

enum hns3_dbg_dentry_type {
	HNS3_DBG_DENTRY_TM = 0,
	HNS3_DBG_DENTRY_TX_BD = 1,
	HNS3_DBG_DENTRY_RX_BD = 2,
	HNS3_DBG_DENTRY_MAC = 3,
	HNS3_DBG_DENTRY_REG = 4,
	HNS3_DBG_DENTRY_QUEUE = 5,
	HNS3_DBG_DENTRY_FD = 6,
	HNS3_DBG_DENTRY_COMMON = 7,
};

struct hns3_dbg_cmd_info {
	const char *name;
	enum hnae3_dbg_cmd cmd;
	enum hns3_dbg_dentry_type dentry;
	u32 buf_len;
	int (*init)(struct hnae3_handle *, unsigned int);
};

struct hns3_dbg_data;

struct hns3_dbg_func {
	enum hnae3_dbg_cmd cmd;
	int (*dbg_dump)(struct hnae3_handle *, char *, int);
	int (*dbg_dump_bd)(struct hns3_dbg_data *, char *, int);
};

struct hns3_dbg_data {
	struct hnae3_handle *handle;
	enum hnae3_dbg_cmd cmd;
	u16 qid;
};

struct hns3_dbg_item {
	char name[32];
	u16 interval;
};

struct hns3_dbg_cap_info {
	const char *name;
	enum HNAE3_DEV_CAP_BITS cap_bit;
};

typedef void (*btf_trace_e1000e_trace_mac_register)(void *, uint32_t);

struct e1000_reg_info {
	u32 ofs;
	char *name;
};

enum e1000_state_t___3 {
	__E1000_TESTING___2 = 0,
	__E1000_RESETTING___2 = 1,
	__E1000_ACCESS_SHARED_RESOURCE = 2,
	__E1000_DOWN___2 = 3,
};

struct trace_event_raw_e1000e_trace_mac_register {
	struct trace_entry ent;
	uint32_t reg;
	char __data[0];
};

union e1000_rx_desc_extended {
	struct {
		__le64 buffer_addr;
		__le64 reserved;
	} read;
	struct {
		struct {
			__le32 mrq;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length;
			__le16 vlan;
		} upper;
	} wb;
};

union e1000_rx_desc_packet_split {
	struct {
		__le64 buffer_addr[4];
	} read;
	struct {
		struct {
			__le32 mrq;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length0;
			__le16 vlan;
		} middle;
		struct {
			__le16 header_status;
			__le16 length[3];
		} upper;
		__le64 reserved;
	} wb;
};

struct my_u0 {
	__le64 a;
	__le64 b;
};

struct my_u1 {
	__le64 a;
	__le64 b;
	__le64 c;
	__le64 d;
};

struct trace_event_data_offsets_e1000e_trace_mac_register {};

struct failover_ops {
	int (*slave_pre_register)(struct net_device *, struct net_device *);
	int (*slave_register)(struct net_device *, struct net_device *);
	int (*slave_pre_unregister)(struct net_device *, struct net_device *);
	int (*slave_unregister)(struct net_device *, struct net_device *);
	int (*slave_link_change)(struct net_device *, struct net_device *);
	int (*slave_name_change)(struct net_device *, struct net_device *);
	rx_handler_result_t (*slave_handle_frame)(struct sk_buff **);
};

struct failover {
	struct list_head list;
	struct net_device __attribute__((btf_type_tag("rcu"))) *failover_dev;
	netdevice_tracker dev_tracker;
	struct failover_ops __attribute__((btf_type_tag("rcu"))) *ops;
};

struct netdev_lag_lower_state_info {
	u8 link_up: 1;
	u8 tx_enabled: 1;
};

struct net_failover_info {
	struct net_device __attribute__((btf_type_tag("rcu"))) *primary_dev;
	struct net_device __attribute__((btf_type_tag("rcu"))) *standby_dev;
	struct rtnl_link_stats64 primary_stats;
	struct rtnl_link_stats64 standby_stats;
	struct rtnl_link_stats64 failover_stats;
	spinlock_t stats_lock;
};

struct class_info {
	int class;
	char *class_name;
};

struct dwc3_keystone {
	struct device *dev;
	void *usbss;
	struct phy *usb3_phy;
};

struct usb_ohci_pdata {
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int no_big_frame_no: 1;
	unsigned int num_ports;
	int (*power_on)(struct platform_device *);
	void (*power_off)(struct platform_device *);
	void (*power_suspend)(struct platform_device *);
};

struct ohci_platform_priv {
	struct clk *clks[4];
	struct reset_control *resets;
};

enum {
	MUSB_CONTROLLER_MHDRC = 0,
	MUSB_CONTROLLER_HDRC = 1,
};

struct musb_pending_work {
	int (*callback)(struct musb *, void *);
	void *data;
	struct list_head node;
};

struct musb_hdrc_platform_data {
	u8 mode;
	const char *clock;
	int (*set_vbus)(struct device *, int);
	u8 power;
	u8 min_power;
	u8 potpgt;
	unsigned int extvbus: 1;
	const struct musb_hdrc_config *config;
	void *board_data;
	const void *platform_ops;
};

typedef void (*btf_trace_i2c_write)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_read)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_reply)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_result)(void *, const struct i2c_adapter *, int, int);

struct trace_event_raw_i2c_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	char __data[0];
};

struct trace_event_raw_i2c_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 nr_msgs;
	__s16 ret;
	char __data[0];
};

struct trace_event_data_offsets_i2c_write {
	u32 buf;
};

struct trace_event_data_offsets_i2c_reply {
	u32 buf;
};

struct trace_event_data_offsets_i2c_read {};

struct trace_event_data_offsets_i2c_result {};

struct i2c_cmd_arg {
	unsigned int cmd;
	void *arg;
};

struct uniphier_fi2c_priv {
	struct completion comp;
	struct i2c_adapter adap;
	void *membase;
	struct clk *clk;
	unsigned int len;
	u8 *buf;
	u32 enabled_irqs;
	int error;
	unsigned int flags;
	unsigned int busy_cnt;
	unsigned int clk_cycle;
	spinlock_t lock;
};

struct hwmon_type_attr_list {
	const u32 *attrs;
	size_t n_attrs;
};

enum hwmon_temp_attributes {
	hwmon_temp_enable = 0,
	hwmon_temp_input = 1,
	hwmon_temp_type = 2,
	hwmon_temp_lcrit = 3,
	hwmon_temp_lcrit_hyst = 4,
	hwmon_temp_min = 5,
	hwmon_temp_min_hyst = 6,
	hwmon_temp_max = 7,
	hwmon_temp_max_hyst = 8,
	hwmon_temp_crit = 9,
	hwmon_temp_crit_hyst = 10,
	hwmon_temp_emergency = 11,
	hwmon_temp_emergency_hyst = 12,
	hwmon_temp_alarm = 13,
	hwmon_temp_lcrit_alarm = 14,
	hwmon_temp_min_alarm = 15,
	hwmon_temp_max_alarm = 16,
	hwmon_temp_crit_alarm = 17,
	hwmon_temp_emergency_alarm = 18,
	hwmon_temp_fault = 19,
	hwmon_temp_offset = 20,
	hwmon_temp_label = 21,
	hwmon_temp_lowest = 22,
	hwmon_temp_highest = 23,
	hwmon_temp_reset_history = 24,
	hwmon_temp_rated_min = 25,
	hwmon_temp_rated_max = 26,
	hwmon_temp_beep = 27,
};

enum hwmon_in_attributes {
	hwmon_in_enable = 0,
	hwmon_in_input = 1,
	hwmon_in_min = 2,
	hwmon_in_max = 3,
	hwmon_in_lcrit = 4,
	hwmon_in_crit = 5,
	hwmon_in_average = 6,
	hwmon_in_lowest = 7,
	hwmon_in_highest = 8,
	hwmon_in_reset_history = 9,
	hwmon_in_label = 10,
	hwmon_in_alarm = 11,
	hwmon_in_min_alarm = 12,
	hwmon_in_max_alarm = 13,
	hwmon_in_lcrit_alarm = 14,
	hwmon_in_crit_alarm = 15,
	hwmon_in_rated_min = 16,
	hwmon_in_rated_max = 17,
	hwmon_in_beep = 18,
};

enum hwmon_curr_attributes {
	hwmon_curr_enable = 0,
	hwmon_curr_input = 1,
	hwmon_curr_min = 2,
	hwmon_curr_max = 3,
	hwmon_curr_lcrit = 4,
	hwmon_curr_crit = 5,
	hwmon_curr_average = 6,
	hwmon_curr_lowest = 7,
	hwmon_curr_highest = 8,
	hwmon_curr_reset_history = 9,
	hwmon_curr_label = 10,
	hwmon_curr_alarm = 11,
	hwmon_curr_min_alarm = 12,
	hwmon_curr_max_alarm = 13,
	hwmon_curr_lcrit_alarm = 14,
	hwmon_curr_crit_alarm = 15,
	hwmon_curr_rated_min = 16,
	hwmon_curr_rated_max = 17,
	hwmon_curr_beep = 18,
};

struct power_supply_hwmon {
	struct power_supply *psy;
	unsigned long *props;
};

struct sbsa_gwdt {
	struct watchdog_device wdd;
	u32 clk;
	int version;
	void *refresh_base;
	void *control_base;
};

struct edac_pci_gen_data {
	int edac_idx;
};

struct tegra186_cpufreq_cpu {
	unsigned int bpmp_cluster_id;
	unsigned int edvd_offset;
};

struct cpu_vhint_data {
	uint32_t ref_clk_hz;
	uint16_t pdiv;
	uint16_t mdiv;
	uint16_t ndiv_max;
	uint16_t ndiv[80];
	uint16_t ndiv_min;
	uint16_t vfloor;
	uint16_t vceil;
	uint16_t vindex_mult;
	uint16_t vindex_div;
	uint16_t reserved[328];
};

struct tegra186_cpufreq_cluster {
	struct cpufreq_frequency_table *table;
	u32 ref_clk_khz;
	u32 div;
};

struct mrq_cpu_vhint_request {
	uint32_t addr;
	uint32_t cluster_id;
};

struct tegra186_cpufreq_data {
	void *regs;
	const struct tegra186_cpufreq_cpu *cpus;
	struct tegra186_cpufreq_cluster clusters[0];
};

enum dw_mci_exynos_type {
	DW_MCI_TYPE_EXYNOS4210 = 0,
	DW_MCI_TYPE_EXYNOS4412 = 1,
	DW_MCI_TYPE_EXYNOS5250 = 2,
	DW_MCI_TYPE_EXYNOS5420 = 3,
	DW_MCI_TYPE_EXYNOS5420_SMU = 4,
	DW_MCI_TYPE_EXYNOS7 = 5,
	DW_MCI_TYPE_EXYNOS7_SMU = 6,
	DW_MCI_TYPE_ARTPEC8 = 7,
};

struct dw_mci_exynos_compatible {
	char *compatible;
	enum dw_mci_exynos_type ctrl_type;
};

struct dw_mci_exynos_priv_data {
	enum dw_mci_exynos_type ctrl_type;
	u8 ciu_div;
	u32 sdr_timing;
	u32 ddr_timing;
	u32 hs400_timing;
	u32 tuned_sample;
	u32 cur_speed;
	u32 dqs_delay;
	u32 saved_dqs_en;
	u32 saved_strobe_ctrl;
};

struct cqhci_slot {
	struct mmc_request *mrq;
	unsigned int flags;
};

struct scpi_chan;

struct scpi_drvinfo {
	u32 protocol_version;
	u32 firmware_version;
	bool is_legacy;
	int num_chans;
	int *commands;
	unsigned long cmd_priority[1];
	atomic_t next_chan;
	struct scpi_ops *scpi_ops;
	struct scpi_chan *channels;
	struct scpi_dvfs_info *dvfs[8];
};

struct scpi_xfer;

struct scpi_chan {
	struct mbox_client cl;
	struct mbox_chan *chan;
	void *tx_payload;
	void *rx_payload;
	struct list_head rx_pending;
	struct list_head xfers_list;
	struct scpi_xfer *xfers;
	spinlock_t rx_lock;
	struct mutex xfers_lock;
	u8 token;
};

struct scpi_xfer {
	u32 slot;
	u32 cmd;
	u32 status;
	const void *tx_buf;
	void *rx_buf;
	unsigned int tx_len;
	unsigned int rx_len;
	struct list_head node;
	struct completion done;
};

enum scpi_drv_cmds {
	CMD_SCPI_CAPABILITIES = 0,
	CMD_GET_CLOCK_INFO = 1,
	CMD_GET_CLOCK_VALUE = 2,
	CMD_SET_CLOCK_VALUE = 3,
	CMD_GET_DVFS = 4,
	CMD_SET_DVFS = 5,
	CMD_GET_DVFS_INFO = 6,
	CMD_SENSOR_CAPABILITIES = 7,
	CMD_SENSOR_INFO = 8,
	CMD_SENSOR_VALUE = 9,
	CMD_SET_DEVICE_PWR_STATE = 10,
	CMD_GET_DEVICE_PWR_STATE = 11,
	CMD_MAX_COUNT = 12,
};

enum scpi_error_codes {
	SCPI_SUCCESS = 0,
	SCPI_ERR_PARAM = 1,
	SCPI_ERR_ALIGN = 2,
	SCPI_ERR_SIZE = 3,
	SCPI_ERR_HANDLER = 4,
	SCPI_ERR_ACCESS = 5,
	SCPI_ERR_RANGE = 6,
	SCPI_ERR_TIMEOUT = 7,
	SCPI_ERR_NOMEM = 8,
	SCPI_ERR_PWRSTATE = 9,
	SCPI_ERR_SUPPORT = 10,
	SCPI_ERR_DEVICE = 11,
	SCPI_ERR_BUSY = 12,
	SCPI_ERR_MAX = 13,
};

struct scpi_shared_mem {
	__le32 command;
	__le32 status;
	u8 payload[0];
};

struct legacy_clk_set_value {
	__le32 rate;
	__le16 id;
	__le16 reserved;
};

struct scp_capabilities {
	__le32 protocol_version;
	__le32 event_version;
	__le32 platform_version;
	__le32 commands[4];
};

struct legacy_scpi_shared_mem {
	__le32 status;
	u8 payload[0];
};

struct clk_get_info {
	__le16 id;
	__le16 flags;
	__le32 min_rate;
	__le32 max_rate;
	u8 name[20];
};

struct clk_set_value {
	__le16 id;
	__le16 reserved;
	__le32 rate;
};

struct dvfs_set {
	u8 domain;
	u8 index;
};

struct dvfs_info {
	u8 domain;
	u8 opp_count;
	__le16 latency;
	struct {
		__le32 freq;
		__le32 m_volt;
	} opps[16];
};

struct _scpi_sensor_info {
	__le16 sensor_id;
	u8 class;
	u8 trigger_type;
	char name[20];
};

struct dev_pstate_set {
	__le16 dev_id;
	u8 pstate;
} __attribute__((packed));

struct efi {
	const efi_runtime_services_t *runtime;
	unsigned int runtime_version;
	unsigned int runtime_supported_mask;
	unsigned long acpi;
	unsigned long acpi20;
	unsigned long smbios;
	unsigned long smbios3;
	unsigned long esrt;
	unsigned long tpm_log;
	unsigned long tpm_final_log;
	unsigned long mokvar_table;
	unsigned long coco_secret;
	unsigned long unaccepted;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_info_t *query_variable_info;
	efi_query_variable_info_t *query_variable_info_nonblocking;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	struct efi_memory_map memmap;
	unsigned long flags;
};

typedef efi_status_t efi_query_variable_store_t(u32, unsigned long, bool);

struct efivar_operations {
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_store_t *query_variable_store;
	efi_query_variable_info_t *query_variable_info;
};

struct efivars {
	struct kset *kset;
	const struct efivar_operations *ops;
};

struct debugfs_blob_wrapper {
	void *data;
	unsigned long size;
};

typedef struct {
	efi_guid_t guid;
	unsigned long *ptr;
	const char name[16];
} efi_config_table_type_t;

typedef struct {
	efi_guid_t guid;
	u32 table;
} efi_config_table_32_t;

typedef union {
	struct {
		efi_guid_t guid;
		void *table;
	};
	efi_config_table_32_t mixed_mode;
} efi_config_table_t;

typedef struct {
	efi_guid_t guid;
	u64 table;
} efi_config_table_64_t;

struct linux_efi_random_seed {
	u32 size;
	u8 bits[0];
};

struct psci_operations {
	u32 (*get_version)();
	int (*cpu_suspend)(u32, unsigned long);
	int (*cpu_off)(u32);
	int (*cpu_on)(unsigned long, unsigned long);
	int (*migrate)(unsigned long);
	int (*affinity_info)(unsigned long, unsigned long);
	int (*migrate_info_type)();
};

typedef unsigned long psci_fn(unsigned long, unsigned long, unsigned long, unsigned long);

typedef int (*psci_initcall_t)(const struct device_node *);

struct hid_bpf_ops {
	struct hid_report * (*hid_get_report)(struct hid_report_enum *, const u8 *);
	int (*hid_hw_raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, enum hid_report_type, enum hid_class_request);
	struct module *owner;
	struct bus_type *bus_type;
};

enum hid_bpf_prog_type {
	HID_BPF_PROG_TYPE_UNDEF = -1,
	HID_BPF_PROG_TYPE_DEVICE_EVENT = 0,
	HID_BPF_PROG_TYPE_RDESC_FIXUP = 1,
	HID_BPF_PROG_TYPE_MAX = 2,
};

enum hid_bpf_attach_flags {
	HID_BPF_FLAG_NONE = 0,
	HID_BPF_FLAG_INSERT_HEAD = 1,
	HID_BPF_FLAG_MAX = 2,
};

struct hid_bpf_ctx {
	__u32 index;
	const struct hid_device *hid;
	__u32 allocated_size;
	enum hid_report_type report_type;
	union {
		__s32 retval;
		__s32 size;
	};
};

struct hid_bpf_ctx_kern {
	struct hid_bpf_ctx ctx;
	u8 *data;
};

enum ec_console_read_subcmd {
	CONSOLE_READ_NEXT = 0,
	CONSOLE_READ_RECENT = 1,
};

struct cros_ec_debugfs {
	struct cros_ec_dev *ec;
	struct dentry *dir;
	struct circ_buf log_buffer;
	struct cros_ec_command *read_msg;
	struct mutex log_mutex;
	struct delayed_work log_poll_work;
	struct debugfs_blob_wrapper panicinfo_blob;
	struct notifier_block notifier_panic;
};

struct ec_params_console_read_v1 {
	uint8_t subcmd;
};

struct ap_reset_log_entry {
	uint16_t reset_cause;
	uint16_t reserved;
	uint32_t reset_time_ms;
};

struct ec_response_uptime_info {
	uint32_t time_since_ec_boot_ms;
	uint32_t ap_resets_since_ec_boot;
	uint32_t ec_reset_flags;
	struct ap_reset_log_entry recent_ap_reset[4];
};

struct cros_ec_platform {
	const char *ec_name;
	u16 cmd_offset;
};

struct hi3660_chan_info {
	unsigned int dst_irq;
	unsigned int ack_irq;
};

struct hi3660_mbox {
	struct device *dev;
	void *base;
	struct mbox_chan chan[32];
	struct hi3660_chan_info mchan[32];
	struct mbox_controller controller;
};

struct qcom_glink_pipe;

struct qcom_glink {
	struct device *dev;
	struct qcom_glink_pipe *rx_pipe;
	struct qcom_glink_pipe *tx_pipe;
	struct work_struct rx_work;
	spinlock_t rx_lock;
	struct list_head rx_queue;
	spinlock_t tx_lock;
	spinlock_t idr_lock;
	struct idr lcids;
	struct idr rcids;
	unsigned long features;
	bool intentless;
	wait_queue_head_t tx_avail_notify;
	bool sent_read_notify;
	bool abort_tx;
};

struct qcom_glink_pipe {
	size_t length;
	size_t (*avail)(struct qcom_glink_pipe *);
	void (*peek)(struct qcom_glink_pipe *, void *, unsigned int, size_t);
	void (*advance)(struct qcom_glink_pipe *, size_t);
	void (*write)(struct qcom_glink_pipe *, const void *, size_t, const void *, size_t);
	void (*kick)(struct qcom_glink_pipe *);
};

struct glink_msg {
	__le16 cmd;
	__le16 param1;
	__le32 param2;
	u8 data[0];
};

struct glink_defer_cmd {
	struct list_head node;
	struct glink_msg msg;
	u8 data[0];
};

struct glink_core_rx_intent;

struct glink_channel {
	struct rpmsg_endpoint ept;
	struct rpmsg_device *rpdev;
	struct qcom_glink *glink;
	struct kref refcount;
	spinlock_t recv_lock;
	char *name;
	unsigned int lcid;
	unsigned int rcid;
	spinlock_t intent_lock;
	struct idr liids;
	struct idr riids;
	struct work_struct intent_work;
	struct list_head done_intents;
	struct glink_core_rx_intent *buf;
	int buf_offset;
	int buf_size;
	struct completion open_ack;
	struct completion open_req;
	struct mutex intent_req_lock;
	int intent_req_result;
	bool intent_received;
	wait_queue_head_t intent_req_wq;
};

struct glink_core_rx_intent {
	void *data;
	u32 id;
	size_t size;
	bool reuse;
	bool in_use;
	u32 offset;
	struct list_head node;
};

struct intent_pair {
	__le32 size;
	__le32 iid;
};

struct command {
	__le16 id;
	__le16 lcid;
	__le32 count;
	__le32 size;
	__le32 liid;
};

enum fpga_mgr_states {
	FPGA_MGR_STATE_UNKNOWN = 0,
	FPGA_MGR_STATE_POWER_OFF = 1,
	FPGA_MGR_STATE_POWER_UP = 2,
	FPGA_MGR_STATE_RESET = 3,
	FPGA_MGR_STATE_FIRMWARE_REQ = 4,
	FPGA_MGR_STATE_FIRMWARE_REQ_ERR = 5,
	FPGA_MGR_STATE_PARSE_HEADER = 6,
	FPGA_MGR_STATE_PARSE_HEADER_ERR = 7,
	FPGA_MGR_STATE_WRITE_INIT = 8,
	FPGA_MGR_STATE_WRITE_INIT_ERR = 9,
	FPGA_MGR_STATE_WRITE = 10,
	FPGA_MGR_STATE_WRITE_ERR = 11,
	FPGA_MGR_STATE_WRITE_COMPLETE = 12,
	FPGA_MGR_STATE_WRITE_COMPLETE_ERR = 13,
	FPGA_MGR_STATE_OPERATING = 14,
};

struct fpga_compat_id;

struct fpga_manager_ops;

struct fpga_manager {
	const char *name;
	struct device dev;
	struct mutex ref_mutex;
	enum fpga_mgr_states state;
	struct fpga_compat_id *compat_id;
	const struct fpga_manager_ops *mops;
	void *priv;
};

struct fpga_compat_id {
	u64 id_h;
	u64 id_l;
};

struct fpga_image_info;

struct fpga_manager_ops {
	size_t initial_header_size;
	bool skip_header;
	enum fpga_mgr_states (*state)(struct fpga_manager *);
	u64 (*status)(struct fpga_manager *);
	int (*parse_header)(struct fpga_manager *, struct fpga_image_info *, const char *, size_t);
	int (*write_init)(struct fpga_manager *, struct fpga_image_info *, const char *, size_t);
	int (*write)(struct fpga_manager *, const char *, size_t);
	int (*write_sg)(struct fpga_manager *, struct sg_table *);
	int (*write_complete)(struct fpga_manager *, struct fpga_image_info *);
	void (*fpga_remove)(struct fpga_manager *);
	const struct attribute_group **groups;
};

struct fpga_image_info {
	u32 flags;
	u32 enable_timeout_us;
	u32 disable_timeout_us;
	u32 config_complete_timeout_us;
	char *firmware_name;
	struct sg_table *sgt;
	const char *buf;
	size_t count;
	size_t header_size;
	size_t data_size;
	int region_id;
	struct device *dev;
	struct device_node *overlay;
};

struct fpga_manager_info {
	const char *name;
	struct fpga_compat_id *compat_id;
	const struct fpga_manager_ops *mops;
	void *priv;
};

struct fpga_mgr_devres {
	struct fpga_manager *mgr;
};

typedef void (*btf_trace_icc_set_bw)(void *, struct icc_path *, struct icc_node *, int, u32, u32);

struct icc_req {
	struct hlist_node req_node;
	struct icc_node *node;
	struct device *dev;
	bool enabled;
	u32 tag;
	u32 avg_bw;
	u32 peak_bw;
};

struct icc_path {
	const char *name;
	size_t num_nodes;
	struct icc_req reqs[0];
};

typedef void (*btf_trace_icc_set_bw_end)(void *, struct icc_path *, int);

struct trace_event_raw_icc_set_bw {
	struct trace_entry ent;
	u32 __data_loc_path_name;
	u32 __data_loc_dev;
	u32 __data_loc_node_name;
	u32 avg_bw;
	u32 peak_bw;
	u32 node_avg_bw;
	u32 node_peak_bw;
	char __data[0];
};

struct trace_event_raw_icc_set_bw_end {
	struct trace_entry ent;
	u32 __data_loc_path_name;
	u32 __data_loc_dev;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_icc_set_bw {
	u32 path_name;
	u32 dev;
	u32 node_name;
};

struct trace_event_data_offsets_icc_set_bw_end {
	u32 path_name;
	u32 dev;
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	void *__ctx[0];
};

struct csum_state {
	__wsum csum;
	size_t off;
};

typedef size_t (*iov_ustep_f)(void __attribute__((btf_type_tag("user"))) *, size_t, size_t, void *, void *);

typedef size_t (*iov_step_f)(void *, size_t, size_t, void *, void *);

struct compat_cmsghdr {
	compat_size_t cmsg_len;
	compat_int_t cmsg_level;
	compat_int_t cmsg_type;
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	ETHTOOL_MSG_FEC_GET_REPLY = 30,
	ETHTOOL_MSG_FEC_NTF = 31,
	ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY = 32,
	ETHTOOL_MSG_STATS_GET_REPLY = 33,
	ETHTOOL_MSG_PHC_VCLOCKS_GET_REPLY = 34,
	ETHTOOL_MSG_MODULE_GET_REPLY = 35,
	ETHTOOL_MSG_MODULE_NTF = 36,
	ETHTOOL_MSG_PSE_GET_REPLY = 37,
	ETHTOOL_MSG_RSS_GET_REPLY = 38,
	ETHTOOL_MSG_PLCA_GET_CFG_REPLY = 39,
	ETHTOOL_MSG_PLCA_GET_STATUS_REPLY = 40,
	ETHTOOL_MSG_PLCA_NTF = 41,
	ETHTOOL_MSG_MM_GET_REPLY = 42,
	ETHTOOL_MSG_MM_NTF = 43,
	__ETHTOOL_MSG_KERNEL_CNT = 44,
	ETHTOOL_MSG_KERNEL_MAX = 43,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	unsigned long ifindex;
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = -1,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	union {
		__be32 imsf_slist[1];
		struct {
			struct {} __empty_imsf_slist_flex;
			__be32 imsf_slist_flex[0];
		};
	};
};

struct group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		};
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		};
	};
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

enum devlink_linecard_state {
	DEVLINK_LINECARD_STATE_UNSPEC = 0,
	DEVLINK_LINECARD_STATE_UNPROVISIONED = 1,
	DEVLINK_LINECARD_STATE_UNPROVISIONING = 2,
	DEVLINK_LINECARD_STATE_PROVISIONING = 3,
	DEVLINK_LINECARD_STATE_PROVISIONING_FAILED = 4,
	DEVLINK_LINECARD_STATE_PROVISIONED = 5,
	DEVLINK_LINECARD_STATE_ACTIVE = 6,
	__DEVLINK_LINECARD_STATE_MAX = 7,
	DEVLINK_LINECARD_STATE_MAX = 6,
};

struct devlink_linecard_ops;

struct devlink_linecard_type;

struct devlink_linecard {
	struct list_head list;
	struct devlink *devlink;
	unsigned int index;
	const struct devlink_linecard_ops *ops;
	void *priv;
	enum devlink_linecard_state state;
	struct mutex state_lock;
	const char *type;
	struct devlink_linecard_type *types;
	unsigned int types_count;
	u32 rel_index;
};

struct devlink_linecard_ops {
	int (*provision)(struct devlink_linecard *, void *, const char *, const void *, struct netlink_ext_ack *);
	int (*unprovision)(struct devlink_linecard *, void *, struct netlink_ext_ack *);
	bool (*same_provision)(struct devlink_linecard *, void *, const char *, const void *);
	unsigned int (*types_count)(struct devlink_linecard *, void *);
	void (*types_get)(struct devlink_linecard *, void *, unsigned int, const char **, const void **);
};

struct devlink_linecard_type {
	const char *type;
	const void *priv;
};

struct crypto_ahash {
	bool using_shash;
	unsigned int statesize;
	unsigned int reqsize;
	struct crypto_tfm base;
};

typedef unsigned long cycles_t;

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long (*fill)(void *, unsigned long);
	long inbufCount;
	long inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

union efi_device_path_from_text_protocol {
	struct {
		efi_device_path_protocol_t * (*convert_text_to_device_node)(const efi_char16_t *);
		efi_device_path_protocol_t * (*convert_text_to_device_path)(const efi_char16_t *);
	};
	struct {
		u32 convert_text_to_device_node;
		u32 convert_text_to_device_path;
	} mixed_mode;
};

typedef union efi_device_path_from_text_protocol efi_device_path_from_text_protocol_t;

struct efi_file_path_dev_path {
	struct efi_generic_dev_path header;
	efi_char16_t filename[0];
};

union efi_file_protocol;

typedef union efi_file_protocol efi_file_protocol_t;

union efi_file_protocol {
	struct {
		u64 revision;
		efi_status_t (*open)(efi_file_protocol_t *, efi_file_protocol_t **, efi_char16_t *, u64, u64);
		efi_status_t (*close)(efi_file_protocol_t *);
		efi_status_t (*delete)(efi_file_protocol_t *);
		efi_status_t (*read)(efi_file_protocol_t *, unsigned long *, void *);
		efi_status_t (*write)(efi_file_protocol_t *, unsigned long, void *);
		efi_status_t (*get_position)(efi_file_protocol_t *, u64 *);
		efi_status_t (*set_position)(efi_file_protocol_t *, u64);
		efi_status_t (*get_info)(efi_file_protocol_t *, efi_guid_t *, unsigned long *, void *);
		efi_status_t (*set_info)(efi_file_protocol_t *, efi_guid_t *, unsigned long, void *);
		efi_status_t (*flush)(efi_file_protocol_t *);
	};
	struct {
		u64 revision;
		u32 open;
		u32 close;
		u32 delete;
		u32 read;
		u32 write;
		u32 get_position;
		u32 set_position;
		u32 get_info;
		u32 set_info;
		u32 flush;
	} mixed_mode;
};

typedef struct {
	u64 size;
	u64 file_size;
	u64 phys_size;
	efi_time_t create_time;
	efi_time_t last_access_time;
	efi_time_t modification_time;
	__u64 attribute;
	efi_char16_t filename[0];
} efi_file_info_t;

struct finfo {
	efi_file_info_t info;
	efi_char16_t filename[256];
};

union efi_simple_file_system_protocol;

typedef union efi_simple_file_system_protocol efi_simple_file_system_protocol_t;

union efi_simple_file_system_protocol {
	struct {
		u64 revision;
		efi_status_t (*open_volume)(efi_simple_file_system_protocol_t *, efi_file_protocol_t **);
	};
	struct {
		u64 revision;
		u32 open_volume;
	} mixed_mode;
};

struct start_info {
	char magic[32];
	unsigned long nr_pages;
	unsigned long shared_info;
	uint32_t flags;
	xen_pfn_t store_mfn;
	uint32_t store_evtchn;
	union {
		struct {
			xen_pfn_t mfn;
			uint32_t evtchn;
		} domU;
		struct {
			uint32_t info_off;
			uint32_t info_size;
		} dom0;
	} console;
	unsigned long pt_base;
	unsigned long nr_pt_frames;
	unsigned long mfn_list;
	unsigned long mod_start;
	unsigned long mod_len;
	int8_t cmd_line[1024];
	unsigned long first_p2m_pfn;
	unsigned long nr_p2m_frames;
};

struct xen_memory_region {
	unsigned long start_pfn;
	unsigned long n_pfns;
};

struct xenpf_settime32 {
	uint32_t secs;
	uint32_t nsecs;
	uint64_t system_time;
};

struct xenpf_settime64 {
	uint64_t secs;
	uint32_t nsecs;
	uint32_t mbz;
	uint64_t system_time;
};

struct xenpf_add_memtype {
	xen_pfn_t mfn;
	uint64_t nr_mfns;
	uint32_t type;
	uint32_t handle;
	uint32_t reg;
};

struct xenpf_del_memtype {
	uint32_t handle;
	uint32_t reg;
};

struct xenpf_read_memtype {
	uint32_t reg;
	xen_pfn_t mfn;
	uint64_t nr_mfns;
	uint32_t type;
};

typedef struct {
	union {
		void *p;
		uint64_t q;
	};
} __guest_handle_void;

struct xenpf_microcode_update {
	__guest_handle_void data;
	uint32_t length;
};

struct xenpf_platform_quirk {
	uint32_t quirk_id;
};

struct xenpf_efi_time {
	uint16_t year;
	uint8_t month;
	uint8_t day;
	uint8_t hour;
	uint8_t min;
	uint8_t sec;
	uint32_t ns;
	int16_t tz;
	uint8_t daylight;
};

struct xenpf_efi_guid {
	uint32_t data1;
	uint16_t data2;
	uint16_t data3;
	uint8_t data4[8];
};

struct xenpf_efi_runtime_call {
	uint32_t function;
	uint32_t misc;
	xen_ulong_t status;
	union {
		struct {
			struct xenpf_efi_time time;
			uint32_t resolution;
			uint32_t accuracy;
		} get_time;
		struct xenpf_efi_time set_time;
		struct xenpf_efi_time get_wakeup_time;
		struct xenpf_efi_time set_wakeup_time;
		struct {
			__guest_handle_void name;
			xen_ulong_t size;
			__guest_handle_void data;
			struct xenpf_efi_guid vendor_guid;
		} get_variable;
		struct {
			__guest_handle_void name;
			xen_ulong_t size;
			__guest_handle_void data;
			struct xenpf_efi_guid vendor_guid;
		} set_variable;
		struct {
			xen_ulong_t size;
			__guest_handle_void name;
			struct xenpf_efi_guid vendor_guid;
		} get_next_variable_name;
		struct {
			uint32_t attr;
			uint64_t max_store_size;
			uint64_t remain_store_size;
			uint64_t max_size;
		} query_variable_info;
		struct {
			__guest_handle_void capsule_header_array;
			xen_ulong_t capsule_count;
			uint64_t max_capsule_size;
			uint32_t reset_type;
		} query_capsule_capabilities;
		struct {
			__guest_handle_void capsule_header_array;
			xen_ulong_t capsule_count;
			uint64_t sg_list;
		} update_capsule;
	} u;
};

typedef struct {
	union {
		unsigned char *p;
		uint64_t q;
	};
} __guest_handle_uchar;

union xenpf_efi_info {
	uint32_t version;
	struct {
		uint64_t addr;
		uint32_t nent;
	} cfg;
	struct {
		uint32_t revision;
		uint32_t bufsz;
		__guest_handle_void name;
	} vendor;
	struct {
		uint64_t addr;
		uint64_t size;
		uint64_t attr;
		uint32_t type;
	} mem;
};

struct xenpf_firmware_info {
	uint32_t type;
	uint32_t index;
	union {
		struct {
			uint8_t device;
			uint8_t version;
			uint16_t interface_support;
			uint16_t legacy_max_cylinder;
			uint8_t legacy_max_head;
			uint8_t legacy_sectors_per_track;
			__guest_handle_void edd_params;
		} disk_info;
		struct {
			uint8_t device;
			uint32_t mbr_signature;
		} disk_mbr_signature;
		struct {
			uint8_t capabilities;
			uint8_t edid_transfer_time;
			__guest_handle_uchar edid;
		} vbeddc_info;
		union xenpf_efi_info efi_info;
		uint8_t kbd_shift_flags;
	} u;
};

struct xenpf_enter_acpi_sleep {
	uint16_t val_a;
	uint16_t val_b;
	uint32_t sleep_state;
	uint32_t flags;
};

struct xenpf_change_freq {
	uint32_t flags;
	uint32_t cpu;
	uint64_t freq;
};

struct xenpf_getidletime {
	__guest_handle_uchar cpumap_bitmap;
	uint32_t cpumap_nr_cpus;
	__guest_handle_uint64_t idletime;
	uint64_t now;
};

struct xen_processor_flags {
	uint32_t bm_control: 1;
	uint32_t bm_check: 1;
	uint32_t has_cst: 1;
	uint32_t power_setup_done: 1;
	uint32_t bm_rld_set: 1;
};

struct xen_processor_cx;

typedef struct {
	union {
		struct xen_processor_cx *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_cx;

struct xen_processor_power {
	uint32_t count;
	struct xen_processor_flags flags;
	__guest_handle_xen_processor_cx states;
};

struct xen_pct_register {
	uint8_t descriptor;
	uint16_t length;
	uint8_t space_id;
	uint8_t bit_width;
	uint8_t bit_offset;
	uint8_t reserved;
	uint64_t address;
};

struct xen_processor_px;

typedef struct {
	union {
		struct xen_processor_px *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_px;

struct xen_psd_package {
	uint64_t num_entries;
	uint64_t revision;
	uint64_t domain;
	uint64_t coord_type;
	uint64_t num_processors;
};

struct xen_processor_performance {
	uint32_t flags;
	uint32_t platform_limit;
	struct xen_pct_register control_register;
	struct xen_pct_register status_register;
	uint32_t state_count;
	__guest_handle_xen_processor_px states;
	struct xen_psd_package domain_info;
	uint32_t shared_type;
};

typedef struct {
	union {
		uint32_t *p;
		uint64_t q;
	};
} __guest_handle_uint32_t;

struct xenpf_set_processor_pminfo {
	uint32_t id;
	uint32_t type;
	union {
		struct xen_processor_power power;
		struct xen_processor_performance perf;
		__guest_handle_uint32_t pdc;
	};
};

struct xenpf_pcpuinfo {
	uint32_t xen_cpuid;
	uint32_t max_present;
	uint32_t flags;
	uint32_t apic_id;
	uint32_t acpi_id;
};

struct xenpf_cpu_ol {
	uint32_t cpuid;
};

struct xenpf_cpu_hotadd {
	uint32_t apic_id;
	uint32_t acpi_id;
	uint32_t pxm;
};

struct xenpf_mem_hotadd {
	uint64_t spfn;
	uint64_t epfn;
	uint32_t pxm;
	uint32_t flags;
};

struct xenpf_core_parking {
	uint32_t type;
	uint32_t idle_nums;
};

typedef struct {
	union {
		char *p;
		uint64_t q;
	};
} __guest_handle_char;

struct xenpf_symdata {
	uint32_t namelen;
	uint32_t symnum;
	__guest_handle_char name;
	uint64_t address;
	char type;
};

struct dom0_vga_console_info {
	uint8_t video_type;
	union {
		struct {
			uint16_t font_height;
			uint16_t cursor_x;
			uint16_t cursor_y;
			uint16_t rows;
			uint16_t columns;
		} text_mode_3;
		struct {
			uint16_t width;
			uint16_t height;
			uint16_t bytes_per_line;
			uint16_t bits_per_pixel;
			uint32_t lfb_base;
			uint32_t lfb_size;
			uint8_t red_pos;
			uint8_t red_size;
			uint8_t green_pos;
			uint8_t green_size;
			uint8_t blue_pos;
			uint8_t blue_size;
			uint8_t rsvd_pos;
			uint8_t rsvd_size;
			uint32_t gbl_caps;
			uint16_t mode_attrs;
			uint16_t pad;
			uint32_t ext_lfb_base;
		} vesa_lfb;
	} u;
};

struct xen_platform_op {
	uint32_t cmd;
	uint32_t interface_version;
	union {
		struct xenpf_settime32 settime32;
		struct xenpf_settime64 settime64;
		struct xenpf_add_memtype add_memtype;
		struct xenpf_del_memtype del_memtype;
		struct xenpf_read_memtype read_memtype;
		struct xenpf_microcode_update microcode;
		struct xenpf_platform_quirk platform_quirk;
		struct xenpf_efi_runtime_call efi_runtime_call;
		struct xenpf_firmware_info firmware_info;
		struct xenpf_enter_acpi_sleep enter_acpi_sleep;
		struct xenpf_change_freq change_freq;
		struct xenpf_getidletime getidletime;
		struct xenpf_set_processor_pminfo set_pminfo;
		struct xenpf_pcpuinfo pcpu_info;
		struct xenpf_cpu_ol cpu_ol;
		struct xenpf_cpu_hotadd cpu_add;
		struct xenpf_mem_hotadd mem_add;
		struct xenpf_core_parking core_parking;
		struct xenpf_symdata symdata;
		struct dom0_vga_console_info dom0_console;
		uint8_t pad[128];
	} u;
};

struct xen_power_register {
	uint32_t space_id;
	uint32_t bit_width;
	uint32_t bit_offset;
	uint32_t access_size;
	uint64_t address;
};

struct xen_processor_csd;

typedef struct {
	union {
		struct xen_processor_csd *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_csd;

struct xen_processor_cx {
	struct xen_power_register reg;
	uint8_t type;
	uint32_t latency;
	uint32_t power;
	uint32_t dpcnt;
	__guest_handle_xen_processor_csd dp;
};

struct xen_processor_csd {
	uint32_t domain;
	uint32_t coord_type;
	uint32_t num;
};

struct xen_processor_px {
	uint64_t core_frequency;
	uint64_t power;
	uint64_t transition_latency;
	uint64_t bus_master_latency;
	uint64_t control;
	uint64_t status;
};

struct sched_shutdown {
	unsigned int reason;
};

struct xen_hvm_param {
	domid_t domid;
	uint32_t index;
	uint64_t value;
};

struct vcpu_register_vcpu_info {
	uint64_t mfn;
	uint32_t offset;
	uint32_t rsvd;
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

struct rt_wake_q_head {
	struct wake_q_head head;
	struct task_struct *rtlock_task;
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, unsigned long);

typedef void (*btf_trace_module_put)(void *, struct module *, unsigned long);

typedef void (*btf_trace_module_request)(void *, char *, bool, unsigned long);

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct mod_tree_root {
	struct latch_tree_root root;
	unsigned long addr_min;
	unsigned long addr_max;
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const s32 *crcs;
	enum mod_license license;
};

enum fail_dup_mod_reason {
	FAIL_DUP_MOD_BECOMING = 0,
	FAIL_DUP_MOD_LOAD = 1,
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	unsigned long ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	unsigned long ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct mod_initfree {
	struct llist_node node;
	void *init_text;
	void *init_data;
	void *init_rodata;
};

struct idempotent {
	const void *cookie;
	struct hlist_node entry;
	struct completion complete;
	int ret;
};

struct trace_event_data_offsets_module_load {
	u32 name;
};

struct trace_event_data_offsets_module_free {
	u32 name;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
};

struct trace_event_data_offsets_module_request {
	u32 name;
};

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const s32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct ftrace_func_command {
	struct list_head list;
	char *name;
	int (*func)(struct trace_array *, struct ftrace_hash *, char *, char *, char *, int);
};

struct ftrace_probe_ops {
	void (*func)(unsigned long, unsigned long, struct trace_array *, struct ftrace_probe_ops *, void *);
	int (*init)(struct ftrace_probe_ops *, struct trace_array *, unsigned long, void *, void **);
	void (*free)(struct ftrace_probe_ops *, struct trace_array *, unsigned long, void *);
	int (*print)(struct seq_file *, unsigned long, struct ftrace_probe_ops *, void *);
};

enum {
	FTRACE_OPS_FL_ENABLED = 1,
	FTRACE_OPS_FL_DYNAMIC = 2,
	FTRACE_OPS_FL_SAVE_REGS = 4,
	FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED = 8,
	FTRACE_OPS_FL_RECURSION = 16,
	FTRACE_OPS_FL_STUB = 32,
	FTRACE_OPS_FL_INITIALIZED = 64,
	FTRACE_OPS_FL_DELETED = 128,
	FTRACE_OPS_FL_ADDING = 256,
	FTRACE_OPS_FL_REMOVING = 512,
	FTRACE_OPS_FL_MODIFYING = 1024,
	FTRACE_OPS_FL_ALLOC_TRAMP = 2048,
	FTRACE_OPS_FL_IPMODIFY = 4096,
	FTRACE_OPS_FL_PID = 8192,
	FTRACE_OPS_FL_RCU = 16384,
	FTRACE_OPS_FL_TRACE_ARRAY = 32768,
	FTRACE_OPS_FL_PERMANENT = 65536,
	FTRACE_OPS_FL_DIRECT = 131072,
};

enum {
	TRACE_CTX_NMI = 0,
	TRACE_CTX_IRQ = 1,
	TRACE_CTX_SOFTIRQ = 2,
	TRACE_CTX_NORMAL = 3,
	TRACE_CTX_TRANSITION = 4,
};

enum {
	TRACE_FUNC_NO_OPTS = 0,
	TRACE_FUNC_OPT_STACK = 1,
	TRACE_FUNC_OPT_NO_REPEATS = 2,
	TRACE_FUNC_OPT_HIGHEST_BIT = 4,
};

typedef int (*ftrace_mapper_func)(void *);

enum bpf_iter_feature {
	BPF_ITER_RESCHED = 1,
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	long: 0;
	u8 target_private[0];
};

typedef u64 (*btf_bpf_for_each_map_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_loop)(u32, void *, void *, u64);

struct bpf_iter_num {
	__u64 __opaque[1];
};

struct bpf_iter_num_kern {
	int cur;
	int end;
};

struct bpf_prog_offload_ops;

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

enum xdp_rx_metadata {
	XDP_METADATA_KFUNC_RX_TIMESTAMP = 0,
	XDP_METADATA_KFUNC_RX_HASH = 1,
	MAX_XDP_METADATA_KFUNC = 2,
};

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

typedef struct ns_common *ns_get_path_helper_t(void *);

struct bpf_prog_info;

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
	__u64 recursion_misses;
	__u32 verified_insns;
	__u32 attach_btf_obj_id;
	__u32 attach_btf_id;
};

struct bpf_map_info;

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
	__u64 map_extra;
};

struct list_lru_memcg {
	struct callback_head rcu;
	struct list_lru_one node[0];
};

struct list_lru_memcg_table {
	struct list_lru_memcg *mlru;
	struct mem_cgroup *memcg;
};

struct hugetlb_cgroup_per_node;

struct hugetlb_cgroup {
	struct cgroup_subsys_state css;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct page_counter hugepage[4];
	struct page_counter rsvd_hugepage[4];
	atomic_long_t events[4];
	atomic_long_t events_local[4];
	struct cgroup_file events_file[4];
	struct cgroup_file events_local_file[4];
	struct hugetlb_cgroup_per_node *nodeinfo[0];
};

struct hugetlb_cgroup_per_node {
	unsigned long usage[4];
};

enum hugetlb_memory_event {
	HUGETLB_MAX = 0,
	HUGETLB_NR_MEMORY_EVENTS = 1,
};

enum {
	RES_USAGE___2 = 0,
	RES_RSVD_USAGE = 1,
	RES_LIMIT___2 = 2,
	RES_RSVD_LIMIT = 3,
	RES_MAX_USAGE___2 = 4,
	RES_RSVD_MAX_USAGE = 5,
	RES_FAILCNT___2 = 6,
	RES_RSVD_FAILCNT = 7,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
	__CFTYPE_ADDED = 262144,
};

struct file_region {
	struct list_head link;
	long from;
	long to;
	struct page_counter *reservation_counter;
	struct cgroup_subsys_state *css;
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct statfs {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__kernel_long_t f_blocks;
	__kernel_long_t f_bfree;
	__kernel_long_t f_bavail;
	__kernel_long_t f_files;
	__kernel_long_t f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct statfs64 {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

typedef int __kernel_daddr_t;

struct ustat {
	__kernel_daddr_t f_tfree;
	unsigned long f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

typedef __kernel_fsid_t compat_fsid_t;

struct compat_statfs {
	int f_type;
	int f_bsize;
	int f_blocks;
	int f_bfree;
	int f_bavail;
	int f_files;
	int f_ffree;
	compat_fsid_t f_fsid;
	int f_namelen;
	int f_frsize;
	int f_flags;
	int f_spare[4];
};

typedef s32 compat_daddr_t;

struct compat_ustat {
	compat_daddr_t f_tfree;
	compat_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct ext2_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_reserved1;
		} linux1;
		struct {
			__le32 h_i_translator;
		} hurd1;
		struct {
			__le32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl;
	__le32 i_dir_acl;
	__le32 i_faddr;
	union {
		struct {
			__u8 l_i_frag;
			__u8 l_i_fsize;
			__u16 i_pad1;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__u32 l_i_reserved2;
		} linux2;
		struct {
			__u8 h_i_frag;
			__u8 h_i_fsize;
			__le16 h_i_mode_high;
			__le16 h_i_uid_high;
			__le16 h_i_gid_high;
			__le32 h_i_author;
		} hurd2;
		struct {
			__u8 m_i_frag;
			__u8 m_i_fsize;
			__u16 m_pad1;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
};

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

struct rsa_asn1_template {
	const char *name;
	const u8 *data;
	size_t size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct rsa_asn1_template *digest_info;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	struct akcipher_request child_req;
};

enum OID {
	OID_id_dsa = 0,
	OID_id_ecPublicKey = 1,
	OID_id_prime192v1 = 2,
	OID_id_prime256v1 = 3,
	OID_id_ecdsa_with_sha224 = 4,
	OID_id_ecdsa_with_sha256 = 5,
	OID_id_ecdsa_with_sha384 = 6,
	OID_id_ecdsa_with_sha512 = 7,
	OID_rsaEncryption = 8,
	OID_sha256WithRSAEncryption = 9,
	OID_sha384WithRSAEncryption = 10,
	OID_sha512WithRSAEncryption = 11,
	OID_sha224WithRSAEncryption = 12,
	OID_data = 13,
	OID_signed_data = 14,
	OID_email_address = 15,
	OID_contentType = 16,
	OID_messageDigest = 17,
	OID_signingTime = 18,
	OID_smimeCapabilites = 19,
	OID_smimeAuthenticatedAttrs = 20,
	OID_mskrb5 = 21,
	OID_krb5 = 22,
	OID_krb5u2u = 23,
	OID_msIndirectData = 24,
	OID_msStatementType = 25,
	OID_msSpOpusInfo = 26,
	OID_msPeImageDataObjId = 27,
	OID_msIndividualSPKeyPurpose = 28,
	OID_msOutlookExpress = 29,
	OID_ntlmssp = 30,
	OID_negoex = 31,
	OID_spnego = 32,
	OID_IAKerb = 33,
	OID_PKU2U = 34,
	OID_Scram = 35,
	OID_certAuthInfoAccess = 36,
	OID_id_ansip384r1 = 37,
	OID_sha256 = 38,
	OID_sha384 = 39,
	OID_sha512 = 40,
	OID_sha224 = 41,
	OID_commonName = 42,
	OID_surname = 43,
	OID_countryName = 44,
	OID_locality = 45,
	OID_stateOrProvinceName = 46,
	OID_organizationName = 47,
	OID_organizationUnitName = 48,
	OID_title = 49,
	OID_description = 50,
	OID_name = 51,
	OID_givenName = 52,
	OID_initials = 53,
	OID_generationalQualifier = 54,
	OID_subjectKeyIdentifier = 55,
	OID_keyUsage = 56,
	OID_subjectAltName = 57,
	OID_issuerAltName = 58,
	OID_basicConstraints = 59,
	OID_crlDistributionPoints = 60,
	OID_certPolicies = 61,
	OID_authorityKeyIdentifier = 62,
	OID_extKeyUsage = 63,
	OID_NetlogonMechanism = 64,
	OID_appleLocalKdcSupported = 65,
	OID_gostCPSignA = 66,
	OID_gostCPSignB = 67,
	OID_gostCPSignC = 68,
	OID_gost2012PKey256 = 69,
	OID_gost2012PKey512 = 70,
	OID_gost2012Digest256 = 71,
	OID_gost2012Digest512 = 72,
	OID_gost2012Signature256 = 73,
	OID_gost2012Signature512 = 74,
	OID_gostTC26Sign256A = 75,
	OID_gostTC26Sign256B = 76,
	OID_gostTC26Sign256C = 77,
	OID_gostTC26Sign256D = 78,
	OID_gostTC26Sign512A = 79,
	OID_gostTC26Sign512B = 80,
	OID_gostTC26Sign512C = 81,
	OID_sm2 = 82,
	OID_sm3 = 83,
	OID_SM2_with_SM3 = 84,
	OID_sm3WithRSAEncryption = 85,
	OID_TPMLoadableKey = 86,
	OID_TPMImportableKey = 87,
	OID_TPMSealedData = 88,
	OID_sha3_256 = 89,
	OID_sha3_384 = 90,
	OID_sha3_512 = 91,
	OID_id_ecdsa_with_sha3_256 = 92,
	OID_id_ecdsa_with_sha3_384 = 93,
	OID_id_ecdsa_with_sha3_512 = 94,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_256 = 95,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_384 = 96,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_512 = 97,
	OID__NR = 98,
};

struct x509_certificate;

struct pkcs7_signed_info;

struct pkcs7_message {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct public_key;

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_sig;
	bool blacklisted;
};

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
	unsigned long key_eflags;
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	unsigned long aa_set;
	time64_t signing_time;
	struct public_key_signature *sig;
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
	BIOSET_PERCPU_CACHE = 4,
};

typedef unsigned int iov_iter_extraction_t;

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[8];
};

struct iov_iter_state {
	size_t iov_offset;
	size_t count;
	unsigned long nr_segs;
};

struct mpm_gic_map;

struct qcom_mpm_priv {
	void *base;
	raw_spinlock_t lock;
	struct mbox_client mbox_client;
	struct mbox_chan *mbox_chan;
	struct mpm_gic_map *maps;
	unsigned int map_cnt;
	unsigned int reg_stride;
	struct irq_domain *domain;
	struct generic_pm_domain genpd;
};

struct mpm_gic_map {
	int pin;
	irq_hw_number_t hwirq;
};

struct dpbp_cmd_open {
	__le32 dpbp_id;
};

struct dpbp_rsp_get_attributes {
	__le16 pad;
	__le16 bpid;
	__le32 id;
	__le16 version_major;
	__le16 version_minor;
};

struct phy_g12a_usb3_pcie_priv {
	struct regmap *regmap;
	struct regmap *regmap_cr;
	struct clk *clk_ref;
	struct reset_control *reset;
	struct phy *phy;
	unsigned int mode;
};

struct r8a779f0_eth_serdes_drv_data;

struct r8a779f0_eth_serdes_channel {
	struct r8a779f0_eth_serdes_drv_data *dd;
	struct phy *phy;
	void *addr;
	phy_interface_t phy_interface;
	int speed;
	int index;
};

struct r8a779f0_eth_serdes_drv_data {
	void *addr;
	struct platform_device *pdev;
	struct reset_control *reset;
	struct r8a779f0_eth_serdes_channel channel[3];
	bool initialized;
};

struct mvebu_mpp_ctrl;

struct mvebu_mpp_ctrl_data;

struct mvebu_mpp_mode;

struct mvebu_pinctrl_soc_info {
	u8 variant;
	const struct mvebu_mpp_ctrl *controls;
	struct mvebu_mpp_ctrl_data *control_data;
	int ncontrols;
	struct mvebu_mpp_mode *modes;
	int nmodes;
	struct pinctrl_gpio_range *gpioranges;
	int ngpioranges;
};

struct mvebu_mpp_ctrl {
	const char *name;
	u8 pid;
	u8 npins;
	unsigned int *pins;
	int (*mpp_get)(struct mvebu_mpp_ctrl_data *, unsigned int, unsigned long *);
	int (*mpp_set)(struct mvebu_mpp_ctrl_data *, unsigned int, unsigned long);
	int (*mpp_gpio_req)(struct mvebu_mpp_ctrl_data *, unsigned int);
	int (*mpp_gpio_dir)(struct mvebu_mpp_ctrl_data *, unsigned int, bool);
};

struct mvebu_mpp_ctrl_data {
	union {
		void *base;
		struct {
			struct regmap *map;
			u32 offset;
		} regmap;
	};
};

struct mvebu_mpp_ctrl_setting;

struct mvebu_mpp_mode {
	u8 pid;
	struct mvebu_mpp_ctrl_setting *settings;
};

struct mvebu_mpp_ctrl_setting {
	u8 val;
	const char *name;
	const char *subname;
	u8 variant;
	u8 flags;
};

enum ioctrl_regs___6 {
	POC0___2 = 0,
	POC1___2 = 1,
	POC3 = 2,
	POC4___2 = 3,
	POC5___2 = 4,
	POC6___2 = 5,
	POC7___2 = 6,
	POC8___2 = 7,
};

enum {
	GP_LAST___4 = 269,
	PIN_VDDQ_AVB0___3 = 270,
	PIN_VDDQ_AVB1 = 271,
	PIN_VDDQ_AVB2 = 272,
	PIN_VDDQ_TSN0 = 273,
};

struct mvebu_gpio_chip;

struct mvebu_pwm {
	struct regmap *regs;
	u32 offset;
	unsigned long clk_rate;
	struct gpio_desc *gpiod;
	struct pwm_chip chip;
	spinlock_t lock;
	struct mvebu_gpio_chip *mvchip;
	u32 blink_select;
	u32 blink_on_duration;
	u32 blink_off_duration;
};

struct mvebu_gpio_chip {
	struct gpio_chip chip;
	struct regmap *regs;
	u32 offset;
	struct regmap *percpu_regs;
	int irqbase;
	struct irq_domain *domain;
	int soc_variant;
	struct clk *clk;
	struct mvebu_pwm *mvpwm;
	u32 out_reg;
	u32 io_conf_reg;
	u32 blink_en_reg;
	u32 in_pol_reg;
	u32 edge_mask_regs[4];
	u32 level_mask_regs[4];
};

struct syscon_gpio_data {
	unsigned int flags;
	unsigned int bit_count;
	unsigned int dat_bit_offset;
	unsigned int dir_bit_offset;
	void (*set)(struct gpio_chip *, unsigned int, int);
};

struct syscon_gpio_priv {
	struct gpio_chip chip;
	struct regmap *syscon;
	const struct syscon_gpio_data *data;
	u32 dreg_offset;
	u32 dir_reg_offset;
};

typedef enum {
	PCI_BRIDGE_EMUL_HANDLED = 0,
	PCI_BRIDGE_EMUL_NOT_HANDLED = 1,
} pci_bridge_emul_read_status_t;

struct pci_bridge_emul;

struct pci_bridge_emul_ops {
	pci_bridge_emul_read_status_t (*read_base)(struct pci_bridge_emul *, int, u32 *);
	pci_bridge_emul_read_status_t (*read_pcie)(struct pci_bridge_emul *, int, u32 *);
	pci_bridge_emul_read_status_t (*read_ext)(struct pci_bridge_emul *, int, u32 *);
	void (*write_base)(struct pci_bridge_emul *, int, u32, u32, u32);
	void (*write_pcie)(struct pci_bridge_emul *, int, u32, u32, u32);
	void (*write_ext)(struct pci_bridge_emul *, int, u32, u32, u32);
};

struct pci_bridge_emul_conf {
	__le16 vendor;
	__le16 device;
	__le16 command;
	__le16 status;
	__le32 class_revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 header_type;
	u8 bist;
	__le32 bar[2];
	u8 primary_bus;
	u8 secondary_bus;
	u8 subordinate_bus;
	u8 secondary_latency_timer;
	u8 iobase;
	u8 iolimit;
	__le16 secondary_status;
	__le16 membase;
	__le16 memlimit;
	__le16 pref_mem_base;
	__le16 pref_mem_limit;
	__le32 prefbaseupper;
	__le32 preflimitupper;
	__le16 iobaseupper;
	__le16 iolimitupper;
	u8 capabilities_pointer;
	u8 reserve[3];
	__le32 romaddr;
	u8 intline;
	u8 intpin;
	__le16 bridgectrl;
};

struct pci_bridge_emul_pcie_conf {
	u8 cap_id;
	u8 next;
	__le16 cap;
	__le32 devcap;
	__le16 devctl;
	__le16 devsta;
	__le32 lnkcap;
	__le16 lnkctl;
	__le16 lnksta;
	__le32 slotcap;
	__le16 slotctl;
	__le16 slotsta;
	__le16 rootctl;
	__le16 rootcap;
	__le32 rootsta;
	__le32 devcap2;
	__le16 devctl2;
	__le16 devsta2;
	__le32 lnkcap2;
	__le16 lnkctl2;
	__le16 lnksta2;
	__le32 slotcap2;
	__le16 slotctl2;
	__le16 slotsta2;
};

struct pci_bridge_reg_behavior;

struct pci_bridge_emul {
	struct pci_bridge_emul_conf conf;
	struct pci_bridge_emul_pcie_conf pcie_conf;
	const struct pci_bridge_emul_ops *ops;
	struct pci_bridge_reg_behavior *pci_regs_behavior;
	struct pci_bridge_reg_behavior *pcie_cap_regs_behavior;
	void *data;
	u8 pcie_start;
	u8 ssid_start;
	bool has_pcie;
	u16 subsystem_vendor_id;
	u16 subsystem_id;
};

enum {
	LTSSM_DETECT_QUIET = 0,
	LTSSM_DETECT_ACTIVE = 1,
	LTSSM_POLLING_ACTIVE = 2,
	LTSSM_POLLING_COMPLIANCE = 3,
	LTSSM_POLLING_CONFIGURATION = 4,
	LTSSM_CONFIG_LINKWIDTH_START = 5,
	LTSSM_CONFIG_LINKWIDTH_ACCEPT = 6,
	LTSSM_CONFIG_LANENUM_ACCEPT = 7,
	LTSSM_CONFIG_LANENUM_WAIT = 8,
	LTSSM_CONFIG_COMPLETE = 9,
	LTSSM_CONFIG_IDLE = 10,
	LTSSM_RECOVERY_RCVR_LOCK = 11,
	LTSSM_RECOVERY_SPEED = 12,
	LTSSM_RECOVERY_RCVR_CFG = 13,
	LTSSM_RECOVERY_IDLE = 14,
	LTSSM_L0 = 16,
	LTSSM_RX_L0S_ENTRY = 17,
	LTSSM_RX_L0S_IDLE = 18,
	LTSSM_RX_L0S_FTS = 19,
	LTSSM_TX_L0S_ENTRY = 20,
	LTSSM_TX_L0S_IDLE = 21,
	LTSSM_TX_L0S_FTS = 22,
	LTSSM_L1_ENTRY = 23,
	LTSSM_L1_IDLE = 24,
	LTSSM_L2_IDLE = 25,
	LTSSM_L2_TRANSMIT_WAKE = 26,
	LTSSM_DISABLED = 32,
	LTSSM_LOOPBACK_ENTRY_MASTER = 33,
	LTSSM_LOOPBACK_ACTIVE_MASTER = 34,
	LTSSM_LOOPBACK_EXIT_MASTER = 35,
	LTSSM_LOOPBACK_ENTRY_SLAVE = 36,
	LTSSM_LOOPBACK_ACTIVE_SLAVE = 37,
	LTSSM_LOOPBACK_EXIT_SLAVE = 38,
	LTSSM_HOT_RESET = 39,
	LTSSM_RECOVERY_EQUALIZATION_PHASE0 = 40,
	LTSSM_RECOVERY_EQUALIZATION_PHASE1 = 41,
	LTSSM_RECOVERY_EQUALIZATION_PHASE2 = 42,
	LTSSM_RECOVERY_EQUALIZATION_PHASE3 = 43,
};

struct advk_pcie {
	struct platform_device *pdev;
	void *base;
	struct {
		phys_addr_t match;
		phys_addr_t remap;
		phys_addr_t mask;
		u32 actions;
	} wins[8];
	u8 wins_count;
	struct irq_domain *rp_irq_domain;
	struct irq_domain *irq_domain;
	struct irq_chip irq_chip;
	raw_spinlock_t irq_lock;
	struct irq_domain *msi_domain;
	struct irq_domain *msi_inner_domain;
	raw_spinlock_t msi_irq_lock;
	unsigned long msi_used[1];
	struct mutex msi_used_lock;
	int link_gen;
	struct pci_bridge_emul bridge;
	struct gpio_desc *reset_gpio;
	struct phy *phy;
};

struct rockchip_pcie {
	void *reg_base;
	void *apb_base;
	bool legacy_phy;
	struct phy *phys[4];
	struct reset_control *core_rst;
	struct reset_control *mgmt_rst;
	struct reset_control *mgmt_sticky_rst;
	struct reset_control *pipe_rst;
	struct reset_control *pm_rst;
	struct reset_control *aclk_rst;
	struct reset_control *pclk_rst;
	struct clk *aclk_pcie;
	struct clk *aclk_perf_pcie;
	struct clk *hclk_pcie;
	struct clk *clk_pcie_pm;
	struct regulator *vpcie12v;
	struct regulator *vpcie3v3;
	struct regulator *vpcie1v8;
	struct regulator *vpcie0v9;
	struct gpio_desc *ep_gpio;
	u32 lanes;
	u8 lanes_map;
	int link_gen;
	struct device *dev;
	struct irq_domain *irq_domain;
	int offset;
	void *msg_region;
	phys_addr_t msg_bus_addr;
	bool is_rc;
	struct resource *mem_res;
};

struct fbcon_display;

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const unsigned short *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, int, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct delayed_work cursor_work;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	bool initialized;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short inverse;
	short yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct acpi_bus_type {
	struct list_head list;
	const char *name;
	bool (*match)(struct device *);
	struct acpi_device * (*find_companion)(struct device *);
	void (*setup)(struct device *);
};

struct find_child_walk_data {
	struct acpi_device *adev;
	u64 address;
	int score;
	bool check_sta;
	bool check_children;
};

struct imx_clk_scu_rsrc_table {
	const u32 *rsrc;
	u8 num;
};

struct meson_clk_mpll_data {
	struct parm sdm;
	struct parm sdm_en;
	struct parm n2;
	struct parm ssen;
	struct parm misc;
	const struct reg_sequence *init_regs;
	unsigned int init_count;
	spinlock_t *lock;
	u8 flags;
};

struct qcom_reset_controller {
	const struct qcom_reset_map *reset_map;
	struct regmap *regmap;
	struct reset_controller_dev rcdev;
};

struct qcom_cc {
	struct qcom_reset_controller reset;
	struct clk_regmap **rclks;
	size_t num_rclks;
};

struct tegra_dma_channel___2;

struct tegra_dma_chip_data___2 {
	bool hw_support_pause;
	unsigned int nr_channels;
	unsigned int channel_reg_size;
	unsigned int max_dma_count;
	int (*terminate)(struct tegra_dma_channel___2 *);
};

struct tegra_dma___2;

struct tegra_dma_desc___2;

struct tegra_dma_channel___2 {
	bool config_init;
	char name[30];
	enum dma_transfer_direction sid_dir;
	int id;
	int irq;
	int slave_id;
	struct tegra_dma___2 *tdma;
	struct virt_dma_chan vc;
	struct tegra_dma_desc___2 *dma_desc;
	struct dma_slave_config dma_sconfig;
	unsigned int stream_id;
	unsigned long chan_base_offset;
};

struct tegra_dma___2 {
	const struct tegra_dma_chip_data___2 *chip_data;
	unsigned long sid_m2d_reserved;
	unsigned long sid_d2m_reserved;
	u32 chan_mask;
	void *base_addr;
	struct device *dev;
	struct dma_device dma_dev;
	struct reset_control *rst;
	struct tegra_dma_channel___2 channels[0];
};

struct tegra_dma_channel_regs___2 {
	u32 csr;
	u32 src_ptr;
	u32 dst_ptr;
	u32 high_addr_ptr;
	u32 mc_seq;
	u32 mmio_seq;
	u32 wcount;
	u32 fixed_pattern;
};

struct tegra_dma_sg_req___2 {
	unsigned int len;
	struct tegra_dma_channel_regs___2 ch_regs;
};

struct tegra_dma_desc___2 {
	bool cyclic;
	unsigned int bytes_req;
	unsigned int bytes_xfer;
	unsigned int sg_idx;
	unsigned int sg_count;
	struct virt_dma_desc vd;
	struct tegra_dma_channel___2 *tdc;
	struct tegra_dma_sg_req___2 sg_req[0];
};

struct dpaa2_io_desc {
	int receives_notifications;
	int has_8prio;
	int cpu;
	void *regs_cena;
	void *regs_cinh;
	int dpio_id;
	u32 qman_version;
	u32 qman_clk;
};

struct qbman_swp_desc {
	void *cena_bar;
	void *cinh_bar;
	u32 qman_version;
	u32 qman_clk;
	u32 qman_256_cycles_per_ns;
};

struct qbman_swp;

struct dpaa2_io {
	struct dpaa2_io_desc dpio_desc;
	struct qbman_swp_desc swp_desc;
	struct qbman_swp *swp;
	struct list_head node;
	spinlock_t lock_mgmt_cmd;
	spinlock_t lock_notifications;
	struct list_head notifications;
	struct device *dev;
	struct dim rx_dim;
	spinlock_t dim_lock;
	u16 event_ctr;
	u64 bytes;
	u64 frames;
};

struct qbman_swp {
	const struct qbman_swp_desc *desc;
	void *addr_cena;
	void *addr_cinh;
	struct {
		u32 valid_bit;
	} mc;
	struct {
		u32 valid_bit;
	} mr;
	u32 sdq;
	struct {
		atomic_t available;
		u32 valid_bit;
		struct dpaa2_dq *storage;
	} vdq;
	struct {
		u32 next_idx;
		u32 valid_bit;
		u8 dqrr_size;
		int reset_bug;
	} dqrr;
	struct {
		u32 pi;
		u32 pi_vb;
		u32 pi_ring_size;
		u32 pi_ci_mask;
		u32 ci;
		int available;
		u32 pend;
		u32 no_pfdr;
	} eqcr;
	spinlock_t access_spinlock;
	u32 irq_threshold;
	u32 irq_holdoff;
	int use_adaptive_rx_coalesce;
};

enum qbman_pull_type_e {
	qbman_pull_type_prio = 1,
	qbman_pull_type_active = 2,
	qbman_pull_type_active_noics = 3,
};

enum dim_state {
	DIM_START_MEASURE = 0,
	DIM_MEASURE_IN_PROGRESS = 1,
	DIM_APPLY_NEW_PROFILE = 2,
};

struct dim_cq_moder {
	u16 usec;
	u16 pkts;
	u16 comps;
	u8 cq_period_mode;
};

struct qbman_pull_desc {
	u8 verb;
	u8 numf;
	u8 tok;
	u8 reserved;
	__le32 dq_src;
	__le64 rsp_addr;
	u64 rsp_addr_virt;
	u8 padding[40];
};

struct qbman_eq_desc {
	u8 verb;
	u8 dca;
	__le16 seqnum;
	__le16 orpid;
	__le16 reserved1;
	__le32 tgtid;
	__le32 tag;
	__le16 qdbin;
	u8 qpri;
	u8 reserved[3];
	u8 wae;
	u8 rspid;
	__le64 rsp_addr;
};

struct qbman_release_desc {
	u8 verb;
	u8 reserved;
	__le16 bpid;
	__le32 reserved2;
	__le64 buf[7];
};

struct qbman_fq_query_np_rslt {
	u8 verb;
	u8 rslt;
	u8 st1;
	u8 st2;
	u8 reserved[2];
	__le16 od1_sfdr;
	__le16 od2_sfdr;
	__le16 od3_sfdr;
	__le16 ra1_sfdr;
	__le16 ra2_sfdr;
	__le32 pfdr_hptr;
	__le32 pfdr_tptr;
	__le32 frm_cnt;
	__le32 byte_cnt;
	__le16 ics_surp;
	u8 is;
	u8 reserved2[29];
};

struct qbman_bp_query_rslt {
	u8 verb;
	u8 rslt;
	u8 reserved[4];
	u8 bdi;
	u8 state;
	__le32 fill;
	__le32 hdotr;
	__le16 swdet;
	__le16 swdxt;
	__le16 hwdet;
	__le16 hwdxt;
	__le16 swset;
	__le16 swsxt;
	__le16 vbpid;
	__le16 icid;
	__le64 bpscn_addr;
	__le64 bpscn_ctx;
	__le16 hw_targ;
	u8 dbe;
	u8 reserved2;
	u8 sdcnt;
	u8 hdcnt;
	u8 sscnt;
	u8 reserved3[9];
};

struct dpaa2_io_store {
	unsigned int max;
	dma_addr_t paddr;
	struct dpaa2_dq *vaddr;
	void *alloced_addr;
	unsigned int idx;
	struct qbman_swp *swp;
	struct device *dev;
};

struct virtio_mmio_device {
	struct virtio_device vdev;
	struct platform_device *pdev;
	void *base;
	unsigned long version;
	spinlock_t lock;
	struct list_head virtqueues;
};

struct virtio_mmio_vq_info {
	struct virtqueue *vq;
	struct list_head node;
};

enum fan53555_vendor {
	FAN53526_VENDOR_FAIRCHILD = 0,
	FAN53555_VENDOR_FAIRCHILD = 1,
	FAN53555_VENDOR_ROCKCHIP = 2,
	RK8602_VENDOR_ROCKCHIP = 3,
	FAN53555_VENDOR_SILERGY = 4,
	FAN53526_VENDOR_TCS = 5,
};

enum {
	FAN53555_VSEL_ID_0 = 0,
	FAN53555_VSEL_ID_1 = 1,
};

enum {
	FAN53526_CHIP_ID_01 = 1,
};

enum {
	FAN53526_CHIP_REV_08 = 8,
};

enum {
	FAN53555_CHIP_ID_00 = 0,
	FAN53555_CHIP_ID_01 = 1,
	FAN53555_CHIP_ID_02 = 2,
	FAN53555_CHIP_ID_03 = 3,
	FAN53555_CHIP_ID_04 = 4,
	FAN53555_CHIP_ID_05 = 5,
	FAN53555_CHIP_ID_08 = 8,
};

enum {
	FAN53555_CHIP_REV_00 = 3,
	FAN53555_CHIP_REV_13 = 15,
};

enum {
	RK8600_CHIP_ID_08 = 8,
};

enum {
	RK8602_CHIP_ID_10 = 10,
};

enum {
	SILERGY_SYR82X = 8,
	SILERGY_SYR83X = 9,
};

enum {
	TCS4525_CHIP_ID_12 = 12,
};

struct fan53555_platform_data {
	struct regulator_init_data *regulator;
	unsigned int slew_rate;
	unsigned int sleep_vsel_id;
};

struct fan53555_device_info {
	enum fan53555_vendor vendor;
	struct device *dev;
	struct regulator_desc desc;
	struct regulator_init_data *regulator;
	int chip_id;
	int chip_rev;
	unsigned int vol_reg;
	unsigned int sleep_reg;
	unsigned int en_reg;
	unsigned int sleep_en_reg;
	unsigned int vsel_min;
	unsigned int vsel_step;
	unsigned int vsel_count;
	unsigned int mode_reg;
	unsigned int mode_mask;
	unsigned int sleep_vol_cache;
	unsigned int slew_reg;
	unsigned int slew_mask;
	const unsigned int *ramp_delay_table;
	unsigned int n_ramp_values;
	unsigned int slew_rate;
};

struct meson_reset_param {
	int reg_count;
	int level_offset;
};

struct meson_reset {
	void *reg_base;
	const struct meson_reset_param *param;
	struct reset_controller_dev rcdev;
	spinlock_t lock;
};

struct exar8250;

struct exar8250_board {
	unsigned int num_ports;
	unsigned int reg_shift;
	int (*setup)(struct exar8250 *, struct pci_dev *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct exar8250 {
	unsigned int nr;
	struct exar8250_board *board;
	void *virt;
	int line[0];
};

struct exar8250_platform {
	int (*rs485_config)(struct uart_port *, struct ktermios *, struct serial_rs485 *);
	const struct serial_rs485 *rs485_supported;
	int (*register_gpio)(struct pci_dev *, struct uart_8250_port *);
	void (*unregister_gpio)(struct uart_8250_port *);
};

struct mctrl_gpios {
	struct uart_port *port;
	struct gpio_desc *gpio[6];
	int irq[6];
	unsigned int mctrl_prev;
	bool mctrl_on;
};

struct meson_rng_priv {
	int (*read)(struct hwrng *, void *, size_t, bool);
};

struct meson_rng_data {
	void *base;
	struct hwrng rng;
	struct device *dev;
};

struct tpm2_hash {
	unsigned int crypto_id;
	unsigned int tpm_id;
};

enum tpm_duration {
	TPM_SHORT = 0,
	TPM_MEDIUM = 1,
	TPM_LONG = 2,
	TPM_LONG_LONG = 3,
	TPM_UNDEFINED = 4,
	TPM_NUM_DURATIONS = 4,
};

enum tpm2_const {
	TPM2_PLATFORM_PCR = 24,
	TPM2_PCR_SELECT_MIN = 3,
};

enum tpm2_permanent_handles {
	TPM2_RS_PW = 1073741833,
};

enum tpm2_properties {
	TPM_PT_TOTAL_COMMANDS = 297,
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO_SHA3_256 = 20,
	HASH_ALGO_SHA3_384 = 21,
	HASH_ALGO_SHA3_512 = 22,
	HASH_ALGO__LAST = 23,
};

struct tpm2_pcr_read_out {
	__be32 update_cnt;
	__be32 pcr_selects_cnt;
	__be16 hash_alg;
	u8 pcr_select_size;
	u8 pcr_select[3];
	__be32 digests_cnt;
	__be16 digest_size;
	u8 digest[0];
} __attribute__((packed));

struct tpm2_get_random_out {
	__be16 size;
	u8 buffer[128];
};

struct tpm2_get_cap_out {
	u8 more_data;
	__be32 subcap_id;
	__be32 property_cnt;
	__be32 property_id;
	__be32 value;
} __attribute__((packed));

struct tpm2_null_auth_area {
	__be32 handle;
	__be16 nonce_size;
	u8 attributes;
	__be16 auth_size;
} __attribute__((packed));

struct tpm2_pcr_selection {
	__be16 hash_alg;
	u8 size_of_select;
	u8 pcr_select[3];
};

enum mipi_dsi_pixel_format {
	MIPI_DSI_FMT_RGB888 = 0,
	MIPI_DSI_FMT_RGB666 = 1,
	MIPI_DSI_FMT_RGB666_PACKED = 2,
	MIPI_DSI_FMT_RGB565 = 3,
};

enum {
	MIPI_DSI_V_SYNC_START = 1,
	MIPI_DSI_V_SYNC_END = 17,
	MIPI_DSI_H_SYNC_START = 33,
	MIPI_DSI_H_SYNC_END = 49,
	MIPI_DSI_COMPRESSION_MODE = 7,
	MIPI_DSI_END_OF_TRANSMISSION = 8,
	MIPI_DSI_COLOR_MODE_OFF = 2,
	MIPI_DSI_COLOR_MODE_ON = 18,
	MIPI_DSI_SHUTDOWN_PERIPHERAL = 34,
	MIPI_DSI_TURN_ON_PERIPHERAL = 50,
	MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM = 3,
	MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM = 19,
	MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM = 35,
	MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM = 4,
	MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM = 20,
	MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM = 36,
	MIPI_DSI_DCS_SHORT_WRITE = 5,
	MIPI_DSI_DCS_SHORT_WRITE_PARAM = 21,
	MIPI_DSI_DCS_READ = 6,
	MIPI_DSI_EXECUTE_QUEUE = 22,
	MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE = 55,
	MIPI_DSI_NULL_PACKET = 9,
	MIPI_DSI_BLANKING_PACKET = 25,
	MIPI_DSI_GENERIC_LONG_WRITE = 41,
	MIPI_DSI_DCS_LONG_WRITE = 57,
	MIPI_DSI_PICTURE_PARAMETER_SET = 10,
	MIPI_DSI_COMPRESSED_PIXEL_STREAM = 11,
	MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20 = 12,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24 = 28,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16 = 44,
	MIPI_DSI_PACKED_PIXEL_STREAM_30 = 13,
	MIPI_DSI_PACKED_PIXEL_STREAM_36 = 29,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12 = 61,
	MIPI_DSI_PACKED_PIXEL_STREAM_16 = 14,
	MIPI_DSI_PACKED_PIXEL_STREAM_18 = 30,
	MIPI_DSI_PIXEL_STREAM_3BYTE_18 = 46,
	MIPI_DSI_PACKED_PIXEL_STREAM_24 = 62,
};

enum {
	MIPI_DCS_NOP = 0,
	MIPI_DCS_SOFT_RESET = 1,
	MIPI_DCS_GET_COMPRESSION_MODE = 3,
	MIPI_DCS_GET_DISPLAY_ID = 4,
	MIPI_DCS_GET_ERROR_COUNT_ON_DSI = 5,
	MIPI_DCS_GET_RED_CHANNEL = 6,
	MIPI_DCS_GET_GREEN_CHANNEL = 7,
	MIPI_DCS_GET_BLUE_CHANNEL = 8,
	MIPI_DCS_GET_DISPLAY_STATUS = 9,
	MIPI_DCS_GET_POWER_MODE = 10,
	MIPI_DCS_GET_ADDRESS_MODE = 11,
	MIPI_DCS_GET_PIXEL_FORMAT = 12,
	MIPI_DCS_GET_DISPLAY_MODE = 13,
	MIPI_DCS_GET_SIGNAL_MODE = 14,
	MIPI_DCS_GET_DIAGNOSTIC_RESULT = 15,
	MIPI_DCS_ENTER_SLEEP_MODE = 16,
	MIPI_DCS_EXIT_SLEEP_MODE = 17,
	MIPI_DCS_ENTER_PARTIAL_MODE = 18,
	MIPI_DCS_ENTER_NORMAL_MODE = 19,
	MIPI_DCS_GET_IMAGE_CHECKSUM_RGB = 20,
	MIPI_DCS_GET_IMAGE_CHECKSUM_CT = 21,
	MIPI_DCS_EXIT_INVERT_MODE = 32,
	MIPI_DCS_ENTER_INVERT_MODE = 33,
	MIPI_DCS_SET_GAMMA_CURVE = 38,
	MIPI_DCS_SET_DISPLAY_OFF = 40,
	MIPI_DCS_SET_DISPLAY_ON = 41,
	MIPI_DCS_SET_COLUMN_ADDRESS = 42,
	MIPI_DCS_SET_PAGE_ADDRESS = 43,
	MIPI_DCS_WRITE_MEMORY_START = 44,
	MIPI_DCS_WRITE_LUT = 45,
	MIPI_DCS_READ_MEMORY_START = 46,
	MIPI_DCS_SET_PARTIAL_ROWS = 48,
	MIPI_DCS_SET_PARTIAL_COLUMNS = 49,
	MIPI_DCS_SET_SCROLL_AREA = 51,
	MIPI_DCS_SET_TEAR_OFF = 52,
	MIPI_DCS_SET_TEAR_ON = 53,
	MIPI_DCS_SET_ADDRESS_MODE = 54,
	MIPI_DCS_SET_SCROLL_START = 55,
	MIPI_DCS_EXIT_IDLE_MODE = 56,
	MIPI_DCS_ENTER_IDLE_MODE = 57,
	MIPI_DCS_SET_PIXEL_FORMAT = 58,
	MIPI_DCS_WRITE_MEMORY_CONTINUE = 60,
	MIPI_DCS_SET_3D_CONTROL = 61,
	MIPI_DCS_READ_MEMORY_CONTINUE = 62,
	MIPI_DCS_GET_3D_CONTROL = 63,
	MIPI_DCS_SET_VSYNC_TIMING = 64,
	MIPI_DCS_SET_TEAR_SCANLINE = 68,
	MIPI_DCS_GET_SCANLINE = 69,
	MIPI_DCS_SET_DISPLAY_BRIGHTNESS = 81,
	MIPI_DCS_GET_DISPLAY_BRIGHTNESS = 82,
	MIPI_DCS_WRITE_CONTROL_DISPLAY = 83,
	MIPI_DCS_GET_CONTROL_DISPLAY = 84,
	MIPI_DCS_WRITE_POWER_SAVE = 85,
	MIPI_DCS_GET_POWER_SAVE = 86,
	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 94,
	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 95,
	MIPI_DCS_READ_DDB_START = 161,
	MIPI_DCS_READ_PPS_START = 162,
	MIPI_DCS_READ_DDB_CONTINUE = 168,
	MIPI_DCS_READ_PPS_CONTINUE = 169,
};

enum mipi_dsi_dcs_tear_mode {
	MIPI_DSI_DCS_TEAR_MODE_VBLANK = 0,
	MIPI_DSI_DCS_TEAR_MODE_VHBLANK = 1,
};

struct mipi_dsi_host;

struct drm_dsc_config;

struct mipi_dsi_device {
	struct mipi_dsi_host *host;
	struct device dev;
	char name[20];
	unsigned int channel;
	unsigned int lanes;
	enum mipi_dsi_pixel_format format;
	unsigned long mode_flags;
	unsigned long hs_rate;
	unsigned long lp_rate;
	struct drm_dsc_config *dsc;
};

struct mipi_dsi_host_ops;

struct mipi_dsi_host {
	struct device *dev;
	const struct mipi_dsi_host_ops *ops;
	struct list_head list;
};

struct mipi_dsi_msg;

struct mipi_dsi_host_ops {
	int (*attach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	int (*detach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	ssize_t (*transfer)(struct mipi_dsi_host *, const struct mipi_dsi_msg *);
};

struct mipi_dsi_msg {
	u8 channel;
	u8 type;
	u16 flags;
	size_t tx_len;
	const void *tx_buf;
	size_t rx_len;
	void *rx_buf;
};

struct drm_dsc_rc_range_parameters {
	u8 range_min_qp;
	u8 range_max_qp;
	u8 range_bpg_offset;
};

struct drm_dsc_config {
	u8 line_buf_depth;
	u8 bits_per_component;
	bool convert_rgb;
	u8 slice_count;
	u16 slice_width;
	u16 slice_height;
	bool simple_422;
	u16 pic_width;
	u16 pic_height;
	u8 rc_tgt_offset_high;
	u8 rc_tgt_offset_low;
	u16 bits_per_pixel;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit1;
	u8 rc_quant_incr_limit0;
	u16 initial_xmit_delay;
	u16 initial_dec_delay;
	bool block_pred_enable;
	u8 first_line_bpg_offset;
	u16 initial_offset;
	u16 rc_buf_thresh[14];
	struct drm_dsc_rc_range_parameters rc_range_params[15];
	u16 rc_model_size;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	u8 initial_scale_value;
	u16 scale_decrement_interval;
	u16 scale_increment_interval;
	u16 nfl_bpg_offset;
	u16 slice_bpg_offset;
	u16 final_offset;
	bool vbr_enable;
	u8 mux_word_size;
	u16 slice_chunk_size;
	u16 rc_bits;
	u8 dsc_version_minor;
	u8 dsc_version_major;
	bool native_422;
	bool native_420;
	u8 second_line_bpg_offset;
	u16 nsl_bpg_offset;
	u16 second_line_offset_adj;
};

struct mipi_dsi_driver {
	struct device_driver driver;
	int (*probe)(struct mipi_dsi_device *);
	void (*remove)(struct mipi_dsi_device *);
	void (*shutdown)(struct mipi_dsi_device *);
};

struct mipi_dsi_device_info {
	char type[20];
	u32 channel;
	struct device_node *node;
};

struct mipi_dsi_packet {
	size_t size;
	u8 header[4];
	size_t payload_length;
	const u8 *payload;
};

struct drm_dsc_picture_parameter_set {
	u8 dsc_version;
	u8 pps_identifier;
	u8 pps_reserved;
	u8 pps_3;
	u8 pps_4;
	u8 bits_per_pixel_low;
	__be16 pic_height;
	__be16 pic_width;
	__be16 slice_height;
	__be16 slice_width;
	__be16 chunk_size;
	u8 initial_xmit_delay_high;
	u8 initial_xmit_delay_low;
	__be16 initial_dec_delay;
	u8 pps20_reserved;
	u8 initial_scale_value;
	__be16 scale_increment_interval;
	u8 scale_decrement_interval_high;
	u8 scale_decrement_interval_low;
	u8 pps26_reserved;
	u8 first_line_bpg_offset;
	__be16 nfl_bpg_offset;
	__be16 slice_bpg_offset;
	__be16 initial_offset;
	__be16 final_offset;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	__be16 rc_model_size;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit0;
	u8 rc_quant_incr_limit1;
	u8 rc_tgt_offset;
	u8 rc_buf_thresh[14];
	__be16 rc_range_parameters[15];
	u8 native_422_420;
	u8 second_line_bpg_offset;
	__be16 nsl_bpg_offset;
	__be16 second_line_offset_adj;
	u32 pps_long_94_reserved;
	u32 pps_long_98_reserved;
	u32 pps_long_102_reserved;
	u32 pps_long_106_reserved;
	u32 pps_long_110_reserved;
	u32 pps_long_114_reserved;
	u32 pps_long_118_reserved;
	u32 pps_long_122_reserved;
	__be16 pps_short_126_reserved;
} __attribute__((packed));

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

typedef int pcpu_fc_cpu_to_node_fn_t(int);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

struct qcom_spmi_pmic {
	unsigned int type;
	unsigned int subtype;
	unsigned int major;
	unsigned int minor;
	unsigned int rev2;
	unsigned int fab_id;
	const char *name;
};

struct qcom_spmi_dev {
	int num_usids;
	struct qcom_spmi_pmic pmic;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
};

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

typedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *);

struct ata_scsi_args {
	struct ata_device *dev;
	u16 *id;
	struct scsi_cmnd *cmd;
};

struct a3700_spi {
	struct spi_controller *host;
	void *base;
	struct clk *clk;
	unsigned int irq;
	unsigned int flags;
	bool xmit_data;
	const u8 *tx_buf;
	u8 *rx_buf;
	size_t buf_len;
	u8 byte_len;
	u32 wait_mask;
	struct completion done;
};

struct bcm_qspi_data {
	bool has_mspi_rev;
	bool has_spcr3_sysclk;
};

struct bcm_qspi_irq {
	const char *irq_name;
	const irq_handler_t irq_handler;
	int irq_source;
	u32 mask;
};

enum base_type {
	MSPI = 0,
	BSPI = 1,
	CHIP_SELECT = 2,
	BASEMAX = 3,
};

enum irq_source {
	SINGLE_L2 = 0,
	MUXED_L1 = 1,
};

struct bcm_qspi_parms {
	u32 speed_hz;
	u8 mode;
	u8 bits_per_word;
};

struct qspi_trans {
	struct spi_transfer *trans;
	int byte;
	bool mspi_last_trans;
};

struct bcm_xfer_mode {
	bool flex_mode;
	unsigned int width;
	unsigned int addrlen;
	unsigned int hp;
};

struct bcm_qspi_dev_id;

struct bcm_qspi {
	struct platform_device *pdev;
	struct spi_controller *host;
	struct clk *clk;
	u32 base_clk;
	u32 max_speed_hz;
	void *base[3];
	struct bcm_qspi_soc_intc *soc_intc;
	struct bcm_qspi_parms last_parms;
	struct qspi_trans trans_pos;
	int curr_cs;
	int bspi_maj_rev;
	int bspi_min_rev;
	int bspi_enabled;
	const struct spi_mem_op *bspi_rf_op;
	u32 bspi_rf_op_idx;
	u32 bspi_rf_op_len;
	u32 bspi_rf_op_status;
	struct bcm_xfer_mode xfer_mode;
	u32 s3_strap_override_ctrl;
	bool bspi_mode;
	bool big_endian;
	int num_irqs;
	struct bcm_qspi_dev_id *dev_ids;
	struct completion mspi_done;
	struct completion bspi_done;
	u8 mspi_maj_rev;
	u8 mspi_min_rev;
	bool mspi_spcr3_sysclk;
};

struct bcm_qspi_dev_id {
	const struct bcm_qspi_irq *irqp;
	void *dev;
};

struct iproc_mdio_priv {
	struct mii_bus *mii_bus;
	void *base;
};

enum enetc_ic_mode {
	ENETC_IC_NONE = 0,
	ENETC_IC_RX_MANUAL = 1,
	ENETC_IC_TX_MANUAL = 2,
	ENETC_IC_RX_ADAPTIVE = 4,
};

enum enetc_flags_bit {
	ENETC_TX_ONESTEP_TSTAMP_IN_PROGRESS = 0,
};

enum enetc_txbd_flags {
	ENETC_TXBD_FLAGS_RES0 = 1,
	ENETC_TXBD_FLAGS_TSE = 2,
	ENETC_TXBD_FLAGS_W = 4,
	ENETC_TXBD_FLAGS_RES3 = 8,
	ENETC_TXBD_FLAGS_TXSTART = 16,
	ENETC_TXBD_FLAGS_EX = 64,
	ENETC_TXBD_FLAGS_F = 128,
};

enum enetc_bdr_type {
	TX = 0,
	RX = 1,
};

union enetc_tx_bd {
	struct {
		__le64 addr;
		__le16 buf_len;
		__le16 frm_len;
		union {
			struct {
				u8 reserved[3];
				u8 flags;
			};
			__le32 txstart;
			__le32 lstatus;
		};
	};
	struct {
		__le32 tstamp;
		__le16 tpid;
		__le16 vid;
		u8 reserved[6];
		u8 e_flags;
		u8 flags;
	} ext;
	struct {
		__le32 tstamp;
		u8 reserved[10];
		u8 status;
		u8 flags;
	} wb;
};

union enetc_rx_bd {
	struct {
		__le64 addr;
		u8 reserved[8];
	} w;
	struct {
		__le16 inet_csum;
		__le16 parse_summary;
		__le32 rss_hash;
		__le16 buf_len;
		__le16 vlan_opt;
		union {
			struct {
				__le16 flags;
				__le16 error;
			};
			__le32 lstatus;
		};
	} r;
	struct {
		__le32 tstamp;
		u8 reserved[12];
	} ext;
};

enum hclge_mdio_c22_op_seq {
	HCLGE_MDIO_C22_WRITE = 1,
	HCLGE_MDIO_C22_READ = 2,
};

struct hclge_phy_reg_cmd {
	__le16 reg_addr;
	u8 rsv0[2];
	__le16 reg_val;
	u8 rsv1[18];
};

struct hclge_mdio_cfg_cmd {
	u8 ctrl_bit;
	u8 phyid;
	u8 phyad;
	u8 rsvd;
	__le16 reserve;
	__le16 data_wr;
	__le16 data_rd;
	__le16 sta;
};

struct dwc3_ep_file_map {
	const char name[25];
	const struct file_operations * const fops;
};

struct ci_hdrc_pci {
	struct platform_device *ci;
	struct platform_device *phy;
};

struct min_max_quirk {
	const char * const *pnp_ids;
	struct {
		u32 min;
		u32 max;
	} board_id;
	u32 x_min;
	u32 x_max;
	u32 y_min;
	u32 y_max;
};

enum synaptics_pkt_type {
	SYN_NEWABS = 0,
	SYN_NEWABS_STRICT = 1,
	SYN_NEWABS_RELAXED = 2,
	SYN_OLDABS = 3,
};

enum rmi_sensor_type {
	rmi_sensor_default = 0,
	rmi_sensor_touchscreen = 1,
	rmi_sensor_touchpad = 2,
};

enum rmi_reg_state {
	RMI_REG_STATE_DEFAULT = 0,
	RMI_REG_STATE_OFF = 1,
	RMI_REG_STATE_ON = 2,
};

enum {
	SYNAPTICS_INTERTOUCH_NOT_SET = -1,
	SYNAPTICS_INTERTOUCH_OFF = 0,
	SYNAPTICS_INTERTOUCH_ON = 1,
};

struct synaptics_device_info {
	u32 model_id;
	u32 firmware_id;
	u32 board_id;
	u32 capabilities;
	u32 ext_cap;
	u32 ext_cap_0c;
	u32 ext_cap_10;
	u32 identity;
	u32 x_res;
	u32 y_res;
	u32 x_max;
	u32 y_max;
	u32 x_min;
	u32 y_min;
};

struct rmi_device_platform_data_spi {
	u32 block_delay_us;
	u32 split_read_block_delay_us;
	u32 read_delay_us;
	u32 write_delay_us;
	u32 split_read_byte_delay_us;
	u32 pre_delay_us;
	u32 post_delay_us;
	u8 bits_per_word;
	u16 mode;
	void *cs_assert_data;
	int (*cs_assert)(const void *, const bool);
};

struct rmi_2d_axis_alignment {
	bool swap_axes;
	bool flip_x;
	bool flip_y;
	u16 clip_x_low;
	u16 clip_y_low;
	u16 clip_x_high;
	u16 clip_y_high;
	u16 offset_x;
	u16 offset_y;
	u8 delta_x_threshold;
	u8 delta_y_threshold;
};

struct rmi_2d_sensor_platform_data {
	struct rmi_2d_axis_alignment axis_align;
	enum rmi_sensor_type sensor_type;
	int x_mm;
	int y_mm;
	int disable_report_mask;
	u16 rezero_wait;
	bool topbuttonpad;
	bool kernel_tracking;
	int dmax;
	int dribble;
	int palm_detect;
};

struct rmi_f01_power_management {
	enum rmi_reg_state nosleep;
	u8 wakeup_threshold;
	u8 doze_holdoff;
	u8 doze_interval;
};

struct rmi_gpio_data {
	bool buttonpad;
	bool trackstick_buttons;
	bool disable;
};

struct rmi_device_platform_data {
	int reset_delay_ms;
	int irq;
	struct rmi_device_platform_data_spi spi_data;
	struct rmi_2d_sensor_platform_data sensor_pdata;
	struct rmi_f01_power_management power_management;
	struct rmi_gpio_data gpio_data;
};

struct synaptics_hw_state {
	int x;
	int y;
	int z;
	int w;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int up: 1;
	unsigned int down: 1;
	u8 ext_buttons;
	s8 scroll;
};

struct synaptics_data {
	struct synaptics_device_info info;
	enum synaptics_pkt_type pkt_type;
	u8 mode;
	int scroll;
	bool absolute_mode;
	bool disable_gesture;
	struct serio *pt_port;
	struct synaptics_hw_state agm;
	unsigned int agm_count;
	unsigned long press_start;
	bool press;
	bool report_press;
	bool is_forcepad;
};

struct i2c_spec_values___2 {
	unsigned long min_hold_start_ns;
	unsigned long min_low_ns;
	unsigned long min_high_ns;
	unsigned long min_setup_start_ns;
	unsigned long max_data_hold_ns;
	unsigned long min_data_setup_ns;
	unsigned long min_setup_stop_ns;
	unsigned long min_hold_buffer_ns;
};

struct rk3x_i2c_calced_timings;

struct rk3x_i2c_soc_data {
	int grf_offset;
	int (*calc_timings)(unsigned long, struct i2c_timings *, struct rk3x_i2c_calced_timings *);
};

struct rk3x_i2c_calced_timings {
	unsigned long div_low;
	unsigned long div_high;
	unsigned int tuning;
};

enum rk3x_i2c_state {
	STATE_IDLE___2 = 0,
	STATE_START = 1,
	STATE_READ = 2,
	STATE_WRITE = 3,
	STATE_STOP = 4,
};

enum {
	REG_CON_MOD_TX = 0,
	REG_CON_MOD_REGISTER_TX = 1,
	REG_CON_MOD_RX = 2,
	REG_CON_MOD_REGISTER_RX = 3,
};

struct rk3x_i2c {
	struct i2c_adapter adap;
	struct device *dev;
	const struct rk3x_i2c_soc_data *soc_data;
	void *regs;
	struct clk *clk;
	struct clk *pclk;
	struct notifier_block clk_rate_nb;
	int irq;
	struct i2c_timings t;
	spinlock_t lock;
	wait_queue_head_t wait;
	bool busy;
	struct i2c_msg *msg;
	u8 addr;
	unsigned int mode;
	bool is_last_msg;
	enum rk3x_i2c_state state;
	unsigned int processed;
	int error;
};

struct dm_kobject_holder {
	struct kobject kobj;
	struct completion completion;
};

struct qcom_cpufreq_drv;

struct qcom_cpufreq_match_data {
	int (*get_version)(struct device *, struct nvmem_cell *, char **, struct qcom_cpufreq_drv *);
	const char **genpd_names;
};

struct qcom_cpufreq_drv_cpu {
	int opp_token;
	struct device **virt_devs;
};

struct qcom_cpufreq_drv {
	u32 versions;
	const struct qcom_cpufreq_match_data *data;
	struct qcom_cpufreq_drv_cpu cpus[0];
};

enum ipq806x_versions {
	IPQ8062_VERSION = 0,
	IPQ8064_VERSION = 1,
	IPQ8065_VERSION = 2,
};

enum ipq8074_versions {
	IPQ8074_HAWKEYE_VERSION = 0,
	IPQ8074_ACORN_VERSION = 1,
};

struct sd_busy_data {
	struct mmc_card *card;
	u8 *reg_buf;
};

struct hs_timing {
	u32 drv_phase;
	u32 smpl_dly;
	u32 smpl_phase_max;
	u32 smpl_phase_min;
};

struct k3_priv {
	int ctrl_id;
	u32 cur_speed;
	struct regmap *reg;
};

struct sdhci_msm_variant_ops;

struct sdhci_msm_offset;

struct sdhci_msm_variant_info {
	bool mci_removed;
	bool restore_dll_config;
	const struct sdhci_msm_variant_ops *var_ops;
	const struct sdhci_msm_offset *offset;
};

struct sdhci_msm_variant_ops {
	u32 (*msm_readl_relaxed)(struct sdhci_host *, u32);
	void (*msm_writel_relaxed)(u32, struct sdhci_host *, u32);
};

struct sdhci_msm_offset {
	u32 core_hc_mode;
	u32 core_mci_data_cnt;
	u32 core_mci_status;
	u32 core_mci_fifo_cnt;
	u32 core_mci_version;
	u32 core_generics;
	u32 core_testbus_config;
	u32 core_testbus_sel2_bit;
	u32 core_testbus_ena;
	u32 core_testbus_sel2;
	u32 core_pwrctl_status;
	u32 core_pwrctl_mask;
	u32 core_pwrctl_clear;
	u32 core_pwrctl_ctl;
	u32 core_sdcc_debug_reg;
	u32 core_dll_config;
	u32 core_dll_status;
	u32 core_vendor_spec;
	u32 core_vendor_spec_adma_err_addr0;
	u32 core_vendor_spec_adma_err_addr1;
	u32 core_vendor_spec_func2;
	u32 core_vendor_spec_capabilities0;
	u32 core_ddr_200_cfg;
	u32 core_vendor_spec3;
	u32 core_dll_config_2;
	u32 core_dll_config_3;
	u32 core_ddr_config_old;
	u32 core_ddr_config;
	u32 core_dll_usr_ctl;
};

struct sdhci_msm_host {
	struct platform_device *pdev;
	void *core_mem;
	int pwr_irq;
	struct clk *bus_clk;
	struct clk *xo_clk;
	struct clk_bulk_data bulk_clks[4];
	unsigned long clk_rate;
	struct mmc_host *mmc;
	bool use_14lpp_dll_reset;
	bool tuning_done;
	bool calibration_done;
	u8 saved_tuning_phase;
	bool use_cdclp533;
	u32 curr_pwr_state;
	u32 curr_io_level;
	wait_queue_head_t pwr_irq_wait;
	bool pwr_irq_flag;
	u32 caps_0;
	bool mci_removed;
	bool restore_dll_config;
	const struct sdhci_msm_variant_ops *var_ops;
	const struct sdhci_msm_offset *offset;
	bool use_cdr;
	u32 transfer_mode;
	bool updated_ddr_cfg;
	bool uses_tassadar_dll;
	u32 dll_config;
	u32 ddr_config;
	bool vqmmc_enabled;
};

struct kfifo {
	union {
		struct __kfifo kfifo;
		unsigned char *type;
		const unsigned char *const_type;
		char (*rectype)[0];
		void *ptr;
		const void *ptr_const;
	};
	unsigned char buf[0];
};

struct events_queue {
	size_t sz;
	struct kfifo kfifo;
	struct work_struct notify_work;
	struct workqueue_struct *wq;
};

struct scmi_notify_instance;

struct scmi_event_header;

struct scmi_registered_event;

struct scmi_registered_events_desc {
	u8 id;
	const struct scmi_event_ops *ops;
	struct events_queue equeue;
	struct scmi_notify_instance *ni;
	struct scmi_event_header *eh;
	size_t eh_sz;
	void *in_flight;
	int num_events;
	struct scmi_registered_event **registered_events;
	struct mutex registered_mtx;
	const struct scmi_protocol_handle *ph;
	struct hlist_head registered_events_handlers[64];
};

struct scmi_notify_instance {
	void *gid;
	struct scmi_handle *handle;
	struct work_struct init_work;
	struct workqueue_struct *notify_wq;
	struct mutex pending_mtx;
	struct scmi_registered_events_desc **registered_protocols;
	struct hlist_head pending_events_handlers[16];
};

struct scmi_event_header {
	ktime_t timestamp;
	size_t payld_sz;
	unsigned char evt_id;
	unsigned char payld[0];
};

struct scmi_registered_event {
	struct scmi_registered_events_desc *proto;
	const struct scmi_event *evt;
	void *report;
	u32 num_sources;
	refcount_t *sources;
	struct mutex sources_mtx;
};

struct scmi_event_handler {
	u32 key;
	refcount_t users;
	struct scmi_registered_event *r_evt;
	struct blocking_notifier_head chain;
	struct hlist_node hash;
	bool enabled;
};

struct scmi_notifier_devres {
	const struct scmi_handle *handle;
	u8 proto_id;
	u8 evt_id;
	u32 __src_id;
	u32 *src_id;
	struct notifier_block *nb;
};

struct of_bus___2 {
	void (*count_cells)(const void *, int, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
};

typedef int (*of_irq_init_cb_t)(struct device_node *, struct device_node *);

struct of_intc_desc {
	struct list_head list;
	of_irq_init_cb_t irq_init_cb;
	struct device_node *dev;
	struct device_node *interrupt_parent;
};

struct pcc_mbox_chan {
	struct mbox_chan *mchan;
	u64 shmem_base_addr;
	u64 shmem_size;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
};

struct pcc_chan_reg {
	void *vaddr;
	struct acpi_generic_address *gas;
	u64 preserve_mask;
	u64 set_mask;
	u64 status_mask;
};

struct pcc_chan_info {
	struct pcc_mbox_chan chan;
	struct pcc_chan_reg db;
	struct pcc_chan_reg plat_irq_ack;
	struct pcc_chan_reg cmd_complete;
	struct pcc_chan_reg cmd_update;
	struct pcc_chan_reg error;
	int plat_irq;
	u8 type;
	unsigned int plat_irq_flags;
	bool chan_in_use;
};

enum acpi_pcct_type {
	ACPI_PCCT_TYPE_GENERIC_SUBSPACE = 0,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE = 1,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2 = 2,
	ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE = 3,
	ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE = 4,
	ACPI_PCCT_TYPE_HW_REG_COMM_SUBSPACE = 5,
	ACPI_PCCT_TYPE_RESERVED = 6,
};

struct acpi_pcct_subspace {
	struct acpi_subtable_header header;
	u8 reserved[6];
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_table_pcct {
	struct acpi_table_header header;
	u32 flags;
	u64 reserved;
};

struct acpi_pcct_hw_reduced {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_ext_pcc_master {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved1;
	u64 base_address;
	u32 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u32 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_set_mask;
	u64 reserved2;
	struct acpi_generic_address cmd_complete_register;
	u64 cmd_complete_mask;
	struct acpi_generic_address cmd_update_register;
	u64 cmd_update_preserve_mask;
	u64 cmd_update_set_mask;
	struct acpi_generic_address error_status_register;
	u64 error_status_mask;
} __attribute__((packed));

struct acpi_pcct_hw_reduced_type2 {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_write_mask;
} __attribute__((packed));

struct cluster_pmu;

struct l2cache_pmu {
	struct hlist_node node;
	u32 num_pmus;
	struct pmu pmu;
	int num_counters;
	cpumask_t cpumask;
	struct platform_device *pdev;
	struct cluster_pmu * __attribute__((btf_type_tag("percpu"))) *pmu_cluster;
	struct list_head clusters;
};

struct cluster_pmu {
	struct list_head next;
	struct perf_event *events[9];
	struct l2cache_pmu *l2cache_pmu;
	unsigned long used_counters[1];
	unsigned long used_groups[1];
	int irq;
	int cluster_id;
	int on_cpu;
	cpumask_t cluster_cpus;
	spinlock_t pmu_lock;
};

enum {
	HTE_TS_REGISTERED = 0,
	HTE_TS_REQ = 1,
	HTE_TS_DISABLE = 2,
	HTE_TS_QUEUE_WK = 3,
};

struct hte_ts_info {
	u32 xlated_id;
	unsigned long flags;
	unsigned long hte_cb_flags;
	u64 seq;
	char *line_name;
	bool free_attr_name;
	hte_ts_cb_t cb;
	hte_ts_sec_cb_t tcb;
	atomic_t dropped_ts;
	spinlock_t slock;
	struct work_struct cb_work;
	struct mutex req_mlock;
	struct dentry *ts_dbg_root;
	struct hte_device *gdev;
	void *cl_data;
};

struct hte_device {
	u32 nlines;
	atomic_t ts_req;
	struct device *sdev;
	struct dentry *dbg_root;
	struct list_head list;
	struct hte_chip *chip;
	struct module *owner;
	struct hte_ts_info ei[0];
};

struct soc_mixer_control {
	int min;
	int max;
	int platform_max;
	int reg;
	int rreg;
	unsigned int shift;
	unsigned int rshift;
	unsigned int sign_bit;
	unsigned int invert: 1;
	unsigned int autodisable: 1;
	struct snd_soc_dobj dobj;
};

struct soc_enum {
	int reg;
	unsigned char shift_l;
	unsigned char shift_r;
	unsigned int items;
	unsigned int mask;
	const char * const *texts;
	const unsigned int *values;
	unsigned int autodisable: 1;
	struct snd_soc_dobj dobj;
};

struct dapm_kcontrol_data {
	unsigned int value;
	struct snd_soc_dapm_widget *widget;
	struct list_head paths;
	struct snd_soc_dapm_widget_list *wlist;
};

struct snd_soc_dapm_pinctrl_priv {
	const char *active_state;
	const char *sleep_state;
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

enum {
	FR_ACT_UNSPEC = 0,
	FR_ACT_TO_TBL = 1,
	FR_ACT_GOTO = 2,
	FR_ACT_NOP = 3,
	FR_ACT_RES3 = 4,
	FR_ACT_RES4 = 5,
	FR_ACT_BLACKHOLE = 6,
	FR_ACT_UNREACHABLE = 7,
	FR_ACT_PROHIBIT = 8,
	__FR_ACT_MAX = 9,
};

enum {
	FRA_UNSPEC = 0,
	FRA_DST = 1,
	FRA_SRC = 2,
	FRA_IIFNAME = 3,
	FRA_GOTO = 4,
	FRA_UNUSED2 = 5,
	FRA_PRIORITY = 6,
	FRA_UNUSED3 = 7,
	FRA_UNUSED4 = 8,
	FRA_UNUSED5 = 9,
	FRA_FWMARK = 10,
	FRA_FLOW = 11,
	FRA_TUN_ID = 12,
	FRA_SUPPRESS_IFGROUP = 13,
	FRA_SUPPRESS_PREFIXLEN = 14,
	FRA_TABLE = 15,
	FRA_FWMASK = 16,
	FRA_OIFNAME = 17,
	FRA_PAD = 18,
	FRA_L3MDEV = 19,
	FRA_UID_RANGE = 20,
	FRA_PROTOCOL = 21,
	FRA_IP_PROTO = 22,
	FRA_SPORT_RANGE = 23,
	FRA_DPORT_RANGE = 24,
	__FRA_MAX = 25,
};

struct fib_rule_uid_range {
	__u32 start;
	__u32 end;
};

struct fib_rule_notifier_info {
	struct fib_notifier_info info;
	struct fib_rule *rule;
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[21];
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	unsigned long rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
	INET_FRAG_DROP = 16,
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

struct raw_hashinfo {
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hlist_head ht[256];
};

struct icmp_filter {
	__u32 data;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
	NEXTHOP_EVENT_REPLACE = 1,
	NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE = 2,
	NEXTHOP_EVENT_BUCKET_REPLACE = 3,
};

enum nh_notifier_info_type {
	NH_NOTIFIER_INFO_TYPE_SINGLE = 0,
	NH_NOTIFIER_INFO_TYPE_GRP = 1,
	NH_NOTIFIER_INFO_TYPE_RES_TABLE = 2,
	NH_NOTIFIER_INFO_TYPE_RES_BUCKET = 3,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	NHA_RES_GROUP = 12,
	NHA_RES_BUCKET = 13,
	__NHA_MAX = 14,
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	NEXTHOP_GRP_TYPE_RES = 1,
	__NEXTHOP_GRP_TYPE_MAX = 2,
};

enum {
	NHA_RES_GROUP_UNSPEC = 0,
	NHA_RES_GROUP_PAD = 0,
	NHA_RES_GROUP_BUCKETS = 1,
	NHA_RES_GROUP_IDLE_TIMER = 2,
	NHA_RES_GROUP_UNBALANCED_TIMER = 3,
	NHA_RES_GROUP_UNBALANCED_TIME = 4,
	__NHA_RES_GROUP_MAX = 5,
};

enum {
	NHA_RES_BUCKET_UNSPEC = 0,
	NHA_RES_BUCKET_PAD = 0,
	NHA_RES_BUCKET_INDEX = 1,
	NHA_RES_BUCKET_IDLE_TIME = 2,
	NHA_RES_BUCKET_NH_ID = 3,
	__NHA_RES_BUCKET_MAX = 4,
};

struct nh_notifier_single_info;

struct nh_notifier_grp_info;

struct nh_notifier_res_table_info;

struct nh_notifier_res_bucket_info;

struct nh_notifier_info {
	struct net *net;
	struct netlink_ext_ack *extack;
	u32 id;
	enum nh_notifier_info_type type;
	union {
		struct nh_notifier_single_info *nh;
		struct nh_notifier_grp_info *nh_grp;
		struct nh_notifier_res_table_info *nh_res_table;
		struct nh_notifier_res_bucket_info *nh_res_bucket;
	};
};

struct nh_notifier_single_info {
	struct net_device *dev;
	u8 gw_family;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	};
	u8 is_reject: 1;
	u8 is_fdb: 1;
	u8 has_encap: 1;
};

struct nh_notifier_grp_entry_info {
	u8 weight;
	u32 id;
	struct nh_notifier_single_info nh;
};

struct nh_notifier_grp_info {
	u16 num_nh;
	bool is_fdb;
	struct nh_notifier_grp_entry_info nh_entries[0];
};

struct nh_notifier_res_table_info {
	u16 num_nh_buckets;
	struct nh_notifier_single_info nhs[0];
};

struct nh_notifier_res_bucket_info {
	u16 bucket_index;
	unsigned int idle_timer_ms;
	bool force;
	struct nh_notifier_single_info old_nh;
	struct nh_notifier_single_info new_nh;
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	u16 nh_grp_res_num_buckets;
	unsigned long nh_grp_res_idle_timer;
	unsigned long nh_grp_res_unbalanced_timer;
	bool nh_grp_res_has_num_buckets;
	bool nh_grp_res_has_idle_timer;
	bool nh_grp_res_has_unbalanced_timer;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 resvd1;
	__u16 resvd2;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	unsigned long fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct nh_dump_filter {
	u32 nh_id;
	int dev_idx;
	int master_idx;
	bool group_filter;
	bool fdb_filter;
	u32 res_bucket_nh_id;
};

struct rtm_dump_nh_ctx {
	u32 idx;
};

struct rtm_dump_res_bucket_ctx {
	struct rtm_dump_nh_ctx nh;
	u16 bucket_index;
};

struct rtm_dump_nexthop_bucket_data {
	struct rtm_dump_res_bucket_ctx *ctx;
	struct nh_dump_filter filter;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct gssx_name_attr;

struct gssx_name_attr_array {
	u32 count;
	struct gssx_name_attr *data;
};

typedef struct xdr_netobj gssx_buffer;

struct gssx_option;

struct gssx_option_array {
	u32 count;
	struct gssx_option *data;
};

struct gssx_name_attr {
	gssx_buffer attr;
	gssx_buffer value;
	struct gssx_option_array extensions;
};

struct gssx_option {
	gssx_buffer option;
	gssx_buffer value;
};

typedef struct xdr_netobj utf8string;

struct gssx_call_ctx {
	utf8string locale;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

typedef struct xdr_netobj gssx_OID;

struct gssx_name {
	gssx_buffer display_name;
};

typedef struct gssx_name gssx_name;

struct gssx_ctx {
	gssx_buffer exported_context_token;
	gssx_buffer state;
	u32 need_release;
	gssx_OID mech;
	gssx_name src_name;
	gssx_name targ_name;
	u64 lifetime;
	u64 ctx_flags;
	u32 locally_initiated;
	u32 open;
	struct gssx_option_array options;
};

struct gssx_cred_element;

struct gssx_cred_element_array {
	u32 count;
	struct gssx_cred_element *data;
};

struct gssx_cred {
	gssx_name desired_name;
	struct gssx_cred_element_array elements;
	gssx_buffer cred_handle_reference;
	u32 needs_release;
};

struct gssx_cred_element {
	gssx_name MN;
	gssx_OID mech;
	u32 cred_usage;
	u64 initiator_time_rec;
	u64 acceptor_time_rec;
	struct gssx_option_array options;
};

struct gssx_status {
	u64 major_status;
	gssx_OID mech;
	u64 minor_status;
	utf8string major_status_string;
	utf8string minor_status_string;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_cb;

struct gssx_arg_accept_sec_context {
	struct gssx_call_ctx call_ctx;
	struct gssx_ctx *context_handle;
	struct gssx_cred *cred_handle;
	struct gssp_in_token input_token;
	struct gssx_cb *input_cb;
	u32 ret_deleg_cred;
	struct gssx_option_array options;
	struct page **pages;
	unsigned int npages;
};

struct gssx_cb {
	u64 initiator_addrtype;
	gssx_buffer initiator_address;
	u64 acceptor_addrtype;
	gssx_buffer acceptor_address;
	gssx_buffer application_data;
};

struct gssx_res_accept_sec_context {
	struct gssx_status status;
	struct gssx_ctx *context_handle;
	gssx_buffer *output_token;
	struct gssx_option_array options;
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

enum dns_lookup_status {
	DNS_LOOKUP_NOT_DONE = 0,
	DNS_LOOKUP_GOOD = 1,
	DNS_LOOKUP_GOOD_WITH_BAD = 2,
	DNS_LOOKUP_BAD = 3,
	DNS_LOOKUP_GOT_NOT_FOUND = 4,
	DNS_LOOKUP_GOT_LOCAL_FAILURE = 5,
	DNS_LOOKUP_GOT_TEMP_FAILURE = 6,
	DNS_LOOKUP_GOT_NS_FAILURE = 7,
	NR__dns_lookup_status = 8,
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

struct dns_server_list_v1_header {
	struct dns_payload_header hdr;
	__u8 source;
	__u8 status;
	__u8 nr_servers;
};

enum handshake_msg_type {
	HANDSHAKE_MSG_TYPE_UNSPEC = 0,
	HANDSHAKE_MSG_TYPE_CLIENTHELLO = 1,
	HANDSHAKE_MSG_TYPE_SERVERHELLO = 2,
};

enum handshake_auth {
	HANDSHAKE_AUTH_UNSPEC = 0,
	HANDSHAKE_AUTH_UNAUTH = 1,
	HANDSHAKE_AUTH_PSK = 2,
	HANDSHAKE_AUTH_X509 = 3,
};

enum hr_flags_bits {
	HANDSHAKE_F_REQ_COMPLETED = 0,
	HANDSHAKE_F_REQ_SESSION = 1,
};

enum {
	TLS_ALERT_DESC_CLOSE_NOTIFY = 0,
	TLS_ALERT_DESC_UNEXPECTED_MESSAGE = 10,
	TLS_ALERT_DESC_BAD_RECORD_MAC = 20,
	TLS_ALERT_DESC_RECORD_OVERFLOW = 22,
	TLS_ALERT_DESC_HANDSHAKE_FAILURE = 40,
	TLS_ALERT_DESC_BAD_CERTIFICATE = 42,
	TLS_ALERT_DESC_UNSUPPORTED_CERTIFICATE = 43,
	TLS_ALERT_DESC_CERTIFICATE_REVOKED = 44,
	TLS_ALERT_DESC_CERTIFICATE_EXPIRED = 45,
	TLS_ALERT_DESC_CERTIFICATE_UNKNOWN = 46,
	TLS_ALERT_DESC_ILLEGAL_PARAMETER = 47,
	TLS_ALERT_DESC_UNKNOWN_CA = 48,
	TLS_ALERT_DESC_ACCESS_DENIED = 49,
	TLS_ALERT_DESC_DECODE_ERROR = 50,
	TLS_ALERT_DESC_DECRYPT_ERROR = 51,
	TLS_ALERT_DESC_TOO_MANY_CIDS_REQUESTED = 52,
	TLS_ALERT_DESC_PROTOCOL_VERSION = 70,
	TLS_ALERT_DESC_INSUFFICIENT_SECURITY = 71,
	TLS_ALERT_DESC_INTERNAL_ERROR = 80,
	TLS_ALERT_DESC_INAPPROPRIATE_FALLBACK = 86,
	TLS_ALERT_DESC_USER_CANCELED = 90,
	TLS_ALERT_DESC_MISSING_EXTENSION = 109,
	TLS_ALERT_DESC_UNSUPPORTED_EXTENSION = 110,
	TLS_ALERT_DESC_UNRECOGNIZED_NAME = 112,
	TLS_ALERT_DESC_BAD_CERTIFICATE_STATUS_RESPONSE = 113,
	TLS_ALERT_DESC_UNKNOWN_PSK_IDENTITY = 115,
	TLS_ALERT_DESC_CERTIFICATE_REQUIRED = 116,
	TLS_ALERT_DESC_NO_APPLICATION_PROTOCOL = 120,
};

enum {
	HANDSHAKE_A_ACCEPT_SOCKFD = 1,
	HANDSHAKE_A_ACCEPT_HANDLER_CLASS = 2,
	HANDSHAKE_A_ACCEPT_MESSAGE_TYPE = 3,
	HANDSHAKE_A_ACCEPT_TIMEOUT = 4,
	HANDSHAKE_A_ACCEPT_AUTH_MODE = 5,
	HANDSHAKE_A_ACCEPT_PEER_IDENTITY = 6,
	HANDSHAKE_A_ACCEPT_CERTIFICATE = 7,
	HANDSHAKE_A_ACCEPT_PEERNAME = 8,
	__HANDSHAKE_A_ACCEPT_MAX = 9,
	HANDSHAKE_A_ACCEPT_MAX = 8,
};

enum {
	HANDSHAKE_A_X509_CERT = 1,
	HANDSHAKE_A_X509_PRIVKEY = 2,
	__HANDSHAKE_A_X509_MAX = 3,
	HANDSHAKE_A_X509_MAX = 2,
};

enum {
	HANDSHAKE_A_DONE_STATUS = 1,
	HANDSHAKE_A_DONE_SOCKFD = 2,
	HANDSHAKE_A_DONE_REMOTE_AUTH = 3,
	__HANDSHAKE_A_DONE_MAX = 4,
	HANDSHAKE_A_DONE_MAX = 3,
};

struct tls_handshake_req {
	void (*th_consumer_done)(void *, int, key_serial_t);
	void *th_consumer_data;
	int th_type;
	unsigned int th_timeout_ms;
	int th_auth_mode;
	const char *th_peername;
	key_serial_t th_keyring;
	key_serial_t th_certificate;
	key_serial_t th_privkey;
	unsigned int th_num_peerids;
	key_serial_t th_peerid[5];
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

enum {
	KTW_FREEZABLE = 1,
};

struct kthread_create_info {
	char *full_name;
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct kthread {
	unsigned long flags;
	unsigned int cpu;
	int result;
	int (*threadfn)(void *);
	void *data;
	struct completion parked;
	struct completion exited;
	struct cgroup_subsys_state *blkcg_css;
	char *full_name;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct trace_mark {
	unsigned long long val;
	char sym;
};

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	unsigned long caller[8];
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
};

struct osnoise_entry {
	struct trace_entry ent;
	u64 noise;
	u64 runtime;
	u64 max_sample;
	unsigned int hw_count;
	unsigned int nmi_count;
	unsigned int irq_count;
	unsigned int softirq_count;
	unsigned int thread_count;
};

struct timerlat_entry {
	struct trace_entry ent;
	unsigned int seqnum;
	int context;
	u64 timer_latency;
};

typedef unsigned long perf_trace_t[1024];

struct tcx_entry {
	struct mini_Qdisc __attribute__((btf_type_tag("rcu"))) *miniq;
	struct bpf_mprog_bundle bundle;
	bool miniq_active;
	struct callback_head rcu;
};

struct tcx_link {
	struct bpf_link link;
	struct net_device *dev;
	u32 location;
};

struct swap_cgroup_ctrl {
	struct page **map;
	unsigned long length;
	spinlock_t lock;
};

struct swap_cgroup {
	unsigned short id;
};

struct user_arg_ptr {
	bool is_compat;
	union {
		const char __attribute__((btf_type_tag("user"))) * const __attribute__((btf_type_tag("user"))) *native;
		const compat_uptr_t __attribute__((btf_type_tag("user"))) *compat;
	} ptr;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

struct postprocess_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

enum proc_param {
	Opt_gid___6 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext2_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

struct fat_floppy_defaults {
	unsigned int nr_sectors;
	unsigned int sec_per_clus;
	unsigned int dir_entries;
	unsigned int media;
	unsigned int fat_length;
};

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

enum {
	Opt_check_n = 0,
	Opt_check_r = 1,
	Opt_check_s = 2,
	Opt_uid___6 = 3,
	Opt_gid___7 = 4,
	Opt_umask = 5,
	Opt_dmask = 6,
	Opt_fmask = 7,
	Opt_allow_utime = 8,
	Opt_codepage = 9,
	Opt_usefree = 10,
	Opt_nocase = 11,
	Opt_quiet = 12,
	Opt_showexec = 13,
	Opt_debug___3 = 14,
	Opt_immutable = 15,
	Opt_dots = 16,
	Opt_nodots = 17,
	Opt_charset = 18,
	Opt_shortname_lower = 19,
	Opt_shortname_win95 = 20,
	Opt_shortname_winnt = 21,
	Opt_shortname_mixed = 22,
	Opt_utf8_no = 23,
	Opt_utf8_yes = 24,
	Opt_uni_xl_no = 25,
	Opt_uni_xl_yes = 26,
	Opt_nonumtail_no = 27,
	Opt_nonumtail_yes = 28,
	Opt_obsolete = 29,
	Opt_flush = 30,
	Opt_tz_utc = 31,
	Opt_rodir = 32,
	Opt_err_cont = 33,
	Opt_err_panic = 34,
	Opt_err_ro = 35,
	Opt_discard___2 = 36,
	Opt_nfs = 37,
	Opt_time_offset = 38,
	Opt_nfs_stale_rw = 39,
	Opt_nfs_nostale_ro = 40,
	Opt_err___6 = 41,
	Opt_dos1xfloppy = 42,
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct fat_boot_fsinfo {
	__le32 signature1;
	__le32 reserved1[120];
	__le32 signature2;
	__le32 free_clusters;
	__le32 next_cluster;
	__le32 reserved2[4];
};

struct fat_bios_param_block {
	u16 fat_sector_size;
	u8 fat_sec_per_clus;
	u16 fat_reserved;
	u8 fat_fats;
	u16 fat_dir_entries;
	u16 fat_sectors;
	u16 fat_fat_length;
	u32 fat_total_sect;
	u8 fat16_state;
	u32 fat16_vol_id;
	u32 fat32_length;
	u32 fat32_root_cluster;
	u16 fat32_info_sector;
	u8 fat32_state;
	u32 fat32_vol_id;
};

struct nfs_createdata {
	struct nfs_createargs arg;
	struct nfs_diropok res;
	struct nfs_fh fhandle;
	struct nfs_fattr fattr;
};

enum {
	NFS_DELEGATION_NEED_RECLAIM = 0,
	NFS_DELEGATION_RETURN = 1,
	NFS_DELEGATION_RETURN_IF_CLOSED = 2,
	NFS_DELEGATION_REFERENCED = 3,
	NFS_DELEGATION_RETURNING = 4,
	NFS_DELEGATION_REVOKED = 5,
	NFS_DELEGATION_TEST_EXPIRED = 6,
	NFS_DELEGATION_INODE_FREEING = 7,
	NFS_DELEGATION_RETURN_DELAYED = 8,
};

enum {
	NSMPROC_NULL = 0,
	NSMPROC_STAT = 1,
	NSMPROC_MON = 2,
	NSMPROC_UNMON = 3,
	NSMPROC_UNMON_ALL = 4,
	NSMPROC_SIMU_CRASH = 5,
	NSMPROC_NOTIFY = 6,
};

struct nsm_args {
	struct nsm_private *priv;
	u32 prog;
	u32 vers;
	u32 proc;
	char *mon_name;
	const char *nodename;
};

struct nsm_res {
	u32 status;
	u32 state;
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct skcipher_walk {
	union {
		struct {
			struct page *page;
			unsigned long offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			unsigned long offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct crypto_report_blkcipher {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

struct asymmetric_key_ids {
	void *id[3];
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

struct pkcs7_parse_context {
	struct pkcs7_message *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	unsigned long data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

enum {
	DIO_SHOULD_DIRTY = 1,
	DIO_IS_SYNC = 2,
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	unsigned int flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bio bio;
	long: 64;
};

struct blk_ia_range_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_independent_access_range *, char *);
};

struct io_xattr {
	struct file *file;
	struct xattr_ctx ctx;
	struct filename *filename;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u32 len;
	rwf_t flags;
};

struct io_rw_state {
	struct iov_iter iter;
	struct iov_iter_state iter_state;
	struct iovec fast_iov[8];
};

struct io_async_rw {
	struct io_rw_state s;
	const struct iovec *free_iovec;
	size_t bytes_done;
	struct wait_page_queue wpq;
};

struct wait_page_key {
	struct folio *folio;
	int bit_nr;
	int page_match;
};

struct mvebu_pic {
	void *base;
	u32 parent_irq;
	struct irq_domain *domain;
	struct platform_device *pdev;
};

struct uniphier_aidet_priv {
	struct irq_domain *domain;
	void *reg_base;
	spinlock_t lock;
	u32 saved_vals[8];
};

struct hisi_lpc_dev {
	spinlock_t cycle_lock;
	void *membase;
	struct logic_pio_hwaddr *io_host;
};

struct lpc_cycle_para {
	unsigned int opflags;
	unsigned int csize;
};

struct hisi_lpc_acpi_cell {
	const char *hid;
	const struct platform_device_info *pdevinfo;
};

struct histb_combphy_mode {
	int fixed;
	int select;
	u32 reg;
	u32 shift;
	u32 mask;
};

struct histb_combphy_priv {
	void *mmio;
	struct regmap *syscon;
	struct reset_control *por_rst;
	struct clk *ref_clk;
	struct phy *phy;
	struct histb_combphy_mode mode;
};

struct uniphier_u3ssphy_param {
	struct {
		int reg_no;
		int msb;
		int lsb;
	} field;
	u8 value;
};

struct uniphier_u3ssphy_soc_data {
	bool is_legacy;
	int nparams;
	const struct uniphier_u3ssphy_param param[7];
};

struct uniphier_u3ssphy_priv {
	struct device *dev;
	void *base;
	struct clk *clk;
	struct clk *clk_ext;
	struct clk *clk_parent;
	struct clk *clk_parent_gio;
	struct reset_control *rst;
	struct reset_control *rst_parent;
	struct reset_control *rst_parent_gio;
	struct regulator *vbus;
	const struct uniphier_u3ssphy_soc_data *data;
};

struct rtd_pin_group_desc;

struct rtd_pin_func_desc;

struct rtd_pin_desc;

struct rtd_pin_config_desc;

struct rtd_pin_sconfig_desc;

struct rtd_pin_reg_list;

struct rtd_pinctrl_desc {
	const struct pinctrl_pin_desc *pins;
	unsigned int num_pins;
	const struct rtd_pin_group_desc *groups;
	unsigned int num_groups;
	const struct rtd_pin_func_desc *functions;
	unsigned int num_functions;
	const struct rtd_pin_desc *muxes;
	unsigned int num_muxes;
	const struct rtd_pin_config_desc *configs;
	unsigned int num_configs;
	const struct rtd_pin_sconfig_desc *sconfigs;
	unsigned int num_sconfigs;
	struct rtd_pin_reg_list *lists;
	unsigned int num_regs;
};

struct rtd_pin_group_desc {
	const char *name;
	const unsigned int *pins;
	unsigned int num_pins;
};

struct rtd_pin_func_desc {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct rtd_pin_mux_desc;

struct rtd_pin_desc {
	const char *name;
	unsigned int mux_offset;
	u32 mux_mask;
	const struct rtd_pin_mux_desc *functions;
};

struct rtd_pin_mux_desc {
	const char *name;
	u32 mux_value;
};

struct rtd_pin_config_desc {
	const char *name;
	unsigned int reg_offset;
	unsigned int base_bit;
	unsigned int pud_en_offset;
	unsigned int pud_sel_offset;
	unsigned int curr_offset;
	unsigned int smt_offset;
	unsigned int power_offset;
	unsigned int curr_type;
};

struct rtd_pin_sconfig_desc {
	const char *name;
	unsigned int reg_offset;
	unsigned int dcycle_offset;
	unsigned int dcycle_maskbits;
	unsigned int ndrive_offset;
	unsigned int ndrive_maskbits;
	unsigned int pdrive_offset;
	unsigned int pdrive_maskbits;
};

struct rtd_pin_reg_list {
	unsigned int reg_offset;
	unsigned int val;
};

struct pwm_export {
	struct device child;
	struct pwm_device *pwm;
	struct mutex lock;
	struct pwm_state suspend;
};

struct portdrv_service_data {
	struct pcie_port_service_driver *drv;
	struct device *dev;
	u32 service;
};

typedef int (*pcie_callback_t)(struct pcie_device *);

struct aperture_range {
	struct device *dev;
	resource_size_t base;
	resource_size_t size;
	struct list_head lh;
	void (*detach)(struct device *);
};

struct pcc_data {
	struct pcc_mbox_chan *pcc_chan;
	void *pcc_comm_addr;
	struct completion done;
	struct mbox_client cl;
	struct acpi_pcc_info ctx;
};

struct acpi_rw_lock {
	void *writer_mutex;
	void *reader_mutex;
	u32 num_readers;
};

enum {
	ACPI_BUTTON_LID_INIT_IGNORE = 0,
	ACPI_BUTTON_LID_INIT_OPEN = 1,
	ACPI_BUTTON_LID_INIT_METHOD = 2,
	ACPI_BUTTON_LID_INIT_DISABLED = 3,
};

struct acpi_button {
	unsigned int type;
	struct input_dev *input;
	char phys[32];
	unsigned long pushed;
	int last_state;
	ktime_t last_time;
	bool suspended;
	bool lid_state_initialized;
};

struct hi655x_clk {
	struct hi655x_pmic *hi655x;
	struct clk_hw clk_hw;
};

struct clk_pllv2 {
	struct clk_hw hw;
	void *base;
};

struct clk_regmap_gate_data {
	unsigned int offset;
	u8 bit_idx;
	u8 flags;
};

struct clk_regmap_div_data {
	unsigned int offset;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
};

struct clk_regmap_mux_data {
	unsigned int offset;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
};

struct frac_entry {
	int num;
	int den;
};

struct mn {
	u8 mnctr_en_bit;
	u8 mnctr_reset_bit;
	u8 mnctr_mode_shift;
	u8 n_val_shift;
	u8 m_val_shift;
	u8 width;
	bool reset_in_cc;
};

struct pre_div {
	u8 pre_div_shift;
	u8 pre_div_width;
};

struct src_sel {
	u8 src_sel_shift;
	const struct parent_map *parent_map;
};

struct clk_rcg {
	u32 ns_reg;
	u32 md_reg;
	struct mn mn;
	struct pre_div p;
	struct src_sel s;
	const struct freq_tbl *freq_tbl;
	struct clk_regmap clkr;
};

struct clk_dyn_rcg {
	u32 ns_reg[2];
	u32 md_reg[2];
	u32 bank_reg;
	u8 mux_sel_bit;
	struct mn mn[2];
	struct pre_div p[2];
	struct src_sel s[2];
	const struct freq_tbl *freq_tbl;
	struct clk_regmap clkr;
};

struct rockchip_clk_frac {
	struct notifier_block clk_nb;
	struct clk_fractional_divider div;
	struct clk_gate gate;
	struct clk_mux mux;
	const struct clk_ops *mux_ops;
	int mux_frac_idx;
	bool rate_change_remuxed;
	int rate_change_idx;
};

struct samsung_clock_reg_cache {
	struct list_head node;
	void *reg_base;
	struct samsung_clk_reg_dump *rdump;
	unsigned int rd_num;
	const struct samsung_clk_reg_dump *rsuspend;
	unsigned int rsuspend_num;
};

struct samsung_clock_alias {
	unsigned int id;
	const char *dev_name;
	const char *alias;
};

struct tegra210_clk_emc_provider;

struct tegra210_clk_emc {
	struct clk_hw hw;
	void *regs;
	struct tegra210_clk_emc_provider *provider;
	struct clk *parents[8];
};

struct tegra210_clk_emc_config;

struct tegra210_clk_emc_provider {
	struct module *owner;
	struct device *dev;
	struct tegra210_clk_emc_config *configs;
	unsigned int num_configs;
	int (*set_rate)(struct device *, const struct tegra210_clk_emc_config *);
};

struct tegra210_clk_emc_config {
	unsigned long rate;
	bool same_freq;
	u32 value;
	unsigned long parent_rate;
	u8 parent;
};

struct dma_chan_tbl_ent {
	struct dma_chan *chan;
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct apple_sart;

struct apple_sart_ops {
	void (*get_entry)(struct apple_sart *, int, u8 *, phys_addr_t *, size_t *);
	void (*set_entry)(struct apple_sart *, int, u8, phys_addr_t, size_t);
	unsigned int size_shift;
	unsigned int paddr_shift;
	size_t size_max;
};

struct apple_sart {
	struct device *dev;
	void *regs;
	const struct apple_sart_ops *ops;
	unsigned long protected_entries;
	unsigned long used_entries;
};

struct qmp_cooling_device;

struct qmp {
	void *msgram;
	struct device *dev;
	struct mbox_client mbox_client;
	struct mbox_chan *mbox_chan;
	size_t offset;
	size_t size;
	wait_queue_head_t event;
	struct mutex tx_lock;
	struct clk_hw qdss_clk;
	struct qmp_cooling_device *cooling_devs;
};

struct qmp_cooling_device {
	struct thermal_cooling_device *cdev;
	struct qmp *qmp;
	char *name;
	bool state;
};

enum tegra_suspend_mode {
	TEGRA_SUSPEND_NONE = 0,
	TEGRA_SUSPEND_LP2 = 1,
	TEGRA_SUSPEND_LP1 = 2,
	TEGRA_SUSPEND_LP0 = 3,
	TEGRA_MAX_SUSPEND_MODE = 4,
	TEGRA_SUSPEND_NOT_READY = 5,
};

struct tegra_pmc_soc;

struct tegra_pmc {
	struct device *dev;
	void *base;
	void *wake;
	void *aotag;
	void *scratch;
	struct clk *clk;
	const struct tegra_pmc_soc *soc;
	bool tz_only;
	unsigned long rate;
	enum tegra_suspend_mode suspend_mode;
	u32 cpu_good_time;
	u32 cpu_off_time;
	u32 core_osc_time;
	u32 core_pmu_time;
	u32 core_off_time;
	bool corereq_high;
	bool sysclkreq_high;
	bool combined_req;
	bool cpu_pwr_good_en;
	u32 lp0_vec_phys;
	u32 lp0_vec_size;
	unsigned long powergates_available[1];
	struct mutex powergates_lock;
	struct pinctrl_dev *pctl_dev;
	struct irq_domain *domain;
	struct irq_chip irq;
	struct notifier_block clk_nb;
	bool core_domain_state_synced;
	bool core_domain_registered;
	unsigned long *wake_type_level_map;
	unsigned long *wake_type_dual_edge_map;
	unsigned long *wake_sw_status_map;
	unsigned long *wake_cntrl_level_map;
	struct syscore_ops syscore;
};

struct tegra_io_pad_soc;

struct tegra_pmc_regs;

struct tegra_wake_event;

struct pmc_clk_init_data;

struct tegra_pmc_soc {
	unsigned int num_powergates;
	const char * const *powergates;
	unsigned int num_cpu_powergates;
	const u8 *cpu_powergates;
	bool has_tsense_reset;
	bool has_gpu_clamps;
	bool needs_mbist_war;
	bool has_impl_33v_pwr;
	bool maybe_tz_only;
	const struct tegra_io_pad_soc *io_pads;
	unsigned int num_io_pads;
	const struct pinctrl_pin_desc *pin_descs;
	unsigned int num_pin_descs;
	const struct tegra_pmc_regs *regs;
	void (*init)(struct tegra_pmc *);
	void (*setup_irq_polarity)(struct tegra_pmc *, struct device_node *, bool);
	void (*set_wake_filters)(struct tegra_pmc *);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*powergate_set)(struct tegra_pmc *, unsigned int, bool);
	const char * const *reset_sources;
	unsigned int num_reset_sources;
	const char * const *reset_levels;
	unsigned int num_reset_levels;
	const struct tegra_wake_event *wake_events;
	unsigned int num_wake_events;
	unsigned int max_wake_events;
	unsigned int max_wake_vectors;
	const struct pmc_clk_init_data *pmc_clks_data;
	unsigned int num_pmc_clks;
	bool has_blink_output;
	bool has_usb_sleepwalk;
	bool supports_core_domain;
};

enum tegra_io_pad {
	TEGRA_IO_PAD_AUDIO = 0,
	TEGRA_IO_PAD_AUDIO_HV = 1,
	TEGRA_IO_PAD_BB = 2,
	TEGRA_IO_PAD_CAM = 3,
	TEGRA_IO_PAD_COMP = 4,
	TEGRA_IO_PAD_CONN = 5,
	TEGRA_IO_PAD_CSIA = 6,
	TEGRA_IO_PAD_CSIB = 7,
	TEGRA_IO_PAD_CSIC = 8,
	TEGRA_IO_PAD_CSID = 9,
	TEGRA_IO_PAD_CSIE = 10,
	TEGRA_IO_PAD_CSIF = 11,
	TEGRA_IO_PAD_CSIG = 12,
	TEGRA_IO_PAD_CSIH = 13,
	TEGRA_IO_PAD_DAP3 = 14,
	TEGRA_IO_PAD_DAP5 = 15,
	TEGRA_IO_PAD_DBG = 16,
	TEGRA_IO_PAD_DEBUG_NONAO = 17,
	TEGRA_IO_PAD_DMIC = 18,
	TEGRA_IO_PAD_DMIC_HV = 19,
	TEGRA_IO_PAD_DP = 20,
	TEGRA_IO_PAD_DSI = 21,
	TEGRA_IO_PAD_DSIB = 22,
	TEGRA_IO_PAD_DSIC = 23,
	TEGRA_IO_PAD_DSID = 24,
	TEGRA_IO_PAD_EDP = 25,
	TEGRA_IO_PAD_EMMC = 26,
	TEGRA_IO_PAD_EMMC2 = 27,
	TEGRA_IO_PAD_EQOS = 28,
	TEGRA_IO_PAD_GPIO = 29,
	TEGRA_IO_PAD_GP_PWM2 = 30,
	TEGRA_IO_PAD_GP_PWM3 = 31,
	TEGRA_IO_PAD_HDMI = 32,
	TEGRA_IO_PAD_HDMI_DP0 = 33,
	TEGRA_IO_PAD_HDMI_DP1 = 34,
	TEGRA_IO_PAD_HDMI_DP2 = 35,
	TEGRA_IO_PAD_HDMI_DP3 = 36,
	TEGRA_IO_PAD_HSIC = 37,
	TEGRA_IO_PAD_HV = 38,
	TEGRA_IO_PAD_LVDS = 39,
	TEGRA_IO_PAD_MIPI_BIAS = 40,
	TEGRA_IO_PAD_NAND = 41,
	TEGRA_IO_PAD_PEX_BIAS = 42,
	TEGRA_IO_PAD_PEX_CLK_BIAS = 43,
	TEGRA_IO_PAD_PEX_CLK1 = 44,
	TEGRA_IO_PAD_PEX_CLK2 = 45,
	TEGRA_IO_PAD_PEX_CLK3 = 46,
	TEGRA_IO_PAD_PEX_CLK_2_BIAS = 47,
	TEGRA_IO_PAD_PEX_CLK_2 = 48,
	TEGRA_IO_PAD_PEX_CNTRL = 49,
	TEGRA_IO_PAD_PEX_CTL2 = 50,
	TEGRA_IO_PAD_PEX_L0_RST = 51,
	TEGRA_IO_PAD_PEX_L1_RST = 52,
	TEGRA_IO_PAD_PEX_L5_RST = 53,
	TEGRA_IO_PAD_PWR_CTL = 54,
	TEGRA_IO_PAD_SDMMC1 = 55,
	TEGRA_IO_PAD_SDMMC1_HV = 56,
	TEGRA_IO_PAD_SDMMC2 = 57,
	TEGRA_IO_PAD_SDMMC2_HV = 58,
	TEGRA_IO_PAD_SDMMC3 = 59,
	TEGRA_IO_PAD_SDMMC3_HV = 60,
	TEGRA_IO_PAD_SDMMC4 = 61,
	TEGRA_IO_PAD_SOC_GPIO10 = 62,
	TEGRA_IO_PAD_SOC_GPIO12 = 63,
	TEGRA_IO_PAD_SOC_GPIO13 = 64,
	TEGRA_IO_PAD_SOC_GPIO53 = 65,
	TEGRA_IO_PAD_SPI = 66,
	TEGRA_IO_PAD_SPI_HV = 67,
	TEGRA_IO_PAD_SYS_DDC = 68,
	TEGRA_IO_PAD_UART = 69,
	TEGRA_IO_PAD_UART4 = 70,
	TEGRA_IO_PAD_UART5 = 71,
	TEGRA_IO_PAD_UFS = 72,
	TEGRA_IO_PAD_USB0 = 73,
	TEGRA_IO_PAD_USB1 = 74,
	TEGRA_IO_PAD_USB2 = 75,
	TEGRA_IO_PAD_USB3 = 76,
	TEGRA_IO_PAD_USB_BIAS = 77,
	TEGRA_IO_PAD_AO_HV = 78,
};

struct tegra_io_pad_soc {
	enum tegra_io_pad id;
	unsigned int dpd;
	unsigned int request;
	unsigned int status;
	unsigned int voltage;
	const char *name;
};

struct tegra_pmc_regs {
	unsigned int scratch0;
	unsigned int rst_status;
	unsigned int rst_source_shift;
	unsigned int rst_source_mask;
	unsigned int rst_level_shift;
	unsigned int rst_level_mask;
};

struct tegra_wake_event {
	const char *name;
	unsigned int id;
	unsigned int irq;
	struct {
		unsigned int instance;
		unsigned int pin;
	} gpio;
};

struct pmc_clk_init_data {
	char *name;
	const char * const *parents;
	int num_parents;
	int clk_id;
	u8 mux_shift;
	u8 force_en_shift;
};

struct tegra_powergate___2 {
	struct generic_pm_domain genpd;
	struct tegra_pmc *pmc;
	unsigned int id;
	struct clk **clks;
	unsigned int num_clks;
	unsigned long *clk_rates;
	struct reset_control *reset;
};

struct pmc_clk {
	struct clk_hw hw;
	unsigned long offs;
	u32 mux_shift;
	u32 force_en_shift;
};

struct pmc_clk_gate {
	struct clk_hw hw;
	unsigned long offs;
	u32 shift;
};

struct rcar_gen4_sysc_pd {
	struct generic_pm_domain genpd;
	u8 pdr;
	unsigned int flags;
	char name[0];
};

struct rcar_gen4_pm_domains {
	struct genpd_onecell_data onecell_data;
	struct generic_pm_domain *domains[65];
};

struct xen_memory_reservation {
	__guest_handle_xen_pfn_t extent_start;
	xen_ulong_t nr_extents;
	unsigned int extent_order;
	unsigned int address_bits;
	domid_t domid;
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	unsigned short iomem_reg_shift;
};

enum {
	PLAT8250_DEV_LEGACY = -1,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

struct irq_info___2 {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct plat_serial8250_port {
	unsigned long iobase;
	void *membase;
	resource_size_t mapbase;
	resource_size_t mapsize;
	unsigned int uartclk;
	unsigned int irq;
	unsigned long irqflags;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	unsigned char has_sysrq;
	unsigned int type;
	upf_t flags;
	u16 bugs;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	u32 (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, u32);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

struct timer_rand_state {
	unsigned long last_time;
	long last_delta;
	long last_delta2;
};

enum {
	CRNG_EMPTY = 0,
	CRNG_EARLY = 1,
	CRNG_READY = 2,
};

struct batch_u8 {
	u8 entropy[96];
	local_lock_t lock;
	unsigned long generation;
	unsigned int position;
};

struct batch_u16 {
	u16 entropy[48];
	local_lock_t lock;
	unsigned long generation;
	unsigned int position;
};

struct batch_u32 {
	u32 entropy[24];
	local_lock_t lock;
	unsigned long generation;
	unsigned int position;
};

struct batch_u64 {
	u64 entropy[12];
	local_lock_t lock;
	unsigned long generation;
	unsigned int position;
};

struct crng {
	u8 key[32];
	unsigned long generation;
	local_lock_t lock;
};

struct fast_pool {
	unsigned long pool[4];
	unsigned long last;
	unsigned int count;
	struct timer_list mix;
};

enum {
	MIX_INFLIGHT = 2147483648,
};

enum blake2s_iv {
	BLAKE2S_IV0 = 1779033703,
	BLAKE2S_IV1 = 3144134277,
	BLAKE2S_IV2 = 1013904242,
	BLAKE2S_IV3 = 2773480762,
	BLAKE2S_IV4 = 1359893119,
	BLAKE2S_IV5 = 2600822924,
	BLAKE2S_IV6 = 528734635,
	BLAKE2S_IV7 = 1541459225,
};

enum chacha_constants {
	CHACHA_CONSTANT_EXPA = 1634760805,
	CHACHA_CONSTANT_ND_3 = 857760878,
	CHACHA_CONSTANT_2_BY = 2036477234,
	CHACHA_CONSTANT_TE_K = 1797285236,
};

enum {
	POOL_BITS = 256,
	POOL_READY_BITS = 256,
	POOL_EARLY_BITS = 128,
};

enum {
	CRNG_RESEED_START_INTERVAL = 250,
	CRNG_RESEED_INTERVAL = 15000,
};

enum {
	NUM_TRIAL_SAMPLES = 8192,
	MAX_SAMPLES_PER_BIT = 16,
};

struct entropy_timer_state {
	unsigned long entropy;
	struct timer_list timer;
	atomic_t samples;
	unsigned int samples_per_bit;
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

struct suspend_stats {
	int success;
	int fail;
	int failed_freeze;
	int failed_prepare;
	int failed_suspend;
	int failed_suspend_late;
	int failed_suspend_noirq;
	int failed_resume;
	int failed_resume_early;
	int failed_resume_noirq;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	u64 last_hw_sleep;
	u64 total_hw_sleep;
	u64 max_hw_sleep;
	enum suspend_stat_step failed_steps[2];
};

typedef int (*pm_callback_t)(struct device *);

struct rk8xx_i2c_platform_data {
	const struct regmap_config *regmap_cfg;
	int variant;
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

struct ata_eh_cmd_timeout_ent {
	const u8 *commands;
	const unsigned int *timeouts;
};

enum {
	ATA_EH_SPDN_NCQ_OFF = 1,
	ATA_EH_SPDN_SPEED_DOWN = 2,
	ATA_EH_SPDN_FALLBACK_TO_PIO = 4,
	ATA_EH_SPDN_KEEP_ERRORS = 8,
	ATA_EFLAG_IS_IO = 1,
	ATA_EFLAG_DUBIOUS_XFER = 2,
	ATA_EFLAG_OLD_ER = -2147483648,
	ATA_ECAT_NONE = 0,
	ATA_ECAT_ATA_BUS = 1,
	ATA_ECAT_TOUT_HSM = 2,
	ATA_ECAT_UNK_DEV = 3,
	ATA_ECAT_DUBIOUS_NONE = 4,
	ATA_ECAT_DUBIOUS_ATA_BUS = 5,
	ATA_ECAT_DUBIOUS_TOUT_HSM = 6,
	ATA_ECAT_DUBIOUS_UNK_DEV = 7,
	ATA_ECAT_NR = 8,
	ATA_EH_CMD_DFL_TIMEOUT = 5000,
	ATA_EH_RESET_COOL_DOWN = 5000,
	ATA_EH_PRERESET_TIMEOUT = 10000,
	ATA_EH_FASTDRAIN_INTERVAL = 3000,
	ATA_EH_UA_TRIES = 5,
	ATA_EH_PROBE_TRIAL_INTERVAL = 60000,
	ATA_EH_PROBE_TRIALS = 2,
};

enum {
	ATA_READID_POSTRESET = 1,
	ATA_DNXFER_PIO = 0,
	ATA_DNXFER_DMA = 1,
	ATA_DNXFER_40C = 2,
	ATA_DNXFER_FORCE_PIO = 3,
	ATA_DNXFER_FORCE_PIO0 = 4,
	ATA_DNXFER_QUIET = -2147483648,
};

enum ata_lpm_hints {
	ATA_LPM_EMPTY = 1,
	ATA_LPM_HIPM = 2,
	ATA_LPM_WAKE_ONLY = 4,
};

struct speed_down_verdict_arg {
	u64 since;
	int xfer_ok;
	int nr_errors[8];
};

enum mtd_file_modes {
	MTD_FILE_MODE_NORMAL = 0,
	MTD_FILE_MODE_OTP_FACTORY = 1,
	MTD_FILE_MODE_OTP_USER = 2,
	MTD_FILE_MODE_RAW = 3,
};

struct mtd_write_req {
	__u64 start;
	__u64 len;
	__u64 ooblen;
	__u64 usr_data;
	__u64 usr_oob;
	__u8 mode;
	__u8 padding[7];
};

struct mtd_read_req_ecc_stats {
	__u32 uncorrectable_errors;
	__u32 corrected_bitflips;
	__u32 max_bitflips;
};

struct mtd_read_req {
	__u64 start;
	__u64 len;
	__u64 ooblen;
	__u64 usr_data;
	__u64 usr_oob;
	__u8 mode;
	__u8 padding[7];
	struct mtd_read_req_ecc_stats ecc_stats;
};

struct mtd_file_info {
	struct mtd_info *mtd;
	enum mtd_file_modes mode;
};

struct mtd_oob_buf32 {
	u_int32_t start;
	u_int32_t length;
	compat_caddr_t ptr;
};

struct blkpg_compat_ioctl_arg {
	compat_int_t op;
	compat_int_t flags;
	compat_int_t datalen;
	compat_uptr_t data;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void __attribute__((btf_type_tag("user"))) *data;
};

struct mtd_info_user {
	__u8 type;
	__u32 flags;
	__u32 size;
	__u32 erasesize;
	__u32 writesize;
	__u32 oobsize;
	__u64 padding;
};

struct erase_info_user64 {
	__u64 start;
	__u64 length;
};

struct erase_info_user {
	__u32 start;
	__u32 length;
};

struct mtd_oob_buf {
	__u32 start;
	__u32 length;
	unsigned char __attribute__((btf_type_tag("user"))) *ptr;
};

struct mtd_oob_buf64 {
	__u64 start;
	__u32 pad;
	__u32 length;
	__u64 usr_ptr;
};

struct nand_oobinfo {
	__u32 useecc;
	__u32 eccbytes;
	__u32 oobfree[16];
	__u32 eccpos[32];
};

struct region_info_user {
	__u32 offset;
	__u32 erasesize;
	__u32 numblocks;
	__u32 regionindex;
};

struct nand_oobfree {
	__u32 offset;
	__u32 length;
};

struct nand_ecclayout_user {
	__u32 eccbytes;
	__u32 eccpos[64];
	__u32 oobavail;
	struct nand_oobfree oobfree[8];
};

struct blkpg_partition {
	long long start;
	long long length;
	int pno;
	char devname[64];
	char volname[64];
};

enum ssp_interface {
	SSP_INTERFACE_MOTOROLA_SPI = 0,
	SSP_INTERFACE_TI_SYNC_SERIAL = 1,
	SSP_INTERFACE_NATIONAL_MICROWIRE = 2,
	SSP_INTERFACE_UNIDIRECTIONAL = 3,
};

enum ssp_hierarchy {
	SSP_MASTER = 0,
	SSP_SLAVE = 1,
};

struct ssp_clock_params {
	u8 cpsdvsr;
	u8 scr;
};

enum ssp_mode {
	INTERRUPT_TRANSFER = 0,
	POLLING_TRANSFER = 1,
	DMA_TRANSFER = 2,
};

enum ssp_rx_level_trig {
	SSP_RX_1_OR_MORE_ELEM = 0,
	SSP_RX_4_OR_MORE_ELEM = 1,
	SSP_RX_8_OR_MORE_ELEM = 2,
	SSP_RX_16_OR_MORE_ELEM = 3,
	SSP_RX_32_OR_MORE_ELEM = 4,
};

enum ssp_tx_level_trig {
	SSP_TX_1_OR_MORE_EMPTY_LOC = 0,
	SSP_TX_4_OR_MORE_EMPTY_LOC = 1,
	SSP_TX_8_OR_MORE_EMPTY_LOC = 2,
	SSP_TX_16_OR_MORE_EMPTY_LOC = 3,
	SSP_TX_32_OR_MORE_EMPTY_LOC = 4,
};

enum ssp_microwire_ctrl_len {
	SSP_BITS_4 = 3,
	SSP_BITS_5 = 4,
	SSP_BITS_6 = 5,
	SSP_BITS_7 = 6,
	SSP_BITS_8 = 7,
	SSP_BITS_9 = 8,
	SSP_BITS_10 = 9,
	SSP_BITS_11 = 10,
	SSP_BITS_12 = 11,
	SSP_BITS_13 = 12,
	SSP_BITS_14 = 13,
	SSP_BITS_15 = 14,
	SSP_BITS_16 = 15,
	SSP_BITS_17 = 16,
	SSP_BITS_18 = 17,
	SSP_BITS_19 = 18,
	SSP_BITS_20 = 19,
	SSP_BITS_21 = 20,
	SSP_BITS_22 = 21,
	SSP_BITS_23 = 22,
	SSP_BITS_24 = 23,
	SSP_BITS_25 = 24,
	SSP_BITS_26 = 25,
	SSP_BITS_27 = 26,
	SSP_BITS_28 = 27,
	SSP_BITS_29 = 28,
	SSP_BITS_30 = 29,
	SSP_BITS_31 = 30,
	SSP_BITS_32 = 31,
};

enum ssp_microwire_wait_state {
	SSP_MWIRE_WAIT_ZERO = 0,
	SSP_MWIRE_WAIT_ONE = 1,
};

enum ssp_duplex {
	SSP_MICROWIRE_CHANNEL_FULL_DUPLEX = 0,
	SSP_MICROWIRE_CHANNEL_HALF_DUPLEX = 1,
};

enum ssp_clkdelay {
	SSP_FEEDBACK_CLK_DELAY_NONE = 0,
	SSP_FEEDBACK_CLK_DELAY_1T = 1,
	SSP_FEEDBACK_CLK_DELAY_2T = 2,
	SSP_FEEDBACK_CLK_DELAY_3T = 3,
	SSP_FEEDBACK_CLK_DELAY_4T = 4,
	SSP_FEEDBACK_CLK_DELAY_5T = 5,
	SSP_FEEDBACK_CLK_DELAY_6T = 6,
	SSP_FEEDBACK_CLK_DELAY_7T = 7,
};

struct pl022_config_chip {
	enum ssp_interface iface;
	enum ssp_hierarchy hierarchy;
	bool slave_tx_disable;
	struct ssp_clock_params clk_freq;
	enum ssp_mode com_mode;
	enum ssp_rx_level_trig rx_lev_trig;
	enum ssp_tx_level_trig tx_lev_trig;
	enum ssp_microwire_ctrl_len ctrl_len;
	enum ssp_microwire_wait_state wait_state;
	enum ssp_duplex duplex;
	enum ssp_clkdelay clkdelay;
};

struct vendor_data___2 {
	int fifodepth;
	int max_bpw;
	bool unidir;
	bool extended_cr;
	bool pl023;
	bool loopback;
	bool internal_cs_ctrl;
};

enum ssp_reading {
	READING_NULL = 0,
	READING_U8 = 1,
	READING_U16 = 2,
	READING_U32 = 3,
};

enum ssp_writing {
	WRITING_NULL = 0,
	WRITING_U8 = 1,
	WRITING_U16 = 2,
	WRITING_U32 = 3,
};

enum ssp_rx_endian {
	SSP_RX_MSB = 0,
	SSP_RX_LSB = 1,
};

enum ssp_tx_endian {
	SSP_TX_MSB = 0,
	SSP_TX_LSB = 1,
};

enum ssp_spi_clk_pol {
	SSP_CLK_POL_IDLE_LOW = 0,
	SSP_CLK_POL_IDLE_HIGH = 1,
};

enum ssp_spi_clk_phase {
	SSP_CLK_FIRST_EDGE = 0,
	SSP_CLK_SECOND_EDGE = 1,
};

enum ssp_loopback {
	LOOPBACK_DISABLED = 0,
	LOOPBACK_ENABLED = 1,
};

enum ssp_chip_select {
	SSP_CHIP_SELECT = 0,
	SSP_CHIP_DESELECT = 1,
};

enum ssp_data_size {
	SSP_DATA_BITS_4 = 3,
	SSP_DATA_BITS_5 = 4,
	SSP_DATA_BITS_6 = 5,
	SSP_DATA_BITS_7 = 6,
	SSP_DATA_BITS_8 = 7,
	SSP_DATA_BITS_9 = 8,
	SSP_DATA_BITS_10 = 9,
	SSP_DATA_BITS_11 = 10,
	SSP_DATA_BITS_12 = 11,
	SSP_DATA_BITS_13 = 12,
	SSP_DATA_BITS_14 = 13,
	SSP_DATA_BITS_15 = 14,
	SSP_DATA_BITS_16 = 15,
	SSP_DATA_BITS_17 = 16,
	SSP_DATA_BITS_18 = 17,
	SSP_DATA_BITS_19 = 18,
	SSP_DATA_BITS_20 = 19,
	SSP_DATA_BITS_21 = 20,
	SSP_DATA_BITS_22 = 21,
	SSP_DATA_BITS_23 = 22,
	SSP_DATA_BITS_24 = 23,
	SSP_DATA_BITS_25 = 24,
	SSP_DATA_BITS_26 = 25,
	SSP_DATA_BITS_27 = 26,
	SSP_DATA_BITS_28 = 27,
	SSP_DATA_BITS_29 = 28,
	SSP_DATA_BITS_30 = 29,
	SSP_DATA_BITS_31 = 30,
	SSP_DATA_BITS_32 = 31,
};

struct pl022_ssp_controller;

struct chip_data___2;

struct pl022 {
	struct amba_device *adev;
	struct vendor_data___2 *vendor;
	resource_size_t phybase;
	void *virtbase;
	struct clk *clk;
	struct spi_controller *host;
	struct pl022_ssp_controller *host_info;
	struct tasklet_struct pump_transfers;
	struct spi_message *cur_msg;
	struct spi_transfer *cur_transfer;
	struct chip_data___2 *cur_chip;
	bool next_msg_cs_active;
	void *tx;
	void *tx_end;
	void *rx;
	void *rx_end;
	enum ssp_reading read;
	enum ssp_writing write;
	u32 exp_fifo_level;
	enum ssp_rx_level_trig rx_lev_trig;
	enum ssp_tx_level_trig tx_lev_trig;
	struct dma_chan *dma_rx_channel;
	struct dma_chan *dma_tx_channel;
	struct sg_table sgt_rx;
	struct sg_table sgt_tx;
	char *dummypage;
	bool dma_running;
	int cur_cs;
	struct gpio_desc *cur_gpiod;
};

struct pl022_ssp_controller {
	u16 bus_id;
	u8 enable_dma: 1;
	bool (*dma_filter)(struct dma_chan *, void *);
	void *dma_rx_param;
	void *dma_tx_param;
	int autosuspend_delay;
	bool rt;
};

struct chip_data___2 {
	u32 cr0;
	u16 cr1;
	u16 dmacr;
	u16 cpsr;
	u8 n_bytes;
	bool enable_dma;
	enum ssp_reading read;
	enum ssp_writing write;
	int xfer_type;
};

struct fman_mac___2;

struct mac_device___2 {
	void *vaddr;
	struct device *dev;
	struct resource *res;
	u8 addr[6];
	struct fman_port *port[2];
	struct phylink *phylink;
	struct phylink_config phylink_config;
	phy_interface_t phy_if;
	bool promisc;
	bool allmulti;
	const struct phylink_mac_ops *phylink_ops;
	int (*enable)(struct fman_mac___2 *);
	void (*disable)(struct fman_mac___2 *);
	int (*set_promisc)(struct fman_mac___2 *, bool);
	int (*change_addr)(struct fman_mac___2 *, const enet_addr_t *);
	int (*set_allmulti)(struct fman_mac___2 *, bool);
	int (*set_tstamp)(struct fman_mac___2 *, bool);
	int (*set_multi)(struct net_device *, struct mac_device___2 *);
	int (*set_exception)(struct fman_mac___2 *, enum fman_mac_exceptions, bool);
	int (*add_hash_mac_addr)(struct fman_mac___2 *, enet_addr_t *);
	int (*remove_hash_mac_addr)(struct fman_mac___2 *, enet_addr_t *);
	void (*update_speed)(struct mac_device___2 *, int);
	struct fman_mac___2 *fman_mac;
	struct mac_priv_s *priv;
};

typedef void fman_mac_exception_cb___2(struct mac_device___2 *, enum fman_mac_exceptions);

struct dtsec_regs;

struct dtsec_cfg;

struct fman_mac___2 {
	struct dtsec_regs *regs;
	u64 addr;
	phy_interface_t phy_if;
	u16 max_speed;
	struct mac_device___2 *dev_id;
	fman_mac_exception_cb___2 *exception_cb;
	fman_mac_exception_cb___2 *event_cb;
	u8 num_of_ind_addr_in_regs;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	bool ptp_tsu_enabled;
	bool en_tsu_err_exception;
	struct dtsec_cfg *dtsec_drv_param;
	void *fm;
	struct fman_rev_info fm_rev_info;
	bool basex_if;
	struct mdio_device *tbidev;
	struct phylink_pcs pcs;
};

struct dtsec_regs {
	u32 tsec_id;
	u32 tsec_id2;
	u32 ievent;
	u32 imask;
	u32 reserved0010[1];
	u32 ecntrl;
	u32 ptv;
	u32 tbipa;
	u32 tmr_ctrl;
	u32 tmr_pevent;
	u32 tmr_pemask;
	u32 reserved002c[5];
	u32 tctrl;
	u32 reserved0044[3];
	u32 rctrl;
	u32 reserved0054[11];
	u32 igaddr[8];
	u32 gaddr[8];
	u32 reserved00c0[16];
	u32 maccfg1;
	u32 maccfg2;
	u32 ipgifg;
	u32 hafdup;
	u32 maxfrm;
	u32 reserved0114[10];
	u32 ifstat;
	u32 macstnaddr1;
	u32 macstnaddr2;
	struct {
		u32 exact_match1;
		u32 exact_match2;
	} macaddr[15];
	u32 reserved01c0[16];
	u32 tr64;
	u32 tr127;
	u32 tr255;
	u32 tr511;
	u32 tr1k;
	u32 trmax;
	u32 trmgv;
	u32 rbyt;
	u32 rpkt;
	u32 rfcs;
	u32 rmca;
	u32 rbca;
	u32 rxcf;
	u32 rxpf;
	u32 rxuo;
	u32 raln;
	u32 rflr;
	u32 rcde;
	u32 rcse;
	u32 rund;
	u32 rovr;
	u32 rfrg;
	u32 rjbr;
	u32 rdrp;
	u32 tbyt;
	u32 tpkt;
	u32 tmca;
	u32 tbca;
	u32 txpf;
	u32 tdfr;
	u32 tedf;
	u32 tscl;
	u32 tmcl;
	u32 tlcl;
	u32 txcl;
	u32 tncl;
	u32 reserved0290[1];
	u32 tdrp;
	u32 tjbr;
	u32 tfcs;
	u32 txcf;
	u32 tovr;
	u32 tund;
	u32 tfrg;
	u32 car1;
	u32 car2;
	u32 cam1;
	u32 cam2;
	u32 reserved02c0[848];
};

struct dtsec_cfg {
	u16 halfdup_retransmit;
	u16 halfdup_coll_window;
	bool tx_pad_crc;
	u16 tx_pause_time;
	bool ptp_tsu_en;
	bool ptp_exception_en;
	u32 preamble_len;
	u32 rx_prepend;
	u16 tx_pause_time_extd;
	u16 maximum_frame;
	u32 non_back_to_back_ipg1;
	u32 non_back_to_back_ipg2;
	u32 min_ifg_enforcement;
	u32 back_to_back_ipg;
};

struct fman_mac_params___2 {
	u8 mac_id;
	void *fm;
	fman_mac_exception_cb___2 *event_cb;
	fman_mac_exception_cb___2 *exception_cb;
};

enum hclge_ptp_udp_type {
	HCLGE_PTP_UDP_NOT_TYPE = 0,
	HCLGE_PTP_UDP_P13F_TYPE = 1,
	HCLGE_PTP_UDP_P140_TYPE = 2,
	HCLGE_PTP_UDP_FULL_TYPE = 3,
};

enum hclge_ptp_msg0_type {
	HCLGE_PTP_MSG0_V2_DELAY_REQ = 1,
	HCLGE_PTP_MSG0_V2_PDELAY_REQ = 2,
	HCLGE_PTP_MSG0_V2_DELAY_RESP = 3,
	HCLGE_PTP_MSG0_V2_EVENT = 15,
};

enum hclge_ptp_msg_type {
	HCLGE_PTP_MSG_TYPE_V2_L2 = 0,
	HCLGE_PTP_MSG_TYPE_V2 = 1,
	HCLGE_PTP_MSG_TYPE_V2_EVENT = 2,
};

struct hclge_ptp_cfg_cmd {
	__le32 cfg;
	u8 rsvd[20];
};

struct hclge_ptp_int_cmd {
	u8 int_en;
	u8 rsvd[23];
};

enum E1000_INVM_STRUCTURE_TYPE {
	E1000_INVM_UNINITIALIZED_STRUCTURE = 0,
	E1000_INVM_WORD_AUTOLOAD_STRUCTURE = 1,
	E1000_INVM_CSR_AUTOLOAD_STRUCTURE = 2,
	E1000_INVM_PHY_REGISTER_AUTOLOAD_STRUCTURE = 3,
	E1000_INVM_RSA_KEY_SHA256_STRUCTURE = 4,
	E1000_INVM_INVALIDATED_STRUCTURE = 15,
};

struct e1000_fw_version {
	u32 etrack_id;
	u16 eep_major;
	u16 eep_minor;
	u16 eep_build;
	u8 invm_major;
	u8 invm_minor;
	u8 invm_img_type;
	bool or_valid;
	u16 or_major;
	u16 or_build;
	u16 or_patch;
};

enum e1000_mac_type___3 {
	e1000_undefined___3 = 0,
	e1000_vfadapt = 1,
	e1000_vfadapt_i350 = 2,
	e1000_num_macs___3 = 3,
};

struct e1000_dev_spec_vf {
	u32 vf_number;
	u32 v2p_mailbox;
};

struct e1000_hw___4;

struct e1000_mac_operations___3 {
	s32 (*init_params)(struct e1000_hw___4 *);
	s32 (*check_for_link)(struct e1000_hw___4 *);
	void (*clear_vfta)(struct e1000_hw___4 *);
	s32 (*get_bus_info)(struct e1000_hw___4 *);
	s32 (*get_link_up_info)(struct e1000_hw___4 *, u16 *, u16 *);
	void (*update_mc_addr_list)(struct e1000_hw___4 *, u8 *, u32, u32, u32);
	s32 (*set_uc_addr)(struct e1000_hw___4 *, u32, u8 *);
	s32 (*reset_hw)(struct e1000_hw___4 *);
	s32 (*init_hw)(struct e1000_hw___4 *);
	s32 (*setup_link)(struct e1000_hw___4 *);
	void (*write_vfta)(struct e1000_hw___4 *, u32, u32);
	void (*mta_set)(struct e1000_hw___4 *, u32);
	void (*rar_set)(struct e1000_hw___4 *, u8 *, u32);
	s32 (*read_mac_addr)(struct e1000_hw___4 *);
	s32 (*set_vfta)(struct e1000_hw___4 *, u16, bool);
};

struct e1000_mac_info___3 {
	struct e1000_mac_operations___3 ops;
	u8 addr[6];
	u8 perm_addr[6];
	enum e1000_mac_type___3 type;
	u16 mta_reg_count;
	u16 rar_entry_count;
	bool get_link_status;
};

struct e1000_mbx_operations___2 {
	s32 (*init_params)(struct e1000_hw___4 *);
	s32 (*read)(struct e1000_hw___4 *, u32 *, u16);
	s32 (*write)(struct e1000_hw___4 *, u32 *, u16);
	s32 (*read_posted)(struct e1000_hw___4 *, u32 *, u16);
	s32 (*write_posted)(struct e1000_hw___4 *, u32 *, u16);
	s32 (*check_for_msg)(struct e1000_hw___4 *);
	s32 (*check_for_ack)(struct e1000_hw___4 *);
	s32 (*check_for_rst)(struct e1000_hw___4 *);
};

struct e1000_mbx_info___2 {
	struct e1000_mbx_operations___2 ops;
	struct e1000_mbx_stats stats;
	u32 timeout;
	u32 usec_delay;
	u16 size;
};

struct e1000_hw___4 {
	void *back;
	u8 *hw_addr;
	u8 *flash_address;
	unsigned long io_base;
	struct e1000_mac_info___3 mac;
	struct e1000_mbx_info___2 mbx;
	spinlock_t mbx_lock;
	union {
		struct e1000_dev_spec_vf vf;
	} dev_spec;
	u16 device_id;
	u16 subsystem_vendor_id;
	u16 subsystem_device_id;
	u16 vendor_id;
	u8 revision_id;
};

struct igbvf_stats {
	char stat_string[32];
	int sizeof_stat;
	int stat_offset;
	int base_stat_offset;
};

enum igbvf_state_t {
	__IGBVF_TESTING = 0,
	__IGBVF_RESETTING = 1,
	__IGBVF_DOWN = 2,
};

struct e1000_vf_stats {
	u64 base_gprc;
	u64 base_gptc;
	u64 base_gorc;
	u64 base_gotc;
	u64 base_mprc;
	u64 base_gotlbc;
	u64 base_gptlbc;
	u64 base_gorlbc;
	u64 base_gprlbc;
	u32 last_gprc;
	u32 last_gptc;
	u32 last_gorc;
	u32 last_gotc;
	u32 last_mprc;
	u32 last_gotlbc;
	u32 last_gptlbc;
	u32 last_gorlbc;
	u32 last_gprlbc;
	u64 gprc;
	u64 gptc;
	u64 gorc;
	u64 gotc;
	u64 mprc;
	u64 gotlbc;
	u64 gptlbc;
	u64 gorlbc;
	u64 gprlbc;
};

struct igbvf_queue_stats {
	u64 packets;
	u64 bytes;
};

struct igbvf_adapter;

union igbvf_desc;

struct igbvf_buffer;

struct igbvf_ring {
	struct igbvf_adapter *adapter;
	union igbvf_desc *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	u16 next_to_use;
	u16 next_to_clean;
	u16 head;
	u16 tail;
	struct igbvf_buffer *buffer_info;
	struct napi_struct napi;
	char name[21];
	u32 eims_value;
	u32 itr_val;
	enum latency_range itr_range;
	u16 itr_register;
	int set_itr;
	struct sk_buff *rx_skb_top;
	struct igbvf_queue_stats stats;
};

struct igbvf_info;

struct igbvf_adapter {
	struct timer_list watchdog_timer;
	struct timer_list blink_timer;
	struct work_struct reset_task;
	struct work_struct watchdog_task;
	const struct igbvf_info *ei;
	unsigned long active_vlans[64];
	u32 bd_number;
	u32 rx_buffer_len;
	u32 polling_interval;
	u16 mng_vlan_id;
	u16 link_speed;
	u16 link_duplex;
	spinlock_t tx_queue_lock;
	unsigned long state;
	u32 requested_itr;
	u32 current_itr;
	struct igbvf_ring *tx_ring;
	unsigned int restart_queue;
	u32 txd_cmd;
	u32 tx_int_delay;
	u32 tx_abs_int_delay;
	unsigned int total_tx_bytes;
	unsigned int total_tx_packets;
	unsigned int total_rx_bytes;
	unsigned int total_rx_packets;
	u32 tx_timeout_count;
	u32 tx_fifo_head;
	u32 tx_head_addr;
	u32 tx_fifo_size;
	u32 tx_dma_failed;
	struct igbvf_ring *rx_ring;
	u32 rx_int_delay;
	u32 rx_abs_int_delay;
	u64 hw_csum_err;
	u64 hw_csum_good;
	u64 rx_hdr_split;
	u32 alloc_rx_buff_failed;
	u32 rx_dma_failed;
	unsigned int rx_ps_hdr_size;
	u32 max_frame_size;
	u32 min_frame_size;
	struct net_device *netdev;
	struct pci_dev *pdev;
	spinlock_t stats_lock;
	struct e1000_hw___4 hw;
	struct e1000_vf_stats stats;
	u64 zero_base;
	struct igbvf_ring test_tx_ring;
	struct igbvf_ring test_rx_ring;
	u32 test_icr;
	u32 msg_enable;
	struct msix_entry *msix_entries;
	int int_mode;
	u32 eims_enable_mask;
	u32 eims_other;
	u32 int_counter0;
	u32 int_counter1;
	u32 eeprom_wol;
	u32 wol;
	u32 pba;
	bool fc_autoneg;
	unsigned long led_status;
	unsigned int flags;
	unsigned long last_reset;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct igbvf_info {
	enum e1000_mac_type___3 mac;
	unsigned int flags;
	u32 pba;
	void (*init_ops)(struct e1000_hw___4 *);
	s32 (*get_variants)(struct igbvf_adapter *);
};

union e1000_adv_rx_desc {
	struct {
		__le64 pkt_addr;
		__le64 hdr_addr;
	} read;
	struct {
		struct {
			union {
				__le32 data;
				struct {
					__le16 pkt_info;
					__le16 hdr_info;
				} hs_rss;
			} lo_dword;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length;
			__le16 vlan;
		} upper;
	} wb;
};

struct e1000_adv_tx_context_desc {
	__le32 vlan_macip_lens;
	__le32 seqnum_seed;
	__le32 type_tucmd_mlhl;
	__le32 mss_l4len_idx;
};

union igbvf_desc {
	union e1000_adv_rx_desc rx_desc;
	union e1000_adv_tx_desc tx_desc;
	struct e1000_adv_tx_context_desc tx_context_desc;
};

struct igbvf_buffer {
	dma_addr_t dma;
	struct sk_buff *skb;
	union {
		struct {
			unsigned long time_stamp;
			union e1000_adv_tx_desc *next_to_watch;
			u16 length;
			u16 mapped_as_page;
		};
		struct {
			struct page *page;
			u64 page_dma;
			unsigned int page_offset;
		};
	};
};

struct smsc911x_data;

struct smsc911x_ops {
	u32 (*reg_read)(struct smsc911x_data *, u32);
	void (*reg_write)(struct smsc911x_data *, u32, u32);
	void (*rx_readfifo)(struct smsc911x_data *, unsigned int *, unsigned int);
	void (*tx_writefifo)(struct smsc911x_data *, unsigned int *, unsigned int);
};

struct smsc911x_platform_config {
	unsigned int irq_polarity;
	unsigned int irq_type;
	unsigned int flags;
	unsigned int shift;
	phy_interface_t phy_interface;
	unsigned char mac[6];
};

struct smsc911x_data {
	void *ioaddr;
	unsigned int idrev;
	unsigned int generation;
	struct smsc911x_platform_config config;
	spinlock_t mac_lock;
	spinlock_t dev_lock;
	struct mii_bus *mii_bus;
	unsigned int using_extphy;
	int last_duplex;
	int last_carrier;
	u32 msg_enable;
	unsigned int gpio_setting;
	unsigned int gpio_orig_setting;
	struct net_device *dev;
	struct napi_struct napi;
	unsigned int software_irq_signal;
	char loopback_tx_pkt[64];
	char loopback_rx_pkt[64];
	unsigned int resetcount;
	unsigned int multicast_update_pending;
	unsigned int set_bits_mask;
	unsigned int clear_bits_mask;
	unsigned int hashhi;
	unsigned int hashlo;
	const struct smsc911x_ops *ops;
	struct regulator_bulk_data supplies[2];
	struct gpio_desc *reset_gpiod;
	struct clk *clk;
};

struct usb_class_driver {
	char *name;
	char * (*devnode)(const struct device *, umode_t *);
	const struct file_operations *fops;
	int minor_base;
};

struct musb_temp_buffer {
	void *kmalloc_ptr;
	void *old_xfer_buffer;
	u8 data[0];
};

struct rtd119x_rtc {
	void *base;
	struct clk *clk;
	struct rtc_device *rtcdev;
	unsigned int base_year;
};

enum i2c_type_exynos {
	I2C_TYPE_EXYNOS5 = 0,
	I2C_TYPE_EXYNOS7 = 1,
	I2C_TYPE_EXYNOSAUTOV9 = 2,
};

struct exynos_hsi2c_variant {
	unsigned int fifo_depth;
	enum i2c_type_exynos hw;
};

struct exynos5_i2c {
	struct i2c_adapter adap;
	struct i2c_msg *msg;
	struct completion msg_complete;
	unsigned int msg_ptr;
	unsigned int irq;
	void *regs;
	struct clk *clk;
	struct clk *pclk;
	struct device *dev;
	int state;
	spinlock_t lock;
	int trans_done;
	unsigned int atomic;
	unsigned int op_clock;
	const struct exynos_hsi2c_variant *variant;
};

struct bsc_clk_param {
	u32 hz;
	u32 scl_mask;
	u32 div_mask;
};

enum bsc_xfer_cmd {
	CMD_WR = 0,
	CMD_RD = 1,
	CMD_WR_NOACK = 2,
	CMD_RD_NOACK = 3,
};

struct bsc_regs;

struct brcmstb_i2c_dev {
	struct device *device;
	void *base;
	int irq;
	struct bsc_regs *bsc_regmap;
	struct i2c_adapter adapter;
	struct completion done;
	u32 clk_freq_hz;
	int data_regsz;
	bool atomic;
};

struct bsc_regs {
	u32 chip_address;
	u32 data_in[8];
	u32 cnt_reg;
	u32 ctl_reg;
	u32 iic_enable;
	u32 data_out[8];
	u32 ctlhi_reg;
	u32 scl_param;
};

struct sp805_wdt {
	struct watchdog_device wdd;
	spinlock_t lock;
	void *base;
	struct clk *clk;
	u64 rate;
	struct amba_device *adev;
	unsigned int load_val;
};

struct mtk_mmc_compatible {
	u8 clk_div_bits;
	bool recheck_sdio_irq;
	bool hs400_tune;
	u32 pad_tune_reg;
	bool async_fifo;
	bool data_tune;
	bool busy_check;
	bool stop_clk_fix;
	bool enhance_rx;
	bool support_64g;
	bool use_internal_cd;
};

struct mt_gpdma_desc;

struct mt_bdma_desc;

struct msdc_dma {
	struct scatterlist *sg;
	struct mt_gpdma_desc *gpd;
	struct mt_bdma_desc *bd;
	dma_addr_t gpd_addr;
	dma_addr_t bd_addr;
};

struct msdc_save_para {
	u32 msdc_cfg;
	u32 iocon;
	u32 sdc_cfg;
	u32 pad_tune;
	u32 patch_bit0;
	u32 patch_bit1;
	u32 patch_bit2;
	u32 pad_ds_tune;
	u32 pad_cmd_tune;
	u32 emmc50_cfg0;
	u32 emmc50_cfg3;
	u32 sdc_fifo_cfg;
	u32 emmc_top_control;
	u32 emmc_top_cmd;
	u32 emmc50_pad_ds_tune;
};

struct msdc_tune_para {
	u32 iocon;
	u32 pad_tune;
	u32 pad_cmd_tune;
	u32 emmc_top_control;
	u32 emmc_top_cmd;
};

struct msdc_host {
	struct device *dev;
	const struct mtk_mmc_compatible *dev_comp;
	int cmd_rsp;
	spinlock_t lock;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
	int error;
	void *base;
	void *top_base;
	struct msdc_dma dma;
	u64 dma_mask;
	u32 timeout_ns;
	u32 timeout_clks;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_uhs;
	struct pinctrl_state *pins_eint;
	struct delayed_work req_timeout;
	int irq;
	int eint_irq;
	struct reset_control *reset;
	struct clk *src_clk;
	struct clk *h_clk;
	struct clk *bus_clk;
	struct clk *src_clk_cg;
	struct clk *sys_clk_cg;
	struct clk *crypto_clk;
	struct clk_bulk_data bulk_clks[3];
	u32 mclk;
	u32 src_clk_freq;
	unsigned char timing;
	bool vqmmc_enabled;
	u32 latch_ck;
	u32 hs400_ds_delay;
	u32 hs400_ds_dly3;
	u32 hs200_cmd_int_delay;
	u32 hs400_cmd_int_delay;
	bool hs400_cmd_resp_sel_rising;
	bool hs400_mode;
	bool hs400_tuning;
	bool internal_cd;
	bool cqhci;
	struct msdc_save_para save_para;
	struct msdc_tune_para def_tune_para;
	struct msdc_tune_para saved_tune_para;
	struct cqhci_host *cq_host;
	u32 cq_ssc1_time;
};

struct mt_gpdma_desc {
	u32 gpd_info;
	u32 next;
	u32 ptr;
	u32 gpd_data_len;
	u32 arg;
	u32 blknum;
	u32 cmd;
};

struct mt_bdma_desc {
	u32 bd_info;
	u32 next;
	u32 ptr;
	u32 bd_data_len;
};

struct msdc_delay_phase {
	u8 maxlen;
	u8 start;
	u8 final_phase;
};

enum {
	UFS_REG_OCPTHRTL = 192,
	UFS_REG_OOCPR = 196,
	UFS_REG_CDACFG = 208,
	UFS_REG_CDATX1 = 212,
	UFS_REG_CDATX2 = 216,
	UFS_REG_CDARX1 = 220,
	UFS_REG_CDARX2 = 224,
	UFS_REG_CDASTA = 228,
	UFS_REG_LBMCFG = 240,
	UFS_REG_LBMSTA = 244,
	UFS_REG_UFSMODE = 248,
	UFS_REG_HCLKDIV = 252,
};

struct ufs_hisi_host {
	struct ufs_hba *hba;
	void *ufs_sys_ctrl;
	struct reset_control *rst;
	uint64_t caps;
	bool in_suspend;
};

struct ufs_dev_params {
	u32 pwm_rx_gear;
	u32 pwm_tx_gear;
	u32 hs_rx_gear;
	u32 hs_tx_gear;
	u32 rx_lanes;
	u32 tx_lanes;
	u32 rx_pwr_pwm;
	u32 tx_pwr_pwm;
	u32 rx_pwr_hs;
	u32 tx_pwr_hs;
	u32 hs_rate;
	u32 desired_working_mode;
};

enum scmi_clock_protocol_cmd {
	CLOCK_ATTRIBUTES = 3,
	CLOCK_DESCRIBE_RATES = 4,
	CLOCK_RATE_SET = 5,
	CLOCK_RATE_GET = 6,
	CLOCK_CONFIG_SET = 7,
	CLOCK_NAME_GET = 8,
	CLOCK_RATE_NOTIFY = 9,
	CLOCK_RATE_CHANGE_REQUESTED_NOTIFY = 10,
	CLOCK_CONFIG_GET = 11,
	CLOCK_POSSIBLE_PARENTS_GET = 12,
	CLOCK_PARENT_SET = 13,
	CLOCK_PARENT_GET = 14,
};

enum clk_state {
	CLK_STATE_DISABLE = 0,
	CLK_STATE_ENABLE = 1,
	CLK_STATE_RESERVED = 2,
	CLK_STATE_UNCHANGED = 3,
};

struct scmi_clk_ipriv {
	struct device *dev;
	u32 clk_id;
	struct scmi_clock_info *clk;
};

struct clock_info {
	u32 version;
	int num_clocks;
	int max_async_req;
	atomic_t cur_async_req;
	struct scmi_clock_info *clk;
	int (*clock_config_set)(const struct scmi_protocol_handle *, u32, enum clk_state, u8, u32, bool);
	int (*clock_config_get)(const struct scmi_protocol_handle *, u32, u8, u32 *, bool *, u32 *, bool);
};

struct scmi_msg_resp_clock_protocol_attributes {
	__le16 num_clocks;
	u8 max_async_req;
	u8 reserved;
};

struct scmi_msg_resp_clock_attributes {
	__le32 attributes;
	u8 name[16];
	__le32 clock_enable_latency;
};

struct scmi_msg_clock_rate_notify {
	__le32 clk_id;
	__le32 notify_enable;
};

struct scmi_msg_clock_config_set_v2 {
	__le32 id;
	__le32 attributes;
	__le32 oem_config_val;
};

struct scmi_msg_clock_config_get {
	__le32 id;
	__le32 flags;
};

struct scmi_msg_resp_clock_config_get {
	__le32 attributes;
	__le32 config;
	__le32 oem_config_val;
};

struct scmi_msg_clock_config_set {
	__le32 id;
	__le32 attributes;
};

struct scmi_msg_clock_possible_parents {
	__le32 id;
	__le32 skip_parents;
};

struct scmi_msg_resp_clock_possible_parents {
	__le32 num_parent_flags;
	__le32 possible_parents[0];
};

struct scmi_msg_clock_describe_rates {
	__le32 id;
	__le32 rate_index;
};

struct scmi_msg_resp_clock_describe_rates {
	__le32 num_rates_flags;
	struct {
		__le32 value_low;
		__le32 value_high;
	} rate[0];
};

struct scmi_clock_set_rate {
	__le32 flags;
	__le32 id;
	__le32 value_low;
	__le32 value_high;
};

struct scmi_msg_resp_set_rate_complete {
	__le32 id;
	__le32 rate_low;
	__le32 rate_high;
};

struct scmi_msg_clock_set_parent {
	__le32 id;
	__le32 parent_id;
};

struct scmi_clock_rate_notify_payld {
	__le32 agent_id;
	__le32 clock_id;
	__le32 rate_low;
	__le32 rate_high;
};

struct scmi_clock_rate_notif_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int clock_id;
	unsigned long long rate;
};

struct scmi_mailbox {
	struct mbox_client cl;
	struct mbox_chan *chan;
	struct mbox_chan *chan_receiver;
	struct scmi_chan_info *cinfo;
	struct scmi_shared_mem *shmem;
};

struct cper_mem_err_compact {
	u64 validation_bits;
	u16 node;
	u16 card;
	u16 module;
	u16 bank;
	u16 device;
	u16 row;
	u16 column;
	u16 bit_pos;
	u64 requestor_id;
	u64 responder_id;
	u64 target_id;
	u16 rank;
	u16 mem_array_handle;
	u16 mem_dev_handle;
	u8 extended;
} __attribute__((packed));

struct cper_sec_proc_generic {
	u64 validation_bits;
	u8 proc_type;
	u8 proc_isa;
	u8 proc_error_type;
	u8 operation;
	u8 flags;
	u8 level;
	u16 reserved;
	u64 cpu_version;
	char cpu_brand[128];
	u64 proc_id;
	u64 target_addr;
	u64 requestor_id;
	u64 responder_id;
	u64 ip;
};

struct cper_sec_fw_err_rec_ref {
	u8 record_type;
	u8 revision;
	u8 reserved[6];
	u64 record_identifier;
	guid_t record_identifier_guid;
};

struct font_desc {
	int idx;
	const char *name;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	const void *data;
	int pref;
};

struct sp804_clkevt {
	void *base;
	void *load;
	void *load_h;
	void *value;
	void *value_h;
	void *ctrl;
	void *intclr;
	void *ris;
	void *mis;
	void *bgload;
	void *bgload_h;
	unsigned long reload;
	int width;
};

struct sp804_timer {
	int load;
	int load_h;
	int value;
	int value_h;
	int ctrl;
	int intclr;
	int ris;
	int mis;
	int bgload;
	int bgload_h;
	int timer_base[2];
	int width;
};

struct ec_host_request_i2c {
	uint8_t command_protocol;
	struct ec_host_request ec_request;
} __attribute__((packed));

struct ec_host_response {
	uint8_t struct_version;
	uint8_t checksum;
	uint16_t result;
	uint16_t data_len;
	uint16_t reserved;
};

struct ec_host_response_i2c {
	uint8_t result;
	uint8_t packet_length;
	struct ec_host_response ec_response;
};

typedef int (*rproc_handle_resource_t)(struct rproc *, void *, int, int);

enum rproc_features {
	RPROC_FEAT_ATTACH_ON_RECOVERY = 0,
	RPROC_MAX_FEATURES = 1,
};

enum rsc_handling_status {
	RSC_HANDLED = 0,
	RSC_IGNORED = 1,
};

struct optee_supp_req {
	struct list_head link;
	bool in_queue;
	u32 func;
	u32 ret;
	size_t num_params;
	struct tee_param *param;
	struct completion c;
};

enum snd_jack_types {
	SND_JACK_HEADPHONE = 1,
	SND_JACK_MICROPHONE = 2,
	SND_JACK_HEADSET = 3,
	SND_JACK_LINEOUT = 4,
	SND_JACK_MECHANICAL = 8,
	SND_JACK_VIDEOOUT = 16,
	SND_JACK_AVOUT = 20,
	SND_JACK_LINEIN = 32,
	SND_JACK_BTN_0 = 16384,
	SND_JACK_BTN_1 = 8192,
	SND_JACK_BTN_2 = 4096,
	SND_JACK_BTN_3 = 2048,
	SND_JACK_BTN_4 = 1024,
	SND_JACK_BTN_5 = 512,
};

struct snd_jack_kctl {
	struct snd_kcontrol *kctl;
	struct list_head list;
	unsigned int mask_bits;
	struct snd_jack *jack;
	bool sw_inject_enable;
};

struct sch_frag_data {
	unsigned long dst;
	struct qdisc_skb_cb cb;
	__be16 inner_protocol;
	u16 vlan_tci;
	__be16 vlan_proto;
	unsigned int l2_len;
	u8 l2_data[18];
	int (*xmit)(struct sk_buff *);
};

struct tc_skb_cb {
	struct qdisc_skb_cb qdisc_cb;
	u16 mru;
	u8 post_ct: 1;
	u8 post_ct_snat: 1;
	u8 post_ct_dnat: 1;
	u16 zone;
};

struct nf_loginfo {
	u_int8_t type;
	union {
		struct {
			u_int32_t copy_len;
			u_int16_t group;
			u_int16_t qthreshold;
			u_int16_t flags;
		} ulog;
		struct {
			u_int8_t level;
			u_int8_t logflags;
		} log;
	} u;
};

struct nf_log_buf {
	unsigned int count;
	char buf[1020];
};

struct fib_prop {
	int error;
	u8 scope;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct rpc_cb_add_xprt_calldata {
	struct rpc_xprt_switch *xps;
	struct rpc_xprt *xprt;
};

struct connect_timeout_data {
	unsigned long connect_timeout;
	unsigned long reconnect_timeout;
};

struct reg_mask_range {
	__u64 addr;
	__u32 range;
	__u32 reserved[13];
};

struct kvm_pgtable_walk_data {
	struct kvm_pgtable_walker *walker;
	const u64 start;
	u64 addr;
	const u64 end;
};

struct hyp_map_data {
	const u64 phys;
	kvm_pte_t attr;
};

struct stage2_map_data {
	const u64 phys;
	kvm_pte_t attr;
	u8 owner_id;
	kvm_pte_t *anchor;
	kvm_pte_t *childp;
	struct kvm_s2_mmu___2 *mmu;
	void *memcache;
	bool force_pte;
};

struct leaf_walk_data {
	kvm_pte_t pte;
	u32 level;
};

struct stage2_attr_data {
	kvm_pte_t attr_set;
	kvm_pte_t attr_clr;
	kvm_pte_t pte;
	u32 level;
};

struct stage2_age_data {
	bool mkold;
	bool young;
};

struct ipi_mux_cpu {
	atomic_t enable;
	atomic_t bits;
};

struct stacktrace_cookie {
	unsigned long *store;
	unsigned int size;
	unsigned int skip;
	unsigned int len;
};

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct sigevent sigevent_t;

struct fgraph_ret_regs {
	unsigned long regs[8];
	unsigned long fp;
	unsigned long __unused;
};

struct btf_anon_stack {
	u32 tid;
	u32 offset;
};

struct bpf_iter__bpf_link {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_link *link;
	};
};

struct bpf_iter_seq_link_info {
	u32 link_id;
};

struct bpf_cpu_map_entry;

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue __attribute__((btf_type_tag("percpu"))) *bulkq;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	struct completion kthread_running;
	struct rcu_work free_work;
};

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry __attribute__((btf_type_tag("rcu"))) **cpu_map;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

enum {
	FOLL_TOUCH = 65536,
	FOLL_TRIED = 131072,
	FOLL_REMOTE = 262144,
	FOLL_PIN = 524288,
	FOLL_FAST_ONLY = 1048576,
	FOLL_UNLOCKABLE = 2097152,
};

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

struct slub_flush_work {
	struct work_struct work;
	struct kmem_cache *s;
	bool skip;
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

enum slab_modes {
	M_NONE = 0,
	M_PARTIAL = 1,
	M_FREE = 2,
	M_FULL_NOLIST = 3,
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

typedef struct {
	unsigned long v;
} freeptr_t;

typedef u32 depot_stack_handle_t;

struct location {
	depot_stack_handle_t handle;
	unsigned long count;
	unsigned long addr;
	unsigned long waste;
	long long sum_time;
	long min_time;
	long max_time;
	long min_pid;
	long max_pid;
	unsigned long cpus[4];
	nodemask_t nodes;
};

struct track {
	unsigned long addr;
	depot_stack_handle_t handle;
	int cpu;
	int pid;
	unsigned long when;
};

typedef freelist_full_t pcp_op_T__;

union __u128_halves {
	u128 full;
	struct {
		u64 low;
		u64 high;
	};
};

struct detached_freelist {
	struct slab *slab;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

struct partial_context {
	struct slab **slab;
	gfp_t flags;
	unsigned int orig_size;
};

struct loc_track {
	unsigned long max;
	unsigned long count;
	struct location *loc;
	loff_t idx;
};

typedef void (*btf_trace_writeback_dirty_folio)(void *, struct folio *, struct address_space *);

typedef void (*btf_trace_folio_wait_writeback)(void *, struct folio *, struct address_space *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_inode_foreign_history)(void *, struct inode *, struct writeback_control *, unsigned int);

typedef void (*btf_trace_inode_switch_wbs)(void *, struct inode *, struct bdi_writeback *, struct bdi_writeback *);

typedef void (*btf_trace_track_foreign_dirty)(void *, struct folio *, struct bdi_writeback *);

typedef void (*btf_trace_flush_foreign)(void *, struct bdi_writeback *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

struct wb_writeback_work;

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

struct wb_writeback_work {
	long nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_pages_written)(void *, long);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, unsigned long, int);

typedef void (*btf_trace_global_dirty_state)(void *, unsigned long, unsigned long);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, unsigned long, unsigned long);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, long, unsigned long);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, unsigned long);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, unsigned long);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

struct trace_event_raw_writeback_folio_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	unsigned long index;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	unsigned long state;
	unsigned long flags;
	char __data[0];
};

struct trace_event_raw_inode_foreign_history {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t cgroup_ino;
	unsigned int history;
	char __data[0];
};

struct trace_event_raw_inode_switch_wbs {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t old_cgroup_ino;
	ino_t new_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_track_foreign_dirty {
	struct trace_entry ent;
	char name[32];
	u64 bdi_id;
	ino_t ino;
	unsigned int memcg_id;
	ino_t cgroup_ino;
	ino_t page_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_flush_foreign {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	unsigned int frn_bdi_id;
	unsigned int frn_memcg_id;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long pages;
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long nr_to_write;
	long pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long range_start;
	long range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	unsigned long older;
	long age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	unsigned long nr_dirty;
	unsigned long nr_writeback;
	unsigned long background_thresh;
	unsigned long dirty_thresh;
	unsigned long dirty_limit;
	unsigned long nr_dirtied;
	unsigned long nr_written;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	unsigned long write_bw;
	unsigned long avg_write_bw;
	unsigned long dirty_rate;
	unsigned long dirty_ratelimit;
	unsigned long task_ratelimit;
	unsigned long balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	unsigned long limit;
	unsigned long setpoint;
	unsigned long dirty;
	unsigned long bdi_setpoint;
	unsigned long bdi_dirty;
	unsigned long dirty_ratelimit;
	unsigned long task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	unsigned long paused;
	long pause;
	unsigned long period;
	long think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	unsigned long state;
	unsigned long dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	unsigned long state;
	unsigned long dirtied_when;
	unsigned long writeback_index;
	long nr_to_write;
	unsigned long wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned long state;
	__u16 mode;
	unsigned long dirtied_when;
	char __data[0];
};

struct inode_switch_wbs_context {
	struct rcu_work work;
	struct bdi_writeback *new_wb;
	struct inode *inodes[0];
};

struct trace_event_data_offsets_writeback_folio_template {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_inode_foreign_history {};

struct trace_event_data_offsets_inode_switch_wbs {};

struct trace_event_data_offsets_track_foreign_dirty {};

struct trace_event_data_offsets_flush_foreign {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_inode_template {};

struct nlm_lookup_host_info {
	const int server;
	const struct sockaddr *sap;
	const size_t salen;
	const unsigned short protocol;
	const u32 version;
	const char *hostname;
	const size_t hostname_len;
	const int noresvport;
	struct net *net;
	const struct cred *cred;
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct acomp_req;

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	void *__ctx[0];
};

struct comp_alg_common {
	struct crypto_alg base;
};

struct crypto_scomp;

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	union {
		struct {
			struct crypto_alg base;
		};
		struct comp_alg_common calg;
	};
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct crypto_report_comp {
	char type[64];
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct io_splice {
	struct file *file_out;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	int splice_fd_in;
	unsigned int flags;
};

typedef uint64_t vli_type;

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
};

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

struct xz_dec_bcj;

struct xz_dec {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
};

enum dim_tune_state {
	DIM_PARKING_ON_TOP = 0,
	DIM_PARKING_TIRED = 1,
	DIM_GOING_RIGHT = 2,
	DIM_GOING_LEFT = 3,
};

enum dim_stats_state {
	DIM_STATS_WORSE = 0,
	DIM_STATS_SAME = 1,
	DIM_STATS_BETTER = 2,
};

enum dim_step_result {
	DIM_STEPPED = 0,
	DIM_TOO_TIRED = 1,
	DIM_ON_EDGE = 2,
};

enum {
	IRQ_POLL_F_SCHED = 0,
	IRQ_POLL_F_DISABLE = 1,
};

struct aic_info {
	int version;
	u32 event;
	u32 target_cpu;
	u32 irq_cfg;
	u32 sw_set;
	u32 sw_clr;
	u32 mask_set;
	u32 mask_clr;
	u32 die_stride;
	bool fast_ipi;
};

struct aic_irq_chip {
	void *base;
	void *event;
	struct irq_domain *hw_domain;
	struct {
		cpumask_t aff;
	} *fiq_aff[7];
	int nr_irq;
	int max_irq;
	int nr_die;
	int max_die;
	struct aic_info info;
};

enum fiq_hwirq {
	AIC_TMR_EL0_PHYS = 0,
	AIC_TMR_EL0_VIRT = 1,
	AIC_TMR_EL02_PHYS = 2,
	AIC_TMR_EL02_VIRT = 3,
	AIC_CPU_PMU_Effi = 4,
	AIC_CPU_PMU_Perf = 5,
	AIC_VGIC_MI = 6,
	AIC_NR_FIQ = 7,
};

struct hi6220_priv {
	struct regmap *reg;
	struct device *dev;
};

struct uniphier_ahciphy_priv;

struct uniphier_ahciphy_soc_data {
	int (*init)(struct uniphier_ahciphy_priv *);
	int (*power_on)(struct uniphier_ahciphy_priv *);
	int (*power_off)(struct uniphier_ahciphy_priv *);
	bool is_legacy;
	bool is_ready_high;
	bool is_phy_clk;
};

struct uniphier_ahciphy_priv {
	struct device *dev;
	void *base;
	struct clk *clk;
	struct clk *clk_parent;
	struct clk *clk_parent_gio;
	struct reset_control *rst;
	struct reset_control *rst_parent;
	struct reset_control *rst_parent_gio;
	struct reset_control *rst_pm;
	struct reset_control *rst_tx;
	struct reset_control *rst_rx;
	const struct uniphier_ahciphy_soc_data *data;
};

struct bcm_plat_data {
	const struct gpio_chip *gpio_chip;
	const struct pinctrl_desc *pctl_desc;
	const struct pinctrl_gpio_range *gpio_range;
};

enum bcm2835_fsel {
	BCM2835_FSEL_COUNT = 8,
	BCM2835_FSEL_MASK = 7,
};

struct bcm2835_pinctrl {
	struct device *dev;
	void *base;
	int *wake_irq;
	unsigned long enabled_irq_map[2];
	unsigned int irq_type[58];
	struct pinctrl_dev *pctl_dev;
	struct gpio_chip gpio_chip;
	struct pinctrl_desc pctl_desc;
	struct pinctrl_gpio_range gpio_range;
	raw_spinlock_t irq_lock[2];
	spinlock_t fsel_lock;
};

struct samsung_pin_ctrl;

struct samsung_pinctrl_of_match_data {
	const struct samsung_pin_ctrl *ctrl;
	unsigned int num_ctrl;
};

struct samsung_pin_bank_data;

struct samsung_retention_data;

struct samsung_pinctrl_drv_data;

struct samsung_pin_ctrl {
	const struct samsung_pin_bank_data *pin_banks;
	unsigned int nr_banks;
	unsigned int nr_ext_resources;
	const struct samsung_retention_data *retention_data;
	int (*eint_gpio_init)(struct samsung_pinctrl_drv_data *);
	int (*eint_wkup_init)(struct samsung_pinctrl_drv_data *);
	void (*suspend)(struct samsung_pinctrl_drv_data *);
	void (*resume)(struct samsung_pinctrl_drv_data *);
};

enum eint_type {
	EINT_TYPE_NONE = 0,
	EINT_TYPE_GPIO = 1,
	EINT_TYPE_WKUP = 2,
	EINT_TYPE_WKUP_MUX = 3,
};

struct samsung_pin_bank_type;

struct samsung_pin_bank_data {
	const struct samsung_pin_bank_type *type;
	u32 pctl_offset;
	u8 pctl_res_idx;
	u8 nr_pins;
	u8 eint_func;
	enum eint_type eint_type;
	u32 eint_mask;
	u32 eint_offset;
	const char *name;
};

struct samsung_pin_bank_type {
	u8 fld_width[6];
	u8 reg_offset[6];
};

struct samsung_retention_ctrl;

struct samsung_retention_data {
	const u32 *regs;
	int nr_regs;
	u32 value;
	atomic_t *refcnt;
	struct samsung_retention_ctrl * (*init)(struct samsung_pinctrl_drv_data *, const struct samsung_retention_data *);
};

struct samsung_retention_ctrl {
	const u32 *regs;
	int nr_regs;
	u32 value;
	atomic_t *refcnt;
	void *priv;
	void (*enable)(struct samsung_pinctrl_drv_data *);
	void (*disable)(struct samsung_pinctrl_drv_data *);
};

struct samsung_pin_group;

struct samsung_pmx_func;

struct samsung_pin_bank;

struct samsung_pinctrl_drv_data {
	struct list_head node;
	void *virt_base;
	struct device *dev;
	int irq;
	struct pinctrl_desc pctl;
	struct pinctrl_dev *pctl_dev;
	const struct samsung_pin_group *pin_groups;
	unsigned int nr_groups;
	const struct samsung_pmx_func *pmx_functions;
	unsigned int nr_functions;
	struct samsung_pin_bank *pin_banks;
	unsigned int nr_banks;
	unsigned int nr_pins;
	struct samsung_retention_ctrl *retention_ctrl;
	void (*suspend)(struct samsung_pinctrl_drv_data *);
	void (*resume)(struct samsung_pinctrl_drv_data *);
};

struct samsung_pin_group {
	const char *name;
	const unsigned int *pins;
	u8 num_pins;
	u8 func;
};

struct samsung_pmx_func {
	const char *name;
	const char **groups;
	u8 num_groups;
	u32 val;
};

struct exynos_irq_chip;

struct samsung_pin_bank {
	const struct samsung_pin_bank_type *type;
	void *pctl_base;
	u32 pctl_offset;
	u8 nr_pins;
	void *eint_base;
	u8 eint_func;
	enum eint_type eint_type;
	u32 eint_mask;
	u32 eint_offset;
	const char *name;
	u32 id;
	u32 pin_base;
	void *soc_priv;
	struct fwnode_handle *fwnode;
	struct samsung_pinctrl_drv_data *drvdata;
	struct irq_domain *irq_domain;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range grange;
	struct exynos_irq_chip *irq_chip;
	raw_spinlock_t slock;
	u32 pm_save[7];
};

struct tegra_gpio_port;

struct tegra186_pin_range;

struct tegra_gpio_soc {
	const struct tegra_gpio_port *ports;
	unsigned int num_ports;
	const char *name;
	unsigned int instance;
	unsigned int num_irqs_per_bank;
	const struct tegra186_pin_range *pin_ranges;
	unsigned int num_pin_ranges;
	const char *pinmux;
	bool has_gte;
	bool has_vm_support;
};

struct tegra_gpio_port {
	const char *name;
	unsigned int bank;
	unsigned int port;
	unsigned int pins;
};

struct tegra186_pin_range {
	unsigned int offset;
	const char *group;
};

struct tegra_gpio {
	struct gpio_chip gpio;
	unsigned int num_irq;
	unsigned int *irq;
	const struct tegra_gpio_soc *soc;
	unsigned int num_irqs_per_bank;
	unsigned int num_banks;
	void *secure;
	void *base;
};

struct rcar_pcie_endpoint {
	struct rcar_pcie pcie;
	phys_addr_t *ob_mapped_addr;
	struct pci_epc_mem_window *ob_window;
	u8 max_functions;
	unsigned int bar_to_atu[6];
	unsigned long *ib_window_map;
	u32 num_ib_windows;
	u32 num_ob_windows;
};

struct rockchip_pcie___2 {
	struct dw_pcie pci;
	void *apb_base;
	struct phy *phy;
	struct clk_bulk_data *clks;
	unsigned int clk_cnt;
	struct reset_control *rst;
	struct gpio_desc *rst_gpio;
	struct regulator *vpcie3v3;
	struct irq_domain *irq_domain;
};

struct acpi_table_apmt {
	struct acpi_table_header header;
};

struct acpi_apmt_node {
	u16 length;
	u8 flags;
	u8 type;
	u32 id;
	u64 inst_primary;
	u32 inst_secondary;
	u64 base_address0;
	u64 base_address1;
	u32 ovflw_irq;
	u32 reserved;
	u32 ovflw_irq_flags;
	u32 proc_affinity;
	u32 impl_id;
} __attribute__((packed));

struct mtk_clk_mux {
	struct clk_hw hw;
	struct regmap *regmap;
	const struct mtk_mux *data;
	spinlock_t *lock;
	bool reparent;
};

struct meson_aoclk_reset_controller {
	struct reset_controller_dev reset;
	const struct meson_aoclk_data *data;
	struct regmap *regmap;
};

enum {
	CP110_CLK_TYPE_CORE = 0,
	CP110_CLK_TYPE_GATABLE = 1,
};

struct cp110_gate_clk {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 bit_idx;
};

struct rockchip_muxgrf_clock {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 shift;
	u32 width;
	int flags;
};

struct ccu_mux_nb {
	struct notifier_block clk_nb;
	struct ccu_common *common;
	struct ccu_mux_internal *cm;
	u32 delay_us;
	u8 bypass_index;
	u8 original_index;
};

struct ccu_nk {
	u16 reg;
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct ccu_phase {
	u8 shift;
	u8 width;
	struct ccu_common common;
};

struct geni_se_desc {
	unsigned int num_clks;
	const char * const *clks;
};

enum geni_se_xfer_mode {
	GENI_SE_INVALID = 0,
	GENI_SE_FIFO = 1,
	GENI_SE_DMA = 2,
	GENI_GPI_DMA = 3,
};

enum geni_se_protocol_type {
	GENI_SE_NONE = 0,
	GENI_SE_SPI = 1,
	GENI_SE_UART = 2,
	GENI_SE_I2C = 3,
	GENI_SE_I3C = 4,
	GENI_SE_SPI_SLAVE = 5,
};

struct geni_icc_path {
	struct icc_path *path;
	unsigned int avg_bw;
};

struct geni_wrapper;

struct geni_se {
	void *base;
	struct device *dev;
	struct geni_wrapper *wrapper;
	struct clk *clk;
	unsigned int num_clk_levels;
	unsigned long *clk_perf_tbl;
	struct geni_icc_path icc_paths[3];
};

struct geni_wrapper {
	struct device *dev;
	void *base;
	struct clk_bulk_data clks[2];
	unsigned int num_clks;
};

struct qcom_smp2p;

struct smp2p_entry {
	struct list_head node;
	struct qcom_smp2p *smp2p;
	const char *name;
	u32 *value;
	u32 last_value;
	struct irq_domain *domain;
	unsigned long irq_enabled[1];
	unsigned long irq_rising[1];
	unsigned long irq_falling[1];
	struct qcom_smem_state *state;
	spinlock_t lock;
};

struct smp2p_smem_item;

struct qcom_smp2p {
	struct device *dev;
	struct smp2p_smem_item *in;
	struct smp2p_smem_item *out;
	unsigned int smem_items[2];
	unsigned int valid_entries;
	bool ssr_ack_enabled;
	bool ssr_ack;
	bool negotiation_done;
	unsigned int local_pid;
	unsigned int remote_pid;
	struct regmap *ipc_regmap;
	int ipc_offset;
	int ipc_bit;
	struct mbox_client mbox_client;
	struct mbox_chan *mbox_chan;
	struct list_head inbound;
	struct list_head outbound;
};

struct smp2p_smem_item {
	u32 magic;
	u8 version;
	unsigned int features: 24;
	u16 local_pid;
	u16 remote_pid;
	u16 total_entries;
	u16 valid_entries;
	u32 flags;
	struct {
		u8 name[16];
		u32 value;
	} entries[16];
};

struct tegra_core_opp_params {
	bool init_state;
};

struct bcm2835_power;

struct bcm2835_power_domain {
	struct generic_pm_domain base;
	struct bcm2835_power *power;
	u32 domain;
	struct clk *clk;
};

struct bcm2835_power {
	struct device *dev;
	void *base;
	void *asb;
	void *rpivid_asb;
	struct genpd_onecell_data pd_xlate;
	struct bcm2835_power_domain domains[13];
	struct reset_controller_dev reset;
};

struct pf8x00_regulator_data {
	struct regulator_desc desc;
	unsigned int suspend_enable_reg;
	unsigned int suspend_enable_mask;
	unsigned int suspend_voltage_reg;
	unsigned int suspend_voltage_cache;
};

enum pf8x00_devid {
	PF8100 = 0,
	PF8121A = 2,
	PF8200 = 8,
};

enum pf8x00_regulators {
	PF8X00_LDO1 = 0,
	PF8X00_LDO2 = 1,
	PF8X00_LDO3 = 2,
	PF8X00_LDO4 = 3,
	PF8X00_BUCK1 = 4,
	PF8X00_BUCK2 = 5,
	PF8X00_BUCK3 = 6,
	PF8X00_BUCK4 = 7,
	PF8X00_BUCK5 = 8,
	PF8X00_BUCK6 = 9,
	PF8X00_BUCK7 = 10,
	PF8X00_VSNVS = 11,
	PF8X00_MAX_REGULATORS = 12,
};

enum pf8x00_buck_states {
	SW_CONFIG1 = 0,
	SW_CONFIG2 = 1,
	SW_PWRUP = 2,
	SW_MODE1 = 3,
	SW_RUN_VOLT = 4,
	SW_STBY_VOLT = 5,
};

enum swxilim_bits {
	SWXILIM_2100_MA = 0,
	SWXILIM_2600_MA = 1,
	SWXILIM_3000_MA = 2,
	SWXILIM_4500_MA = 3,
};

struct pf8x00_chip {
	struct regmap *regmap;
	struct device *dev;
};

struct brcm_rescal_reset {
	void *base;
	struct device *dev;
	struct reset_controller_dev rcdev;
};

struct uniphier8250_priv {
	int line;
	struct clk *clk;
	spinlock_t atomic_write_lock;
};

struct serport {
	struct tty_port *port;
	struct tty_struct *tty;
	struct tty_driver *tty_drv;
	int tty_idx;
	unsigned long flags;
};

struct mtk_rng {
	void *base;
	struct clk *clk;
	struct hwrng rng;
};

struct tpm_pcr_attr {
	int alg_id;
	int pcr;
	struct device_attribute attr;
};

enum tpm_algorithms {
	TPM_ALG_ERROR = 0,
	TPM_ALG_SHA1 = 4,
	TPM_ALG_KEYEDHASH = 8,
	TPM_ALG_SHA256 = 11,
	TPM_ALG_SHA384 = 12,
	TPM_ALG_SHA512 = 13,
	TPM_ALG_NULL = 16,
	TPM_ALG_SM3_256 = 18,
};

enum tpm_sub_capabilities {
	TPM_CAP_PROP_PCR = 257,
	TPM_CAP_PROP_MANUFACTURER = 259,
	TPM_CAP_FLAG_PERM = 264,
	TPM_CAP_FLAG_VOL = 265,
	TPM_CAP_PROP_OWNER = 273,
	TPM_CAP_PROP_TIS_TIMEOUT = 277,
	TPM_CAP_PROP_TIS_DURATION = 288,
};

enum tpm_capabilities {
	TPM_CAP_FLAG = 4,
	TPM_CAP_PROP = 5,
	TPM_CAP_VERSION_1_1 = 6,
	TPM_CAP_VERSION_1_2 = 26,
};

struct tpm_readpubek_out {
	u8 algorithm[4];
	u8 encscheme[2];
	u8 sigscheme[2];
	__be32 paramsize;
	u8 parameters[12];
	__be32 keysize;
	u8 modulus[256];
	u8 checksum[20];
};

struct permanent_flags_t {
	__be16 tag;
	u8 disable;
	u8 ownership;
	u8 deactivated;
	u8 readPubek;
	u8 disableOwnerClear;
	u8 allowMaintenance;
	u8 physicalPresenceLifetimeLock;
	u8 physicalPresenceHWEnable;
	u8 physicalPresenceCMDEnable;
	u8 CEKPUsed;
	u8 TPMpost;
	u8 TPMpostLock;
	u8 FIPS;
	u8 operator;
	u8 enableRevokeEK;
	u8 nvLocked;
	u8 readSRKPub;
	u8 tpmEstablished;
	u8 maintenanceDone;
	u8 disableFullDALogicInfo;
};

struct stclear_flags_t {
	__be16 tag;
	u8 deactivated;
	u8 disableForceClear;
	u8 physicalPresence;
	u8 physicalPresenceLock;
	u8 bGlobalLock;
} __attribute__((packed));

struct tpm1_version {
	u8 major;
	u8 minor;
	u8 rev_major;
	u8 rev_minor;
};

struct tpm1_version2 {
	__be16 tag;
	struct tpm1_version version;
};

struct timeout_t {
	__be32 a;
	__be32 b;
	__be32 c;
	__be32 d;
};

struct duration_t {
	__be32 tpm_short;
	__be32 tpm_medium;
	__be32 tpm_long;
};

typedef union {
	struct permanent_flags_t perm_flags;
	struct stclear_flags_t stclear_flags;
	__u8 owned;
	__be32 num_pcrs;
	struct tpm1_version version1;
	struct tpm1_version2 version2;
	__be32 manufacturer_id;
	struct timeout_t timeout;
	struct duration_t duration;
} cap_t;

struct of_pci_iommu_alias_info {
	struct device *dev;
	struct device_node *np;
};

struct soc_device {
	struct device dev;
	struct soc_device_attribute *attr;
	int soc_dev_num;
};

enum mt6397_irq_numbers {
	MT6397_IRQ_SPKL_AB = 0,
	MT6397_IRQ_SPKR_AB = 1,
	MT6397_IRQ_SPKL = 2,
	MT6397_IRQ_SPKR = 3,
	MT6397_IRQ_BAT_L = 4,
	MT6397_IRQ_BAT_H = 5,
	MT6397_IRQ_FG_BAT_L = 6,
	MT6397_IRQ_FG_BAT_H = 7,
	MT6397_IRQ_WATCHDOG = 8,
	MT6397_IRQ_PWRKEY = 9,
	MT6397_IRQ_THR_L = 10,
	MT6397_IRQ_THR_H = 11,
	MT6397_IRQ_VBATON_UNDET = 12,
	MT6397_IRQ_BVALID_DET = 13,
	MT6397_IRQ_CHRDET = 14,
	MT6397_IRQ_OV = 15,
	MT6397_IRQ_LDO = 16,
	MT6397_IRQ_HOMEKEY = 17,
	MT6397_IRQ_ACCDET = 18,
	MT6397_IRQ_AUDIO = 19,
	MT6397_IRQ_RTC = 20,
	MT6397_IRQ_PWRKEY_RSTB = 21,
	MT6397_IRQ_HDMI_SIFM = 22,
	MT6397_IRQ_HDMI_CEC = 23,
	MT6397_IRQ_VCA15 = 24,
	MT6397_IRQ_VSRMCA15 = 25,
	MT6397_IRQ_VCORE = 26,
	MT6397_IRQ_VGPU = 27,
	MT6397_IRQ_VIO18 = 28,
	MT6397_IRQ_VPCA7 = 29,
	MT6397_IRQ_VSRMCA7 = 30,
	MT6397_IRQ_VDRM = 31,
	MT6397_IRQ_NR = 32,
};

enum scsi_ml_status {
	SCSIML_STAT_OK = 0,
	SCSIML_STAT_RESV_CONFLICT = 1,
	SCSIML_STAT_NOSPC = 2,
	SCSIML_STAT_MED_ERROR = 3,
	SCSIML_STAT_TGT_FAILURE = 4,
	SCSIML_STAT_DL_TIMEOUT = 5,
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

struct ata_task_resp {
	u16 frame_len;
	u8 ending_fis[24];
};

enum sata_rcar_type {
	RCAR_GEN1_SATA = 0,
	RCAR_GEN2_SATA = 1,
	RCAR_GEN3_SATA = 2,
	RCAR_R8A7790_ES1_SATA = 3,
};

struct sata_rcar_priv {
	void *base;
	u32 sataint_mask;
	enum sata_rcar_type type;
};

struct lpspi_config {
	u8 bpw;
	u8 chip_select;
	u8 prescale;
	u16 mode;
	u32 speed_hz;
};

struct fsl_lpspi_data {
	struct device *dev;
	void *base;
	unsigned long base_phys;
	struct clk *clk_ipg;
	struct clk *clk_per;
	bool is_target;
	bool is_only_cs1;
	bool is_first_byte;
	void *rx_buf;
	const void *tx_buf;
	void (*tx)(struct fsl_lpspi_data *);
	void (*rx)(struct fsl_lpspi_data *);
	u32 remain;
	u8 watermark;
	u8 txfifosize;
	u8 rxfifosize;
	struct lpspi_config config;
	struct completion xfer_done;
	bool target_aborted;
	bool usedma;
	struct completion dma_rx_completion;
	struct completion dma_tx_completion;
};

struct unimac_mdio_priv {
	struct mii_bus *mii_bus;
	void *base;
	int (*wait_func)(void *);
	void *wait_func_data;
	struct clk *clk;
	u32 clk_freq;
};

struct unimac_mdio_pdata {
	u32 phy_mask;
	int (*wait_func)(void *);
	void *wait_func_data;
	const char *bus_name;
};

enum xgene_phy_speed {
	PHY_SPEED_10 = 0,
	PHY_SPEED_100 = 1,
	PHY_SPEED_1000 = 2,
};

struct tgec_mdio_controller;

struct mdio_fsl_priv {
	struct tgec_mdio_controller *mdio_base;
	struct clk *enet_clk;
	u32 mdc_freq;
	bool is_little_endian;
	bool has_a009885;
	bool has_a011043;
};

struct tgec_mdio_controller {
	__be32 reserved[12];
	__be32 mdio_stat;
	__be32 mdio_ctl;
	__be32 mdio_data;
	__be32 mdio_addr;
};

enum qman_cb_dqrr_result {
	qman_cb_dqrr_consume = 0,
	qman_cb_dqrr_park = 1,
	qman_cb_dqrr_defer = 2,
	qman_cb_dqrr_stop = 3,
	qman_cb_dqrr_consume_stop = 4,
};

enum qman_fq_state {
	qman_fq_state_oos = 0,
	qman_fq_state_parked = 1,
	qman_fq_state_sched = 2,
	qman_fq_state_retired = 3,
};

struct qman_portal;

struct qman_cgr;

typedef void (*qman_cb_cgr)(struct qman_portal *, struct qman_cgr *, int);

struct qman_cgr {
	u32 cgrid;
	qman_cb_cgr cb;
	u16 chan;
	struct list_head node;
};

struct dpaa_buffer_layout {
	u16 priv_data_size;
};

struct dpaa_percpu_priv;

struct dpaa_bp;

struct qman_fq;

struct dpaa_priv {
	struct dpaa_percpu_priv __attribute__((btf_type_tag("percpu"))) *percpu_priv;
	struct dpaa_bp *dpaa_bp;
	u16 tx_headroom;
	struct net_device *net_dev;
	struct mac_device___2 *mac_dev;
	struct device *rx_dma_dev;
	struct device *tx_dma_dev;
	struct qman_fq *egress_fqs[1024];
	struct qman_fq *conf_fqs[1024];
	u16 channel;
	struct list_head dpaa_fq_list;
	u8 num_tc;
	bool keygen_in_use;
	u32 msg_enable;
	struct {
		struct qman_cgr cgr;
		u32 congestion_start_jiffies;
		u32 congested_jiffies;
		u32 cgr_congested_count;
	} cgr_data;
	bool use_ingress_cgr;
	struct qman_cgr ingress_cgr;
	struct dpaa_buffer_layout buf_layout[2];
	u16 rx_headroom;
	bool tx_tstamp;
	bool rx_tstamp;
	struct bpf_prog *xdp_prog;
};

struct dpaa_napi_portal {
	struct napi_struct napi;
	struct qman_portal *p;
	bool down;
	int xdp_act;
};

struct dpaa_rx_errors {
	u64 dme;
	u64 fpe;
	u64 fse;
	u64 phe;
};

struct dpaa_ern_cnt {
	u64 cg_tdrop;
	u64 wred;
	u64 err_cond;
	u64 early_window;
	u64 late_window;
	u64 fq_tdrop;
	u64 fq_retired;
	u64 orp_zero;
};

struct dpaa_percpu_priv {
	struct net_device *net_dev;
	struct dpaa_napi_portal np;
	u64 in_interrupt;
	u64 tx_confirm;
	u64 tx_frag_skbuffs;
	struct rtnl_link_stats64 stats;
	struct dpaa_rx_errors rx_errors;
	struct dpaa_ern_cnt ern_cnt;
};

struct dpaa_bp {
	struct dpaa_priv *priv;
	int __attribute__((btf_type_tag("percpu"))) *percpu_count;
	size_t raw_size;
	size_t size;
	u16 config_count;
	u8 bpid;
	struct bman_pool *pool;
	int (*seed_cb)(struct dpaa_bp *);
	void (*free_buf_cb)(const struct dpaa_bp *, struct bm_buffer *);
	refcount_t refs;
};

struct qm_dqrr_entry;

typedef enum qman_cb_dqrr_result (*qman_cb_dqrr)(struct qman_portal *, struct qman_fq *, const struct qm_dqrr_entry *, bool);

union qm_mr_entry;

typedef void (*qman_cb_mr)(struct qman_portal *, struct qman_fq *, const union qm_mr_entry *);

struct qman_fq_cb {
	qman_cb_dqrr dqrr;
	qman_cb_mr ern;
	qman_cb_mr fqs;
};

struct qman_fq {
	struct qman_fq_cb cb;
	u32 fqid;
	u32 idx;
	unsigned long flags;
	enum qman_fq_state state;
	int cgr_groupid;
};

struct qm_fd {
	union {
		struct {
			u8 cfg8b_w1;
			u8 bpid;
			u8 cfg8b_w3;
			u8 addr_hi;
			__be32 addr_lo;
		};
		__be64 data;
	};
	__be32 cfg;
	union {
		__be32 cmd;
		__be32 status;
	};
};

struct qm_dqrr_entry {
	u8 verb;
	u8 stat;
	__be16 seqnum;
	u8 tok;
	u8 __reserved2[3];
	__be32 fqid;
	__be32 context_b;
	struct qm_fd fd;
	u8 __reserved4[32];
};

union qm_mr_entry {
	struct {
		u8 verb;
		u8 __reserved[63];
	};
	struct {
		u8 verb;
		u8 dca;
		__be16 seqnum;
		u8 rc;
		u8 __reserved[3];
		__be32 fqid;
		__be32 tag;
		struct qm_fd fd;
		u8 __reserved1[32];
	} ern;
	struct {
		u8 verb;
		u8 fqs;
		u8 __reserved1[6];
		__be32 fqid;
		__be32 context_b;
		u8 __reserved2[48];
	} fq;
};

enum _dsm_op_index {
	HNS_OP_RESET_FUNC = 1,
	HNS_OP_SERDES_LP_FUNC = 2,
	HNS_OP_LED_SET_FUNC = 3,
	HNS_OP_GET_PORT_TYPE_FUNC = 4,
	HNS_OP_GET_SFP_STAT_FUNC = 5,
	HNS_OP_LOCATE_LED_SET_FUNC = 6,
};

enum _dsm_rst_type {
	HNS_DSAF_RESET_FUNC = 1,
	HNS_PPE_RESET_FUNC = 2,
	HNS_XGE_RESET_FUNC = 4,
	HNS_GE_RESET_FUNC = 5,
	HNS_DSAF_CHN_RESET_FUNC = 6,
	HNS_ROCE_RESET_FUNC = 7,
};

struct ich8_hsflctl {
	u16 flcgo: 1;
	u16 flcycle: 2;
	u16 reserved: 5;
	u16 fldbcount: 2;
	u16 flockdn: 6;
};

union ich8_hws_flash_ctrl {
	struct ich8_hsflctl hsf_ctrl;
	u16 regval;
};

struct ich8_hsfsts {
	u16 flcdone: 1;
	u16 flcerr: 1;
	u16 dael: 1;
	u16 berasesz: 2;
	u16 flcinprog: 1;
	u16 reserved1: 2;
	u16 reserved2: 6;
	u16 fldesvalid: 1;
	u16 flockdn: 1;
};

union ich8_hws_flash_status {
	struct ich8_hsfsts hsf_status;
	u16 regval;
};

struct ich8_pr {
	u32 base: 13;
	u32 reserved1: 2;
	u32 rpe: 1;
	u32 limit: 13;
	u32 reserved2: 2;
	u32 wpe: 1;
};

union ich8_flash_protected_range {
	struct ich8_pr range;
	u32 regval;
};

struct mvpp2_prs_result_info {
	u32 ri;
	u32 ri_mask;
};

struct mvpp2_cls_flow {
	int flow_type;
	u16 flow_id;
	u16 supported_hash_opts;
	struct mvpp2_prs_result_info prs_ri;
};

enum mvpp2_cls_field_id {
	MVPP22_CLS_FIELD_MAC_DA = 3,
	MVPP22_CLS_FIELD_VLAN_PRI = 5,
	MVPP22_CLS_FIELD_VLAN = 6,
	MVPP22_CLS_FIELD_L3_PROTO = 15,
	MVPP22_CLS_FIELD_IP4SA = 16,
	MVPP22_CLS_FIELD_IP4DA = 17,
	MVPP22_CLS_FIELD_IP6SA = 23,
	MVPP22_CLS_FIELD_IP6DA = 26,
	MVPP22_CLS_FIELD_L4SIP = 29,
	MVPP22_CLS_FIELD_L4DIP = 30,
};

enum mvpp2_prs_flow {
	MVPP2_FL_START = 8,
	MVPP2_FL_IP4_TCP_NF_UNTAG = 8,
	MVPP2_FL_IP4_UDP_NF_UNTAG = 9,
	MVPP2_FL_IP4_TCP_NF_TAG = 10,
	MVPP2_FL_IP4_UDP_NF_TAG = 11,
	MVPP2_FL_IP6_TCP_NF_UNTAG = 12,
	MVPP2_FL_IP6_UDP_NF_UNTAG = 13,
	MVPP2_FL_IP6_TCP_NF_TAG = 14,
	MVPP2_FL_IP6_UDP_NF_TAG = 15,
	MVPP2_FL_IP4_TCP_FRAG_UNTAG = 16,
	MVPP2_FL_IP4_UDP_FRAG_UNTAG = 17,
	MVPP2_FL_IP4_TCP_FRAG_TAG = 18,
	MVPP2_FL_IP4_UDP_FRAG_TAG = 19,
	MVPP2_FL_IP6_TCP_FRAG_UNTAG = 20,
	MVPP2_FL_IP6_UDP_FRAG_UNTAG = 21,
	MVPP2_FL_IP6_TCP_FRAG_TAG = 22,
	MVPP2_FL_IP6_UDP_FRAG_TAG = 23,
	MVPP2_FL_IP4_UNTAG = 24,
	MVPP2_FL_IP4_TAG = 25,
	MVPP2_FL_IP6_UNTAG = 26,
	MVPP2_FL_IP6_TAG = 27,
	MVPP2_FL_NON_IP_UNTAG = 28,
	MVPP2_FL_NON_IP_TAG = 29,
	MVPP2_FL_LAST = 30,
};

enum mvpp2_cls_engine {
	MVPP22_CLS_ENGINE_C2 = 1,
	MVPP22_CLS_ENGINE_C3A = 2,
	MVPP22_CLS_ENGINE_C3B = 3,
	MVPP22_CLS_ENGINE_C4 = 4,
	MVPP22_CLS_ENGINE_C3HA = 6,
	MVPP22_CLS_ENGINE_C3HB = 7,
};

enum mvpp2_cls_lu_type {
	MVPP22_CLS_LU_TYPE_ALL = 63,
};

enum mvpp22_cls_c2_action {
	MVPP22_C2_NO_UPD = 0,
	MVPP22_C2_NO_UPD_LOCK = 1,
	MVPP22_C2_UPD = 2,
	MVPP22_C2_UPD_LOCK = 3,
};

enum mvpp22_cls_c2_fwd_action {
	MVPP22_C2_FWD_NO_UPD = 0,
	MVPP22_C2_FWD_NO_UPD_LOCK = 1,
	MVPP22_C2_FWD_SW = 2,
	MVPP22_C2_FWD_SW_LOCK = 3,
	MVPP22_C2_FWD_HW = 4,
	MVPP22_C2_FWD_HW_LOCK = 5,
	MVPP22_C2_FWD_HW_LOW_LAT = 6,
	MVPP22_C2_FWD_HW_LOW_LAT_LOCK = 7,
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

enum mvpp22_cls_c2_color_action {
	MVPP22_C2_COL_NO_UPD = 0,
	MVPP22_C2_COL_NO_UPD_LOCK = 1,
	MVPP22_C2_COL_GREEN = 2,
	MVPP22_C2_COL_GREEN_LOCK = 3,
	MVPP22_C2_COL_YELLOW = 4,
	MVPP22_C2_COL_YELLOW_LOCK = 5,
	MVPP22_C2_COL_RED = 6,
	MVPP22_C2_COL_RED_LOCK = 7,
};

struct mvpp2_cls_flow_entry {
	u32 index;
	u32 data[3];
};

struct mvpp2_cls_lookup_entry {
	u32 lkpid;
	u32 way;
	u32 data;
};

struct mvpp2_cls_c2_entry {
	u32 index;
	u32 tcam[5];
	u32 act;
	u32 attr[5];
	u8 valid;
};

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	unsigned long priv[0];
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct vfio___2 {
	struct class *device_class;
	struct ida device_ida;
};

enum {
	IOMMUFD_ACCESS_RW_READ = 0,
	IOMMUFD_ACCESS_RW_WRITE = 1,
	IOMMUFD_ACCESS_RW_KTHREAD = 2,
	__IOMMUFD_ACCESS_RW_SLOW_PATH = 4,
};

struct vfio_device_feature {
	__u32 argsz;
	__u32 flags;
	__u8 data[0];
};

struct vfio_device_feature_mig_state {
	__u32 device_state;
	__s32 data_fd;
};

struct vfio_device_feature_migration {
	__u64 flags;
};

struct vfio_device_feature_dma_logging_control {
	__u64 page_size;
	__u32 num_ranges;
	__u32 __reserved;
	__u64 ranges;
};

struct vfio_device_feature_dma_logging_range {
	__u64 iova;
	__u64 length;
};

struct vfio_device_feature_dma_logging_report {
	__u64 iova;
	__u64 length;
	__u64 page_size;
	__u64 bitmap;
};

struct vfio_device_feature_mig_data_size {
	__u64 stop_copy_length;
};

struct usb_cdc_union_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bMasterInterface0;
	__u8 bSlaveInterface0;
};

struct usb_cdc_country_functional_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iCountryCodeRelDate;
	__le16 wCountyCode0;
};

struct usb_cdc_header_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdCDC;
} __attribute__((packed));

struct usb_cdc_acm_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
};

struct usb_cdc_ether_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iMACAddress;
	__le32 bmEthernetStatistics;
	__le16 wMaxSegmentSize;
	__le16 wNumberMCFilters;
	__u8 bNumberPowerFilters;
} __attribute__((packed));

struct usb_cdc_call_mgmt_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
	__u8 bDataInterface;
};

struct usb_cdc_dmm_desc {
	__u8 bFunctionLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u16 bcdVersion;
	__le16 wMaxCommand;
} __attribute__((packed));

struct usb_cdc_mdlm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
	__u8 bGUID[16];
} __attribute__((packed));

struct usb_cdc_mdlm_detail_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bGuidDescriptorType;
	__u8 bDetailData[0];
};

struct usb_cdc_ncm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdNcmVersion;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMVersion;
	__le16 wMaxControlMessage;
	__u8 bNumberFilters;
	__u8 bMaxFilterSize;
	__le16 wMaxSegmentSize;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_extended_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMExtendedVersion;
	__u8 bMaxOutstandingCommandMessages;
	__le16 wMTU;
} __attribute__((packed));

struct set_config_request {
	struct usb_device *udev;
	int config;
	struct work_struct work;
	struct list_head node;
};

struct api_context {
	struct completion done;
	int status;
};

struct usb_cdc_network_terminal_desc;

struct usb_cdc_obex_desc;

struct usb_cdc_parsed_header {
	struct usb_cdc_union_desc *usb_cdc_union_desc;
	struct usb_cdc_header_desc *usb_cdc_header_desc;
	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
	bool phonet_magic_present;
};

struct usb_cdc_network_terminal_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bEntityId;
	__u8 iName;
	__u8 bChannelIndex;
	__u8 bPhysicalInterface;
};

struct usb_cdc_obex_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
} __attribute__((packed));

struct exynos_ohci_hcd {
	struct clk *clk;
	struct device_node *of_node;
	struct phy *phy[3];
	bool legacy_phy;
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

struct byd_data {
	struct timer_list timer;
	struct psmouse *psmouse;
	s32 abs_x;
	s32 abs_y;
	volatile unsigned long last_touch_time;
	bool btn_left;
	bool btn_right;
	bool touch;
};

struct thermal_hwmon_device {
	char type[20];
	struct device *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_attr {
	struct device_attribute attr;
	char name[16];
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct amlogic_thermal_soc_calib_data;

struct amlogic_thermal_data {
	int u_efuse_off;
	const struct amlogic_thermal_soc_calib_data *calibration_parameters;
	const struct regmap_config *regmap_config;
};

struct amlogic_thermal_soc_calib_data {
	int A;
	int B;
	int m;
	int n;
};

struct amlogic_thermal {
	struct platform_device *pdev;
	const struct amlogic_thermal_data *data;
	struct regmap *regmap;
	struct regmap *sec_ao_map;
	struct clk *clk;
	struct thermal_zone_device *tzd;
	u32 trim_info;
};

struct armada37xx_cpufreq_state {
	struct platform_device *pdev;
	struct device *cpu_dev;
	struct regmap *regmap;
	u32 nb_l0l1;
	u32 nb_l2l3;
	u32 nb_dyn_mod;
	u32 nb_cpu_load;
};

struct armada_37xx_dvfs {
	u32 cpu_freq_max;
	u8 divider[4];
	u32 avs[4];
};

struct cpufreq_dt_platform_data {
	bool have_governor_per_policy;
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
};

enum sdhci_reset_reason {
	SDHCI_RESET_FOR_INIT = 0,
	SDHCI_RESET_FOR_REQUEST_ERROR = 1,
	SDHCI_RESET_FOR_REQUEST_ERROR_DATA_ONLY = 2,
	SDHCI_RESET_FOR_TUNING_ABORT = 3,
	SDHCI_RESET_FOR_CARD_REMOVED = 4,
	SDHCI_RESET_FOR_CQE_RECOVERY = 5,
};

enum sdhci_cookie {
	COOKIE_UNMAPPED___3 = 0,
	COOKIE_PRE_MAPPED___3 = 1,
	COOKIE_MAPPED___3 = 2,
};

struct sdhci_adma2_64_desc {
	__le16 cmd;
	__le16 len;
	__le32 addr_lo;
	__le32 addr_hi;
};

typedef int (*gpio_blink_set_t)(struct gpio_desc *, int, unsigned long *, unsigned long *);

struct gpio_led_data {
	struct led_classdev cdev;
	struct gpio_desc *gpiod;
	u8 can_sleep;
	u8 blinking;
	gpio_blink_set_t platform_gpio_blink_set;
};

struct gpio_led {
	const char *name;
	const char *default_trigger;
	unsigned int gpio;
	unsigned int active_low: 1;
	unsigned int retain_state_suspended: 1;
	unsigned int panic_indicator: 1;
	unsigned int default_state: 2;
	unsigned int retain_state_shutdown: 1;
	struct gpio_desc *gpiod;
};

struct gpio_leds_priv {
	int num_leds;
	struct gpio_led_data leds[0];
};

struct gpio_led_platform_data {
	int num_leds;
	const struct gpio_led *leds;
	gpio_blink_set_t gpio_blink_set;
};

enum scmi_power_protocol_cmd {
	POWER_DOMAIN_ATTRIBUTES = 3,
	POWER_STATE_SET = 4,
	POWER_STATE_GET = 5,
	POWER_STATE_NOTIFY = 6,
	POWER_DOMAIN_NAME_GET = 8,
};

struct power_dom_info;

struct scmi_power_info {
	u32 version;
	int num_domains;
	u64 stats_addr;
	u32 stats_size;
	struct power_dom_info *dom_info;
};

struct power_dom_info {
	bool state_set_sync;
	bool state_set_async;
	bool state_set_notify;
	char name[64];
};

struct scmi_msg_resp_power_attributes {
	__le16 num_domains;
	__le16 reserved;
	__le32 stats_addr_low;
	__le32 stats_addr_high;
	__le32 stats_size;
};

struct scmi_msg_resp_power_domain_attributes {
	__le32 flags;
	u8 name[16];
};

struct scmi_power_state_notify {
	__le32 domain;
	__le32 notify_enable;
};

struct scmi_power_set_state {
	__le32 flags;
	__le32 domain;
	__le32 state;
};

struct scmi_power_state_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 power_state;
};

struct scmi_power_state_changed_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int power_state;
};

struct scmi_smc {
	int irq;
	struct scmi_chan_info *cinfo;
	struct scmi_shared_mem *shmem;
	struct mutex shmem_lock;
	atomic_t inflight;
	unsigned long func_id;
	unsigned long param_page;
	unsigned long param_offset;
	unsigned long cap_id;
};

struct tegra_ivc {
	struct device *peer;
	struct {
		struct iosys_map map;
		unsigned int position;
		dma_addr_t phys;
	} rx;
	struct {
		struct iosys_map map;
		unsigned int position;
		dma_addr_t phys;
	} tx;
	void (*notify)(struct tegra_ivc *, void *);
	void *notify_data;
	unsigned int num_frames;
	size_t frame_size;
};

typedef void (*tegra_bpmp_mrq_handler_t)(unsigned int, struct tegra_bpmp_channel *, void *);

struct tegra_bpmp_mrq {
	struct list_head list;
	unsigned int mrq;
	tegra_bpmp_mrq_handler_t handler;
	void *data;
};

struct tegra_bpmp_mb_data {
	u32 code;
	u32 flags;
	u8 data[120];
};

struct mrq_query_abi_request {
	uint32_t mrq;
};

struct mrq_query_abi_response {
	int32_t status;
};

struct mrq_query_tag_request {
	uint32_t addr;
};

struct mrq_ping_request {
	uint32_t challenge;
};

struct mrq_ping_response {
	uint32_t reply;
};

struct mrq_query_fw_tag_response {
	uint8_t tag[32];
};

struct hid_usage_entry {
	unsigned int page;
	unsigned int usage;
	const char *description;
};

struct hid_debug_list {
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[0];
	} hid_debug_fifo;
	struct fasync_struct *fasync;
	struct hid_device *hdev;
	struct list_head node;
	struct mutex read_mutex;
};

enum lightbar_command {
	LIGHTBAR_CMD_DUMP = 0,
	LIGHTBAR_CMD_OFF = 1,
	LIGHTBAR_CMD_ON = 2,
	LIGHTBAR_CMD_INIT = 3,
	LIGHTBAR_CMD_SET_BRIGHTNESS = 4,
	LIGHTBAR_CMD_SEQ = 5,
	LIGHTBAR_CMD_REG = 6,
	LIGHTBAR_CMD_SET_RGB = 7,
	LIGHTBAR_CMD_GET_SEQ = 8,
	LIGHTBAR_CMD_DEMO = 9,
	LIGHTBAR_CMD_GET_PARAMS_V0 = 10,
	LIGHTBAR_CMD_SET_PARAMS_V0 = 11,
	LIGHTBAR_CMD_VERSION = 12,
	LIGHTBAR_CMD_GET_BRIGHTNESS = 13,
	LIGHTBAR_CMD_GET_RGB = 14,
	LIGHTBAR_CMD_GET_DEMO = 15,
	LIGHTBAR_CMD_GET_PARAMS_V1 = 16,
	LIGHTBAR_CMD_SET_PARAMS_V1 = 17,
	LIGHTBAR_CMD_SET_PROGRAM = 18,
	LIGHTBAR_CMD_MANUAL_SUSPEND_CTRL = 19,
	LIGHTBAR_CMD_SUSPEND = 20,
	LIGHTBAR_CMD_RESUME = 21,
	LIGHTBAR_CMD_GET_PARAMS_V2_TIMING = 22,
	LIGHTBAR_CMD_SET_PARAMS_V2_TIMING = 23,
	LIGHTBAR_CMD_GET_PARAMS_V2_TAP = 24,
	LIGHTBAR_CMD_SET_PARAMS_V2_TAP = 25,
	LIGHTBAR_CMD_GET_PARAMS_V2_OSCILLATION = 26,
	LIGHTBAR_CMD_SET_PARAMS_V2_OSCILLATION = 27,
	LIGHTBAR_CMD_GET_PARAMS_V2_BRIGHTNESS = 28,
	LIGHTBAR_CMD_SET_PARAMS_V2_BRIGHTNESS = 29,
	LIGHTBAR_CMD_GET_PARAMS_V2_THRESHOLDS = 30,
	LIGHTBAR_CMD_SET_PARAMS_V2_THRESHOLDS = 31,
	LIGHTBAR_CMD_GET_PARAMS_V2_COLORS = 32,
	LIGHTBAR_CMD_SET_PARAMS_V2_COLORS = 33,
	LIGHTBAR_NUM_CMDS = 34,
};

struct rgb_s {
	uint8_t r;
	uint8_t g;
	uint8_t b;
};

struct lightbar_params_v0 {
	int32_t google_ramp_up;
	int32_t google_ramp_down;
	int32_t s3s0_ramp_up;
	int32_t s0_tick_delay[2];
	int32_t s0a_tick_delay[2];
	int32_t s0s3_ramp_down;
	int32_t s3_sleep_for;
	int32_t s3_ramp_up;
	int32_t s3_ramp_down;
	uint8_t new_s0;
	uint8_t osc_min[2];
	uint8_t osc_max[2];
	uint8_t w_ofs[2];
	uint8_t bright_bl_off_fixed[2];
	uint8_t bright_bl_on_min[2];
	uint8_t bright_bl_on_max[2];
	uint8_t battery_threshold[3];
	uint8_t s0_idx[8];
	uint8_t s3_idx[8];
	struct rgb_s color[8];
};

struct lightbar_params_v1 {
	int32_t google_ramp_up;
	int32_t google_ramp_down;
	int32_t s3s0_ramp_up;
	int32_t s0_tick_delay[2];
	int32_t s0a_tick_delay[2];
	int32_t s0s3_ramp_down;
	int32_t s3_sleep_for;
	int32_t s3_ramp_up;
	int32_t s3_ramp_down;
	int32_t s5_ramp_up;
	int32_t s5_ramp_down;
	int32_t tap_tick_delay;
	int32_t tap_gate_delay;
	int32_t tap_display_time;
	uint8_t tap_pct_red;
	uint8_t tap_pct_green;
	uint8_t tap_seg_min_on;
	uint8_t tap_seg_max_on;
	uint8_t tap_seg_osc;
	uint8_t tap_idx[3];
	uint8_t osc_min[2];
	uint8_t osc_max[2];
	uint8_t w_ofs[2];
	uint8_t bright_bl_off_fixed[2];
	uint8_t bright_bl_on_min[2];
	uint8_t bright_bl_on_max[2];
	uint8_t battery_threshold[3];
	uint8_t s0_idx[8];
	uint8_t s3_idx[8];
	uint8_t s5_idx;
	struct rgb_s color[8];
};

struct lightbar_params_v2_timing {
	int32_t google_ramp_up;
	int32_t google_ramp_down;
	int32_t s3s0_ramp_up;
	int32_t s0_tick_delay[2];
	int32_t s0a_tick_delay[2];
	int32_t s0s3_ramp_down;
	int32_t s3_sleep_for;
	int32_t s3_ramp_up;
	int32_t s3_ramp_down;
	int32_t s5_ramp_up;
	int32_t s5_ramp_down;
	int32_t tap_tick_delay;
	int32_t tap_gate_delay;
	int32_t tap_display_time;
};

struct lightbar_params_v2_tap {
	uint8_t tap_pct_red;
	uint8_t tap_pct_green;
	uint8_t tap_seg_min_on;
	uint8_t tap_seg_max_on;
	uint8_t tap_seg_osc;
	uint8_t tap_idx[3];
};

struct lightbar_params_v2_oscillation {
	uint8_t osc_min[2];
	uint8_t osc_max[2];
	uint8_t w_ofs[2];
};

struct lightbar_params_v2_brightness {
	uint8_t bright_bl_off_fixed[2];
	uint8_t bright_bl_on_min[2];
	uint8_t bright_bl_on_max[2];
};

struct lightbar_params_v2_thresholds {
	uint8_t battery_threshold[3];
};

struct lightbar_params_v2_colors {
	uint8_t s0_idx[8];
	uint8_t s3_idx[8];
	uint8_t s5_idx;
	struct rgb_s color[8];
};

struct lightbar_program {
	uint8_t size;
	uint8_t data[192];
};

struct ec_params_lightbar {
	uint8_t cmd;
	union {
		struct {
			uint8_t num;
		} set_brightness;
		struct {
			uint8_t num;
		} seq;
		struct {
			uint8_t num;
		} demo;
		struct {
			uint8_t ctrl;
			uint8_t reg;
			uint8_t value;
		} reg;
		struct {
			uint8_t led;
			uint8_t red;
			uint8_t green;
			uint8_t blue;
		} set_rgb;
		struct {
			uint8_t led;
		} get_rgb;
		struct {
			uint8_t enable;
		} manual_suspend_ctrl;
		struct lightbar_params_v0 set_params_v0;
		struct lightbar_params_v1 set_params_v1;
		struct lightbar_params_v2_timing set_v2par_timing;
		struct lightbar_params_v2_tap set_v2par_tap;
		struct lightbar_params_v2_oscillation set_v2par_osc;
		struct lightbar_params_v2_brightness set_v2par_bright;
		struct lightbar_params_v2_thresholds set_v2par_thlds;
		struct lightbar_params_v2_colors set_v2par_colors;
		struct lightbar_program set_program;
	};
};

struct ec_response_lightbar {
	union {
		struct {
			struct {
				uint8_t reg;
				uint8_t ic0;
				uint8_t ic1;
			} vals[23];
		} dump;
		struct {
			uint8_t num;
		} get_seq;
		struct {
			uint8_t num;
		} get_brightness;
		struct {
			uint8_t num;
		} get_demo;
		struct lightbar_params_v0 get_params_v0;
		struct lightbar_params_v1 get_params_v1;
		struct lightbar_params_v2_timing get_params_v2_timing;
		struct lightbar_params_v2_tap get_params_v2_tap;
		struct lightbar_params_v2_oscillation get_params_v2_osc;
		struct lightbar_params_v2_brightness get_params_v2_bright;
		struct lightbar_params_v2_thresholds get_params_v2_thlds;
		struct lightbar_params_v2_colors get_params_v2_colors;
		struct {
			uint32_t num;
			uint32_t flags;
		} version;
		struct {
			uint8_t red;
			uint8_t green;
			uint8_t blue;
		} get_rgb;
	};
};

struct tegra_hsp_channel;

struct tegra_hsp_sm_ops {
	void (*send)(struct tegra_hsp_channel *, void *);
	void (*recv)(struct tegra_hsp_channel *);
};

struct tegra_hsp;

struct tegra_hsp_channel {
	struct tegra_hsp *hsp;
	struct mbox_chan *chan;
	void *regs;
};

struct tegra_hsp_soc;

struct tegra_hsp_mailbox;

struct tegra_hsp {
	struct device *dev;
	const struct tegra_hsp_soc *soc;
	struct mbox_controller mbox_db;
	struct mbox_controller mbox_sm;
	void *regs;
	unsigned int doorbell_irq;
	unsigned int *shared_irqs;
	unsigned int shared_irq;
	unsigned int num_sm;
	unsigned int num_as;
	unsigned int num_ss;
	unsigned int num_db;
	unsigned int num_si;
	spinlock_t lock;
	struct lock_class_key lock_key;
	struct list_head doorbells;
	struct tegra_hsp_mailbox *mailboxes;
	unsigned long mask;
};

struct tegra_hsp_db_map;

struct tegra_hsp_soc {
	const struct tegra_hsp_db_map *map;
	bool has_per_mb_ie;
	bool has_128_bit_mb;
	unsigned int reg_stride;
};

struct tegra_hsp_db_map {
	const char *name;
	unsigned int master;
	unsigned int index;
};

struct tegra_hsp_mailbox {
	struct tegra_hsp_channel channel;
	const struct tegra_hsp_sm_ops *ops;
	unsigned int index;
	bool producer;
};

struct tegra_hsp_doorbell {
	struct tegra_hsp_channel channel;
	struct list_head list;
	const char *name;
	unsigned int master;
	unsigned int index;
};

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

enum nf_dev_hooks {
	NF_NETDEV_INGRESS = 0,
	NF_NETDEV_EGRESS = 1,
	NF_NETDEV_NUMHOOKS = 2,
};

enum tcx_action_base {
	TCX_NEXT = -1,
	TCX_PASS = 0,
	TCX_DROP = 2,
	TCX_REDIRECT = 7,
};

struct netdev_adjacent {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

struct dev_kfree_skb_cb {
	enum skb_drop_reason reason;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct net_device_path_stack {
	int num_paths;
	struct net_device_path path[5];
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct netdev_notifier_offload_xstats_rd;

struct netdev_notifier_offload_xstats_ru;

struct netdev_notifier_offload_xstats_info {
	struct netdev_notifier_info info;
	enum netdev_offload_xstats_type type;
	union {
		struct netdev_notifier_offload_xstats_rd *report_delta;
		struct netdev_notifier_offload_xstats_ru *report_used;
	};
};

struct netdev_notifier_offload_xstats_rd {
	struct rtnl_hw_stats64 stats;
	bool used;
};

struct netdev_notifier_offload_xstats_ru {
	bool used;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct dpll_pin;

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

enum {
	ETHTOOL_A_FEC_UNSPEC = 0,
	ETHTOOL_A_FEC_HEADER = 1,
	ETHTOOL_A_FEC_MODES = 2,
	ETHTOOL_A_FEC_AUTO = 3,
	ETHTOOL_A_FEC_ACTIVE = 4,
	ETHTOOL_A_FEC_STATS = 5,
	__ETHTOOL_A_FEC_CNT = 6,
	ETHTOOL_A_FEC_MAX = 5,
};

enum {
	ETHTOOL_A_FEC_STAT_UNSPEC = 0,
	ETHTOOL_A_FEC_STAT_PAD = 1,
	ETHTOOL_A_FEC_STAT_CORRECTED = 2,
	ETHTOOL_A_FEC_STAT_UNCORR = 3,
	ETHTOOL_A_FEC_STAT_CORR_BITS = 4,
	__ETHTOOL_A_FEC_STAT_CNT = 5,
	ETHTOOL_A_FEC_STAT_MAX = 4,
};

struct fec_stat_grp {
	u64 stats[9];
	u8 cnt;
};

struct fec_reply_data {
	struct ethnl_reply_data base;
	unsigned long fec_link_modes[2];
	u32 active_fec;
	u8 fec_auto;
	struct fec_stat_grp corr;
	struct fec_stat_grp uncorr;
	struct fec_stat_grp corr_bits;
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

enum packet_sock_flags {
	PACKET_SOCK_ORIGDEV = 0,
	PACKET_SOCK_AUXDATA = 1,
	PACKET_SOCK_TX_HAS_OFF = 2,
	PACKET_SOCK_TP_LOSS = 3,
	PACKET_SOCK_RUNNING = 4,
	PACKET_SOCK_PRESSURE = 5,
	PACKET_SOCK_QDISC_BYPASS = 6,
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	unsigned short kactive_blk_num;
	unsigned short blk_sizeof_priv;
	unsigned short last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	unsigned short retire_blk_tov;
	unsigned short version;
	unsigned long tov_in_jiffies;
	struct timer_list retire_blk_timer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int __attribute__((btf_type_tag("percpu"))) *pending_refcnt;
	union {
		unsigned long *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_fanout;

struct packet_rollover;

struct packet_mclist;

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	unsigned long flags;
	int ifindex;
	u8 vnet_hdr_sz;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_long_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device __attribute__((btf_type_tag("rcu"))) *cached_dev;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t tp_drops;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog __attribute__((btf_type_tag("rcu"))) *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	long: 64;
	struct packet_type prot_hook;
	struct sock __attribute__((btf_type_tag("rcu"))) *arr[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct pgv {
	char *buffer;
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 history[16];
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	unsigned short type;
	unsigned short alen;
	unsigned char addr[32];
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct sockaddr_ll {
	unsigned short sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	unsigned short sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct sockaddr_pkt {
	unsigned short spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

struct tpacket_hdr;

struct tpacket2_hdr;

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct tpacket_hdr {
	unsigned long tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	unsigned short tp_mac;
	unsigned short tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr hdr;
	__virtio16 num_buffers;
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct packet_mreq_max {
	int mr_ifindex;
	unsigned short mr_type;
	unsigned short mr_alen;
	unsigned char mr_address[32];
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

enum {
	GSSX_NULL = 0,
	GSSX_INDICATE_MECHS = 1,
	GSSX_GET_CALL_CONTEXT = 2,
	GSSX_IMPORT_AND_CANON_NAME = 3,
	GSSX_EXPORT_CRED = 4,
	GSSX_IMPORT_CRED = 5,
	GSSX_ACQUIRE_CRED = 6,
	GSSX_STORE_CRED = 7,
	GSSX_INIT_SEC_CONTEXT = 8,
	GSSX_ACCEPT_SEC_CONTEXT = 9,
	GSSX_RELEASE_HANDLE = 10,
	GSSX_GET_MIC = 11,
	GSSX_VERIFY = 12,
	GSSX_WRAP = 13,
	GSSX_UNWRAP = 14,
	GSSX_WRAP_SIZE_LIMIT = 15,
};

struct errormap {
	char *name;
	int val;
	int namelen;
	struct hlist_node list;
};

typedef struct {
	void *read;
	void *write;
} efi_pci_io_protocol_access_t;

typedef enum {
	EfiPciIoWidthUint8 = 0,
	EfiPciIoWidthUint16 = 1,
	EfiPciIoWidthUint32 = 2,
	EfiPciIoWidthUint64 = 3,
	EfiPciIoWidthFifoUint8 = 4,
	EfiPciIoWidthFifoUint16 = 5,
	EfiPciIoWidthFifoUint32 = 6,
	EfiPciIoWidthFifoUint64 = 7,
	EfiPciIoWidthFillUint8 = 8,
	EfiPciIoWidthFillUint16 = 9,
	EfiPciIoWidthFillUint32 = 10,
	EfiPciIoWidthFillUint64 = 11,
	EfiPciIoWidthMaximum = 12,
} EFI_PCI_IO_PROTOCOL_WIDTH;

union efi_pci_io_protocol;

typedef union efi_pci_io_protocol efi_pci_io_protocol_t;

typedef efi_status_t (*efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *, EFI_PCI_IO_PROTOCOL_WIDTH, u32, unsigned long, void *);

typedef struct {
	efi_pci_io_protocol_cfg_t read;
	efi_pci_io_protocol_cfg_t write;
} efi_pci_io_protocol_config_access_t;

typedef struct {
	u32 read;
	u32 write;
} efi_pci_io_protocol_access_32_t;

union efi_pci_io_protocol {
	struct {
		void *poll_mem;
		void *poll_io;
		efi_pci_io_protocol_access_t mem;
		efi_pci_io_protocol_access_t io;
		efi_pci_io_protocol_config_access_t pci;
		void *copy_mem;
		void *map;
		void *unmap;
		void *allocate_buffer;
		void *free_buffer;
		void *flush;
		efi_status_t (*get_location)(efi_pci_io_protocol_t *, unsigned long *, unsigned long *, unsigned long *, unsigned long *);
		void *attributes;
		void *get_bar_attributes;
		void *set_bar_attributes;
		uint64_t romsize;
		void *romimage;
	};
	struct {
		u32 poll_mem;
		u32 poll_io;
		efi_pci_io_protocol_access_32_t mem;
		efi_pci_io_protocol_access_32_t io;
		efi_pci_io_protocol_access_32_t pci;
		u32 copy_mem;
		u32 map;
		u32 unmap;
		u32 allocate_buffer;
		u32 free_buffer;
		u32 flush;
		u32 get_location;
		u32 attributes;
		u32 get_bar_attributes;
		u32 set_bar_attributes;
		u64 romsize;
		u32 romimage;
	} mixed_mode;
};

struct mpidr_hash {
	u64 mask;
	u32 shift_aff[4];
	u32 bits;
};

struct arm64_image_header {
	__le32 code0;
	__le32 code1;
	__le64 text_offset;
	__le64 image_size;
	__le64 flags;
	__le64 res2;
	__le64 res3;
	__le64 res4;
	__le32 magic;
	__le32 res5;
};

typedef void (*btf_trace_kvm_entry)(void *, unsigned long);

typedef void (*btf_trace_kvm_exit)(void *, int, unsigned int, unsigned long);

typedef void (*btf_trace_kvm_guest_fault)(void *, unsigned long, unsigned long, unsigned long, unsigned long long);

typedef void (*btf_trace_kvm_access_fault)(void *, unsigned long);

typedef void (*btf_trace_kvm_irq_line)(void *, unsigned int, int, int, int);

typedef void (*btf_trace_kvm_mmio_emulate)(void *, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_kvm_mmio_nisv)(void *, unsigned long, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_kvm_set_way_flush)(void *, unsigned long, bool);

typedef void (*btf_trace_kvm_toggle_cache)(void *, unsigned long, bool, bool);

typedef void (*btf_trace_kvm_timer_update_irq)(void *, unsigned long, __u32, int);

typedef void (*btf_trace_kvm_get_timer_map)(void *, unsigned long, struct timer_map *);

typedef void (*btf_trace_kvm_timer_save_state)(void *, struct arch_timer_context *);

typedef void (*btf_trace_kvm_timer_restore_state)(void *, struct arch_timer_context *);

typedef void (*btf_trace_kvm_timer_hrtimer_expire)(void *, struct arch_timer_context *);

typedef void (*btf_trace_kvm_timer_emulate)(void *, struct arch_timer_context *, bool);

typedef void (*btf_trace_kvm_nested_eret)(void *, struct kvm_vcpu *, unsigned long, unsigned long);

typedef void (*btf_trace_kvm_inject_nested_exception)(void *, struct kvm_vcpu *, u64, int);

typedef void (*btf_trace_kvm_forward_sysreg_trap)(void *, struct kvm_vcpu *, u32, bool);

enum {
	OUTSIDE_GUEST_MODE = 0,
	IN_GUEST_MODE = 1,
	EXITING_GUEST_MODE = 2,
	READING_SHADOW_PAGE_TABLES = 3,
};

struct trace_event_raw_kvm_entry {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	char __data[0];
};

struct trace_event_raw_kvm_exit {
	struct trace_entry ent;
	int ret;
	unsigned int esr_ec;
	unsigned long vcpu_pc;
	char __data[0];
};

struct trace_event_raw_kvm_guest_fault {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	unsigned long hsr;
	unsigned long hxfar;
	unsigned long long ipa;
	char __data[0];
};

struct trace_event_raw_kvm_access_fault {
	struct trace_entry ent;
	unsigned long ipa;
	char __data[0];
};

struct trace_event_raw_kvm_irq_line {
	struct trace_entry ent;
	unsigned int type;
	int vcpu_idx;
	int irq_num;
	int level;
	char __data[0];
};

struct trace_event_raw_kvm_mmio_emulate {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	unsigned long instr;
	unsigned long cpsr;
	char __data[0];
};

struct trace_event_raw_kvm_mmio_nisv {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	unsigned long esr;
	unsigned long far;
	unsigned long ipa;
	char __data[0];
};

struct trace_event_raw_kvm_set_way_flush {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	bool cache;
	char __data[0];
};

struct trace_event_raw_kvm_toggle_cache {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	bool was;
	bool now;
	char __data[0];
};

struct trace_event_raw_kvm_timer_update_irq {
	struct trace_entry ent;
	unsigned long vcpu_id;
	__u32 irq;
	int level;
	char __data[0];
};

struct trace_event_raw_kvm_get_timer_map {
	struct trace_entry ent;
	unsigned long vcpu_id;
	int direct_vtimer;
	int direct_ptimer;
	int emul_vtimer;
	int emul_ptimer;
	char __data[0];
};

struct trace_event_raw_kvm_timer_save_state {
	struct trace_entry ent;
	unsigned long ctl;
	unsigned long long cval;
	int timer_idx;
	char __data[0];
};

struct trace_event_raw_kvm_timer_restore_state {
	struct trace_entry ent;
	unsigned long ctl;
	unsigned long long cval;
	int timer_idx;
	char __data[0];
};

struct trace_event_raw_kvm_timer_hrtimer_expire {
	struct trace_entry ent;
	int timer_idx;
	char __data[0];
};

struct trace_event_raw_kvm_timer_emulate {
	struct trace_entry ent;
	int timer_idx;
	bool should_fire;
	char __data[0];
};

struct trace_event_raw_kvm_nested_eret {
	struct trace_entry ent;
	struct kvm_vcpu *vcpu;
	unsigned long elr_el2;
	unsigned long spsr_el2;
	unsigned long target_mode;
	unsigned long hcr_el2;
	char __data[0];
};

struct trace_event_raw_kvm_inject_nested_exception {
	struct trace_entry ent;
	struct kvm_vcpu *vcpu;
	unsigned long esr_el2;
	int type;
	unsigned long spsr_el2;
	unsigned long pc;
	unsigned long source_mode;
	unsigned long hcr_el2;
	char __data[0];
};

struct trace_event_raw_kvm_forward_sysreg_trap {
	struct trace_entry ent;
	u64 pc;
	u32 sysreg;
	bool is_read;
	char __data[0];
};

struct kvm_host_data___2 {
	struct kvm_cpu_context host_ctxt;
};

struct kvm_vcpu_init {
	__u32 target;
	__u32 features[7];
};

struct trace_event_data_offsets_kvm_entry {};

struct trace_event_data_offsets_kvm_exit {};

struct trace_event_data_offsets_kvm_guest_fault {};

struct trace_event_data_offsets_kvm_access_fault {};

struct trace_event_data_offsets_kvm_irq_line {};

struct trace_event_data_offsets_kvm_mmio_emulate {};

struct trace_event_data_offsets_kvm_mmio_nisv {};

struct trace_event_data_offsets_kvm_set_way_flush {};

struct trace_event_data_offsets_kvm_toggle_cache {};

struct trace_event_data_offsets_kvm_timer_update_irq {};

struct trace_event_data_offsets_kvm_get_timer_map {};

struct trace_event_data_offsets_kvm_timer_save_state {};

struct trace_event_data_offsets_kvm_timer_restore_state {};

struct trace_event_data_offsets_kvm_timer_hrtimer_expire {};

struct trace_event_data_offsets_kvm_timer_emulate {};

struct trace_event_data_offsets_kvm_nested_eret {};

struct trace_event_data_offsets_kvm_inject_nested_exception {};

struct trace_event_data_offsets_kvm_forward_sysreg_trap {};

struct kvm_enable_cap {
	__u32 cap;
	__u32 flags;
	__u64 args[4];
	__u8 pad[64];
};

struct kvm_irq_level {
	union {
		__u32 irq;
		__s32 status;
	};
	__u32 level;
};

struct kvm_reg_list {
	__u64 n;
	__u64 reg[0];
};

struct tlb_inv_context___2 {
	struct kvm_s2_mmu___2 *mmu;
	unsigned long flags;
	u64 tcr;
	u64 sctlr;
};

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

enum sig_handler {
	HANDLER_CURRENT = 0,
	HANDLER_SIG_DFL = 1,
	HANDLER_EXIT = 2,
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	unsigned long sa_handler;
	unsigned long sa_flags;
	char __data[0];
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

struct sigaltstack {
	void __attribute__((btf_type_tag("user"))) *ss_sp;
	int ss_flags;
	__kernel_size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct compat_sigaltstack {
	compat_uptr_t ss_sp;
	int ss_flags;
	compat_size_t ss_size;
};

typedef struct compat_sigaltstack compat_stack_t;

struct compat_sigaction {
	compat_uptr_t sa_handler;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
	compat_sigset_t sa_mask;
};

struct compat_old_sigaction {
	compat_uptr_t sa_handler;
	compat_old_sigset_t sa_mask;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_signal_deliver {};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

enum {
	Q_REQUEUE_PI_NONE = 0,
	Q_REQUEUE_PI_IGNORE = 1,
	Q_REQUEUE_PI_IN_PROGRESS = 2,
	Q_REQUEUE_PI_WAIT = 3,
	Q_REQUEUE_PI_DONE = 4,
	Q_REQUEUE_PI_LOCKED = 5,
};

struct compat_kexec_segment {
	compat_uptr_t buf;
	compat_size_t bufsz;
	compat_ulong_t mem;
	compat_size_t memsz;
};

struct action_cache {
	unsigned long allow_native[8];
	unsigned long allow_compat[8];
};

struct notification;

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	bool wait_killable_recv;
	struct action_cache cache;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct notification {
	atomic_t requests;
	u32 flags;
	u64 next_id;
	struct list_head notifications;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	__u32 ioctl_flags;
	union {
		bool setfd;
		int ret;
	};
	struct completion completion;
	struct list_head list;
};

struct seccomp_knotif {
	struct task_struct *task;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct bpf_preload_info;

struct bpf_preload_ops {
	int (*preload)(struct bpf_preload_info *);
	struct module *owner;
};

struct bpf_preload_info {
	char link_name[16];
	struct bpf_link *link;
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

enum {
	OPT_MODE = 0,
};

struct map_iter {
	void *key;
	bool done;
};

struct bpf_mount_opts {
	umode_t mode;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
};

typedef void (*btf_trace_hugepage_set_pmd)(void *, unsigned long, unsigned long);

typedef void (*btf_trace_hugepage_set_pud)(void *, unsigned long, unsigned long);

typedef void (*btf_trace_hugepage_update_pmd)(void *, unsigned long, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_hugepage_update_pud)(void *, unsigned long, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_set_migration_pmd)(void *, unsigned long, unsigned long);

typedef void (*btf_trace_remove_migration_pmd)(void *, unsigned long, unsigned long);

struct trace_event_raw_hugepage_set {
	struct trace_entry ent;
	unsigned long addr;
	unsigned long pte;
	char __data[0];
};

struct trace_event_raw_hugepage_update {
	struct trace_entry ent;
	unsigned long addr;
	unsigned long pte;
	unsigned long clr;
	unsigned long set;
	char __data[0];
};

struct trace_event_raw_migration_pmd {
	struct trace_entry ent;
	unsigned long addr;
	unsigned long pmd;
	char __data[0];
};

struct trace_event_data_offsets_hugepage_set {};

struct trace_event_data_offsets_hugepage_update {};

struct trace_event_data_offsets_migration_pmd {};

struct kioctx_cpu;

struct ctx_rq_wait;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	unsigned long user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	unsigned long mmap_base;
	unsigned long mmap_size;
	struct page **ring_pages;
	long nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	long: 64;
	long: 64;
	long: 64;
	struct {
		atomic_t reqs_available;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct page *internal_pages[8];
	struct file *aio_ring_file;
	unsigned int id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool cancelled;
	bool work_scheduled;
	bool work_need_resched;
	struct wait_queue_entry wait;
	struct work_struct work;
};

typedef int kiocb_cancel_fn(struct kiocb *);

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

typedef __kernel_ulong_t aio_context_t;

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	bool queued;
	int error;
};

typedef u32 compat_aio_context_t;

struct __aio_sigset {
	const sigset_t __attribute__((btf_type_tag("user"))) *sigmask;
	size_t sigsetsize;
};

struct __compat_aio_sigset {
	compat_uptr_t sigmask;
	compat_size_t sigsetsize;
};

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct ext4_orphan_block_tail {
	__le32 ob_magic;
	__le32 ob_checksum;
};

struct squashfs_fragment_entry {
	__le64 start_block;
	__le32 size;
	unsigned int unused;
};

enum {
	PARSE_INVALID = 1,
	PARSE_NOT_LONGNAME = 2,
	PARSE_EOF = 3,
};

typedef unsigned long long llu;

struct __fat_dirent {
	long d_ino;
	__kernel_off_t d_off;
	unsigned short d_reclen;
	char d_name[256];
};

struct fat_ioctl_filldir_callback {
	struct dir_context ctx;
	void __attribute__((btf_type_tag("user"))) *dirent;
	int result;
	const char *longname;
	int long_len;
	const char *shortname;
	int short_len;
};

struct compat_dirent {
	u32 d_ino;
	compat_off_t d_off;
	u16 d_reclen;
	char d_name[256];
};

struct nfs_netns_client {
	struct kobject kobject;
	struct kobject nfs_net_kobj;
	struct net *net;
	const char __attribute__((btf_type_tag("rcu"))) *identifier;
};

enum nfs_ftype4 {
	NF4BAD = 0,
	NF4REG = 1,
	NF4DIR = 2,
	NF4BLK = 3,
	NF4CHR = 4,
	NF4LNK = 5,
	NF4SOCK = 6,
	NF4FIFO = 7,
	NF4ATTRDIR = 8,
	NF4NAMEDATTR = 9,
};

enum {
	FATTR4_DIR_NOTIF_DELAY = 56,
	FATTR4_DIRENT_NOTIF_DELAY = 57,
	FATTR4_DACL = 58,
	FATTR4_SACL = 59,
	FATTR4_CHANGE_POLICY = 60,
	FATTR4_FS_STATUS = 61,
	FATTR4_FS_LAYOUT_TYPES = 62,
	FATTR4_LAYOUT_HINT = 63,
	FATTR4_LAYOUT_TYPES = 64,
	FATTR4_LAYOUT_BLKSIZE = 65,
	FATTR4_LAYOUT_ALIGNMENT = 66,
	FATTR4_FS_LOCATIONS_INFO = 67,
	FATTR4_MDSTHRESHOLD = 68,
	FATTR4_RETENTION_GET = 69,
	FATTR4_RETENTION_SET = 70,
	FATTR4_RETENTEVT_GET = 71,
	FATTR4_RETENTEVT_SET = 72,
	FATTR4_RETENTION_HOLD = 73,
	FATTR4_MODE_SET_MASKED = 74,
	FATTR4_SUPPATTR_EXCLCREAT = 75,
	FATTR4_FS_CHARSET_CAP = 76,
};

enum {
	FATTR4_CLONE_BLKSIZE = 77,
	FATTR4_SPACE_FREED = 78,
	FATTR4_CHANGE_ATTR_TYPE = 79,
	FATTR4_SEC_LABEL = 80,
};

enum opentype4 {
	NFS4_OPEN_NOCREATE = 0,
	NFS4_OPEN_CREATE = 1,
};

enum {
	FATTR4_MODE_UMASK = 81,
};

enum open_delegation_type4 {
	NFS4_OPEN_DELEGATE_NONE = 0,
	NFS4_OPEN_DELEGATE_READ = 1,
	NFS4_OPEN_DELEGATE_WRITE = 2,
	NFS4_OPEN_DELEGATE_NONE_EXT = 3,
};

enum limit_by4 {
	NFS4_LIMIT_SIZE = 1,
	NFS4_LIMIT_BLOCKS = 2,
};

enum why_no_delegation4 {
	WND4_NOT_WANTED = 0,
	WND4_CONTENTION = 1,
	WND4_RESOURCE = 2,
	WND4_NOT_SUPP_FTYPE = 3,
	WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
	WND4_NOT_SUPP_UPGRADE = 5,
	WND4_NOT_SUPP_DOWNGRADE = 6,
	WND4_CANCELLED = 7,
	WND4_IS_DIR = 8,
};

enum {
	FATTR4_XATTR_SUPPORT = 82,
};

enum lock_type4 {
	NFS4_UNLOCK_LT = 0,
	NFS4_READ_LT = 1,
	NFS4_WRITE_LT = 2,
	NFS4_READW_LT = 3,
	NFS4_WRITEW_LT = 4,
};

enum nfs4_acl_type {
	NFS4ACL_NONE = 0,
	NFS4ACL_ACL = 1,
	NFS4ACL_DACL = 2,
	NFS4ACL_SACL = 3,
};

enum state_protect_how4 {
	SP4_NONE = 0,
	SP4_MACH_CRED = 1,
	SP4_SSV = 2,
};

enum data_content4 {
	NFS4_CONTENT_DATA = 0,
	NFS4_CONTENT_HOLE = 1,
};

struct compound_hdr {
	int32_t status;
	uint32_t nops;
	__be32 *nops_p;
	uint32_t taglen;
	char *tag;
	uint32_t replen;
	u32 minorversion;
};

struct nfs_setattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct iattr *iap;
	const struct nfs_server *server;
	const u32 *bitmask;
	const struct nfs4_label *label;
};

typedef u64 clientid4;

struct nfs4_setclientid {
	const nfs4_verifier *sc_verifier;
	u32 sc_prog;
	unsigned int sc_netid_len;
	char sc_netid[6];
	unsigned int sc_uaddr_len;
	char sc_uaddr[58];
	struct nfs_client *sc_clnt;
	struct rpc_cred *sc_cred;
};

struct nfs_lock_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *lock_seqid;
	nfs4_stateid lock_stateid;
	struct nfs_seqid *open_seqid;
	nfs4_stateid open_stateid;
	struct nfs_lowner lock_owner;
	unsigned char block: 1;
	unsigned char reclaim: 1;
	unsigned char new_lock: 1;
	unsigned char new_lock_owner: 1;
};

struct nfs_lock_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *lock_seqid;
	struct nfs_seqid *open_seqid;
};

struct nfs_lockt_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_lowner lock_owner;
};

struct nfs_lockt_res {
	struct nfs4_sequence_res seq_res;
	struct file_lock *denied;
};

struct nfs_locku_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *seqid;
	nfs4_stateid stateid;
};

struct nfs_locku_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs4_create_arg {
	struct nfs4_sequence_args seq_args;
	u32 ftype;
	union {
		struct {
			struct page **pages;
			unsigned int len;
		} symlink;
		struct {
			u32 specdata1;
			u32 specdata2;
		} device;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const struct iattr *attrs;
	const struct nfs_fh *dir_fh;
	const u32 *bitmask;
	const struct nfs4_label *label;
	umode_t umask;
};

struct nfs4_readlink {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs4_readdir_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	u64 cookie;
	nfs4_verifier verifier;
	u32 count;
	struct page **pages;
	unsigned int pgbase;
	const u32 *bitmask;
	bool plus;
};

struct nfs4_readdir_res {
	struct nfs4_sequence_res seq_res;
	nfs4_verifier verifier;
	unsigned int pgbase;
};

struct nfs4_server_caps_res {
	struct nfs4_sequence_res seq_res;
	u32 attr_bitmask[3];
	u32 exclcreat_bitmask[3];
	u32 acl_bitmask;
	u32 has_links;
	u32 has_symlinks;
	u32 fh_expire_type;
	u32 case_insensitive;
	u32 case_preserving;
};

struct nfs_getaclres {
	struct nfs4_sequence_res seq_res;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	size_t acl_data_offset;
	int acl_flags;
	struct page *acl_scratch;
};

struct nfs_setaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs4_secinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_secinfo_flavors *flavors;
};

struct nfs4_op_map {
	union {
		unsigned long longs[2];
		u32 words[4];
	} u;
};

struct nfs41_state_protection {
	u32 how;
	struct nfs4_op_map enforce;
	struct nfs4_op_map allow;
};

struct nfs41_exchange_id_args {
	struct nfs_client *client;
	nfs4_verifier verifier;
	u32 flags;
	struct nfs41_state_protection state_protect;
};

struct nfs41_exchange_id_res {
	u64 clientid;
	u32 seqid;
	u32 flags;
	struct nfs41_server_owner *server_owner;
	struct nfs41_server_scope *server_scope;
	struct nfs41_impl_id *impl_id;
	struct nfs41_state_protection state_protect;
};

struct nfs41_create_session_args {
	struct nfs_client *client;
	u64 clientid;
	uint32_t seqid;
	uint32_t flags;
	uint32_t cb_program;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_channel_attrs bc_attrs;
};

struct nfs41_create_session_res {
	struct nfs4_sessionid sessionid;
	uint32_t seqid;
	uint32_t flags;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_channel_attrs bc_attrs;
};

struct nfs41_reclaim_complete_args {
	struct nfs4_sequence_args seq_args;
	unsigned char one_fs: 1;
};

struct nfs4_getdeviceinfo_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_device *pdev;
	__u32 notify_types;
};

struct nfs4_getdeviceinfo_res {
	struct nfs4_sequence_res seq_res;
	struct pnfs_device *pdev;
	__u32 notification;
};

struct nfs41_secinfo_no_name_args {
	struct nfs4_sequence_args seq_args;
	int style;
};

struct nfs41_test_stateid_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid *stateid;
};

struct nfs41_test_stateid_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
};

struct nfs41_free_stateid_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid stateid;
};

struct nfs41_free_stateid_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
};

struct nfs41_bind_conn_to_session_args {
	struct nfs_client *client;
	struct nfs4_sessionid sessionid;
	u32 dir;
	bool use_conn_in_rdma_mode;
	int retries;
};

struct nfs41_bind_conn_to_session_res {
	struct nfs4_sessionid sessionid;
	u32 dir;
	bool use_conn_in_rdma_mode;
};

struct nfs42_falloc_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
	struct nfs_fattr *falloc_fattr;
	const struct nfs_server *falloc_server;
};

struct nfs42_offload_status_res {
	struct nfs4_sequence_res osr_seq_res;
	uint64_t osr_count;
	int osr_status;
};

struct nfs42_getxattrres {
	struct nfs4_sequence_res seq_res;
	size_t xattr_len;
};

struct nfs42_setxattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const u32 *bitmask;
	const char *xattr_name;
	u32 xattr_flags;
	size_t xattr_len;
	struct page **xattr_pages;
};

struct nfs42_listxattrsargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	u32 count;
	u64 cookie;
	struct page **xattr_pages;
};

struct nfs42_listxattrsres {
	struct nfs4_sequence_res seq_res;
	struct page *scratch;
	void *xattr_buf;
	size_t xattr_len;
	u64 cookie;
	bool eof;
	size_t copied;
};

struct read_plus_segment {
	enum data_content4 type;
	uint64_t offset;
	union {
		struct {
			uint64_t length;
		} hole;
		struct {
			uint32_t length;
			unsigned int from;
		} data;
	};
};

struct nfs_setattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
};

struct nfs4_fsinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_fsinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsinfo *fsinfo;
};

struct nfs4_accessargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
	u32 access;
};

struct nfs4_accessres {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	u32 supported;
	u32 access;
};

struct nfs4_getattr_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_getattr_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
};

struct nfs4_lookup_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_lookup_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
};

struct nfs4_lookup_root_arg {
	struct nfs4_sequence_args seq_args;
	const u32 *bitmask;
};

struct nfs4_link_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_link_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs4_change_info cinfo;
	struct nfs_fattr *dir_attr;
};

struct nfs4_create_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_change_info dir_cinfo;
};

struct nfs4_pathconf_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_pathconf_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_pathconf *pathconf;
};

struct nfs4_statfs_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_statfs_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsstat *fsstat;
};

struct nfs4_readlink_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_server_caps_arg {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fhandle;
	const u32 *bitmask;
};

struct nfs_getaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_setaclres {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_fs_locations_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct nfs_fh *fh;
	const struct qstr *name;
	struct page *page;
	const u32 *bitmask;
	clientid4 clientid;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_fs_locations_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_fs_locations *fs_locations;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs_release_lockowner_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_lowner lock_owner;
};

struct nfs4_secinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
};

struct nfs4_fsid_present_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	clientid4 clientid;
	unsigned char renew: 1;
};

struct nfs4_fsid_present_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fh *fh;
	unsigned char renew: 1;
};

struct nfs4_get_lease_time_args {
	struct nfs4_sequence_args la_seq_args;
};

struct nfs4_get_lease_time_res {
	struct nfs4_sequence_res lr_seq_res;
	struct nfs_fsinfo *lr_fsinfo;
};

struct nfs41_reclaim_complete_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs42_clone_res {
	struct nfs4_sequence_res seq_res;
	unsigned int rpc_status;
	struct nfs_fattr *dst_fattr;
	const struct nfs_server *server;
};

struct nfs4_lookupp_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_lookupp_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
};

struct nfs42_layouterror_args {
	struct nfs4_sequence_args seq_args;
	struct inode *inode;
	unsigned int num_errors;
	struct nfs42_layout_error errors[5];
};

struct nfs42_layouterror_res {
	struct nfs4_sequence_res seq_res;
	unsigned int num_errors;
	int rpc_status;
};

struct nfs42_getxattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
	size_t xattr_len;
	struct page **xattr_pages;
};

struct nfs42_setxattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs4_change_info cinfo;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
};

struct nfs42_removexattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
};

struct nfs42_removexattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs4_change_info cinfo;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

struct tracefs_fs_info {
	struct tracefs_mount_opts mount_opts;
};

struct crypto_istat_hash {
	atomic64_t hash_cnt;
	atomic64_t hash_tlen;
	atomic64_t err_cnt;
};

struct crypto_report_hash {
	char type[64];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

enum blacklist_hash_type {
	BLACKLIST_HASH_X509_TBS = 1,
	BLACKLIST_HASH_BINARY = 2,
};

struct pr_keys {
	u32 generation;
	u32 num_keys;
	u64 keys[0];
};

struct pr_held_reservation {
	u64 key;
	u32 generation;
	enum pr_type type;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct compat_hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	unsigned short cylinders;
	u32 start;
};

struct compat_blkpg_ioctl_arg {
	compat_int_t op;
	compat_int_t flags;
	compat_int_t datalen;
	compat_caddr_t data;
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	u32 repeats;
	struct list_head list;
	struct io_kiocb *head;
	struct io_kiocb *prev;
};

struct io_timeout_rem {
	struct file *file;
	u64 addr;
	struct timespec64 ts;
	u32 flags;
	bool ltimeout;
};

struct io_timeout_data {
	struct io_kiocb *req;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
	u32 flags;
};

typedef struct {
	__be64 a;
	__be64 b;
} be128;

struct gf128mul_4k;

struct gf128mul_64k {
	struct gf128mul_4k *t[16];
};

struct gf128mul_4k {
	be128 t[256];
};

typedef struct {
	__le64 b;
	__le64 a;
} le128;

enum gcry_mpi_constants {
	MPI_C_ZERO = 0,
	MPI_C_ONE = 1,
	MPI_C_TWO = 2,
	MPI_C_THREE = 3,
	MPI_C_FOUR = 4,
	MPI_C_EIGHT = 5,
};

struct sunxi_sc_nmi_reg_offs {
	u32 ctrl;
	u32 pend;
	u32 enable;
};

enum {
	SUNXI_SRC_TYPE_LEVEL_LOW = 0,
	SUNXI_SRC_TYPE_EDGE_FALLING = 1,
	SUNXI_SRC_TYPE_LEVEL_HIGH = 2,
	SUNXI_SRC_TYPE_EDGE_RISING = 3,
};

struct mtk_sysirq_chip_data {
	raw_spinlock_t lock;
	u32 nr_intpol_bases;
	void **intpol_bases;
	u32 *intpol_words;
	u8 *intpol_idx;
	u16 *which_word;
};

struct fsl_mc_child_objs {
	int child_count;
	struct fsl_mc_obj_desc *child_array;
};

struct phy_axg_pcie_priv {
	struct phy *phy;
	struct phy *analog;
	struct regmap *regmap;
	struct reset_control *reset;
};

struct rockchip_p3phy_priv;

struct rockchip_p3phy_ops {
	int (*phy_init)(struct rockchip_p3phy_priv *);
};

struct rockchip_p3phy_priv {
	const struct rockchip_p3phy_ops *ops;
	void *mmio;
	int mode;
	int pcie30_phymode;
	struct regmap *phy_grf;
	struct regmap *pipe_grf;
	struct reset_control *p30phy;
	struct phy *phy;
	struct clk_bulk_data *clks;
	int num_clks;
	int num_lanes;
	u32 lanes[4];
};

struct ns2_pinconf {
	unsigned int base;
	unsigned int offset;
	unsigned int src_shift;
	unsigned int input_en;
	unsigned int pull_shift;
	unsigned int drive_shift;
};

struct ns2_pin {
	unsigned int pin;
	char *name;
	struct ns2_pinconf pin_conf;
};

struct ns2_mux {
	unsigned int base;
	unsigned int offset;
	unsigned int shift;
	unsigned int mask;
	unsigned int alt;
};

struct ns2_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int num_pins;
	const struct ns2_mux mux;
};

struct ns2_pin_function {
	const char *name;
	const char * const *groups;
	const unsigned int num_groups;
};

struct ns2_mux_log;

struct ns2_pinctrl {
	struct pinctrl_dev *pctl;
	struct device *dev;
	void *base0;
	void *base1;
	void *pinconf_base;
	const struct ns2_pin_group *groups;
	unsigned int num_groups;
	const struct ns2_pin_function *functions;
	unsigned int num_functions;
	struct ns2_mux_log *mux_log;
	spinlock_t lock;
};

struct ns2_mux_log {
	struct ns2_mux mux;
	bool is_configured;
};

struct meson8_pmx_data {
	bool is_gpio;
	unsigned int reg;
	unsigned int bit;
};

struct rtd_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pcdev;
	void *base;
	struct pinctrl_desc desc;
	const struct rtd_pinctrl_desc *info;
	struct regmap *regmap_pinctrl;
};

struct mb86s70_gpio_chip {
	struct gpio_chip gc;
	void *base;
	struct clk *clk;
	spinlock_t lock;
};

struct xgene_pcie {
	struct device_node *node;
	struct device *dev;
	struct clk *clk;
	void *csr_base;
	void *cfg_base;
	unsigned long cfg_addr;
	bool link_up;
	u32 version;
};

enum {
	ACPI_GENL_CMD_UNSPEC = 0,
	ACPI_GENL_CMD_EVENT = 1,
	__ACPI_GENL_CMD_MAX = 2,
};

enum {
	ACPI_GENL_ATTR_UNSPEC = 0,
	ACPI_GENL_ATTR_EVENT = 1,
	__ACPI_GENL_ATTR_MAX = 2,
};

struct acpi_bus_event {
	struct list_head node;
	acpi_device_class device_class;
	acpi_bus_id bus_id;
	u32 type;
	u32 data;
};

struct acpi_genl_event {
	acpi_device_class device_class;
	char bus_id[15];
	u32 type;
	u32 data;
};

struct cppc_pcc_data {
	struct pcc_mbox_chan *pcc_channel;
	void *pcc_comm_addr;
	bool pcc_channel_acquired;
	unsigned int deadline_us;
	unsigned int pcc_mpar;
	unsigned int pcc_mrtt;
	unsigned int pcc_nominal;
	bool pending_pcc_write_cmd;
	bool platform_owns_pcc;
	unsigned int pcc_write_cnt;
	struct rw_semaphore pcc_lock;
	wait_queue_head_t pcc_write_wait_q;
	ktime_t last_cmd_cmpl_time;
	ktime_t last_mpar_reset;
	int mpar_count;
	int refcount;
};

struct cpc_register_resource {
	acpi_object_type type;
	u64 *sys_mem_vaddr;
	union {
		struct cpc_reg reg;
		u64 int_value;
	} cpc_entry;
};

struct cpc_desc {
	int num_entries;
	int version;
	int cpu_id;
	int write_cmd_status;
	int write_cmd_id;
	struct cpc_register_resource cpc_regs[21];
	struct acpi_psd_package domain_info;
	struct kobject kobj;
};

enum cppc_regs {
	HIGHEST_PERF = 0,
	NOMINAL_PERF = 1,
	LOW_NON_LINEAR_PERF = 2,
	LOWEST_PERF = 3,
	GUARANTEED_PERF = 4,
	DESIRED_PERF = 5,
	MIN_PERF = 6,
	MAX_PERF = 7,
	PERF_REDUC_TOLERANCE = 8,
	TIME_WINDOW = 9,
	CTR_WRAP_TIME = 10,
	REFERENCE_CTR = 11,
	DELIVERED_CTR = 12,
	PERF_LIMITED = 13,
	ENABLE = 14,
	AUTO_SEL_ENABLE = 15,
	AUTO_ACT_WINDOW = 16,
	ENERGY_PERF = 17,
	REFERENCE_PERF = 18,
	LOWEST_FREQ = 19,
	NOMINAL_FREQ = 20,
};

struct cppc_perf_caps {
	u32 guaranteed_perf;
	u32 highest_perf;
	u32 nominal_perf;
	u32 lowest_perf;
	u32 lowest_nonlinear_perf;
	u32 lowest_freq;
	u32 nominal_freq;
	u32 energy_perf;
	bool auto_sel;
};

struct cppc_perf_ctrls {
	u32 max_perf;
	u32 min_perf;
	u32 desired_perf;
	u32 energy_perf;
};

struct cppc_perf_fb_ctrs {
	u64 reference;
	u64 delivered;
	u64 reference_perf;
	u64 wraparound_time;
};

struct cppc_cpudata {
	struct list_head node;
	struct cppc_perf_caps perf_caps;
	struct cppc_perf_ctrls perf_ctrls;
	struct cppc_perf_fb_ctrs perf_fb_ctrs;
	unsigned int shared_type;
	cpumask_var_t shared_cpu_map;
};

struct acpi_pcct_shared_memory {
	u32 signature;
	u16 command;
	u16 status;
};

struct clk_multiplier {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	spinlock_t *lock;
};

struct u32_fract {
	__u32 numerator;
	__u32 denominator;
};

struct meson_g12a_data {
	const struct meson_eeclkc_data eeclkc_data;
	int (*dvfs_setup)(struct platform_device *);
};

struct g12a_cpu_clk_postmux_nb_data {
	struct notifier_block nb;
	struct clk_hw *xtal;
	struct clk_hw *cpu_clk_dyn;
	struct clk_hw *cpu_clk_postmux0;
	struct clk_hw *cpu_clk_postmux1;
	struct clk_hw *cpu_clk_premux1;
};

struct g12a_sys_pll_nb_data {
	struct notifier_block nb;
	struct clk_hw *sys_pll;
	struct clk_hw *cpu_clk;
	struct clk_hw *cpu_clk_dyn;
};

struct exynos_arm64_cmu_data {
	struct samsung_clk_reg_dump *clk_save;
	unsigned int nr_clk_save;
	const struct samsung_clk_reg_dump *clk_suspend;
	unsigned int nr_clk_suspend;
	struct clk *clk;
	struct clk **pclks;
	int nr_pclks;
	struct samsung_clk_provider *ctx;
};

struct _ccu_nk {
	unsigned long n;
	unsigned long min_n;
	unsigned long max_n;
	unsigned long k;
	unsigned long min_k;
	unsigned long max_k;
};

enum dpio_channel_mode {
	DPIO_NO_CHANNEL = 0,
	DPIO_LOCAL_CHANNEL = 1,
};

struct dpio_cmd_open {
	__le32 dpio_id;
};

struct dpio_rsp_get_attr {
	__le32 id;
	__le16 qbman_portal_id;
	u8 num_priorities;
	u8 channel_mode;
	__le64 qbman_portal_ce_addr;
	__le64 qbman_portal_ci_addr;
	__le32 qbman_version;
	__le32 pad1;
	__le32 clk;
};

struct dpio_stashing_dest {
	u8 sdest;
};

struct dpio_attr {
	int id;
	u64 qbman_portal_ce_offset;
	u64 qbman_portal_ci_offset;
	u16 qbman_portal_id;
	enum dpio_channel_mode channel_mode;
	u8 num_priorities;
	u32 qbman_version;
	u32 clk;
};

struct rzv2m_pwc_priv {
	void *base;
	struct device *dev;
	struct gpio_chip gp;
	unsigned long ch_en_bits[1];
};

struct rpi_power_domain {
	u32 domain;
	bool enabled;
	bool old_interface;
	struct generic_pm_domain base;
	struct rpi_firmware *fw;
};

struct rpi_power_domains {
	bool has_new_interface;
	struct genpd_onecell_data xlate;
	struct rpi_firmware *fw;
	struct rpi_power_domain domains[23];
};

struct rpi_power_domain_packet {
	u32 domain;
	u32 on;
};

struct gntdev_unmap_notify {
	int flags;
	int addr;
	evtchn_port_t event;
};

struct ioctl_gntdev_grant_ref;

struct gntdev_grant_map {
	atomic_t in_use;
	struct mmu_interval_notifier notifier;
	bool notifier_init;
	struct list_head next;
	int index;
	int count;
	int flags;
	refcount_t users;
	struct gntdev_unmap_notify notify;
	struct ioctl_gntdev_grant_ref *grants;
	struct gnttab_map_grant_ref *map_ops;
	struct gnttab_unmap_grant_ref *unmap_ops;
	struct gnttab_map_grant_ref *kmap_ops;
	struct gnttab_unmap_grant_ref *kunmap_ops;
	bool *being_removed;
	struct page **pages;
	unsigned long pages_vm_start;
	atomic_t live_grants;
	struct gntab_unmap_queue_data unmap_data;
};

struct ioctl_gntdev_grant_ref {
	__u32 domid;
	__u32 ref;
};

struct gntdev_priv {
	struct list_head maps;
	struct mutex lock;
};

struct ioctl_gntdev_map_grant_ref {
	__u32 count;
	__u32 pad;
	__u64 index;
	struct ioctl_gntdev_grant_ref refs[1];
};

struct ioctl_gntdev_unmap_notify {
	__u64 index;
	__u32 action;
	__u32 event_channel_port;
};

struct gntdev_grant_copy_segment;

struct ioctl_gntdev_grant_copy {
	unsigned int count;
	struct gntdev_grant_copy_segment __attribute__((btf_type_tag("user"))) *segments;
};

struct gntdev_grant_copy_segment {
	union {
		void __attribute__((btf_type_tag("user"))) *virt;
		struct {
			grant_ref_t ref;
			__u16 offset;
			domid_t domid;
		} foreign;
	} source;
	union {
		void __attribute__((btf_type_tag("user"))) *virt;
		struct {
			grant_ref_t ref;
			__u16 offset;
			domid_t domid;
		} foreign;
	} dest;
	__u16 len;
	__u16 flags;
	__s16 status;
};

struct gntdev_copy_batch {
	struct gnttab_copy ops[16];
	struct page *pages[16];
	s16 __attribute__((btf_type_tag("user"))) *status[16];
	unsigned int nr_ops;
	unsigned int nr_pages;
	bool writeable;
};

struct ioctl_gntdev_get_offset_for_vaddr {
	__u64 vaddr;
	__u64 offset;
	__u32 count;
	__u32 pad;
};

struct ioctl_gntdev_unmap_grant_ref {
	__u64 index;
	__u32 count;
	__u32 pad;
};

struct xmaddr {
	phys_addr_t maddr;
};

typedef struct xmaddr xmaddr_t;

struct mt6397_regulator_info {
	struct regulator_desc desc;
	u32 qi;
	u32 vselon_reg;
	u32 vselctrl_reg;
	u32 vselctrl_mask;
	u32 modeset_reg;
	u32 modeset_mask;
};

enum {
	MT6397_ID_VPCA15 = 0,
	MT6397_ID_VPCA7 = 1,
	MT6397_ID_VSRAMCA15 = 2,
	MT6397_ID_VSRAMCA7 = 3,
	MT6397_ID_VCORE = 4,
	MT6397_ID_VGPU = 5,
	MT6397_ID_VDRM = 6,
	MT6397_ID_VIO18 = 7,
	MT6397_ID_VTCXO = 8,
	MT6397_ID_VA28 = 9,
	MT6397_ID_VCAMA = 10,
	MT6397_ID_VIO28 = 11,
	MT6397_ID_VUSB = 12,
	MT6397_ID_VMC = 13,
	MT6397_ID_VMCH = 14,
	MT6397_ID_VEMC3V3 = 15,
	MT6397_ID_VGP1 = 16,
	MT6397_ID_VGP2 = 17,
	MT6397_ID_VGP3 = 18,
	MT6397_ID_VGP4 = 19,
	MT6397_ID_VGP5 = 20,
	MT6397_ID_VGP6 = 21,
	MT6397_ID_VIBR = 22,
	MT6397_ID_RG_MAX = 23,
};

struct qcom_geni_private_data {
	struct uart_driver *drv;
	u32 poll_cached_bytes;
	unsigned int poll_cached_bytes_cnt;
	u32 write_cached_bytes;
	unsigned int write_cached_bytes_cnt;
};

struct qcom_geni_device_data;

struct qcom_geni_serial_port {
	struct uart_port uport;
	struct geni_se se;
	const char *name;
	u32 tx_fifo_depth;
	u32 tx_fifo_width;
	u32 rx_fifo_depth;
	dma_addr_t tx_dma_addr;
	dma_addr_t rx_dma_addr;
	bool setup;
	unsigned int baud;
	unsigned long clk_rate;
	void *rx_buf;
	u32 loopback;
	bool brk;
	unsigned int tx_remaining;
	int wakeup_irq;
	bool rx_tx_swap;
	bool cts_rts_swap;
	struct qcom_geni_private_data private_data;
	const struct qcom_geni_device_data *dev_data;
};

struct qcom_geni_device_data {
	bool console;
	enum geni_se_xfer_mode mode;
};

enum geni_icc_path_index {
	GENI_TO_CORE = 0,
	CPU_TO_GENI = 1,
	GENI_TO_DDR = 2,
};

struct xgene_rng_dev {
	u32 irq;
	void *csr_base;
	u32 revision;
	u32 datum_size;
	u32 failure_cnt;
	unsigned long failure_ts;
	struct timer_list failure_timer;
	struct device *dev;
};

struct file_priv {
	struct tpm_chip *chip;
	struct tpm_space *space;
	struct mutex buffer_mutex;
	struct timer_list user_read_timer;
	struct work_struct timeout_work;
	struct work_struct async_work;
	wait_queue_head_t async_wait;
	ssize_t response_length;
	bool response_read;
	bool command_enqueued;
	u8 data_buffer[4096];
};

struct devres_node {
	struct list_head entry;
	dr_release_t release;
	const char *name;
	size_t size;
};

struct devres {
	struct devres_node node;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct pages_devres {
	unsigned long addr;
	unsigned int order;
};

enum blkif_state {
	BLKIF_STATE_DISCONNECTED = 0,
	BLKIF_STATE_CONNECTED = 1,
	BLKIF_STATE_SUSPENDED = 2,
	BLKIF_STATE_ERROR = 3,
};

enum blk_req_status {
	REQ_PROCESSING = 0,
	REQ_WAITING = 1,
	REQ_DONE = 2,
	REQ_ERROR = 3,
	REQ_EOPNOTSUPP = 4,
};

typedef uint16_t blkif_vdev_t;

struct blkfront_ring_info;

struct blkfront_info {
	struct mutex mutex;
	struct xenbus_device *xbdev;
	struct gendisk *gd;
	u16 sector_size;
	unsigned int physical_sector_size;
	unsigned long vdisk_info;
	int vdevice;
	blkif_vdev_t handle;
	enum blkif_state connected;
	unsigned int nr_ring_pages;
	struct request_queue *rq;
	unsigned int feature_flush: 1;
	unsigned int feature_fua: 1;
	unsigned int feature_discard: 1;
	unsigned int feature_secdiscard: 1;
	unsigned int feature_persistent_parm: 1;
	unsigned int feature_persistent: 1;
	unsigned int bounce: 1;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int max_indirect_segments;
	int is_ready;
	struct blk_mq_tag_set tag_set;
	struct blkfront_ring_info *rinfo;
	unsigned int nr_rings;
	unsigned int rinfo_size;
	struct list_head requests;
	struct bio_list bio_list;
	struct list_head info_list;
};

struct blkif_sring;

struct blkif_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct blkif_sring *sring;
};

typedef uint64_t blkif_sector_t;

struct blkif_request_segment {
	grant_ref_t gref;
	uint8_t first_sect;
	uint8_t last_sect;
};

struct blkif_request_rw {
	uint8_t nr_segments;
	blkif_vdev_t handle;
	uint32_t _pad1;
	uint64_t id;
	blkif_sector_t sector_number;
	struct blkif_request_segment seg[11];
} __attribute__((packed));

struct blkif_request_discard {
	uint8_t flag;
	blkif_vdev_t _pad1;
	uint32_t _pad2;
	uint64_t id;
	blkif_sector_t sector_number;
	uint64_t nr_sectors;
	uint8_t _pad3;
} __attribute__((packed));

struct blkif_request_other {
	uint8_t _pad1;
	blkif_vdev_t _pad2;
	uint32_t _pad3;
	uint64_t id;
} __attribute__((packed));

struct blkif_request_indirect {
	uint8_t indirect_op;
	uint16_t nr_segments;
	uint32_t _pad1;
	uint64_t id;
	blkif_sector_t sector_number;
	blkif_vdev_t handle;
	uint16_t _pad2;
	grant_ref_t indirect_grefs[8];
	uint32_t _pad3;
} __attribute__((packed));

struct blkif_request {
	uint8_t operation;
	union {
		struct blkif_request_rw rw;
		struct blkif_request_discard discard;
		struct blkif_request_other other;
		struct blkif_request_indirect indirect;
	} u;
};

struct grant;

struct blk_shadow {
	struct blkif_request req;
	struct request *request;
	struct grant **grants_used;
	struct grant **indirect_grants;
	struct scatterlist *sg;
	unsigned int num_sg;
	enum blk_req_status status;
	unsigned long associated_id;
};

struct blkfront_ring_info {
	spinlock_t ring_lock;
	struct blkif_front_ring ring;
	unsigned int ring_ref[16];
	unsigned int evtchn;
	unsigned int irq;
	struct work_struct work;
	struct gnttab_free_callback callback;
	struct list_head indirect_pages;
	struct list_head grants;
	unsigned int persistent_gnts_c;
	unsigned long shadow_free;
	struct blkfront_info *dev_info;
	struct blk_shadow shadow[0];
};

struct blkif_response {
	uint64_t id;
	uint8_t operation;
	int16_t status;
};

union blkif_sring_entry {
	struct blkif_request req;
	struct blkif_response rsp;
};

struct blkif_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union blkif_sring_entry ring[1];
};

struct grant {
	grant_ref_t gref;
	struct page *page;
	struct list_head node;
};

struct copy_from_grant {
	const struct blk_shadow *s;
	unsigned int grant_idx;
	unsigned int bvec_offset;
	char *bvec_data;
};

struct setup_rw_req {
	unsigned int grant_idx;
	struct blkif_request_segment *segments;
	struct blkfront_ring_info *rinfo;
	struct blkif_request *ring_req;
	grant_ref_t gref_head;
	unsigned int id;
	bool need_copy;
	unsigned int bvec_off;
	char *bvec_data;
	bool require_extra_req;
	struct blkif_request *extra_ring_req;
};

enum {
	HISI_SAS_PHY_BCAST_ACK = 0,
	HISI_SAS_PHY_SL_PHY_ENABLED = 1,
	HISI_SAS_PHY_INT_ABNORMAL = 2,
	HISI_SAS_PHY_INT_NR___2 = 3,
};

enum {
	DMA_TX_ERR_BASE___2 = 0,
	DMA_RX_ERR_BASE___2 = 256,
	TRANS_TX_FAIL_BASE___2 = 512,
	TRANS_RX_FAIL_BASE___2 = 768,
	DMA_TX_DIF_CRC_ERR___2 = 0,
	DMA_TX_DIF_APP_ERR___2 = 1,
	DMA_TX_DIF_RPP_ERR___2 = 2,
	DMA_TX_AXI_BUS_ERR = 3,
	DMA_TX_DATA_SGL_OVERFLOW_ERR = 4,
	DMA_TX_DIF_SGL_OVERFLOW_ERR = 5,
	DMA_TX_UNEXP_XFER_RDY_ERR = 6,
	DMA_TX_XFER_RDY_OFFSET_ERR = 7,
	DMA_TX_DATA_UNDERFLOW_ERR = 8,
	DMA_TX_XFER_RDY_LENGTH_OVERFLOW_ERR = 9,
	DMA_RX_BUFFER_ECC_ERR = 256,
	DMA_RX_DIF_CRC_ERR___2 = 257,
	DMA_RX_DIF_APP_ERR___2 = 258,
	DMA_RX_DIF_RPP_ERR___2 = 259,
	DMA_RX_RESP_BUFFER_OVERFLOW_ERR = 260,
	DMA_RX_AXI_BUS_ERR = 261,
	DMA_RX_DATA_SGL_OVERFLOW_ERR = 262,
	DMA_RX_DIF_SGL_OVERFLOW_ERR = 263,
	DMA_RX_DATA_OFFSET_ERR___2 = 264,
	DMA_RX_UNEXP_RX_DATA_ERR = 265,
	DMA_RX_DATA_OVERFLOW_ERR = 266,
	DMA_RX_DATA_UNDERFLOW_ERR = 267,
	DMA_RX_UNEXP_RETRANS_RESP_ERR___2 = 268,
	TRANS_TX_RSVD0_ERR = 512,
	TRANS_TX_PHY_NOT_ENABLE_ERR = 513,
	TRANS_TX_OPEN_REJCT_WRONG_DEST_ERR = 514,
	TRANS_TX_OPEN_REJCT_ZONE_VIOLATION_ERR = 515,
	TRANS_TX_OPEN_REJCT_BY_OTHER_ERR = 516,
	TRANS_TX_RSVD1_ERR = 517,
	TRANS_TX_OPEN_REJCT_AIP_TIMEOUT_ERR = 518,
	TRANS_TX_OPEN_REJCT_STP_BUSY_ERR = 519,
	TRANS_TX_OPEN_REJCT_PROTOCOL_NOT_SUPPORT_ERR = 520,
	TRANS_TX_OPEN_REJCT_RATE_NOT_SUPPORT_ERR = 521,
	TRANS_TX_OPEN_REJCT_BAD_DEST_ERR = 522,
	TRANS_TX_OPEN_BREAK_RECEIVE_ERR = 523,
	TRANS_TX_LOW_PHY_POWER_ERR = 524,
	TRANS_TX_OPEN_REJCT_PATHWAY_BLOCKED_ERR = 525,
	TRANS_TX_OPEN_TIMEOUT_ERR = 526,
	TRANS_TX_OPEN_REJCT_NO_DEST_ERR = 527,
	TRANS_TX_OPEN_RETRY_ERR = 528,
	TRANS_TX_RSVD2_ERR = 529,
	TRANS_TX_BREAK_TIMEOUT_ERR = 530,
	TRANS_TX_BREAK_REQUEST_ERR = 531,
	TRANS_TX_BREAK_RECEIVE_ERR = 532,
	TRANS_TX_CLOSE_TIMEOUT_ERR = 533,
	TRANS_TX_CLOSE_NORMAL_ERR = 534,
	TRANS_TX_CLOSE_PHYRESET_ERR = 535,
	TRANS_TX_WITH_CLOSE_DWS_TIMEOUT_ERR = 536,
	TRANS_TX_WITH_CLOSE_COMINIT_ERR = 537,
	TRANS_TX_NAK_RECEIVE_ERR = 538,
	TRANS_TX_ACK_NAK_TIMEOUT_ERR = 539,
	TRANS_TX_CREDIT_TIMEOUT_ERR = 540,
	TRANS_TX_IPTT_CONFLICT_ERR = 541,
	TRANS_TX_TXFRM_TYPE_ERR = 542,
	TRANS_TX_TXSMP_LENGTH_ERR = 543,
	TRANS_RX_FRAME_CRC_ERR = 768,
	TRANS_RX_FRAME_DONE_ERR = 769,
	TRANS_RX_FRAME_ERRPRM_ERR = 770,
	TRANS_RX_FRAME_NO_CREDIT_ERR = 771,
	TRANS_RX_RSVD0_ERR = 772,
	TRANS_RX_FRAME_OVERRUN_ERR = 773,
	TRANS_RX_FRAME_NO_EOF_ERR = 774,
	TRANS_RX_LINK_BUF_OVERRUN_ERR = 775,
	TRANS_RX_BREAK_TIMEOUT_ERR = 776,
	TRANS_RX_BREAK_REQUEST_ERR = 777,
	TRANS_RX_BREAK_RECEIVE_ERR = 778,
	TRANS_RX_CLOSE_TIMEOUT_ERR = 779,
	TRANS_RX_CLOSE_NORMAL_ERR = 780,
	TRANS_RX_CLOSE_PHYRESET_ERR = 781,
	TRANS_RX_WITH_CLOSE_DWS_TIMEOUT_ERR = 782,
	TRANS_RX_WITH_CLOSE_COMINIT_ERR = 783,
	TRANS_RX_DATA_LENGTH0_ERR = 784,
	TRANS_RX_BAD_HASH_ERR = 785,
	TRANS_RX_XRDY_ZERO_ERR = 786,
	TRANS_RX_SSP_FRAME_LEN_ERR = 787,
	TRANS_RX_TRANS_RX_RSVD1_ERR = 788,
	TRANS_RX_NO_BALANCE_ERR = 789,
	TRANS_RX_TRANS_RX_RSVD2_ERR = 790,
	TRANS_RX_TRANS_RX_RSVD3_ERR = 791,
	TRANS_RX_BAD_FRAME_TYPE_ERR = 792,
	TRANS_RX_SMP_FRAME_LEN_ERR = 793,
	TRANS_RX_SMP_RESP_TIMEOUT_ERR___2 = 794,
};

struct hisi_sas_complete_v1_hdr {
	__le32 data;
};

struct hisi_sas_err_record_v1 {
	__le32 dma_err_type;
	__le32 trans_tx_fail_type;
	__le32 trans_rx_fail_type;
	u32 rsvd;
};

struct mtd_part_parser {
	struct list_head list;
	struct module *owner;
	const char *name;
	const struct of_device_id *of_match_table;
	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **, struct mtd_part_parser_data *);
	void (*cleanup)(const struct mtd_partition *, int);
};

struct fixed_partitions_quirks {
	int (*post_parse)(struct mtd_info *, struct mtd_partition *, int);
};

struct sfdp_bfpt_read {
	u32 hwcaps;
	u32 supported_dword;
	u32 supported_bit;
	u32 settings_dword;
	u32 settings_shift;
	enum spi_nor_protocol proto;
};

struct sfdp_bfpt_erase {
	u32 dword;
	u32 shift;
};

struct sfdp_4bait {
	u32 hwcaps;
	u32 supported_bit;
};

struct sfdp_header {
	u32 signature;
	u8 minor;
	u8 major;
	u8 nph;
	u8 unused;
	struct sfdp_parameter_header bfpt_header;
};

struct rockchip_spi {
	struct device *dev;
	struct clk *spiclk;
	struct clk *apb_pclk;
	void *regs;
	dma_addr_t dma_addr_rx;
	dma_addr_t dma_addr_tx;
	const void *tx;
	void *rx;
	unsigned int tx_left;
	unsigned int rx_left;
	atomic_t state;
	u32 fifo_len;
	u32 freq;
	u8 n_bytes;
	u8 rsd;
	bool cs_asserted[4];
	bool target_abort;
	bool cs_inactive;
	bool cs_high_supported;
	struct spi_transfer *xfer;
};

struct kszphy_type {
	u32 led_mode_reg;
	u16 interrupt_level_mask;
	u16 cable_diag_reg;
	unsigned long pair_mask;
	u16 disable_dll_tx_bit;
	u16 disable_dll_rx_bit;
	u16 disable_dll_mask;
	bool has_broadcast_disable;
	bool has_nand_tree_disable;
	bool has_rmii_ref_clk_sel;
};

struct kszphy_hw_stat {
	const char *string;
	u8 reg;
	u8 bits;
};

struct ksz9477_errata_write {
	u8 dev_addr;
	u8 reg_addr;
	u16 val;
};

struct lan8814_shared_priv {
	struct phy_device *phydev;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	u8 ref;
	struct mutex shared_lock;
};

struct kszphy_ptp_priv {
	struct mii_timestamper mii_ts;
	struct phy_device *phydev;
	struct sk_buff_head tx_queue;
	struct sk_buff_head rx_queue;
	struct list_head rx_ts_list;
	spinlock_t rx_ts_lock;
	int hwts_tx_type;
	enum hwtstamp_rx_filters rx_filter;
	int layer;
	int version;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct mutex ptp_lock;
	struct ptp_pin_desc *pin_config;
	s64 seconds;
	spinlock_t seconds_lock;
};

struct kszphy_priv {
	struct kszphy_ptp_priv ptp_priv;
	const struct kszphy_type *type;
	int led_mode;
	u16 vct_ctrl1000;
	bool rmii_ref_clk_sel;
	bool rmii_ref_clk_sel_val;
	u64 stats[2];
};

struct lan8814_ptp_rx_ts {
	struct list_head list;
	u32 seconds;
	u32 nsec;
	u16 seq_id;
};

struct xgene_gstrings_stats {
	char name[32];
	int offset;
	u32 addr;
	u32 mask;
};

typedef void (*btf_trace_hns3_over_max_bd)(void *, struct sk_buff *);

typedef void (*btf_trace_hns3_gro)(void *, struct sk_buff *);

typedef void (*btf_trace_hns3_tso)(void *, struct sk_buff *);

typedef void (*btf_trace_hns3_tx_desc)(void *, struct hns3_enet_ring *, int);

typedef void (*btf_trace_hns3_rx_desc)(void *, struct hns3_enet_ring *);

struct hns3_rx_ptype {
	u32 ptype: 8;
	u32 csum_level: 2;
	u32 ip_summed: 2;
	u32 l3_type: 4;
	u32 valid: 1;
	u32 hash_type: 3;
};

struct hns3_hw_error_info {
	enum hnae3_hw_error_type type;
	const char *msg;
};

enum hns3_pkt_ol3t_type {
	HNS3_OL3T_NONE = 0,
	HNS3_OL3T_IPV6 = 1,
	HNS3_OL3T_IPV4_NO_CSUM = 2,
	HNS3_OL3T_IPV4_CSUM = 3,
};

enum hns3_pkt_tun_type {
	HNS3_TUN_NONE = 0,
	HNS3_TUN_MAC_IN_UDP = 1,
	HNS3_TUN_NVGRE = 2,
	HNS3_TUN_OTHER = 3,
};

enum hns3_pkt_l3t_type {
	HNS3_L3T_NONE = 0,
	HNS3_L3T_IPV6 = 1,
	HNS3_L3T_IPV4 = 2,
	HNS3_L3T_RESERVED = 3,
};

enum hns3_pkt_l4t_type {
	HNS3_L4T_UNKNOWN = 0,
	HNS3_L4T_TCP = 1,
	HNS3_L4T_UDP = 2,
	HNS3_L4T_SCTP = 3,
};

enum hns3_desc_type {
	DESC_TYPE_UNKNOWN = 0,
	DESC_TYPE_SKB = 1,
	DESC_TYPE_FRAGLIST_SKB = 2,
	DESC_TYPE_PAGE = 4,
	DESC_TYPE_BOUNCE_ALL = 8,
	DESC_TYPE_BOUNCE_HEAD = 16,
	DESC_TYPE_SGL_SKB = 32,
	DESC_TYPE_PP_FRAG = 64,
};

enum hns3_pkt_l2t_type {
	HNS3_L2_TYPE_UNICAST = 0,
	HNS3_L2_TYPE_MULTICAST = 1,
	HNS3_L2_TYPE_BROADCAST = 2,
	HNS3_L2_TYPE_INVALID = 3,
};

enum hns3_pkt_l3type {
	HNS3_L3_TYPE_IPV4 = 0,
	HNS3_L3_TYPE_IPV6 = 1,
	HNS3_L3_TYPE_ARP = 2,
	HNS3_L3_TYPE_RARP = 3,
	HNS3_L3_TYPE_IPV4_OPT = 4,
	HNS3_L3_TYPE_IPV6_EXT = 5,
	HNS3_L3_TYPE_LLDP = 6,
	HNS3_L3_TYPE_BPDU = 7,
	HNS3_L3_TYPE_MAC_PAUSE = 8,
	HNS3_L3_TYPE_PFC_PAUSE = 9,
	HNS3_L3_TYPE_CNM = 12,
	HNS3_L3_TYPE_PARSE_FAIL = 15,
};

enum hns3_pkt_ol4type {
	HNS3_OL4_TYPE_NO_TUN = 0,
	HNS3_OL4_TYPE_MAC_IN_UDP = 1,
	HNS3_OL4_TYPE_NVGRE = 2,
	HNS3_OL4_TYPE_UNKNOWN = 3,
};

enum hns3_pkt_l4type {
	HNS3_L4_TYPE_UDP = 0,
	HNS3_L4_TYPE_TCP = 1,
	HNS3_L4_TYPE_GRE = 2,
	HNS3_L4_TYPE_SCTP = 3,
	HNS3_L4_TYPE_IGMP = 4,
	HNS3_L4_TYPE_ICMP = 5,
	HNS3_L4_TYPE_PARSE_FAIL = 15,
};

enum {
	TC_MQPRIO_MODE_DCB = 0,
	TC_MQPRIO_MODE_CHANNEL = 1,
	__TC_MQPRIO_MODE_MAX = 2,
};

struct trace_event_raw_hns3_skb_template {
	struct trace_entry ent;
	unsigned int headlen;
	unsigned int len;
	__u8 nr_frags;
	__u8 ip_summed;
	unsigned int hdr_len;
	unsigned short gso_size;
	unsigned short gso_segs;
	unsigned int gso_type;
	bool fraglist;
	__u32 size[17];
	char __data[0];
};

struct trace_event_raw_hns3_tx_desc {
	struct trace_entry ent;
	int index;
	int ntu;
	int ntc;
	dma_addr_t desc_dma;
	u32 desc[8];
	u32 __data_loc_devname;
	char __data[0];
};

struct trace_event_raw_hns3_rx_desc {
	struct trace_entry ent;
	int index;
	int ntu;
	int ntc;
	dma_addr_t desc_dma;
	dma_addr_t buf_dma;
	u32 desc[8];
	u32 __data_loc_devname;
	char __data[0];
};

struct trace_event_data_offsets_hns3_tx_desc {
	u32 devname;
};

struct trace_event_data_offsets_hns3_rx_desc {
	u32 devname;
};

struct hns3_desc_param {
	u32 paylen_ol4cs;
	u32 ol_type_vlan_len_msec;
	u32 type_cs_vlan_tso;
	u16 mss_hw_csum;
	u16 inner_vtag;
	u16 out_vtag;
};

union l3_hdr_info {
	struct iphdr *v4;
	struct ipv6hdr *v6;
	unsigned char *hdr;
};

union l4_hdr_info {
	struct tcphdr *tcp;
	struct udphdr *udp;
	struct gre_base_hdr *gre;
	unsigned char *hdr;
};

struct trace_event_data_offsets_hns3_skb_template {};

struct rcar_gen4_ptp_reg_offset {
	u16 enable;
	u16 disable;
	u16 increment;
	u16 config_t0;
	u16 config_t1;
	u16 config_t2;
	u16 monitor_t0;
	u16 monitor_t1;
	u16 monitor_t2;
};

enum rcar_gen4_ptp_reg_layout {
	RCAR_GEN4_PTP_REG_LAYOUT_S4 = 0,
};

struct rcar_gen4_ptp_private {
	void *addr;
	struct ptp_clock *clock;
	struct ptp_clock_info info;
	const struct rcar_gen4_ptp_reg_offset *offs;
	spinlock_t lock;
	u32 tstamp_tx_ctrl;
	u32 tstamp_rx_ctrl;
	s64 default_addend;
	bool initialized;
};

struct vfio_pci_irq_ctx {
	struct eventfd_ctx *trigger;
	struct virqfd *unmask;
	struct virqfd *mask;
	char *name;
	bool masked;
	struct irq_bypass_producer producer;
};

typedef void (*companion_fn)(struct pci_dev *, struct usb_hcd *, struct pci_dev *, struct usb_hcd *);

struct dwc3_acpi_pdata {
	u32 qscratch_base_offset;
	u32 qscratch_base_size;
	u32 dwc3_core_base_size;
	int hs_phy_irq_index;
	int dp_hs_phy_irq_index;
	int dm_hs_phy_irq_index;
	int ss_phy_irq_index;
	bool is_urs;
};

struct dwc3_qcom {
	struct device *dev;
	void *qscratch_base;
	struct platform_device *dwc3;
	struct platform_device *urs_usb;
	struct clk **clks;
	int num_clocks;
	struct reset_control *resets;
	int hs_phy_irq;
	int dp_hs_phy_irq;
	int dm_hs_phy_irq;
	int ss_phy_irq;
	enum usb_device_speed usb2_speed;
	struct extcon_dev *edev;
	struct extcon_dev *host_edev;
	struct notifier_block vbus_nb;
	struct notifier_block host_nb;
	const struct dwc3_acpi_pdata *acpi_pdata;
	enum usb_dr_mode mode;
	bool is_suspended;
	bool pm_suspended;
	struct icc_path *icc_path_ddr;
	struct icc_path *icc_path_apps;
};

struct isp1760_request {
	struct usb_request req;
	struct list_head queue;
	struct isp1760_ep *ep;
	unsigned int packet_size;
};

struct xhci_file_map {
	const char *name;
	int (*show)(struct seq_file *, void *);
};

struct xhci_regset {
	char name[32];
	struct debugfs_regset32 regset;
	size_t nregs;
	struct list_head list;
};

struct xhci_ep_priv;

struct xhci_slot_priv {
	char name[32];
	struct dentry *root;
	struct xhci_ep_priv *eps[31];
	struct xhci_virt_device *dev;
};

struct xhci_ep_priv {
	char name[32];
	struct dentry *root;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *show_ring;
	unsigned int stream_id;
};

struct input_led {
	struct led_classdev cdev;
	struct input_handle *handle;
	unsigned int code;
};

struct input_leds {
	struct input_handle handle;
	unsigned int num_leds;
	struct input_led leds[0];
};

struct armada38x_rtc;

struct armada38x_rtc_data {
	void (*update_mbus_timing)(struct armada38x_rtc *);
	u32 (*read_rtc_reg)(struct armada38x_rtc *, u8);
	void (*clear_isr)(struct armada38x_rtc *);
	void (*unmask_interrupt)(struct armada38x_rtc *);
	u32 alarm;
};

struct value_to_freq;

struct armada38x_rtc {
	struct rtc_device *rtc_dev;
	void *regs;
	void *regs_soc;
	spinlock_t lock;
	int irq;
	bool initialized;
	struct value_to_freq *val_to_freq;
	const struct armada38x_rtc_data *data;
};

struct value_to_freq {
	u32 value;
	u8 freq;
};

struct i2c_mux_priv {
	struct i2c_adapter adap;
	struct i2c_algorithm algo;
	struct i2c_mux_core *muxc;
	u32 chan_id;
};

struct xgene_reboot_context {
	struct device *dev;
	void *csr;
	u32 mask;
	struct notifier_block restart_handler;
};

typedef void (*btf_trace_thermal_power_allocator)(void *, struct thermal_zone_device *, u32 *, u32, u32 *, u32, size_t, u32, u32, int, s32);

typedef void (*btf_trace_thermal_power_allocator_pid)(void *, struct thermal_zone_device *, s32, s32, s64, s64, s64, s32);

struct trace_event_raw_thermal_power_allocator {
	struct trace_entry ent;
	int tz_id;
	u32 __data_loc_req_power;
	u32 total_req_power;
	u32 __data_loc_granted_power;
	u32 total_granted_power;
	size_t num_actors;
	u32 power_range;
	u32 max_allocatable_power;
	int current_temp;
	s32 delta_temp;
	char __data[0];
};

struct trace_event_raw_thermal_power_allocator_pid {
	struct trace_entry ent;
	int tz_id;
	s32 err;
	s32 err_integral;
	s64 p;
	s64 i;
	s64 d;
	s32 output;
	char __data[0];
};

struct trace_event_data_offsets_thermal_power_allocator {
	u32 req_power;
	u32 granted_power;
};

struct power_allocator_params {
	bool allocated_tzp;
	s64 err_integral;
	s32 prev_err;
	u32 sustainable_power;
	const struct thermal_trip *trip_switch_on;
	const struct thermal_trip *trip_max_desired_temperature;
};

struct trace_event_data_offsets_thermal_power_allocator_pid {};

struct cpu_data {
	struct clk **pclk;
	struct cpufreq_frequency_table *table;
};

struct sunxi_mmc_clk_delay;

struct sunxi_mmc_cfg {
	u32 idma_des_size_bits;
	u32 idma_des_shift;
	const struct sunxi_mmc_clk_delay *clk_delays;
	bool can_calibrate;
	bool mask_data0;
	bool needs_new_timings;
	bool ccu_has_timings_switch;
};

struct sunxi_mmc_clk_delay {
	u32 output;
	u32 sample;
};

struct sunxi_idma_des {
	__le32 config;
	__le32 buf_size;
	__le32 buf_addr_ptr1;
	__le32 buf_addr_ptr2;
};

struct sunxi_mmc_host {
	struct device *dev;
	struct mmc_host *mmc;
	struct reset_control *reset;
	const struct sunxi_mmc_cfg *cfg;
	void *reg_base;
	struct clk *clk_ahb;
	struct clk *clk_mmc;
	struct clk *clk_sample;
	struct clk *clk_output;
	spinlock_t lock;
	int irq;
	u32 int_sum;
	u32 sdio_imask;
	dma_addr_t sg_dma;
	void *sg_cpu;
	bool wait_dma;
	struct mmc_request *mrq;
	struct mmc_request *manual_stop_mrq;
	int ferror;
	bool vqmmc_enabled;
	bool use_new_timings;
};

enum zynqmp_pm_shutdown_subtype {
	ZYNQMP_PM_SHUTDOWN_SUBTYPE_SUBSYSTEM = 0,
	ZYNQMP_PM_SHUTDOWN_SUBTYPE_PS_ONLY = 1,
	ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM = 2,
};

struct zynqmp_pm_shutdown_scope {
	const enum zynqmp_pm_shutdown_subtype subtype;
	const char *name;
};

enum tap_delay_type {
	PM_TAPDELAY_INPUT = 0,
	PM_TAPDELAY_OUTPUT = 1,
};

enum pm_node_id {
	NODE_SD_0 = 39,
	NODE_SD_1 = 40,
};

enum zynqmp_pm_reset {
	ZYNQMP_PM_RESET_START = 1000,
	ZYNQMP_PM_RESET_PCIE_CFG = 1000,
	ZYNQMP_PM_RESET_PCIE_BRIDGE = 1001,
	ZYNQMP_PM_RESET_PCIE_CTRL = 1002,
	ZYNQMP_PM_RESET_DP = 1003,
	ZYNQMP_PM_RESET_SWDT_CRF = 1004,
	ZYNQMP_PM_RESET_AFI_FM5 = 1005,
	ZYNQMP_PM_RESET_AFI_FM4 = 1006,
	ZYNQMP_PM_RESET_AFI_FM3 = 1007,
	ZYNQMP_PM_RESET_AFI_FM2 = 1008,
	ZYNQMP_PM_RESET_AFI_FM1 = 1009,
	ZYNQMP_PM_RESET_AFI_FM0 = 1010,
	ZYNQMP_PM_RESET_GDMA = 1011,
	ZYNQMP_PM_RESET_GPU_PP1 = 1012,
	ZYNQMP_PM_RESET_GPU_PP0 = 1013,
	ZYNQMP_PM_RESET_GPU = 1014,
	ZYNQMP_PM_RESET_GT = 1015,
	ZYNQMP_PM_RESET_SATA = 1016,
	ZYNQMP_PM_RESET_ACPU3_PWRON = 1017,
	ZYNQMP_PM_RESET_ACPU2_PWRON = 1018,
	ZYNQMP_PM_RESET_ACPU1_PWRON = 1019,
	ZYNQMP_PM_RESET_ACPU0_PWRON = 1020,
	ZYNQMP_PM_RESET_APU_L2 = 1021,
	ZYNQMP_PM_RESET_ACPU3 = 1022,
	ZYNQMP_PM_RESET_ACPU2 = 1023,
	ZYNQMP_PM_RESET_ACPU1 = 1024,
	ZYNQMP_PM_RESET_ACPU0 = 1025,
	ZYNQMP_PM_RESET_DDR = 1026,
	ZYNQMP_PM_RESET_APM_FPD = 1027,
	ZYNQMP_PM_RESET_SOFT = 1028,
	ZYNQMP_PM_RESET_GEM0 = 1029,
	ZYNQMP_PM_RESET_GEM1 = 1030,
	ZYNQMP_PM_RESET_GEM2 = 1031,
	ZYNQMP_PM_RESET_GEM3 = 1032,
	ZYNQMP_PM_RESET_QSPI = 1033,
	ZYNQMP_PM_RESET_UART0 = 1034,
	ZYNQMP_PM_RESET_UART1 = 1035,
	ZYNQMP_PM_RESET_SPI0 = 1036,
	ZYNQMP_PM_RESET_SPI1 = 1037,
	ZYNQMP_PM_RESET_SDIO0 = 1038,
	ZYNQMP_PM_RESET_SDIO1 = 1039,
	ZYNQMP_PM_RESET_CAN0 = 1040,
	ZYNQMP_PM_RESET_CAN1 = 1041,
	ZYNQMP_PM_RESET_I2C0 = 1042,
	ZYNQMP_PM_RESET_I2C1 = 1043,
	ZYNQMP_PM_RESET_TTC0 = 1044,
	ZYNQMP_PM_RESET_TTC1 = 1045,
	ZYNQMP_PM_RESET_TTC2 = 1046,
	ZYNQMP_PM_RESET_TTC3 = 1047,
	ZYNQMP_PM_RESET_SWDT_CRL = 1048,
	ZYNQMP_PM_RESET_NAND = 1049,
	ZYNQMP_PM_RESET_ADMA = 1050,
	ZYNQMP_PM_RESET_GPIO = 1051,
	ZYNQMP_PM_RESET_IOU_CC = 1052,
	ZYNQMP_PM_RESET_TIMESTAMP = 1053,
	ZYNQMP_PM_RESET_RPU_R50 = 1054,
	ZYNQMP_PM_RESET_RPU_R51 = 1055,
	ZYNQMP_PM_RESET_RPU_AMBA = 1056,
	ZYNQMP_PM_RESET_OCM = 1057,
	ZYNQMP_PM_RESET_RPU_PGE = 1058,
	ZYNQMP_PM_RESET_USB0_CORERESET = 1059,
	ZYNQMP_PM_RESET_USB1_CORERESET = 1060,
	ZYNQMP_PM_RESET_USB0_HIBERRESET = 1061,
	ZYNQMP_PM_RESET_USB1_HIBERRESET = 1062,
	ZYNQMP_PM_RESET_USB0_APB = 1063,
	ZYNQMP_PM_RESET_USB1_APB = 1064,
	ZYNQMP_PM_RESET_IPI = 1065,
	ZYNQMP_PM_RESET_APM_LPD = 1066,
	ZYNQMP_PM_RESET_RTC = 1067,
	ZYNQMP_PM_RESET_SYSMON = 1068,
	ZYNQMP_PM_RESET_AFI_FM6 = 1069,
	ZYNQMP_PM_RESET_LPD_SWDT = 1070,
	ZYNQMP_PM_RESET_FPD = 1071,
	ZYNQMP_PM_RESET_RPU_DBG1 = 1072,
	ZYNQMP_PM_RESET_RPU_DBG0 = 1073,
	ZYNQMP_PM_RESET_DBG_LPD = 1074,
	ZYNQMP_PM_RESET_DBG_FPD = 1075,
	ZYNQMP_PM_RESET_APLL = 1076,
	ZYNQMP_PM_RESET_DPLL = 1077,
	ZYNQMP_PM_RESET_VPLL = 1078,
	ZYNQMP_PM_RESET_IOPLL = 1079,
	ZYNQMP_PM_RESET_RPLL = 1080,
	ZYNQMP_PM_RESET_GPO3_PL_0 = 1081,
	ZYNQMP_PM_RESET_GPO3_PL_1 = 1082,
	ZYNQMP_PM_RESET_GPO3_PL_2 = 1083,
	ZYNQMP_PM_RESET_GPO3_PL_3 = 1084,
	ZYNQMP_PM_RESET_GPO3_PL_4 = 1085,
	ZYNQMP_PM_RESET_GPO3_PL_5 = 1086,
	ZYNQMP_PM_RESET_GPO3_PL_6 = 1087,
	ZYNQMP_PM_RESET_GPO3_PL_7 = 1088,
	ZYNQMP_PM_RESET_GPO3_PL_8 = 1089,
	ZYNQMP_PM_RESET_GPO3_PL_9 = 1090,
	ZYNQMP_PM_RESET_GPO3_PL_10 = 1091,
	ZYNQMP_PM_RESET_GPO3_PL_11 = 1092,
	ZYNQMP_PM_RESET_GPO3_PL_12 = 1093,
	ZYNQMP_PM_RESET_GPO3_PL_13 = 1094,
	ZYNQMP_PM_RESET_GPO3_PL_14 = 1095,
	ZYNQMP_PM_RESET_GPO3_PL_15 = 1096,
	ZYNQMP_PM_RESET_GPO3_PL_16 = 1097,
	ZYNQMP_PM_RESET_GPO3_PL_17 = 1098,
	ZYNQMP_PM_RESET_GPO3_PL_18 = 1099,
	ZYNQMP_PM_RESET_GPO3_PL_19 = 1100,
	ZYNQMP_PM_RESET_GPO3_PL_20 = 1101,
	ZYNQMP_PM_RESET_GPO3_PL_21 = 1102,
	ZYNQMP_PM_RESET_GPO3_PL_22 = 1103,
	ZYNQMP_PM_RESET_GPO3_PL_23 = 1104,
	ZYNQMP_PM_RESET_GPO3_PL_24 = 1105,
	ZYNQMP_PM_RESET_GPO3_PL_25 = 1106,
	ZYNQMP_PM_RESET_GPO3_PL_26 = 1107,
	ZYNQMP_PM_RESET_GPO3_PL_27 = 1108,
	ZYNQMP_PM_RESET_GPO3_PL_28 = 1109,
	ZYNQMP_PM_RESET_GPO3_PL_29 = 1110,
	ZYNQMP_PM_RESET_GPO3_PL_30 = 1111,
	ZYNQMP_PM_RESET_GPO3_PL_31 = 1112,
	ZYNQMP_PM_RESET_RPU_LS = 1113,
	ZYNQMP_PM_RESET_PS_ONLY = 1114,
	ZYNQMP_PM_RESET_PL = 1115,
	ZYNQMP_PM_RESET_PS_PL0 = 1116,
	ZYNQMP_PM_RESET_PS_PL1 = 1117,
	ZYNQMP_PM_RESET_PS_PL2 = 1118,
	ZYNQMP_PM_RESET_PS_PL3 = 1119,
	ZYNQMP_PM_RESET_END = 1119,
};

enum zynqmp_pm_reset_action {
	PM_RESET_ACTION_RELEASE = 0,
	PM_RESET_ACTION_ASSERT = 1,
	PM_RESET_ACTION_PULSE = 2,
};

enum pm_pinctrl_config_param {
	PM_PINCTRL_CONFIG_SLEW_RATE = 0,
	PM_PINCTRL_CONFIG_BIAS_STATUS = 1,
	PM_PINCTRL_CONFIG_PULL_CTRL = 2,
	PM_PINCTRL_CONFIG_SCHMITT_CMOS = 3,
	PM_PINCTRL_CONFIG_DRIVE_STRENGTH = 4,
	PM_PINCTRL_CONFIG_VOLTAGE_STATUS = 5,
	PM_PINCTRL_CONFIG_TRI_STATE = 6,
	PM_PINCTRL_CONFIG_MAX = 7,
};

enum zynqmp_pm_request_ack {
	ZYNQMP_PM_REQUEST_ACK_NO = 1,
	ZYNQMP_PM_REQUEST_ACK_BLOCKING = 2,
	ZYNQMP_PM_REQUEST_ACK_NON_BLOCKING = 3,
};

enum rpu_oper_mode {
	PM_RPU_MODE_LOCKSTEP = 0,
	PM_RPU_MODE_SPLIT = 1,
};

enum pm_ret_status {
	XST_PM_SUCCESS = 0,
	XST_PM_NO_FEATURE = 19,
	XST_PM_INTERNAL = 2000,
	XST_PM_CONFLICT = 2001,
	XST_PM_NO_ACCESS = 2002,
	XST_PM_INVALID_NODE = 2003,
	XST_PM_DOUBLE_REQ = 2004,
	XST_PM_ABORT_SUSPEND = 2005,
	XST_PM_MULT_USER = 2008,
};

enum rpu_tcm_comb {
	PM_RPU_TCM_SPLIT = 0,
	PM_RPU_TCM_COMB = 1,
};

enum pm_feature_config_id {
	PM_FEATURE_INVALID = 0,
	PM_FEATURE_OVERTEMP_STATUS = 1,
	PM_FEATURE_OVERTEMP_VALUE = 2,
	PM_FEATURE_EXTWDT_STATUS = 3,
	PM_FEATURE_EXTWDT_VALUE = 4,
};

enum pm_sd_config_type {
	SD_CONFIG_EMMC_SEL = 1,
	SD_CONFIG_BASECLK = 2,
	SD_CONFIG_8BIT = 3,
	SD_CONFIG_FIXED = 4,
};

enum zynqmp_pm_shutdown_type {
	ZYNQMP_PM_SHUTDOWN_TYPE_SHUTDOWN = 0,
	ZYNQMP_PM_SHUTDOWN_TYPE_RESET = 1,
	ZYNQMP_PM_SHUTDOWN_TYPE_SETSCOPE_ONLY = 2,
};

struct pm_api_feature_data {
	u32 pm_api_id;
	int feature_status;
	struct hlist_node hentry;
};

struct zynqmp_devinfo {
	struct device *dev;
	u32 feature_conf_id;
};

enum ec_vbnvcontext_op {
	EC_VBNV_CONTEXT_OP_READ = 0,
	EC_VBNV_CONTEXT_OP_WRITE = 1,
};

struct ec_params_vbnvcontext {
	uint32_t op;
	uint8_t block[16];
};

struct ti_msgmgr_valid_queue_desc;

struct ti_msgmgr_desc {
	u8 queue_count;
	u8 max_message_size;
	u8 max_messages;
	u8 data_first_reg;
	u8 data_last_reg;
	u32 status_cnt_mask;
	u32 status_err_mask;
	bool tx_polled;
	int tx_poll_timeout_ms;
	const struct ti_msgmgr_valid_queue_desc *valid_queues;
	const char *data_region_name;
	const char *status_region_name;
	const char *ctrl_region_name;
	int num_valid_queues;
	bool is_sproxy;
};

struct ti_msgmgr_valid_queue_desc {
	u8 queue_id;
	u8 proxy_id;
	bool is_tx;
};

struct ti_queue_inst;

struct ti_msgmgr_inst {
	struct device *dev;
	const struct ti_msgmgr_desc *desc;
	void *queue_proxy_region;
	void *queue_state_debug_region;
	void *queue_ctrl_region;
	u8 num_valid_queues;
	struct ti_queue_inst *qinsts;
	struct mbox_controller mbox;
	struct mbox_chan *chans;
};

struct ti_queue_inst {
	char name[30];
	u8 queue_id;
	u8 proxy_id;
	int irq;
	bool is_tx;
	void *queue_buff_start;
	void *queue_buff_end;
	void *queue_state;
	void *queue_ctrl;
	struct mbox_chan *chan;
	u32 *rx_buff;
	bool polled_rx_mode;
};

enum iio_buffer_direction {
	IIO_BUFFER_DIRECTION_IN = 0,
	IIO_BUFFER_DIRECTION_OUT = 1,
};

struct iio_buffer_access_funcs;

struct iio_buffer {
	unsigned int length;
	unsigned long flags;
	size_t bytes_per_datum;
	enum iio_buffer_direction direction;
	const struct iio_buffer_access_funcs *access;
	long *scan_mask;
	struct list_head demux_list;
	wait_queue_head_t pollq;
	unsigned int watermark;
	bool scan_timestamp;
	struct list_head buffer_attr_list;
	struct attribute_group buffer_group;
	const struct iio_dev_attr **attrs;
	void *demux_bounce;
	struct list_head attached_entry;
	struct list_head buffer_list;
	struct kref ref;
};

struct iio_buffer_access_funcs {
	int (*store_to)(struct iio_buffer *, const void *);
	int (*read)(struct iio_buffer *, size_t, char __attribute__((btf_type_tag("user"))) *);
	size_t (*data_available)(struct iio_buffer *);
	int (*remove_from)(struct iio_buffer *, void *);
	int (*write)(struct iio_buffer *, size_t, const char __attribute__((btf_type_tag("user"))) *);
	size_t (*space_available)(struct iio_buffer *);
	int (*request_update)(struct iio_buffer *);
	int (*set_bytes_per_datum)(struct iio_buffer *, size_t);
	int (*set_length)(struct iio_buffer *, unsigned int);
	int (*enable)(struct iio_buffer *, struct iio_dev *);
	int (*disable)(struct iio_buffer *, struct iio_dev *);
	void (*release)(struct iio_buffer *);
	unsigned int modes;
	unsigned int flags;
};

struct iio_mount_matrix {
	const char *rotation[9];
};

enum iio_available_type {
	IIO_AVAIL_LIST = 0,
	IIO_AVAIL_RANGE = 1,
};

struct iio_const_attr {
	const char *string;
	struct device_attribute dev_attr;
};

struct iio_enum {
	const char * const *items;
	unsigned int num_items;
	int (*set)(struct iio_dev *, const struct iio_chan_spec *, unsigned int);
	int (*get)(struct iio_dev *, const struct iio_chan_spec *);
};

typedef const struct iio_mount_matrix *iio_get_mount_matrix_t(const struct iio_dev *, const struct iio_chan_spec *);

struct iio_dev_buffer_pair {
	struct iio_dev *indio_dev;
	struct iio_buffer *buffer;
};

struct apple_efuses_priv {
	void *fuses;
};

struct notif_entry {
	struct list_head link;
	struct completion c;
	u_int key;
};

struct snd_soc_tplg_kcontrol_ops {
	u32 id;
	int (*get)(struct snd_kcontrol *, struct snd_ctl_elem_value *);
	int (*put)(struct snd_kcontrol *, struct snd_ctl_elem_value *);
	int (*info)(struct snd_kcontrol *, struct snd_ctl_elem_info *);
};

struct soc_tplg_map {
	int uid;
	int kid;
};

enum {
	SNDRV_CHMAP_UNKNOWN = 0,
	SNDRV_CHMAP_NA = 1,
	SNDRV_CHMAP_MONO = 2,
	SNDRV_CHMAP_FL = 3,
	SNDRV_CHMAP_FR = 4,
	SNDRV_CHMAP_RL = 5,
	SNDRV_CHMAP_RR = 6,
	SNDRV_CHMAP_FC = 7,
	SNDRV_CHMAP_LFE = 8,
	SNDRV_CHMAP_SL = 9,
	SNDRV_CHMAP_SR = 10,
	SNDRV_CHMAP_RC = 11,
	SNDRV_CHMAP_FLC = 12,
	SNDRV_CHMAP_FRC = 13,
	SNDRV_CHMAP_RLC = 14,
	SNDRV_CHMAP_RRC = 15,
	SNDRV_CHMAP_FLW = 16,
	SNDRV_CHMAP_FRW = 17,
	SNDRV_CHMAP_FLH = 18,
	SNDRV_CHMAP_FCH = 19,
	SNDRV_CHMAP_FRH = 20,
	SNDRV_CHMAP_TC = 21,
	SNDRV_CHMAP_TFL = 22,
	SNDRV_CHMAP_TFR = 23,
	SNDRV_CHMAP_TFC = 24,
	SNDRV_CHMAP_TRL = 25,
	SNDRV_CHMAP_TRR = 26,
	SNDRV_CHMAP_TRC = 27,
	SNDRV_CHMAP_TFLC = 28,
	SNDRV_CHMAP_TFRC = 29,
	SNDRV_CHMAP_TSL = 30,
	SNDRV_CHMAP_TSR = 31,
	SNDRV_CHMAP_LLFE = 32,
	SNDRV_CHMAP_RLFE = 33,
	SNDRV_CHMAP_BC = 34,
	SNDRV_CHMAP_BLC = 35,
	SNDRV_CHMAP_BRC = 36,
	SNDRV_CHMAP_LAST = 36,
};

struct snd_soc_tplg_hdr {
	__le32 magic;
	__le32 abi;
	__le32 version;
	__le32 type;
	__le32 size;
	__le32 vendor_type;
	__le32 payload_size;
	__le32 index;
	__le32 count;
};

struct snd_soc_tplg_io_ops {
	__le32 get;
	__le32 put;
	__le32 info;
};

struct snd_soc_tplg_tlv_dbscale {
	__le32 min;
	__le32 step;
	__le32 mute;
};

struct snd_soc_tplg_ctl_tlv {
	__le32 size;
	__le32 type;
	union {
		__le32 data[32];
		struct snd_soc_tplg_tlv_dbscale scale;
	};
};

struct snd_soc_tplg_ctl_hdr {
	__le32 size;
	__le32 type;
	char name[44];
	__le32 access;
	struct snd_soc_tplg_io_ops ops;
	struct snd_soc_tplg_ctl_tlv tlv;
};

struct snd_soc_tplg_channel {
	__le32 size;
	__le32 reg;
	__le32 shift;
	__le32 id;
};

struct snd_soc_tplg_vendor_uuid_elem {
	__le32 token;
	char uuid[16];
};

struct snd_soc_tplg_vendor_value_elem {
	__le32 token;
	__le32 value;
};

struct snd_soc_tplg_vendor_string_elem {
	__le32 token;
	char string[44];
};

struct snd_soc_tplg_vendor_array {
	__le32 size;
	__le32 type;
	__le32 num_elems;
	union {
		struct {
			struct {} __empty_uuid;
			struct snd_soc_tplg_vendor_uuid_elem uuid[0];
		};
		struct {
			struct {} __empty_value;
			struct snd_soc_tplg_vendor_value_elem value[0];
		};
		struct {
			struct {} __empty_string;
			struct snd_soc_tplg_vendor_string_elem string[0];
		};
	};
};

struct snd_soc_tplg_private {
	__le32 size;
	union {
		struct {
			struct {} __empty_data;
			char data[0];
		};
		struct {
			struct {} __empty_array;
			struct snd_soc_tplg_vendor_array array[0];
		};
	};
};

struct snd_soc_tplg_mixer_control {
	struct snd_soc_tplg_ctl_hdr hdr;
	__le32 size;
	__le32 min;
	__le32 max;
	__le32 platform_max;
	__le32 invert;
	__le32 num_channels;
	struct snd_soc_tplg_channel channel[8];
	struct snd_soc_tplg_private priv;
};

struct soc_bytes_ext {
	int max;
	struct snd_soc_dobj dobj;
	int (*get)(struct snd_kcontrol *, unsigned int __attribute__((btf_type_tag("user"))) *, unsigned int);
	int (*put)(struct snd_kcontrol *, const unsigned int __attribute__((btf_type_tag("user"))) *, unsigned int);
};

struct snd_soc_tplg_bytes_control {
	struct snd_soc_tplg_ctl_hdr hdr;
	__le32 size;
	__le32 max;
	__le32 mask;
	__le32 base;
	__le32 num_regs;
	struct snd_soc_tplg_io_ops ext_ops;
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_enum_control {
	struct snd_soc_tplg_ctl_hdr hdr;
	__le32 size;
	__le32 num_channels;
	struct snd_soc_tplg_channel channel[8];
	__le32 items;
	__le32 mask;
	__le32 count;
	char texts[704];
	__le32 values[176];
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_dapm_graph_elem {
	char sink[44];
	char control[44];
	char source[44];
};

struct snd_soc_tplg_dapm_widget {
	__le32 size;
	__le32 id;
	char name[44];
	char sname[44];
	__le32 reg;
	__le32 shift;
	__le32 mask;
	__le32 subseq;
	__le32 invert;
	__le32 ignore_suspend;
	__le16 event_flags;
	__le16 event_type;
	__le32 num_kcontrols;
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_stream {
	__le32 size;
	char name[44];
	__le64 format;
	__le32 rate;
	__le32 period_bytes;
	__le32 buffer_bytes;
	__le32 channels;
};

struct snd_soc_tplg_stream_caps {
	__le32 size;
	char name[44];
	__le64 formats;
	__le32 rates;
	__le32 rate_min;
	__le32 rate_max;
	__le32 channels_min;
	__le32 channels_max;
	__le32 periods_min;
	__le32 periods_max;
	__le32 period_size_min;
	__le32 period_size_max;
	__le32 buffer_size_min;
	__le32 buffer_size_max;
	__le32 sig_bits;
};

struct snd_soc_tplg_pcm {
	__le32 size;
	char pcm_name[44];
	char dai_name[44];
	__le32 pcm_id;
	__le32 dai_id;
	__le32 playback;
	__le32 capture;
	__le32 compress;
	struct snd_soc_tplg_stream stream[8];
	__le32 num_streams;
	struct snd_soc_tplg_stream_caps caps[2];
	__le32 flag_mask;
	__le32 flags;
	struct snd_soc_tplg_private priv;
} __attribute__((packed));

struct snd_soc_tplg_stream_caps_v4 {
	__le32 size;
	char name[44];
	__le64 formats;
	__le32 rates;
	__le32 rate_min;
	__le32 rate_max;
	__le32 channels_min;
	__le32 channels_max;
	__le32 periods_min;
	__le32 periods_max;
	__le32 period_size_min;
	__le32 period_size_max;
	__le32 buffer_size_min;
	__le32 buffer_size_max;
} __attribute__((packed));

struct snd_soc_tplg_pcm_v4 {
	__le32 size;
	char pcm_name[44];
	char dai_name[44];
	__le32 pcm_id;
	__le32 dai_id;
	__le32 playback;
	__le32 capture;
	__le32 compress;
	struct snd_soc_tplg_stream stream[8];
	__le32 num_streams;
	struct snd_soc_tplg_stream_caps_v4 caps[2];
} __attribute__((packed));

struct snd_soc_tplg_dai {
	__le32 size;
	char dai_name[44];
	__le32 dai_id;
	__le32 playback;
	__le32 capture;
	struct snd_soc_tplg_stream_caps caps[2];
	__le32 flag_mask;
	__le32 flags;
	struct snd_soc_tplg_private priv;
} __attribute__((packed));

struct snd_soc_tplg_hw_config {
	__le32 size;
	__le32 id;
	__le32 fmt;
	__u8 clock_gated;
	__u8 invert_bclk;
	__u8 invert_fsync;
	__u8 bclk_provider;
	__u8 fsync_provider;
	__u8 mclk_direction;
	__le16 reserved;
	__le32 mclk_rate;
	__le32 bclk_rate;
	__le32 fsync_rate;
	__le32 tdm_slots;
	__le32 tdm_slot_width;
	__le32 tx_slots;
	__le32 rx_slots;
	__le32 tx_channels;
	__le32 tx_chanmap[8];
	__le32 rx_channels;
	__le32 rx_chanmap[8];
};

struct snd_soc_tplg_link_config {
	__le32 size;
	__le32 id;
	char name[44];
	char stream_name[44];
	struct snd_soc_tplg_stream stream[8];
	__le32 num_streams;
	struct snd_soc_tplg_hw_config hw_config[8];
	__le32 num_hw_configs;
	__le32 default_hw_config_id;
	__le32 flag_mask;
	__le32 flags;
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_link_config_v4 {
	__le32 size;
	__le32 id;
	struct snd_soc_tplg_stream stream[8];
	__le32 num_streams;
} __attribute__((packed));

struct snd_soc_tplg_manifest {
	__le32 size;
	__le32 control_elems;
	__le32 widget_elems;
	__le32 graph_elems;
	__le32 pcm_elems;
	__le32 dai_link_elems;
	__le32 dai_elems;
	__le32 reserved[20];
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_manifest_v4 {
	__le32 size;
	__le32 control_elems;
	__le32 widget_elems;
	__le32 graph_elems;
	__le32 pcm_elems;
	__le32 dai_link_elems;
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_bytes_ext_ops;

struct snd_soc_tplg_ops;

struct soc_tplg {
	const struct firmware *fw;
	const u8 *pos;
	const u8 *hdr_pos;
	unsigned int pass;
	struct device *dev;
	struct snd_soc_component *comp;
	u32 index;
	const struct snd_soc_tplg_kcontrol_ops *io_ops;
	int io_ops_count;
	const struct snd_soc_tplg_bytes_ext_ops *bytes_ext_ops;
	int bytes_ext_ops_count;
	struct snd_soc_tplg_ops *ops;
};

struct snd_soc_tplg_bytes_ext_ops {
	u32 id;
	int (*get)(struct snd_kcontrol *, unsigned int __attribute__((btf_type_tag("user"))) *, unsigned int);
	int (*put)(struct snd_kcontrol *, const unsigned int __attribute__((btf_type_tag("user"))) *, unsigned int);
};

struct snd_soc_tplg_ops {
	int (*control_load)(struct snd_soc_component *, int, struct snd_kcontrol_new *, struct snd_soc_tplg_ctl_hdr *);
	int (*control_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*dapm_route_load)(struct snd_soc_component *, int, struct snd_soc_dapm_route *);
	int (*dapm_route_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*widget_load)(struct snd_soc_component *, int, struct snd_soc_dapm_widget *, struct snd_soc_tplg_dapm_widget *);
	int (*widget_ready)(struct snd_soc_component *, int, struct snd_soc_dapm_widget *, struct snd_soc_tplg_dapm_widget *);
	int (*widget_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*dai_load)(struct snd_soc_component *, int, struct snd_soc_dai_driver *, struct snd_soc_tplg_pcm *, struct snd_soc_dai *);
	int (*dai_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*link_load)(struct snd_soc_component *, int, struct snd_soc_dai_link *, struct snd_soc_tplg_link_config *);
	int (*link_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*vendor_load)(struct snd_soc_component *, int, struct snd_soc_tplg_hdr *);
	int (*vendor_unload)(struct snd_soc_component *, struct snd_soc_tplg_hdr *);
	int (*complete)(struct snd_soc_component *);
	int (*manifest)(struct snd_soc_component *, int, struct snd_soc_tplg_manifest *);
	const struct snd_soc_tplg_kcontrol_ops *io_ops;
	int io_ops_count;
	const struct snd_soc_tplg_bytes_ext_ops *bytes_ext_ops;
	int bytes_ext_ops_count;
};

struct snd_soc_tplg_widget_events {
	u16 type;
	int (*event_handler)(struct snd_soc_dapm_widget *, struct snd_kcontrol *, int);
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum lw_bits {
	LW_URGENT = 0,
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

struct genl_op_iter {
	const struct genl_family *family;
	struct genl_split_ops doit;
	struct genl_split_ops dumpit;
	int cmd_idx;
	int entry_idx;
	u32 cmd;
	u8 flags;
};

struct netlink_policy_dump_state;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	struct genl_op_iter *op_iter;
	u32 op;
	u16 fam_id;
	u8 dump_map: 1;
	u8 single_op: 1;
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_split_ops *ops;
	int hdrlen;
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	__ETHTOOL_A_TSINFO_CNT = 6,
	ETHTOOL_A_TSINFO_MAX = 5,
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ts_info ts_info;
};

struct tcp_metrics_block;

struct tcpm_hash_bucket {
	struct tcp_metrics_block __attribute__((btf_type_tag("rcu"))) *chain;
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	unsigned long last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_metrics_block {
	struct tcp_metrics_block __attribute__((btf_type_tag("rcu"))) *tcpm_next;
	struct net *tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	unsigned long tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
};

enum {
	UDP_BPF_IPV4 = 0,
	UDP_BPF_IPV6 = 1,
	UDP_BPF_NUM_PROTS = 2,
};

struct rpcb_info {
	u32 rpc_vers;
	const struct rpc_procinfo *rpc_proc;
};

enum {
	RPCBPROC_NULL = 0,
	RPCBPROC_SET = 1,
	RPCBPROC_UNSET = 2,
	RPCBPROC_GETPORT = 3,
	RPCBPROC_GETADDR = 3,
	RPCBPROC_DUMP = 4,
	RPCBPROC_CALLIT = 5,
	RPCBPROC_BCAST = 5,
	RPCBPROC_GETTIME = 6,
	RPCBPROC_UADDR2TADDR = 7,
	RPCBPROC_TADDR2UADDR = 8,
	RPCBPROC_GETVERSADDR = 9,
	RPCBPROC_INDIRECT = 10,
	RPCBPROC_GETADDRLIST = 11,
	RPCBPROC_GETSTAT = 12,
};

struct rpcbind_args {
	struct rpc_xprt *r_xprt;
	u32 r_prog;
	u32 r_vers;
	u32 r_prot;
	unsigned short r_port;
	const char *r_netid;
	const char *r_addr;
	const char *r_owner;
	int r_status;
};

enum {
	XDP_DIAG_NONE = 0,
	XDP_DIAG_INFO = 1,
	XDP_DIAG_UID = 2,
	XDP_DIAG_RX_RING = 3,
	XDP_DIAG_TX_RING = 4,
	XDP_DIAG_UMEM = 5,
	XDP_DIAG_UMEM_FILL_RING = 6,
	XDP_DIAG_UMEM_COMPLETION_RING = 7,
	XDP_DIAG_MEMINFO = 8,
	XDP_DIAG_STATS = 9,
	__XDP_DIAG_MAX = 10,
};

struct xdp_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 xdiag_ino;
	__u32 xdiag_show;
	__u32 xdiag_cookie[2];
};

struct xdp_diag_msg {
	__u8 xdiag_family;
	__u8 xdiag_type;
	__u16 pad;
	__u32 xdiag_ino;
	__u32 xdiag_cookie[2];
};

struct xdp_diag_info {
	__u32 ifindex;
	__u32 queue_id;
};

struct xdp_diag_ring {
	__u32 entries;
};

struct xdp_diag_umem {
	__u64 size;
	__u32 id;
	__u32 num_pages;
	__u32 chunk_size;
	__u32 headroom;
	__u32 ifindex;
	__u32 queue_id;
	__u32 flags;
	__u32 refs;
};

struct xdp_diag_stats {
	__u64 n_rx_dropped;
	__u64 n_rx_invalid;
	__u64 n_rx_full;
	__u64 n_fill_ring_empty;
	__u64 n_tx_invalid;
	__u64 n_tx_ring_empty;
};

struct sigcontext {
	__u64 fault_address;
	__u64 regs[31];
	__u64 sp;
	__u64 pc;
	__u64 pstate;
	long: 64;
	__u8 __reserved[4096];
};

struct ucontext {
	unsigned long uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	sigset_t uc_sigmask;
	__u8 __unused[120];
	long: 64;
	struct sigcontext uc_mcontext;
};

struct rt_sigframe {
	struct siginfo info;
	struct ucontext uc;
};

struct _aarch64_ctx {
	__u32 magic;
	__u32 size;
};

struct fpsimd_context {
	struct _aarch64_ctx head;
	__u32 fpsr;
	__u32 fpcr;
	__uint128_t vregs[32];
};

struct sve_context {
	struct _aarch64_ctx head;
	__u16 vl;
	__u16 flags;
	__u16 __reserved[2];
};

struct tpidr2_context {
	struct _aarch64_ctx head;
	__u64 tpidr2;
};

struct za_context {
	struct _aarch64_ctx head;
	__u16 vl;
	__u16 __reserved[3];
};

struct zt_context {
	struct _aarch64_ctx head;
	__u16 nregs;
	__u16 __reserved[3];
};

struct extra_context {
	struct _aarch64_ctx head;
	__u64 datap;
	__u32 size;
	__u32 __reserved[3];
};

struct frame_record {
	u64 fp;
	u64 lr;
};

struct user_ctxs {
	struct fpsimd_context __attribute__((btf_type_tag("user"))) *fpsimd;
	u32 fpsimd_size;
	struct sve_context __attribute__((btf_type_tag("user"))) *sve;
	u32 sve_size;
	struct tpidr2_context __attribute__((btf_type_tag("user"))) *tpidr2;
	u32 tpidr2_size;
	struct za_context __attribute__((btf_type_tag("user"))) *za;
	u32 za_size;
	struct zt_context __attribute__((btf_type_tag("user"))) *zt;
	u32 zt_size;
};

struct rt_sigframe_user_layout {
	struct rt_sigframe __attribute__((btf_type_tag("user"))) *sigframe;
	struct frame_record __attribute__((btf_type_tag("user"))) *next_frame;
	unsigned long size;
	unsigned long limit;
	unsigned long fpsimd_offset;
	unsigned long esr_offset;
	unsigned long sve_offset;
	unsigned long tpidr2_offset;
	unsigned long za_offset;
	unsigned long zt_offset;
	unsigned long extra_offset;
	unsigned long end_offset;
};

struct esr_context {
	struct _aarch64_ctx head;
	__u64 esr;
};

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

struct smp_hotplug_thread {
	struct task_struct * __attribute__((btf_type_tag("percpu"))) *store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	atomic_t ap_sync_state;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

enum cpuhp_sync_state {
	SYNC_STATE_DEAD = 0,
	SYNC_STATE_KICKED = 1,
	SYNC_STATE_SHOULD_DIE = 2,
	SYNC_STATE_ALIVE = 3,
	SYNC_STATE_SHOULD_ONLINE = 4,
	SYNC_STATE_ONLINE = 5,
};

enum cc_attr {
	CC_ATTR_MEM_ENCRYPT = 0,
	CC_ATTR_HOST_MEM_ENCRYPT = 1,
	CC_ATTR_GUEST_MEM_ENCRYPT = 2,
	CC_ATTR_GUEST_STATE_ENCRYPT = 3,
	CC_ATTR_GUEST_UNROLL_STRING_IO = 4,
	CC_ATTR_GUEST_SEV_SNP = 5,
	CC_ATTR_HOTPLUG_DISABLED = 6,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct cpu_down_work {
	unsigned int cpu;
	enum cpuhp_state target;
};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	unsigned long attrs;
};

struct kexec_load_limit {
	struct mutex mutex;
	int limit;
};

struct listener_list {
	struct rw_semaphore sem;
	struct list_head list;
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum {
	TASKSTATS_TYPE_UNSPEC = 0,
	TASKSTATS_TYPE_PID = 1,
	TASKSTATS_TYPE_TGID = 2,
	TASKSTATS_TYPE_STATS = 3,
	TASKSTATS_TYPE_AGGR_PID = 4,
	TASKSTATS_TYPE_AGGR_TGID = 5,
	TASKSTATS_TYPE_NULL = 6,
	__TASKSTATS_TYPE_MAX = 7,
};

enum {
	TASKSTATS_CMD_ATTR_UNSPEC = 0,
	TASKSTATS_CMD_ATTR_PID = 1,
	TASKSTATS_CMD_ATTR_TGID = 2,
	TASKSTATS_CMD_ATTR_REGISTER_CPUMASK = 3,
	TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 4,
	__TASKSTATS_CMD_ATTR_MAX = 5,
};

enum actions {
	REGISTER = 0,
	DEREGISTER = 1,
	CPU_DONT_CARE = 2,
};

enum {
	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
	CGROUPSTATS_CMD_ATTR_FD = 1,
	__CGROUPSTATS_CMD_ATTR_MAX = 2,
};

enum {
	CGROUPSTATS_CMD_UNSPEC = 3,
	CGROUPSTATS_CMD_GET = 4,
	CGROUPSTATS_CMD_NEW = 5,
	__CGROUPSTATS_CMD_MAX = 6,
};

enum {
	CGROUPSTATS_TYPE_UNSPEC = 0,
	CGROUPSTATS_TYPE_CGROUP_STATS = 1,
	__CGROUPSTATS_TYPE_MAX = 2,
};

struct listener {
	struct list_head list;
	pid_t pid;
	char valid;
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

struct boot_triggers {
	const char *event;
	char *trigger;
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

struct module_string {
	struct list_head next;
	struct module *module;
	char *str;
};

struct event_probe_data {
	struct trace_event_file *file;
	unsigned long count;
	int ref;
	bool enable;
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_ringbuf_reserve_dynptr)(struct bpf_map *, u32, u64, struct bpf_dynptr_kern *);

typedef u64 (*btf_bpf_ringbuf_submit_dynptr)(struct bpf_dynptr_kern *, u64);

typedef u64 (*btf_bpf_ringbuf_discard_dynptr)(struct bpf_dynptr_kern *, u64);

typedef u64 (*btf_bpf_user_ringbuf_drain)(struct bpf_map *, void *, void *, u64);

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t spinlock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t busy;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned long consumer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned long producer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_ringbuf *rb;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

struct reuseport_array {
	struct bpf_map map;
	struct sock __attribute__((btf_type_tag("rcu"))) *ptrs[0];
};

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct folio *);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct folio *);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	unsigned long pfn;
	unsigned long i_ino;
	unsigned long index;
	dev_t s_dev;
	unsigned char order;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	unsigned long i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	unsigned long i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct cachestat_range {
	__u64 off;
	__u64 len;
};

struct cachestat {
	__u64 nr_cache;
	__u64 nr_dirty;
	__u64 nr_writeback;
	__u64 nr_evicted;
	__u64 nr_recently_evicted;
};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

enum mnt_tree_flags_t {
	MNT_TREE_MOVE = 1,
	MNT_TREE_BENEATH = 2,
};

struct mount_attr {
	__u64 attr_set;
	__u64 attr_clr;
	__u64 propagation;
	__u64 userns_fd;
};

struct mount_kattr {
	unsigned int attr_set;
	unsigned int attr_clr;
	unsigned int propagation;
	unsigned int lookup_flags;
	bool recurse;
	struct user_namespace *mnt_userns;
	struct mnt_idmap *mnt_idmap;
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct vmcore {
	struct list_head list;
	unsigned long long paddr;
	unsigned long long size;
	loff_t offset;
};

struct vmcore_cb {
	bool (*pfn_is_ram)(struct vmcore_cb *, unsigned long);
	struct list_head next;
};

typedef struct elf64_note Elf64_Nhdr;

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
};

struct nfs_open_dir_context {
	struct list_head list;
	atomic_t cache_hits;
	atomic_t cache_misses;
	unsigned long attr_gencount;
	__be32 verf[2];
	__u64 dir_cookie;
	__u64 last_cookie;
	unsigned long page_index;
	unsigned int dtsize;
	bool force_clear;
	bool eof;
	struct callback_head callback_head;
};

struct nfs_readdir_descriptor {
	struct file *file;
	struct folio *folio;
	struct dir_context *ctx;
	unsigned long folio_index;
	unsigned long folio_index_max;
	u64 dir_cookie;
	u64 last_cookie;
	loff_t current_index;
	__be32 verf[2];
	unsigned long dir_verifier;
	unsigned long timestamp;
	unsigned long gencount;
	unsigned long attr_gencount;
	unsigned int cache_entry_index;
	unsigned int buffer_fills;
	unsigned int dtsize;
	bool clear_cache;
	bool plus;
	bool eob;
	bool eof;
};

struct nfs_cache_array_entry {
	u64 cookie;
	u64 ino;
	const char *name;
	unsigned int name_len;
	unsigned char d_type;
};

struct nfs_cache_array {
	u64 change_attr;
	u64 last_cookie;
	unsigned int size;
	unsigned char folio_full: 1;
	unsigned char folio_is_eof: 1;
	unsigned char cookies_are_ordered: 1;
	struct nfs_cache_array_entry array[0];
};

struct nfs4_xattr_bucket {
	spinlock_t lock;
	struct hlist_head hlist;
	struct nfs4_xattr_cache *cache;
	bool draining;
};

struct nfs4_xattr_entry;

struct nfs4_xattr_cache {
	struct kref ref;
	struct nfs4_xattr_bucket buckets[64];
	struct list_head lru;
	struct list_head dispose;
	atomic_long_t nent;
	spinlock_t listxattr_lock;
	struct inode *inode;
	struct nfs4_xattr_entry *listxattr;
};

struct nfs4_xattr_entry {
	struct kref ref;
	struct hlist_node hnode;
	struct list_head lru;
	struct list_head dispose;
	char *xattr_name;
	void *xattr_value;
	size_t xattr_size;
	struct nfs4_xattr_bucket *bucket;
	uint32_t flags;
};

typedef unsigned long (*count_objects_cb)(struct shrinker *, struct shrink_control *);

typedef unsigned long (*scan_objects_cb)(struct shrinker *, struct shrink_control *);

struct variable_validate {
	efi_guid_t vendor;
	char *name;
	bool (*validate)(efi_char16_t *, int, u8 *, unsigned long);
};

struct aead_request;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	struct crypto_alg base;
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	void *__ctx[0];
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

enum blktrace_cat {
	BLK_TC_READ = 1,
	BLK_TC_WRITE = 2,
	BLK_TC_FLUSH = 4,
	BLK_TC_SYNC = 8,
	BLK_TC_SYNCIO = 8,
	BLK_TC_QUEUE = 16,
	BLK_TC_REQUEUE = 32,
	BLK_TC_ISSUE = 64,
	BLK_TC_COMPLETE = 128,
	BLK_TC_FS = 256,
	BLK_TC_PC = 512,
	BLK_TC_NOTIFY = 1024,
	BLK_TC_AHEAD = 2048,
	BLK_TC_META = 4096,
	BLK_TC_DISCARD = 8192,
	BLK_TC_DRV_DATA = 16384,
	BLK_TC_FUA = 32768,
	BLK_TC_END = 32768,
};

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	struct filename *filename;
	struct statx __attribute__((btf_type_tag("user"))) *buffer;
};

union nested_table {
	union nested_table __attribute__((btf_type_tag("rcu"))) *table;
	struct rhash_lock_head __attribute__((btf_type_tag("rcu"))) *bucket;
};

struct rhltable {
	struct rhashtable ht;
};

struct gic_clk_data {
	unsigned int num_clocks;
	const char * const *clocks;
};

struct gic_chip_data;

struct gic_chip_pm {
	struct gic_chip_data *chip_data;
	const struct gic_clk_data *clk_data;
	struct clk_bulk_data *clks;
};

struct gpcv2_irqchip_data {
	struct raw_spinlock rlock;
	void *gpc_base;
	u32 wakeup_sources[4];
	u32 saved_irq_mask[4];
	u32 cpu2wakeup;
};

struct sl28cpld_intc {
	struct regmap *regmap;
	struct regmap_irq_chip chip;
	struct regmap_irq_chip_data *irq_data;
};

struct value_to_name_map {
	int value;
	const char *name;
};

struct match_chip_info {
	void (*init_func)(struct brcm_usb_init_params *);
	u8 required_regs[7];
	u8 optional_reg;
};

enum brcm_usb_phy_id {
	BRCM_USB_PHY_2_0 = 0,
	BRCM_USB_PHY_3_0 = 1,
	BRCM_USB_PHY_ID_MAX = 2,
};

struct brcm_usb_phy {
	struct phy *phy;
	unsigned int id;
	bool inited;
};

struct brcm_usb_phy_data {
	struct brcm_usb_init_params ini;
	bool has_eohci;
	bool has_xhci;
	struct clk *usb_20_clk;
	struct clk *usb_30_clk;
	struct clk *suspend_clk;
	struct mutex mutex;
	int init_count;
	int wake_irq;
	struct brcm_usb_phy phys[2];
	struct notifier_block pm_notifier;
	bool pm_active;
};

struct samsung_usb2_common_phy;

struct samsung_usb2_phy_config {
	const struct samsung_usb2_common_phy *phys;
	int (*rate_to_clk)(unsigned long, u32 *);
	unsigned int num_phys;
	bool has_mode_switch;
	bool has_refclk_sel;
};

struct samsung_usb2_phy_instance;

struct samsung_usb2_common_phy {
	int (*power_on)(struct samsung_usb2_phy_instance *);
	int (*power_off)(struct samsung_usb2_phy_instance *);
	unsigned int id;
	char *label;
};

struct samsung_usb2_phy_driver;

struct samsung_usb2_phy_instance {
	const struct samsung_usb2_common_phy *cfg;
	struct phy *phy;
	struct samsung_usb2_phy_driver *drv;
	int int_cnt;
	int ext_cnt;
};

struct samsung_usb2_phy_driver {
	const struct samsung_usb2_phy_config *cfg;
	struct clk *clk;
	struct clk *ref_clk;
	struct regulator *vbus;
	unsigned long ref_rate;
	u32 ref_reg_val;
	struct device *dev;
	void *reg_phy;
	struct regmap *reg_pmu;
	struct regmap *reg_sys;
	spinlock_t lock;
	struct samsung_usb2_phy_instance instances[0];
};

enum pm_pinctrl_pull_ctrl {
	PM_PINCTRL_BIAS_PULL_DOWN = 0,
	PM_PINCTRL_BIAS_PULL_UP = 1,
};

enum pm_pinctrl_bias_status {
	PM_PINCTRL_BIAS_DISABLE = 0,
	PM_PINCTRL_BIAS_ENABLE = 1,
};

enum pm_pinctrl_drive_strength {
	PM_PINCTRL_DRIVE_STRENGTH_2MA = 0,
	PM_PINCTRL_DRIVE_STRENGTH_4MA = 1,
	PM_PINCTRL_DRIVE_STRENGTH_8MA = 2,
	PM_PINCTRL_DRIVE_STRENGTH_12MA = 3,
};

enum pm_pinctrl_tri_state {
	PM_PINCTRL_TRI_STATE_DISABLE = 0,
	PM_PINCTRL_TRI_STATE_ENABLE = 1,
};

struct zynqmp_pctrl_group;

struct zynqmp_pmux_function;

struct zynqmp_pinctrl {
	struct pinctrl_dev *pctrl;
	const struct zynqmp_pctrl_group *groups;
	unsigned int ngroups;
	const struct zynqmp_pmux_function *funcs;
	unsigned int nfuncs;
};

struct zynqmp_pctrl_group {
	const char *name;
	unsigned int pins[50];
	unsigned int npins;
};

struct zynqmp_pmux_function {
	char name[16];
	const char * const *groups;
	unsigned int ngroups;
};

enum {
	GP_LAST___5 = 209,
	PIN_ASEBRK = 210,
	PIN_AVB_MDC = 211,
	PIN_AVB_MDIO = 212,
	PIN_AVB_TD0 = 213,
	PIN_AVB_TD1 = 214,
	PIN_AVB_TD2 = 215,
	PIN_AVB_TD3 = 216,
	PIN_AVB_TXC = 217,
	PIN_AVB_TX_CTL = 218,
	PIN_FSCLKST_N___4 = 219,
	PIN_MLB_REF___2 = 220,
	PIN_PRESETOUT_N___4 = 221,
	PIN_TCK___3 = 222,
	PIN_TDI___3 = 223,
	PIN_TMS___3 = 224,
	PIN_TRST_N___3 = 225,
	PIN_VDDQ_AVB0___4 = 226,
};

struct acpi_gpio_event {
	struct list_head node;
	acpi_handle handle;
	irq_handler_t handler;
	unsigned int pin;
	unsigned int irq;
	unsigned long irqflags;
	bool irq_is_wake;
	bool irq_requested;
	struct gpio_desc *desc;
};

struct acpi_gpio_connection {
	struct list_head node;
	unsigned int pin;
	struct gpio_desc *desc;
};

struct acpi_gpio_chip {
	struct acpi_connection_info conn_info;
	struct list_head conns;
	struct mutex conn_lock;
	struct gpio_chip *chip;
	struct list_head events;
	struct list_head deferred_req_irqs_list_entry;
};

struct acpi_gpio_info {
	struct acpi_device *adev;
	enum gpiod_flags flags;
	bool gpioint;
	int pin_config;
	int polarity;
	int triggering;
	bool wake_capable;
	unsigned int debounce;
	unsigned int quirks;
};

struct acpi_gpio_lookup {
	struct acpi_gpio_info info;
	int index;
	u16 pin_index;
	bool active_low;
	struct gpio_desc *desc;
	int n;
};

struct acpi_gpiolib_dmi_quirk {
	bool no_edge_events_on_boot;
	char *ignore_wake;
	char *ignore_interrupt;
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
	unsigned int flags;
};

enum smbios_attr_enum {
	SMBIOS_ATTR_NONE = 0,
	SMBIOS_ATTR_LABEL_SHOW = 1,
	SMBIOS_ATTR_INSTANCE_SHOW = 2,
};

enum acpi_attr_enum {
	ACPI_ATTR_LABEL_SHOW = 0,
	ACPI_ATTR_INDEX_SHOW = 1,
};

struct dmi_dev_onboard {
	struct dmi_device dev;
	int instance;
	int segment;
	int bus;
	int devfn;
};

struct iproc_pcie_ob_map {
	resource_size_t window_sizes[4];
	unsigned int nr_sizes;
};

enum iproc_pcie_ib_map_type {
	IPROC_PCIE_IB_MAP_MEM = 0,
	IPROC_PCIE_IB_MAP_IO = 1,
	IPROC_PCIE_IB_MAP_INVALID = 2,
};

struct iproc_pcie_ib_map {
	enum iproc_pcie_ib_map_type type;
	unsigned int size_unit;
	resource_size_t region_sizes[9];
	unsigned int nr_sizes;
	unsigned int nr_windows;
	u16 imap_addr_offset;
	u16 imap_window_offset;
};

enum iproc_pcie_type {
	IPROC_PCIE_PAXB_BCMA = 0,
	IPROC_PCIE_PAXB = 1,
	IPROC_PCIE_PAXB_V2 = 2,
	IPROC_PCIE_PAXC = 3,
	IPROC_PCIE_PAXC_V2 = 4,
};

enum iproc_pcie_reg {
	IPROC_PCIE_CLK_CTRL = 0,
	IPROC_PCIE_MSI_GIC_MODE = 1,
	IPROC_PCIE_MSI_BASE_ADDR = 2,
	IPROC_PCIE_MSI_WINDOW_SIZE = 3,
	IPROC_PCIE_MSI_ADDR_LO = 4,
	IPROC_PCIE_MSI_ADDR_HI = 5,
	IPROC_PCIE_MSI_EN_CFG = 6,
	IPROC_PCIE_CFG_IND_ADDR = 7,
	IPROC_PCIE_CFG_IND_DATA = 8,
	IPROC_PCIE_CFG_ADDR = 9,
	IPROC_PCIE_CFG_DATA = 10,
	IPROC_PCIE_INTX_EN = 11,
	IPROC_PCIE_OARR0 = 12,
	IPROC_PCIE_OMAP0 = 13,
	IPROC_PCIE_OARR1 = 14,
	IPROC_PCIE_OMAP1 = 15,
	IPROC_PCIE_OARR2 = 16,
	IPROC_PCIE_OMAP2 = 17,
	IPROC_PCIE_OARR3 = 18,
	IPROC_PCIE_OMAP3 = 19,
	IPROC_PCIE_IARR0 = 20,
	IPROC_PCIE_IMAP0 = 21,
	IPROC_PCIE_IARR1 = 22,
	IPROC_PCIE_IMAP1 = 23,
	IPROC_PCIE_IARR2 = 24,
	IPROC_PCIE_IMAP2 = 25,
	IPROC_PCIE_IARR3 = 26,
	IPROC_PCIE_IMAP3 = 27,
	IPROC_PCIE_IARR4 = 28,
	IPROC_PCIE_IMAP4 = 29,
	IPROC_PCIE_CFG_RD_STATUS = 30,
	IPROC_PCIE_LINK_STATUS = 31,
	IPROC_PCIE_APB_ERR_EN = 32,
	IPROC_PCIE_MAX_NUM_REG = 33,
};

struct iproc_pcie_ob {
	resource_size_t axi_offset;
	unsigned int nr_windows;
};

struct iproc_pcie_ib {
	unsigned int nr_regions;
};

struct iproc_msi;

struct iproc_pcie {
	struct device *dev;
	enum iproc_pcie_type type;
	u16 *reg_offsets;
	void *base;
	phys_addr_t base_addr;
	struct resource mem;
	struct phy *phy;
	int (*map_irq)(const struct pci_dev *, u8, u8);
	bool ep_is_internal;
	bool iproc_cfg_read;
	bool rej_unconfig_pf;
	bool has_apb_err_disable;
	bool fix_paxc_cap;
	bool need_ob_cfg;
	struct iproc_pcie_ob ob;
	const struct iproc_pcie_ob_map *ob_map;
	bool need_ib_cfg;
	struct iproc_pcie_ib ib;
	const struct iproc_pcie_ib_map *ib_map;
	bool need_msi_steer;
	struct iproc_msi *msi;
};

enum {
	FBCON_LOGO_CANSHOW = -1,
	FBCON_LOGO_DRAW = -2,
	FBCON_LOGO_DONTSHOW = -3,
};

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct prt_quirk {
	const struct dmi_system_id *system;
	unsigned int segment;
	unsigned int bus;
	unsigned int device;
	unsigned char pin;
	const char *source;
	const char *actual_source;
};

struct acpi_prt_entry {
	struct acpi_pci_id id;
	u8 pin;
	acpi_handle link;
	u32 index;
};

typedef enum {
	ACPI_TRACE_AML_METHOD = 0,
	ACPI_TRACE_AML_OPCODE = 1,
	ACPI_TRACE_AML_REGION = 2,
} acpi_trace_event_type;

struct acpi_get_devices_info {
	acpi_walk_callback user_function;
	void *context;
	const char *hid;
};

struct acpi_comment_node {
	char *comment;
	struct acpi_comment_node *next;
};

struct acpi_table_list {
	struct acpi_table_desc *tables;
	u32 current_table_count;
	u32 max_table_count;
	u8 flags;
};

struct acpi_mutex_info {
	void *mutex;
	u32 use_count;
	u64 thread_id;
};

typedef acpi_status (*acpi_exception_handler)(acpi_status, acpi_name, u16, u32, void *);

typedef acpi_status (*acpi_init_handler)(acpi_handle, u32);

typedef u32 (*acpi_sci_handler)(void *);

struct acpi_sci_handler_info {
	struct acpi_sci_handler_info *next;
	acpi_sci_handler address;
	void *context;
};

struct acpi_ged_handler_info {
	struct acpi_ged_handler_info *next;
	u32 int_id;
	struct acpi_namespace_node *evt_method;
};

struct acpi_memory_info {
	struct list_head list;
	u64 start_addr;
	u64 length;
	unsigned short caching;
	unsigned short write_protect;
	unsigned int enabled: 1;
};

struct acpi_memory_device {
	struct acpi_device *device;
	struct list_head res_list;
	int mgid;
};

typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);

struct clk_parent_map;

struct clk_core {
	const char *name;
	const struct clk_ops *ops;
	struct clk_hw *hw;
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct clk_core *parent;
	struct clk_parent_map *parents;
	u8 num_parents;
	u8 new_parent_index;
	unsigned long rate;
	unsigned long req_rate;
	unsigned long new_rate;
	struct clk_core *new_parent;
	struct clk_core *new_child;
	unsigned long flags;
	bool orphan;
	bool rpm_enabled;
	unsigned int enable_count;
	unsigned int prepare_count;
	unsigned int protect_count;
	unsigned long min_rate;
	unsigned long max_rate;
	unsigned long accuracy;
	int phase;
	struct clk_duty duty;
	struct hlist_head children;
	struct hlist_node child_node;
	struct hlist_head clks;
	unsigned int notifier_count;
	struct dentry *dentry;
	struct hlist_node debug_node;
	struct kref ref;
};

struct clk_parent_map {
	const struct clk_hw *hw;
	struct clk_core *core;
	const char *fw_name;
	const char *name;
	int index;
};

typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, unsigned long);

typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, unsigned long);

typedef void (*btf_trace_clk_set_min_rate)(void *, struct clk_core *, unsigned long);

typedef void (*btf_trace_clk_set_max_rate)(void *, struct clk_core *, unsigned long);

typedef void (*btf_trace_clk_set_rate_range)(void *, struct clk_core *, unsigned long, unsigned long);

typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_rate_request_start)(void *, struct clk_rate_request *);

typedef void (*btf_trace_clk_rate_request_done)(void *, struct clk_rate_request *);

struct clk_notifier {
	struct clk *clk;
	struct srcu_notifier_head notifier_head;
	struct list_head node;
};

struct of_clk_provider {
	struct list_head link;
	struct device_node *node;
	struct clk * (*get)(struct of_phandle_args *, void *);
	struct clk_hw * (*get_hw)(struct of_phandle_args *, void *);
	void *data;
};

struct clock_provider {
	void (*clk_init_cb)(struct device_node *);
	struct device_node *np;
	struct list_head node;
};

struct trace_event_raw_clk {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_clk_rate {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned long rate;
	char __data[0];
};

struct trace_event_raw_clk_rate_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned long min;
	unsigned long max;
	char __data[0];
};

struct trace_event_raw_clk_parent {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	char __data[0];
};

struct trace_event_raw_clk_phase {
	struct trace_entry ent;
	u32 __data_loc_name;
	int phase;
	char __data[0];
};

struct trace_event_raw_clk_duty_cycle {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int num;
	unsigned int den;
	char __data[0];
};

struct trace_event_raw_clk_rate_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	unsigned long min;
	unsigned long max;
	unsigned long prate;
	char __data[0];
};

struct trace_event_data_offsets_clk {
	u32 name;
};

struct trace_event_data_offsets_clk_rate {
	u32 name;
};

struct trace_event_data_offsets_clk_rate_range {
	u32 name;
};

struct trace_event_data_offsets_clk_parent {
	u32 name;
	u32 pname;
};

struct trace_event_data_offsets_clk_phase {
	u32 name;
};

struct trace_event_data_offsets_clk_duty_cycle {
	u32 name;
};

struct trace_event_data_offsets_clk_rate_request {
	u32 name;
	u32 pname;
};

struct clk_notifier_devres {
	struct clk *clk;
	struct notifier_block *nb;
};

struct clk_fixup_div {
	struct clk_divider divider;
	const struct clk_ops *ops;
	void (*fixup)(u32 *);
};

enum imx_pllv3_type {
	IMX_PLLV3_GENERIC = 0,
	IMX_PLLV3_SYS = 1,
	IMX_PLLV3_USB = 2,
	IMX_PLLV3_USB_VF610 = 3,
	IMX_PLLV3_AV = 4,
	IMX_PLLV3_ENET = 5,
	IMX_PLLV3_ENET_IMX7 = 6,
	IMX_PLLV3_SYS_VF610 = 7,
	IMX_PLLV3_DDR_IMX7 = 8,
	IMX_PLLV3_AV_IMX7 = 9,
};

struct clk_pllv3 {
	struct clk_hw hw;
	void *base;
	u32 power_bit;
	bool powerup_set;
	u32 div_mask;
	u32 div_shift;
	unsigned long ref_clock;
	u32 num_offset;
	u32 denom_offset;
};

struct clk_pllv3_vf610_mf {
	u32 mfi;
	u32 mfn;
	u32 mfd;
};

struct clk_sscg_pll_setup {
	int divr1;
	int divf1;
	int divr2;
	int divf2;
	int divq;
	int bypass;
	uint64_t vco1;
	uint64_t vco2;
	uint64_t fout;
	uint64_t ref;
	uint64_t ref_div1;
	uint64_t ref_div2;
	uint64_t fout_request;
	int fout_error;
};

struct clk_sscg_pll {
	struct clk_hw hw;
	const struct clk_ops ops;
	void *base;
	struct clk_sscg_pll_setup setup;
	u8 parent;
	u8 bypass1;
	u8 bypass2;
};

enum imx_sc_pm_func {
	IMX_SC_PM_FUNC_UNKNOWN = 0,
	IMX_SC_PM_FUNC_SET_SYS_POWER_MODE = 19,
	IMX_SC_PM_FUNC_SET_PARTITION_POWER_MODE = 1,
	IMX_SC_PM_FUNC_GET_SYS_POWER_MODE = 2,
	IMX_SC_PM_FUNC_SET_RESOURCE_POWER_MODE = 3,
	IMX_SC_PM_FUNC_GET_RESOURCE_POWER_MODE = 4,
	IMX_SC_PM_FUNC_REQ_LOW_POWER_MODE = 16,
	IMX_SC_PM_FUNC_SET_CPU_RESUME_ADDR = 17,
	IMX_SC_PM_FUNC_REQ_SYS_IF_POWER_MODE = 18,
	IMX_SC_PM_FUNC_SET_CLOCK_RATE = 5,
	IMX_SC_PM_FUNC_GET_CLOCK_RATE = 6,
	IMX_SC_PM_FUNC_CLOCK_ENABLE = 7,
	IMX_SC_PM_FUNC_SET_CLOCK_PARENT = 14,
	IMX_SC_PM_FUNC_GET_CLOCK_PARENT = 15,
	IMX_SC_PM_FUNC_RESET = 13,
	IMX_SC_PM_FUNC_RESET_REASON = 10,
	IMX_SC_PM_FUNC_BOOT = 8,
	IMX_SC_PM_FUNC_REBOOT = 9,
	IMX_SC_PM_FUNC_REBOOT_PARTITION = 12,
	IMX_SC_PM_FUNC_CPU_START = 11,
};

struct imx_scu_clk_node {
	const char *name;
	u32 rsrc;
	u8 clk_type;
	const char * const *parents;
	int num_parents;
	struct clk_hw *hw;
	struct list_head node;
};

struct clk_scu {
	struct clk_hw hw;
	u16 rsrc_id;
	u8 clk_type;
	struct clk_hw *parent;
	u8 parent_index;
	bool is_enabled;
	u32 rate;
};

struct clk_gpr_scu {
	struct clk_hw hw;
	u16 rsrc_id;
	u8 gpr_id;
	u8 flags;
	bool gate_invert;
};

struct imx_sc_msg_req_clock_enable {
	struct imx_sc_rpc_msg hdr;
	__le16 resource;
	u8 clk;
	u8 enable;
	u8 autog;
	int: 0;
};

struct req_get_clock_rate {
	__le16 resource;
	u8 clk;
};

struct resp_get_clock_rate {
	__le32 rate;
};

struct imx_sc_msg_get_clock_rate {
	struct imx_sc_rpc_msg hdr;
	union {
		struct req_get_clock_rate req;
		struct resp_get_clock_rate resp;
	} data;
};

struct imx_sc_msg_set_clock_parent {
	struct imx_sc_rpc_msg hdr;
	__le16 resource;
	u8 clk;
	u8 parent;
};

struct imx_sc_msg_req_set_clock_rate {
	struct imx_sc_rpc_msg hdr;
	__le32 rate;
	__le16 resource;
	u8 clk;
};

struct req_get_clock_parent {
	__le16 resource;
	u8 clk;
};

struct resp_get_clock_parent {
	u8 parent;
};

struct imx_sc_msg_get_clock_parent {
	struct imx_sc_rpc_msg hdr;
	union {
		struct req_get_clock_parent req;
		struct resp_get_clock_parent resp;
	} data;
};

enum rcar_gen4_clk_types {
	CLK_TYPE_GEN4_MAIN = 5,
	CLK_TYPE_GEN4_PLL1 = 6,
	CLK_TYPE_GEN4_PLL2 = 7,
	CLK_TYPE_GEN4_PLL2_VAR = 8,
	CLK_TYPE_GEN4_PLL2X_3X = 9,
	CLK_TYPE_GEN4_PLL3 = 10,
	CLK_TYPE_GEN4_PLL4 = 11,
	CLK_TYPE_GEN4_PLL5 = 12,
	CLK_TYPE_GEN4_PLL6 = 13,
	CLK_TYPE_GEN4_SDSRC = 14,
	CLK_TYPE_GEN4_SDH = 15,
	CLK_TYPE_GEN4_SD = 16,
	CLK_TYPE_GEN4_MDSEL = 17,
	CLK_TYPE_GEN4_Z = 18,
	CLK_TYPE_GEN4_OSC = 19,
	CLK_TYPE_GEN4_RPCSRC = 20,
	CLK_TYPE_GEN4_RPC = 21,
	CLK_TYPE_GEN4_RPCD2 = 22,
	CLK_TYPE_GEN4_SOC_BASE = 23,
};

struct cpg_pll_clk___2 {
	struct clk_hw hw;
	void *pllcr0_reg;
	void *pllecr_reg;
	u32 pllecr_pllst_mask;
};

struct uniphier_clk_mux {
	struct clk_hw hw;
	struct regmap *regmap;
	unsigned int reg;
	const unsigned int *masks;
	const unsigned int *vals;
};

enum owl_dma_id {
	S900_DMA = 0,
	S700_DMA = 1,
};

enum owl_dmadesc_offsets {
	OWL_DMADESC_NEXT_LLI = 0,
	OWL_DMADESC_SADDR = 1,
	OWL_DMADESC_DADDR = 2,
	OWL_DMADESC_FLEN = 3,
	OWL_DMADESC_SRC_STRIDE = 4,
	OWL_DMADESC_DST_STRIDE = 5,
	OWL_DMADESC_CTRLA = 6,
	OWL_DMADESC_CTRLB = 7,
	OWL_DMADESC_CONST_NUM = 8,
	OWL_DMADESC_SIZE = 9,
};

struct owl_dma_pchan;

struct owl_dma_txd;

struct owl_dma_vchan {
	struct virt_dma_chan vc;
	struct owl_dma_pchan *pchan;
	struct owl_dma_txd *txd;
	struct dma_slave_config cfg;
	u8 drq;
};

struct owl_dma_pchan {
	u32 id;
	void *base;
	struct owl_dma_vchan *vchan;
};

struct owl_dma_txd {
	struct virt_dma_desc vd;
	struct list_head lli_list;
	bool cyclic;
};

struct owl_dma_lli {
	u32 hw[9];
	dma_addr_t phys;
	struct list_head node;
};

struct owl_dma {
	struct dma_device dma;
	void *base;
	struct clk *clk;
	spinlock_t lock;
	struct dma_pool *lli_pool;
	int irq;
	unsigned int nr_pchans;
	struct owl_dma_pchan *pchans;
	unsigned int nr_vchans;
	struct owl_dma_vchan *vchans;
	enum owl_dma_id devid;
};

typedef void (*btf_trace_rpmh_tx_done)(void *, struct rsc_drv *, int, const struct tcs_request *);

typedef void (*btf_trace_rpmh_send_msg)(void *, struct rsc_drv *, int, enum rpmh_state, int, u32, const struct tcs_cmd *);

enum {
	RSC_DRV_TCS_OFFSET = 0,
	RSC_DRV_CMD_OFFSET = 1,
	DRV_SOLVER_CONFIG = 2,
	DRV_PRNT_CHLD_CONFIG = 3,
	RSC_DRV_IRQ_ENABLE = 4,
	RSC_DRV_IRQ_STATUS = 5,
	RSC_DRV_IRQ_CLEAR = 6,
	RSC_DRV_CMD_WAIT_FOR_CMPL = 7,
	RSC_DRV_CONTROL = 8,
	RSC_DRV_STATUS = 9,
	RSC_DRV_CMD_ENABLE = 10,
	RSC_DRV_CMD_MSGID = 11,
	RSC_DRV_CMD_ADDR = 12,
	RSC_DRV_CMD_DATA = 13,
	RSC_DRV_CMD_STATUS = 14,
	RSC_DRV_CMD_RESP_DATA = 15,
};

struct trace_event_raw_rpmh_tx_done {
	struct trace_entry ent;
	u32 __data_loc_name;
	int m;
	u32 addr;
	u32 data;
	char __data[0];
};

struct trace_event_raw_rpmh_send_msg {
	struct trace_entry ent;
	u32 __data_loc_name;
	int m;
	u32 state;
	int n;
	u32 hdr;
	u32 addr;
	u32 data;
	bool wait;
	char __data[0];
};

struct trace_event_data_offsets_rpmh_tx_done {
	u32 name;
};

struct trace_event_data_offsets_rpmh_send_msg {
	u32 name;
};

struct tcs_type_config {
	u32 type;
	u32 n;
};

struct tegra_fuse_soc;

struct tegra_fuse {
	struct device *dev;
	void *base;
	phys_addr_t phys;
	struct clk *clk;
	struct reset_control *rst;
	u32 (*read_early)(struct tegra_fuse *, unsigned int);
	u32 (*read)(struct tegra_fuse *, unsigned int);
	const struct tegra_fuse_soc *soc;
	struct {
		struct mutex lock;
		struct completion wait;
		struct dma_chan *chan;
		struct dma_slave_config config;
		dma_addr_t phys;
		u32 *virt;
	} apbdma;
	struct nvmem_device *nvmem;
	struct nvmem_cell_lookup *lookups;
};

struct tegra_fuse_info;

struct tegra_fuse_soc {
	void (*init)(struct tegra_fuse *);
	void (*speedo_init)(struct tegra_sku_info *);
	int (*probe)(struct tegra_fuse *);
	const struct tegra_fuse_info *info;
	const struct nvmem_cell_lookup *lookups;
	unsigned int num_lookups;
	const struct nvmem_cell_info *cells;
	unsigned int num_cells;
	const struct nvmem_keepout *keepouts;
	unsigned int num_keepouts;
	const struct attribute_group *soc_attr_group;
	bool clk_suspend_on;
};

struct tegra_fuse_info {
	u32 (*read)(struct tegra_fuse *, unsigned int);
	unsigned int size;
	unsigned int spare;
};

struct privcmd_hypercall {
	__u64 op;
	__u64 arg[5];
};

struct privcmd_data {
	domid_t domid;
};

struct privcmd_mmap_entry;

struct privcmd_mmap {
	int num;
	domid_t dom;
	struct privcmd_mmap_entry __attribute__((btf_type_tag("user"))) *entry;
};

struct privcmd_mmap_entry {
	__u64 va;
	__u64 mfn;
	__u64 npages;
};

struct mmap_gfn_state {
	unsigned long va;
	struct vm_area_struct *vma;
	domid_t domain;
};

struct privcmd_mmap_resource {
	domid_t dom;
	__u32 type;
	__u32 id;
	__u32 idx;
	__u64 num;
	__u64 addr;
};

struct xen_mem_acquire_resource {
	domid_t domid;
	uint16_t type;
	uint32_t id;
	uint32_t nr_frames;
	uint32_t flags;
	uint64_t frame;
	__guest_handle_xen_pfn_t frame_list;
};

struct privcmd_dm_op_buf;

struct privcmd_dm_op {
	domid_t dom;
	__u16 num;
	const struct privcmd_dm_op_buf __attribute__((btf_type_tag("user"))) *ubufs;
};

struct privcmd_dm_op_buf {
	void __attribute__((btf_type_tag("user"))) *uptr;
	size_t size;
};

struct xen_dm_op_buf {
	__guest_handle_void h;
	xen_ulong_t size;
};

struct mmap_batch_state {
	domid_t domain;
	unsigned long va;
	struct vm_area_struct *vma;
	int index;
	int global_error;
	int version;
	xen_pfn_t __attribute__((btf_type_tag("user"))) *user_gfn;
	int __attribute__((btf_type_tag("user"))) *user_err;
};

struct privcmd_mmapbatch_v2 {
	unsigned int num;
	domid_t dom;
	__u64 addr;
	const xen_pfn_t __attribute__((btf_type_tag("user"))) *arr;
	int __attribute__((btf_type_tag("user"))) *err;
};

struct reset_simple_devdata {
	u32 reg_offset;
	u32 nr_resets;
	bool active_low;
	bool status_active_low;
};

struct tegra_uart_chip_data {
	bool tx_fifo_full_status;
	bool allow_txfifo_reset_fifo_mode;
	bool support_clk_src_div;
	bool fifo_mode_enable_status;
	int uart_max_port;
	int max_dma_burst_bytes;
	int error_tolerance_low_range;
	int error_tolerance_high_range;
};

struct tegra_baud_tolerance;

struct tegra_uart_port {
	struct uart_port uport;
	const struct tegra_uart_chip_data *cdata;
	struct clk *uart_clk;
	struct reset_control *rst;
	unsigned int current_baud;
	unsigned long fcr_shadow;
	unsigned long mcr_shadow;
	unsigned long lcr_shadow;
	unsigned long ier_shadow;
	bool rts_active;
	int tx_in_progress;
	unsigned int tx_bytes;
	bool enable_modem_interrupt;
	bool rx_timeout;
	int rx_in_progress;
	int symb_bit;
	struct dma_chan *rx_dma_chan;
	struct dma_chan *tx_dma_chan;
	dma_addr_t rx_dma_buf_phys;
	dma_addr_t tx_dma_buf_phys;
	unsigned char *rx_dma_buf_virt;
	unsigned char *tx_dma_buf_virt;
	struct dma_async_tx_descriptor *tx_dma_desc;
	struct dma_async_tx_descriptor *rx_dma_desc;
	dma_cookie_t tx_cookie;
	dma_cookie_t rx_cookie;
	unsigned int tx_bytes_requested;
	unsigned int rx_bytes_requested;
	struct tegra_baud_tolerance *baud_tolerance;
	int n_adjustable_baud_rates;
	int required_rate;
	int configured_rate;
	bool use_rx_pio;
	bool use_tx_pio;
	bool rx_dma_active;
};

struct tegra_baud_tolerance {
	u32 lower_range_baud;
	u32 upper_range_baud;
	s32 tolerance;
};

struct cavium_rng {
	struct hwrng ops;
	void *result;
	void *pf_regbase;
	struct pci_dev *pdev;
	u64 clock_rate;
	u64 prev_error;
	u64 prev_time;
};

struct rk_iommu_ops {
	phys_addr_t (*pt_address)(u32);
	u32 (*mk_dtentries)(dma_addr_t);
	u32 (*mk_ptentries)(phys_addr_t, int);
	u64 dma_bit_mask;
	gfp_t gfp_flags;
};

struct rk_iommu_domain {
	struct list_head iommus;
	u32 *dt;
	dma_addr_t dt_dma;
	spinlock_t iommus_lock;
	spinlock_t dt_lock;
	struct iommu_domain domain;
};

struct rk_iommu {
	struct device *dev;
	void **bases;
	int num_mmu;
	int num_irq;
	struct clk_bulk_data *clocks;
	int num_clocks;
	bool reset_disabled;
	struct iommu_device iommu;
	struct list_head node;
	struct iommu_domain *domain;
};

struct rk_iommudata {
	struct device_link *link;
	struct rk_iommu *iommu;
};

struct regmap_async_spi {
	struct regmap_async core;
	struct spi_message m;
	struct spi_transfer t[2];
};

struct virtio_blk_vq;

struct virtio_blk {
	struct mutex vdev_mutex;
	struct virtio_device *vdev;
	struct gendisk *disk;
	struct blk_mq_tag_set tag_set;
	struct work_struct config_work;
	int index;
	int num_vqs;
	int io_queues[3];
	struct virtio_blk_vq *vqs;
	unsigned int zone_sectors;
};

struct virtio_blk_vq {
	struct virtqueue *vq;
	spinlock_t lock;
	char name[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct virtio_blk_outhdr {
	__virtio32 type;
	__virtio32 ioprio;
	__virtio64 sector;
};

struct virtblk_req {
	struct virtio_blk_outhdr out_hdr;
	union {
		u8 status;
		struct {
			__virtio64 sector;
			u8 status;
		} zone_append;
	} in_hdr;
	size_t in_hdr_len;
	struct sg_table sg_table;
	struct scatterlist sg[0];
};

struct virtio_blk_discard_write_zeroes {
	__le64 sector;
	__le32 num_sectors;
	__le32 flags;
};

struct syscon {
	struct device_node *np;
	struct regmap *regmap;
	struct reset_control *reset;
	struct list_head list;
};

struct syscon_platform_data {
	const char *label;
};

enum scsi_msg_byte {
	COMMAND_COMPLETE = 0,
	EXTENDED_MESSAGE = 1,
	SAVE_POINTERS = 2,
	RESTORE_POINTERS = 3,
	DISCONNECT = 4,
	INITIATOR_ERROR = 5,
	ABORT_TASK_SET = 6,
	MESSAGE_REJECT = 7,
	NOP = 8,
	MSG_PARITY_ERROR = 9,
	LINKED_CMD_COMPLETE = 10,
	LINKED_FLG_CMD_COMPLETE = 11,
	TARGET_RESET = 12,
	ABORT_TASK = 13,
	CLEAR_TASK_SET = 14,
	INITIATE_RECOVERY = 15,
	RELEASE_RECOVERY = 16,
	TERMINATE_IO_PROC = 17,
	CLEAR_ACA = 22,
	LOGICAL_UNIT_RESET = 23,
	SIMPLE_QUEUE_TAG = 32,
	HEAD_OF_QUEUE_TAG = 33,
	ORDERED_QUEUE_TAG = 34,
	IGNORE_WIDE_RESIDUE = 35,
	ACA = 36,
	QAS_REQUEST = 85,
	BUS_DEVICE_RESET = 12,
	ABORT = 6,
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char __attribute__((btf_type_tag("user"))) *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense __attribute__((btf_type_tag("user"))) *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void __attribute__((btf_type_tag("user"))) *reserved[1];
		void __attribute__((btf_type_tag("user"))) *unused;
	};
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	unsigned short iovec_count;
	unsigned int dxfer_len;
	void __attribute__((btf_type_tag("user"))) *dxferp;
	unsigned char __attribute__((btf_type_tag("user"))) *cmdp;
	void __attribute__((btf_type_tag("user"))) *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void __attribute__((btf_type_tag("user"))) *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	unsigned short host_status;
	unsigned short driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

struct compat_cdrom_generic_command {
	unsigned char cmd[12];
	compat_caddr_t buffer;
	compat_uint_t buflen;
	compat_int_t stat;
	compat_caddr_t sense;
	unsigned char data_direction;
	unsigned char pad[3];
	compat_int_t quiet;
	compat_int_t timeout;
	compat_caddr_t unused;
};

struct rq_map_data {
	struct page **pages;
	unsigned long offset;
	unsigned short page_order;
	unsigned short nr_entries;
	bool null_mapped;
	bool from_user;
};

struct compat_sg_io_hdr {
	compat_int_t interface_id;
	compat_int_t dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	unsigned short iovec_count;
	compat_uint_t dxfer_len;
	compat_uint_t dxferp;
	compat_uptr_t cmdp;
	compat_uptr_t sbp;
	compat_uint_t timeout;
	compat_uint_t flags;
	compat_int_t pack_id;
	compat_uptr_t usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	unsigned short host_status;
	unsigned short driver_status;
	compat_int_t resid;
	compat_uint_t duration;
	compat_uint_t info;
};

struct ata_internal {
	struct scsi_transport_template t;
	struct device_attribute private_port_attrs[3];
	struct device_attribute private_link_attrs[3];
	struct device_attribute private_dev_attrs[9];
	struct transport_container link_attr_cont;
	struct transport_container dev_attr_cont;
	struct device_attribute *link_attrs[4];
	struct device_attribute *port_attrs[4];
	struct device_attribute *dev_attrs[10];
};

struct ata_show_ering_arg {
	char *buf;
	int written;
};

struct physmap_flash_info {
	unsigned int nmaps;
	struct mtd_info **mtds;
	struct mtd_info *cmtd;
	struct map_info *maps;
	spinlock_t vpp_lock;
	int vpp_refcnt;
	const char *probe_type;
	const char * const *part_types;
	unsigned int nparts;
	const struct mtd_partition *parts;
	struct gpio_descs *gpios;
	unsigned int gpio_values;
	unsigned int win_order;
};

struct physmap_flash_data {
	unsigned int width;
	int (*init)(struct platform_device *);
	void (*exit)(struct platform_device *);
	void (*set_vpp)(struct platform_device *, int);
	unsigned int nr_parts;
	unsigned int pfow_base;
	char *probe_type;
	struct mtd_partition *parts;
	const char * const *part_probe_types;
};

enum phy_state_work {
	PHY_STATE_WORK_NONE = 0,
	PHY_STATE_WORK_ANEG = 1,
	PHY_STATE_WORK_SUSPEND = 2,
};

enum sgmii_speed {
	SGMII_SPEED_10 = 0,
	SGMII_SPEED_100 = 1,
	SGMII_SPEED_1000 = 2,
	SGMII_SPEED_2500 = 2,
};

struct lynx_pcs {
	struct phylink_pcs pcs;
	struct mdio_device *mdio;
};

struct macb_dma_desc_ptp {
	u32 ts_1;
	u32 ts_2;
};

enum hns_desc_type {
	DESC_TYPE_SKB___2 = 0,
	DESC_TYPE_PAGE___2 = 1,
};

enum hns_nic_state {
	NIC_STATE_TESTING = 0,
	NIC_STATE_RESETTING = 1,
	NIC_STATE_REINITING = 2,
	NIC_STATE_DOWN = 3,
	NIC_STATE_DISABLED = 4,
	NIC_STATE_REMOVING = 5,
	NIC_STATE_SERVICE_INITED = 6,
	NIC_STATE_SERVICE_SCHED = 7,
	NIC_STATE2_RESET_REQUESTED = 8,
	NIC_STATE_MAX = 9,
};

struct hns_nic_ring_data {
	struct hnae_ring *ring;
	struct napi_struct napi;
	cpumask_t mask;
	u32 queue_index;
	int (*poll_one)(struct hns_nic_ring_data *, int, void *);
	void (*ex_process)(struct hns_nic_ring_data *, struct sk_buff *);
	bool (*fini_process)(struct hns_nic_ring_data *);
};

struct hns_nic_ops {
	void (*fill_desc)(struct hnae_ring *, void *, int, dma_addr_t, int, int, enum hns_desc_type, int, bool);
	int (*maybe_stop_tx)(struct sk_buff **, int *, struct hnae_ring *);
	void (*get_rxd_bnum)(u32, int *);
};

struct hns_nic_priv {
	const struct fwnode_handle *fwnode;
	u32 enet_ver;
	u32 port_id;
	int phy_mode;
	int phy_led_val;
	struct net_device *netdev;
	struct device *dev;
	struct hnae_handle *ae_handle;
	struct hns_nic_ops ops;
	struct hns_nic_ring_data *ring_data;
	int link;
	u64 tx_timeout_count;
	unsigned long state;
	struct timer_list service_timer;
	struct work_struct service_task;
	struct notifier_block notifier_block;
};

struct dwc3_rtk {
	struct device *dev;
	void *regs;
	size_t regs_size;
	void *pm_base;
	struct dwc3 *dwc;
	enum usb_role cur_role;
	struct usb_role_switch *role_switch;
};

struct ci_hw_req {
	struct usb_request req;
	struct list_head queue;
	struct list_head tds;
};

struct i2c_dev {
	struct list_head list;
	struct i2c_adapter *adap;
	struct device dev;
	struct cdev cdev;
};

struct i2c_rdwr_ioctl_data {
	struct i2c_msg __attribute__((btf_type_tag("user"))) *msgs;
	__u32 nmsgs;
};

struct i2c_smbus_ioctl_data {
	__u8 read_write;
	__u8 command;
	__u32 size;
	union i2c_smbus_data __attribute__((btf_type_tag("user"))) *data;
};

struct i2c_rdwr_ioctl_data32 {
	compat_caddr_t msgs;
	u32 nmsgs;
};

struct i2c_msg32 {
	u16 addr;
	u16 flags;
	u16 len;
	compat_caddr_t buf;
};

struct i2c_smbus_ioctl_data32 {
	u8 read_write;
	u8 command;
	u32 size;
	compat_caddr_t data;
};

enum s3c24xx_i2c_state {
	STATE_IDLE___3 = 0,
	STATE_START___2 = 1,
	STATE_READ___2 = 2,
	STATE_WRITE___2 = 3,
	STATE_STOP___2 = 4,
};

struct s3c2410_platform_i2c;

struct s3c24xx_i2c {
	wait_queue_head_t wait;
	kernel_ulong_t quirks;
	struct i2c_msg *msg;
	unsigned int msg_num;
	unsigned int msg_idx;
	unsigned int msg_ptr;
	unsigned int tx_setup;
	unsigned int irq;
	enum s3c24xx_i2c_state state;
	unsigned long clkrate;
	void *regs;
	struct clk *clk;
	struct device *dev;
	struct i2c_adapter adap;
	struct s3c2410_platform_i2c *pdata;
	struct gpio_desc *gpios[2];
	struct pinctrl *pctrl;
	struct regmap *sysreg;
	unsigned int sys_i2c_cfg;
};

struct s3c2410_platform_i2c {
	int bus_num;
	unsigned int flags;
	unsigned int slave_addr;
	unsigned long frequency;
	unsigned int sda_delay;
	void (*cfg_gpio)(struct platform_device *);
};

struct syscon_reboot_context {
	struct regmap *map;
	u32 offset;
	u32 value;
	u32 mask;
	struct notifier_block restart_handler;
};

struct cpufreq_cooling_device {
	u32 last_load;
	unsigned int cpufreq_state;
	unsigned int max_level;
	struct em_perf_domain *em;
	struct cpufreq_policy *policy;
	struct thermal_cooling_device_ops cooling_ops;
	struct freq_qos_request qos_req;
};

struct s3c2410_wdt_variant {
	int disable_reg;
	int mask_reset_reg;
	bool mask_reset_inv;
	int mask_bit;
	int rst_stat_reg;
	int rst_stat_bit;
	int cnt_en_reg;
	int cnt_en_bit;
	u32 quirks;
};

struct s3c2410_wdt {
	struct device *dev;
	struct clk *bus_clk;
	struct clk *src_clk;
	void *reg_base;
	unsigned int count;
	spinlock_t lock;
	unsigned long wtcon_save;
	unsigned long wtdat_save;
	struct watchdog_device wdt_device;
	struct notifier_block freq_transition;
	const struct s3c2410_wdt_variant *drv_data;
	struct regmap *pmureg;
};

struct ghes_hw_desc {
	int num_dimms;
	struct dimm_info *dimms;
};

struct ghes_pvt {
	struct mem_ctl_info *mci;
	char other_detail[400];
	char msg[80];
};

enum dmi_entry_type {
	DMI_ENTRY_BIOS = 0,
	DMI_ENTRY_SYSTEM = 1,
	DMI_ENTRY_BASEBOARD = 2,
	DMI_ENTRY_CHASSIS = 3,
	DMI_ENTRY_PROCESSOR = 4,
	DMI_ENTRY_MEM_CONTROLLER = 5,
	DMI_ENTRY_MEM_MODULE = 6,
	DMI_ENTRY_CACHE = 7,
	DMI_ENTRY_PORT_CONNECTOR = 8,
	DMI_ENTRY_SYSTEM_SLOT = 9,
	DMI_ENTRY_ONBOARD_DEVICE = 10,
	DMI_ENTRY_OEMSTRINGS = 11,
	DMI_ENTRY_SYSCONF = 12,
	DMI_ENTRY_BIOS_LANG = 13,
	DMI_ENTRY_GROUP_ASSOC = 14,
	DMI_ENTRY_SYSTEM_EVENT_LOG = 15,
	DMI_ENTRY_PHYS_MEM_ARRAY = 16,
	DMI_ENTRY_MEM_DEVICE = 17,
	DMI_ENTRY_32_MEM_ERROR = 18,
	DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR = 19,
	DMI_ENTRY_MEM_DEV_MAPPED_ADDR = 20,
	DMI_ENTRY_BUILTIN_POINTING_DEV = 21,
	DMI_ENTRY_PORTABLE_BATTERY = 22,
	DMI_ENTRY_SYSTEM_RESET = 23,
	DMI_ENTRY_HW_SECURITY = 24,
	DMI_ENTRY_SYSTEM_POWER_CONTROLS = 25,
	DMI_ENTRY_VOLTAGE_PROBE = 26,
	DMI_ENTRY_COOLING_DEV = 27,
	DMI_ENTRY_TEMP_PROBE = 28,
	DMI_ENTRY_ELECTRICAL_CURRENT_PROBE = 29,
	DMI_ENTRY_OOB_REMOTE_ACCESS = 30,
	DMI_ENTRY_BIS_ENTRY = 31,
	DMI_ENTRY_SYSTEM_BOOT = 32,
	DMI_ENTRY_MGMT_DEV = 33,
	DMI_ENTRY_MGMT_DEV_COMPONENT = 34,
	DMI_ENTRY_MGMT_DEV_THRES = 35,
	DMI_ENTRY_MEM_CHANNEL = 36,
	DMI_ENTRY_IPMI_DEV = 37,
	DMI_ENTRY_SYS_POWER_SUPPLY = 38,
	DMI_ENTRY_ADDITIONAL = 39,
	DMI_ENTRY_ONBOARD_DEV_EXT = 40,
	DMI_ENTRY_MGMT_CONTROLLER_HOST = 41,
	DMI_ENTRY_INACTIVE = 126,
	DMI_ENTRY_END_OF_TABLE = 127,
};

struct memdev_dmi_entry {
	u8 type;
	u8 length;
	u16 handle;
	u16 phys_mem_array_handle;
	u16 mem_err_info_handle;
	u16 total_width;
	u16 data_width;
	u16 size;
	u8 form_factor;
	u8 device_set;
	u8 device_locator;
	u8 bank_locator;
	u8 memory_type;
	u16 type_detail;
	u16 speed;
	u8 manufacturer;
	u8 serial_number;
	u8 asset_tag;
	u8 part_number;
	u8 attributes;
	u32 extended_size;
	u16 conf_mem_clk_speed;
} __attribute__((packed));

struct scpi_data {
	struct clk *clk;
	struct device *cpu_dev;
};

enum dwcmshc_rk_type {
	DWCMSHC_RK3568 = 0,
	DWCMSHC_RK3588 = 1,
};

struct dwcmshc_priv {
	struct clk *bus_clk;
	int vendor_specific_area1;
	void *priv;
};

struct rk35xx_priv {
	struct clk_bulk_data rockchip_clks[3];
	struct reset_control *reset;
	enum dwcmshc_rk_type devtype;
	u8 txclk_tapnum;
};

struct led_pwm_data {
	struct led_classdev cdev;
	struct pwm_device *pwm;
	struct pwm_state pwmstate;
	unsigned int active_low;
};

struct led_pwm_priv {
	int num_leds;
	struct led_pwm_data leds[0];
};

struct led_pwm {
	const char *name;
	u8 active_low;
	u8 default_state;
	unsigned int max_brightness;
};

struct meson_sm_cmd {
	unsigned int index;
	u32 smc_id;
};

struct meson_sm_chip {
	unsigned int shmem_size;
	u32 cmd_shmem_in_base;
	u32 cmd_shmem_out_base;
	struct meson_sm_cmd cmd[0];
};

struct meson_sm_firmware {
	const struct meson_sm_chip *chip;
	void *sm_shmem_in_base;
	void *sm_shmem_out_base;
};

enum tegra_ivc_state {
	TEGRA_IVC_STATE_ESTABLISHED = 0,
	TEGRA_IVC_STATE_SYNC = 1,
	TEGRA_IVC_STATE_ACK = 2,
};

struct tegra_ivc_header {
	union {
		struct {
			u32 count;
			u32 state;
		};
		u8 pad[64];
	} tx;
	union {
		u32 count;
		u8 pad[64];
	} rx;
};

struct hid_bpf_prog_entry {
	struct bpf_prog *prog;
	struct hid_device *hdev;
	enum hid_bpf_prog_type type;
	u16 idx;
};

struct hid_bpf_jmp_table {
	struct bpf_map *map;
	struct hid_bpf_prog_entry entries[1024];
	int tail;
	int head;
	struct bpf_prog *progs[1024];
	unsigned long enabled[16];
};

struct bpf_map_desc {
	int map_fd;
	__u32 max_entries;
	__u64 initial_value;
};

struct bpf_prog_desc {
	int prog_fd;
};

struct bpf_loader_ctx {
	__u32 sz;
	__u32 flags;
	__u32 log_level;
	__u32 log_size;
	__u64 log_buf;
};

struct entrypoints_bpf {
	struct bpf_loader_ctx ctx;
	struct {
		struct bpf_map_desc hid_jmp_table;
	} maps;
	struct {
		struct bpf_prog_desc hid_tail_call;
	} progs;
	struct {
		int hid_tail_call_fd;
	} links;
};

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
};

enum {
	BPF_SKEL_KERNEL = 1,
};

struct hid_bpf_link {
	struct bpf_link link;
	int hid_table_index;
};

struct bpf_load_and_run_opts {
	struct bpf_loader_ctx *ctx;
	const void *data;
	const void *insns;
	__u32 data_sz;
	__u32 insns_sz;
	const char *errstr;
};

enum ec_feature_code {
	EC_FEATURE_LIMITED = 0,
	EC_FEATURE_FLASH = 1,
	EC_FEATURE_PWM_FAN = 2,
	EC_FEATURE_PWM_KEYB = 3,
	EC_FEATURE_LIGHTBAR = 4,
	EC_FEATURE_LED = 5,
	EC_FEATURE_MOTION_SENSE = 6,
	EC_FEATURE_KEYB = 7,
	EC_FEATURE_PSTORE = 8,
	EC_FEATURE_PORT80 = 9,
	EC_FEATURE_THERMAL = 10,
	EC_FEATURE_BKLIGHT_SWITCH = 11,
	EC_FEATURE_WIFI_SWITCH = 12,
	EC_FEATURE_HOST_EVENTS = 13,
	EC_FEATURE_GPIO = 14,
	EC_FEATURE_I2C = 15,
	EC_FEATURE_CHARGER = 16,
	EC_FEATURE_BATTERY = 17,
	EC_FEATURE_SMART_BATTERY = 18,
	EC_FEATURE_HANG_DETECT = 19,
	EC_FEATURE_PMU = 20,
	EC_FEATURE_SUB_MCU = 21,
	EC_FEATURE_USB_PD = 22,
	EC_FEATURE_USB_MUX = 23,
	EC_FEATURE_MOTION_SENSE_FIFO = 24,
	EC_FEATURE_VSTORE = 25,
	EC_FEATURE_USBC_SS_MUX_VIRTUAL = 26,
	EC_FEATURE_RTC = 27,
	EC_FEATURE_FINGERPRINT = 28,
	EC_FEATURE_TOUCHPAD = 29,
	EC_FEATURE_RWSIG = 30,
	EC_FEATURE_DEVICE_EVENT = 31,
	EC_FEATURE_UNIFIED_WAKE_MASKS = 32,
	EC_FEATURE_HOST_EVENT64 = 33,
	EC_FEATURE_EXEC_IN_RAM = 34,
	EC_FEATURE_CEC = 35,
	EC_FEATURE_MOTION_SENSE_TIGHT_TIMESTAMPS = 36,
	EC_FEATURE_REFINED_TABLET_MODE_HYSTERESIS = 37,
	EC_FEATURE_SCP = 39,
	EC_FEATURE_ISH = 40,
	EC_FEATURE_TYPEC_CMD = 41,
	EC_FEATURE_TYPEC_REQUIRE_AP_MODE_ENTRY = 42,
	EC_FEATURE_TYPEC_MUX_REQUIRE_AP_ACK = 43,
	EC_FEATURE_S4_RESIDENCY = 44,
	EC_FEATURE_TYPEC_AP_MUX_SET = 45,
	EC_FEATURE_TYPEC_AP_VDM_SEND = 46,
};

enum motionsensor_type {
	MOTIONSENSE_TYPE_ACCEL = 0,
	MOTIONSENSE_TYPE_GYRO = 1,
	MOTIONSENSE_TYPE_MAG = 2,
	MOTIONSENSE_TYPE_PROX = 3,
	MOTIONSENSE_TYPE_LIGHT = 4,
	MOTIONSENSE_TYPE_ACTIVITY = 5,
	MOTIONSENSE_TYPE_BARO = 6,
	MOTIONSENSE_TYPE_SYNC = 7,
	MOTIONSENSE_TYPE_MAX = 8,
};

struct cros_ec_sensors_ec_overflow_state {
	s64 offset;
	s64 last;
};

struct cros_ec_sensors_ts_filter_state {
	s64 x_offset;
	s64 y_offset;
	s64 x_history[64];
	s64 y_history[64];
	s64 m_history[64];
	int history_len;
	s64 temp_buf[64];
	s64 median_m;
	s64 median_error;
};

struct cros_ec_sensors_ring_sample;

struct cros_ec_sensors_ts_batch_state;

struct cros_ec_sensorhub_sensor_push_data;

struct cros_ec_sensorhub {
	struct device *dev;
	struct cros_ec_dev *ec;
	int sensor_num;
	struct cros_ec_command *msg;
	struct ec_params_motion_sense *params;
	struct ec_response_motion_sense *resp;
	struct mutex cmd_lock;
	struct notifier_block notifier;
	struct cros_ec_sensors_ring_sample *ring;
	ktime_t fifo_timestamp[2];
	struct ec_response_motion_sense_fifo_info *fifo_info;
	int fifo_size;
	struct cros_ec_sensors_ts_batch_state *batch_state;
	struct cros_ec_sensors_ec_overflow_state overflow_a;
	struct cros_ec_sensors_ec_overflow_state overflow_b;
	struct cros_ec_sensors_ts_filter_state filter;
	int tight_timestamps;
	s32 future_timestamp_count;
	s64 future_timestamp_total_ns;
	struct cros_ec_sensorhub_sensor_push_data *push_data;
};

struct cros_ec_sensors_ring_sample {
	u8 sensor_id;
	u8 flag;
	s16 vector[3];
	s64 timestamp;
};

struct cros_ec_sensors_ts_batch_state {
	s64 penul_ts;
	int penul_len;
	s64 last_ts;
	int last_len;
	s64 newest_sensor_event;
};

typedef int (*cros_ec_sensorhub_push_data_cb_t)(struct iio_dev *, s16 *, s64);

struct cros_ec_sensorhub_sensor_push_data {
	struct iio_dev *indio_dev;
	cros_ec_sensorhub_push_data_cb_t push_data_cb;
};

struct cros_ec_sensor_platform {
	u8 sensor_num;
};

struct hi6220_mbox_chan;

struct hi6220_mbox {
	struct device *dev;
	int irq;
	bool tx_irq_mode;
	void *ipc;
	void *base;
	unsigned int chan_num;
	struct hi6220_mbox_chan *mchan;
	void *irq_map_chan[32];
	struct mbox_chan *chan;
	struct mbox_controller controller;
};

struct hi6220_mbox_chan {
	unsigned int dir;
	unsigned int dst_irq;
	unsigned int ack_irq;
	unsigned int slot;
	struct hi6220_mbox *parent;
};

struct iio_demux_table {
	unsigned int from;
	unsigned int to;
	unsigned int length;
	struct list_head l;
};

struct iio_device_config {
	unsigned int mode;
	unsigned int watermark;
	const unsigned long *scan_mask;
	unsigned int scan_bytes;
	bool scan_timestamp;
};

struct ocotp_region {
	u32 start;
	u32 end;
	u32 flag;
};

struct ocotp_devtype_data {
	int devtype;
	int nregs;
	u32 num_region;
	struct ocotp_region region[0];
};

struct ocotp_priv {
	struct device *dev;
	const struct ocotp_devtype_data *data;
	struct imx_sc_ipc *nvmem_ipc;
};

struct imx_sc_msg_misc_fuse_read {
	struct imx_sc_rpc_msg hdr;
	u32 word;
};

struct bcm_voter {
	struct device *dev;
	struct device_node *np;
	struct mutex lock;
	struct list_head commit_list;
	struct list_head ws_list;
	struct list_head voter_node;
	u32 tcs_wait;
};

struct soc_mreg_control {
	long min;
	long max;
	unsigned int regbase;
	unsigned int regcount;
	unsigned int nbits;
	unsigned int invert;
};

struct soc_bytes {
	int base;
	int num_regs;
	u32 mask;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct nf_ct_event {
	struct nf_conn *ct;
	u32 portid;
	int report;
};

struct nf_ct_ext {
	u8 offset[5];
	u8 len;
	unsigned int gen_id;
	long: 0;
	char data[0];
};

struct nf_conntrack_expect;

struct nf_exp_event {
	struct nf_conntrack_expect *exp;
	u32 portid;
	int report;
};

struct nf_conntrack_tuple_mask {
	struct {
		union nf_inet_addr u3;
		union nf_conntrack_man_proto u;
	} src;
};

struct nf_conntrack_helper;

enum ip_conntrack_dir {
	IP_CT_DIR_ORIGINAL = 0,
	IP_CT_DIR_REPLY = 1,
	IP_CT_DIR_MAX = 2,
};

struct nf_conntrack_expect {
	struct hlist_node lnode;
	struct hlist_node hnode;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_tuple_mask mask;
	refcount_t use;
	unsigned int flags;
	unsigned int class;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
	struct nf_conntrack_helper *helper;
	struct nf_conn *master;
	struct timer_list timeout;
	union nf_inet_addr saved_addr;
	union nf_conntrack_man_proto saved_proto;
	enum ip_conntrack_dir dir;
	struct callback_head rcu;
};

enum {
	TCA_FLOWER_KEY_CT_FLAGS_NEW = 1,
	TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 2,
	TCA_FLOWER_KEY_CT_FLAGS_RELATED = 4,
	TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 8,
	TCA_FLOWER_KEY_CT_FLAGS_INVALID = 16,
	TCA_FLOWER_KEY_CT_FLAGS_REPLY = 32,
	__TCA_FLOWER_KEY_CT_FLAGS_MAX = 33,
};

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_MCAST = 5,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

struct mpls_label {
	__be32 entry;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct flow_dissector_key_cfm {
	u8 mdl_ver;
	u8 opcode;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct ip_esp_hdr {
	__be32 spi;
	__be32 seq_no;
	__u8 enc_data[0];
};

struct flow_dissector_key_ipsec {
	__be32 spi;
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct flow_dissector_key_l2tpv3 {
	__be32 session_id;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
	u8 l2_miss;
};

struct nf_conn_labels {
	unsigned long bits[2];
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	__be16 dst_opt_type;
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct hsr_tag {
	__be16 path_and_LSDU_size;
	__be16 sequence_nr;
	__be16 encap_proto;
};

struct flow_dissector_key_num_of_vlans {
	u8 num_of_vlans;
};

struct flow_dissector_key_pppoe {
	__be16 session_id;
	__be16 ppp_proto;
	__be16 type;
};

struct flow_keys_digest {
	u8 data[16];
};

typedef void (*btf_trace_netlink_extack)(void *, const char *);

struct listeners;

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners __attribute__((btf_type_tag("rcu"))) *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	void (*release)(struct sock *, unsigned long *);
	int registered;
};

struct listeners {
	struct callback_head rcu;
	unsigned long masks[0];
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

enum {
	NETLINK_F_KERNEL_SOCKET = 0,
	NETLINK_F_RECV_PKTINFO = 1,
	NETLINK_F_BROADCAST_SEND_ERROR = 2,
	NETLINK_F_RECV_NO_ENOBUFS = 3,
	NETLINK_F_LISTEN_ALL_NSID = 4,
	NETLINK_F_CAP_ACK = 5,
	NETLINK_F_EXT_ACK = 6,
	NETLINK_F_STRICT_CHK = 7,
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	NLMSGERR_ATTR_MISS_TYPE = 5,
	NLMSGERR_ATTR_MISS_NEST = 6,
	__NLMSGERR_ATTR_MAX = 7,
	NLMSGERR_ATTR_MAX = 6,
};

struct trace_event_raw_netlink_extack {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct netlink_sock {
	struct sock sk;
	unsigned long flags;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 subscriptions;
	u32 ngroups;
	unsigned long *groups;
	unsigned long state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex *cb_mutex;
	struct mutex cb_def_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	void (*netlink_release)(struct sock *, unsigned long *);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
	struct work_struct work;
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	unsigned short nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct trace_event_data_offsets_netlink_extack {
	u32 msg;
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct nl_pktinfo {
	__u32 group;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	ETHTOOL_A_PAUSE_STATS_SRC = 6,
	__ETHTOOL_A_PAUSE_CNT = 7,
	ETHTOOL_A_PAUSE_MAX = 6,
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

struct pause_req_info {
	struct ethnl_req_info base;
	enum ethtool_mac_stats_src src;
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	struct ethtool_pause_stats pausestat;
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

enum {
	IFLA_IPTUN_UNSPEC = 0,
	IFLA_IPTUN_LINK = 1,
	IFLA_IPTUN_LOCAL = 2,
	IFLA_IPTUN_REMOTE = 3,
	IFLA_IPTUN_TTL = 4,
	IFLA_IPTUN_TOS = 5,
	IFLA_IPTUN_ENCAP_LIMIT = 6,
	IFLA_IPTUN_FLOWINFO = 7,
	IFLA_IPTUN_FLAGS = 8,
	IFLA_IPTUN_PROTO = 9,
	IFLA_IPTUN_PMTUDISC = 10,
	IFLA_IPTUN_6RD_PREFIX = 11,
	IFLA_IPTUN_6RD_RELAY_PREFIX = 12,
	IFLA_IPTUN_6RD_PREFIXLEN = 13,
	IFLA_IPTUN_6RD_RELAY_PREFIXLEN = 14,
	IFLA_IPTUN_ENCAP_TYPE = 15,
	IFLA_IPTUN_ENCAP_FLAGS = 16,
	IFLA_IPTUN_ENCAP_SPORT = 17,
	IFLA_IPTUN_ENCAP_DPORT = 18,
	IFLA_IPTUN_COLLECT_METADATA = 19,
	IFLA_IPTUN_FWMARK = 20,
	__IFLA_IPTUN_MAX = 21,
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct vxlan_metadata {
	u32 gbp;
};

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_nh_release_dsts)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)();
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	struct net_device * (*ipv6_dev_find)(struct net *, const struct in6_addr *, struct net_device *);
};

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

struct sys_reg_desc___2 {
	const char *name;
	enum {
		AA32_DIRECT___2 = 0,
		AA32_LO___2 = 1,
		AA32_HI___2 = 2,
	} aarch32_map;
	u8 Op0;
	u8 Op1;
	u8 CRn;
	u8 CRm;
	u8 Op2;
	bool (*access)(struct kvm_vcpu___2 *, struct sys_reg_params *, const struct sys_reg_desc___2 *);
	u64 (*reset)(struct kvm_vcpu___2 *, const struct sys_reg_desc___2 *);
	int reg;
	u64 val;
	int (*__get_user)(struct kvm_vcpu___2 *, const struct sys_reg_desc___2 *, u64 *);
	int (*set_user)(struct kvm_vcpu___2 *, const struct sys_reg_desc___2 *, u64);
	unsigned int (*visibility)(const struct kvm_vcpu___2 *, const struct sys_reg_desc___2 *);
};

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
};

struct io_tlb_area {
	unsigned long used;
	unsigned int index;
	spinlock_t lock;
};

struct io_tlb_slot {
	phys_addr_t orig_addr;
	size_t alloc_size;
	unsigned int list;
};

typedef void (*btf_trace_swiotlb_bounced)(void *, struct device *, dma_addr_t, size_t);

struct trace_event_raw_swiotlb_bounced {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u64 dma_mask;
	dma_addr_t dev_addr;
	size_t size;
	bool force;
	char __data[0];
};

struct trace_event_data_offsets_swiotlb_bounced {
	u32 dev_name;
};

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	unsigned long value;
	unsigned int nameoff;
	char type;
	char name[512];
	char module_name[56];
	int exported;
	int show_value;
};

struct bpf_iter__ksym {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct kallsym_iter *ksym;
	};
};

struct eprobe_trace_entry_head {
	struct trace_entry ent;
};

struct trace_eprobe {
	const char *event_system;
	const char *event_name;
	char *filter_str;
	struct trace_event_call *event;
	struct dyn_event devent;
	struct trace_probe tp;
};

struct eprobe_data {
	struct trace_event_file *file;
	struct trace_eprobe *ep;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

enum vmpressure_levels {
	VMPRESSURE_LOW = 0,
	VMPRESSURE_MEDIUM = 1,
	VMPRESSURE_CRITICAL = 2,
	VMPRESSURE_NUM_LEVELS = 3,
};

enum vmpressure_modes {
	VMPRESSURE_NO_PASSTHROUGH = 0,
	VMPRESSURE_HIERARCHY = 1,
	VMPRESSURE_LOCAL = 2,
	VMPRESSURE_NUM_MODES = 3,
};

struct vmpressure_event {
	struct eventfd_ctx *efd;
	enum vmpressure_levels level;
	enum vmpressure_modes mode;
	struct list_head node;
};

enum {
	XA_CHECK_SCHED = 4096,
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	u64 ticks;
	int clockid;
	unsigned short expired;
	unsigned short settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

typedef __kernel_uid32_t qid_t;

enum {
	BIAS = 2147483648,
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

enum {
	Opt_bsd_df___2 = 0,
	Opt_minix_df___2 = 1,
	Opt_grpid___2 = 2,
	Opt_nogrpid___2 = 3,
	Opt_resgid___2 = 4,
	Opt_resuid___2 = 5,
	Opt_sb___2 = 6,
	Opt_err_cont___2 = 7,
	Opt_err_panic___2 = 8,
	Opt_err_ro___2 = 9,
	Opt_nouid32___2 = 10,
	Opt_debug___4 = 11,
	Opt_oldalloc = 12,
	Opt_orlov = 13,
	Opt_nobh = 14,
	Opt_user_xattr___2 = 15,
	Opt_nouser_xattr = 16,
	Opt_acl___3 = 17,
	Opt_noacl = 18,
	Opt_xip = 19,
	Opt_dax___2 = 20,
	Opt_ignore___2 = 21,
	Opt_err___7 = 22,
	Opt_quota___2 = 23,
	Opt_usrquota___2 = 24,
	Opt_grpquota___2 = 25,
	Opt_reservation = 26,
	Opt_noreservation = 27,
};

struct ext2_mount_options {
	unsigned long s_mount_opt;
	kuid_t s_resuid;
	kgid_t s_resgid;
};

struct fat_cache {
	struct list_head cache_list;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_cache_id {
	unsigned int id;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct nfs_callback_data {
	unsigned int users;
	struct svc_serv *serv;
};

enum nfs4_callback_procnum {
	CB_NULL = 0,
	CB_COMPOUND = 1,
};

struct crypto_istat_aead {
	atomic64_t encrypt_cnt;
	atomic64_t encrypt_tlen;
	atomic64_t decrypt_cnt;
	atomic64_t decrypt_tlen;
	atomic64_t err_cnt;
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

struct crypto_report_aead {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

typedef unsigned char u8___2;

struct rand_data {
	void *hash_state;
	__u64 prev_time;
	__u64 last_delta;
	__s64 last_delta2;
	unsigned int flags;
	unsigned int osr;
	unsigned char *mem;
	unsigned int memlocation;
	unsigned int memblocks;
	unsigned int memblocksize;
	unsigned int memaccessloops;
	unsigned int rct_count;
	unsigned int apt_cutoff;
	unsigned int apt_cutoff_permanent;
	unsigned int apt_observations;
	unsigned int apt_count;
	unsigned int apt_base;
	unsigned int health_failure;
	unsigned int apt_base_set: 1;
};

enum bfqq_state_flags {
	BFQQF_just_created = 0,
	BFQQF_busy = 1,
	BFQQF_wait_request = 2,
	BFQQF_non_blocking_wait_rq = 3,
	BFQQF_fifo_expire = 4,
	BFQQF_has_short_ttime = 5,
	BFQQF_sync = 6,
	BFQQF_IO_bound = 7,
	BFQQF_in_large_burst = 8,
	BFQQF_softrt_update = 9,
	BFQQF_coop = 10,
	BFQQF_split_coop = 11,
};

struct io_futex {
	struct file *file;
	union {
		u32 __attribute__((btf_type_tag("user"))) *uaddr;
		struct futex_waitv __attribute__((btf_type_tag("user"))) *uwaitv;
	};
	unsigned long futex_val;
	unsigned long futex_mask;
	unsigned long futexv_owned;
	u32 futex_flags;
	unsigned int futex_nr;
	bool futexv_unqueued;
};

struct io_futex_data {
	union {
		struct futex_q q;
		struct io_cache_entry cache;
	};
	struct io_kiocb *req;
};

struct redist_region;

struct gic_chip_data {
	struct fwnode_handle *fwnode;
	phys_addr_t dist_phys_base;
	void *dist_base;
	struct redist_region *redist_regions;
	struct rdists rdists;
	struct irq_domain *domain;
	u64 redist_stride;
	u32 nr_redist_regions;
	u64 flags;
	bool has_rss;
	unsigned int ppi_nr;
	struct partition_desc **ppi_descs;
};

struct redist_region {
	void *redist_base;
	phys_addr_t phys_base;
	bool single_redist;
};

enum gic_intid_range {
	SGI_RANGE = 0,
	PPI_RANGE = 1,
	SPI_RANGE = 2,
	EPPI_RANGE = 3,
	ESPI_RANGE = 4,
	LPI_RANGE = 5,
	__INVALID_RANGE__ = 6,
};

struct acpi_madt_generic_distributor {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 gic_id;
	u64 base_address;
	u32 global_irq_base;
	u8 version;
	u8 reserved2[3];
};

struct acpi_madt_generic_redistributor {
	struct acpi_subtable_header header;
	u16 reserved;
	u64 base_address;
	u32 length;
} __attribute__((packed));

struct vexpress_config_bridge_ops {
	struct regmap * (*regmap_init)(struct device *, void *);
	void (*regmap_exit)(struct regmap *, void *);
};

struct vexpress_syscfg;

struct vexpress_syscfg_func {
	struct list_head list;
	struct vexpress_syscfg *syscfg;
	struct regmap *regmap;
	int num_templates;
	u32 template[0];
};

struct vexpress_syscfg {
	struct device *dev;
	void *base;
	struct list_head funcs;
};

struct vexpress_config_bridge {
	struct vexpress_config_bridge_ops *ops;
	void *context;
};

struct hisi_inno_phy_priv;

struct hisi_inno_phy_port {
	struct reset_control *utmi_rst;
	struct hisi_inno_phy_priv *priv;
};

struct hisi_inno_phy_priv {
	void *mmio;
	struct clk *ref_clk;
	struct reset_control *por_rst;
	unsigned int type;
	struct hisi_inno_phy_port ports[2];
};

struct tegra_xusb_fuse_calibration {
	u32 *hs_curr_level;
	u32 hs_squelch;
	u32 hs_term_range_adj;
	u32 rpd_ctrl;
};

struct tegra186_xusb_padctl_context {
	u32 vbus_id;
	u32 usb2_pad_mux;
	u32 usb2_port_cap;
	u32 ss_port_cap;
};

struct tegra186_xusb_padctl {
	struct tegra_xusb_padctl base;
	void *ao_regs;
	struct tegra_xusb_fuse_calibration calib;
	struct clk *usb2_trk_clk;
	unsigned int bias_pad_enable;
	struct tegra186_xusb_padctl_context context;
};

struct tegra_xusb_usb3_lane {
	struct tegra_xusb_lane base;
};

struct tegra_xusb_usb3_pad {
	struct tegra_xusb_pad base;
	unsigned int enable;
	struct mutex lock;
};

struct mvebu_pinctrl_group {
	const char *name;
	const struct mvebu_mpp_ctrl *ctrl;
	struct mvebu_mpp_ctrl_data *data;
	struct mvebu_mpp_ctrl_setting *settings;
	unsigned int num_settings;
	unsigned int gid;
	unsigned int *pins;
	unsigned int npins;
};

struct mvebu_pinctrl_function;

struct mvebu_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctldev;
	struct pinctrl_desc desc;
	struct mvebu_pinctrl_group *groups;
	unsigned int num_groups;
	struct mvebu_pinctrl_function *functions;
	unsigned int num_functions;
	u8 variant;
};

struct mvebu_pinctrl_function {
	const char *name;
	const char **groups;
	unsigned int num_groups;
};

struct scu_gpio_priv {
	struct gpio_chip chip;
	struct mutex lock;
	struct device *dev;
	struct imx_sc_ipc *handle;
};

struct rockchip_pwm_regs {
	unsigned long duty;
	unsigned long period;
	unsigned long cntr;
	unsigned long ctrl;
};

struct rockchip_pwm_data {
	struct rockchip_pwm_regs regs;
	unsigned int prescaler;
	bool supports_polarity;
	bool supports_lock;
	u32 enable_conf;
};

struct rockchip_pwm_chip {
	struct pwm_chip chip;
	struct clk *clk;
	struct clk *pclk;
	const struct rockchip_pwm_data *data;
	void *base;
};

enum dw_pcie_app_clk {
	DW_PCIE_DBI_CLK = 0,
	DW_PCIE_MSTR_CLK = 1,
	DW_PCIE_SLV_CLK = 2,
	DW_PCIE_NUM_APP_CLKS = 3,
};

enum dw_pcie_core_clk {
	DW_PCIE_PIPE_CLK = 0,
	DW_PCIE_CORE_CLK = 1,
	DW_PCIE_AUX_CLK = 2,
	DW_PCIE_REF_CLK = 3,
	DW_PCIE_NUM_CORE_CLKS = 4,
};

enum dw_pcie_app_rst {
	DW_PCIE_DBI_RST = 0,
	DW_PCIE_MSTR_RST = 1,
	DW_PCIE_SLV_RST = 2,
	DW_PCIE_NUM_APP_RSTS = 3,
};

enum dw_pcie_core_rst {
	DW_PCIE_NON_STICKY_RST = 0,
	DW_PCIE_STICKY_RST = 1,
	DW_PCIE_CORE_RST = 2,
	DW_PCIE_PIPE_RST = 3,
	DW_PCIE_PHY_RST = 4,
	DW_PCIE_HOT_RST = 5,
	DW_PCIE_PWR_RST = 6,
	DW_PCIE_NUM_CORE_RSTS = 7,
};

enum dw_edma_chip_flags {
	DW_EDMA_CHIP_LOCAL = 1,
};

struct dmt_videomode {
	u32 dmt_id;
	u32 std_2byte_code;
	u32 cvt_3byte_code;
	const struct fb_videomode *mode;
};

struct logo_data {
	int depth;
	int needs_directpalette;
	int needs_truepalette;
	int needs_cmapreset;
	const struct linux_logo *logo;
};

struct acpi_handle_list {
	u32 count;
	acpi_handle *handles;
};

struct acpi_thermal_trip {
	unsigned long temp_dk;
	struct acpi_handle_list devices;
};

struct acpi_thermal_passive {
	struct acpi_thermal_trip trip;
	unsigned long tc1;
	unsigned long tc2;
	unsigned long tsp;
};

struct acpi_thermal_active {
	struct acpi_thermal_trip trip;
};

struct acpi_thermal_trips {
	struct acpi_thermal_passive passive;
	struct acpi_thermal_active active[10];
};

struct acpi_thermal {
	struct acpi_device *device;
	acpi_bus_id name;
	unsigned long temp_dk;
	unsigned long last_temp_dk;
	unsigned long polling_frequency;
	volatile u8 zombie;
	struct acpi_thermal_trips trips;
	struct thermal_trip *trip_table;
	struct thermal_zone_device *thermal_zone;
	int kelvin_offset;
	struct work_struct thermal_check_work;
	struct mutex thermal_check_lock;
	refcount_t thermal_check_count;
};

struct adjust_trip_data {
	struct acpi_thermal *tz;
	u32 event;
};

struct acpi_thermal_bind_data {
	struct thermal_zone_device *thermal;
	struct thermal_cooling_device *cdev;
	bool bind;
};

enum iproc_arm_pll_fid {
	ARM_PLL_FID_CRYSTAL_CLK = 0,
	ARM_PLL_FID_SYS_CLK = 2,
	ARM_PLL_FID_CH0_SLOW_CLK = 6,
	ARM_PLL_FID_CH1_FAST_CLK = 7,
};

struct iproc_arm_pll {
	struct clk_hw hw;
	void *base;
	unsigned long rate;
};

struct clk_imx8_acm_sel;

struct imx8_acm_soc_data {
	struct clk_imx8_acm_sel *sels;
	unsigned int num_sels;
};

struct clk_imx8_acm_sel {
	const char *name;
	int clkid;
	const struct clk_parent_data *parents;
	int num_parents;
	u32 reg;
	u8 shift;
	u8 width;
};

struct clk_imx_acm_pm_domains {
	struct device **pd_dev;
	struct device_link **pd_dev_link;
	int num_domains;
};

struct imx8_acm_priv {
	struct clk_imx_acm_pm_domains dev_pm;
	const struct imx8_acm_soc_data *soc_data;
	void *reg;
	u32 regs[25];
};

struct rockchip_ddrclk {
	struct clk_hw hw;
	void *reg_base;
	int mux_offset;
	int mux_shift;
	int mux_width;
	int div_shift;
	int div_width;
	int ddr_flag;
	spinlock_t *lock;
};

struct qm_portal_config {
	void *addr_virt_ce;
	void *addr_virt_ci;
	struct device *dev;
	struct iommu_domain *iommu_domain;
	struct list_head list;
	int cpu;
	int irq;
	u16 channel;
	u32 pools;
};

struct __qm_mcr_querycongestion {
	u32 state[8];
};

struct qman_cgrs {
	struct __qm_mcr_querycongestion q;
};

struct imx_sc_pd_range;

struct imx_sc_pd_soc {
	const struct imx_sc_pd_range *pd_ranges;
	u8 num_ranges;
};

struct imx_sc_pd_range {
	char *name;
	u32 rsrc;
	u8 num;
	bool postfix;
	u8 start_from;
};

struct imx_sc_pm_domain {
	struct generic_pm_domain pd;
	char name[20];
	u32 rsrc;
};

struct req_get_resource_mode {
	u16 resource;
};

struct resp_get_resource_mode {
	u8 mode;
};

struct imx_sc_msg_req_get_resource_power_mode {
	struct imx_sc_rpc_msg hdr;
	union {
		struct req_get_resource_mode req;
		struct resp_get_resource_mode resp;
	} data;
	long: 0;
};

struct imx_sc_msg_req_set_resource_power_mode {
	struct imx_sc_rpc_msg hdr;
	u16 resource;
	u8 mode;
};

struct vring_desc;

typedef struct vring_desc vring_desc_t;

struct vring_avail;

typedef struct vring_avail vring_avail_t;

struct vring_used;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_desc_state_split;

struct vring_desc_extra;

struct vring_virtqueue_split {
	struct vring vring;
	u16 avail_flags_shadow;
	u16 avail_idx_shadow;
	struct vring_desc_state_split *desc_state;
	struct vring_desc_extra *desc_extra;
	dma_addr_t queue_dma_addr;
	size_t queue_size_in_bytes;
	u32 vring_align;
	bool may_reduce_num;
};

struct vring_packed_desc;

struct vring_packed_desc_event;

struct vring_desc_state_packed;

struct vring_virtqueue_packed {
	struct {
		unsigned int num;
		struct vring_packed_desc *desc;
		struct vring_packed_desc_event *driver;
		struct vring_packed_desc_event *device;
	} vring;
	bool avail_wrap_counter;
	u16 avail_used_flags;
	u16 next_avail_idx;
	u16 event_flags_shadow;
	struct vring_desc_state_packed *desc_state;
	struct vring_desc_extra *desc_extra;
	dma_addr_t ring_dma_addr;
	dma_addr_t driver_event_dma_addr;
	dma_addr_t device_event_dma_addr;
	size_t ring_size_in_bytes;
	size_t event_size_in_bytes;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	bool premapped;
	bool do_unmap;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	bool event_triggered;
	union {
		struct vring_virtqueue_split split;
		struct vring_virtqueue_packed packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
	struct device *dma_dev;
};

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_desc_extra {
	dma_addr_t addr;
	u32 len;
	u16 flags;
	u16 next;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 last;
};

struct qcom_aoss_reset_map;

struct qcom_aoss_desc {
	const struct qcom_aoss_reset_map *resets;
	size_t num_resets;
};

struct qcom_aoss_reset_map {
	unsigned int reg;
};

struct qcom_aoss_reset_data {
	struct reset_controller_dev rcdev;
	void *base;
	const struct qcom_aoss_desc *desc;
};

struct tegra_uart {
	struct clk *clk;
	struct reset_control *rst;
	int line;
};

struct memdev {
	const char *name;
	const struct file_operations *fops;
	fmode_t fmode;
	umode_t mode;
};

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

enum mtk_iommu_plat {
	M4U_MT2712 = 0,
	M4U_MT6779 = 1,
	M4U_MT6795 = 2,
	M4U_MT8167 = 3,
	M4U_MT8173 = 4,
	M4U_MT8183 = 5,
	M4U_MT8186 = 6,
	M4U_MT8188 = 7,
	M4U_MT8192 = 8,
	M4U_MT8195 = 9,
	M4U_MT8365 = 10,
};

struct mtk_iommu_iova_region;

struct mtk_iommu_plat_data {
	enum mtk_iommu_plat m4u_plat;
	u32 flags;
	u32 inv_sel_reg;
	char *pericfg_comp_str;
	struct list_head *hw_list;
	struct {
		unsigned int iova_region_nr;
		const struct mtk_iommu_iova_region *iova_region;
		const u32 (*iova_region_larb_msk)[32];
	};
	struct {
		u8 banks_num;
		bool banks_enable[5];
		unsigned int banks_portmsk[5];
	};
	unsigned char larbid_remap[64];
};

struct mtk_iommu_iova_region {
	dma_addr_t iova_base;
	unsigned long long size;
};

struct mtk_iommu_suspend_reg {
	u32 misc_ctrl;
	u32 dcm_dis;
	u32 ctrl_reg;
	u32 vld_pa_rng;
	u32 wr_len_ctrl;
	u32 int_control[5];
	u32 int_main_control[5];
	u32 ivrp_paddr[5];
};

struct mtk_iommu_bank_data;

struct mtk_iommu_domain;

struct mtk_iommu_data {
	struct device *dev;
	struct clk *bclk;
	phys_addr_t protect_base;
	struct mtk_iommu_suspend_reg reg;
	struct iommu_group *m4u_group[8];
	bool enable_4GB;
	struct iommu_device iommu;
	const struct mtk_iommu_plat_data *plat_data;
	struct device *smicomm_dev;
	struct mtk_iommu_bank_data *bank;
	struct mtk_iommu_domain *share_dom;
	struct regmap *pericfg;
	struct mutex mutex;
	struct list_head *hw_list;
	struct list_head hw_list_head;
	struct list_head list;
	struct mtk_smi_larb_iommu larb_imu[32];
};

struct mtk_iommu_bank_data {
	void *base;
	int irq;
	u8 id;
	struct device *parent_dev;
	struct mtk_iommu_data *parent_data;
	spinlock_t tlb_lock;
	struct mtk_iommu_domain *m4u_dom;
};

struct mtk_iommu_domain {
	struct io_pgtable_cfg cfg;
	struct io_pgtable_ops *iop;
	struct mtk_iommu_bank_data *bank;
	struct iommu_domain domain;
	struct mutex mutex;
};

struct cache_type_info {
	const char *size_prop;
	const char *line_size_props[2];
	const char *nr_sets_prop;
};

struct builtin_fw {
	char *name;
	void *data;
	unsigned long size;
};

struct node_attr {
	struct device_attribute attr;
	enum node_states state;
};

enum cache_indexing {
	NODE_CACHE_DIRECT_MAP = 0,
	NODE_CACHE_INDEXED = 1,
	NODE_CACHE_OTHER = 2,
};

enum cache_write_policy {
	NODE_CACHE_WRITE_BACK = 0,
	NODE_CACHE_WRITE_THROUGH = 1,
	NODE_CACHE_WRITE_OTHER = 2,
};

struct node_cache_attrs {
	enum cache_indexing indexing;
	enum cache_write_policy write_policy;
	u64 size;
	u16 line_size;
	u8 level;
};

struct node_cache_info {
	struct device dev;
	struct list_head node;
	struct node_cache_attrs cache_attrs;
};

struct node_access_nodes {
	struct device dev;
	struct list_head list_node;
	unsigned int access;
	struct node_hmem_attrs hmem_attrs;
};

enum {
	MT6360_SLAVE_TCPC = 0,
	MT6360_SLAVE_PMIC = 1,
	MT6360_SLAVE_LDO = 2,
	MT6360_SLAVE_PMU = 3,
	MT6360_SLAVE_MAX = 4,
};

struct mt6360_ddata {
	struct i2c_client *i2c[4];
	struct device *dev;
	struct regmap *regmap;
	struct regmap_irq_chip_data *irq_data;
	unsigned int chip_rev;
	u8 crc8_tbl[256];
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_DELAYED_REPREP = 2,
	ACTION_RETRY = 3,
	ACTION_DELAYED_RETRY = 4,
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

enum pr_status {
	PR_STS_SUCCESS = 0,
	PR_STS_IOERR = 2,
	PR_STS_RESERVATION_CONFLICT = 24,
	PR_STS_RETRY_PATH_FAILURE = 917504,
	PR_STS_PATH_FAST_FAILED = 983040,
	PR_STS_PATH_FAILED = 65536,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

struct hynix_read_retry_otp {
	int nregs;
	const u8 *regs;
	const u8 *values;
	int page;
	int size;
};

struct hynix_read_retry;

struct hynix_nand {
	const struct hynix_read_retry *read_retry;
};

struct hynix_read_retry {
	int nregs;
	const u8 *regs;
	u8 values[0];
};

struct sun6i_spi_cfg {
	unsigned long fifo_depth;
	bool has_clk_ctl;
	u32 mode_bits;
};

struct sun6i_spi {
	struct spi_controller *master;
	void *base_addr;
	dma_addr_t dma_addr_rx;
	dma_addr_t dma_addr_tx;
	struct clk *hclk;
	struct clk *mclk;
	struct reset_control *rstc;
	struct completion done;
	struct completion dma_rx_done;
	const u8 *tx_buf;
	u8 *rx_buf;
	int len;
	const struct sun6i_spi_cfg *cfg;
};

struct mv3310_chip {
	bool (*has_downshift)(struct phy_device *);
	void (*init_supported_interfaces)(unsigned long *);
	int (*get_mactype)(struct phy_device *);
	int (*set_mactype)(struct phy_device *, int);
	int (*select_mactype)(unsigned long *);
	int (*init_interface)(struct phy_device *, int);
	int (*hwmon_read_temp_reg)(struct phy_device *);
};

enum {
	MV_PMA_FW_VER0 = 49169,
	MV_PMA_FW_VER1 = 49170,
	MV_PMA_21X0_PORT_CTRL = 49226,
	MV_PMA_21X0_PORT_CTRL_SWRST = 32768,
	MV_PMA_21X0_PORT_CTRL_MACTYPE_MASK = 7,
	MV_PMA_21X0_PORT_CTRL_MACTYPE_USXGMII = 0,
	MV_PMA_2180_PORT_CTRL_MACTYPE_DXGMII = 1,
	MV_PMA_2180_PORT_CTRL_MACTYPE_QXGMII = 2,
	MV_PMA_21X0_PORT_CTRL_MACTYPE_5GBASER = 4,
	MV_PMA_21X0_PORT_CTRL_MACTYPE_5GBASER_NO_SGMII_AN = 5,
	MV_PMA_21X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH = 6,
	MV_PMA_BOOT = 49232,
	MV_PMA_BOOT_FATAL = 1,
	MV_PCS_BASE_T = 0,
	MV_PCS_BASE_R = 4096,
	MV_PCS_1000BASEX = 8192,
	MV_PCS_CSCR1 = 32768,
	MV_PCS_CSCR1_ED_MASK = 768,
	MV_PCS_CSCR1_ED_OFF = 0,
	MV_PCS_CSCR1_ED_RX = 512,
	MV_PCS_CSCR1_ED_NLP = 768,
	MV_PCS_CSCR1_MDIX_MASK = 96,
	MV_PCS_CSCR1_MDIX_MDI = 0,
	MV_PCS_CSCR1_MDIX_MDIX = 32,
	MV_PCS_CSCR1_MDIX_AUTO = 96,
	MV_PCS_DSC1 = 32771,
	MV_PCS_DSC1_ENABLE = 512,
	MV_PCS_DSC1_10GBT = 448,
	MV_PCS_DSC1_1GBR = 56,
	MV_PCS_DSC1_100BTX = 7,
	MV_PCS_DSC2 = 32772,
	MV_PCS_DSC2_2P5G = 61440,
	MV_PCS_DSC2_5G = 3840,
	MV_PCS_CSSR1 = 32776,
	MV_PCS_CSSR1_SPD1_MASK = 49152,
	MV_PCS_CSSR1_SPD1_SPD2 = 49152,
	MV_PCS_CSSR1_SPD1_1000 = 32768,
	MV_PCS_CSSR1_SPD1_100 = 16384,
	MV_PCS_CSSR1_SPD1_10 = 0,
	MV_PCS_CSSR1_DUPLEX_FULL = 8192,
	MV_PCS_CSSR1_RESOLVED = 2048,
	MV_PCS_CSSR1_MDIX = 64,
	MV_PCS_CSSR1_SPD2_MASK = 12,
	MV_PCS_CSSR1_SPD2_5000 = 8,
	MV_PCS_CSSR1_SPD2_2500 = 4,
	MV_PCS_CSSR1_SPD2_10000 = 0,
	MV_PCS_TEMP = 32834,
	MV_PCS_PORT_INFO = 53261,
	MV_PCS_PORT_INFO_NPORTS_MASK = 896,
	MV_PCS_PORT_INFO_NPORTS_SHIFT = 7,
	MV_AN_21X0_SERDES_CTRL2 = 32783,
	MV_AN_21X0_SERDES_CTRL2_AUTO_INIT_DIS = 8192,
	MV_AN_21X0_SERDES_CTRL2_RUN_INIT = 32768,
	MV_AN_CTRL1000 = 32768,
	MV_AN_STAT1000 = 32769,
	MV_V2_PORT_CTRL = 61441,
	MV_V2_PORT_CTRL_PWRDOWN = 2048,
	MV_V2_33X0_PORT_CTRL_SWRST = 32768,
	MV_V2_33X0_PORT_CTRL_MACTYPE_MASK = 7,
	MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI = 0,
	MV_V2_3310_PORT_CTRL_MACTYPE_XAUI_RATE_MATCH = 1,
	MV_V2_3340_PORT_CTRL_MACTYPE_RXAUI_NO_SGMII_AN = 1,
	MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI_RATE_MATCH = 2,
	MV_V2_3310_PORT_CTRL_MACTYPE_XAUI = 3,
	MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER = 4,
	MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_NO_SGMII_AN = 5,
	MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH = 6,
	MV_V2_33X0_PORT_CTRL_MACTYPE_USXGMII = 7,
	MV_V2_PORT_INTR_STS = 61504,
	MV_V2_PORT_INTR_MASK = 61507,
	MV_V2_PORT_INTR_STS_WOL_EN = 256,
	MV_V2_MAGIC_PKT_WORD0 = 61547,
	MV_V2_MAGIC_PKT_WORD1 = 61548,
	MV_V2_MAGIC_PKT_WORD2 = 61549,
	MV_V2_WOL_CTRL = 61550,
	MV_V2_WOL_CTRL_CLEAR_STS = 32768,
	MV_V2_WOL_CTRL_MAGIC_PKT_EN = 1,
	MV_V2_TEMP_CTRL = 61578,
	MV_V2_TEMP_CTRL_MASK = 49152,
	MV_V2_TEMP_CTRL_SAMPLE = 0,
	MV_V2_TEMP_CTRL_DISABLE = 49152,
	MV_V2_TEMP = 61580,
	MV_V2_TEMP_UNKNOWN = 38400,
};

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
	hwmon_chip_beep_enable = 12,
};

struct mv3310_priv {
	unsigned long supported_interfaces[1];
	u32 firmware_ver;
	bool has_downshift;
	bool rate_match;
	phy_interface_t const_interface;
	struct device *hwmon_dev;
	char *hwmon_name;
};

enum ether_type_algorithm {
	ETYPE_ALG_NONE = 0,
	ETYPE_ALG_SKIP = 1,
	ETYPE_ALG_ENDPARSE = 2,
	ETYPE_ALG_VLAN = 3,
	ETYPE_ALG_VLAN_STRIP = 4,
};

enum cpi_algorithm_type {
	CPI_ALG_NONE = 0,
	CPI_ALG_VLAN = 1,
	CPI_ALG_VLAN16 = 2,
	CPI_ALG_DIFF = 3,
};

enum rx_stats_reg_offset {
	RX_OCTS = 0,
	RX_UCAST = 1,
	RX_BCAST = 2,
	RX_MCAST = 3,
	RX_RED = 4,
	RX_RED_OCTS = 5,
	RX_ORUN = 6,
	RX_ORUN_OCTS = 7,
	RX_FCS = 8,
	RX_L2ERR = 9,
	RX_DRP_BCAST = 10,
	RX_DRP_MCAST = 11,
	RX_DRP_L3BCAST = 12,
	RX_DRP_L3MCAST = 13,
	RX_STATS_ENUM_LAST = 14,
};

enum tx_stats_reg_offset {
	TX_OCTS = 0,
	TX_UCAST = 1,
	TX_BCAST = 2,
	TX_MCAST = 3,
	TX_DROP = 4,
	TX_STATS_ENUM_LAST = 5,
};

struct pkind_cfg {
	u64 minlen: 16;
	u64 maxlen: 16;
	u64 reserved_32_32: 1;
	u64 lenerr_en: 1;
	u64 rx_hdr: 3;
	u64 hdr_sl: 5;
	u64 reserved_42_63: 22;
};

struct hw_info;

struct nicpf {
	struct pci_dev *pdev;
	struct hw_info *hw;
	u8 node;
	unsigned int flags;
	u8 num_vf_en;
	bool vf_enabled[128];
	void *reg_base;
	u8 num_sqs_en;
	u64 nicvf[128];
	u8 vf_sqs[1408];
	u8 pqs_vf[128];
	bool sqs_used[128];
	struct pkind_cfg pkind;
	u8 *vf_lmac_map;
	u16 cpi_base[128];
	u16 rssi_base[128];
	u8 num_vec;
	unsigned int irq_allocated[10];
	char irq_name[200];
};

struct hw_info {
	u8 bgx_cnt;
	u8 chans_per_lmac;
	u8 chans_per_bgx;
	u8 chans_per_rgx;
	u8 chans_per_lbk;
	u16 cpi_cnt;
	u16 rssi_cnt;
	u16 rss_ind_tbl_size;
	u16 tl4_cnt;
	u16 tl3_cnt;
	u8 tl2_cnt;
	u8 tl1_cnt;
	bool tl1_per_bgx;
};

struct nic_cfg_msg {
	u8 msg;
	u8 vf_id;
	u8 node_id;
	u8 tns_mode: 1;
	u8 sqs_mode: 1;
	u8 loopback_supported: 1;
	u8 mac_addr[6];
};

struct qs_cfg_msg {
	u8 msg;
	u8 num;
	u8 sqs_count;
	u64 cfg;
};

struct rq_cfg_msg {
	u8 msg;
	u8 qs_num;
	u8 rq_num;
	u64 cfg;
};

struct sq_cfg_msg {
	u8 msg;
	u8 qs_num;
	u8 sq_num;
	bool sqs_mode;
	u64 cfg;
};

struct set_mac_msg {
	u8 msg;
	u8 vf_id;
	u8 mac_addr[6];
};

struct set_frs_msg {
	u8 msg;
	u8 vf_id;
	u16 max_frs;
};

struct cpi_cfg_msg {
	u8 msg;
	u8 vf_id;
	u8 rq_cnt;
	u8 cpi_alg;
};

struct rss_sz_msg {
	u8 msg;
	u8 vf_id;
	u16 ind_tbl_size;
};

struct rss_cfg_msg {
	u8 msg;
	u8 vf_id;
	u8 hash_bits;
	u8 tbl_len;
	u8 tbl_offset;
	u8 ind_tbl[8];
};

struct bgx_stats_msg {
	u8 msg;
	u8 vf_id;
	u8 rx;
	u8 idx;
	u64 stats;
};

struct bgx_link_status {
	u8 msg;
	u8 mac_type;
	u8 link_up;
	u8 duplex;
	u32 speed;
};

struct sqs_alloc {
	u8 msg;
	u8 vf_id;
	u8 qs_count;
};

struct nicvf_ptr {
	u8 msg;
	u8 vf_id;
	bool sqs_mode;
	u8 sqs_id;
	u64 nicvf;
};

struct set_loopback {
	u8 msg;
	u8 vf_id;
	bool enable;
};

struct reset_stat_cfg {
	u8 msg;
	u16 rx_stat_mask;
	u8 tx_stat_mask;
	u16 rq_stat_mask;
	u16 sq_stat_mask;
};

struct pfc {
	u8 msg;
	u8 get;
	u8 autoneg;
	u8 fc_rx;
	u8 fc_tx;
};

struct set_ptp {
	u8 msg;
	bool enable;
};

struct xcast {
	u8 msg;
	u8 mode;
	u64 mac: 48;
};

union nic_mbx {
	struct {
		u8 msg;
	} msg;
	struct nic_cfg_msg nic_cfg;
	struct qs_cfg_msg qs;
	struct rq_cfg_msg rq;
	struct sq_cfg_msg sq;
	struct set_mac_msg mac;
	struct set_frs_msg frs;
	struct cpi_cfg_msg cpi_cfg;
	struct rss_sz_msg rss_size;
	struct rss_cfg_msg rss_cfg;
	struct bgx_stats_msg bgx_stats;
	struct bgx_link_status link_status;
	struct sqs_alloc sqs_alloc;
	struct nicvf_ptr nicvf;
	struct set_loopback lbk;
	struct reset_stat_cfg reset_stat;
	struct pfc pfc;
	struct set_ptp ptp;
	struct xcast xcast;
};

struct hclge_devlink_priv {
	struct hclge_dev *hdev;
};

struct igb_reg_info {
	u32 ofs;
	char *name;
};

enum e1000_ring_flags_t {
	IGB_RING_FLAG_RX_3K_BUFFER = 0,
	IGB_RING_FLAG_RX_BUILD_SKB_ENABLED = 1,
	IGB_RING_FLAG_RX_SCTP_CSUM = 2,
	IGB_RING_FLAG_RX_LB_VLAN_BSWAP = 3,
	IGB_RING_FLAG_TX_CTX_IDX = 4,
	IGB_RING_FLAG_TX_DETECT_HANG = 5,
};

enum igb_tx_flags {
	IGB_TX_FLAGS_VLAN = 1,
	IGB_TX_FLAGS_TSO = 2,
	IGB_TX_FLAGS_TSTAMP = 4,
	IGB_TX_FLAGS_IPV4 = 16,
	IGB_TX_FLAGS_CSUM = 32,
};

enum tx_queue_prio {
	TX_QUEUE_PRIO_HIGH = 0,
	TX_QUEUE_PRIO_LOW = 1,
};

enum queue_mode {
	QUEUE_MODE_STRICT_PRIORITY = 0,
	QUEUE_MODE_STREAM_RESERVATION = 1,
};

enum igb_filter_match_flags {
	IGB_FILTER_FLAG_ETHER_TYPE = 1,
	IGB_FILTER_FLAG_VLAN_TCI = 2,
	IGB_FILTER_FLAG_SRC_MAC_ADDR = 4,
	IGB_FILTER_FLAG_DST_MAC_ADDR = 8,
};

union e1000_adv_rx_desc___2 {
	struct {
		__le64 pkt_addr;
		__le64 hdr_addr;
	} read;
	struct {
		struct {
			struct {
				__le16 pkt_info;
				__le16 hdr_info;
			} lo_dword;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length;
			__le16 vlan;
		} upper;
	} wb;
};

struct igb_nfc_input {
	u8 match_flags;
	__be16 etype;
	__be16 vlan_tci;
	u8 src_addr[6];
	u8 dst_addr[6];
};

struct igb_nfc_filter {
	struct hlist_node nfc_node;
	struct igb_nfc_input filter;
	unsigned long cookie;
	u16 etype_reg_index;
	u16 sw_idx;
	u16 action;
};

struct tc_taprio_caps {
	bool supports_queue_max_sdu: 1;
	bool gate_mask_per_txq: 1;
	bool broken_mqprio: 1;
};

struct tc_cbs_qopt_offload {
	u8 enable;
	s32 queue;
	s32 hicredit;
	s32 locredit;
	s32 idleslope;
	s32 sendslope;
};

struct tc_etf_qopt_offload {
	u8 enable;
	s32 queue;
};

typedef void (*btf_trace_dwc3_readl)(void *, void *, u32, u32);

typedef void (*btf_trace_dwc3_writel)(void *, void *, u32, u32);

typedef void (*btf_trace_dwc3_event)(void *, u32, struct dwc3 *);

typedef void (*btf_trace_dwc3_ctrl_req)(void *, struct usb_ctrlrequest *);

typedef void (*btf_trace_dwc3_alloc_request)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_free_request)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_ep_queue)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_ep_dequeue)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_gadget_giveback)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_gadget_generic_cmd)(void *, unsigned int, u32, int);

struct dwc3_gadget_ep_cmd_params;

typedef void (*btf_trace_dwc3_gadget_ep_cmd)(void *, struct dwc3_ep *, unsigned int, struct dwc3_gadget_ep_cmd_params *, int);

struct dwc3_gadget_ep_cmd_params {
	u32 param2;
	u32 param1;
	u32 param0;
};

typedef void (*btf_trace_dwc3_prepare_trb)(void *, struct dwc3_ep *, struct dwc3_trb *);

typedef void (*btf_trace_dwc3_complete_trb)(void *, struct dwc3_ep *, struct dwc3_trb *);

typedef void (*btf_trace_dwc3_gadget_ep_enable)(void *, struct dwc3_ep *);

typedef void (*btf_trace_dwc3_gadget_ep_disable)(void *, struct dwc3_ep *);

struct trace_event_raw_dwc3_log_io {
	struct trace_entry ent;
	void *base;
	u32 offset;
	u32 value;
	char __data[0];
};

struct trace_event_raw_dwc3_log_event {
	struct trace_entry ent;
	u32 event;
	u32 ep0state;
	char __data[0];
};

struct trace_event_raw_dwc3_log_ctrl {
	struct trace_entry ent;
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	char __data[0];
};

struct trace_event_raw_dwc3_log_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct dwc3_request *req;
	unsigned int actual;
	unsigned int length;
	int status;
	int zero;
	int short_not_ok;
	int no_interrupt;
	char __data[0];
};

struct trace_event_raw_dwc3_log_generic_cmd {
	struct trace_entry ent;
	unsigned int cmd;
	u32 param;
	int status;
	char __data[0];
};

struct trace_event_raw_dwc3_log_gadget_ep_cmd {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int cmd;
	u32 param0;
	u32 param1;
	u32 param2;
	int cmd_status;
	char __data[0];
};

struct trace_event_raw_dwc3_log_trb {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct dwc3_trb *trb;
	u32 bpl;
	u32 bph;
	u32 size;
	u32 ctrl;
	u32 type;
	u32 enqueue;
	u32 dequeue;
	char __data[0];
};

struct trace_event_raw_dwc3_log_ep {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int maxpacket;
	unsigned int maxpacket_limit;
	unsigned int max_streams;
	unsigned int maxburst;
	unsigned int flags;
	unsigned int direction;
	u8 trb_enqueue;
	u8 trb_dequeue;
	char __data[0];
};

struct trace_event_data_offsets_dwc3_log_request {
	u32 name;
};

struct trace_event_data_offsets_dwc3_log_gadget_ep_cmd {
	u32 name;
};

struct trace_event_data_offsets_dwc3_log_trb {
	u32 name;
};

struct trace_event_data_offsets_dwc3_log_ep {
	u32 name;
};

struct dwc3_event_type {
	u32 is_devspec: 1;
	u32 type: 7;
	u32 reserved8_31: 24;
};

struct dwc3_event_depevt {
	u32 one_bit: 1;
	u32 endpoint_number: 5;
	u32 endpoint_event: 4;
	u32 reserved11_10: 2;
	u32 status: 4;
	u32 parameters: 16;
};

struct dwc3_event_devt {
	u32 one_bit: 1;
	u32 device_event: 7;
	u32 type: 4;
	u32 reserved15_12: 4;
	u32 event_info: 9;
	u32 reserved31_25: 7;
};

struct dwc3_event_gevt {
	u32 one_bit: 1;
	u32 device_event: 7;
	u32 phy_port_number: 4;
	u32 reserved31_12: 20;
};

union dwc3_event {
	u32 raw;
	struct dwc3_event_type type;
	struct dwc3_event_depevt depevt;
	struct dwc3_event_devt devt;
	struct dwc3_event_gevt gevt;
};

struct trace_event_data_offsets_dwc3_log_io {};

struct trace_event_data_offsets_dwc3_log_event {};

struct trace_event_data_offsets_dwc3_log_ctrl {};

struct trace_event_data_offsets_dwc3_log_generic_cmd {};

enum isp1760_queue_head_types {
	QH_CONTROL = 0,
	QH_BULK = 1,
	QH_INTERRUPT = 2,
	QH_END = 3,
};

struct isp1760_qh {
	struct list_head qh_list;
	struct list_head qtd_list;
	u32 toggle;
	u32 ping;
	int slot;
	int tt_buffer_dirty;
};

struct isp1760_qtd {
	u8 packet_type;
	void *data_buffer;
	u32 payload_addr;
	struct list_head qtd_list;
	struct urb *urb;
	size_t length;
	size_t actual_length;
	u32 status;
};

typedef __u32 __dw;

struct urb_listitem {
	struct list_head urb_list;
	struct urb *urb;
};

struct ptd {
	__dw dw0;
	__dw dw1;
	__dw dw2;
	__dw dw3;
	__dw dw4;
	__dw dw5;
	__dw dw6;
	__dw dw7;
};

struct ptd_le32 {
	__le32 dw0;
	__le32 dw1;
	__le32 dw2;
	__le32 dw3;
	__le32 dw4;
	__le32 dw5;
	__le32 dw6;
	__le32 dw7;
};

typedef void (*btf_trace_ci_log)(void *, struct ci_hdrc *, struct va_format *);

typedef void (*btf_trace_ci_prepare_td)(void *, struct ci_hw_ep *, struct ci_hw_req *, struct td_node *);

typedef void (*btf_trace_ci_complete_td)(void *, struct ci_hw_ep *, struct ci_hw_req *, struct td_node *);

struct trace_event_raw_ci_log {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_ci_log_trb {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct td_node *td;
	struct usb_request *req;
	dma_addr_t dma;
	s32 td_remaining_size;
	u32 next;
	u32 token;
	u32 type;
	char __data[0];
};

struct trace_event_data_offsets_ci_log {
	u32 name;
	u32 msg;
};

struct trace_event_data_offsets_ci_log_trb {
	u32 name;
};

struct gpio_keys_button {
	unsigned int code;
	int gpio;
	int active_low;
	const char *desc;
	unsigned int type;
	int wakeup;
	int wakeup_event_action;
	int debounce_interval;
	bool can_disable;
	int value;
	unsigned int irq;
};

struct gpio_button_data {
	const struct gpio_keys_button *button;
	struct input_dev *input;
	struct gpio_desc *gpiod;
	unsigned short *code;
	struct hrtimer release_timer;
	unsigned int release_delay;
	struct delayed_work work;
	struct hrtimer debounce_timer;
	unsigned int software_debounce;
	unsigned int irq;
	unsigned int wakeup_trigger_type;
	spinlock_t lock;
	bool disabled;
	bool key_pressed;
	bool suspended;
	bool debounce_use_hrtimer;
};

struct gpio_keys_platform_data;

struct gpio_keys_drvdata {
	const struct gpio_keys_platform_data *pdata;
	struct input_dev *input;
	struct mutex disable_lock;
	unsigned short *keymap;
	struct gpio_button_data data[0];
};

struct gpio_keys_platform_data {
	const struct gpio_keys_button *buttons;
	int nbuttons;
	unsigned int poll_interval;
	unsigned int rep: 1;
	int (*enable)(struct device *);
	void (*disable)(struct device *);
	const char *name;
};

struct ds3232 {
	struct device *dev;
	struct regmap *regmap;
	int irq;
	struct rtc_device *rtc;
	bool suspended;
};

struct omap_i2c_bus_platform_data {
	u32 clkrate;
	u32 rev;
	u32 flags;
	void (*set_mpu_wkup_lat)(struct device *, long);
};

enum {
	OMAP_I2C_REV_REG = 0,
	OMAP_I2C_IE_REG = 1,
	OMAP_I2C_STAT_REG = 2,
	OMAP_I2C_IV_REG = 3,
	OMAP_I2C_WE_REG = 4,
	OMAP_I2C_SYSS_REG = 5,
	OMAP_I2C_BUF_REG = 6,
	OMAP_I2C_CNT_REG = 7,
	OMAP_I2C_DATA_REG = 8,
	OMAP_I2C_SYSC_REG = 9,
	OMAP_I2C_CON_REG = 10,
	OMAP_I2C_OA_REG = 11,
	OMAP_I2C_SA_REG = 12,
	OMAP_I2C_PSC_REG = 13,
	OMAP_I2C_SCLL_REG = 14,
	OMAP_I2C_SCLH_REG = 15,
	OMAP_I2C_SYSTEST_REG = 16,
	OMAP_I2C_BUFSTAT_REG = 17,
	OMAP_I2C_IP_V2_REVNB_LO = 18,
	OMAP_I2C_IP_V2_REVNB_HI = 19,
	OMAP_I2C_IP_V2_IRQSTATUS_RAW = 20,
	OMAP_I2C_IP_V2_IRQENABLE_SET = 21,
	OMAP_I2C_IP_V2_IRQENABLE_CLR = 22,
};

struct omap_i2c_dev {
	struct device *dev;
	void *base;
	int irq;
	int reg_shift;
	struct completion cmd_complete;
	struct resource *ioarea;
	u32 latency;
	void (*set_mpu_wkup_lat)(struct device *, long);
	u32 speed;
	u32 flags;
	u16 scheme;
	u16 cmd_err;
	u8 *buf;
	u8 *regs;
	size_t buf_len;
	struct i2c_adapter adapter;
	u8 threshold;
	u8 fifo_size;
	u32 rev;
	unsigned int b_hw: 1;
	unsigned int bb_valid: 1;
	unsigned int receiver: 1;
	u16 iestate;
	u16 pscstate;
	u16 scllstate;
	u16 sclhstate;
	u16 syscstate;
	u16 westate;
	u16 errata;
};

struct ptp_dte {
	void *regs;
	struct ptp_clock *ptp_clk;
	struct ptp_clock_info caps;
	struct device *dev;
	u32 ts_ovf_last;
	u32 ts_wrap_cnt;
	spinlock_t lock;
	u32 reg_val[4];
};

enum scpi_sensor_class {
	TEMPERATURE = 0,
	VOLTAGE___2 = 1,
	CURRENT___2 = 2,
	POWER___2 = 3,
	ENERGY___2 = 4,
};

struct sensor_data {
	unsigned int scale;
	struct scpi_sensor_info info;
	struct device_attribute dev_attr_input;
	struct device_attribute dev_attr_label;
	char input[20];
	char label[20];
};

struct scpi_sensors {
	struct scpi_ops *scpi_ops;
	struct sensor_data *data;
	struct list_head thermal_zones;
	struct attribute **attrs;
	struct attribute_group group;
	const struct attribute_group *groups[2];
};

struct scpi_thermal_zone {
	int sensor_id;
	struct scpi_sensors *scpi_sensors;
};

struct gti_match_data {
	u32 gti_num_timers;
};

struct gti_wdt_priv {
	struct watchdog_device wdev;
	void *base;
	u32 clock_freq;
	struct clk *sclk;
	u32 wdt_timer_idx;
	const struct gti_match_data *data;
};

struct apple_soc_cpufreq_info {
	u64 max_pstate;
	u64 cur_pstate_mask;
	u64 cur_pstate_shift;
};

struct apple_cpu_priv {
	struct device *cpu_dev;
	void *reg_base;
	const struct apple_soc_cpufreq_info *info;
};

struct psci_pd_provider {
	struct list_head link;
	struct device_node *node;
};

struct brcmstb_match_priv {
	void (*hs400es)(struct mmc_host *, struct mmc_ios *);
	struct sdhci_ops *ops;
	const unsigned int flags;
};

struct sdhci_brcmstb_priv {
	void *cfg_regs;
	unsigned int flags;
	struct clk *base_clk;
	u32 base_freq_hz;
};

struct ec_params_host_sleep_event {
	uint8_t sleep_event;
};

struct ec_params_host_sleep_event_v1 {
	uint8_t sleep_event;
	uint8_t reserved;
	union {
		struct {
			uint16_t sleep_timeout_ms;
		} suspend_params;
	};
};

struct ec_response_host_sleep_event_v1 {
	union {
		struct {
			uint32_t sleep_transitions;
		} resume_response;
	};
};

enum host_sleep_event {
	HOST_SLEEP_EVENT_S3_SUSPEND = 1,
	HOST_SLEEP_EVENT_S3_RESUME = 2,
	HOST_SLEEP_EVENT_S0IX_SUSPEND = 3,
	HOST_SLEEP_EVENT_S0IX_RESUME = 4,
	HOST_SLEEP_EVENT_S3_WAKEABLE_SUSPEND = 5,
};

struct sun6i_msgbox {
	struct mbox_controller controller;
	struct clk *clk;
	spinlock_t lock;
	void *regs;
};

struct usb_extcon_info {
	struct device *dev;
	struct extcon_dev *edev;
	struct gpio_desc *id_gpiod;
	struct gpio_desc *vbus_gpiod;
	int id_irq;
	int vbus_irq;
	unsigned long debounce_jiffies;
	struct delayed_work wq_detcable;
};

struct uniphier_efuse_priv {
	void *base;
};

struct snd_dmaengine_pcm_config {
	int (*prepare_slave_config)(struct snd_pcm_substream *, struct snd_pcm_hw_params *, struct dma_slave_config *);
	struct dma_chan * (*compat_request_channel)(struct snd_soc_pcm_runtime *, struct snd_pcm_substream *);
	int (*process)(struct snd_pcm_substream *, int, unsigned long, unsigned long);
	dma_filter_fn compat_filter_fn;
	struct device *dma_dev;
	const char *chan_names[2];
	const struct snd_pcm_hardware *pcm_hardware;
	unsigned int prealloc_buffer_size;
};

struct dmaengine_pcm {
	struct dma_chan *chan[2];
	const struct snd_dmaengine_pcm_config *config;
	struct snd_soc_component component;
	unsigned int flags;
};

struct snd_dmaengine_dai_dma_data {
	dma_addr_t addr;
	enum dma_slave_buswidth addr_width;
	u32 maxburst;
	void *filter_data;
	const char *chan_name;
	unsigned int fifo_size;
	unsigned int flags;
	void *peripheral_config;
	size_t peripheral_size;
};

struct drop_reason_list {
	const char * const *reasons;
	size_t n_reasons;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct page_frag_1k {
	void *va;
	u16 offset;
	bool pfmemalloc;
};

struct napi_alloc_cache {
	struct page_frag_cache page;
	struct page_frag_1k page_small;
	unsigned int skb_count;
	void *skb_cache[64];
};

enum skb_drop_reason_subsys {
	SKB_DROP_REASON_SUBSYS_CORE = 0,
	SKB_DROP_REASON_SUBSYS_MAC80211_UNUSABLE = 1,
	SKB_DROP_REASON_SUBSYS_MAC80211_MONITOR = 2,
	SKB_DROP_REASON_SUBSYS_OPENVSWITCH = 3,
	SKB_DROP_REASON_SUBSYS_NUM = 4,
};

enum skb_ext_id {
	SKB_EXT_BRIDGE_NF = 0,
	SKB_EXT_NUM = 1,
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
	__u32 frag_off;
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct skb_free_array {
	unsigned int skb_count;
	void *skb_array[16];
};

struct ts_ops;

struct ts_state;

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_state {
	unsigned int offset;
	char cb[48];
};

typedef int (*sendmsg_func)(struct sock *, struct msghdr *);

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct compat_rtentry {
	u32 rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	unsigned short rt_flags;
	short rt_pad2;
	u32 rt_pad3;
	unsigned char rt_tos;
	unsigned char rt_class;
	short rt_pad4;
	short rt_metric;
	compat_uptr_t rt_dev;
	u32 rt_mtu;
	u32 rt_window;
	unsigned short rt_irtt;
};

enum devlink_health_reporter_state {
	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY = 0,
	DEVLINK_HEALTH_REPORTER_STATE_ERROR = 1,
};

struct devlink_health_reporter_ops;

struct devlink_fmsg;

struct devlink_health_reporter {
	struct list_head list;
	void *priv;
	const struct devlink_health_reporter_ops *ops;
	struct devlink *devlink;
	struct devlink_port *devlink_port;
	struct devlink_fmsg *dump_fmsg;
	u64 graceful_period;
	bool auto_recover;
	bool auto_dump;
	u8 health_state;
	u64 dump_ts;
	u64 dump_real_ts;
	u64 error_count;
	u64 recovery_count;
	u64 last_recovery_ts;
};

struct devlink_health_reporter_ops {
	char *name;
	int (*recover)(struct devlink_health_reporter *, void *, struct netlink_ext_ack *);
	int (*dump)(struct devlink_health_reporter *, struct devlink_fmsg *, void *, struct netlink_ext_ack *);
	int (*diagnose)(struct devlink_health_reporter *, struct devlink_fmsg *, struct netlink_ext_ack *);
	int (*test)(struct devlink_health_reporter *, struct netlink_ext_ack *);
};

struct devlink_fmsg {
	struct list_head item_list;
	int err;
	bool putting_binary;
};

struct devlink_fmsg_item {
	struct list_head list;
	int attrtype;
	u8 nla_type;
	u16 len;
	int value[0];
};

struct rc {
	long (*fill)(void *, unsigned long);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct lzma_header;

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long (*flush)(void *, unsigned long);
	struct lzma_header *header;
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

struct fdt_errtabent {
	const char *str;
};

struct fprop_local_single {
	unsigned long events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct efi_vendor_dev_path {
	struct efi_generic_dev_path header;
	efi_guid_t vendorguid;
	u8 vendordata[0];
};

enum efistub_event {
	EFISTUB_EVT_INITRD = 0,
	EFISTUB_EVT_LOAD_OPTIONS = 1,
	EFISTUB_EVT_COUNT = 2,
};

struct efi_tcg2_tagged_event {
	u32 tagged_event_id;
	u32 tagged_event_data_size;
};

typedef struct efi_tcg2_tagged_event efi_tcg2_tagged_event_t;

struct efi_measured_event {
	efi_tcg2_event_t event_data;
	efi_tcg2_tagged_event_t tagged_event;
	u8 tagged_event_data[0];
} __attribute__((packed));

union efi_load_file_protocol;

typedef union efi_load_file_protocol efi_load_file_protocol_t;

union efi_load_file_protocol {
	struct {
		efi_status_t (*load_file)(efi_load_file_protocol_t *, efi_device_path_protocol_t *, bool, unsigned long *, void *);
	};
	struct {
		u32 load_file;
	} mixed_mode;
};

typedef union efi_load_file_protocol efi_load_file2_protocol_t;

typedef struct {
	u32 attributes;
	u16 file_path_list_length;
	u8 variable_data[0];
} __attribute__((packed)) efi_load_option_t;

typedef struct {
	u32 attributes;
	u16 file_path_list_length;
	const efi_char16_t *description;
	const efi_device_path_protocol_t *file_path_list;
	u32 optional_data_size;
	const void *optional_data;
} efi_load_option_unpacked_t;

union efi_memory_attribute_protocol;

typedef union efi_memory_attribute_protocol efi_memory_attribute_protocol_t;

union efi_memory_attribute_protocol {
	struct {
		efi_status_t (*get_memory_attributes)(efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64 *);
		efi_status_t (*set_memory_attributes)(efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64);
		efi_status_t (*clear_memory_attributes)(efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64);
	};
	struct {
		u32 get_memory_attributes;
		u32 set_memory_attributes;
		u32 clear_memory_attributes;
	} mixed_mode;
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int walksize;
	union {
		struct {
			unsigned int min_keysize;
			unsigned int max_keysize;
			unsigned int ivsize;
			unsigned int chunksize;
			struct crypto_alg base;
		};
		struct skcipher_alg_common co;
	};
};

struct mac_tfm_ctx {
	struct crypto_aes_ctx key;
	long: 0;
	u8 consts[0];
};

struct crypto_aes_xts_ctx {
	struct crypto_aes_ctx key1;
	long: 0;
	struct crypto_aes_ctx key2;
	long: 0;
};

struct crypto_aes_essiv_cbc_ctx {
	struct crypto_aes_ctx key1;
	long: 0;
	struct crypto_aes_ctx key2;
	struct crypto_shash *hash;
};

struct mac_desc_ctx {
	unsigned int len;
	u8 dg[16];
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = -1,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, unsigned long, unsigned int);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, unsigned long);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, unsigned long long);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, unsigned long long);

typedef void (*btf_trace_tick_stop)(void *, int, int);

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	unsigned long clk;
	unsigned long next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	bool timers_pending;
	unsigned long pending_map[9];
	struct hlist_head vectors[576];
	long: 64;
	long: 64;
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	unsigned long expires;
	unsigned long now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	unsigned long now;
	void *function;
	unsigned long baseclk;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	s64 now;
	void *function;
	char __data[0];
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	unsigned long long expires;
	long value_sec;
	long value_nsec;
	long interval_sec;
	long interval_nsec;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	unsigned long long now;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_tick_stop {};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
	Opt_favordynmods = 8,
	Opt_nofavordynmods = 9,
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct cgroup_file_ctx {
	struct cgroup_namespace *ns;
	struct {
		void *trigger;
	} psi;
	struct {
		bool started;
		struct css_task_iter iter;
	} procs;
	struct {
		struct cgroup_pidlist *pidlist;
	} procs1;
};

struct ftrace_page;

struct ftrace_rec_iter {
	struct ftrace_page *pg;
	int index;
};

struct ftrace_page {
	struct ftrace_page *next;
	struct dyn_ftrace *records;
	int index;
	int order;
};

enum ftrace_bug_type {
	FTRACE_BUG_UNKNOWN = 0,
	FTRACE_BUG_INIT = 1,
	FTRACE_BUG_NOP = 2,
	FTRACE_BUG_CALL = 3,
	FTRACE_BUG_UPDATE = 4,
};

struct ftrace_profile_page;

struct ftrace_profile_stat {
	atomic_t disabled;
	struct hlist_head *hash;
	struct ftrace_profile_page *pages;
	struct ftrace_profile_page *start;
	struct tracer_stat stat;
};

struct ftrace_profile {
	struct hlist_node node;
	unsigned long ip;
	unsigned long counter;
	unsigned long long time;
	unsigned long long time_squared;
};

struct ftrace_profile_page {
	struct ftrace_profile_page *next;
	unsigned long index;
	struct ftrace_profile records[0];
};

enum {
	FTRACE_MODIFY_ENABLE_FL = 1,
	FTRACE_MODIFY_MAY_SLEEP_FL = 2,
};

enum {
	FTRACE_ITER_FILTER = 1,
	FTRACE_ITER_NOTRACE = 2,
	FTRACE_ITER_PRINTALL = 4,
	FTRACE_ITER_DO_PROBES = 8,
	FTRACE_ITER_PROBE = 16,
	FTRACE_ITER_MOD = 32,
	FTRACE_ITER_ENABLED = 64,
	FTRACE_ITER_TOUCHED = 128,
	FTRACE_ITER_ADDRS = 256,
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

enum {
	FTRACE_UPDATE_IGNORE = 0,
	FTRACE_UPDATE_MAKE_CALL = 1,
	FTRACE_UPDATE_MODIFY_CALL = 2,
	FTRACE_UPDATE_MAKE_NOP = 3,
};

enum graph_filter_type {
	GRAPH_FILTER_NOTRACE = 0,
	GRAPH_FILTER_FUNCTION = 1,
};

struct ftrace_func_mapper {
	struct ftrace_hash hash;
};

struct ftrace_func_map {
	struct ftrace_func_entry entry;
	void *data;
};

struct ftrace_func_probe {
	struct ftrace_probe_ops *probe_ops;
	struct ftrace_ops ops;
	struct trace_array *tr;
	struct list_head list;
	void *data;
	int ref;
};

struct ftrace_mod_map {
	struct callback_head rcu;
	struct list_head list;
	struct module *mod;
	unsigned long start_addr;
	unsigned long end_addr;
	struct list_head funcs;
	unsigned int num_funcs;
};

struct ftrace_mod_func {
	struct list_head list;
	char *name;
	unsigned long ip;
	unsigned int size;
};

struct ftrace_init_func {
	struct list_head list;
	unsigned long ip;
};

struct ftrace_mod_load {
	struct list_head list;
	char *func;
	char *module;
	int enable;
};

struct ftrace_iterator {
	loff_t pos;
	loff_t func_pos;
	loff_t mod_pos;
	struct ftrace_page *pg;
	struct dyn_ftrace *func;
	struct ftrace_func_probe *probe;
	struct ftrace_func_entry *probe_entry;
	struct trace_parser parser;
	struct ftrace_hash *hash;
	struct ftrace_ops *ops;
	struct trace_array *tr;
	struct list_head *mod_list;
	int pidx;
	int idx;
	unsigned int flags;
};

struct ftrace_glob {
	char *search;
	unsigned int len;
	int type;
};

struct ftrace_graph_data {
	struct ftrace_hash *hash;
	struct ftrace_func_entry *entry;
	int idx;
	enum graph_filter_type type;
	struct ftrace_hash *new_hash;
	const struct seq_operations *seq_ops;
	struct trace_parser parser;
};

struct kallsyms_data {
	unsigned long *addrs;
	const char **syms;
	size_t cnt;
	size_t found;
};

struct bpf_empty_prog_array {
	struct bpf_prog_array hdr;
	struct bpf_prog *null_prog;
};

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

typedef void (*btf_trace_bpf_xdp_link_attach_failed)(void *, const char *);

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

struct bpf_prog_pack {
	struct list_head list;
	void *ptr;
	unsigned long bitmap[0];
};

typedef u64 (*btf_bpf_user_rnd_u32)();

typedef u64 (*btf_bpf_get_raw_cpu_id)();

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_raw_bpf_xdp_link_attach_failed {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_bpf_xdp_link_attach_failed {
	u32 msg;
};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_return_failed {};

struct dirty_throttle_control {
	struct wb_domain *dom;
	struct dirty_throttle_control *gdtc;
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	unsigned long avail;
	unsigned long dirty;
	unsigned long thresh;
	unsigned long bg_thresh;
	unsigned long wb_dirty;
	unsigned long wb_thresh;
	unsigned long wb_bg_thresh;
	unsigned long pos_ratio;
};

struct wb_lock_cookie {
	bool locked;
	unsigned long flags;
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
};

struct dma_block;

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	struct dma_block *next_block;
	size_t nr_blocks;
	size_t nr_active;
	size_t nr_pages;
	struct device *dev;
	unsigned int size;
	unsigned int allocation;
	unsigned int boundary;
	char name[32];
	struct list_head pools;
};

struct dma_block {
	struct dma_block *next_block;
	dma_addr_t dma;
};

typedef void (*btf_trace_cma_release)(void *, const char *, unsigned long, const struct page *, unsigned long);

typedef void (*btf_trace_cma_alloc_start)(void *, const char *, unsigned long, unsigned int);

typedef void (*btf_trace_cma_alloc_finish)(void *, const char *, unsigned long, const struct page *, unsigned long, unsigned int, int);

typedef void (*btf_trace_cma_alloc_busy_retry)(void *, const char *, unsigned long, const struct page *, unsigned long, unsigned int);

struct trace_event_raw_cma_release {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned long pfn;
	const struct page *page;
	unsigned long count;
	char __data[0];
};

struct trace_event_raw_cma_alloc_start {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned long count;
	unsigned int align;
	char __data[0];
};

struct trace_event_raw_cma_alloc_finish {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned long pfn;
	const struct page *page;
	unsigned long count;
	unsigned int align;
	int errorno;
	char __data[0];
};

struct trace_event_raw_cma_alloc_busy_retry {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned long pfn;
	const struct page *page;
	unsigned long count;
	unsigned int align;
	char __data[0];
};

struct trace_event_data_offsets_cma_release {
	u32 name;
};

struct trace_event_data_offsets_cma_alloc_start {
	u32 name;
};

struct trace_event_data_offsets_cma_alloc_finish {
	u32 name;
};

struct trace_event_data_offsets_cma_alloc_busy_retry {
	u32 name;
};

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

struct epitem;

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	struct hlist_head refs;
	refcount_t refcount;
	unsigned int napi_id;
};

struct epoll_filefd {
	struct file *file;
	int fd;
} __attribute__((packed));

struct eppoll_entry;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	bool dying;
	struct eppoll_entry *pwqlist;
	struct eventpoll *ep;
	struct hlist_node fllink;
	struct wakeup_source __attribute__((btf_type_tag("rcu"))) *ws;
	struct epoll_event event;
};

struct eppoll_entry {
	struct eppoll_entry *next;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct epitems_head {
	struct hlist_head epitems;
	struct epitems_head *next;
};

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct kernfs_global_locks {
	struct mutex open_file_mutex[1024];
};

struct configfs_buffer {
	size_t count;
	loff_t pos;
	char *page;
	struct configfs_item_operations *ops;
	struct mutex mutex;
	int needs_read_fill;
	bool read_in_progress;
	bool write_in_progress;
	char *bin_buffer;
	int bin_buffer_size;
	int cb_max_size;
	struct config_item *item;
	struct module *owner;
	union {
		struct configfs_attribute *attr;
		struct configfs_bin_attribute *bin_attr;
	};
};

enum netfs_read_trace {
	netfs_read_trace_expanded = 0,
	netfs_read_trace_readahead = 1,
	netfs_read_trace_readpage = 2,
	netfs_read_trace_write_begin = 3,
} __attribute__((mode(byte)));

typedef void (*btf_trace_netfs_read)(void *, struct netfs_io_request *, loff_t, size_t, enum netfs_read_trace);

typedef void (*btf_trace_netfs_rreq)(void *, struct netfs_io_request *, enum netfs_rreq_trace);

typedef void (*btf_trace_netfs_sreq)(void *, struct netfs_io_subrequest *, enum netfs_sreq_trace);

typedef void (*btf_trace_netfs_failure)(void *, struct netfs_io_request *, struct netfs_io_subrequest *, int, enum netfs_failure);

typedef void (*btf_trace_netfs_rreq_ref)(void *, unsigned int, int, enum netfs_rreq_ref_trace);

typedef void (*btf_trace_netfs_sreq_ref)(void *, unsigned int, unsigned int, int, enum netfs_sreq_ref_trace);

struct trace_event_raw_netfs_read {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int cookie;
	loff_t start;
	size_t len;
	enum netfs_read_trace what;
	unsigned int netfs_inode;
	char __data[0];
};

struct trace_event_raw_netfs_rreq {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int flags;
	enum netfs_io_origin origin;
	enum netfs_rreq_trace what;
	char __data[0];
};

struct trace_event_raw_netfs_sreq {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned short index;
	short error;
	unsigned short flags;
	enum netfs_io_source source;
	enum netfs_sreq_trace what;
	size_t len;
	size_t transferred;
	loff_t start;
	char __data[0];
};

struct trace_event_raw_netfs_failure {
	struct trace_entry ent;
	unsigned int rreq;
	short index;
	short error;
	unsigned short flags;
	enum netfs_io_source source;
	enum netfs_failure what;
	size_t len;
	size_t transferred;
	loff_t start;
	char __data[0];
};

struct trace_event_raw_netfs_rreq_ref {
	struct trace_entry ent;
	unsigned int rreq;
	int ref;
	enum netfs_rreq_ref_trace what;
	char __data[0];
};

struct trace_event_raw_netfs_sreq_ref {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int subreq;
	int ref;
	enum netfs_sreq_ref_trace what;
	char __data[0];
};

struct trace_event_data_offsets_netfs_read {};

struct trace_event_data_offsets_netfs_rreq {};

struct trace_event_data_offsets_netfs_sreq {};

struct trace_event_data_offsets_netfs_failure {};

struct trace_event_data_offsets_netfs_rreq_ref {};

struct trace_event_data_offsets_netfs_sreq_ref {};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

struct nfs_ssc_client_ops {
	void (*sco_sb_deactive)(struct super_block *);
};

struct proc_nfs_info {
	int flag;
	const char *str;
	const char *nostr;
};

struct nfs_mount_request {
	struct __kernel_sockaddr_storage *sap;
	size_t salen;
	char *hostname;
	char *dirpath;
	u32 version;
	unsigned short protocol;
	struct nfs_fh *fh;
	int noresvport;
	unsigned int *auth_flav_len;
	rpc_authflavor_t *auth_flavs;
	struct net *net;
};

struct nfs42_layouterror_data {
	struct nfs42_layouterror_args args;
	struct nfs42_layouterror_res res;
	struct inode *inode;
	struct pnfs_layout_segment *lseg;
};

struct nfs42_offloadcancel_data {
	struct nfs_server *seq_server;
	struct nfs42_offload_status_args args;
	struct nfs42_offload_status_res res;
};

struct dccp_hdr {
	__be16 dccph_sport;
	__be16 dccph_dport;
	__u8 dccph_doff;
	__u8 dccph_cscov: 4;
	__u8 dccph_ccval: 4;
	__sum16 dccph_checksum;
	__u8 dccph_x: 1;
	__u8 dccph_type: 4;
	__u8 dccph_reserved: 3;
	__u8 dccph_seq2;
	__be16 dccph_seq;
};

struct sctphdr {
	__be16 source;
	__be16 dest;
	__be32 vtag;
	__le32 checksum;
};

struct lsm_network_audit;

struct lsm_ioctlop_audit;

struct lsm_ibpkey_audit;

struct lsm_ibendport_audit;

struct common_audit_data {
	char type;
	union {
		struct path path;
		struct dentry *dentry;
		struct inode *inode;
		struct lsm_network_audit *net;
		int cap;
		int ipc_id;
		struct task_struct *tsk;
		struct {
			key_serial_t key;
			char *key_desc;
		} key_struct;
		char *kmod_name;
		struct lsm_ioctlop_audit *op;
		struct file *file;
		struct lsm_ibpkey_audit *ibpkey;
		struct lsm_ibendport_audit *ibendport;
		int reason;
		const char *anonclass;
	} u;
	union {};
};

struct lsm_network_audit {
	int netif;
	const struct sock *sk;
	u16 family;
	__be16 dport;
	__be16 sport;
	union {
		struct {
			__be32 daddr;
			__be32 saddr;
		} v4;
		struct {
			struct in6_addr daddr;
			struct in6_addr saddr;
		} v6;
	} fam;
};

struct lsm_ioctlop_audit {
	struct path path;
	u16 cmd;
};

struct lsm_ibpkey_audit {
	u64 subnet_prefix;
	u16 pkey;
};

struct lsm_ibendport_audit {
	const char *dev_name;
	u8 port;
};

struct sha3_state {
	u64 st[25];
	unsigned int rsiz;
	unsigned int rsizw;
	unsigned int partial;
	u8 buf[144];
};

enum {
	ICQ_EXITED = 4,
	ICQ_DESTROYED = 8,
};

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
} __attribute__((packed));

typedef struct _gpt_header gpt_header;

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

enum gcry_mpi_format {
	GCRYMPI_FMT_NONE = 0,
	GCRYMPI_FMT_STD = 1,
	GCRYMPI_FMT_PGP = 2,
	GCRYMPI_FMT_SSH = 3,
	GCRYMPI_FMT_HEX = 4,
	GCRYMPI_FMT_USG = 5,
	GCRYMPI_FMT_OPAQUE = 8,
};

struct alpine_msix_data {
	spinlock_t msi_map_lock;
	phys_addr_t addr;
	u32 spi_first;
	u32 num_spis;
	unsigned long *msi_map;
};

struct mvebu_gicp_spi_range;

struct mvebu_gicp {
	struct mvebu_gicp_spi_range *spi_ranges;
	unsigned int spi_ranges_cnt;
	unsigned int spi_cnt;
	unsigned long *spi_bitmap;
	spinlock_t spi_lock;
	struct resource *res;
	struct device *dev;
};

struct mvebu_gicp_spi_range {
	unsigned int start;
	unsigned int count;
};

struct phy_meson_gxl_usb2_priv {
	struct regmap *regmap;
	enum phy_mode mode;
	int is_enabled;
	struct clk *clk;
	struct reset_control *reset;
};

enum mtk_phy_version {
	MTK_PHY_V1 = 1,
	MTK_PHY_V2 = 2,
	MTK_PHY_V3 = 3,
};

struct mtk_phy_pdata {
	bool avoid_rx_sen_degradation;
	bool sw_pll_48m_to_26m;
	bool sw_efuse_supported;
	enum mtk_phy_version version;
};

enum u2_phy_params {
	U2P_EYE_VRT = 0,
	U2P_EYE_TERM = 1,
	U2P_EFUSE_EN = 2,
	U2P_EFUSE_INTR = 3,
	U2P_DISCTH = 4,
	U2P_PRE_EMPHASIS = 5,
};

enum u3_phy_params {
	U3P_EFUSE_EN = 0,
	U3P_EFUSE_INTR = 1,
	U3P_EFUSE_TX_IMP = 2,
	U3P_EFUSE_RX_IMP = 3,
};

struct u2phy_banks {
	void *misc;
	void *fmreg;
	void *com;
};

struct u3phy_banks {
	void *spllc;
	void *chip;
	void *phyd;
	void *phya;
};

struct mtk_phy_instance {
	struct phy *phy;
	void *port_base;
	union {
		struct u2phy_banks u2_banks;
		struct u3phy_banks u3_banks;
	};
	struct clk_bulk_data clks[2];
	u32 index;
	u32 type;
	struct regmap *type_sw;
	u32 type_sw_reg;
	u32 type_sw_index;
	u32 efuse_sw_en;
	u32 efuse_intr;
	u32 efuse_tx_imp;
	u32 efuse_rx_imp;
	int eye_src;
	int eye_vrt;
	int eye_term;
	int intr;
	int discth;
	int pre_emphasis;
	bool bc12_en;
};

struct mtk_tphy {
	struct device *dev;
	void *sif_base;
	const struct mtk_phy_pdata *pdata;
	struct mtk_phy_instance **phys;
	int nphys;
	int src_ref_clk;
	int src_coef;
};

struct dwapb_gpio_port_irqchip;

struct dwapb_gpio;

struct dwapb_context;

struct dwapb_gpio_port {
	struct gpio_chip gc;
	struct dwapb_gpio_port_irqchip *pirq;
	struct dwapb_gpio *gpio;
	struct dwapb_context *ctx;
	unsigned int idx;
};

struct dwapb_gpio_port_irqchip {
	unsigned int nr_irqs;
	unsigned int irq[32];
};

struct dwapb_gpio {
	struct device *dev;
	void *regs;
	struct dwapb_gpio_port *ports;
	unsigned int nr_ports;
	unsigned int flags;
	struct reset_control *rst;
	struct clk_bulk_data clks[2];
};

struct dwapb_context {
	u32 data;
	u32 dir;
	u32 ext;
	u32 int_en;
	u32 int_mask;
	u32 int_type;
	u32 int_pol;
	u32 int_deb;
	u32 wake_en;
};

struct dwapb_port_property;

struct dwapb_platform_data {
	struct dwapb_port_property *properties;
	unsigned int nports;
};

struct dwapb_port_property {
	struct fwnode_handle *fwnode;
	unsigned int idx;
	unsigned int ngpio;
	unsigned int gpio_base;
	int irq[32];
};

struct walk_rcec_data {
	struct pci_dev *rcec;
	int (*user_callback)(struct pci_dev *, void *);
	void *user_data;
};

struct pci_epc_group {
	struct config_group group;
	struct pci_epc *epc;
	bool start;
};

struct pci_epf_group {
	struct config_group group;
	struct config_group primary_epc_group;
	struct config_group secondary_epc_group;
	struct config_group *type_group;
	struct delayed_work cfs_work;
	struct pci_epf *epf;
	int index;
};

struct nvs_region {
	__u64 phys_start;
	__u64 size;
	struct list_head node;
};

struct acpi_wakeup_handler {
	struct list_head list_node;
	bool (*wakeup)(void *);
	void *context;
};

struct event_counter {
	u32 count;
	u32 flags;
};

struct acpi_data_attr;

struct acpi_data_obj {
	char *name;
	int (*fn)(void *, struct acpi_data_attr *);
};

struct acpi_data_attr {
	struct bin_attribute attr;
	u64 addr;
};

struct acpi_table_attr {
	struct bin_attribute attr;
	char name[4];
	int instance;
	char filename[8];
	struct list_head node;
};

struct acpi_table_bert {
	struct acpi_table_header header;
	u32 region_length;
	u64 address;
};

struct acpi_table_ccel {
	struct acpi_table_header header;
	u8 CCtype;
	u8 Ccsub_type;
	u16 reserved;
	u64 log_area_minimum_length;
	u64 log_area_start_address;
};

struct acpi_exception_info {
	char *name;
};

struct acpi_offsets {
	size_t offset;
	u8 mode;
};

enum {
	ACPI_BATTERY_ALARM_PRESENT = 0,
	ACPI_BATTERY_XINFO_PRESENT = 1,
	ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY = 2,
	ACPI_BATTERY_QUIRK_THINKPAD_MAH = 3,
	ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE = 4,
};

struct acpi_battery {
	struct mutex lock;
	struct mutex sysfs_lock;
	struct power_supply *bat;
	struct power_supply_desc bat_desc;
	struct acpi_device *device;
	struct notifier_block pm_nb;
	struct list_head list;
	unsigned long update_time;
	int revision;
	int rate_now;
	int capacity_now;
	int voltage_now;
	int design_capacity;
	int full_charge_capacity;
	int technology;
	int design_voltage;
	int design_capacity_warning;
	int design_capacity_low;
	int cycle_count;
	int measurement_accuracy;
	int max_sampling_time;
	int min_sampling_time;
	int max_averaging_interval;
	int min_averaging_interval;
	int capacity_granularity_1;
	int capacity_granularity_2;
	int alarm;
	char model_number[64];
	char serial_number[64];
	char type[64];
	char oem_info[64];
	int state;
	int power_unit;
	unsigned long flags;
};

struct acpi_battery_hook {
	const char *name;
	int (*add_battery)(struct power_supply *, struct acpi_battery_hook *);
	int (*remove_battery)(struct power_supply *, struct acpi_battery_hook *);
	struct list_head list;
};

enum rs9_model {
	RENESAS_9FGV0241 = 0,
	RENESAS_9FGV0441 = 1,
};

struct rs9_chip_info {
	const enum rs9_model model;
	unsigned int num_clks;
	u8 did;
};

struct rs9_driver_data {
	struct i2c_client *client;
	struct regmap *regmap;
	const struct rs9_chip_info *chip_info;
	struct clk_hw *clk_dif[4];
	u8 pll_amplitude;
	u8 pll_ssc;
	u8 clk_dif_sr;
};

struct hi3660_stub_clk_chan {
	struct mbox_client cl;
	struct mbox_chan *mbox;
};

struct hi3660_stub_clk {
	unsigned int id;
	struct clk_hw hw;
	unsigned int cmd;
	unsigned int msg[8];
	unsigned int rate;
};

struct mtk_clk_rst_data {
	struct regmap *regmap;
	struct reset_controller_dev rcdev;
	const struct mtk_clk_rst_desc *desc;
};

struct clk_regmap_mux_div {
	u32 reg_offset;
	u32 hid_width;
	u32 hid_shift;
	u32 src_width;
	u32 src_shift;
	u32 div;
	u32 src;
	const u32 *parent_map;
	struct clk_regmap clkr;
	struct clk *pclk;
	struct notifier_block clk_nb;
};

enum clk_ids___7 {
	LAST_DT_CORE_CLK___7 = 52,
	CLK_EXTAL___7 = 53,
	CLK_EXTALR___7 = 54,
	CLK_MAIN___7 = 55,
	CLK_PLL0___5 = 56,
	CLK_PLL1___7 = 57,
	CLK_PLL2___4 = 58,
	CLK_PLL3___6 = 59,
	CLK_PLL4___5 = 60,
	CLK_PLL1_DIV2___7 = 61,
	CLK_PLL1_DIV4___5 = 62,
	CLK_S0___5 = 63,
	CLK_S1___5 = 64,
	CLK_S2___4 = 65,
	CLK_S3___5 = 66,
	CLK_SDSRC___6 = 67,
	CLK_SSPSRC___2 = 68,
	CLK_RPCSRC___6 = 69,
	CLK_RINT___4 = 70,
	MOD_CLK_BASE___7 = 71,
};

struct clk_rk3399_inits {
	void (*inits)(struct device_node *);
};

enum {
	APPLE_RTKIT_PWR_STATE_OFF = 0,
	APPLE_RTKIT_PWR_STATE_SLEEP = 1,
	APPLE_RTKIT_PWR_STATE_IDLE = 513,
	APPLE_RTKIT_PWR_STATE_QUIESCED = 16,
	APPLE_RTKIT_PWR_STATE_ON = 32,
};

enum {
	APPLE_RTKIT_MGMT_HELLO = 1,
	APPLE_RTKIT_MGMT_HELLO_REPLY = 2,
	APPLE_RTKIT_MGMT_STARTEP = 5,
	APPLE_RTKIT_MGMT_SET_IOP_PWR_STATE = 6,
	APPLE_RTKIT_MGMT_SET_IOP_PWR_STATE_ACK = 7,
	APPLE_RTKIT_MGMT_EPMAP = 8,
	APPLE_RTKIT_MGMT_EPMAP_REPLY = 8,
	APPLE_RTKIT_MGMT_SET_AP_PWR_STATE = 11,
	APPLE_RTKIT_MGMT_SET_AP_PWR_STATE_ACK = 11,
};

enum {
	APPLE_RTKIT_EP_MGMT = 0,
	APPLE_RTKIT_EP_CRASHLOG = 1,
	APPLE_RTKIT_EP_SYSLOG = 2,
	APPLE_RTKIT_EP_DEBUG = 3,
	APPLE_RTKIT_EP_IOREPORT = 4,
	APPLE_RTKIT_EP_OSLOG = 8,
};

struct apple_rtkit_rx_work {
	struct apple_rtkit *rtk;
	u8 ep;
	u64 msg;
	struct work_struct work;
};

struct apple_rtkit_msg {
	struct completion *completion;
	struct apple_mbox_msg mbox_msg;
};

struct rsc_hdr {
	__le16 slv_id;
	__le16 header_offset;
	__le16 data_offset;
	__le16 cnt;
	__le16 version;
	__le16 reserved[3];
};

struct cmd_db_header {
	__le32 version;
	u8 magic[4];
	struct rsc_hdr header[8];
	__le32 checksum;
	__le32 reserved;
	u8 data[0];
};

struct entry_header {
	u8 id[8];
	__le32 priority[2];
	__le32 addr;
	__le16 len;
	__le16 offset;
};

struct zynqmp_pm_work_struct {
	struct work_struct callback_work;
	u32 args[4];
};

enum pm_suspend_mode {
	PM_SUSPEND_MODE_FIRST = 0,
	PM_SUSPEND_MODE_STD = 0,
	PM_SUSPEND_MODE_POWER_OFF = 1,
};

enum pm_api_cb_id {
	PM_INIT_SUSPEND_CB = 30,
	PM_ACKNOWLEDGE_CB = 31,
	PM_NOTIFY_CB = 32,
};

enum zynqmp_pm_suspend_reason {
	SUSPEND_POWER_REQUEST = 201,
	SUSPEND_ALERT = 202,
	SUSPEND_SYSTEM_SHUTDOWN = 203,
};

typedef void (*event_cb_func_t)(const u32 *, void *);

struct virtio_pci_legacy_device {
	struct pci_dev *pci_dev;
	u8 *isr;
	void *ioaddr;
	struct virtio_device_id id;
};

struct virtio_pci_vq_info;

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
	union {
		struct virtio_pci_legacy_device ldev;
		struct virtio_pci_modern_device mdev;
	};
	bool is_legacy;
	u8 *isr;
	spinlock_t lock;
	struct list_head virtqueues;
	struct virtio_pci_vq_info **vqs;
	int msix_enabled;
	int intx_enabled;
	cpumask_var_t *msix_affinity_masks;
	char (*msix_names)[256];
	unsigned int msix_vectors;
	unsigned int msix_used_vectors;
	bool per_vq_vectors;
	struct virtqueue * (*setup_vq)(struct virtio_pci_device *, struct virtio_pci_vq_info *, unsigned int, void (*)(struct virtqueue *), const char *, bool, u16);
	void (*del_vq)(struct virtio_pci_vq_info *);
	u16 (*config_vector)(struct virtio_pci_device *, u16);
};

struct virtio_pci_vq_info {
	struct virtqueue *vq;
	struct list_head node;
	unsigned int msix_vector;
};

struct rpmh_vreg_hw_data;

struct rpmh_vreg_init_data {
	const char *name;
	const char *resource_name;
	const char *supply_name;
	const struct rpmh_vreg_hw_data *hw_data;
};

enum rpmh_regulator_type {
	VRM = 0,
	XOB = 1,
};

struct rpmh_vreg_hw_data {
	enum rpmh_regulator_type regulator_type;
	const struct regulator_ops *ops;
	const struct linear_range voltage_range;
	int n_voltages;
	int hpm_min_load_uA;
	const int *pmic_mode_map;
	unsigned int (*of_map_mode)(unsigned int);
};

struct rpmh_vreg {
	struct device *dev;
	u32 addr;
	struct regulator_desc rdesc;
	const struct rpmh_vreg_hw_data *hw_data;
	bool always_wait_for_ack;
	int enabled;
	bool bypassed;
	int voltage_selector;
	unsigned int mode;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct compat_console_font_op {
	compat_uint_t op;
	compat_uint_t flags;
	compat_uint_t width;
	compat_uint_t height;
	compat_uint_t charcount;
	compat_caddr_t data;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct unimapdesc {
	unsigned short entry_ct;
	struct unipair __attribute__((btf_type_tag("user"))) *entries;
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	unsigned short kb_value;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

struct compat_unimapdesc {
	unsigned short entry_ct;
	compat_caddr_t entries;
};

struct vt_stat {
	unsigned short v_active;
	unsigned short v_signal;
	unsigned short v_state;
};

struct vt_sizes {
	unsigned short v_rows;
	unsigned short v_cols;
	unsigned short v_scrollsize;
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_consize {
	unsigned short v_rows;
	unsigned short v_cols;
	unsigned short v_vlin;
	unsigned short v_clin;
	unsigned short v_vcol;
	unsigned short v_ccol;
};

struct tpm1_get_random_out {
	__be32 rng_data_len;
	u8 rng_data[128];
};

typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_bulk_write)(void *, struct regmap *, unsigned int, const void *, int);

typedef void (*btf_trace_regmap_bulk_read)(void *, struct regmap *, unsigned int, const void *, int);

typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regcache_sync)(void *, struct regmap *, const char *, const char *);

typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap *);

typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap *, unsigned int, unsigned int);

struct trace_event_raw_regmap_reg {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	unsigned int val;
	char __data[0];
};

struct trace_event_raw_regmap_bulk {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	u32 __data_loc_buf;
	int val_len;
	char __data[0];
};

struct trace_event_raw_regmap_block {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	int count;
	char __data[0];
};

struct trace_event_raw_regcache_sync {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_status;
	u32 __data_loc_type;
	char __data[0];
};

struct trace_event_raw_regmap_bool {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flag;
	char __data[0];
};

struct trace_event_raw_regmap_async {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regcache_drop_region {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int from;
	unsigned int to;
	char __data[0];
};

struct trace_event_data_offsets_regmap_reg {
	u32 name;
};

struct trace_event_data_offsets_regmap_bulk {
	u32 name;
	u32 buf;
};

struct trace_event_data_offsets_regmap_block {
	u32 name;
};

struct trace_event_data_offsets_regcache_sync {
	u32 name;
	u32 status;
	u32 type;
};

struct trace_event_data_offsets_regmap_bool {
	u32 name;
};

struct trace_event_data_offsets_regmap_async {
	u32 name;
};

struct trace_event_data_offsets_regcache_drop_region {
	u32 name;
};

struct regmap_field {
	struct regmap *regmap;
	unsigned int mask;
	unsigned int shift;
	unsigned int reg;
	unsigned int id_size;
	unsigned int id_offset;
};

struct sram_config {
	int (*init)();
	bool map_only_reserved;
};

struct sram_reserve {
	struct list_head list;
	u32 start;
	u32 size;
	struct resource res;
	bool export;
	bool pool;
	bool protect_exec;
	const char *label;
};

struct sram_partition {
	void *base;
	struct gen_pool *pool;
	struct bin_attribute battr;
	struct mutex lock;
	struct list_head list;
};

struct sram_dev {
	const struct sram_config *config;
	struct device *dev;
	void *virt_base;
	bool no_memory_wc;
	struct gen_pool *pool;
	struct sram_partition *partition;
	u32 partitions;
};

struct hisi_sas_rst {
	struct hisi_hba *hisi_hba;
	struct completion *completion;
	struct work_struct work;
	bool done;
};

struct hisi_sas_internal_abort_data {
	bool rst_ha_timeout;
};

struct pata_platform_info {
	unsigned int ioport_shift;
};

enum nand_ecc_legacy_mode {
	NAND_ECC_INVALID = 0,
	NAND_ECC_NONE = 1,
	NAND_ECC_SOFT = 2,
	NAND_ECC_SOFT_BCH = 3,
	NAND_ECC_HW = 4,
	NAND_ECC_HW_SYNDROME = 5,
	NAND_ECC_ON_DIE = 6,
};

struct nand_op_parser_ctx {
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
	struct nand_subop subop;
};

struct nand_ecc_step_info;

struct nand_ecc_caps {
	const struct nand_ecc_step_info *stepinfos;
	int nstepinfos;
	int (*calc_ecc_bytes)(int, int);
};

struct nand_ecc_step_info {
	int stepsize;
	const int *strengths;
	int nstrengths;
};

enum dpaa_fq_type {
	FQ_TYPE_RX_DEFAULT = 1,
	FQ_TYPE_RX_ERROR = 2,
	FQ_TYPE_RX_PCD = 3,
	FQ_TYPE_TX = 4,
	FQ_TYPE_TX_CONFIRM = 5,
	FQ_TYPE_TX_CONF_MQ = 6,
	FQ_TYPE_TX_ERROR = 7,
};

struct dpaa_fq {
	struct qman_fq fq_base;
	struct list_head list;
	struct net_device *net_dev;
	bool init;
	u32 fqid;
	u32 flags;
	u16 channel;
	u8 wq;
	enum dpaa_fq_type fq_type;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

enum dsaf_port_rate_mode {
	DSAF_PORT_RATE_1000 = 0,
	DSAF_PORT_RATE_2500 = 1,
	DSAF_PORT_RATE_10000 = 2,
};

enum dsaf_roce_port_mode {
	DSAF_ROCE_6PORT_MODE = 0,
	DSAF_ROCE_4PORT_MODE = 1,
	DSAF_ROCE_2PORT_MODE = 2,
	DSAF_ROCE_CHAN_MODE_NUM = 3,
};

enum dsaf_stp_port_type {
	DSAF_STP_PORT_TYPE_DISCARD = 0,
	DSAF_STP_PORT_TYPE_BLOCK = 1,
	DSAF_STP_PORT_TYPE_LISTEN = 2,
	DSAF_STP_PORT_TYPE_LEARN = 3,
	DSAF_STP_PORT_TYPE_FORWARD = 4,
};

enum dsaf_sw_port_type {
	DSAF_SW_PORT_TYPE_NON_VLAN = 0,
	DSAF_SW_PORT_TYPE_ACCESS = 1,
	DSAF_SW_PORT_TYPE_TRUNK = 2,
};

struct dsaf_drv_soft_mac_tbl;

struct dsaf_drv_priv {
	struct dsaf_drv_soft_mac_tbl *soft_mac_tbl;
};

struct dsaf_drv_tbl_tcam_key {
	union {
		struct {
			u8 mac_3;
			u8 mac_2;
			u8 mac_1;
			u8 mac_0;
		} bits;
		u32 val;
	} high;
	union {
		struct {
			u16 port_vlan;
			u8 mac_5;
			u8 mac_4;
		} bits;
		u32 val;
	} low;
};

struct dsaf_drv_soft_mac_tbl {
	struct dsaf_drv_tbl_tcam_key tcam_key;
	u16 index;
};

struct dsaf_tbl_tcam_data {
	u32 tbl_tcam_data_high;
	u32 tbl_tcam_data_low;
};

struct dsaf_tbl_tcam_ucast_cfg {
	u32 tbl_ucast_old_en;
	u32 tbl_ucast_item_vld;
	u32 tbl_ucast_mac_discard;
	u32 tbl_ucast_dvc;
	u32 tbl_ucast_out_port;
};

struct dsaf_tbl_tcam_mcast_cfg {
	u8 tbl_mcast_old_en;
	u8 tbl_mcast_item_vld;
	u32 tbl_mcast_port_msk[5];
};

struct dsaf_tbl_line_cfg {
	u32 tbl_line_mac_discard;
	u32 tbl_line_dvc;
	u32 tbl_line_out_port;
};

struct hclge_mbx_vf_to_pf_cmd;

typedef void (*btf_trace_hclge_pf_mbx_get)(void *, struct hclge_dev *, struct hclge_mbx_vf_to_pf_cmd *);

struct hclge_ring_chain_param {
	u8 ring_type;
	u8 tqp_index;
	u8 int_gl_index;
};

struct hclge_vf_to_pf_msg {
	u8 code;
	union {
		struct {
			u8 subcode;
			u8 data[14];
		};
		struct {
			u8 en_bc;
			u8 en_uc;
			u8 en_mc;
			u8 en_limit_promisc;
		};
		struct {
			u8 vector_id;
			u8 ring_num;
			struct hclge_ring_chain_param param[4];
		};
	};
};

struct hclge_mbx_vf_to_pf_cmd {
	u8 rsv;
	u8 mbx_src_vfid;
	u8 mbx_need_resp;
	u8 rsv1[1];
	u8 msg_len;
	u8 rsv2;
	__le16 match_id;
	struct hclge_vf_to_pf_msg msg;
};

struct hclge_mbx_pf_to_vf_cmd;

typedef void (*btf_trace_hclge_pf_mbx_send)(void *, struct hclge_dev *, struct hclge_mbx_pf_to_vf_cmd *);

struct hclge_pf_to_vf_msg {
	__le16 code;
	union {
		struct {
			__le16 vf_mbx_msg_code;
			__le16 vf_mbx_msg_subcode;
			__le16 resp_status;
			u8 resp_data[8];
		};
		struct {
			u8 msg_data[14];
		};
	};
};

struct hclge_mbx_pf_to_vf_cmd {
	u8 dest_vfid;
	u8 rsv[3];
	u8 msg_len;
	u8 rsv1;
	__le16 match_id;
	struct hclge_pf_to_vf_msg msg;
};

struct hclge_mbx_ops_param;

typedef int (*hclge_mbx_ops_fn)(struct hclge_mbx_ops_param *);

struct hclge_respond_to_vf_msg;

struct hclge_mbx_ops_param {
	struct hclge_vport *vport;
	struct hclge_mbx_vf_to_pf_cmd *req;
	struct hclge_respond_to_vf_msg *resp_msg;
};

struct hclge_respond_to_vf_msg {
	int status;
	u8 data[8];
	u16 len;
};

enum HCLGE_MBX_OPCODE {
	HCLGE_MBX_RESET = 1,
	HCLGE_MBX_ASSERTING_RESET = 2,
	HCLGE_MBX_SET_UNICAST = 3,
	HCLGE_MBX_SET_MULTICAST = 4,
	HCLGE_MBX_SET_VLAN = 5,
	HCLGE_MBX_MAP_RING_TO_VECTOR = 6,
	HCLGE_MBX_UNMAP_RING_TO_VECTOR = 7,
	HCLGE_MBX_SET_PROMISC_MODE = 8,
	HCLGE_MBX_SET_MACVLAN = 9,
	HCLGE_MBX_API_NEGOTIATE = 10,
	HCLGE_MBX_GET_QINFO = 11,
	HCLGE_MBX_GET_QDEPTH = 12,
	HCLGE_MBX_GET_BASIC_INFO = 13,
	HCLGE_MBX_GET_RETA = 14,
	HCLGE_MBX_GET_RSS_KEY = 15,
	HCLGE_MBX_GET_MAC_ADDR = 16,
	HCLGE_MBX_PF_VF_RESP = 17,
	HCLGE_MBX_GET_BDNUM = 18,
	HCLGE_MBX_GET_BUFSIZE = 19,
	HCLGE_MBX_GET_STREAMID = 20,
	HCLGE_MBX_SET_AESTART = 21,
	HCLGE_MBX_SET_TSOSTATS = 22,
	HCLGE_MBX_LINK_STAT_CHANGE = 23,
	HCLGE_MBX_GET_BASE_CONFIG = 24,
	HCLGE_MBX_BIND_FUNC_QUEUE = 25,
	HCLGE_MBX_GET_LINK_STATUS = 26,
	HCLGE_MBX_QUEUE_RESET = 27,
	HCLGE_MBX_KEEP_ALIVE = 28,
	HCLGE_MBX_SET_ALIVE = 29,
	HCLGE_MBX_SET_MTU = 30,
	HCLGE_MBX_GET_QID_IN_PF = 31,
	HCLGE_MBX_LINK_STAT_MODE = 32,
	HCLGE_MBX_GET_LINK_MODE = 33,
	HCLGE_MBX_PUSH_VLAN_INFO = 34,
	HCLGE_MBX_GET_MEDIA_TYPE = 35,
	HCLGE_MBX_PUSH_PROMISC_INFO = 36,
	HCLGE_MBX_VF_UNINIT = 37,
	HCLGE_MBX_HANDLE_VF_TBL = 38,
	HCLGE_MBX_GET_RING_VECTOR_MAP = 39,
	HCLGE_MBX_GET_VF_FLR_STATUS = 200,
	HCLGE_MBX_PUSH_LINK_STATUS = 201,
	HCLGE_MBX_NCSI_ERROR = 202,
};

enum hclge_mbx_mac_vlan_subcode {
	HCLGE_MBX_MAC_VLAN_UC_MODIFY = 0,
	HCLGE_MBX_MAC_VLAN_UC_ADD = 1,
	HCLGE_MBX_MAC_VLAN_UC_REMOVE = 2,
	HCLGE_MBX_MAC_VLAN_MC_MODIFY = 3,
	HCLGE_MBX_MAC_VLAN_MC_ADD = 4,
	HCLGE_MBX_MAC_VLAN_MC_REMOVE = 5,
};

enum hclge_mbx_vlan_cfg_subcode {
	HCLGE_MBX_VLAN_FILTER = 0,
	HCLGE_MBX_VLAN_TX_OFF_CFG = 1,
	HCLGE_MBX_VLAN_RX_OFF_CFG = 2,
	HCLGE_MBX_PORT_BASE_VLAN_CFG = 3,
	HCLGE_MBX_GET_PORT_BASE_VLAN_STATE = 4,
	HCLGE_MBX_ENABLE_VLAN_FILTER = 5,
};

enum HNAE3_PF_CAP_BITS {
	HNAE3_PF_SUPPORT_VLAN_FLTR_MDF_B = 0,
};

enum hclge_mbx_tbl_cfg_subcode {
	HCLGE_MBX_VPORT_LIST_CLEAR = 0,
};

enum hclge_link_fail_code {
	HCLGE_LF_NORMAL = 0,
	HCLGE_LF_REF_CLOCK_LOST = 1,
	HCLGE_LF_XSFP_TX_DISABLE = 2,
	HCLGE_LF_XSFP_ABSENT = 3,
};

struct trace_event_raw_hclge_pf_mbx_get {
	struct trace_entry ent;
	u8 vfid;
	u8 code;
	u8 subcode;
	u32 __data_loc_pciname;
	u32 __data_loc_devname;
	u32 mbx_data[6];
	char __data[0];
};

struct trace_event_raw_hclge_pf_mbx_send {
	struct trace_entry ent;
	u8 vfid;
	u16 code;
	u32 __data_loc_pciname;
	u32 __data_loc_devname;
	u32 mbx_data[6];
	char __data[0];
};

struct hclge_vf_vlan_cfg {
	u8 mbx_cmd;
	u8 subcode;
	union {
		struct {
			u8 is_kill;
			__le16 vlan;
			__le16 proto;
		} __attribute__((packed));
		u8 enable;
	};
};

struct hclge_mbx_vf_queue_info {
	__le16 num_tqps;
	__le16 rss_size;
	__le16 rx_buf_len;
};

struct hclge_mbx_vf_queue_depth {
	__le16 num_tx_desc;
	__le16 num_rx_desc;
};

struct hclge_basic_info {
	u8 hw_tc_map;
	u8 rsv;
	__le16 mbx_api_version;
	__le32 pf_caps;
};

struct hclge_mbx_mtu_info {
	__le32 mtu;
};

struct trace_event_data_offsets_hclge_pf_mbx_get {
	u32 pciname;
	u32 devname;
};

struct trace_event_data_offsets_hclge_pf_mbx_send {
	u32 pciname;
	u32 devname;
};

struct hclge_mbx_link_status {
	__le16 link_status;
	__le32 speed;
	__le16 duplex;
	u8 flag;
} __attribute__((packed));

struct hclge_mbx_port_base_vlan {
	__le16 state;
	__le16 vlan_proto;
	__le16 qos;
	__le16 vlan_tag;
};

struct hclge_mbx_link_mode {
	__le16 idx;
	__le64 link_mode;
} __attribute__((packed));

enum ssusb_uwk_vers___2 {
	SSUSB_UWK_V1___2 = 1,
	SSUSB_UWK_V2___2 = 2,
	SSUSB_UWK_V1_1___2 = 101,
	SSUSB_UWK_V1_2___2 = 102,
	SSUSB_UWK_V1_3 = 103,
	SSUSB_UWK_V1_4 = 104,
	SSUSB_UWK_V1_5 = 105,
	SSUSB_UWK_V1_6 = 106,
};

struct usbmisc_ops {
	int (*init)(struct imx_usbmisc_data *);
	int (*post)(struct imx_usbmisc_data *);
	int (*set_wakeup)(struct imx_usbmisc_data *, bool);
	int (*hsic_set_connect)(struct imx_usbmisc_data *);
	int (*hsic_set_clk)(struct imx_usbmisc_data *, bool);
	int (*charger_detection)(struct imx_usbmisc_data *);
	int (*power_lost_check)(struct imx_usbmisc_data *);
	void (*vbus_comparator_on)(struct imx_usbmisc_data *, bool);
};

struct imx_usbmisc {
	void *base;
	spinlock_t lock;
	const struct usbmisc_ops *ops;
};

struct evdev;

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	unsigned long *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client __attribute__((btf_type_tag("rcu"))) *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct pl031_vendor_data {
	struct rtc_class_ops ops;
	bool clockwatch;
	bool st_weekday;
	unsigned long irqflags;
	time64_t range_min;
	timeu64_t range_max;
};

struct pl031_local {
	struct pl031_vendor_data *vendor;
	struct rtc_device *rtc;
	void *base;
};

enum smcwd_call {
	SMCWD_INIT = 0,
	SMCWD_SET_TIMEOUT = 1,
	SMCWD_ENABLE = 2,
	SMCWD_PET = 3,
	SMCWD_GET_TIMELEFT = 4,
};

struct owl_mmc_host {
	struct device *dev;
	struct reset_control *reset;
	void *base;
	struct clk *clk;
	struct completion sdc_complete;
	spinlock_t lock;
	int irq;
	u32 clock;
	bool ddr_50;
	enum dma_data_direction dma_dir;
	struct dma_chan *dma;
	struct dma_async_tx_descriptor *desc;
	struct dma_slave_config dma_cfg;
	struct completion dma_complete;
	struct mmc_host *mmc;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
};

struct dmi_device_attribute {
	struct device_attribute dev_attr;
	int field;
};

struct mafield {
	const char *prefix;
	int field;
};

struct cper_arm_ctx_info {
	u16 version;
	u16 type;
	u32 size;
};

enum imx_sc_rm_func {
	IMX_SC_RM_FUNC_UNKNOWN = 0,
	IMX_SC_RM_FUNC_PARTITION_ALLOC = 1,
	IMX_SC_RM_FUNC_SET_CONFIDENTIAL = 31,
	IMX_SC_RM_FUNC_PARTITION_FREE = 2,
	IMX_SC_RM_FUNC_GET_DID = 26,
	IMX_SC_RM_FUNC_PARTITION_STATIC = 3,
	IMX_SC_RM_FUNC_PARTITION_LOCK = 4,
	IMX_SC_RM_FUNC_GET_PARTITION = 5,
	IMX_SC_RM_FUNC_SET_PARENT = 6,
	IMX_SC_RM_FUNC_MOVE_ALL = 7,
	IMX_SC_RM_FUNC_ASSIGN_RESOURCE = 8,
	IMX_SC_RM_FUNC_SET_RESOURCE_MOVABLE = 9,
	IMX_SC_RM_FUNC_SET_SUBSYS_RSRC_MOVABLE = 28,
	IMX_SC_RM_FUNC_SET_MASTER_ATTRIBUTES = 10,
	IMX_SC_RM_FUNC_SET_MASTER_SID = 11,
	IMX_SC_RM_FUNC_SET_PERIPHERAL_PERMISSIONS = 12,
	IMX_SC_RM_FUNC_IS_RESOURCE_OWNED = 13,
	IMX_SC_RM_FUNC_GET_RESOURCE_OWNER = 33,
	IMX_SC_RM_FUNC_IS_RESOURCE_MASTER = 14,
	IMX_SC_RM_FUNC_IS_RESOURCE_PERIPHERAL = 15,
	IMX_SC_RM_FUNC_GET_RESOURCE_INFO = 16,
	IMX_SC_RM_FUNC_MEMREG_ALLOC = 17,
	IMX_SC_RM_FUNC_MEMREG_SPLIT = 29,
	IMX_SC_RM_FUNC_MEMREG_FRAG = 32,
	IMX_SC_RM_FUNC_MEMREG_FREE = 18,
	IMX_SC_RM_FUNC_FIND_MEMREG = 30,
	IMX_SC_RM_FUNC_ASSIGN_MEMREG = 19,
	IMX_SC_RM_FUNC_SET_MEMREG_PERMISSIONS = 20,
	IMX_SC_RM_FUNC_IS_MEMREG_OWNED = 21,
	IMX_SC_RM_FUNC_GET_MEMREG_INFO = 22,
	IMX_SC_RM_FUNC_ASSIGN_PAD = 23,
	IMX_SC_RM_FUNC_SET_PAD_MOVABLE = 24,
	IMX_SC_RM_FUNC_IS_PAD_OWNED = 25,
	IMX_SC_RM_FUNC_DUMP = 27,
};

struct imx_sc_msg_rm_rsrc_owned {
	struct imx_sc_rpc_msg hdr;
	u16 resource;
	long: 0;
};

struct imx_sc_msg_rm_get_resource_owner {
	struct imx_sc_rpc_msg hdr;
	union {
		struct {
			u16 resource;
		} req;
		struct {
			u8 val;
		} resp;
	} data;
	long: 0;
};

struct qcom_scm {
	struct device *dev;
	struct clk *core_clk;
	struct clk *iface_clk;
	struct clk *bus_clk;
	struct icc_path *path;
	struct completion waitq_comp;
	struct reset_controller_dev reset;
	struct mutex scm_bw_lock;
	int scm_vote_count;
	u64 dload_mode_addr;
};

enum qcom_scm_arg_types {
	QCOM_SCM_VAL = 0,
	QCOM_SCM_RO = 1,
	QCOM_SCM_RW = 2,
	QCOM_SCM_BUFVAL = 3,
};

enum qcom_scm_ocmem_client {
	QCOM_SCM_OCMEM_UNUSED_ID = 0,
	QCOM_SCM_OCMEM_GRAPHICS_ID = 1,
	QCOM_SCM_OCMEM_VIDEO_ID = 2,
	QCOM_SCM_OCMEM_LP_AUDIO_ID = 3,
	QCOM_SCM_OCMEM_SENSORS_ID = 4,
	QCOM_SCM_OCMEM_OTHER_OS_ID = 5,
	QCOM_SCM_OCMEM_DEBUG_ID = 6,
};

enum qcom_scm_ice_cipher {
	QCOM_SCM_ICE_CIPHER_AES_128_XTS = 0,
	QCOM_SCM_ICE_CIPHER_AES_128_CBC = 1,
	QCOM_SCM_ICE_CIPHER_AES_256_XTS = 3,
	QCOM_SCM_ICE_CIPHER_AES_256_CBC = 4,
};

struct qcom_scm_pas_metadata {
	void *ptr;
	dma_addr_t phys;
	ssize_t size;
};

struct qcom_scm_vmperm {
	int vmid;
	int perm;
};

struct qcom_scm_mem_map_info {
	__le64 mem_addr;
	__le64 mem_size;
};

struct qcom_scm_current_perm_info {
	__le32 vmid;
	__le32 perm;
	__le64 ctx;
	__le32 ctx_size;
	__le32 unused;
};

struct qcom_scm_hdcp_req {
	u32 addr;
	u32 val;
};

struct omap_dm_timer_ops;

struct dmtimer_platform_data {
	int (*set_timer_src)(struct platform_device *, int);
	u32 timer_capability;
	u32 timer_errata;
	int (*get_context_loss_count)(struct device *);
	const struct omap_dm_timer_ops *timer_ops;
};

struct omap_dm_timer;

struct omap_dm_timer_ops {
	struct omap_dm_timer * (*request_by_node)(struct device_node *);
	struct omap_dm_timer * (*request_specific)(int);
	struct omap_dm_timer * (*request)();
	int (*free)(struct omap_dm_timer *);
	void (*enable)(struct omap_dm_timer *);
	void (*disable)(struct omap_dm_timer *);
	int (*get_irq)(struct omap_dm_timer *);
	int (*set_int_enable)(struct omap_dm_timer *, unsigned int);
	int (*set_int_disable)(struct omap_dm_timer *, u32);
	struct clk * (*get_fclk)(struct omap_dm_timer *);
	int (*start)(struct omap_dm_timer *);
	int (*stop)(struct omap_dm_timer *);
	int (*set_source)(struct omap_dm_timer *, int);
	int (*set_load)(struct omap_dm_timer *, unsigned int);
	int (*set_match)(struct omap_dm_timer *, int, unsigned int);
	int (*set_pwm)(struct omap_dm_timer *, int, int, int, int);
	int (*get_pwm_status)(struct omap_dm_timer *);
	int (*set_prescaler)(struct omap_dm_timer *, int);
	unsigned int (*read_counter)(struct omap_dm_timer *);
	int (*write_counter)(struct omap_dm_timer *, unsigned int);
	unsigned int (*read_status)(struct omap_dm_timer *);
	int (*write_status)(struct omap_dm_timer *, unsigned int);
};

struct omap_dm_timer {};

enum {
	REQUEST_ANY = 0,
	REQUEST_BY_ID = 1,
	REQUEST_BY_CAP = 2,
	REQUEST_BY_NODE = 3,
};

struct timer_regs {
	u32 ocp_cfg;
	u32 tidr;
	u32 tier;
	u32 twer;
	u32 tclr;
	u32 tcrr;
	u32 tldr;
	u32 ttrg;
	u32 twps;
	u32 tmar;
	u32 tcar1;
	u32 tsicr;
	u32 tcar2;
	u32 tpir;
	u32 tnir;
	u32 tcvr;
	u32 tocr;
	u32 towr;
};

struct dmtimer {
	struct omap_dm_timer cookie;
	int id;
	int irq;
	struct clk *fclk;
	void *io_base;
	int irq_stat;
	int irq_ena;
	int irq_dis;
	void *pend;
	void *func_base;
	atomic_t enabled;
	unsigned long rate;
	unsigned int reserved: 1;
	unsigned int posted: 1;
	unsigned int omap1: 1;
	struct timer_regs context;
	int revision;
	u32 capability;
	u32 errata;
	struct platform_device *pdev;
	struct list_head node;
	struct notifier_block nb;
	struct notifier_block fclk_nb;
	unsigned long fclk_rate;
};

typedef int (*cros_ec_xfer_fn_t)(struct cros_ec_device *, struct cros_ec_command *);

struct cros_ec_xfer_work_params {
	struct kthread_work work;
	cros_ec_xfer_fn_t fn;
	struct cros_ec_device *ec_dev;
	struct cros_ec_command *ec_msg;
	int ret;
};

struct cros_ec_spi {
	struct spi_device *spi;
	s64 last_transfer_ns;
	unsigned int start_of_msg_delay;
	unsigned int end_of_msg_delay;
	struct kthread_worker *high_pri_worker;
};

struct mca_data;

struct mca_cluster {
	int no;
	void *base;
	struct mca_data *host;
	struct device *pd_dev;
	struct clk *clk_parent;
	struct dma_chan *dma_chans[2];
	bool port_started[2];
	int port_driver;
	bool clocks_in_use[2];
	struct device_link *pd_link;
	unsigned int bclk_ratio;
	int tdm_slots;
	int tdm_slot_width;
	unsigned int tdm_tx_mask;
	unsigned int tdm_rx_mask;
};

struct mca_data {
	struct device *dev;
	void *switch_base;
	struct device *pd_dev;
	struct reset_control *rstc;
	struct device_link *pd_link;
	struct mutex port_mutex;
	int nclusters;
	struct mca_cluster clusters[0];
};

enum hwtstamp_flags {
	HWTSTAMP_FLAG_BONDED_PHC_INDEX = 1,
	HWTSTAMP_FLAG_LAST = 1,
	HWTSTAMP_FLAG_MASK = 1,
};

struct compat_ifconf {
	compat_int_t ifc_len;
	compat_caddr_t ifcbuf;
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	__ETHTOOL_A_CABLE_RESULT_CNT = 3,
	ETHTOOL_A_CABLE_RESULT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 3,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
} __attribute__((packed));

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
} __attribute__((packed));

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct compat_group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		} __attribute__((packed));
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		} __attribute__((packed));
	};
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

struct icmp_control {
	enum skb_drop_reason (*handler)(struct sk_buff *);
	short error;
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_ext_echo_ctype3_hdr {
	__be16 afi;
	__u8 addrlen;
	__u8 reserved;
};

struct icmp_ext_echo_iio {
	struct icmp_extobj_hdr extobj_hdr;
	union {
		char name[16];
		__be32 ifindex;
		struct {
			struct icmp_ext_echo_ctype3_hdr ctype3_hdr;
			union {
				__be32 ipv4_addr;
				struct in6_addr ipv6_addr;
			} ip_addr;
		} addr;
	} ident;
};

struct xdr_array2_desc;

typedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *, void *);

struct xdr_array2_desc {
	unsigned int elem_size;
	unsigned int array_len;
	unsigned int array_maxlen;
	xdr_xcode_elem_t xcode;
};

enum {
	Rworksched = 1,
	Rpending = 2,
	Wworksched = 4,
	Wpending = 8,
};

enum {
	Opt_port___2 = 0,
	Opt_rfdno = 1,
	Opt_wfdno = 2,
	Opt_err___8 = 3,
	Opt_privport = 4,
};

struct p9_conn;

struct p9_poll_wait {
	struct p9_conn *conn;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_addr;
};

struct p9_conn {
	struct list_head mux_list;
	struct p9_client *client;
	int err;
	spinlock_t req_lock;
	struct list_head req_list;
	struct list_head unsent_req_list;
	struct p9_req_t *rreq;
	struct p9_req_t *wreq;
	char tmp_buf[7];
	struct p9_fcall rc;
	int wpos;
	int wsize;
	char *wbuf;
	struct list_head poll_pending_link;
	struct p9_poll_wait poll_wait[2];
	poll_table pt;
	struct work_struct rq;
	struct work_struct wq;
	unsigned long wsched;
};

struct p9_trans_fd {
	struct file *rd;
	struct file *wr;
	struct p9_conn conn;
};

struct p9_fd_opts {
	int rfd;
	int wfd;
	u16 port;
	bool privport;
};

typedef void (*btf_trace_kvm_wfx_arm64)(void *, unsigned long, bool);

typedef void (*btf_trace_kvm_hvc_arm64)(void *, unsigned long, unsigned long, unsigned long);

typedef void (*btf_trace_kvm_arm_setup_debug)(void *, struct kvm_vcpu *, __u32);

typedef void (*btf_trace_kvm_arm_clear_debug)(void *, __u32);

typedef void (*btf_trace_kvm_arm_set_dreg32)(void *, const char *, __u64);

typedef void (*btf_trace_kvm_arm_set_regset)(void *, const char *, int, __u64 *, __u64 *);

typedef void (*btf_trace_trap_reg)(void *, const char *, int, bool, u64);

typedef void (*btf_trace_kvm_handle_sys_reg)(void *, unsigned long);

typedef void (*btf_trace_kvm_sys_access)(void *, unsigned long, struct sys_reg_params *, const struct sys_reg_desc *);

typedef void (*btf_trace_kvm_set_guest_debug)(void *, struct kvm_vcpu *, __u32);

typedef int (*exit_handle_fn)(struct kvm_vcpu *);

struct trace_event_raw_kvm_wfx_arm64 {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	bool is_wfe;
	char __data[0];
};

struct trace_event_raw_kvm_hvc_arm64 {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	unsigned long r0;
	unsigned long imm;
	char __data[0];
};

struct trace_event_raw_kvm_arm_setup_debug {
	struct trace_entry ent;
	struct kvm_vcpu *vcpu;
	__u32 guest_debug;
	char __data[0];
};

struct trace_event_raw_kvm_arm_clear_debug {
	struct trace_entry ent;
	__u32 guest_debug;
	char __data[0];
};

struct trace_event_raw_kvm_arm_set_dreg32 {
	struct trace_entry ent;
	const char *name;
	__u64 value;
	char __data[0];
};

struct trace_event_raw_kvm_arm_set_regset {
	struct trace_entry ent;
	const char *name;
	int len;
	u64 ctrls[16];
	u64 values[16];
	char __data[0];
};

struct trace_event_raw_trap_reg {
	struct trace_entry ent;
	const char *fn;
	int reg;
	bool is_write;
	u64 write_value;
	char __data[0];
};

struct trace_event_raw_kvm_handle_sys_reg {
	struct trace_entry ent;
	unsigned long hsr;
	char __data[0];
};

struct trace_event_raw_kvm_sys_access {
	struct trace_entry ent;
	unsigned long vcpu_pc;
	bool is_write;
	const char *name;
	u8 Op0;
	u8 Op1;
	u8 CRn;
	u8 CRm;
	u8 Op2;
	char __data[0];
};

struct trace_event_raw_kvm_set_guest_debug {
	struct trace_entry ent;
	struct kvm_vcpu *vcpu;
	__u32 guest_debug;
	char __data[0];
};

struct trace_event_data_offsets_kvm_wfx_arm64 {};

struct trace_event_data_offsets_kvm_hvc_arm64 {};

struct trace_event_data_offsets_kvm_arm_setup_debug {};

struct trace_event_data_offsets_kvm_arm_clear_debug {};

struct trace_event_data_offsets_kvm_arm_set_dreg32 {};

struct trace_event_data_offsets_kvm_arm_set_regset {};

struct trace_event_data_offsets_trap_reg {};

struct trace_event_data_offsets_kvm_handle_sys_reg {};

struct trace_event_data_offsets_kvm_sys_access {};

struct trace_event_data_offsets_kvm_set_guest_debug {};

struct vgic_state_iter {
	int nr_cpus;
	int nr_spis;
	int nr_lpis;
	int dist_id;
	int vcpu_id;
	int intid;
	int lpi_idx;
	u32 *lpi_array;
};

struct sha256_ce_state {
	struct sha256_state sst;
	u32 finalize;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

struct mcs_spinlock {
	struct mcs_spinlock *next;
	int locked;
	int count;
};

struct qnode {
	struct mcs_spinlock mcs;
};

typedef void (*btf_trace_console)(void *, const char *, size_t);

struct prb_desc;

struct printk_info;

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
	atomic_long_t last_finalized_id;
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prb_data_blk_lpos {
	unsigned long begin;
	unsigned long next;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_buffers {
	char outbuf[2048];
	char scratchbuf[1024];
};

struct latched_seq {
	seqcount_latch_t latch;
	u64 val[2];
};

struct console_cmdline {
	char name[16];
	int index;
	bool user_specified;
	char *options;
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum printk_info_flags {
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_console {
	u32 msg;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	unsigned long irqflags;
	unsigned long id;
	unsigned int text_space;
};

struct printk_message {
	struct printk_buffers *pbufs;
	unsigned int outbuf_len;
	u64 seq;
	unsigned long dropped;
};

struct devkmsg_user {
	atomic64_t seq;
	struct ratelimit_state rs;
	struct mutex lock;
	struct printk_buffers pbufs;
};

struct tk_fast {
	seqcount_latch_t seq;
	struct tk_read_base base[2];
};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

struct ktime_timestamps {
	u64 mono;
	u64 boot;
	u64 real;
};

struct bsd_acct_struct {
	struct fs_pin pin;
	atomic_long_t count;
	struct callback_head rcu;
	struct mutex lock;
	int active;
	unsigned long needcheck;
	struct file *file;
	struct pid_namespace *ns;
	struct work_struct work;
	struct completion done;
};

typedef __u16 comp_t;

struct acct_v3 {
	char ac_flag;
	char ac_version;
	__u16 ac_tty;
	__u32 ac_exitcode;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u32 ac_etime;
	comp_t ac_utime;
	comp_t ac_stime;
	comp_t ac_mem;
	comp_t ac_io;
	comp_t ac_rw;
	comp_t ac_minflt;
	comp_t ac_majflt;
	comp_t ac_swaps;
	char ac_comm[16];
};

typedef struct acct_v3 acct_t;

struct audit_rule_data {
	__u32 flags;
	__u32 action;
	__u32 field_count;
	__u32 mask[64];
	__u32 fields[64];
	__u32 values[64];
	__u32 fieldflags[64];
	__u32 buflen;
	char buf[0];
};

struct user_event_group {
	char *system_name;
	struct hlist_node node;
	struct mutex reg_mutex;
	struct hlist_head register_table[256];
};

enum user_reg_flag {
	USER_EVENT_REG_PERSIST = 1,
	USER_EVENT_REG_MAX = 2,
};

struct user_event;

struct user_event_enabler {
	struct list_head mm_enablers_link;
	struct user_event *event;
	unsigned long addr;
	unsigned long values;
};

struct user_event {
	struct user_event_group *group;
	struct tracepoint tracepoint;
	struct trace_event_call call;
	struct trace_event_class class;
	struct dyn_event devent;
	struct hlist_node node;
	struct list_head fields;
	struct list_head validators;
	struct work_struct put_work;
	refcount_t refcnt;
	int min_size;
	int reg_flags;
	char status;
};

struct user_event_validator {
	struct list_head user_event_link;
	int offset;
	int flags;
};

struct user_event_refs {
	struct callback_head rcu;
	int count;
	struct user_event *events[0];
};

struct user_reg {
	__u32 size;
	__u8 enable_bit;
	__u8 enable_size;
	__u16 flags;
	__u64 enable_addr;
	__u64 name_args;
	__u32 write_index;
} __attribute__((packed));

struct user_event_enabler_fault {
	struct work_struct work;
	struct user_event_mm *mm;
	struct user_event_enabler *enabler;
	int attempt;
};

struct user_unreg {
	__u32 size;
	__u8 disable_bit;
	__u8 __reserved;
	__u16 __reserved2;
	__u64 disable_addr;
};

struct user_event_file_info {
	struct user_event_group *group;
	struct user_event_refs *refs;
};

typedef void (*user_event_func_t)(struct user_event *, struct iov_iter *, void *, bool *);

struct bpf_bloom_filter {
	struct bpf_map map;
	u32 bitset_mask;
	u32 hash_seed;
	u32 nr_hash_funcs;
	unsigned long bitset[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
	BPF_STRUCT_OPS_STATE_READY = 3,
};

struct bpf_dummy_ops_state;

struct bpf_dummy_ops {
	int (*test_1)(struct bpf_dummy_ops_state *);
	int (*test_2)(struct bpf_dummy_ops_state *, int, unsigned short, char, unsigned long);
	int (*test_sleepable)(struct bpf_dummy_ops_state *);
};

struct bpf_struct_ops_bpf_dummy_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bpf_dummy_ops data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_dummy_ops_state {
	int val;
};

struct bpf_struct_ops_tcp_congestion_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct tcp_congestion_ops data;
};

struct bpf_struct_ops_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	struct callback_head rcu;
	const struct bpf_struct_ops *st_ops;
	struct mutex lock;
	struct bpf_link **links;
	void *image;
	struct bpf_struct_ops_value *uvalue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bpf_struct_ops_value kvalue;
};

struct bpf_struct_ops_link {
	struct bpf_link link;
	struct bpf_map __attribute__((btf_type_tag("rcu"))) *map;
};

typedef void (*btf_trace_percpu_alloc_percpu)(void *, unsigned long, bool, bool, size_t, size_t, void *, int, void __attribute__((btf_type_tag("percpu"))) *, size_t, gfp_t);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void __attribute__((btf_type_tag("percpu"))) *);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	unsigned long *bound_map;
	void *base_addr;
	unsigned long *alloc_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	bool isolated;
	int start_offset;
	int end_offset;
	struct obj_cgroup **obj_cgroups;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	unsigned long populated[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	unsigned long call_site;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void __attribute__((btf_type_tag("percpu"))) *ptr;
	size_t bytes_alloc;
	unsigned long gfp_flags;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void __attribute__((btf_type_tag("percpu"))) *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct pcpu_group_info {
	int nr_units;
	unsigned long base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

struct swap_extent {
	struct rb_node rb_node;
	unsigned long start_page;
	unsigned long nr_pages;
	sector_t start_block;
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

struct nfs_ssc_client_ops_tbl {
	const struct nfs4_ssc_client_ops *ssc_nfs4_ops;
	const struct nfs_ssc_client_ops *ssc_nfs_ops;
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct ext4_new_group_input {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head __attribute__((btf_type_tag("user"))) *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

struct fsuuid {
	__u32 fsu_len;
	__u32 fsu_flags;
	__u8 fsu_uuid[0];
};

typedef void ext4_update_sb_callback(struct ext4_super_block *, const void *);

struct compat_ext4_new_group_input {
	u32 group;
	compat_u64 block_bitmap;
	compat_u64 inode_bitmap;
	compat_u64 inode_table;
	u32 blocks_count;
	u16 reserved_blocks;
	u16 unused;
};

enum nfs3_ftype {
	NF3NON = 0,
	NF3REG = 1,
	NF3DIR = 2,
	NF3BLK = 3,
	NF3CHR = 4,
	NF3LNK = 5,
	NF3SOCK = 6,
	NF3FIFO = 7,
	NF3BAD = 8,
};

enum nfs3_createmode {
	NFS3_CREATE_UNCHECKED = 0,
	NFS3_CREATE_GUARDED = 1,
	NFS3_CREATE_EXCLUSIVE = 2,
};

struct nfs3_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
	unsigned int guard;
	struct timespec64 guardtime;
};

struct nfs3_accessargs {
	struct nfs_fh *fh;
	__u32 access;
};

struct nfs3_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
	enum nfs3_createmode createmode;
	__be32 verifier[2];
};

struct nfs3_diropres {
	struct nfs_fattr *dir_attr;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs3_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs3_mknodargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	enum nfs3_ftype type;
	struct iattr *sattr;
	dev_t rdev;
};

struct nfs3_readdirargs {
	struct nfs_fh *fh;
	__u64 cookie;
	__be32 verf[2];
	bool plus;
	unsigned int count;
	struct page **pages;
};

struct nfs3_readdirres {
	struct nfs_fattr *dir_attr;
	__be32 *verf;
	bool plus;
};

struct nfs3_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs3_accessres {
	struct nfs_fattr *fattr;
	__u32 access;
};

struct nfs3_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs3_mkdirargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs3_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs3_linkres {
	struct nfs_fattr *dir_attr;
	struct nfs_fattr *fattr;
};

enum {
	Opt_kmsg_bytes = 0,
	Opt_err___9 = 1,
};

struct pstore_private {
	struct list_head list;
	struct dentry *dentry;
	struct pstore_record *record;
	size_t total_size;
};

struct pstore_ftrace_record {
	unsigned long ip;
	unsigned long parent_ip;
	u64 ts;
};

struct pstore_ftrace_seq_data {
	const void *ptr;
	size_t off;
	size_t size;
};

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	int (*clone_tfm)(struct crypto_ahash *, struct crypto_ahash *);
	struct hash_alg_common halg;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	union {
		struct {
			char head[96];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int flags;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 1250,
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

enum {
	IORING_MSG_DATA = 0,
	IORING_MSG_SEND_FD = 1,
};

struct io_msg {
	struct file *file;
	struct file *src_file;
	struct callback_head tw;
	u64 user_data;
	u32 len;
	u32 cmd;
	u32 src_fd;
	union {
		u32 dst_fd;
		u32 cqe_flags;
	};
	u32 flags;
};

struct mpi_ec_ctx;

struct field_table {
	const char *p;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
};

enum gcry_mpi_ec_models {
	MPI_EC_WEIERSTRASS = 0,
	MPI_EC_MONTGOMERY = 1,
	MPI_EC_EDWARDS = 2,
};

enum ecc_dialects {
	ECC_DIALECT_STANDARD = 0,
	ECC_DIALECT_ED25519 = 1,
	ECC_DIALECT_SAFECURVE = 2,
};

struct gcry_mpi_point;

typedef struct gcry_mpi_point *MPI_POINT;

struct mpi_ec_ctx {
	enum gcry_mpi_ec_models model;
	enum ecc_dialects dialect;
	int flags;
	unsigned int nbits;
	MPI p;
	MPI a;
	MPI b;
	MPI_POINT G;
	MPI n;
	unsigned int h;
	MPI_POINT Q;
	MPI d;
	const char *name;
	struct {
		struct {
			unsigned int a_is_pminus3: 1;
			unsigned int two_inv_p: 1;
		} valid;
		int a_is_pminus3;
		MPI two_inv_p;
		mpi_barrett_t p_barrett;
		MPI scratch[11];
	} t;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
};

struct gcry_mpi_point {
	MPI x;
	MPI y;
	MPI z;
};

typedef struct {
	size_t compressedSize;
	unsigned long long decompressedBound;
} ZSTD_frameSizeInfo;

typedef enum {
	ZSTD_dlm_byCopy = 0,
	ZSTD_dlm_byRef = 1,
} ZSTD_dictLoadMethod_e;

typedef enum {
	ZSTD_dct_auto = 0,
	ZSTD_dct_rawContent = 1,
	ZSTD_dct_fullDict = 2,
} ZSTD_dictContentType_e;

typedef enum {
	ZSTD_reset_session_only = 1,
	ZSTD_reset_parameters = 2,
	ZSTD_reset_session_and_parameters = 3,
} ZSTD_ResetDirective;

typedef enum {
	ZSTD_d_windowLogMax = 100,
	ZSTD_d_experimentalParam1 = 1000,
	ZSTD_d_experimentalParam2 = 1001,
	ZSTD_d_experimentalParam3 = 1002,
	ZSTD_d_experimentalParam4 = 1003,
} ZSTD_dParameter;

typedef struct {
	size_t error;
	int lowerBound;
	int upperBound;
} ZSTD_bounds;

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

union handle_parts {
	depot_stack_handle_t handle;
	struct {
		u32 pool_index: 16;
		u32 offset: 10;
		u32 valid: 1;
		u32 extra: 5;
	};
};

struct stack_record {
	struct stack_record *next;
	u32 hash;
	u32 size;
	union handle_parts handle;
	unsigned long entries[0];
};

struct bcm7038_l1_cpu;

struct bcm7038_l1_chip {
	raw_spinlock_t lock;
	unsigned int n_words;
	struct irq_domain *domain;
	struct bcm7038_l1_cpu *cpus[256];
	struct list_head list;
	u32 wake_mask[8];
	u32 irq_fwd_mask[8];
	u8 affinity[256];
};

struct bcm7038_l1_cpu {
	void *map_base;
	u32 mask_cache[0];
};

struct mst_intc_chip_data {
	raw_spinlock_t lock;
	unsigned int irq_start;
	unsigned int nr_irqs;
	void *base;
	bool no_eoi;
	struct list_head entry;
	u16 saved_polarity_conf[4];
};

struct simple_pm_bus {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct sr_pcie_phy_core;

struct sr_pcie_phy {
	struct sr_pcie_phy_core *core;
	unsigned int index;
	struct phy *phy;
};

struct sr_pcie_phy_core {
	struct device *dev;
	void *base;
	struct regmap *cdru;
	struct regmap *mhb;
	u32 pipemux;
	struct sr_pcie_phy phys[9];
};

struct uniphier_u2phy_param {
	u32 offset;
	u32 value;
};

struct uniphier_u2phy_soc_data {
	struct uniphier_u2phy_param config0;
	struct uniphier_u2phy_param config1;
};

struct uniphier_u2phy_priv {
	struct regmap *regmap;
	struct phy *phy;
	struct regulator *vbus;
	const struct uniphier_u2phy_soc_data *data;
	struct uniphier_u2phy_priv *next;
};

struct bcm4908_pinctrl_pin_setup;

struct bcm4908_pinctrl_grp {
	const char *name;
	const struct bcm4908_pinctrl_pin_setup *pins;
	const unsigned int num_pins;
};

struct bcm4908_pinctrl_pin_setup {
	unsigned int number;
	unsigned int function;
};

struct bcm4908_pinctrl_function {
	const char *name;
	const char * const *groups;
	const unsigned int num_groups;
};

struct bcm4908_pinctrl {
	struct device *dev;
	void *base;
	struct mutex mutex;
	struct pinctrl_dev *pctldev;
	struct pinctrl_desc pctldesc;
};

struct xgene_gpio_sb {
	struct gpio_chip gc;
	void *regs;
	struct irq_domain *irq_domain;
	u16 irq_start;
	u16 nirq;
	u16 parent_irq_base;
};

struct acpi_data_node_attr {
	struct attribute attr;
	ssize_t (*show)(struct acpi_data_node *, char *);
	ssize_t (*store)(struct acpi_data_node *, const char *, size_t);
};

struct acpi_table_cdat {
	u32 length;
	u8 revision;
	u8 checksum;
	u8 reserved[6];
	u32 sequence;
};

enum acpi_pptt_type {
	ACPI_PPTT_TYPE_PROCESSOR = 0,
	ACPI_PPTT_TYPE_CACHE = 1,
	ACPI_PPTT_TYPE_ID = 2,
	ACPI_PPTT_TYPE_RESERVED = 3,
};

struct acpi_pptt_processor {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 flags;
	u32 parent;
	u32 acpi_processor_id;
	u32 number_of_priv_resources;
};

struct acpi_pptt_cache {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 flags;
	u32 next_level_of_cache;
	u32 size;
	u32 number_of_sets;
	u8 associativity;
	u8 attributes;
	u16 line_size;
};

struct acpi_pptt_cache_v1 {
	u32 cache_id;
};

struct acpi_bert_region {
	u32 block_status;
	u32 raw_data_offset;
	u32 raw_data_length;
	u32 data_length;
	u32 error_severity;
};

struct acpi_table_einj {
	struct acpi_table_header header;
	u32 header_length;
	u8 flags;
	u8 reserved[3];
	u32 entries;
};

enum acpi_einj_actions {
	ACPI_EINJ_BEGIN_OPERATION = 0,
	ACPI_EINJ_GET_TRIGGER_TABLE = 1,
	ACPI_EINJ_SET_ERROR_TYPE = 2,
	ACPI_EINJ_GET_ERROR_TYPE = 3,
	ACPI_EINJ_END_OPERATION = 4,
	ACPI_EINJ_EXECUTE_OPERATION = 5,
	ACPI_EINJ_CHECK_BUSY_STATUS = 6,
	ACPI_EINJ_GET_COMMAND_STATUS = 7,
	ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS = 8,
	ACPI_EINJ_GET_EXECUTE_TIMINGS = 9,
	ACPI_EINJ_ACTION_RESERVED = 10,
	ACPI_EINJ_TRIGGER_ERROR = 255,
};

enum {
	SETWA_FLAGS_APICID = 1,
	SETWA_FLAGS_MEM = 2,
	SETWA_FLAGS_PCIE_SBDF = 4,
};

enum acpi_einj_instructions {
	ACPI_EINJ_READ_REGISTER = 0,
	ACPI_EINJ_READ_REGISTER_VALUE = 1,
	ACPI_EINJ_WRITE_REGISTER = 2,
	ACPI_EINJ_WRITE_REGISTER_VALUE = 3,
	ACPI_EINJ_NOOP = 4,
	ACPI_EINJ_FLUSH_CACHELINE = 5,
	ACPI_EINJ_INSTRUCTION_RESERVED = 6,
};

struct set_error_type_with_address {
	u32 type;
	u32 vendor_extension;
	u32 flags;
	u32 apicid;
	u64 memory_address;
	u64 memory_address_range;
	u32 pcie_sbdf;
};

struct vendor_error_type_extension {
	u32 length;
	u32 pcie_sbdf;
	u16 vendor_id;
	u16 device_id;
	u8 rev_id;
	u8 reserved[3];
};

struct einj_parameter {
	u64 type;
	u64 reserved1;
	u64 reserved2;
	u64 param1;
	u64 param2;
};

struct acpi_einj_trigger {
	u32 header_size;
	u32 revision;
	u32 table_size;
	u32 entry_count;
};

struct rk808_clkout {
	struct regmap *regmap;
	struct clk_hw clkout1_hw;
	struct clk_hw clkout2_hw;
};

struct clk_hisi_phase {
	struct clk_hw hw;
	void *reg;
	u32 *phase_degrees;
	u32 *phase_regvals;
	u8 phase_num;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct clk_lpcg_scu {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	bool hw_gate;
	u32 state;
};

struct pll_config {
	u16 l;
	u32 m;
	u32 n;
	u32 vco_val;
	u32 vco_mask;
	u32 pre_div_val;
	u32 pre_div_mask;
	u32 post_div_val;
	u32 post_div_mask;
	u32 mn_ena_mask;
	u32 main_output_mask;
	u32 aux_output_mask;
};

struct apss_pll_data {
	int pll_type;
	struct clk_alpha_pll *pll;
	const struct alpha_pll_config *pll_config;
};

enum {
	CLK_ALPHA_PLL_TYPE_DEFAULT = 0,
	CLK_ALPHA_PLL_TYPE_HUAYRA = 1,
	CLK_ALPHA_PLL_TYPE_BRAMMO = 2,
	CLK_ALPHA_PLL_TYPE_FABIA = 3,
	CLK_ALPHA_PLL_TYPE_TRION = 4,
	CLK_ALPHA_PLL_TYPE_LUCID = 4,
	CLK_ALPHA_PLL_TYPE_AGERA = 5,
	CLK_ALPHA_PLL_TYPE_ZONDA = 6,
	CLK_ALPHA_PLL_TYPE_LUCID_EVO = 7,
	CLK_ALPHA_PLL_TYPE_LUCID_OLE = 8,
	CLK_ALPHA_PLL_TYPE_RIVIAN_EVO = 9,
	CLK_ALPHA_PLL_TYPE_DEFAULT_EVO = 10,
	CLK_ALPHA_PLL_TYPE_BRAMMO_EVO = 11,
	CLK_ALPHA_PLL_TYPE_STROMER = 12,
	CLK_ALPHA_PLL_TYPE_STROMER_PLUS = 13,
	CLK_ALPHA_PLL_TYPE_MAX = 14,
};

struct exynos_cpuclk {
	struct clk_hw hw;
	const struct clk_hw *alt_parent;
	void *ctrl_base;
	spinlock_t *lock;
	const struct exynos_cpuclk_cfg_data *cfg;
	const unsigned long num_cfgs;
	struct notifier_block clk_nb;
	unsigned long flags;
};

struct utmi_clk_param___2 {
	u32 osc_frequency;
	u8 enable_delay_count;
	u8 stable_count;
	u8 active_delay_count;
	u8 xtal_freq_count;
};

struct k3dma_soc_data {
	unsigned long flags;
};

struct k3_dma_phy;

struct k3_dma_chan;

struct k3_dma_dev {
	struct dma_device slave;
	void *base;
	struct tasklet_struct task;
	spinlock_t lock;
	struct list_head chan_pending;
	struct k3_dma_phy *phy;
	struct k3_dma_chan *chans;
	struct clk *clk;
	struct dma_pool *pool;
	u32 dma_channels;
	u32 dma_requests;
	u32 dma_channel_mask;
	unsigned int irq;
};

struct k3_dma_desc_sw;

struct k3_dma_phy {
	u32 idx;
	void *base;
	struct k3_dma_chan *vchan;
	struct k3_dma_desc_sw *ds_run;
	struct k3_dma_desc_sw *ds_done;
};

struct k3_dma_chan {
	u32 ccfg;
	struct virt_dma_chan vc;
	struct k3_dma_phy *phy;
	struct list_head node;
	dma_addr_t dev_addr;
	enum dma_status status;
	bool cyclic;
	struct dma_slave_config slave_config;
};

struct k3_desc_hw;

struct k3_dma_desc_sw {
	struct virt_dma_desc vd;
	dma_addr_t desc_hw_lli;
	size_t desc_num;
	size_t size;
	struct k3_desc_hw *desc_hw;
};

struct k3_desc_hw {
	u32 lli;
	u32 reserved[3];
	u32 count;
	u32 saddr;
	u32 daddr;
	u32 config;
};

enum cpubiuctrl_regs {
	CPU_CREDIT_REG = 0,
	CPU_MCP_FLOW_REG = 1,
	CPU_WRITEBACK_CTRL_REG = 2,
	RAC_CONFIG0_REG = 3,
	RAC_CONFIG1_REG = 4,
	NUM_CPU_BIUCTRL_REGS = 5,
};

enum qbman_sdqcr_dct {
	qbman_sdqcr_dct_null = 0,
	qbman_sdqcr_dct_prio_ics = 1,
	qbman_sdqcr_dct_active_ics = 2,
	qbman_sdqcr_dct_active = 3,
};

enum qbman_sdqcr_fc {
	qbman_sdqcr_fc_one = 0,
	qbman_sdqcr_fc_up_to_3 = 1,
};

enum qb_enqueue_commands {
	enqueue_empty = 0,
	enqueue_response_always = 1,
	enqueue_rejects_to_fq = 2,
};

enum qb_pull_dt_e {
	qb_pull_dt_channel = 0,
	qb_pull_dt_workqueue = 1,
	qb_pull_dt_framequeue = 2,
};

struct qbman_fq_query_desc {
	u8 verb;
	u8 reserved[3];
	__le32 fqid;
	u8 reserved2[56];
};

struct qbman_bp_query_desc {
	u8 verb;
	u8 reserved;
	__le16 bpid;
	u8 reserved2[60];
};

struct qbman_acquire_desc {
	u8 verb;
	u8 reserved;
	__le16 bpid;
	u8 num;
	u8 reserved2[59];
};

struct qbman_acquire_rslt {
	u8 verb;
	u8 rslt;
	__le16 reserved;
	u8 num;
	u8 reserved2[3];
	__le64 buf[7];
};

struct qbman_alt_fq_state_desc {
	u8 verb;
	u8 reserved[3];
	__le32 fqid;
	u8 reserved2[56];
};

struct qbman_alt_fq_state_rslt {
	u8 verb;
	u8 rslt;
	u8 reserved[62];
};

struct qbman_cdan_ctrl_desc {
	u8 verb;
	u8 reserved;
	__le16 ch;
	u8 we;
	u8 ctrl;
	__le16 reserved2;
	__le64 cdan_ctx;
	u8 reserved3[48];
};

struct qbman_cdan_ctrl_rslt {
	u8 verb;
	u8 rslt;
	__le16 ch;
	u8 reserved[60];
};

struct mediatek_regulator_coupler {
	struct regulator_coupler coupler;
	struct regulator_dev *vsram_rdev;
};

struct registered_event_data {
	u64 key;
	enum pm_api_cb_id cb_type;
	bool wake;
	struct list_head cb_list_head;
	struct hlist_node hentry;
};

struct agent_cb {
	void *agent_data;
	event_cb_func_t eve_cb;
	struct list_head list;
};

enum shutdown_state {
	SHUTDOWN_INVALID = -1,
	SHUTDOWN_POWEROFF = 0,
	SHUTDOWN_SUSPEND = 2,
	SHUTDOWN_HALT = 4,
};

struct shutdown_handler {
	const char command[11];
	bool flag;
	void (*cb)();
};

struct suspend_info {
	int cancelled;
};

struct vcpu_runstate_info {
	int state;
	uint64_t state_entry_time;
	uint64_t time[4];
};

typedef struct {
	union {
		struct vcpu_runstate_info *p;
		uint64_t q;
	};
} __guest_handle_vcpu_runstate_info;

struct vcpu_register_runstate_memory_area {
	union {
		__guest_handle_vcpu_runstate_info h;
		struct vcpu_runstate_info *v;
		uint64_t p;
	} addr;
};

struct per_user_data;

struct user_evtchn {
	struct rb_node node;
	struct per_user_data *user;
	evtchn_port_t port;
	bool enabled;
};

struct per_user_data {
	struct mutex bind_mutex;
	struct rb_root evtchns;
	unsigned int nr_evtchns;
	unsigned int ring_size;
	evtchn_port_t *ring;
	unsigned int ring_cons;
	unsigned int ring_prod;
	unsigned int ring_overflow;
	struct mutex ring_cons_mutex;
	spinlock_t ring_prod_lock;
	wait_queue_head_t evtchn_wait;
	struct fasync_struct *evtchn_async_queue;
	const char *name;
	domid_t restrict_domid;
};

struct ioctl_evtchn_bind_virq {
	unsigned int virq;
};

struct ioctl_evtchn_bind_interdomain {
	unsigned int remote_domain;
	unsigned int remote_port;
};

struct ioctl_evtchn_bind_unbound_port {
	unsigned int remote_domain;
};

struct ioctl_evtchn_unbind {
	unsigned int port;
};

struct ioctl_evtchn_bind {
	unsigned int port;
};

struct ioctl_evtchn_notify {
	unsigned int port;
};

struct ioctl_evtchn_restrict_domid {
	domid_t domid;
};

struct gpio_regulator_state;

struct gpio_regulator_config {
	const char *supply_name;
	const char *input_supply;
	unsigned int enabled_at_boot: 1;
	unsigned int startup_delay;
	enum gpiod_flags *gflags;
	int ngpios;
	struct gpio_regulator_state *states;
	int nr_states;
	enum regulator_type type;
	struct regulator_init_data *init_data;
};

struct gpio_regulator_state {
	int value;
	int gpios;
};

struct gpio_regulator_data {
	struct regulator_desc desc;
	struct gpio_desc **gpiods;
	int nr_gpios;
	struct gpio_regulator_state *states;
	int nr_states;
	int state;
};

struct mt6360_irq_mapping;

struct mt6360_regulator_desc {
	const struct regulator_desc desc;
	unsigned int mode_reg;
	unsigned int mode_mask;
	unsigned int state_reg;
	unsigned int state_mask;
	const struct mt6360_irq_mapping *irq_tables;
	int irq_table_size;
};

struct mt6360_irq_mapping {
	const char *name;
	irq_handler_t handler;
};

struct mt6360_regulator_data {
	struct device *dev;
	struct regmap *regmap;
};

struct reset_control {
	struct reset_controller_dev *rcdev;
	struct list_head list;
	unsigned int id;
	struct kref refcnt;
	bool acquired;
	bool shared;
	bool array;
	atomic_t deassert_count;
	atomic_t triggered_count;
};

struct reset_control_array {
	struct reset_control base;
	unsigned int num_rstcs;
	struct reset_control *rstc[0];
};

struct reset_control_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
};

struct reset_control_bulk_devres {
	int num_rstcs;
	struct reset_control_bulk_data *rstcs;
};

struct serial8250_config {
	const char *name;
	unsigned short fifo_size;
	unsigned short tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct stm32_usart_offsets {
	u8 cr1;
	u8 cr2;
	u8 cr3;
	u8 brr;
	u8 gtpr;
	u8 rtor;
	u8 rqr;
	u8 isr;
	u8 icr;
	u8 rdr;
	u8 tdr;
};

struct stm32_usart_config {
	u8 uart_enable_bit;
	bool has_7bits_data;
	bool has_swap;
	bool has_wakeup;
	bool has_fifo;
	int fifosize;
};

struct stm32_usart_info {
	struct stm32_usart_offsets ofs;
	struct stm32_usart_config cfg;
};

struct stm32_port {
	struct uart_port port;
	struct clk *clk;
	const struct stm32_usart_info *info;
	struct dma_chan *rx_ch;
	dma_addr_t rx_dma_buf;
	unsigned char *rx_buf;
	struct dma_chan *tx_ch;
	dma_addr_t tx_dma_buf;
	unsigned char *tx_buf;
	u32 cr1_irq;
	u32 cr3_irq;
	int last_res;
	bool tx_dma_busy;
	bool rx_dma_busy;
	bool throttled;
	bool hw_flow_control;
	bool swap;
	bool fifoen;
	int rxftcfg;
	int txftcfg;
	bool wakeup_src;
	int rdr_mask;
	struct mctrl_gpios *gpios;
	struct dma_tx_state rx_dma_state;
};

struct npcm_rng {
	void *base;
	struct hwrng rng;
	u32 clkp;
};

enum dart_type {
	DART_T8020 = 0,
	DART_T6000 = 1,
	DART_T8110 = 2,
};

struct apple_dart_stream_map;

struct apple_dart_hw {
	enum dart_type type;
	irqreturn_t (*irq_handler)(int, void *);
	int (*invalidate_tlb)(struct apple_dart_stream_map *);
	u32 oas;
	enum io_pgtable_fmt fmt;
	int max_sid_count;
	u64 lock;
	u64 lock_bit;
	u64 error;
	u64 enable_streams;
	u64 tcr;
	u64 tcr_enabled;
	u64 tcr_disabled;
	u64 tcr_bypass;
	u64 ttbr;
	u64 ttbr_valid;
	u64 ttbr_addr_field_shift;
	u64 ttbr_shift;
	int ttbr_count;
};

struct apple_dart;

struct apple_dart_stream_map {
	struct apple_dart *dart;
	unsigned long sidmap[4];
};

struct apple_dart {
	struct device *dev;
	const struct apple_dart_hw *hw;
	void *regs;
	int irq;
	struct clk_bulk_data *clks;
	int num_clks;
	spinlock_t lock;
	u32 ias;
	u32 oas;
	u32 pgsize;
	u32 num_streams;
	u32 supports_bypass: 1;
	struct iommu_group *sid2group[256];
	struct iommu_device iommu;
	u32 save_tcr[256];
	u32 save_ttbr[1024];
};

struct apple_dart_atomic_stream_map {
	struct apple_dart *dart;
	atomic_long_t sidmap[4];
};

struct apple_dart_domain {
	struct io_pgtable_ops *pgtbl_ops;
	bool finalized;
	struct mutex init_lock;
	struct apple_dart_atomic_stream_map stream_maps[2];
	struct iommu_domain domain;
};

struct apple_dart_master_cfg {
	struct apple_dart_stream_map stream_maps[2];
};

struct cros_feature_to_name {
	unsigned int id;
	const char *name;
	const char *desc;
};

struct cros_feature_to_cells {
	unsigned int id;
	const struct mfd_cell *mfd_cells;
	unsigned int num_cells;
};

struct dma_fence_chain {
	struct dma_fence base;
	struct dma_fence __attribute__((btf_type_tag("rcu"))) *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	union {
		struct dma_fence_cb cb;
		struct irq_work work;
	};
	spinlock_t lock;
};

enum hsm_task_states {
	HSM_ST_IDLE = 0,
	HSM_ST_FIRST = 1,
	HSM_ST = 2,
	HSM_ST_LAST = 3,
	HSM_ST_ERR = 4,
};

enum fwh_lock_state {
	FWH_UNLOCKED = 0,
	FWH_DENY_WRITE = 1,
	FWH_IMMUTABLE = 2,
	FWH_DENY_READ = 4,
};

struct cfi_intelext_otpinfo {
	uint32_t ProtRegAddr;
	uint16_t FactGroups;
	uint8_t FactProtRegSize;
	uint16_t UserGroups;
	uint8_t UserProtRegSize;
} __attribute__((packed));

struct cfi_intelext_blockinfo {
	uint16_t NumIdentBlocks;
	uint16_t BlockSize;
	uint16_t MinBlockEraseCycles;
	uint8_t BitsPerCell;
	uint8_t BlockCap;
};

struct cfi_intelext_regioninfo {
	uint16_t NumIdentPartitions;
	uint8_t NumOpAllowed;
	uint8_t NumOpAllowedSimProgMode;
	uint8_t NumOpAllowedSimEraMode;
	uint8_t NumBlockTypes;
	struct cfi_intelext_blockinfo BlockTypes[1];
};

struct fwh_xxlock_thunk {
	enum fwh_lock_state val;
	flstate_t state;
};

struct cfi_intelext_programming_regioninfo {
	uint8_t ProgRegShift;
	uint8_t Reserved1;
	uint8_t ControlValid;
	uint8_t Reserved2;
	uint8_t ControlInvalid;
	uint8_t Reserved3;
};

struct flchip_shared {
	struct mutex lock;
	struct flchip *writing;
	struct flchip *erasing;
};

struct cfi_pri_atmel {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint8_t Features;
	uint8_t BottomBoot;
	uint8_t BurstMode;
	uint8_t PageMode;
};

struct mdio_mux_child_bus;

struct mdio_mux_parent_bus {
	struct mii_bus *mii_bus;
	int current_child;
	int parent_id;
	void *switch_data;
	int (*switch_fn)(int, int, void *);
	struct mdio_mux_child_bus *children;
};

struct mdio_mux_child_bus {
	struct mii_bus *mii_bus;
	struct mdio_mux_parent_bus *parent;
	struct mdio_mux_child_bus *next;
	int bus_number;
};

struct xgene_cle_ptree_branch {
	bool valid;
	u16 next_packet_pointer;
	bool jump_bw;
	bool jump_rel;
	u8 operation;
	u16 next_node;
	u8 next_branch;
	u16 data;
	u16 mask;
};

struct xgene_cle_ptree_ewdn {
	u8 node_type;
	bool last_node;
	bool hdr_len_store;
	u8 hdr_extn;
	u8 byte_store;
	u8 search_byte_store;
	u16 result_pointer;
	u8 num_branches;
	struct xgene_cle_ptree_branch branch[6];
};

enum xgene_cle_ptree_dbptrs {
	DB_RES_DROP = 0,
	DB_RES_DEF = 1,
	DB_RES_ACCEPT = 2,
	DB_MAX_PTRS = 3,
};

enum xgene_cle_node_type {
	INV = 0,
	KN = 1,
	EWDN = 2,
	RES_NODE = 3,
};

enum xgene_cle_ipv4_rss_hashtype {
	RSS_IPV4_8B = 0,
	RSS_IPV4_12B = 1,
};

enum xgene_cle_prot_version {
	XGENE_CLE_IPV4 = 0,
};

enum xgene_cle_prot_type {
	XGENE_CLE_TCP = 0,
	XGENE_CLE_UDP = 1,
	XGENE_CLE_ESP = 2,
	XGENE_CLE_OTHER = 3,
};

enum xgene_cle_dram_type {
	PKT_RAM = 0,
	RSS_IDT = 1,
	RSS_IPV4_HASH_SKEY = 2,
	PTREE_RAM = 12,
	AVL_RAM = 13,
	DB_RAM = 14,
};

enum xgene_cle_cmd_type {
	CLE_CMD_WR = 1,
	CLE_CMD_RD = 2,
	CLE_CMD_AVL_ADD = 8,
	CLE_CMD_AVL_DEL = 16,
	CLE_CMD_AVL_SRCH = 32,
};

typedef void (*btf_trace_dpaa_tx_fd)(void *, struct net_device *, struct qman_fq *, const struct qm_fd *);

typedef void (*btf_trace_dpaa_rx_fd)(void *, struct net_device *, struct qman_fq *, const struct qm_fd *);

typedef void (*btf_trace_dpaa_tx_conf_fd)(void *, struct net_device *, struct qman_fq *, const struct qm_fd *);

struct dpaa_fq_cbs {
	struct qman_fq rx_defq;
	struct qman_fq tx_defq;
	struct qman_fq rx_errq;
	struct qman_fq tx_errq;
	struct qman_fq egress_ern;
};

enum qm_fd_format {
	qm_fd_contig = 0,
	qm_fd_contig_big = 1073741824,
	qm_fd_sg = 2147483648,
	qm_fd_sg_big = 3221225472,
	qm_fd_compound = 536870912,
};

enum port_type {
	RX___2 = 0,
	TX___2 = 1,
};

struct trace_event_raw_dpaa_eth_fd {
	struct trace_entry ent;
	u32 fqid;
	u64 fd_addr;
	u8 fd_format;
	u16 fd_offset;
	u32 fd_length;
	u32 fd_status;
	u32 __data_loc_name;
	char __data[0];
};

struct dpaa_eth_swbp {
	struct sk_buff *skb;
	struct xdp_frame *xdpf;
};

struct qm_sg_entry {
	union {
		struct {
			u8 __reserved1[3];
			u8 addr_hi;
			__be32 addr_lo;
		};
		__be64 data;
	};
	__be32 cfg;
	u8 __reserved2;
	u8 bpid;
	__be16 offset;
};

struct fman_prs_result {
	u8 lpid;
	u8 shimr;
	__be16 l2r;
	__be16 l3r;
	u8 l4r;
	u8 cplan;
	__be16 nxthdr;
	__be16 cksum;
	__be16 flags_frag_off;
	u8 route_type;
	u8 rhp_ip_valid;
	u8 shim_off[2];
	u8 ip_pid_off;
	u8 eth_off;
	u8 llc_snap_off;
	u8 vlan_off[2];
	u8 etype_off;
	u8 pppoe_off;
	u8 mpls_off[2];
	u8 ip_off[2];
	u8 gre_off;
	u8 l4_off;
	u8 nxthdr_off;
};

struct trace_event_data_offsets_dpaa_eth_fd {
	u32 name;
};

struct fm_port_fqs {
	struct dpaa_fq *tx_defq;
	struct dpaa_fq *tx_errq;
	struct dpaa_fq *rx_defq;
	struct dpaa_fq *rx_errq;
	struct dpaa_fq *rx_pcdq;
};

struct qm_cgr_wr_parm {
	__be32 word;
};

struct qm_cgr_cs_thres {
	__be16 word;
};

struct __qm_mc_cgr {
	struct qm_cgr_wr_parm wr_parm_g;
	struct qm_cgr_wr_parm wr_parm_y;
	struct qm_cgr_wr_parm wr_parm_r;
	u8 wr_en_g;
	u8 wr_en_y;
	u8 wr_en_r;
	u8 cscn_en;
	union {
		struct {
			__be16 cscn_targ_upd_ctrl;
			__be16 cscn_targ_dcp_low;
		};
		__be32 cscn_targ;
	};
	u8 cstd_en;
	u8 cs;
	struct qm_cgr_cs_thres cs_thres;
	u8 mode;
} __attribute__((packed));

struct qm_mcc_initcgr {
	u8 __reserve1[2];
	__be16 we_mask;
	struct __qm_mc_cgr cgr;
	u8 __reserved2[2];
	u8 cgid;
	u8 __reserved3[32];
};

struct qm_fqd_oac {
	u8 oac;
	s8 oal;
};

struct qm_fqd_stashing {
	u8 exclusive;
	u8 cl;
};

struct qm_fqd {
	u8 orpc;
	u8 cgid;
	__be16 fq_ctrl;
	__be16 dest_wq;
	__be16 ics_cred;
	union {
		__be16 td;
		struct qm_fqd_oac oac_init;
	};
	__be32 context_b;
	union {
		__be64 opaque;
		struct {
			__be32 hi;
			__be32 lo;
		};
		struct {
			struct qm_fqd_stashing stashing;
			__be16 context_hi;
			__be32 context_lo;
		};
	} context_a;
	struct qm_fqd_oac oac_query;
} __attribute__((packed));

struct qm_mcc_initfq {
	u8 __reserved1[2];
	__be16 we_mask;
	__be32 fqid;
	__be16 count;
	struct qm_fqd fqd;
	u8 __reserved2[30];
};

struct fman_buffer_prefix_content {
	u16 priv_data_size;
	bool pass_prs_result;
	bool pass_time_stamp;
	bool pass_hash_result;
	u16 data_align;
};

struct fman_ext_pool_params {
	u8 id;
	u16 size;
};

struct fman_ext_pools {
	u8 num_of_pools_used;
	struct fman_ext_pool_params ext_buf_pool[8];
};

struct fman_port_rx_params {
	u32 err_fqid;
	u32 dflt_fqid;
	u32 pcd_base_fqid;
	u32 pcd_fqs_count;
	struct fman_ext_pools ext_buf_pools;
};

struct fman_port_non_rx_params {
	u32 err_fqid;
	u32 dflt_fqid;
};

union fman_port_specific_params {
	struct fman_port_rx_params rx_params;
	struct fman_port_non_rx_params non_rx_params;
};

struct fman_port_params {
	void *fm;
	union fman_port_specific_params specific_params;
};

struct mvpp2_dbgfs_prs_entry {
	int tid;
	struct mvpp2 *priv;
};

struct mvpp2_dbgfs_c2_entry {
	int id;
	struct mvpp2 *priv;
};

struct mvpp2_dbgfs_flow_tbl_entry {
	int id;
	struct mvpp2 *priv;
};

struct mvpp2_dbgfs_flow_entry {
	int flow;
	struct mvpp2 *priv;
};

struct mvpp2_dbgfs_port_flow_entry {
	struct mvpp2_port *port;
	struct mvpp2_dbgfs_flow_entry *dbg_fe;
};

struct mvpp2_dbgfs_entries {
	struct mvpp2_dbgfs_prs_entry prs_entries[256];
	struct mvpp2_dbgfs_c2_entry c2_entries[256];
	struct mvpp2_dbgfs_flow_tbl_entry flt_entries[512];
	struct mvpp2_dbgfs_flow_entry flow_entries[52];
	struct mvpp2_dbgfs_port_flow_entry port_flow_entries[4];
};

struct quirk_entry {
	u16 vid;
	u16 pid;
	u32 flags;
};

struct timing {
	u8 u1sel;
	u8 u1pel;
	__le16 u2sel;
	__le16 u2pel;
};

struct mtu3_file_map {
	const char *name;
	int (*show)(struct seq_file *, void *);
};

struct mtu3_regset {
	char name[32];
	struct debugfs_regset32 regset;
};

struct npcm_udc_data {
	struct platform_device *ci;
	struct clk *core_clk;
	struct ci_hdrc_platform_data pdata;
};

enum bdc_link_state {
	BDC_LINK_STATE_U0 = 0,
	BDC_LINK_STATE_U3 = 3,
	BDC_LINK_STATE_RX_DET = 5,
	BDC_LINK_STATE_RESUME = 15,
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	unsigned short id;
	unsigned short keycode[512];
	unsigned long force_release_mask[8];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	unsigned long xl_bit;
	unsigned int last;
	unsigned long time;
	unsigned long err_count;
	struct delayed_work event_work;
	unsigned long event_jiffies;
	unsigned long event_mask;
	struct mutex mutex;
	struct vivaldi_data vdata;
};

struct cros_ec_rtc {
	struct cros_ec_device *cros_ec;
	struct rtc_device *rtc;
	struct notifier_block notifier;
	u32 saved_alarm;
};

struct ec_response_rtc {
	uint32_t time;
};

enum bcm_iproc_i2c_type {
	IPROC_I2C = 0,
	IPROC_I2C_NIC = 1,
};

enum i2c_slave_read_status {
	I2C_SLAVE_RX_FIFO_EMPTY = 0,
	I2C_SLAVE_RX_START = 1,
	I2C_SLAVE_RX_DATA = 2,
	I2C_SLAVE_RX_END = 3,
};

struct bcm_iproc_i2c_dev {
	struct device *device;
	enum bcm_iproc_i2c_type type;
	int irq;
	void *base;
	void *idm_base;
	u32 ape_addr_mask;
	spinlock_t idm_lock;
	struct i2c_adapter adapter;
	unsigned int bus_speed;
	struct completion done;
	int xfer_is_done;
	struct i2c_msg *msg;
	struct i2c_client *slave;
	unsigned int tx_bytes;
	unsigned int rx_bytes;
	unsigned int thld_bytes;
	bool slave_rx_only;
	bool rx_start_rcvd;
	bool slave_read_complete;
	u32 tx_underrun;
	u32 slave_int_mask;
	struct tasklet_struct slave_rx_tasklet;
};

enum {
	CMD_I2C_XFER = 1,
};

struct tegra_bpmp_i2c {
	struct i2c_adapter adapter;
	struct device *dev;
	struct tegra_bpmp *bpmp;
	unsigned int bus;
};

struct cmd_i2c_xfer_request {
	uint32_t bus_id;
	uint32_t data_size;
	uint8_t data_buf[108];
};

struct mrq_i2c_request {
	uint32_t cmd;
	struct cmd_i2c_xfer_request xfer;
};

struct cmd_i2c_xfer_response {
	uint32_t data_size;
	uint8_t data_buf[116];
};

struct mrq_i2c_response {
	struct cmd_i2c_xfer_response xfer;
};

struct rcar_thermal_chip {
	unsigned int use_of_thermal: 1;
	unsigned int has_filonoff: 1;
	unsigned int irq_per_ch: 1;
	unsigned int needs_suspend_resume: 1;
	unsigned int nirqs;
	unsigned int ctemp_bands;
};

struct rcar_thermal_common;

struct rcar_thermal_priv {
	void *base;
	struct rcar_thermal_common *common;
	struct thermal_zone_device *zone;
	const struct rcar_thermal_chip *chip;
	struct delayed_work work;
	struct mutex lock;
	struct list_head list;
	int id;
};

struct rcar_thermal_common {
	void *base;
	struct device *dev;
	struct list_head head;
	spinlock_t lock;
};

struct rwdt_priv {
	void *base;
	struct watchdog_device wdev;
	unsigned long clk_rate;
	u8 cks;
	struct clk *clk;
};

struct userspace_policy {
	unsigned int is_managed;
	unsigned int setspeed;
	struct mutex mutex;
};

typedef int tpl_parse_t(struct mmc_card *, struct sdio_func *, const unsigned char *, unsigned int);

struct cis_tpl {
	unsigned char code;
	unsigned char min_size;
	tpl_parse_t *parse;
};

struct of_mmc_spi {
	struct mmc_spi_platform_data pdata;
	int detect_irq;
};

typedef __kernel_mode_t mode_t;

struct ufs_debugfs_attr {
	const char *name;
	mode_t mode;
	const struct file_operations *fops;
};

enum stratix10_svc_command_code {
	COMMAND_NOOP = 0,
	COMMAND_RECONFIG = 1,
	COMMAND_RECONFIG_DATA_SUBMIT = 2,
	COMMAND_RECONFIG_DATA_CLAIM = 3,
	COMMAND_RECONFIG_STATUS = 4,
	COMMAND_RSU_STATUS = 10,
	COMMAND_RSU_UPDATE = 11,
	COMMAND_RSU_NOTIFY = 12,
	COMMAND_RSU_RETRY = 13,
	COMMAND_RSU_MAX_RETRY = 14,
	COMMAND_RSU_DCMF_VERSION = 15,
	COMMAND_RSU_DCMF_STATUS = 16,
	COMMAND_FIRMWARE_VERSION = 17,
	COMMAND_FCS_REQUEST_SERVICE = 20,
	COMMAND_FCS_SEND_CERTIFICATE = 21,
	COMMAND_FCS_GET_PROVISION_DATA = 22,
	COMMAND_FCS_DATA_ENCRYPTION = 23,
	COMMAND_FCS_DATA_DECRYPTION = 24,
	COMMAND_FCS_RANDOM_NUMBER_GEN = 25,
	COMMAND_POLL_SERVICE_STATUS = 40,
	COMMAND_MBOX_SEND_CMD = 100,
	COMMAND_SMC_SVC_VERSION = 200,
};

typedef void svc_invoke_fn(unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, struct arm_smccc_res *);

struct stratix10_svc_chan;

struct stratix10_svc_controller {
	struct device *dev;
	struct stratix10_svc_chan *chans;
	int num_chans;
	int num_active_client;
	struct list_head node;
	struct gen_pool *genpool;
	struct task_struct *task;
	struct kfifo svc_fifo;
	struct completion complete_status;
	spinlock_t svc_fifo_lock;
	svc_invoke_fn *invoke_fn;
};

struct stratix10_svc_client;

struct stratix10_svc_chan {
	struct stratix10_svc_controller *ctrl;
	struct stratix10_svc_client *scl;
	char *name;
	spinlock_t lock;
};

struct stratix10_svc_cb_data;

struct stratix10_svc_client {
	struct device *dev;
	void (*receive_cb)(struct stratix10_svc_client *, struct stratix10_svc_cb_data *);
	void *priv;
};

struct stratix10_svc_cb_data {
	u32 status;
	void *kaddr1;
	void *kaddr2;
	void *kaddr3;
};

struct stratix10_svc_client_msg {
	void *payload;
	size_t payload_length;
	void *payload_output;
	size_t payload_length_output;
	enum stratix10_svc_command_code command;
	u64 arg[3];
};

struct stratix10_svc_command_config_type {
	u32 flags;
};

struct stratix10_svc_data_mem {
	void *vaddr;
	phys_addr_t paddr;
	size_t size;
	struct list_head node;
};

struct stratix10_svc_sh_memory {
	struct completion sync_complete;
	unsigned long addr;
	unsigned long size;
	svc_invoke_fn *invoke_fn;
};

struct stratix10_svc_data {
	struct stratix10_svc_chan *chan;
	phys_addr_t paddr;
	size_t size;
	phys_addr_t paddr_output;
	size_t size_output;
	u32 command;
	u32 flag;
	u64 arg[3];
};

struct stratix10_svc {
	struct platform_device *stratix10_svc_rsu;
	struct platform_device *intel_svc_fcs;
};

enum scmi_system_protocol_cmd {
	SYSTEM_POWER_STATE_NOTIFY = 5,
};

enum scmi_system_events {
	SCMI_SYSTEM_SHUTDOWN = 0,
	SCMI_SYSTEM_COLDRESET = 1,
	SCMI_SYSTEM_WARMRESET = 2,
	SCMI_SYSTEM_POWERUP = 3,
	SCMI_SYSTEM_SUSPEND = 4,
	SCMI_SYSTEM_MAX = 5,
};

struct scmi_system_power_state_notify {
	__le32 notify_enable;
};

struct scmi_system_info {
	u32 version;
	bool graceful_timeout_supported;
};

struct scmi_system_power_state_notifier_payld {
	__le32 agent_id;
	__le32 flags;
	__le32 system_state;
	__le32 timeout;
};

struct scmi_system_power_state_notifier_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int flags;
	unsigned int system_state;
	unsigned int timeout;
};

struct imx_sc_msg_resp_misc_get_ctrl {
	struct imx_sc_rpc_msg hdr;
	u32 val;
};

struct imx_sc_msg_req_misc_set_ctrl {
	struct imx_sc_rpc_msg hdr;
	u32 ctrl;
	u32 val;
	u16 resource;
};

struct imx_sc_msg_req_misc_get_ctrl {
	struct imx_sc_rpc_msg hdr;
	u32 ctrl;
	u16 resource;
};

struct imx_sc_msg_req_cpu_start {
	struct imx_sc_rpc_msg hdr;
	u32 address_hi;
	u32 address_lo;
	u16 resource;
	u8 enable;
};

struct imx_sc_msg_misc_get_soc_id {
	struct imx_sc_rpc_msg hdr;
	union {
		struct {
			u32 control;
			u16 resource;
		} __attribute__((packed)) req;
		struct {
			u32 id;
		} resp;
	} data;
};

struct imx_sc_msg_misc_get_soc_uid {
	struct imx_sc_rpc_msg hdr;
	u32 uid_low;
	u32 uid_high;
};

enum sh_cmt_model {
	SH_CMT_16BIT = 0,
	SH_CMT_32BIT = 1,
	SH_CMT_48BIT = 2,
	SH_CMT0_RCAR_GEN2 = 3,
	SH_CMT1_RCAR_GEN2 = 4,
};

struct sh_cmt_info {
	enum sh_cmt_model model;
	unsigned int channels_mask;
	unsigned long width;
	u32 overflow_bit;
	u32 clear_bits;
	u32 (*read_control)(void *, unsigned long);
	void (*write_control)(void *, unsigned long, u32);
	u32 (*read_count)(void *, unsigned long);
	void (*write_count)(void *, unsigned long, u32);
};

struct sh_cmt_device;

struct sh_cmt_channel {
	struct sh_cmt_device *cmt;
	unsigned int index;
	unsigned int hwidx;
	void *iostart;
	void *ioctrl;
	unsigned int timer_bit;
	unsigned long flags;
	u32 match_value;
	u32 next_match_value;
	u32 max_match_value;
	raw_spinlock_t lock;
	struct clock_event_device ced;
	struct clocksource cs;
	u64 total_cycles;
	bool cs_enabled;
	long: 64;
	long: 64;
	long: 64;
};

struct sh_cmt_device {
	struct platform_device *pdev;
	const struct sh_cmt_info *info;
	void *mapbase;
	struct clk *clk;
	unsigned long rate;
	unsigned int reg_delay;
	raw_spinlock_t lock;
	struct sh_cmt_channel *channels;
	unsigned int num_channels;
	unsigned int hw_channels;
	bool has_clockevent;
	bool has_clocksource;
};

typedef void (*btf_trace_cros_ec_sensorhub_timestamp)(void *, u32, u32, s64, s64, s64);

typedef void (*btf_trace_cros_ec_sensorhub_data)(void *, u32, u32, s64, s64, s64);

typedef void (*btf_trace_cros_ec_sensorhub_filter)(void *, struct cros_ec_sensors_ts_filter_state *, s64, s64);

enum {
	CROS_EC_SENSOR_LAST_TS = 0,
	CROS_EC_SENSOR_NEW_TS = 1,
	CROS_EC_SENSOR_ALL_TS = 2,
};

struct trace_event_raw_cros_ec_sensorhub_timestamp {
	struct trace_entry ent;
	u32 ec_sample_timestamp;
	u32 ec_fifo_timestamp;
	s64 fifo_timestamp;
	s64 current_timestamp;
	s64 current_time;
	s64 delta;
	char __data[0];
};

struct trace_event_raw_cros_ec_sensorhub_data {
	struct trace_entry ent;
	u32 ec_sensor_num;
	u32 ec_fifo_timestamp;
	s64 fifo_timestamp;
	s64 current_timestamp;
	s64 current_time;
	s64 delta;
	char __data[0];
};

struct trace_event_raw_cros_ec_sensorhub_filter {
	struct trace_entry ent;
	s64 dx;
	s64 dy;
	s64 median_m;
	s64 median_error;
	s64 history_len;
	s64 x;
	s64 y;
	char __data[0];
};

struct trace_event_data_offsets_cros_ec_sensorhub_timestamp {};

struct trace_event_data_offsets_cros_ec_sensorhub_data {};

struct trace_event_data_offsets_cros_ec_sensorhub_filter {};

struct iio_map;

struct iio_map_internal {
	struct iio_dev *indio_dev;
	struct iio_map *map;
	struct list_head l;
};

struct iio_map {
	const char *adc_channel_label;
	const char *consumer_dev_name;
	const char *consumer_channel;
	void *consumer_data;
};

struct iio_channel {
	struct iio_dev *indio_dev;
	const struct iio_chan_spec *channel;
	void *data;
};

struct rockchip_efuse_chip {
	struct device *dev;
	void *base;
	struct clk *clk;
};

struct snd_minor {
	int type;
	int card;
	int device;
	const struct file_operations *f_ops;
	void *private_data;
	struct device *dev;
	struct snd_card *card_ptr;
};

enum tc_fifo_command {
	TC_FIFO_REPLACE = 0,
	TC_FIFO_DESTROY = 1,
	TC_FIFO_STATS = 2,
};

struct tc_fifo_qopt {
	__u32 limit;
};

struct tc_fifo_qopt_offload {
	enum tc_fifo_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_qopt_offload_stats stats;
	};
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_TX = 24,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_RX = 25,
	ETHTOOL_A_COALESCE_TX_AGGR_MAX_BYTES = 26,
	ETHTOOL_A_COALESCE_TX_AGGR_MAX_FRAMES = 27,
	ETHTOOL_A_COALESCE_TX_AGGR_TIME_USECS = 28,
	__ETHTOOL_A_COALESCE_CNT = 29,
	ETHTOOL_A_COALESCE_MAX = 28,
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	struct kernel_ethtool_coalesce kernel_coalesce;
	u32 supported_params;
};

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);

enum {
	TCP_BPF_IPV4 = 0,
	TCP_BPF_IPV6 = 1,
	TCP_BPF_NUM_PROTS = 2,
};

enum {
	TCP_BPF_BASE = 0,
	TCP_BPF_TX = 1,
	TCP_BPF_RX = 2,
	TCP_BPF_TXRX = 3,
	TCP_BPF_NUM_CFGS = 4,
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_rec;

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	spinlock_t encrypt_compl_lock;
	int async_notify;
	u8 async_capable: 1;
	unsigned long tx_bitmask;
};

typedef void (*btf_trace_rpc_xdr_sendto)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_recvfrom)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_reply_pages)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_clnt_free)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_killall)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_shutdown)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_release)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt_err)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_new)(void *, const struct rpc_clnt *, const struct rpc_xprt *, const struct rpc_create_args *);

typedef void (*btf_trace_rpc_clnt_new_err)(void *, const char *, const char *, int);

typedef void (*btf_trace_rpc_clnt_clone_err)(void *, const struct rpc_clnt *, int);

typedef void (*btf_trace_rpc_call_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_connect_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_timeout_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_retry_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_request)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_task_begin)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_run_action)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_sleep)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_wake)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_complete)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_timeout)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_signalled)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_end)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_call_done)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sleep)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_task_wakeup)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_bad_callhdr)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_verifier)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__proc_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__garbage_args)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__unparsable)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__stale_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__bad_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__auth_tooweak)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_prog_unavail_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_timeout_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_bind_version_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unreachable_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unrecognized_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_buf_alloc)(void *, const struct rpc_task *, int);

typedef void (*btf_trace_rpc_call_rpcerror)(void *, const struct rpc_task *, int, int);

typedef void (*btf_trace_rpc_stats_latency)(void *, const struct rpc_task *, ktime_t, ktime_t, ktime_t);

typedef void (*btf_trace_rpc_xdr_overflow)(void *, const struct xdr_stream *, size_t);

typedef void (*btf_trace_rpc_xdr_alignment)(void *, const struct xdr_stream *, size_t, unsigned int);

typedef void (*btf_trace_rpc_socket_state_change)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_connect)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_error)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_reset_connection)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_close)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_shutdown)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_nospace)(void *, const struct rpc_rqst *, const struct sock_xprt *);

typedef void (*btf_trace_xprt_create)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_connect)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_auto)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_done)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_force)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_destroy)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_timer)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_lookup_rqst)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_transmit)(void *, const struct rpc_rqst *, int);

typedef void (*btf_trace_xprt_retransmit)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xprt_ping)(void *, const struct rpc_xprt *, int);

typedef void (*btf_trace_xprt_reserve_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_get_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_put_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xs_data_ready)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xs_stream_read_data)(void *, struct rpc_xprt *, ssize_t, size_t);

typedef void (*btf_trace_xs_stream_read_request)(void *, struct sock_xprt *);

typedef void (*btf_trace_rpcb_getport)(void *, const struct rpc_clnt *, const struct rpc_task *, unsigned int);

typedef void (*btf_trace_rpcb_setport)(void *, const struct rpc_task *, int, unsigned short);

typedef void (*btf_trace_pmap_register)(void *, u32, u32, int, unsigned short);

typedef void (*btf_trace_rpcb_register)(void *, u32, u32, const char *, const char *);

typedef void (*btf_trace_rpcb_unregister)(void *, u32, u32, const char *);

typedef void (*btf_trace_rpc_tls_unavailable)(void *, const struct rpc_clnt *, const struct rpc_xprt *);

typedef void (*btf_trace_rpc_tls_not_started)(void *, const struct rpc_clnt *, const struct rpc_xprt *);

typedef void (*btf_trace_svc_xdr_recvfrom)(void *, const struct xdr_buf *);

typedef void (*btf_trace_svc_xdr_sendto)(void *, __be32, const struct xdr_buf *);

typedef void (*btf_trace_svc_authenticate)(void *, const struct svc_rqst *, enum svc_auth_status);

typedef void (*btf_trace_svc_process)(void *, const struct svc_rqst *, const char *);

typedef void (*btf_trace_svc_defer)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_drop)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_send)(void *, const struct svc_rqst *, int);

typedef void (*btf_trace_svc_replace_page_err)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_stats_latency)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_create_err)(void *, const char *, const char *, struct sockaddr *, size_t, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_enqueue)(void *, const struct svc_xprt *, unsigned long);

typedef void (*btf_trace_svc_xprt_dequeue)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_no_write_space)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_close)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_detach)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_free)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_start)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_upcall)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_unavailable)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_not_started)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_timed_out)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_accept)(void *, const struct svc_xprt *, const char *);

typedef void (*btf_trace_svc_wake_up)(void *, int);

typedef void (*btf_trace_svc_alloc_arg_err)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_svc_defer_drop)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_queue)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_recv)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svcsock_new)(void *, const void *, const struct socket *);

typedef void (*btf_trace_svcsock_free)(void *, const void *, const struct socket *);

typedef void (*btf_trace_svcsock_marker)(void *, const struct svc_xprt *, __be32);

typedef void (*btf_trace_svcsock_udp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_eagain)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_data_ready)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_write_space)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_short)(void *, const struct svc_xprt *, u32, u32);

typedef void (*btf_trace_svcsock_tcp_state)(void *, const struct svc_xprt *, const struct socket *);

typedef void (*btf_trace_svcsock_accept_err)(void *, const struct svc_xprt *, const char *, long);

typedef void (*btf_trace_svcsock_getpeername_err)(void *, const struct svc_xprt *, const char *, long);

typedef void (*btf_trace_cache_entry_expired)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_upcall)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_update)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_make_negative)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_no_listener)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_svc_register)(void *, const char *, const u32, const int, const unsigned short, const unsigned short, int);

typedef void (*btf_trace_svc_noregister)(void *, const char *, const u32, const int, const unsigned short, const unsigned short, int);

typedef void (*btf_trace_svc_unregister)(void *, const char *, const u32, int);

struct trace_event_raw_rpc_xdr_buf_class {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_class {
	struct trace_entry ent;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new {
	struct trace_entry ent;
	unsigned int client_id;
	unsigned long xprtsec;
	unsigned long flags;
	u32 __data_loc_program;
	u32 __data_loc_server;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new_err {
	struct trace_entry ent;
	int error;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_clone_err {
	struct trace_entry ent;
	unsigned int client_id;
	int error;
	char __data[0];
};

struct trace_event_raw_rpc_task_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_request {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	bool async;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_rpc_task_running {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *action;
	unsigned long runstate;
	int status;
	unsigned short flags;
	char __data[0];
};

struct trace_event_raw_rpc_task_queued {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned long timeout;
	unsigned long runstate;
	int status;
	unsigned short flags;
	u32 __data_loc_q_name;
	char __data[0];
};

struct trace_event_raw_rpc_failure {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_reply_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 __data_loc_progname;
	u32 version;
	u32 __data_loc_procname;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpc_buf_alloc {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	size_t callsize;
	size_t recvsize;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_call_rpcerror {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int tk_status;
	int rpc_status;
	char __data[0];
};

struct trace_event_raw_rpc_stats_latency {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	unsigned long backlog;
	unsigned long rtt;
	unsigned long execute;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_overflow {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t requested;
	const void *end;
	const void *p;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_alignment {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t offset;
	unsigned int copied;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_xs_socket_event {
	struct trace_entry ent;
	unsigned int socket_state;
	unsigned int sock_state;
	unsigned long long ino;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_xs_socket_event_done {
	struct trace_entry ent;
	int error;
	unsigned int socket_state;
	unsigned int sock_state;
	unsigned long long ino;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_rpc_socket_nospace {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int total;
	unsigned int remaining;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_lifetime_class {
	struct trace_entry ent;
	unsigned long state;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_event {
	struct trace_entry ent;
	u32 xid;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_transmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	int status;
	char __data[0];
};

struct trace_event_raw_xprt_retransmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int ntrans;
	int version;
	unsigned long timeout;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_xprt_ping {
	struct trace_entry ent;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_writelock_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	char __data[0];
};

struct trace_event_raw_xprt_cong_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	unsigned long cong;
	unsigned long cwnd;
	bool wait;
	char __data[0];
};

struct trace_event_raw_xprt_reserve {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	char __data[0];
};

struct trace_event_raw_xs_data_ready {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_data {
	struct trace_entry ent;
	ssize_t err;
	size_t total;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_request {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 xid;
	unsigned long copied;
	unsigned int reclen;
	unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rpcb_getport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int bind_version;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpcb_setport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	unsigned short port;
	char __data[0];
};

struct trace_event_raw_pmap_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int port;
	char __data[0];
};

struct trace_event_raw_rpcb_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_addr;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcb_unregister {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpc_tls_class {
	struct trace_entry ent;
	unsigned long requested_policy;
	u32 version;
	u32 __data_loc_servername;
	u32 __data_loc_progname;
	char __data[0];
};

struct trace_event_raw_svc_xdr_msg_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_xdr_buf_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_authenticate {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	unsigned long svc_status;
	unsigned long auth_stat;
	char __data[0];
};

struct trace_event_raw_svc_process {
	struct trace_entry ent;
	u32 xid;
	u32 vers;
	u32 proc;
	u32 __data_loc_service;
	u32 __data_loc_procedure;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_rqst_event {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	unsigned long flags;
	char __data[0];
};

struct trace_event_raw_svc_rqst_status {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	int status;
	unsigned long flags;
	char __data[0];
};

struct trace_event_raw_svc_replace_page_err {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	const void *begin;
	const void *respages;
	const void *nextpage;
	char __data[0];
};

struct trace_event_raw_svc_stats_latency {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	unsigned long execute;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_svc_xprt_create_err {
	struct trace_entry ent;
	long error;
	u32 __data_loc_program;
	u32 __data_loc_protocol;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_enqueue {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned long flags;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svc_xprt_dequeue {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned long flags;
	unsigned int netns_ino;
	unsigned long wakeup;
	char __data[0];
};

struct trace_event_raw_svc_xprt_event {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned long flags;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svc_xprt_accept {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned long flags;
	unsigned int netns_ino;
	u32 __data_loc_protocol;
	u32 __data_loc_service;
	char __data[0];
};

struct trace_event_raw_svc_wake_up {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_svc_alloc_arg_err {
	struct trace_entry ent;
	unsigned int requested;
	unsigned int allocated;
	char __data[0];
};

struct trace_event_raw_svc_deferred_event {
	struct trace_entry ent;
	const void *dr;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_lifetime_class {
	struct trace_entry ent;
	unsigned int netns_ino;
	const void *svsk;
	const void *sk;
	unsigned long type;
	unsigned long family;
	unsigned long state;
	char __data[0];
};

struct trace_event_raw_svcsock_marker {
	struct trace_entry ent;
	unsigned int length;
	bool last;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_class {
	struct trace_entry ent;
	ssize_t result;
	unsigned long flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_recv_short {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	unsigned long flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_state {
	struct trace_entry ent;
	unsigned long socket_state;
	unsigned long sock_state;
	unsigned long flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_accept_class {
	struct trace_entry ent;
	long status;
	u32 __data_loc_service;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_cache_event {
	struct trace_entry ent;
	const struct cache_head *h;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_register_class {
	struct trace_entry ent;
	u32 version;
	unsigned long family;
	unsigned short protocol;
	unsigned short port;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_svc_unregister {
	struct trace_entry ent;
	u32 version;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_data_offsets_rpc_clnt_new {
	u32 program;
	u32 server;
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpc_clnt_new_err {
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_request {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_task_queued {
	u32 q_name;
};

struct trace_event_data_offsets_rpc_reply_event {
	u32 progname;
	u32 procname;
	u32 servername;
};

struct trace_event_data_offsets_rpc_stats_latency {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_xdr_overflow {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_rpc_xdr_alignment {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_rpc_xprt_lifetime_class {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpc_xprt_event {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_retransmit {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_xprt_ping {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xs_data_ready {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xs_stream_read_data {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xs_stream_read_request {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpcb_getport {
	u32 servername;
};

struct trace_event_data_offsets_rpcb_register {
	u32 addr;
	u32 netid;
};

struct trace_event_data_offsets_rpcb_unregister {
	u32 netid;
};

struct trace_event_data_offsets_rpc_tls_class {
	u32 servername;
	u32 progname;
};

struct trace_event_data_offsets_svc_authenticate {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_process {
	u32 service;
	u32 procedure;
	u32 addr;
};

struct trace_event_data_offsets_svc_rqst_event {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_rqst_status {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_replace_page_err {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_stats_latency {
	u32 server;
	u32 client;
	u32 procedure;
};

struct trace_event_data_offsets_svc_xprt_create_err {
	u32 program;
	u32 protocol;
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_enqueue {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_xprt_dequeue {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_xprt_event {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_xprt_accept {
	u32 server;
	u32 client;
	u32 protocol;
	u32 service;
};

struct trace_event_data_offsets_svc_deferred_event {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_marker {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_class {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_recv_short {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_state {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_accept_class {
	u32 service;
};

struct trace_event_data_offsets_cache_event {
	u32 name;
};

struct trace_event_data_offsets_register_class {
	u32 program;
};

struct trace_event_data_offsets_svc_unregister {
	u32 program;
};

struct trace_event_data_offsets_rpc_xdr_buf_class {};

struct trace_event_data_offsets_rpc_clnt_class {};

struct trace_event_data_offsets_rpc_clnt_clone_err {};

struct trace_event_data_offsets_rpc_task_status {};

struct trace_event_data_offsets_rpc_task_running {};

struct trace_event_data_offsets_rpc_failure {};

struct trace_event_data_offsets_rpc_buf_alloc {};

struct trace_event_data_offsets_rpc_call_rpcerror {};

struct trace_event_data_offsets_xs_socket_event {};

struct trace_event_data_offsets_xs_socket_event_done {};

struct trace_event_data_offsets_rpc_socket_nospace {};

struct trace_event_data_offsets_xprt_transmit {};

struct trace_event_data_offsets_xprt_writelock_event {};

struct trace_event_data_offsets_xprt_cong_event {};

struct trace_event_data_offsets_xprt_reserve {};

struct trace_event_data_offsets_rpcb_setport {};

struct trace_event_data_offsets_pmap_register {};

struct trace_event_data_offsets_svc_xdr_msg_class {};

struct trace_event_data_offsets_svc_xdr_buf_class {};

struct trace_event_data_offsets_svc_wake_up {};

struct trace_event_data_offsets_svc_alloc_arg_err {};

struct trace_event_data_offsets_svcsock_lifetime_class {};

enum hp_flags_bits {
	HANDSHAKE_F_PROTO_NOTIFY = 0,
};

enum {
	HANDSHAKE_CMD_READY = 1,
	HANDSHAKE_CMD_ACCEPT = 2,
	HANDSHAKE_CMD_DONE = 3,
	__HANDSHAKE_CMD_MAX = 4,
	HANDSHAKE_CMD_MAX = 3,
};

enum hn_flags_bits {
	HANDSHAKE_F_NET_DRAINING = 0,
};

struct handshake_net {
	spinlock_t hn_lock;
	int hn_pending;
	int hn_pending_max;
	struct list_head hn_requests;
	unsigned long hn_flags;
};

struct sys64_hook {
	unsigned long esr_mask;
	unsigned long esr_val;
	void (*handler)(unsigned long, struct pt_regs *);
};

enum dl_bw_request {
	dl_bw_req_check_overflow = 0,
	dl_bw_req_alloc = 1,
	dl_bw_req_free = 2,
};

struct idle_timer {
	struct hrtimer timer;
	int done;
};

typedef struct rt_rq *rt_rq_iter_t;

struct pids_cgroup {
	struct cgroup_subsys_state css;
	atomic64_t counter;
	atomic64_t limit;
	int64_t watermark;
	struct cgroup_file events_file;
	atomic64_t events_limit;
};

struct audit_fsnotify_mark {
	dev_t dev;
	unsigned long ino;
	char *path;
	struct fsnotify_mark mark;
	struct audit_krule *rule;
};

enum {
	Blktrace_setup = 1,
	Blktrace_running = 2,
	Blktrace_stopped = 3,
};

enum blktrace_notify {
	__BLK_TN_PROCESS = 0,
	__BLK_TN_TIMESTAMP = 1,
	__BLK_TN_MESSAGE = 2,
	__BLK_TN_CGROUP = 256,
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

struct blk_io_trace {
	__u32 magic;
	__u32 sequence;
	__u64 time;
	__u64 sector;
	__u32 bytes;
	__u32 action;
	__u32 pid;
	__u32 device;
	__u32 cpu;
	__u16 error;
	__u16 pdu_len;
};

struct blk_user_trace_setup {
	char name[32];
	__u16 act_mask;
	__u32 buf_size;
	__u32 buf_nr;
	__u64 start_lba;
	__u64 end_lba;
	__u32 pid;
};

struct blk_io_trace_remap {
	__be32 device_from;
	__be32 device_to;
	__be64 sector_from;
};

typedef void blk_log_action_t(struct trace_iterator *, const char *, bool);

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

struct swap_iocb {
	struct kiocb iocb;
	struct bio_vec bvec[32];
	int pages;
	int len;
};

enum {
	PAGE_REPORTING_IDLE = 0,
	PAGE_REPORTING_REQUESTED = 1,
	PAGE_REPORTING_ACTIVE = 2,
};

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	u32 io_folios;
	struct inode *io_inode;
	size_t io_size;
	loff_t io_offset;
	sector_t io_sector;
	struct bio *io_bio;
	struct bio io_inline_bio;
};

struct iomap_readpage_ctx {
	struct folio *cur_folio;
	bool cur_folio_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

struct iomap_folio_state {
	spinlock_t state_lock;
	unsigned int read_bytes_pending;
	atomic_t write_bytes_pending;
	unsigned long state[0];
};

typedef int (*iomap_punch_t)(struct inode *, loff_t, loff_t);

struct iomap_writeback_ops;

struct iomap_writepage_ctx {
	struct iomap iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
};

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_folio)(struct folio *, loff_t);
};

typedef struct ext2_dir_entry_2 ext2_dirent;

enum Opt_errors {
	Opt_errors_continue = 0,
	Opt_errors_panic = 1,
};

enum squashfs_param {
	Opt_errors___2 = 0,
	Opt_threads = 1,
};

struct squashfs_mount_opts {
	enum Opt_errors errors;
	const struct squashfs_decompressor_thread_ops *thread_ops;
	int thread_num;
};

struct squashfs_super_block {
	__le32 s_magic;
	__le32 inodes;
	__le32 mkfs_time;
	__le32 block_size;
	__le32 fragments;
	__le16 compression;
	__le16 block_log;
	__le16 flags;
	__le16 no_ids;
	__le16 s_major;
	__le16 s_minor;
	__le64 root_inode;
	__le64 bytes_used;
	__le64 id_table_start;
	__le64 xattr_id_table_start;
	__le64 inode_table_start;
	__le64 directory_table_start;
	__le64 fragment_table_start;
	__le64 lookup_table_start;
};

struct squashfs_xattr_id_table {
	__le64 xattr_table_start;
	__le32 xattr_ids;
	__le32 unused;
};

struct nfs3_createdata {
	struct rpc_message msg;
	union {
		struct nfs3_createargs create;
		struct nfs3_mkdirargs mkdir;
		struct nfs3_symlinkargs symlink;
		struct nfs3_mknodargs mknod;
	} arg;
	struct nfs3_diropres res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
	struct nfs_fattr dir_attr;
};

struct crypto_istat_rng {
	atomic64_t generate_cnt;
	atomic64_t generate_tlen;
	atomic64_t seed_cnt;
	atomic64_t err_cnt;
};

struct crypto_report_rng {
	char type[64];
	unsigned int seedsize;
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

typedef __be16 csum_fn(void *, unsigned int);

struct t10_pi_tuple {
	__be16 guard_tag;
	__be16 app_tag;
	__be32 ref_tag;
};

struct crc64_pi_tuple {
	__be64 guard_tag;
	__be16 app_tag;
	__u8 ref_tag[6];
};

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
	unsigned int nbits;
};

union gic_base {
	void *common_base;
	void __attribute__((btf_type_tag("percpu"))) **percpu_base;
};

struct gic_chip_data___2 {
	union gic_base dist_base;
	union gic_base cpu_base;
	void *raw_dist_base;
	void *raw_cpu_base;
	u32 percpu_offset;
	u32 saved_spi_enable[32];
	u32 saved_spi_active[32];
	u32 saved_spi_conf[64];
	u32 saved_spi_target[255];
	u32 __attribute__((btf_type_tag("percpu"))) *saved_ppi_enable;
	u32 __attribute__((btf_type_tag("percpu"))) *saved_ppi_active;
	u32 __attribute__((btf_type_tag("percpu"))) *saved_ppi_conf;
	struct irq_domain *domain;
	unsigned int gic_irqs;
};

enum acpi_madt_gic_version {
	ACPI_MADT_GIC_VERSION_NONE = 0,
	ACPI_MADT_GIC_VERSION_V1 = 1,
	ACPI_MADT_GIC_VERSION_V2 = 2,
	ACPI_MADT_GIC_VERSION_V3 = 3,
	ACPI_MADT_GIC_VERSION_V4 = 4,
	ACPI_MADT_GIC_VERSION_RESERVED = 5,
};

struct phy_reg {
	u16 value;
	u32 addr;
};

struct usb3phy_reg {
	u32 offset;
	u32 enable_bit;
	u32 write_enable;
};

struct rockchip_usb3phy_port_cfg {
	unsigned int reg;
	struct usb3phy_reg typec_conn_dir;
	struct usb3phy_reg usb3tousb2_en;
	struct usb3phy_reg external_psm;
	struct usb3phy_reg pipe_status;
	struct usb3phy_reg usb3_host_disable;
	struct usb3phy_reg usb3_host_port;
	struct usb3phy_reg uphy_dp_sel;
};

struct rockchip_typec_phy {
	struct device *dev;
	void *base;
	struct extcon_dev *extcon;
	struct regmap *grf_regs;
	struct clk *clk_core;
	struct clk *clk_ref;
	struct reset_control *uphy_rst;
	struct reset_control *pipe_rst;
	struct reset_control *tcphy_rst;
	const struct rockchip_usb3phy_port_cfg *port_cfgs;
	struct mutex lock;
	bool flip;
	u8 mode;
};

enum pincfg_type {
	PINCFG_TYPE_FUNC = 0,
	PINCFG_TYPE_DAT = 1,
	PINCFG_TYPE_PUD = 2,
	PINCFG_TYPE_DRV = 3,
	PINCFG_TYPE_CON_PDN = 4,
	PINCFG_TYPE_PUD_PDN = 5,
	PINCFG_TYPE_NUM = 6,
};

struct pin_config {
	const char *property;
	enum pincfg_type param;
};

enum gio_reg_index {
	GIO_REG_ODEN = 0,
	GIO_REG_DATA = 1,
	GIO_REG_IODIR = 2,
	GIO_REG_EC = 3,
	GIO_REG_EI = 4,
	GIO_REG_MASK = 5,
	GIO_REG_LEVEL = 6,
	GIO_REG_STAT = 7,
	NUMBER_OF_GIO_REGISTERS = 8,
};

struct brcmstb_gpio_priv;

struct brcmstb_gpio_bank {
	struct list_head node;
	int id;
	struct gpio_chip gc;
	struct brcmstb_gpio_priv *parent_priv;
	u32 width;
	u32 wake_active;
	u32 saved_regs[7];
};

struct brcmstb_gpio_priv {
	struct list_head bank_list;
	void *reg_base;
	struct platform_device *pdev;
	struct irq_domain *irq_domain;
	struct irq_chip irq_chip;
	int parent_irq;
	int gpio_base;
	int num_gpios;
	int parent_wake_irq;
};

struct gpio_rcar_info {
	bool has_outdtsel;
	bool has_both_edge_trigger;
	bool has_always_in;
	bool has_inen;
};

struct gpio_rcar_bank_info {
	u32 iointsel;
	u32 inoutsel;
	u32 outdt;
	u32 posneg;
	u32 edglevel;
	u32 bothedge;
	u32 intmsk;
};

struct gpio_rcar_priv {
	void *base;
	spinlock_t lock;
	struct device *dev;
	struct gpio_chip gpio_chip;
	unsigned int irq_parent;
	atomic_t wakeup_path;
	struct gpio_rcar_info info;
	struct gpio_rcar_bank_info bank_info;
};

struct samsung_pwm_variant {
	u8 bits;
	u8 div_base;
	u8 tclk_mask;
	u8 output_mask;
	bool has_tint_cstat;
};

struct samsung_pwm_channel {
	u32 period_ns;
	u32 duty_ns;
	u32 tin_ns;
};

struct samsung_pwm_chip {
	struct pwm_chip chip;
	struct samsung_pwm_variant variant;
	u8 inverter_mask;
	u8 disabled_mask;
	void *base;
	struct clk *base_clk;
	struct clk *tclk0;
	struct clk *tclk1;
	struct samsung_pwm_channel channel[5];
};

struct hisi_pcie {
	void *reg_base;
};

struct acpi_dev_walk_context {
	int (*fn)(struct acpi_device *, void *);
	void *data;
};

struct acpi_port_info {
	char *name;
	u16 start;
	u16 end;
	u8 osi_dependency;
};

typedef acpi_status (*acpi_object_converter)(struct acpi_namespace_node *, union acpi_operand_object *, union acpi_operand_object **);

struct acpi_simple_repair_info {
	char name[4];
	u32 unexpected_btypes;
	u32 package_index;
	acpi_object_converter object_converter;
};

struct iproc_asiu_div {
	unsigned int offset;
	unsigned int en_shift;
	unsigned int high_shift;
	unsigned int high_width;
	unsigned int low_shift;
	unsigned int low_width;
};

struct iproc_asiu;

struct iproc_asiu_clk {
	struct clk_hw hw;
	const char *name;
	struct iproc_asiu *asiu;
	unsigned long rate;
	struct iproc_asiu_div div;
	struct iproc_asiu_gate gate;
};

struct iproc_asiu {
	void *div_base;
	void *gate_base;
	struct clk_hw_onecell_data *clk_data;
	struct iproc_asiu_clk *clks;
};

struct clk_busy_divider {
	struct clk_divider div;
	const struct clk_ops *div_ops;
	void *reg;
	u8 shift;
};

struct clk_busy_mux {
	struct clk_mux mux;
	const struct clk_ops *mux_ops;
	void *reg;
	u8 shift;
};

struct clk_cpu {
	struct clk_hw hw;
	struct clk *div;
	struct clk *mux;
	struct clk *pll;
	struct clk *step;
};

struct clk_pfd {
	struct clk_hw hw;
	void *reg;
	u8 idx;
};

struct imx_clk_gpr {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 mask;
	u32 reg;
	const u32 *mux_table;
};

struct exynos_clkout_variant {
	u32 mux_mask;
};

struct exynos_clkout {
	struct clk_gate gate;
	struct clk_mux mux;
	spinlock_t slock;
	void *reg;
	struct device_node *np;
	u32 pmu_debug_save;
	struct clk_hw_onecell_data data;
};

struct _ccu_mult {
	unsigned long mult;
	unsigned long min;
	unsigned long max;
};

struct _ccu_nkmp {
	unsigned long n;
	unsigned long min_n;
	unsigned long max_n;
	unsigned long k;
	unsigned long min_k;
	unsigned long max_k;
	unsigned long m;
	unsigned long min_m;
	unsigned long max_m;
	unsigned long p;
	unsigned long min_p;
	unsigned long max_p;
};

struct uniphier_clk_gate {
	struct clk_hw hw;
	struct regmap *regmap;
	unsigned int reg;
	unsigned int bit;
};

struct pl330_of_quirks {
	char *quirk;
	int id;
};

enum pl330_cachectrl {
	CCTRL0 = 0,
	CCTRL1 = 1,
	CCTRL2 = 2,
	CCTRL3 = 3,
	INVALID1 = 4,
	INVALID2 = 5,
	CCTRL6 = 6,
	CCTRL7 = 7,
};

enum pl330_byteswap {
	SWAP_NO = 0,
	SWAP_2 = 1,
	SWAP_4 = 2,
	SWAP_8 = 3,
	SWAP_16 = 4,
};

enum desc_status {
	FREE = 0,
	PREP = 1,
	BUSY = 2,
	PAUSED = 3,
	DONE___2 = 4,
};

enum pl330_dmac_state {
	UNINIT___2 = 0,
	INIT = 1,
	DYING = 2,
};

enum pl330_op_err {
	PL330_ERR_NONE = 0,
	PL330_ERR_ABORT = 1,
	PL330_ERR_FAIL = 2,
};

enum dmamov_dst {
	SAR = 0,
	CCR = 1,
	DAR = 2,
};

enum pl330_cond {
	SINGLE = 0,
	BURST = 1,
	ALWAYS = 2,
};

struct pl330_dmac;

struct pl330_thread;

struct dma_pl330_chan {
	struct tasklet_struct task;
	struct dma_chan chan;
	struct list_head submitted_list;
	struct list_head work_list;
	struct list_head completed_list;
	struct pl330_dmac *dmac;
	spinlock_t lock;
	struct pl330_thread *thread;
	int burst_sz;
	int burst_len;
	phys_addr_t fifo_addr;
	dma_addr_t fifo_dma;
	enum dma_data_direction dir;
	struct dma_slave_config slave_config;
	bool cyclic;
	bool active;
};

struct pl330_config {
	u32 periph_id;
	unsigned int mode;
	unsigned int data_bus_width: 10;
	unsigned int data_buf_dep: 11;
	unsigned int num_chan: 4;
	unsigned int num_peri: 6;
	u32 peri_ns;
	unsigned int num_events: 6;
	u32 irq_ns;
};

struct _pl330_tbd {
	bool reset_dmac;
	bool reset_mngr;
	u8 reset_chan;
};

struct pl330_dmac {
	struct dma_device ddma;
	struct list_head desc_pool;
	spinlock_t pool_lock;
	unsigned int mcbufsz;
	void *base;
	struct pl330_config pcfg;
	spinlock_t lock;
	int events[32];
	dma_addr_t mcode_bus;
	void *mcode_cpu;
	struct pl330_thread *channels;
	struct pl330_thread *manager;
	struct tasklet_struct tasks;
	struct _pl330_tbd dmac_tbd;
	enum pl330_dmac_state state;
	struct list_head req_done;
	unsigned int num_peripherals;
	struct dma_pl330_chan *peripherals;
	int quirks;
	struct reset_control *rstc;
	struct reset_control *rstc_ocp;
};

struct dma_pl330_desc;

struct _pl330_req {
	u32 mc_bus;
	void *mc_cpu;
	struct dma_pl330_desc *desc;
};

struct pl330_thread {
	u8 id;
	int ev;
	bool free;
	struct pl330_dmac *dmac;
	struct _pl330_req req[2];
	unsigned int lstenq;
	int req_running;
};

struct pl330_xfer {
	u32 src_addr;
	u32 dst_addr;
	u32 bytes;
};

struct pl330_reqcfg {
	unsigned int dst_inc: 1;
	unsigned int src_inc: 1;
	bool nonsecure;
	bool privileged;
	bool insnaccess;
	unsigned int brst_len: 5;
	unsigned int brst_size: 3;
	enum pl330_cachectrl dcctl;
	enum pl330_cachectrl scctl;
	enum pl330_byteswap swap;
	struct pl330_config *pcfg;
};

struct dma_pl330_desc {
	struct list_head node;
	struct dma_async_tx_descriptor txd;
	struct pl330_xfer px;
	struct pl330_reqcfg rqcfg;
	enum desc_status status;
	int bytes_requested;
	bool last;
	struct dma_pl330_chan *pchan;
	enum dma_transfer_direction rqtype;
	unsigned int peri: 5;
	struct list_head rqd;
};

struct _arg_GO {
	u8 chan;
	u32 addr;
	unsigned int ns;
};

struct _xfer_spec {
	u32 ccr;
	struct dma_pl330_desc *desc;
};

struct _arg_LPEND {
	enum pl330_cond cond;
	bool forever;
	unsigned int loop;
	u8 bjump;
};

struct imx8m_blk_ctrl_domain_data;

struct imx8m_blk_ctrl_data {
	int max_reg;
	notifier_fn_t power_notifier_fn;
	const struct imx8m_blk_ctrl_domain_data *domains;
	int num_domains;
};

struct imx8m_blk_ctrl_domain_data {
	const char *name;
	const char * const *clk_names;
	const char * const *path_names;
	const char *gpc_name;
	int num_clks;
	int num_paths;
	u32 rst_mask;
	u32 clk_mask;
	u32 mipi_phy_rst_mask;
};

struct imx8m_blk_ctrl;

struct imx8m_blk_ctrl_domain {
	struct generic_pm_domain genpd;
	const struct imx8m_blk_ctrl_domain_data *data;
	struct clk_bulk_data clks[4];
	struct icc_bulk_data paths[4];
	struct device *power_dev;
	struct imx8m_blk_ctrl *bc;
	int num_paths;
};

struct imx8m_blk_ctrl {
	struct device *dev;
	struct notifier_block power_nb;
	struct device *bus_power_dev;
	struct regmap *regmap;
	struct imx8m_blk_ctrl_domain *domains;
	struct genpd_onecell_data onecell_data;
};

struct xen_device_domain_owner {
	domid_t domain;
	struct pci_dev *dev;
	struct list_head list;
};

struct physdev_pci_device_add {
	uint16_t seg;
	uint8_t bus;
	uint8_t devfn;
	uint32_t flags;
	struct {
		uint8_t bus;
		uint8_t devfn;
	} physfn;
	uint32_t optarr[0];
};

struct physdev_manage_pci_ext {
	uint8_t bus;
	uint8_t devfn;
	unsigned int is_extfn;
	unsigned int is_virtfn;
	struct {
		uint8_t bus;
		uint8_t devfn;
	} physfn;
};

struct physdev_manage_pci {
	uint8_t bus;
	uint8_t devfn;
};

struct devm_of_regulator_matches {
	struct of_regulator_match *matches;
	unsigned int num_matches;
};

struct hi655x_regulator {
	unsigned int disable_reg;
	unsigned int status_reg;
	struct regulator_desc rdesc;
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

enum imx_tx_state {
	OFF___2 = 0,
	WAIT_AFTER_RTS = 1,
	SEND = 2,
	WAIT_AFTER_SEND = 3,
};

struct imx_uart_data;

struct imx_port {
	struct uart_port port;
	struct timer_list timer;
	unsigned int old_status;
	unsigned int have_rtscts: 1;
	unsigned int have_rtsgpio: 1;
	unsigned int dte_mode: 1;
	unsigned int inverted_tx: 1;
	unsigned int inverted_rx: 1;
	struct clk *clk_ipg;
	struct clk *clk_per;
	const struct imx_uart_data *devdata;
	struct mctrl_gpios *gpios;
	int idle_counter;
	unsigned int dma_is_enabled: 1;
	unsigned int dma_is_rxing: 1;
	unsigned int dma_is_txing: 1;
	struct dma_chan *dma_chan_rx;
	struct dma_chan *dma_chan_tx;
	struct scatterlist rx_sgl;
	struct scatterlist tx_sgl[2];
	void *rx_buf;
	struct circ_buf rx_ring;
	unsigned int rx_buf_size;
	unsigned int rx_period_length;
	unsigned int rx_periods;
	dma_cookie_t rx_cookie;
	unsigned int tx_bytes;
	unsigned int dma_tx_nents;
	unsigned int saved_reg[10];
	bool context_saved;
	enum imx_tx_state tx_state;
	struct hrtimer trigger_start_tx;
	struct hrtimer trigger_stop_tx;
};

enum imx_uart_type {
	IMX1_UART = 0,
	IMX21_UART = 1,
};

struct imx_uart_data {
	unsigned int uts_reg;
	enum imx_uart_type devtype;
};

struct imx_port_ucrs {
	unsigned int ucr1;
	unsigned int ucr2;
	unsigned int ucr3;
};

struct tpmrm_priv {
	struct file_priv priv;
	struct tpm_space space;
};

struct iommu_group {
	struct kobject kobj;
	struct kobject *devices_kobj;
	struct list_head devices;
	struct xarray pasid_array;
	struct mutex mutex;
	void *iommu_data;
	void (*iommu_data_release)(void *);
	char *name;
	int id;
	struct iommu_domain *default_domain;
	struct iommu_domain *blocking_domain;
	struct iommu_domain *domain;
	struct list_head entry;
	unsigned int owner_cnt;
	void *owner;
};

struct iommu_group_attribute {
	struct attribute attr;
	ssize_t (*show)(struct iommu_group *, char *);
	ssize_t (*store)(struct iommu_group *, const char *, size_t);
};

enum iommu_fault_type {
	IOMMU_FAULT_DMA_UNRECOV = 1,
	IOMMU_FAULT_PAGE_REQ = 2,
};

enum {
	IOMMU_SET_DOMAIN_MUST_SUCCEED = 1,
};

struct group_device {
	struct list_head list;
	struct device *dev;
	char *name;
};

struct group_for_pci_data {
	struct pci_dev *pdev;
	struct iommu_group *group;
};

struct auxiliary_device;

struct auxiliary_device_id;

struct auxiliary_driver {
	int (*probe)(struct auxiliary_device *, const struct auxiliary_device_id *);
	void (*remove)(struct auxiliary_device *);
	void (*shutdown)(struct auxiliary_device *);
	int (*suspend)(struct auxiliary_device *, pm_message_t);
	int (*resume)(struct auxiliary_device *);
	const char *name;
	struct device_driver driver;
	const struct auxiliary_device_id *id_table;
};

struct auxiliary_device {
	struct device dev;
	const char *name;
	u32 id;
};

struct auxiliary_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct platform_msi_priv_data {
	struct device *dev;
	void *host_data;
	msi_alloc_info_t arg;
	irq_write_msi_msg_t write_msg;
	int devid;
};

struct ata_acpi_hotplug_context {
	struct acpi_hotplug_context hp;
	union {
		struct ata_port *ap;
		struct ata_device *dev;
	} data;
};

struct ata_acpi_gtf {
	u8 tf[7];
};

struct mtd_partitions {
	const struct mtd_partition *parts;
	int nr_parts;
	const struct mtd_part_parser *parser;
};

enum nand_bbt_block_status {
	NAND_BBT_BLOCK_STATUS_UNKNOWN = 0,
	NAND_BBT_BLOCK_GOOD = 1,
	NAND_BBT_BLOCK_WORN = 2,
	NAND_BBT_BLOCK_RESERVED = 3,
	NAND_BBT_BLOCK_FACTORY_BAD = 4,
	NAND_BBT_BLOCK_NUM_STATUS = 5,
};

struct denali_chip_sel {
	int bank;
	u32 hwhr2_and_we_2_re;
	u32 tcwaw_and_addr_2_data;
	u32 re_2_we;
	u32 acc_clks;
	u32 rdwr_en_lo_cnt;
	u32 rdwr_en_hi_cnt;
	u32 cs_setup_cnt;
	u32 re_2_re;
};

struct denali_chip {
	struct nand_chip chip;
	struct list_head node;
	unsigned int nsels;
	struct denali_chip_sel sels[0];
};

struct denali_controller {
	struct nand_controller controller;
	struct device *dev;
	struct list_head chips;
	unsigned long clk_rate;
	unsigned long clk_x_rate;
	void *reg;
	void *host;
	struct completion complete;
	int irq;
	u32 irq_mask;
	u32 irq_status;
	spinlock_t irq_lock;
	bool dma_avail;
	int devs_per_cs;
	int oob_skip_bytes;
	int active_bank;
	int nbanks;
	unsigned int revision;
	unsigned int caps;
	const struct nand_ecc_caps *ecc_caps;
	u32 (*host_read)(struct denali_controller *, u32);
	void (*host_write)(struct denali_controller *, u32, u32);
	void (*setup_dma)(struct denali_controller *, dma_addr_t, int, bool);
};

typedef void (*btf_trace_spi_controller_idle)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_controller_busy)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_setup)(void *, struct spi_device *, int);

typedef void (*btf_trace_spi_set_cs)(void *, struct spi_device *, bool);

typedef void (*btf_trace_spi_message_submit)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_start)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_done)(void *, struct spi_message *);

typedef void (*btf_trace_spi_transfer_start)(void *, struct spi_message *, struct spi_transfer *);

typedef void (*btf_trace_spi_transfer_stop)(void *, struct spi_message *, struct spi_transfer *);

struct spi_board_info {
	char modalias[32];
	const void *platform_data;
	const struct software_node *swnode;
	void *controller_data;
	int irq;
	u32 max_speed_hz;
	u16 bus_num;
	u16 chip_select;
	u32 mode;
};

struct boardinfo {
	struct list_head list;
	struct spi_board_info board_info;
};

struct trace_event_raw_spi_controller {
	struct trace_entry ent;
	int bus_num;
	char __data[0];
};

struct trace_event_raw_spi_setup {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	unsigned long mode;
	unsigned int bits_per_word;
	unsigned int max_speed_hz;
	int status;
	char __data[0];
};

struct trace_event_raw_spi_set_cs {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	unsigned long mode;
	bool enable;
	char __data[0];
};

struct trace_event_raw_spi_message {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	char __data[0];
};

struct trace_event_raw_spi_message_done {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	unsigned int frame;
	unsigned int actual;
	char __data[0];
};

struct trace_event_raw_spi_transfer {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_transfer *xfer;
	int len;
	u32 __data_loc_rx_buf;
	u32 __data_loc_tx_buf;
	char __data[0];
};

typedef void (*spi_res_release_t)(struct spi_controller *, struct spi_message *, void *);

struct spi_res {
	struct list_head entry;
	spi_res_release_t release;
	unsigned long long data[0];
};

struct trace_event_data_offsets_spi_transfer {
	u32 rx_buf;
	u32 tx_buf;
};

struct spi_replaced_transfers;

typedef void (*spi_replaced_release_t)(struct spi_controller *, struct spi_message *, struct spi_replaced_transfers *);

struct spi_replaced_transfers {
	spi_replaced_release_t release;
	void *extradata;
	struct list_head replaced_transfers;
	struct list_head *replaced_after;
	size_t inserted;
	struct spi_transfer inserted_transfers[0];
};

struct trace_event_data_offsets_spi_controller {};

struct trace_event_data_offsets_spi_setup {};

struct trace_event_data_offsets_spi_set_cs {};

struct trace_event_data_offsets_spi_message {};

struct trace_event_data_offsets_spi_message_done {};

struct acpi_spi_lookup {
	struct spi_controller *ctlr;
	u32 max_speed_hz;
	u32 mode;
	int irq;
	u8 bits_per_word;
	u8 chip_select;
	int n;
	int index;
};

struct bcmasp_pkt_offload {
	__be32 nop;
	__be32 header;
	__be32 header2;
	__be32 epkt;
	__be32 end;
};

enum enetc_vf_flags {
	ENETC_VF_FLAG_PF_SET_MAC = 1,
};

struct enetc_mac_filter {
	union {
		char mac_addr[6];
		unsigned long mac_hash_table[1];
	};
	int mac_addr_cnt;
};

struct enetc_vf_state;

struct enetc_pf {
	struct enetc_si *si;
	int num_vfs;
	int total_vfs;
	struct enetc_vf_state *vf_state;
	struct enetc_mac_filter mac_filter[6];
	struct enetc_msg_swbd rxmsg[2];
	struct work_struct msg_task;
	char msg_int_name[24];
	char vlan_promisc_simap;
	unsigned long vlan_ht_filter[1];
	unsigned long active_vlans[64];
	struct mii_bus *mdio;
	struct mii_bus *imdio;
	struct phylink_pcs *pcs;
	phy_interface_t if_mode;
	struct phylink_config phylink_config;
};

struct enetc_vf_state {
	enum enetc_vf_flags flags;
};

struct hclge_dbg_status_dfx_info {
	u32 offset;
	char message[60];
};

struct hclge_dbg_func {
	enum hnae3_dbg_cmd cmd;
	int (*dbg_dump)(struct hclge_dev *, char *, int);
	int (*dbg_dump_reg)(struct hclge_dev *, enum hnae3_dbg_cmd, char *, int);
};

struct hclge_dbg_item {
	char name[32];
	u16 interval;
};

struct hclge_dbg_reg_common_msg {
	int msg_num;
	int offset;
	enum hclge_opcode_type cmd;
};

struct hclge_dbg_dfx_message;

struct hclge_dbg_reg_type_info {
	enum hnae3_dbg_cmd cmd;
	const struct hclge_dbg_dfx_message *dfx_msg;
	struct hclge_dbg_reg_common_msg reg_msg;
};

struct hclge_dbg_dfx_message {
	int flag;
	char message[60];
};

struct hclge_qos_pri_map_cmd {
	u8 pri0_tc: 4;
	u8 pri1_tc: 4;
	u8 pri2_tc: 4;
	u8 pri3_tc: 4;
	u8 pri4_tc: 4;
	u8 pri5_tc: 4;
	u8 pri6_tc: 4;
	u8 pri7_tc: 4;
	u8 vlan_pri: 4;
	u8 rev: 4;
};

struct hclge_mac_ethertype_idx_rd_cmd {
	u8 flags;
	u8 resp_code;
	__le16 vlan_tag;
	u8 mac_addr[6];
	__le16 index;
	__le16 ethter_type;
	__le16 egress_port;
	__le16 egress_queue;
	__le16 rev0;
	u8 i_port_bitmap;
	u8 i_port_direction;
	u8 rev1[2];
};

struct hclge_get_imp_bd_cmd {
	__le32 bd_num;
	u8 rsv[20];
};

struct hclge_fd_ad_cnt_read_cmd {
	u8 rsv0[4];
	__le16 index;
	u8 rsv1[2];
	__le64 cnt;
	u8 rsv2[8];
};

struct hclge_dbg_bitmap_cmd {
	union {
		u8 bitmap;
		struct {
			u8 bit0: 1;
			u8 bit1: 1;
			u8 bit2: 1;
			u8 bit3: 1;
			u8 bit4: 1;
			u8 bit5: 1;
			u8 bit6: 1;
			u8 bit7: 1;
		};
	};
};

struct hclge_dbg_vlan_cfg {
	u16 pvid;
	u8 accept_tag1;
	u8 accept_tag2;
	u8 accept_untag1;
	u8 accept_untag2;
	u8 insert_tag1;
	u8 insert_tag2;
	u8 shift_tag;
	u8 strip_tag1;
	u8 strip_tag2;
	u8 drop_tag1;
	u8 drop_tag2;
	u8 pri_only1;
	u8 pri_only2;
};

struct hclge_dbg_tcam_msg {
	u8 stage;
	u32 loc;
};

struct mvpp2_ethtool_counter {
	unsigned int offset;
	const char string[32];
	bool reg_is_64b;
};

enum mvpp2_bm_pool_log_num {
	MVPP2_BM_SHORT = 0,
	MVPP2_BM_LONG = 1,
	MVPP2_BM_JUMBO = 2,
	MVPP2_BM_POOLS_NUM = 3,
};

enum mvpp22_ptp_action {
	MVPP22_PTP_ACTION_NONE = 0,
	MVPP22_PTP_ACTION_FORWARD = 1,
	MVPP22_PTP_ACTION_CAPTURE = 3,
	MVPP22_PTP_ACTION_ADDTIME = 4,
	MVPP22_PTP_ACTION_ADDCORRECTEDTIME = 5,
	MVPP22_PTP_ACTION_CAPTUREADDTIME = 6,
	MVPP22_PTP_ACTION_CAPTUREADDCORRECTEDTIME = 7,
	MVPP22_PTP_ACTION_ADDINGRESSTIME = 8,
	MVPP22_PTP_ACTION_CAPTUREADDINGRESSTIME = 9,
	MVPP22_PTP_ACTION_CAPTUREINGRESSTIME = 10,
};

enum mvpp22_ptp_packet_format {
	MVPP22_PTP_PKT_FMT_PTPV2 = 0,
	MVPP22_PTP_PKT_FMT_PTPV1 = 1,
	MVPP22_PTP_PKT_FMT_Y1731 = 2,
	MVPP22_PTP_PKT_FMT_NTPTS = 3,
	MVPP22_PTP_PKT_FMT_NTPRX = 4,
	MVPP22_PTP_PKT_FMT_NTPTX = 5,
	MVPP22_PTP_PKT_FMT_TWAMP = 6,
};

enum {
	ETHTOOL_XDP_REDIRECT___2 = 0,
	ETHTOOL_XDP_PASS___2 = 1,
	ETHTOOL_XDP_DROP___2 = 2,
	ETHTOOL_XDP_TX___2 = 3,
	ETHTOOL_XDP_TX_ERR___2 = 4,
	ETHTOOL_XDP_XMIT___2 = 5,
	ETHTOOL_XDP_XMIT_ERR___2 = 6,
};

struct mvpp2_buff_hdr {
	__le32 next_phys_addr;
	__le32 next_dma_addr;
	__le16 byte_count;
	__le16 info;
	__le16 reserved1;
	u8 next_phys_addr_high;
	u8 next_dma_addr_high;
	__le16 reserved2;
	__le16 reserved3;
	__le16 reserved4;
	__le16 reserved5;
};

struct brcmstb_usb_pinmap_data;

struct in_pin {
	u32 enable_mask;
	u32 value_mask;
	struct gpio_desc *gpiod;
	const char *name;
	struct brcmstb_usb_pinmap_data *pdata;
};

struct out_pin;

struct brcmstb_usb_pinmap_data {
	void *regs;
	int in_count;
	struct in_pin *in_pins;
	int out_count;
	struct out_pin *out_pins;
};

struct out_pin {
	u32 enable_mask;
	u32 value_mask;
	u32 changed_mask;
	u32 clr_changed_mask;
	struct gpio_desc *gpiod;
	const char *name;
};

struct tegra_usb_soc_info {
	unsigned long flags;
	unsigned int txfifothresh;
	enum usb_dr_mode dr_mode;
};

struct tegra_usb {
	struct ci_hdrc_platform_data data;
	struct platform_device *dev;
	const struct tegra_usb_soc_info *soc;
	struct usb_phy *phy;
	struct clk *clk;
	bool needs_double_reset;
};

struct sun6i_rtc_clk_data;

struct sun6i_rtc_dev {
	struct rtc_device *rtc;
	const struct sun6i_rtc_clk_data *data;
	void *base;
	int irq;
	time64_t alarm;
	unsigned long flags;
	struct clk_hw hw;
	struct clk_hw *int_osc;
	struct clk *losc;
	struct clk *ext_losc;
	spinlock_t lock;
};

struct sun6i_rtc_clk_data {
	unsigned long rc_osc_rate;
	unsigned int fixed_prescaler: 16;
	unsigned int has_prescaler: 1;
	unsigned int has_out_clk: 1;
	unsigned int has_losc_en: 1;
	unsigned int has_auto_swt: 1;
};

struct mv64xxx_i2c_regs {
	u8 addr;
	u8 ext_addr;
	u8 data;
	u8 control;
	u8 status;
	u8 clock;
	u8 soft_reset;
};

enum {
	MV64XXX_I2C_STATE_INVALID = 0,
	MV64XXX_I2C_STATE_IDLE = 1,
	MV64XXX_I2C_STATE_WAITING_FOR_START_COND = 2,
	MV64XXX_I2C_STATE_WAITING_FOR_RESTART = 3,
	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK = 4,
	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK = 5,
	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK = 6,
	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA = 7,
};

enum {
	MV64XXX_I2C_ACTION_INVALID = 0,
	MV64XXX_I2C_ACTION_CONTINUE = 1,
	MV64XXX_I2C_ACTION_SEND_RESTART = 2,
	MV64XXX_I2C_ACTION_SEND_ADDR_1 = 3,
	MV64XXX_I2C_ACTION_SEND_ADDR_2 = 4,
	MV64XXX_I2C_ACTION_SEND_DATA = 5,
	MV64XXX_I2C_ACTION_RCV_DATA = 6,
	MV64XXX_I2C_ACTION_RCV_DATA_STOP = 7,
	MV64XXX_I2C_ACTION_SEND_STOP = 8,
};

struct mv64xxx_i2c_data {
	struct i2c_msg *msgs;
	int num_msgs;
	int irq;
	u32 state;
	u32 action;
	u32 aborting;
	u32 cntl_bits;
	void *reg_base;
	struct mv64xxx_i2c_regs reg_offsets;
	u32 addr1;
	u32 addr2;
	u32 bytes_left;
	u32 byte_posn;
	u32 send_stop;
	u32 block;
	int rc;
	u32 freq_m;
	u32 freq_n;
	struct clk *clk;
	struct clk *reg_clk;
	wait_queue_head_t waitq;
	spinlock_t lock;
	struct i2c_msg *msg;
	struct i2c_adapter adapter;
	bool offload_enabled;
	bool errata_delay;
	struct reset_control *rstc;
	bool irq_clear_inverted;
	bool clk_n_base_0;
	struct i2c_bus_recovery_info rinfo;
	bool atomic;
};

struct mv64xxx_i2c_pdata {
	u32 freq_m;
	u32 freq_n;
	u32 timeout;
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

enum power_supply_charge_behaviour {
	POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO = 0,
	POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE = 1,
	POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE = 2,
};

struct rzg2l_thermal_priv {
	struct device *dev;
	void *base;
	struct thermal_zone_device *zone;
	struct reset_control *rstc;
	u32 calib0;
	u32 calib1;
};

enum rz_wdt_type {
	WDT_RZG2L = 0,
	WDT_RZV2M = 1,
};

struct rzg2l_wdt_priv {
	void *base;
	struct watchdog_device wdev;
	struct reset_control *rstc;
	unsigned long osc_clk_rate;
	unsigned long delay;
	unsigned long minimum_assertion_period;
	struct clk *pclk;
	struct clk *osc_clk;
	enum rz_wdt_type devtype;
};

struct f_sdhost_priv {
	struct clk *clk_iface;
	struct clk *clk;
	struct reset_control *rst;
	u32 vendor_hs200;
	struct device *dev;
	bool enable_cmd_dat_delay;
};

struct sdhci_arasan_soc_ctl_map;

struct sdhci_arasan_clk_ops;

struct sdhci_arasan_of_data {
	const struct sdhci_arasan_soc_ctl_map *soc_ctl_map;
	const struct sdhci_pltfm_data *pdata;
	const struct sdhci_arasan_clk_ops *clk_ops;
};

struct sdhci_arasan_soc_ctl_field {
	u32 reg;
	u16 width;
	s16 shift;
};

struct sdhci_arasan_soc_ctl_map {
	struct sdhci_arasan_soc_ctl_field baseclkfreq;
	struct sdhci_arasan_soc_ctl_field clockmultiplier;
	struct sdhci_arasan_soc_ctl_field support64b;
	bool hiword_update;
};

struct sdhci_arasan_clk_ops {
	const struct clk_ops *sdcardclk_ops;
	const struct clk_ops *sampleclk_ops;
};

enum dll_reset_type {
	PM_DLL_RESET_ASSERT = 0,
	PM_DLL_RESET_RELEASE = 1,
	PM_DLL_RESET_PULSE = 2,
};

struct sdhci_arasan_clk_data {
	struct clk_hw sdcardclk_hw;
	struct clk *sdcardclk;
	struct clk_hw sampleclk_hw;
	struct clk *sampleclk;
	int clk_phase_in[11];
	int clk_phase_out[11];
	void (*set_clk_delays)(struct sdhci_host *);
	void *clk_of_data;
};

struct sdhci_arasan_data {
	struct sdhci_host *host;
	struct clk *clk_ahb;
	struct phy *phy;
	bool is_phy_on;
	bool internal_phy_reg;
	bool has_cqe;
	struct sdhci_arasan_clk_data clk_data;
	const struct sdhci_arasan_clk_ops *clk_ops;
	struct regmap *soc_ctl_base;
	const struct sdhci_arasan_soc_ctl_map *soc_ctl_map;
	unsigned int quirks;
};

struct heartbeat_trig_data {
	struct led_classdev *led_cdev;
	unsigned int phase;
	unsigned int period;
	struct timer_list timer;
	unsigned int invert;
};

struct clocksource_mmio {
	void *reg;
	struct clocksource clksrc;
};

struct virtproc_info;

struct virtio_rpmsg_channel {
	struct rpmsg_device rpdev;
	struct virtproc_info *vrp;
};

struct virtproc_info {
	struct virtio_device *vdev;
	struct virtqueue *rvq;
	struct virtqueue *svq;
	void *rbufs;
	void *sbufs;
	unsigned int num_bufs;
	unsigned int buf_size;
	int last_sbuf;
	dma_addr_t bufs_dma;
	struct mutex tx_lock;
	struct idr endpoints;
	struct mutex endpoints_lock;
	wait_queue_head_t sendq;
	atomic_t sleepers;
};

typedef __u16 __rpmsg16;

struct rpmsg_hdr {
	__rpmsg32 src;
	__rpmsg32 dst;
	__rpmsg32 reserved;
	__rpmsg16 len;
	__rpmsg16 flags;
	u8 data[0];
};

struct otpc_map {
	u32 otpc_row_size;
	u16 data_r_offset[4];
	u16 data_w_offset[4];
};

struct otpc_priv {
	struct device *dev;
	void *base;
	const struct otpc_map *map;
	struct nvmem_config *config;
};

struct mux_chip;

struct mux_control {
	struct semaphore lock;
	struct mux_chip *chip;
	int cached_state;
	unsigned int states;
	int idle_state;
	ktime_t last_change;
};

struct mux_control_ops;

struct mux_chip {
	unsigned int controllers;
	struct mux_control *mux;
	struct device dev;
	int id;
	const struct mux_control_ops *ops;
};

struct mux_control_ops {
	int (*set)(struct mux_control *, int);
};

struct mux_state {
	struct mux_control *mux;
	unsigned int state;
};

struct snd_fasync {
	struct fasync_struct *fasync;
	int signal;
	int poll;
	int on;
	struct list_head list;
};

struct snd_pci_quirk {
	unsigned short subvendor;
	unsigned short subdevice;
	unsigned short subdevice_mask;
	int value;
};

struct snd_pcm_chmap_elem {
	unsigned char channels;
	unsigned char map[15];
};

enum {
	SNDRV_PCM_TSTAMP_NONE = 0,
	SNDRV_PCM_TSTAMP_ENABLE = 1,
	SNDRV_PCM_TSTAMP_LAST = 1,
};

enum {
	SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,
	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC = 1,
	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW = 2,
	SNDRV_PCM_TSTAMP_TYPE_LAST = 2,
};

enum {
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_COMPAT = 0,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT = 1,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK = 2,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ABSOLUTE = 3,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ESTIMATED = 4,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_SYNCHRONIZED = 5,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LAST = 5,
};

typedef int (*pcm_transfer_f)(struct snd_pcm_substream *, int, unsigned long, struct iov_iter *, unsigned long);

struct snd_ratden {
	unsigned int num_min;
	unsigned int num_max;
	unsigned int num_step;
	unsigned int den;
};

struct snd_pcm_channel_info {
	unsigned int channel;
	__kernel_off_t offset;
	unsigned int first;
	unsigned int step;
};

struct snd_pcm_chmap {
	struct snd_pcm *pcm;
	int stream;
	struct snd_kcontrol *kctl;
	const struct snd_pcm_chmap_elem *chmap;
	unsigned int max_channels;
	unsigned int channel_mask;
	void *private_data;
};

struct snd_ratnum {
	unsigned int num;
	unsigned int den_min;
	unsigned int den_max;
	unsigned int den_step;
};

struct snd_pcm_hw_constraint_list {
	const unsigned int *list;
	unsigned int count;
	unsigned int mask;
};

struct snd_pcm_hw_constraint_ranges {
	unsigned int count;
	const struct snd_interval *ranges;
	unsigned int mask;
};

struct snd_pcm_hw_constraint_ratnums {
	int nrats;
	const struct snd_ratnum *rats;
};

struct snd_pcm_hw_constraint_ratdens {
	int nrats;
	const struct snd_ratden *rats;
};

typedef int (*pcm_copy_f)(struct snd_pcm_substream *, snd_pcm_uframes_t, void *, snd_pcm_uframes_t, snd_pcm_uframes_t, pcm_transfer_f, bool);

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

struct tc_mq_opt_offload_graft_params {
	unsigned long queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

struct bpf_test_timer {
	enum {
		NO_PREEMPT = 0,
		NO_MIGRATE = 1,
	} mode;
	u32 i;
	u64 time_start;
	u64 time_spent;
};

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct xdp_test_data {
	struct xdp_buff *orig_ctx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info rxq;
	struct net_device *dev;
	struct page_pool *pp;
	struct xdp_frame **frames;
	struct sk_buff **skbs;
	struct xdp_mem_info mem;
	u32 batch_size;
	u32 frame_cnt;
	long: 64;
	long: 64;
};

struct xdp_page_head {
	struct xdp_buff orig_ctx;
	struct xdp_buff ctx;
	union {
		struct {
			struct {} __empty_frame;
			struct xdp_frame frame[0];
		};
		struct {
			struct {} __empty_data;
			u8 data[0];
		};
	};
};

struct trace_event_data_offsets_bpf_test_finish {};

struct prog_test_member1 {
	int a;
};

struct prog_test_member {
	struct prog_test_member1 m;
	int c;
};

struct prog_test_ref_kfunc {
	int a;
	int b;
	struct prog_test_member memb;
	struct prog_test_ref_kfunc *next;
	refcount_t cnt;
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

struct nf_queue_entry;

struct nf_queue_handler {
	int (*outfn)(struct nf_queue_entry *, unsigned int);
	void (*nf_hook_drop)(struct net *);
};

struct nf_queue_entry {
	struct list_head list;
	struct sk_buff *skb;
	unsigned int id;
	unsigned int hook_index;
	struct net_device *physin;
	struct net_device *physout;
	struct nf_hook_state state;
	u16 size;
};

struct nf_bridge_info {
	enum {
		BRNF_PROTO_UNCHANGED = 0,
		BRNF_PROTO_8021Q = 1,
		BRNF_PROTO_PPPOE = 2,
	} orig_proto: 8;
	u8 pkt_otherhost: 1;
	u8 in_prerouting: 1;
	u8 bridged_dnat: 1;
	u8 sabotage_in_done: 1;
	__u16 frag_max_size;
	int physinif;
	struct net_device *physoutdev;
	union {
		__be32 ipv4_daddr;
		struct in6_addr ipv6_daddr;
		char neigh_header[8];
	};
};

struct ip_rt_info {
	__be32 daddr;
	__be32 saddr;
	u_int8_t tos;
	u_int32_t mark;
};

struct ip6_rt_info {
	struct in6_addr daddr;
	struct in6_addr saddr;
	u_int32_t mark;
};

struct snmp_mib {
	const char *name;
	int entry;
};

enum devlink_port_function_attr {
	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC = 0,
	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR = 1,
	DEVLINK_PORT_FN_ATTR_STATE = 2,
	DEVLINK_PORT_FN_ATTR_OPSTATE = 3,
	DEVLINK_PORT_FN_ATTR_CAPS = 4,
	DEVLINK_PORT_FN_ATTR_DEVLINK = 5,
	__DEVLINK_PORT_FUNCTION_ATTR_MAX = 6,
	DEVLINK_PORT_FUNCTION_ATTR_MAX = 5,
};

enum devlink_port_fn_attr_cap {
	DEVLINK_PORT_FN_ATTR_CAP_ROCE_BIT = 0,
	DEVLINK_PORT_FN_ATTR_CAP_MIGRATABLE_BIT = 1,
	DEVLINK_PORT_FN_ATTR_CAP_IPSEC_CRYPTO_BIT = 2,
	DEVLINK_PORT_FN_ATTR_CAP_IPSEC_PACKET_BIT = 3,
	__DEVLINK_PORT_FN_ATTR_CAPS_MAX = 4,
};

struct encryptor_desc {
	u8 iv[16];
	struct skcipher_request *req;
	int pos;
	struct xdr_buf *outbuf;
	struct page **pages;
	struct scatterlist infrags[4];
	struct scatterlist outfrags[4];
	int fragno;
	int fraglen;
};

struct decryptor_desc {
	u8 iv[16];
	struct skcipher_request *req;
	struct scatterlist frags[4];
	int fragno;
	int fraglen;
};

struct xsk_dma_map {
	dma_addr_t *dma_pages;
	struct device *dev;
	struct net_device *netdev;
	refcount_t users;
	struct list_head list;
	u32 dma_pages_cnt;
	bool dma_need_sync;
};

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long);

struct pt_regs_offset {
	const char *name;
	int offset;
};

enum compat_regset {
	REGSET_COMPAT_GPR = 0,
	REGSET_COMPAT_VFP = 1,
};

enum ptrace_syscall_dir {
	PTRACE_SYSCALL_ENTER = 0,
	PTRACE_SYSCALL_EXIT = 1,
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long id;
	unsigned long args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long id;
	long ret;
	char __data[0];
};

struct user_sve_header {
	__u32 size;
	__u32 max_size;
	__u16 vl;
	__u16 max_vl;
	__u16 flags;
	__u16 __reserved;
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

struct user_za_header {
	__u32 size;
	__u32 max_size;
	__u16 vl;
	__u16 max_vl;
	__u16 flags;
	__u16 __reserved;
};

struct user_pac_mask {
	__u64 data_mask;
	__u64 insn_mask;
};

struct aes_block {
	u8 b[16];
};

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, unsigned long);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	unsigned long clone_flags;
	short oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	pid_t pid;
	char oldcomm[16];
	char newcomm[16];
	short oom_score_adj;
	char __data[0];
};

struct vm_stack {
	struct callback_head rcu;
	struct vm_struct *stack_vm_area;
};

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_rename {};

struct nbcon_state {
	union {
		unsigned int atom;
		struct {
			unsigned int prio: 2;
			unsigned int req_prio: 2;
			unsigned int unsafe: 1;
			unsigned int unsafe_takeover: 1;
			unsigned int cpu: 24;
		};
	};
};

enum desc_state___2 {
	desc_miss = -1,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

struct prb_data_block {
	unsigned long id;
	char data[0];
};

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)();
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alarm_class {};

struct bpf_hrtimer {
	struct hrtimer timer;
	struct bpf_map *map;
	struct bpf_prog *prog;
	void __attribute__((btf_type_tag("rcu"))) *callback_fn;
	void *value;
};

struct bpf_bprintf_buffers {
	char bin_args[512];
	char buf[1024];
};

enum {
	BPF_F_TIMER_ABS = 1,
	BPF_F_TIMER_CPU_PIN = 2,
};

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_lookup_percpu_elem)(struct bpf_map *, void *, u32);

typedef u64 (*btf_bpf_get_smp_processor_id)();

typedef u64 (*btf_bpf_get_numa_node_id)();

typedef u64 (*btf_bpf_ktime_get_ns)();

typedef u64 (*btf_bpf_ktime_get_boot_ns)();

typedef u64 (*btf_bpf_ktime_get_coarse_ns)();

typedef u64 (*btf_bpf_ktime_get_tai_ns)();

typedef u64 (*btf_bpf_get_current_pid_tgid)();

typedef u64 (*btf_bpf_get_current_uid_gid)();

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

struct bpf_spin_lock;

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

struct bpf_spin_lock {
	__u32 val;
};

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_jiffies64)();

typedef u64 (*btf_bpf_get_current_cgroup_id)();

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, long *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, unsigned long *);

typedef u64 (*btf_bpf_strncmp)(const char *, u32, const char *);

struct bpf_pidns_info;

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void __attribute__((btf_type_tag("user"))) *);

typedef u64 (*btf_bpf_copy_from_user_task)(void *, u32, const void __attribute__((btf_type_tag("user"))) *, struct task_struct *, u64);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

typedef u64 (*btf_bpf_snprintf)(char *, u32, char *, const void *, u32);

struct bpf_timer_kern;

typedef u64 (*btf_bpf_timer_init)(struct bpf_timer_kern *, struct bpf_map *, u64);

struct bpf_timer_kern {
	struct bpf_hrtimer *timer;
	struct bpf_spin_lock lock;
};

typedef u64 (*btf_bpf_timer_set_callback)(struct bpf_timer_kern *, void *, struct bpf_prog_aux *);

typedef u64 (*btf_bpf_timer_start)(struct bpf_timer_kern *, u64, u64);

typedef u64 (*btf_bpf_timer_cancel)(struct bpf_timer_kern *);

typedef u64 (*btf_bpf_kptr_xchg)(void *, void *);

typedef u64 (*btf_bpf_dynptr_from_mem)(void *, u32, u64, struct bpf_dynptr_kern *);

typedef u64 (*btf_bpf_dynptr_read)(void *, u32, const struct bpf_dynptr_kern *, u32, u64);

typedef u64 (*btf_bpf_dynptr_write)(const struct bpf_dynptr_kern *, u32, void *, u32, u64);

typedef u64 (*btf_bpf_dynptr_data)(const struct bpf_dynptr_kern *, u32, u32);

struct bpf_refcount {
	int: 32;
};

struct bpf_rb_node_kern {
	struct rb_node rb_node;
	void *owner;
};

struct bpf_rb_node {
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_timer {
	long: 64;
	long: 64;
};

struct bpf_dynptr {
	long: 64;
	long: 64;
};

struct bpf_list_node_kern {
	struct list_head list_head;
	void *owner;
};

struct bpf_list_node {
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_list_head {
	long: 64;
	long: 64;
};

struct bpf_rb_root {
	long: 64;
	long: 64;
};

struct bpf_throw_ctx {
	struct bpf_prog_aux *aux;
	u64 sp;
	u64 bp;
	int cnt;
};

struct bp_slots_histogram {
	atomic_t *count;
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	struct bp_slots_histogram tsk_pinned;
};

struct context_tracking {
	atomic_t state;
	long dynticks_nesting;
	long dynticks_nmi_nesting;
};

enum shmem_param {
	Opt_gid___8 = 0,
	Opt_huge = 1,
	Opt_mode___5 = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes___2 = 5,
	Opt_size___2 = 6,
	Opt_uid___7 = 7,
	Opt_inode32 = 8,
	Opt_inode64 = 9,
	Opt_noswap = 10,
	Opt_quota___3 = 11,
	Opt_usrquota___3 = 12,
	Opt_grpquota___3 = 13,
	Opt_usrquota_block_hardlimit = 14,
	Opt_usrquota_inode_hardlimit = 15,
	Opt_grpquota_block_hardlimit = 16,
	Opt_grpquota_inode_hardlimit = 17,
};

struct shmem_quota_limits {
	qsize_t usrquota_bhardlimit;
	qsize_t usrquota_ihardlimit;
	qsize_t grpquota_bhardlimit;
	qsize_t grpquota_ihardlimit;
};

struct shmem_sb_info {
	unsigned long max_blocks;
	struct percpu_counter used_blocks;
	unsigned long max_inodes;
	unsigned long free_ispace;
	raw_spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	bool noswap;
	ino_t next_ino;
	ino_t __attribute__((btf_type_tag("percpu"))) *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	unsigned long shrinklist_len;
	struct shmem_quota_limits qlimits;
};

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

struct shmem_falloc {
	wait_queue_head_t *waitq;
	unsigned long start;
	unsigned long next;
	unsigned long nr_falloced;
	unsigned long nr_unswapped;
};

struct shmem_options {
	unsigned long long blocks;
	unsigned long long inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
	bool noswap;
	unsigned short quota_types;
	struct shmem_quota_limits qlimits;
};

struct node_hstate {
	struct kobject *hugepages_kobj;
	struct kobject *hstate_kobjs[4];
};

enum vma_resv_mode {
	VMA_NEEDS_RESV = 0,
	VMA_COMMIT_RESV = 1,
	VMA_END_RESV = 2,
	VMA_ADD_RESV = 3,
	VMA_DEL_RESV = 4,
};

struct huge_bootmem_page {
	struct list_head list;
	struct hstate *hstate;
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

struct dio {
	int flags;
	blk_opf_t opf;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	bool is_pinned;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	unsigned long refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	long: 64;
};

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
};

struct dqstats {
	unsigned long stat[8];
	struct percpu_counter counter[8];
};

struct quota_module_name {
	int qm_fmt_id;
	char *qm_mod_name;
};

enum {
	DQF_INFO_DIRTY_B = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

enum {
	QIF_BLIMITS_B = 0,
	QIF_SPACE_B = 1,
	QIF_ILIMITS_B = 2,
	QIF_INODES_B = 3,
	QIF_BTIME_B = 4,
	QIF_ITIME_B = 5,
};

struct dquot_warn {
	struct super_block *w_sb;
	struct kqid w_dq_id;
	short w_type;
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

struct dx_entry;

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

struct squashfs_base_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
};

struct squashfs_dev_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 rdev;
};

struct squashfs_ldev_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 rdev;
	__le32 xattr;
};

struct squashfs_symlink_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 symlink_size;
	char symlink[0];
};

struct squashfs_reg_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 start_block;
	__le32 fragment;
	__le32 offset;
	__le32 file_size;
	__le16 block_list[0];
};

struct squashfs_lreg_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le64 start_block;
	__le64 file_size;
	__le64 sparse;
	__le32 nlink;
	__le32 fragment;
	__le32 offset;
	__le32 xattr;
	__le16 block_list[0];
};

struct squashfs_dir_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 start_block;
	__le32 nlink;
	__le16 file_size;
	__le16 offset;
	__le32 parent_inode;
};

struct squashfs_ldir_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 file_size;
	__le32 start_block;
	__le32 parent_inode;
	__le16 i_count;
	__le16 offset;
	__le32 xattr;
	struct squashfs_dir_index index[0];
};

struct squashfs_ipc_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
};

struct squashfs_lipc_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 xattr;
};

union squashfs_inode {
	struct squashfs_base_inode base;
	struct squashfs_dev_inode dev;
	struct squashfs_ldev_inode ldev;
	struct squashfs_symlink_inode symlink;
	struct squashfs_reg_inode reg;
	struct squashfs_lreg_inode lreg;
	struct squashfs_dir_inode dir;
	struct squashfs_ldir_inode ldir;
	struct squashfs_ipc_inode ipc;
	struct squashfs_lipc_inode lipc;
};

struct idmap_legacy_upcalldata;

struct idmap {
	struct rpc_pipe_dir_object idmap_pdo;
	struct rpc_pipe *idmap_pipe;
	struct idmap_legacy_upcalldata *idmap_upcall_data;
	struct mutex idmap_mutex;
	struct user_namespace *user_ns;
};

struct idmap_msg {
	__u8 im_type;
	__u8 im_conv;
	char im_name[128];
	__u32 im_id;
	__u8 im_status;
};

struct idmap_legacy_upcalldata {
	struct rpc_pipe_msg pipe_msg;
	struct idmap_msg idmap_msg;
	struct key *authkey;
	struct idmap *idmap;
};

enum {
	Opt_find_uid = 0,
	Opt_find_gid = 1,
	Opt_find_user = 2,
	Opt_find_group = 3,
	Opt_find_err = 4,
};

struct fscache_cookie;

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	union {
		struct {
			struct crypto_alg base;
		};
		struct comp_alg_common calg;
	};
};

struct crypto_istat_compress {
	atomic64_t compress_cnt;
	atomic64_t compress_tlen;
	atomic64_t decompress_cnt;
	atomic64_t decompress_tlen;
	atomic64_t err_cnt;
};

struct crypto_report_acomp {
	char type[64];
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	struct iov_iter iter;
	struct iovec iov[0];
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long poll_msecs;
	struct delayed_work dwork;
};

struct io_rename {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_unlink {
	struct file *file;
	int dfd;
	int flags;
	struct filename *filename;
};

struct io_mkdir {
	struct file *file;
	int dfd;
	umode_t mode;
	struct filename *filename;
};

struct io_link {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

typedef unsigned int FSE_DTable;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	unsigned short newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef struct {
	short ncount[256];
	FSE_DTable dtable[0];
} FSE_DecompressWksp;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

enum acpi_subtable_type {
	ACPI_SUBTABLE_COMMON = 0,
	ACPI_SUBTABLE_HMAT = 1,
	ACPI_SUBTABLE_PRMT = 2,
	ACPI_SUBTABLE_CEDT = 3,
};

struct acpi_subtable_entry {
	union acpi_subtable_headers *hdr;
	enum acpi_subtable_type type;
};

struct armctrl_ic {
	void *base;
	void *pending[3];
	void *enable[3];
	void *disable[3];
	struct irq_domain *domain;
};

struct irqc_priv;

struct irqc_irq {
	int hw_irq;
	int requested_irq;
	struct irqc_priv *p;
};

struct irqc_priv {
	void *iomem;
	void *cpu_int_base;
	struct irqc_irq irq[32];
	unsigned int number_of_irqs;
	struct device *dev;
	struct irq_chip_generic *gc;
	struct irq_domain *irq_domain;
	atomic_t wakeup_path;
};

struct phy_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct phy *phy;
};

struct exynos_dp_video_phy_drvdata {
	u32 phy_ctrl_offset;
};

struct exynos_dp_video_phy {
	struct regmap *regs;
	const struct exynos_dp_video_phy_drvdata *drvdata;
};

enum ioctrl_regs___7 {
	POC0___3 = 0,
	POC1___3 = 1,
	POC3___2 = 2,
	TD0SEL1 = 3,
};

struct max77620_gpio {
	struct gpio_chip gpio_chip;
	struct regmap *rmap;
	struct device *dev;
	struct mutex buslock;
	unsigned int irq_type[8];
	bool irq_enabled[8];
};

struct iproc_pwmc {
	struct pwm_chip chip;
	void *base;
	struct clk *clk;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	int: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
};

enum imx6_pcie_variants {
	IMX6Q = 0,
	IMX6SX = 1,
	IMX6QP = 2,
	IMX7D = 3,
	IMX8MQ = 4,
	IMX8MM___2 = 5,
	IMX8MP___2 = 6,
	IMX8MQ_EP = 7,
	IMX8MM_EP = 8,
	IMX8MP_EP = 9,
};

enum dw_pcie_device_mode {
	DW_PCIE_UNKNOWN_TYPE = 0,
	DW_PCIE_EP_TYPE = 1,
	DW_PCIE_LEG_EP_TYPE = 2,
	DW_PCIE_RC_TYPE = 3,
};

struct imx6_pcie_drvdata {
	enum imx6_pcie_variants variant;
	enum dw_pcie_device_mode mode;
	u32 flags;
	int dbi_length;
	const char *gpr;
};

struct imx6_pcie {
	struct dw_pcie *pci;
	int reset_gpio;
	bool gpio_active_high;
	bool link_is_up;
	struct clk *pcie_bus;
	struct clk *pcie_phy;
	struct clk *pcie_inbound_axi;
	struct clk *pcie;
	struct clk *pcie_aux;
	struct regmap *iomuxc_gpr;
	u16 msi_ctrl;
	u32 controller_id;
	struct reset_control *pciephy_reset;
	struct reset_control *apps_reset;
	struct reset_control *turnoff_reset;
	u32 tx_deemph_gen1;
	u32 tx_deemph_gen2_3p5db;
	u32 tx_deemph_gen2_6db;
	u32 tx_swing_full;
	u32 tx_swing_low;
	struct regulator *vpcie;
	struct regulator *vph;
	void *phy_base;
	struct device *pd_pcie;
	struct device *pd_pcie_phy;
	struct phy *phy;
	const struct imx6_pcie_drvdata *drvdata;
};

struct acpi_device_bus_id {
	const char *bus_id;
	struct ida instance_ida;
	struct list_head node;
};

struct acpi_dep_data {
	struct list_head node;
	acpi_handle supplier;
	acpi_handle consumer;
	bool honor_dep;
	bool met;
	bool free_when_met;
};

struct acpi_scan_clear_dep_work {
	struct work_struct work;
	struct acpi_device *adev;
};

struct acpi_table_stao {
	struct acpi_table_header header;
	u8 ignore_uart;
} __attribute__((packed));

struct acpi_table_spcr {
	struct acpi_table_header header;
	u8 interface_type;
	u8 reserved[3];
	struct acpi_generic_address serial_port;
	u8 interrupt_type;
	u8 pc_interrupt;
	u32 interrupt;
	u8 baud_rate;
	u8 parity;
	u8 stop_bits;
	u8 flow_control;
	u8 terminal_type;
	u8 reserved1;
	u16 pci_device_id;
	u16 pci_vendor_id;
	u8 pci_bus;
	u8 pci_device;
	u8 pci_function;
	u32 pci_flags;
	u8 pci_segment;
	u32 reserved2;
} __attribute__((packed));

struct iort_dev_config {
	const char *name;
	int (*dev_init)(struct acpi_iort_node *);
	void (*dev_dma_configure)(struct device *, struct acpi_iort_node *);
	int (*dev_count_resources)(struct acpi_iort_node *);
	void (*dev_init_resources)(struct resource *, struct acpi_iort_node *);
	int (*dev_set_proximity)(struct device *, struct acpi_iort_node *);
	int (*dev_add_platdata)(struct platform_device *);
};

enum acpi_predicate {
	all_versions = 0,
	less_than_or_equal = 1,
	equal = 2,
	greater_than_or_equal = 3,
};

struct acpi_platform_list {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
	char *table;
	enum acpi_predicate pred;
	char *reason;
	u32 data;
};

enum acpi_iort_node_type {
	ACPI_IORT_NODE_ITS_GROUP = 0,
	ACPI_IORT_NODE_NAMED_COMPONENT = 1,
	ACPI_IORT_NODE_PCI_ROOT_COMPLEX = 2,
	ACPI_IORT_NODE_SMMU = 3,
	ACPI_IORT_NODE_SMMU_V3 = 4,
	ACPI_IORT_NODE_PMCG = 5,
	ACPI_IORT_NODE_RMR = 6,
};

struct iort_its_msi_chip {
	struct list_head list;
	struct fwnode_handle *fw_node;
	phys_addr_t base_addr;
	u32 translation_id;
};

struct acpi_iort_named_component {
	u32 node_flags;
	u64 memory_properties;
	u8 memory_address_limit;
	char device_name[0];
} __attribute__((packed));

struct acpi_iort_root_complex {
	u64 memory_properties;
	u32 ats_attribute;
	u32 pci_segment_number;
	u8 memory_address_limit;
	u16 pasid_capabilities;
	u8 reserved[0];
} __attribute__((packed));

struct iort_fwnode {
	struct list_head list;
	struct acpi_iort_node *iort_node;
	struct fwnode_handle *fwnode;
};

struct acpi_iort_id_mapping {
	u32 input_base;
	u32 id_count;
	u32 output_base;
	u32 output_reference;
	u32 flags;
};

struct acpi_iort_smmu_v3 {
	u64 base_address;
	u32 flags;
	u32 reserved;
	u64 vatos_address;
	u32 model;
	u32 event_gsiv;
	u32 pri_gsiv;
	u32 gerr_gsiv;
	u32 sync_gsiv;
	u32 pxm;
	u32 id_mapping_index;
} __attribute__((packed));

struct acpi_iort_pmcg {
	u64 page0_base_address;
	u32 overflow_gsiv;
	u32 node_reference;
	u64 page1_base_address;
};

struct acpi_iort_its_group {
	u32 its_count;
	u32 identifiers[0];
};

struct acpi_table_iort {
	struct acpi_table_header header;
	u32 node_count;
	u32 node_offset;
	u32 reserved;
};

struct acpi_iort_rmr {
	u32 flags;
	u32 rmr_count;
	u32 rmr_offset;
};

struct acpi_iort_rmr_desc {
	u64 base_address;
	u64 length;
	u32 reserved;
} __attribute__((packed));

struct iort_pci_alias_info {
	struct device *dev;
	struct acpi_iort_node *node;
};

typedef acpi_status (*iort_find_node_callback)(struct acpi_iort_node *, void *);

struct berlin2_avpll_vco {
	struct clk_hw hw;
	void *base;
	u8 flags;
};

struct berlin2_avpll_channel {
	struct clk_hw hw;
	void *base;
	u8 flags;
	u8 index;
};

struct berlin2_div_map {
	u16 pll_select_offs;
	u16 pll_switch_offs;
	u16 div_select_offs;
	u16 div_switch_offs;
	u16 div3_switch_offs;
	u16 gate_offs;
	u8 pll_select_shift;
	u8 pll_switch_shift;
	u8 div_select_shift;
	u8 div_switch_shift;
	u8 div3_switch_shift;
	u8 gate_shift;
};

struct berlin2_div {
	struct clk_hw hw;
	void *base;
	struct berlin2_div_map map;
	spinlock_t *lock;
};

struct clkgate_separated {
	struct clk_hw hw;
	void *enable;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

enum imx_pfdv2_type {
	IMX_PFDV2_IMX7ULP = 0,
	IMX_PFDV2_IMX8ULP = 1,
};

struct pcc_reset_dev {
	void *base;
	struct reset_controller_dev rcdev;
	const u32 *resets;
	spinlock_t *lock;
};

enum clk_types___2 {
	CLK_TYPE_IN___2 = 0,
	CLK_TYPE_FF___2 = 1,
	CLK_TYPE_SAM_PLL = 2,
	CLK_TYPE_G3S_PLL = 3,
	CLK_TYPE_DIV = 4,
	CLK_TYPE_G3S_DIV = 5,
	CLK_TYPE_MUX = 6,
	CLK_TYPE_SD_MUX = 7,
	CLK_TYPE_SIPLL5 = 8,
	CLK_TYPE_PLL5_4_MUX = 9,
	CLK_TYPE_DSI_DIV = 10,
};

struct rzg2l_cpg_priv;

struct clk_hw_data {
	struct clk_hw hw;
	u32 conf;
	u32 sconf;
	struct rzg2l_cpg_priv *priv;
};

struct rzg2l_pll5_mux_dsi_div_param {
	u8 clksrc;
	u8 dsi_div_a;
	u8 dsi_div_b;
};

struct rzg2l_cpg_priv {
	struct reset_controller_dev rcdev;
	struct device *dev;
	void *base;
	spinlock_t rmw_lock;
	struct clk **clks;
	unsigned int num_core_clks;
	unsigned int num_mod_clks;
	unsigned int num_resets;
	unsigned int last_dt_core_clk;
	const struct rzg2l_cpg_info *info;
	struct generic_pm_domain genpd;
	struct rzg2l_pll5_mux_dsi_div_param mux_dsi_div_params;
};

struct div_hw_data {
	struct clk_hw_data hw_data;
	const struct clk_div_table *dtable;
	unsigned long invalid_rate;
	unsigned long max_rate;
	u32 width;
};

struct pll_clk {
	struct clk_hw hw;
	unsigned int conf;
	unsigned int type;
	void *base;
	struct rzg2l_cpg_priv *priv;
};

struct sipll5 {
	struct clk_hw hw;
	u32 conf;
	unsigned long foutpostdiv_rate;
	struct rzg2l_cpg_priv *priv;
};

struct sd_mux_hw_data {
	struct clk_hw_data hw_data;
	const u32 *mtable;
};

struct pll5_mux_hw_data {
	struct clk_hw hw;
	u32 conf;
	unsigned long rate;
	struct rzg2l_cpg_priv *priv;
};

struct dsi_div_hw_data {
	struct clk_hw hw;
	u32 conf;
	unsigned long rate;
	struct rzg2l_cpg_priv *priv;
};

struct mstp_clock___2 {
	struct clk_hw hw;
	u16 off;
	u8 bit;
	bool enabled;
	struct rzg2l_cpg_priv *priv;
	struct mstp_clock___2 *sibling;
};

struct rzg2l_pll5_param {
	u32 pl5_fracin;
	u8 pl5_refdiv;
	u8 pl5_intin;
	u8 pl5_postdiv1;
	u8 pl5_postdiv2;
	u8 pl5_spread;
};

enum hidma_cap {
	HIDMA_MSI_CAP = 1,
	HIDMA_IDENTITY_CAP = 2,
};

enum tre_type {
	HIDMA_TRE_MEMCPY = 3,
	HIDMA_TRE_MEMSET = 4,
};

struct dpio_priv {
	struct dpaa2_io *io;
};

struct qcom_smem_state {
	struct kref refcount;
	bool orphan;
	struct list_head list;
	struct device_node *of_node;
	void *priv;
	struct qcom_smem_state_ops ops;
};

struct apple_pmgr_ps {
	struct device *dev;
	struct generic_pm_domain genpd;
	struct reset_controller_dev rcdev;
	struct regmap *regmap;
	u32 offset;
	u32 min_state;
};

enum {
	VP_MSIX_CONFIG_VECTOR = 0,
	VP_MSIX_VQ_VECTOR = 1,
};

struct notify_info {
	uint16_t pgoff: 12;
	uint16_t flags: 2;
	int event;
};

struct gntalloc_gref {
	struct list_head next_gref;
	struct list_head next_file;
	struct page *page;
	uint64_t file_index;
	unsigned int users;
	grant_ref_t gref_id;
	struct notify_info notify;
};

struct gntalloc_file_private_data {
	struct list_head list;
	uint64_t index;
};

struct ioctl_gntalloc_alloc_gref {
	__u16 domid;
	__u16 flags;
	__u32 count;
	__u64 index;
	__u32 gref_ids[1];
};

struct ioctl_gntalloc_dealloc_gref {
	__u64 index;
	__u32 count;
};

struct ioctl_gntalloc_unmap_notify {
	__u64 index;
	__u32 action;
	__u32 event_channel_port;
};

struct gntalloc_vma_private_data {
	struct gntalloc_gref *gref;
	int users;
	int count;
};

struct pwm_continuous_reg_data {
	unsigned int min_uV_dutycycle;
	unsigned int max_uV_dutycycle;
	unsigned int dutycycle_unit;
};

struct pwm_voltages;

struct pwm_regulator_data {
	struct pwm_device *pwm;
	struct pwm_voltages *duty_cycle_table;
	struct pwm_continuous_reg_data continuous;
	struct regulator_desc desc;
	int state;
	struct gpio_desc *enb_gpio;
};

struct pwm_voltages {
	unsigned int uV;
	unsigned int dutycycle;
};

struct scmi_reset_proto_ops {
	int (*num_domains_get)(const struct scmi_protocol_handle *);
	const char * (*name_get)(const struct scmi_protocol_handle *, u32);
	int (*latency_get)(const struct scmi_protocol_handle *, u32);
	int (*reset)(const struct scmi_protocol_handle *, u32);
	int (*assert)(const struct scmi_protocol_handle *, u32);
	int (*deassert)(const struct scmi_protocol_handle *, u32);
};

struct scmi_reset_data {
	struct reset_controller_dev rcdev;
	const struct scmi_protocol_handle *ph;
};

typedef uint32_t XENCONS_RING_IDX;

struct xencons_interface;

struct xencons_info {
	struct list_head list;
	struct xenbus_device *xbdev;
	struct xencons_interface *intf;
	unsigned int evtchn;
	XENCONS_RING_IDX out_cons;
	unsigned int out_cons_same;
	struct hvc_struct *hvc;
	int irq;
	int vtermno;
	grant_ref_t gntref;
	spinlock_t ring_lock;
};

struct xencons_interface {
	char in[1024];
	char out[2048];
	XENCONS_RING_IDX in_cons;
	XENCONS_RING_IDX in_prod;
	XENCONS_RING_IDX out_cons;
	XENCONS_RING_IDX out_prod;
};

struct s3c24xx_uart_info;

struct s3c24xx_serial_drv_data;

struct s3c2410_uartcfg;

struct s3c24xx_uart_dma;

struct s3c24xx_uart_port {
	unsigned char rx_enabled;
	unsigned char tx_enabled;
	unsigned int pm_level;
	unsigned long baudclk_rate;
	unsigned int min_dma_size;
	unsigned int rx_irq;
	unsigned int tx_irq;
	unsigned int tx_in_progress;
	unsigned int tx_mode;
	unsigned int rx_mode;
	const struct s3c24xx_uart_info *info;
	struct clk *clk;
	struct clk *baudclk;
	struct uart_port port;
	const struct s3c24xx_serial_drv_data *drv_data;
	const struct s3c2410_uartcfg *cfg;
	struct s3c24xx_uart_dma *dma;
};

enum s3c24xx_port_type {
	TYPE_S3C6400 = 0,
	TYPE_APPLE_S5L = 1,
};

struct s3c24xx_uart_info {
	const char *name;
	enum s3c24xx_port_type type;
	unsigned int port_type;
	unsigned int fifosize;
	unsigned long rx_fifomask;
	unsigned long rx_fifoshift;
	unsigned long rx_fifofull;
	unsigned long tx_fifomask;
	unsigned long tx_fifoshift;
	unsigned long tx_fifofull;
	unsigned int def_clk_sel;
	unsigned long num_clks;
	unsigned long clksel_mask;
	unsigned long clksel_shift;
	unsigned long ucon_mask;
	unsigned int has_divslot: 1;
};

struct s3c2410_uartcfg {
	unsigned char hwport;
	unsigned char unused;
	unsigned short flags;
	upf_t uart_flags;
	unsigned int clk_sel;
	unsigned int has_fracval;
	unsigned long ucon;
	unsigned long ulcon;
	unsigned long ufcon;
};

struct s3c24xx_serial_drv_data {
	const struct s3c24xx_uart_info info;
	const struct s3c2410_uartcfg def_cfg;
	const unsigned int fifosize[12];
};

struct s3c24xx_uart_dma {
	unsigned int rx_chan_id;
	unsigned int tx_chan_id;
	struct dma_slave_config rx_conf;
	struct dma_slave_config tx_conf;
	struct dma_chan *rx_chan;
	struct dma_chan *tx_chan;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	char *rx_buf;
	dma_addr_t tx_transfer_addr;
	size_t rx_size;
	size_t tx_size;
	struct dma_async_tx_descriptor *tx_desc;
	struct dma_async_tx_descriptor *rx_desc;
	int tx_bytes_requested;
	int rx_bytes_requested;
};

struct samsung_early_console_data {
	u32 txfull_mask;
	u32 rxfifo_mask;
};

struct stm32_rng_data {
	uint max_clock_rate;
	u32 cr;
	u32 nscr;
	u32 htcr;
	bool has_cond_reset;
};

struct stm32_rng_config {
	u32 cr;
	u32 nscr;
	u32 htcr;
};

struct stm32_rng_private {
	struct hwrng rng;
	void *base;
	struct clk *clk;
	struct reset_control *rst;
	struct stm32_rng_config pm_conf;
	const struct stm32_rng_data *data;
	bool ced;
	bool lock_conf;
};

enum i2c_chip_type {
	SLB9635 = 0,
	SLB9645 = 1,
	UNKNOWN = 2,
};

struct tpm_inf_dev {
	struct i2c_client *client;
	int locality;
	u8 buf[1261];
	struct tpm_chip *chip;
	enum i2c_chip_type chip_type;
	unsigned int adapterlimit;
};

enum tis_defaults {
	TIS_SHORT_TIMEOUT = 750,
	TIS_LONG_TIMEOUT = 2000,
};

enum tis_status {
	TPM_STS_VALID = 128,
	TPM_STS_COMMAND_READY = 64,
	TPM_STS_GO = 32,
	TPM_STS_DATA_AVAIL = 16,
	TPM_STS_DATA_EXPECT = 8,
};

enum tis_access {
	TPM_ACCESS_VALID = 128,
	TPM_ACCESS_ACTIVE_LOCALITY = 32,
	TPM_ACCESS_REQUEST_PENDING = 4,
	TPM_ACCESS_REQUEST_USE = 2,
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

typedef void (*btf_trace_thermal_pressure_update)(void *, int, unsigned long);

struct cpu_topology {
	int thread_id;
	int core_id;
	int cluster_id;
	int package_id;
	cpumask_t thread_sibling;
	cpumask_t core_sibling;
	cpumask_t cluster_sibling;
	cpumask_t llc_sibling;
};

struct trace_event_raw_thermal_pressure_update {
	struct trace_entry ent;
	unsigned long thermal_pressure;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_thermal_pressure_update {};

struct hisi_sas_debugfs_reg_lu;

struct hisi_sas_debugfs_reg {
	const struct hisi_sas_debugfs_reg_lu *lu;
	int count;
	int base_off;
};

struct hisi_sas_debugfs_reg_lu {
	char *name;
	int off;
};

enum {
	DSM_FUNC_ERR_HANDLE_MSI = 0,
};

enum hisi_sas_debugfs_bist_ffe_cfg {
	FFE_SAS_1_5_GBPS = 0,
	FFE_SAS_3_0_GBPS = 1,
	FFE_SAS_6_0_GBPS = 2,
	FFE_SAS_12_0_GBPS = 3,
	FFE_RESV = 4,
	FFE_SATA_1_5_GBPS = 5,
	FFE_SATA_3_0_GBPS = 6,
	FFE_SATA_6_0_GBPS = 7,
	FFE_CFG_MAX = 8,
};

enum hisi_sas_debugfs_reg_array_member {
	DEBUGFS_GLOBAL = 0,
	DEBUGFS_AXI = 1,
	DEBUGFS_RAS = 2,
	DEBUGFS_REGS_NUM = 3,
};

enum hisi_sas_debugfs_cache_type {
	HISI_SAS_ITCT_CACHE = 0,
	HISI_SAS_IOST_CACHE = 1,
};

enum hisi_sas_debugfs_bist_fixed_code {
	FIXED_CODE = 0,
	FIXED_CODE_1 = 1,
	FIXED_CODE_MAX = 2,
};

enum {
	HISI_SAS_BIST_CODE_MODE_PRBS7 = 0,
	HISI_SAS_BIST_CODE_MODE_PRBS23 = 1,
	HISI_SAS_BIST_CODE_MODE_PRBS31 = 2,
	HISI_SAS_BIST_CODE_MODE_JTPAT = 3,
	HISI_SAS_BIST_CODE_MODE_CJTPAT = 4,
	HISI_SAS_BIST_CODE_MODE_SCRAMBED_0 = 5,
	HISI_SAS_BIST_CODE_MODE_TRAIN = 6,
	HISI_SAS_BIST_CODE_MODE_TRAIN_DONE = 7,
	HISI_SAS_BIST_CODE_MODE_HFTP = 8,
	HISI_SAS_BIST_CODE_MODE_MFTP = 9,
	HISI_SAS_BIST_CODE_MODE_LFTP = 10,
	HISI_SAS_BIST_CODE_MODE_FIXED_DATA = 11,
};

enum fifo_dump_mode_v3_hw {
	FIFO_DUMP_FORVER = 1,
	FIFO_DUMP_AFTER_TRIGGER = 2,
	FIFO_DUMP_UNTILL_TRIGGER = 4,
};

enum fifo_trigger_mode_v3_hw {
	FIFO_TRIGGER_EDGE = 1,
	FIFO_TRIGGER_SAME_LEVEL = 2,
	FIFO_TRIGGER_DIFF_LEVEL = 4,
};

struct hisi_sas_complete_v3_hdr {
	__le32 dw0;
	__le32 dw1;
	__le32 act;
	__le32 dw3;
};

struct hisi_sas_err_record_v3 {
	__le32 trans_tx_fail_type;
	__le32 trans_rx_fail_type;
	__le16 dma_tx_err_type;
	__le16 sipc_rx_err_type;
	__le32 dma_rx_err_type;
};

struct hisi_sas_protect_iu_v3_hw {
	u32 dw0;
	u32 lbrtcv;
	u32 lbrtgv;
	u32 dw3;
	u32 dw4;
	u32 dw5;
	u32 rsv;
};

struct hisi_sas_sge_dif_page {
	struct hisi_sas_sge sge[124];
};

struct cfi_early_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct cfi_private *);
};

struct jedec_ecc_info {
	u8 ecc_bits;
	u8 codeword_size;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 reserved[2];
};

struct nand_jedec_params {
	u8 sig[4];
	__le16 revision;
	__le16 features;
	u8 opt_cmd[3];
	__le16 sec_cmd;
	u8 num_of_param_pages;
	u8 reserved0[18];
	char manufacturer[12];
	char model[20];
	u8 jedec_id[6];
	u8 reserved1[10];
	__le32 byte_per_page;
	__le16 spare_bytes_per_page;
	u8 reserved2[6];
	__le32 pages_per_block;
	__le32 blocks_per_lun;
	u8 lun_count;
	u8 addr_cycles;
	u8 bits_per_cell;
	u8 programs_per_page;
	u8 multi_plane_addr;
	u8 multi_plane_op_attr;
	u8 reserved3[38];
	__le16 async_sdr_speed_grade;
	__le16 toggle_ddr_speed_grade;
	__le16 sync_ddr_speed_grade;
	u8 async_sdr_features;
	u8 toggle_ddr_features;
	u8 sync_ddr_features;
	__le16 t_prog;
	__le16 t_bers;
	__le16 t_r;
	__le16 t_r_multi_plane;
	__le16 t_ccs;
	__le16 io_pin_capacitance_typ;
	__le16 input_pin_capacitance_typ;
	__le16 clk_pin_capacitance_typ;
	u8 driver_strength_support;
	__le16 t_adl;
	u8 reserved4[36];
	u8 guaranteed_good_blocks;
	__le16 guaranteed_block_endurance;
	struct jedec_ecc_info ecc_info[4];
	u8 reserved5[29];
	u8 reserved6[148];
	__le16 vendor_rev_num;
	u8 reserved7[88];
	__le16 crc;
} __attribute__((packed));

struct nxp_fspi_devtype_data {
	unsigned int rxfifo;
	unsigned int txfifo;
	unsigned int ahb_buf_size;
	unsigned int quirks;
	bool little_endian;
};

struct nxp_fspi {
	void *iobase;
	void *ahb_addr;
	u32 memmap_phy;
	u32 memmap_phy_size;
	u32 memmap_start;
	u32 memmap_len;
	struct clk *clk;
	struct clk *clk_en;
	struct device *dev;
	struct completion c;
	struct nxp_fspi_devtype_data *devtype_data;
	struct mutex lock;
	struct pm_qos_request pm_qos_req;
	int selected;
};

enum {
	DP83867_PORT_MIRROING_KEEP = 0,
	DP83867_PORT_MIRROING_EN = 1,
	DP83867_PORT_MIRROING_DIS = 2,
};

enum led_trigger_netdev_modes {
	TRIGGER_NETDEV_LINK = 0,
	TRIGGER_NETDEV_LINK_10 = 1,
	TRIGGER_NETDEV_LINK_100 = 2,
	TRIGGER_NETDEV_LINK_1000 = 3,
	TRIGGER_NETDEV_HALF_DUPLEX = 4,
	TRIGGER_NETDEV_FULL_DUPLEX = 5,
	TRIGGER_NETDEV_TX = 6,
	TRIGGER_NETDEV_RX = 7,
	__TRIGGER_NETDEV_MAX = 8,
};

struct dp83867_private {
	u32 rx_id_delay;
	u32 tx_id_delay;
	u32 tx_fifo_depth;
	u32 rx_fifo_depth;
	int io_impedance;
	int port_mirroring;
	bool rxctrl_strap_quirk;
	bool set_clk_output;
	u32 clk_output_sel;
	bool sgmii_ref_clk_en;
};

struct virtnet_stat_desc {
	char desc[32];
	size_t offset;
};

struct virtnet_interrupt_coalesce {
	u32 max_packets;
	u32 max_usecs;
};

struct send_queue;

struct receive_queue;

struct control_buf;

struct virtnet_info {
	struct virtio_device *vdev;
	struct virtqueue *cvq;
	struct net_device *dev;
	struct send_queue *sq;
	struct receive_queue *rq;
	unsigned int status;
	u16 max_queue_pairs;
	u16 curr_queue_pairs;
	u16 xdp_queue_pairs;
	bool xdp_enabled;
	bool big_packets;
	unsigned int big_packets_num_skbfrags;
	bool mergeable_rx_bufs;
	bool has_rss;
	bool has_rss_hash_report;
	u8 rss_key_size;
	u16 rss_indir_table_size;
	u32 rss_hash_types_supported;
	u32 rss_hash_types_saved;
	bool has_cvq;
	bool any_header_sg;
	u8 hdr_len;
	struct delayed_work refill;
	bool refill_enabled;
	spinlock_t refill_lock;
	struct work_struct config_work;
	bool affinity_hint_set;
	struct hlist_node node;
	struct hlist_node node_dead;
	struct control_buf *ctrl;
	u8 duplex;
	u32 speed;
	struct virtnet_interrupt_coalesce intr_coal_tx;
	struct virtnet_interrupt_coalesce intr_coal_rx;
	unsigned long guest_offloads;
	unsigned long guest_offloads_capable;
	struct failover *failover;
};

struct virtnet_sq_stats {
	struct u64_stats_sync syncp;
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t xdp_tx;
	u64_stats_t xdp_tx_drops;
	u64_stats_t kicks;
	u64_stats_t tx_timeouts;
};

struct send_queue {
	struct virtqueue *vq;
	struct scatterlist sg[19];
	char name[16];
	struct virtnet_sq_stats stats;
	struct virtnet_interrupt_coalesce intr_coal;
	struct napi_struct napi;
	bool reset;
};

struct virtnet_rq_stats {
	struct u64_stats_sync syncp;
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t drops;
	u64_stats_t xdp_packets;
	u64_stats_t xdp_tx;
	u64_stats_t xdp_redirects;
	u64_stats_t xdp_drops;
	u64_stats_t kicks;
};

struct ewma_pkt_len {
	unsigned long internal;
};

struct virtnet_rq_dma;

struct receive_queue {
	struct virtqueue *vq;
	struct napi_struct napi;
	struct bpf_prog __attribute__((btf_type_tag("rcu"))) *xdp_prog;
	struct virtnet_rq_stats stats;
	struct virtnet_interrupt_coalesce intr_coal;
	struct page *pages;
	struct ewma_pkt_len mrg_avg_pkt_len;
	struct page_frag alloc_frag;
	struct scatterlist sg[19];
	unsigned int min_buf_len;
	char name[16];
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct virtnet_rq_dma *last_dma;
	bool do_dma;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct virtnet_rq_dma {
	dma_addr_t addr;
	u32 ref;
	u16 len;
	u16 need_sync;
};

struct virtio_net_ctrl_hdr {
	__u8 class;
	__u8 cmd;
};

typedef __u8 virtio_net_ctrl_ack;

struct virtio_net_ctrl_mq {
	__virtio16 virtqueue_pairs;
};

struct virtio_net_ctrl_rss {
	u32 hash_types;
	u16 indirection_table_mask;
	u16 unclassified_queue;
	u16 indirection_table[128];
	u16 max_tx_vq;
	u8 hash_key_length;
	u8 key[40];
};

struct virtio_net_ctrl_coal_tx {
	__le32 tx_max_packets;
	__le32 tx_usecs;
};

struct virtio_net_ctrl_coal_rx {
	__le32 rx_max_packets;
	__le32 rx_usecs;
};

struct virtio_net_ctrl_coal {
	__le32 max_packets;
	__le32 max_usecs;
};

struct virtio_net_ctrl_coal_vq {
	__le16 vqn;
	__le16 reserved;
	struct virtio_net_ctrl_coal coal;
};

struct control_buf {
	struct virtio_net_ctrl_hdr hdr;
	virtio_net_ctrl_ack status;
	struct virtio_net_ctrl_mq mq;
	u8 promisc;
	u8 allmulti;
	__virtio16 vid;
	__virtio64 offloads;
	struct virtio_net_ctrl_rss rss;
	struct virtio_net_ctrl_coal_tx coal_tx;
	struct virtio_net_ctrl_coal_rx coal_rx;
	struct virtio_net_ctrl_coal_vq coal_vq;
};

struct virtio_net_hdr_v1 {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	union {
		struct {
			__virtio16 csum_start;
			__virtio16 csum_offset;
		};
		struct {
			__virtio16 start;
			__virtio16 offset;
		} csum;
		struct {
			__le16 segments;
			__le16 dup_acks;
		} rsc;
	};
	__virtio16 num_buffers;
};

struct virtio_net_hdr_v1_hash {
	struct virtio_net_hdr_v1 hdr;
	__le32 hash_value;
	__le16 hash_report;
	__le16 padding;
};

struct virtio_net_common_hdr {
	union {
		struct virtio_net_hdr hdr;
		struct virtio_net_hdr_mrg_rxbuf mrg_hdr;
		struct virtio_net_hdr_v1_hash hash_v1_hdr;
	};
};

struct virtio_net_ctrl_mac {
	__virtio32 entries;
	__u8 macs[0];
};

struct fman_mac___3;

struct mac_device___3 {
	void *vaddr;
	struct device *dev;
	struct resource *res;
	u8 addr[6];
	struct fman_port *port[2];
	struct phylink *phylink;
	struct phylink_config phylink_config;
	phy_interface_t phy_if;
	bool promisc;
	bool allmulti;
	const struct phylink_mac_ops *phylink_ops;
	int (*enable)(struct fman_mac___3 *);
	void (*disable)(struct fman_mac___3 *);
	int (*set_promisc)(struct fman_mac___3 *, bool);
	int (*change_addr)(struct fman_mac___3 *, const enet_addr_t *);
	int (*set_allmulti)(struct fman_mac___3 *, bool);
	int (*set_tstamp)(struct fman_mac___3 *, bool);
	int (*set_multi)(struct net_device *, struct mac_device___3 *);
	int (*set_exception)(struct fman_mac___3 *, enum fman_mac_exceptions, bool);
	int (*add_hash_mac_addr)(struct fman_mac___3 *, enet_addr_t *);
	int (*remove_hash_mac_addr)(struct fman_mac___3 *, enet_addr_t *);
	void (*update_speed)(struct mac_device___3 *, int);
	struct fman_mac___3 *fman_mac;
	struct mac_priv_s *priv;
};

typedef void fman_mac_exception_cb___3(struct mac_device___3 *, enum fman_mac_exceptions);

struct memac_regs;

struct memac_cfg;

struct fman_mac___3 {
	struct memac_regs *regs;
	u64 addr;
	struct mac_device___3 *dev_id;
	fman_mac_exception_cb___3 *exception_cb;
	fman_mac_exception_cb___3 *event_cb;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	struct memac_cfg *memac_drv_param;
	void *fm;
	struct fman_rev_info fm_rev_info;
	struct phy *serdes;
	struct phylink_pcs *sgmii_pcs;
	struct phylink_pcs *qsgmii_pcs;
	struct phylink_pcs *xfi_pcs;
	bool allmulti_enabled;
	bool rgmii_no_half_duplex;
};

struct mac_addr___2 {
	u32 mac_addr_l;
	u32 mac_addr_u;
};

struct memac_regs {
	u32 res0000[2];
	u32 command_config;
	struct mac_addr___2 mac_addr0;
	u32 maxfrm;
	u32 res0018[1];
	u32 rx_fifo_sections;
	u32 tx_fifo_sections;
	u32 res0024[2];
	u32 hashtable_ctrl;
	u32 res0030[4];
	u32 ievent;
	u32 tx_ipg_length;
	u32 res0048;
	u32 imask;
	u32 res0050;
	u32 pause_quanta[4];
	u32 pause_thresh[4];
	u32 rx_pause_status;
	u32 res0078[2];
	struct mac_addr___2 mac_addr[7];
	u32 lpwake_timer;
	u32 sleep_timer;
	u32 res00c0[8];
	u32 statn_config;
	u32 res00e4[7];
	u32 reoct_l;
	u32 reoct_u;
	u32 roct_l;
	u32 roct_u;
	u32 raln_l;
	u32 raln_u;
	u32 rxpf_l;
	u32 rxpf_u;
	u32 rfrm_l;
	u32 rfrm_u;
	u32 rfcs_l;
	u32 rfcs_u;
	u32 rvlan_l;
	u32 rvlan_u;
	u32 rerr_l;
	u32 rerr_u;
	u32 ruca_l;
	u32 ruca_u;
	u32 rmca_l;
	u32 rmca_u;
	u32 rbca_l;
	u32 rbca_u;
	u32 rdrp_l;
	u32 rdrp_u;
	u32 rpkt_l;
	u32 rpkt_u;
	u32 rund_l;
	u32 rund_u;
	u32 r64_l;
	u32 r64_u;
	u32 r127_l;
	u32 r127_u;
	u32 r255_l;
	u32 r255_u;
	u32 r511_l;
	u32 r511_u;
	u32 r1023_l;
	u32 r1023_u;
	u32 r1518_l;
	u32 r1518_u;
	u32 r1519x_l;
	u32 r1519x_u;
	u32 rovr_l;
	u32 rovr_u;
	u32 rjbr_l;
	u32 rjbr_u;
	u32 rfrg_l;
	u32 rfrg_u;
	u32 rcnp_l;
	u32 rcnp_u;
	u32 rdrntp_l;
	u32 rdrntp_u;
	u32 res01d0[12];
	u32 teoct_l;
	u32 teoct_u;
	u32 toct_l;
	u32 toct_u;
	u32 res0210[2];
	u32 txpf_l;
	u32 txpf_u;
	u32 tfrm_l;
	u32 tfrm_u;
	u32 tfcs_l;
	u32 tfcs_u;
	u32 tvlan_l;
	u32 tvlan_u;
	u32 terr_l;
	u32 terr_u;
	u32 tuca_l;
	u32 tuca_u;
	u32 tmca_l;
	u32 tmca_u;
	u32 tbca_l;
	u32 tbca_u;
	u32 res0258[2];
	u32 tpkt_l;
	u32 tpkt_u;
	u32 tund_l;
	u32 tund_u;
	u32 t64_l;
	u32 t64_u;
	u32 t127_l;
	u32 t127_u;
	u32 t255_l;
	u32 t255_u;
	u32 t511_l;
	u32 t511_u;
	u32 t1023_l;
	u32 t1023_u;
	u32 t1518_l;
	u32 t1518_u;
	u32 t1519x_l;
	u32 t1519x_u;
	u32 res02a8[6];
	u32 tcnp_l;
	u32 tcnp_u;
	u32 res02c8[14];
	u32 if_mode;
	u32 if_status;
	u32 res0308[14];
	u32 hg_config;
	u32 res0344[3];
	u32 hg_pause_quanta;
	u32 res0354[3];
	u32 hg_pause_thresh;
	u32 res0364[3];
	u32 hgrx_pause_status;
	u32 hg_fifos_status;
	u32 rhm;
	u32 thm;
};

struct memac_cfg {
	bool reset_on_init;
	bool pause_ignore;
	bool promiscuous_mode_enable;
	struct fixed_phy_status *fixed_link;
	u16 max_frame_length;
	u16 pause_quanta;
	u32 tx_ipg_length;
};

struct fman_mac_params___3 {
	u8 mac_id;
	void *fm;
	fman_mac_exception_cb___3 *event_cb;
	fman_mac_exception_cb___3 *exception_cb;
};

enum hclge_reg_tag {
	HCLGE_REG_TAG_CMDQ = 0,
	HCLGE_REG_TAG_COMMON = 1,
	HCLGE_REG_TAG_RING = 2,
	HCLGE_REG_TAG_TQP_INTR = 3,
	HCLGE_REG_TAG_QUERY_32_BIT = 4,
	HCLGE_REG_TAG_QUERY_64_BIT = 5,
	HCLGE_REG_TAG_DFX_BIOS_COMMON = 6,
	HCLGE_REG_TAG_DFX_SSU_0 = 7,
	HCLGE_REG_TAG_DFX_SSU_1 = 8,
	HCLGE_REG_TAG_DFX_IGU_EGU = 9,
	HCLGE_REG_TAG_DFX_RPU_0 = 10,
	HCLGE_REG_TAG_DFX_RPU_1 = 11,
	HCLGE_REG_TAG_DFX_NCSI = 12,
	HCLGE_REG_TAG_DFX_RTC = 13,
	HCLGE_REG_TAG_DFX_PPP = 14,
	HCLGE_REG_TAG_DFX_RCB = 15,
	HCLGE_REG_TAG_DFX_TQP = 16,
	HCLGE_REG_TAG_DFX_SSU_2 = 17,
	HCLGE_REG_TAG_RPU_TNL = 18,
};

struct hclge_reg_tlv {
	u16 tag;
	u16 len;
};

struct hclge_reg_header {
	u64 magic_number;
	u8 is_vf;
	u8 rsv[7];
};

struct igb_reg_test {
	u16 reg;
	u16 reg_offset;
	u16 array_len;
	u16 test_type;
	u32 mask;
	u32 write;
};

struct igb_stats {
	char stat_string[32];
	int sizeof_stat;
	int stat_offset;
};

enum igb_diagnostics_results {
	TEST_REG = 0,
	TEST_EEP = 1,
	TEST_IRQ = 2,
	TEST_LOOP = 3,
	TEST_LINK = 4,
};

struct k3_cppi_desc_pool {
	struct device *dev;
	dma_addr_t dma_addr;
	void *cpumem;
	size_t desc_size;
	size_t mem_size;
	size_t num_desc;
	struct gen_pool *gen_pool;
};

struct vfio_iommu_driver_ops {
	char *name;
	struct module *owner;
	void * (*open)(unsigned long);
	void (*release)(void *);
	long (*ioctl)(void *, unsigned int, unsigned long);
	int (*attach_group)(void *, struct iommu_group *, enum vfio_group_type);
	void (*detach_group)(void *, struct iommu_group *);
	int (*pin_pages)(void *, struct iommu_group *, dma_addr_t, int, int, struct page **);
	void (*unpin_pages)(void *, dma_addr_t, int);
	void (*register_device)(void *, struct vfio_device *);
	void (*unregister_device)(void *, struct vfio_device *);
	int (*dma_rw)(void *, dma_addr_t, void *, size_t, bool);
	struct iommu_domain * (*group_iommu_domain)(void *, struct iommu_group *);
};

struct vfio_iommu_group {
	struct iommu_group *iommu_group;
	struct list_head next;
	bool pinned_page_dirty_scope;
};

struct vfio_domain {
	struct iommu_domain *domain;
	struct list_head next;
	struct list_head group_list;
	bool fgsp: 1;
	bool enforce_cache_coherency: 1;
};

struct vfio_dma {
	struct rb_node node;
	dma_addr_t iova;
	unsigned long vaddr;
	size_t size;
	int prot;
	bool iommu_mapped;
	bool lock_cap;
	bool vaddr_invalid;
	struct task_struct *task;
	struct rb_root pfn_list;
	unsigned long *bitmap;
	struct mm_struct *mm;
	size_t locked_vm;
};

struct vfio_pfn {
	struct rb_node node;
	dma_addr_t iova;
	unsigned long pfn;
	unsigned int ref_count;
};

struct vfio_regions {
	struct list_head list;
	dma_addr_t iova;
	phys_addr_t phys;
	size_t len;
};

struct vfio_iova {
	struct list_head list;
	dma_addr_t start;
	dma_addr_t end;
};

struct vfio_iova_range {
	__u64 start;
	__u64 end;
};

struct vfio_iommu_type1_info_cap_iova_range {
	struct vfio_info_cap_header header;
	__u32 nr_iovas;
	__u32 reserved;
	struct vfio_iova_range iova_ranges[0];
};

struct vfio_iommu {
	struct list_head domain_list;
	struct list_head iova_list;
	struct mutex lock;
	struct rb_root dma_list;
	struct list_head device_list;
	struct mutex device_list_lock;
	unsigned int dma_avail;
	unsigned int vaddr_invalid_count;
	uint64_t pgsize_bitmap;
	uint64_t num_non_pinned_groups;
	bool v2;
	bool nesting;
	bool dirty_page_tracking;
	struct list_head emulated_iommu_groups;
};

struct vfio_iommu_type1_dma_map {
	__u32 argsz;
	__u32 flags;
	__u64 vaddr;
	__u64 iova;
	__u64 size;
};

struct vfio_iommu_type1_info {
	__u32 argsz;
	__u32 flags;
	__u64 iova_pgsizes;
	__u32 cap_offset;
	__u32 pad;
};

struct vfio_iommu_type1_info_cap_migration {
	struct vfio_info_cap_header header;
	__u32 flags;
	__u64 pgsize_bitmap;
	__u64 max_dirty_bitmap_size;
};

struct vfio_iommu_type1_info_dma_avail {
	struct vfio_info_cap_header header;
	__u32 avail;
};

struct vfio_iommu_type1_dma_unmap {
	__u32 argsz;
	__u32 flags;
	__u64 iova;
	__u64 size;
	__u8 data[0];
};

struct vfio_bitmap {
	__u64 pgsize;
	__u64 size;
	__u64 __attribute__((btf_type_tag("user"))) *data;
};

struct vfio_iommu_type1_dirty_bitmap {
	__u32 argsz;
	__u32 flags;
	__u8 data[0];
};

struct vfio_iommu_type1_dirty_bitmap_get {
	__u64 iova;
	__u64 size;
	struct vfio_bitmap bitmap;
};

struct vfio_batch {
	struct page **pages;
	struct page *fallback_page;
	int capacity;
	int size;
	int offset;
};

struct tegra_xusb_mbox_regs {
	u16 cmd;
	u16 data_in;
	u16 data_out;
	u16 owner;
	u16 smi_intr;
};

struct tegra_xusb_phy_type;

struct tegra_xusb_context_soc;

struct tegra_xusb_soc_ops;

struct tegra_xusb_soc {
	const char *firmware;
	const char * const *supply_names;
	unsigned int num_supplies;
	const struct tegra_xusb_phy_type *phy_types;
	unsigned int num_types;
	const struct tegra_xusb_context_soc *context;
	struct {
		struct {
			unsigned int offset;
			unsigned int count;
		} usb2;
		struct {
			unsigned int offset;
			unsigned int count;
		} ulpi;
		struct {
			unsigned int offset;
			unsigned int count;
		} hsic;
		struct {
			unsigned int offset;
			unsigned int count;
		} usb3;
	} ports;
	struct tegra_xusb_mbox_regs mbox;
	const struct tegra_xusb_soc_ops *ops;
	bool scale_ss_clock;
	bool has_ipfs;
	bool lpm_support;
	bool otg_reset_sspi;
	bool has_bar2;
};

struct tegra_xusb_phy_type {
	const char *name;
	unsigned int num;
};

struct tegra_xusb_context_soc {
	struct {
		const unsigned int *offsets;
		unsigned int num_offsets;
	} ipfs;
	struct {
		const unsigned int *offsets;
		unsigned int num_offsets;
	} fpci;
};

struct tegra_xusb;

struct tegra_xusb_soc_ops {
	u32 (*mbox_reg_readl)(struct tegra_xusb *, unsigned int);
	void (*mbox_reg_writel)(struct tegra_xusb *, u32, unsigned int);
	u32 (*csb_reg_readl)(struct tegra_xusb *, unsigned int);
	void (*csb_reg_writel)(struct tegra_xusb *, u32, unsigned int);
};

struct tegra_xusb_padctl;

struct tegra_xusb_context {
	u32 *ipfs;
	u32 *fpci;
};

struct tegra_xusb {
	struct device *dev;
	void *regs;
	struct usb_hcd *hcd;
	struct mutex lock;
	int xhci_irq;
	int mbox_irq;
	int padctl_irq;
	void *ipfs_base;
	void *fpci_base;
	void *bar2_base;
	struct resource *bar2;
	const struct tegra_xusb_soc *soc;
	struct regulator_bulk_data *supplies;
	struct tegra_xusb_padctl *padctl;
	struct clk *host_clk;
	struct clk *falcon_clk;
	struct clk *ss_clk;
	struct clk *ss_src_clk;
	struct clk *hs_src_clk;
	struct clk *fs_src_clk;
	struct clk *pll_u_480m;
	struct clk *clk_m;
	struct clk *pll_e;
	struct reset_control *host_rst;
	struct reset_control *ss_rst;
	struct device *genpd_dev_host;
	struct device *genpd_dev_ss;
	bool use_genpd;
	struct phy **phys;
	unsigned int num_phys;
	struct usb_phy **usbphy;
	unsigned int num_usb_phys;
	int otg_usb2_port;
	int otg_usb3_port;
	bool host_mode;
	struct notifier_block id_nb;
	struct work_struct id_work;
	struct {
		size_t size;
		void *virt;
		dma_addr_t phys;
	} fw;
	bool suspended;
	struct tegra_xusb_context context;
	u8 lp0_utmi_pad_mask;
};

enum tegra_xusb_mbox_cmd {
	MBOX_CMD_MSG_ENABLED = 1,
	MBOX_CMD_INC_FALC_CLOCK = 2,
	MBOX_CMD_DEC_FALC_CLOCK = 3,
	MBOX_CMD_INC_SSPI_CLOCK = 4,
	MBOX_CMD_DEC_SSPI_CLOCK = 5,
	MBOX_CMD_SET_BW = 6,
	MBOX_CMD_SET_SS_PWR_GATING = 7,
	MBOX_CMD_SET_SS_PWR_UNGATING = 8,
	MBOX_CMD_SAVE_DFE_CTLE_CTX = 9,
	MBOX_CMD_AIRPLANE_MODE_ENABLED = 10,
	MBOX_CMD_AIRPLANE_MODE_DISABLED = 11,
	MBOX_CMD_START_HSIC_IDLE = 12,
	MBOX_CMD_STOP_HSIC_IDLE = 13,
	MBOX_CMD_DBC_WAKE_STACK = 14,
	MBOX_CMD_HSIC_PRETEND_CONNECT = 15,
	MBOX_CMD_RESET_SSPI = 16,
	MBOX_CMD_DISABLE_SS_LFPS_DETECTION = 17,
	MBOX_CMD_ENABLE_SS_LFPS_DETECTION = 18,
	MBOX_CMD_MAX = 19,
	MBOX_CMD_ACK = 128,
	MBOX_CMD_NAK = 129,
};

struct tegra_xusb_fw_header {
	__le32 boot_loadaddr_in_imem;
	__le32 boot_codedfi_offset;
	__le32 boot_codetag;
	__le32 boot_codesize;
	__le32 phys_memaddr;
	__le16 reqphys_memsize;
	__le16 alloc_phys_memsize;
	__le32 rodata_img_offset;
	__le32 rodata_section_start;
	__le32 rodata_section_end;
	__le32 main_fnaddr;
	__le32 fwimg_cksum;
	__le32 fwimg_created_time;
	__le32 imem_resident_start;
	__le32 imem_resident_end;
	__le32 idirect_start;
	__le32 idirect_end;
	__le32 l2_imem_start;
	__le32 l2_imem_end;
	__le32 version_id;
	u8 init_ddirect;
	u8 reserved[3];
	__le32 phys_addr_log_buffer;
	__le32 total_log_entries;
	__le32 dequeue_ptr;
	__le32 dummy_var[2];
	__le32 fwimg_len;
	u8 magic[8];
	__le32 ss_low_power_entry_timeout;
	u8 num_hsic_port;
	u8 padding[139];
};

struct tegra_xusb_mbox_msg {
	u32 cmd;
	u32 data;
};

struct ci_hdrc_msm {
	struct platform_device *ci;
	struct clk *core_clk;
	struct clk *iface_clk;
	struct clk *fs_clk;
	struct ci_hdrc_platform_data pdata;
	struct reset_controller_dev rcdev;
	bool secondary_phy;
	bool hsic;
	void *base;
};

struct ml_effect_state {
	struct ff_effect *effect;
	unsigned long flags;
	int count;
	unsigned long play_at;
	unsigned long stop_at;
	unsigned long adj_at;
};

struct ml_device {
	void *private;
	struct ml_effect_state states[16];
	int gain;
	struct timer_list timer;
	struct input_dev *dev;
	int (*play_effect)(struct input_dev *, void *, struct ff_effect *);
};

typedef void (*btf_trace_i2c_slave)(void *, const struct i2c_client *, enum i2c_slave_event, __u8 *, int);

struct trace_event_raw_i2c_slave {
	struct trace_entry ent;
	int adapter_nr;
	int ret;
	__u16 addr;
	__u16 len;
	enum i2c_slave_event event;
	__u8 buf[1];
	char __data[0];
};

struct trace_event_data_offsets_i2c_slave {};

struct sh_mobile_i2c_data;

struct sh_mobile_dt_config {
	int clks_per_count;
	int (*setup)(struct sh_mobile_i2c_data *);
};

struct sh_mobile_i2c_data {
	struct device *dev;
	void *reg;
	struct i2c_adapter adap;
	unsigned long bus_speed;
	unsigned int clks_per_count;
	struct clk *clk;
	u_int8_t icic;
	u_int8_t flags;
	u_int16_t iccl;
	u_int16_t icch;
	spinlock_t lock;
	wait_queue_head_t wait;
	struct i2c_msg *msg;
	int pos;
	int sr;
	bool send_stop;
	bool stop_after_dma;
	bool atomic_xfer;
	struct resource *res;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	struct scatterlist sg;
	enum dma_data_direction dma_direction;
	u8 *dma_buf;
};

enum sh_mobile_i2c_op {
	OP_START = 0,
	OP_TX_FIRST = 1,
	OP_TX = 2,
	OP_TX_STOP = 3,
	OP_TX_TO_RX = 4,
	OP_RX = 5,
	OP_RX_STOP = 6,
	OP_RX_STOP_DATA = 7,
};

struct syscon_reboot_mode {
	struct regmap *map;
	struct reboot_mode_driver reboot;
	u32 offset;
	u32 mask;
};

struct ths_device;

struct ths_thermal_chip {
	bool has_mod_clk;
	bool has_bus_clk_reset;
	int sensor_num;
	int offset;
	int scale;
	int ft_deviation;
	int temp_data_base;
	int (*calibrate)(struct ths_device *, u16 *, int);
	int (*init)(struct ths_device *);
	unsigned long (*irq_ack)(struct ths_device *);
	int (*calc_temp)(struct ths_device *, int, int);
};

struct tsensor {
	struct ths_device *tmdev;
	struct thermal_zone_device *tzd;
	int id;
};

struct ths_device {
	const struct ths_thermal_chip *chip;
	struct device *dev;
	struct regmap *regmap;
	struct reset_control *reset;
	struct clk *bus_clk;
	struct clk *mod_clk;
	struct tsensor sensor[4];
};

struct mtk_wdt_data {
	int toprgu_sw_rst_num;
};

struct mtk_wdt_dev {
	struct watchdog_device wdt_dev;
	void *wdt_base;
	spinlock_t lock;
	struct reset_controller_dev rcdev;
	bool disable_wdt_extrst;
	bool reset_by_toprgu;
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

enum interconnect_desc_param {
	INTERCONNECT_DESC_PARAM_LEN = 0,
	INTERCONNECT_DESC_PARAM_TYPE = 1,
	INTERCONNECT_DESC_PARAM_UNIPRO_VER = 2,
	INTERCONNECT_DESC_PARAM_MPHY_VER = 4,
};

enum health_desc_param {
	HEALTH_DESC_PARAM_LEN = 0,
	HEALTH_DESC_PARAM_TYPE = 1,
	HEALTH_DESC_PARAM_EOL_INFO = 2,
	HEALTH_DESC_PARAM_LIFE_TIME_EST_A = 3,
	HEALTH_DESC_PARAM_LIFE_TIME_EST_B = 4,
};

struct tegra186_bpmp {
	struct tegra_bpmp *parent;
	struct {
		struct gen_pool *pool;
		union {
			void *sram;
			void *dram;
		};
		dma_addr_t phys;
	} tx;
	struct {
		struct gen_pool *pool;
		union {
			void *sram;
			void *dram;
		};
		dma_addr_t phys;
	} rx;
	struct {
		struct mbox_client client;
		struct mbox_chan *channel;
	} mbox;
};

struct hid_global {
	unsigned int usage_page;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	unsigned int report_id;
	unsigned int report_size;
	unsigned int report_count;
};

struct hid_local {
	unsigned int usage[12288];
	u8 usage_size[12288];
	unsigned int collection_index[12288];
	unsigned int usage_index;
	unsigned int usage_minimum;
	unsigned int delimiter_depth;
	unsigned int delimiter_branch;
};

struct hid_parser {
	struct hid_global global;
	struct hid_global global_stack[4];
	unsigned int global_stack_ptr;
	struct hid_local local;
	unsigned int *collection_stack;
	unsigned int collection_stack_ptr;
	unsigned int collection_stack_size;
	struct hid_device *device;
	unsigned int scan_flags;
};

struct hid_item {
	unsigned int format;
	__u8 size;
	__u8 type;
	__u8 tag;
	union {
		__u8 u8;
		__s8 s8;
		__u16 u16;
		__s16 s16;
		__u32 u32;
		__s32 s32;
		__u8 *longdata;
	} data;
};

struct hiddev {
	int minor;
	int exist;
	int open;
	struct mutex existancelock;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct list_head list;
	spinlock_t list_lock;
	bool initialized;
};

struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hid_dynid {
	struct list_head list;
	struct hid_device_id id;
};

struct rmem_assigned_device {
	struct device *dev;
	struct reserved_mem *rmem;
	struct list_head list;
};

typedef int (*reservedmem_of_init_fn)(struct reserved_mem *);

enum imx_mu_type {
	IMX_MU_V1 = 0,
	IMX_MU_V2 = 2,
	IMX_MU_V2_S4 = 32768,
	IMX_MU_V2_IRQ = 65536,
};

struct imx_mu_priv;

struct imx_mu_con_priv;

struct imx_mu_dcfg {
	int (*tx)(struct imx_mu_priv *, struct imx_mu_con_priv *, void *);
	int (*rx)(struct imx_mu_priv *, struct imx_mu_con_priv *);
	int (*rxdb)(struct imx_mu_priv *, struct imx_mu_con_priv *);
	void (*init)(struct imx_mu_priv *);
	enum imx_mu_type type;
	u32 xTR;
	u32 xRR;
	u32 xSR[4];
	u32 xCR[5];
};

enum imx_mu_chan_type {
	IMX_MU_TYPE_TX = 0,
	IMX_MU_TYPE_RX = 1,
	IMX_MU_TYPE_TXDB = 2,
	IMX_MU_TYPE_RXDB = 3,
	IMX_MU_TYPE_RST = 4,
	IMX_MU_TYPE_TXDB_V2 = 5,
};

struct imx_mu_con_priv {
	unsigned int idx;
	char irq_desc[20];
	enum imx_mu_chan_type type;
	struct mbox_chan *chan;
	struct tasklet_struct txdb_tasklet;
};

struct imx_mu_priv {
	struct device *dev;
	void *base;
	void *msg;
	spinlock_t xcr_lock;
	struct mbox_controller mbox;
	struct mbox_chan mbox_chans[24];
	struct imx_mu_con_priv con_priv[24];
	const struct imx_mu_dcfg *dcfg;
	struct clk *clk;
	int irq[24];
	bool suspend;
	u32 xcr[5];
	bool side_b;
};

enum imx_mu_xcr {
	IMX_MU_CR = 0,
	IMX_MU_GIER = 1,
	IMX_MU_GCR = 2,
	IMX_MU_TCR = 3,
	IMX_MU_RCR = 4,
	IMX_MU_xCR_MAX = 5,
};

enum imx_mu_xsr {
	IMX_MU_SR = 0,
	IMX_MU_GSR = 1,
	IMX_MU_TSR = 2,
	IMX_MU_RSR = 3,
	IMX_MU_xSR_MAX = 4,
};

struct imx_s4_rpc_msg {
	uint8_t ver;
	uint8_t size;
	uint8_t cmd;
	uint8_t tag;
};

struct imx_s4_rpc_msg_max {
	struct imx_s4_rpc_msg hdr;
	u32 data[254];
};

struct imx_sc_rpc_msg_max {
	struct imx_sc_rpc_msg hdr;
	u32 data[30];
};

struct glink_rpm_pipe {
	struct qcom_glink_pipe native;
	void *tail;
	void *head;
	void *fifo;
};

struct glink_rpm {
	struct qcom_glink *glink;
	int irq;
	struct mbox_client mbox_client;
	struct mbox_chan *mbox_chan;
	struct glink_rpm_pipe rx_pipe;
	struct glink_rpm_pipe tx_pipe;
};

struct rpm_toc_entry {
	__le32 id;
	__le32 offset;
	__le32 size;
};

struct rpm_toc {
	__le32 magic;
	__le32 count;
	struct rpm_toc_entry entries[0];
};

struct iio_subirq {
	bool enabled;
};

struct iio_trigger_ops;

struct iio_trigger {
	const struct iio_trigger_ops *ops;
	struct module *owner;
	int id;
	const char *name;
	struct device dev;
	struct list_head list;
	struct list_head alloc_list;
	atomic_t use_count;
	struct irq_chip subirq_chip;
	int subirq_base;
	struct iio_subirq subirqs[2];
	unsigned long pool[1];
	struct mutex pool_lock;
	bool attached_own_device;
	struct work_struct reenable_work;
};

struct iio_trigger_ops {
	int (*set_trigger_state)(struct iio_trigger *, bool);
	void (*reenable)(struct iio_trigger *);
	int (*validate_device)(struct iio_trigger *, struct iio_dev *);
};

struct iio_poll_func {
	struct iio_dev *indio_dev;
	irqreturn_t (*h)(int, void *);
	irqreturn_t (*thread)(int, void *);
	int type;
	char *name;
	int irq;
	s64 timestamp;
};

struct ocotp_ctrl_reg {
	u32 bm_addr;
	u32 bm_busy;
	u32 bm_error;
	u32 bm_rel_shadows;
};

struct ocotp_priv___2;

struct ocotp_params {
	unsigned int nregs;
	unsigned int bank_address_words;
	void (*set_timing)(struct ocotp_priv___2 *);
	struct ocotp_ctrl_reg ctrl;
};

struct ocotp_priv___2 {
	struct device *dev;
	struct clk *clk;
	void *base;
	const struct ocotp_params *params;
	struct nvmem_config *config;
};

struct snd_compr_avail {
	__u64 avail;
	struct snd_compr_tstamp tstamp;
} __attribute__((packed));

struct snd_compr_file {
	unsigned long caps;
	struct snd_compr_stream stream;
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

struct so_timestamping {
	int flags;
	int bind_phc;
};

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
	NL_ATTR_TYPE_SINT = 16,
	NL_ATTR_TYPE_UINT = 17,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

struct netlink_policy_dump_state {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

struct ethtool_devlink_compat {
	struct devlink *devlink;
	union {
		struct ethtool_flash efl;
		struct ethtool_drvinfo info;
	};
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[4];
		__u32 advertising[4];
		__u32 lp_advertising[4];
	} link_modes;
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 rsvd8[3];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

struct nf_bridge_frag_data;

struct nf_ipv6_ops {
	int (*chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
	int (*route_me_harder)(struct net *, struct sock *, struct sk_buff *);
	int (*dev_get_saddr)(struct net *, const struct net_device *, const struct in6_addr *, unsigned int, struct in6_addr *);
	int (*route)(struct net *, struct dst_entry **, struct flowi *, bool);
	u32 (*cookie_init_sequence)(const struct ipv6hdr *, const struct tcphdr *, u16 *);
	int (*cookie_v6_check)(const struct ipv6hdr *, const struct tcphdr *, __u32);
	void (*route_input)(struct sk_buff *);
	int (*fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
	int (*br_fragment)(struct net *, struct sock *, struct sk_buff *, struct nf_bridge_frag_data *, int (*)(struct net *, struct sock *, const struct nf_bridge_frag_data *, struct sk_buff *));
};

struct tcp_plb_state {
	u8 consec_cong_rounds: 5;
	u8 unused: 3;
	u32 pause_until;
};

struct xdr_skb_reader {
	struct sk_buff *skb;
	unsigned int offset;
	size_t count;
	__wsum csum;
};

typedef size_t (*xdr_skb_read_actor)(struct xdr_skb_reader *, void *, size_t);

struct xprt_addr {
	const char *addr;
	struct callback_head rcu;
};

typedef void (*btf_trace_ma_op)(void *, const char *, struct ma_state *);

typedef void (*btf_trace_ma_read)(void *, const char *, struct ma_state *);

typedef void (*btf_trace_ma_write)(void *, const char *, struct ma_state *, unsigned long, void *);

enum maple_type {
	maple_dense = 0,
	maple_leaf_64 = 1,
	maple_range_64 = 2,
	maple_arange_64 = 3,
};

struct trace_event_raw_ma_op {
	struct trace_entry ent;
	const char *fn;
	unsigned long min;
	unsigned long max;
	unsigned long index;
	unsigned long last;
	void *node;
	char __data[0];
};

struct trace_event_raw_ma_read {
	struct trace_entry ent;
	const char *fn;
	unsigned long min;
	unsigned long max;
	unsigned long index;
	unsigned long last;
	void *node;
	char __data[0];
};

struct trace_event_raw_ma_write {
	struct trace_entry ent;
	const char *fn;
	unsigned long min;
	unsigned long max;
	unsigned long index;
	unsigned long last;
	unsigned long piv;
	void *val;
	void *node;
	char __data[0];
};

struct maple_pnode;

struct maple_metadata {
	unsigned char end;
	unsigned char gap;
};

struct maple_range_64 {
	struct maple_pnode *parent;
	unsigned long pivot[15];
	union {
		void __attribute__((btf_type_tag("rcu"))) *slot[16];
		struct {
			void __attribute__((btf_type_tag("rcu"))) *pad[15];
			struct maple_metadata meta;
		};
	};
};

struct maple_arange_64 {
	struct maple_pnode *parent;
	unsigned long pivot[9];
	void __attribute__((btf_type_tag("rcu"))) *slot[10];
	unsigned long gap[10];
	struct maple_metadata meta;
};

struct maple_node {
	union {
		struct {
			struct maple_pnode *parent;
			void __attribute__((btf_type_tag("rcu"))) *slot[31];
		};
		struct {
			void *pad;
			struct callback_head rcu;
			struct maple_enode *piv_parent;
			unsigned char parent_slot;
			enum maple_type type;
			unsigned char slot_len;
			unsigned int ma_flags;
		};
		struct maple_range_64 mr64;
		struct maple_arange_64 ma64;
		struct maple_alloc alloc;
	};
};

struct maple_topiary {
	struct maple_pnode *parent;
	struct maple_enode *next;
};

struct ma_wr_state {
	struct ma_state *mas;
	struct maple_node *node;
	unsigned long r_min;
	unsigned long r_max;
	enum maple_type type;
	unsigned char offset_end;
	unsigned char node_end;
	unsigned long *pivots;
	unsigned long end_piv;
	void __attribute__((btf_type_tag("rcu"))) **slots;
	void *entry;
	void *content;
};

struct maple_big_node {
	struct maple_pnode *parent;
	unsigned long pivot[33];
	union {
		struct maple_enode *slot[34];
		struct {
			unsigned long padding[21];
			unsigned long gap[21];
		};
	};
	unsigned char b_end;
	enum maple_type type;
};

struct ma_topiary;

struct maple_subtree_state {
	struct ma_state *orig_l;
	struct ma_state *orig_r;
	struct ma_state *l;
	struct ma_state *m;
	struct ma_state *r;
	struct ma_topiary *free;
	struct ma_topiary *destroy;
	struct maple_big_node *bn;
};

struct ma_topiary {
	struct maple_enode *head;
	struct maple_enode *tail;
	struct maple_tree *mtree;
};

struct trace_event_data_offsets_ma_op {};

struct trace_event_data_offsets_ma_read {};

struct trace_event_data_offsets_ma_write {};

struct vdso_abi_info {
	const char *name;
	const char *vdso_code_start;
	const char *vdso_code_end;
	unsigned long vdso_pages;
	struct vm_special_mapping *dm;
	struct vm_special_mapping *cm;
};

enum vdso_abi {
	VDSO_ABI_AA64 = 0,
	VDSO_ABI_AA32 = 1,
};

enum aarch32_map {
	AA32_MAP_VECTORS = 0,
	AA32_MAP_SIGPAGE = 1,
	AA32_MAP_VVAR = 2,
	AA32_MAP_VDSO = 3,
};

enum vvar_pages {
	VVAR_DATA_PAGE_OFFSET = 0,
	VVAR_TIMENS_PAGE_OFFSET = 1,
	VVAR_NR_PAGES = 2,
};

enum aarch64_map {
	AA64_MAP_VVAR = 0,
	AA64_MAP_VDSO = 1,
};

struct page_change_data {
	pgprot_t set_mask;
	pgprot_t clear_mask;
};

struct vgic_its_abi {
	int cte_esz;
	int dte_esz;
	int ite_esz;
	int (*save_tables)(struct vgic_its *);
	int (*restore_tables)(struct vgic_its *);
	int (*commit)(struct vgic_its *);
};

struct vgic_translation_cache_entry {
	struct list_head entry;
	phys_addr_t db;
	u32 devid;
	u32 eventid;
	struct vgic_irq *irq;
};

struct its_device___2 {
	struct list_head dev_list;
	struct list_head itt_head;
	u32 num_eventid_bits;
	gpa_t itt_addr;
	u32 device_id;
};

struct its_collection___2;

struct its_ite {
	struct list_head ite_list;
	struct vgic_irq *irq;
	struct its_collection___2 *collection;
	u32 event_id;
};

struct its_collection___2 {
	struct list_head coll_list;
	u32 collection_id;
	u32 target_addr;
};

typedef int (*entry_fn_t)(struct vgic_its *, u32, void *, void *);

struct host_mmu {
	struct kvm_arch___2 arch;
	struct kvm_pgtable___2 pgt;
	struct kvm_pgtable_mm_ops mm_ops;
	hyp_spinlock_t lock;
};

struct kvm_mem_range {
	u64 start;
	u64 end;
};

struct pkvm_mem_transition {
	u64 nr_pages;
	struct {
		enum pkvm_component_id id;
		u64 addr;
		union {
			struct {
				u64 completer_addr;
			} host;
			struct {
				u64 completer_addr;
			} hyp;
		};
	} initiator;
	struct {
		enum pkvm_component_id id;
	} completer;
};

struct pkvm_mem_donation {
	const struct pkvm_mem_transition tx;
};

struct pkvm_mem_share {
	const struct pkvm_mem_transition tx;
	const enum kvm_pgtable_prot completer_prot;
};

struct check_walk_data {
	enum pkvm_page_state desired;
	enum pkvm_page_state (*get_page_state)(kvm_pte_t, u64);
};

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

typedef void (*btf_trace_tasklet_entry)(void *, struct tasklet_struct *, void *);

typedef void (*btf_trace_tasklet_exit)(void *, struct tasklet_struct *, void *);

typedef struct {
	unsigned int __softirq_pending;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} irq_cpustat_t;

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_raw_tasklet {
	struct trace_entry ent;
	void *tasklet;
	void *func;
	char __data[0];
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_softirq {};

struct trace_event_data_offsets_tasklet {};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_suseconds_t suseconds_t;

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)();
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

struct kprobe_blacklist_entry {
	struct list_head list;
	unsigned long start_addr;
	unsigned long end_addr;
};

typedef int (*objpool_init_obj_cb)(void *, void *);

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
};

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

enum {
	BPF_F_UPROBE_MULTI_RETURN = 1,
};

enum {
	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
};

typedef u64 (*btf_bpf_override_return)(struct pt_regs *, unsigned long);

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void __attribute__((btf_type_tag("user"))) *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void __attribute__((btf_type_tag("user"))) *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void __attribute__((btf_type_tag("user"))) *, const void *, u32);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_trace_vprintk)(char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

struct btf_ptr;

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

struct bpf_perf_event_value;

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_current_task)();

typedef u64 (*btf_bpf_get_current_task_btf)();

typedef u64 (*btf_bpf_task_pt_regs)(struct task_struct *);

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_get_func_ip_tracing)(void *);

typedef u64 (*btf_bpf_get_func_ip_kprobe)(struct pt_regs *);

typedef u64 (*btf_bpf_get_func_ip_kprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_attach_cookie_kprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_func_ip_uprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_attach_cookie_uprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_attach_cookie_trace)(void *);

typedef u64 (*btf_bpf_get_attach_cookie_pe)(struct bpf_perf_event_data_kern *);

typedef u64 (*btf_bpf_get_attach_cookie_tracing)(void *);

typedef u64 (*btf_bpf_get_branch_snapshot)(void *, u32, u64);

typedef u64 (*btf_get_func_arg)(void *, u32, u64 *);

typedef u64 (*btf_get_func_ret)(void *, u64 *);

typedef u64 (*btf_get_func_arg_cnt)(void *);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct bpf_uprobe;

struct bpf_uprobe_multi_run_ctx {
	struct bpf_run_ctx run_ctx;
	unsigned long entry_ip;
	struct bpf_uprobe *uprobe;
};

struct bpf_uprobe_multi_link;

struct bpf_uprobe {
	struct bpf_uprobe_multi_link *link;
	loff_t offset;
	u64 cookie;
	struct uprobe_consumer consumer;
};

struct bpf_uprobe_multi_link {
	struct path path;
	struct bpf_link link;
	u32 cnt;
	struct bpf_uprobe *uprobes;
	struct task_struct *task;
};

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
};

struct bpf_key {
	struct key *key;
	bool has_ref;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

typedef void (*btf_trace_mm_lru_insertion)(void *, struct folio *);

typedef void (*btf_trace_mm_lru_activate)(void *, struct folio *);

struct lru_rotate {
	local_lock_t lock;
	struct folio_batch fbatch;
};

struct cpu_fbatches {
	local_lock_t lock;
	struct folio_batch lru_add;
	struct folio_batch lru_deactivate_file;
	struct folio_batch lru_deactivate;
	struct folio_batch lru_lazyfree;
	struct folio_batch activate;
};

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct folio *folio;
	unsigned long pfn;
	enum lru_list lru;
	unsigned long flags;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct folio *folio;
	unsigned long pfn;
	char __data[0];
};

typedef void (*move_fn_t)(struct lruvec *, struct folio *);

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_lru_activate {};

struct vma_swap_readahead {
	unsigned short win;
	unsigned short offset;
	unsigned short nr_pte;
};

struct inodes_stat_t {
	long nr_inodes;
	long nr_unused;
	long dummy[5];
};

typedef void (*btf_trace_ext2_dio_write_begin)(void *, struct kiocb *, struct iov_iter *, ssize_t);

typedef void (*btf_trace_ext2_dio_write_end)(void *, struct kiocb *, struct iov_iter *, ssize_t);

typedef void (*btf_trace_ext2_dio_write_buff_end)(void *, struct kiocb *, struct iov_iter *, ssize_t);

typedef void (*btf_trace_ext2_dio_read_begin)(void *, struct kiocb *, struct iov_iter *, ssize_t);

typedef void (*btf_trace_ext2_dio_read_end)(void *, struct kiocb *, struct iov_iter *, ssize_t);

typedef void (*btf_trace_ext2_dio_write_endio)(void *, struct kiocb *, ssize_t, int);

struct trace_event_raw_ext2_dio_class {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t isize;
	loff_t pos;
	size_t count;
	int ki_flags;
	bool aio;
	ssize_t ret;
	char __data[0];
};

struct trace_event_raw_ext2_dio_write_endio {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t isize;
	loff_t pos;
	ssize_t size;
	int ki_flags;
	bool aio;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_ext2_dio_class {};

struct trace_event_data_offsets_ext2_dio_write_endio {};

struct nfs_page_iter_page {
	const struct nfs_page *req;
	size_t count;
};

struct nfs4_ds_server {
	struct list_head list;
	struct rpc_clnt *rpc_clnt;
};

struct autofs_dev_ioctl;

typedef int (*ioctl_fn___2)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

struct args_protover {
	__u32 version;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_openmount {
	__u32 devid;
};

struct args_ready {
	__u32 token;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_expire {
	__u32 how;
};

struct args_askumount {
	__u32 may_umount;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

struct security_hook_heads {
	struct hlist_head binder_set_context_mgr;
	struct hlist_head binder_transaction;
	struct hlist_head binder_transfer_binder;
	struct hlist_head binder_transfer_file;
	struct hlist_head ptrace_access_check;
	struct hlist_head ptrace_traceme;
	struct hlist_head capget;
	struct hlist_head capset;
	struct hlist_head capable;
	struct hlist_head quotactl;
	struct hlist_head quota_on;
	struct hlist_head syslog;
	struct hlist_head settime;
	struct hlist_head vm_enough_memory;
	struct hlist_head bprm_creds_for_exec;
	struct hlist_head bprm_creds_from_file;
	struct hlist_head bprm_check_security;
	struct hlist_head bprm_committing_creds;
	struct hlist_head bprm_committed_creds;
	struct hlist_head fs_context_submount;
	struct hlist_head fs_context_dup;
	struct hlist_head fs_context_parse_param;
	struct hlist_head sb_alloc_security;
	struct hlist_head sb_delete;
	struct hlist_head sb_free_security;
	struct hlist_head sb_free_mnt_opts;
	struct hlist_head sb_eat_lsm_opts;
	struct hlist_head sb_mnt_opts_compat;
	struct hlist_head sb_remount;
	struct hlist_head sb_kern_mount;
	struct hlist_head sb_show_options;
	struct hlist_head sb_statfs;
	struct hlist_head sb_mount;
	struct hlist_head sb_umount;
	struct hlist_head sb_pivotroot;
	struct hlist_head sb_set_mnt_opts;
	struct hlist_head sb_clone_mnt_opts;
	struct hlist_head move_mount;
	struct hlist_head dentry_init_security;
	struct hlist_head dentry_create_files_as;
	struct hlist_head path_notify;
	struct hlist_head inode_alloc_security;
	struct hlist_head inode_free_security;
	struct hlist_head inode_init_security;
	struct hlist_head inode_init_security_anon;
	struct hlist_head inode_create;
	struct hlist_head inode_link;
	struct hlist_head inode_unlink;
	struct hlist_head inode_symlink;
	struct hlist_head inode_mkdir;
	struct hlist_head inode_rmdir;
	struct hlist_head inode_mknod;
	struct hlist_head inode_rename;
	struct hlist_head inode_readlink;
	struct hlist_head inode_follow_link;
	struct hlist_head inode_permission;
	struct hlist_head inode_setattr;
	struct hlist_head inode_getattr;
	struct hlist_head inode_setxattr;
	struct hlist_head inode_post_setxattr;
	struct hlist_head inode_getxattr;
	struct hlist_head inode_listxattr;
	struct hlist_head inode_removexattr;
	struct hlist_head inode_set_acl;
	struct hlist_head inode_get_acl;
	struct hlist_head inode_remove_acl;
	struct hlist_head inode_need_killpriv;
	struct hlist_head inode_killpriv;
	struct hlist_head inode_getsecurity;
	struct hlist_head inode_setsecurity;
	struct hlist_head inode_listsecurity;
	struct hlist_head inode_getsecid;
	struct hlist_head inode_copy_up;
	struct hlist_head inode_copy_up_xattr;
	struct hlist_head kernfs_init_security;
	struct hlist_head file_permission;
	struct hlist_head file_alloc_security;
	struct hlist_head file_free_security;
	struct hlist_head file_ioctl;
	struct hlist_head mmap_addr;
	struct hlist_head mmap_file;
	struct hlist_head file_mprotect;
	struct hlist_head file_lock;
	struct hlist_head file_fcntl;
	struct hlist_head file_set_fowner;
	struct hlist_head file_send_sigiotask;
	struct hlist_head file_receive;
	struct hlist_head file_open;
	struct hlist_head file_truncate;
	struct hlist_head task_alloc;
	struct hlist_head task_free;
	struct hlist_head cred_alloc_blank;
	struct hlist_head cred_free;
	struct hlist_head cred_prepare;
	struct hlist_head cred_transfer;
	struct hlist_head cred_getsecid;
	struct hlist_head kernel_act_as;
	struct hlist_head kernel_create_files_as;
	struct hlist_head kernel_module_request;
	struct hlist_head kernel_load_data;
	struct hlist_head kernel_post_load_data;
	struct hlist_head kernel_read_file;
	struct hlist_head kernel_post_read_file;
	struct hlist_head task_fix_setuid;
	struct hlist_head task_fix_setgid;
	struct hlist_head task_fix_setgroups;
	struct hlist_head task_setpgid;
	struct hlist_head task_getpgid;
	struct hlist_head task_getsid;
	struct hlist_head current_getsecid_subj;
	struct hlist_head task_getsecid_obj;
	struct hlist_head task_setnice;
	struct hlist_head task_setioprio;
	struct hlist_head task_getioprio;
	struct hlist_head task_prlimit;
	struct hlist_head task_setrlimit;
	struct hlist_head task_setscheduler;
	struct hlist_head task_getscheduler;
	struct hlist_head task_movememory;
	struct hlist_head task_kill;
	struct hlist_head task_prctl;
	struct hlist_head task_to_inode;
	struct hlist_head userns_create;
	struct hlist_head ipc_permission;
	struct hlist_head ipc_getsecid;
	struct hlist_head msg_msg_alloc_security;
	struct hlist_head msg_msg_free_security;
	struct hlist_head msg_queue_alloc_security;
	struct hlist_head msg_queue_free_security;
	struct hlist_head msg_queue_associate;
	struct hlist_head msg_queue_msgctl;
	struct hlist_head msg_queue_msgsnd;
	struct hlist_head msg_queue_msgrcv;
	struct hlist_head shm_alloc_security;
	struct hlist_head shm_free_security;
	struct hlist_head shm_associate;
	struct hlist_head shm_shmctl;
	struct hlist_head shm_shmat;
	struct hlist_head sem_alloc_security;
	struct hlist_head sem_free_security;
	struct hlist_head sem_associate;
	struct hlist_head sem_semctl;
	struct hlist_head sem_semop;
	struct hlist_head netlink_send;
	struct hlist_head d_instantiate;
	struct hlist_head getprocattr;
	struct hlist_head setprocattr;
	struct hlist_head ismaclabel;
	struct hlist_head secid_to_secctx;
	struct hlist_head secctx_to_secid;
	struct hlist_head release_secctx;
	struct hlist_head inode_invalidate_secctx;
	struct hlist_head inode_notifysecctx;
	struct hlist_head inode_setsecctx;
	struct hlist_head inode_getsecctx;
	struct hlist_head key_alloc;
	struct hlist_head key_free;
	struct hlist_head key_permission;
	struct hlist_head key_getsecurity;
	struct hlist_head audit_rule_init;
	struct hlist_head audit_rule_known;
	struct hlist_head audit_rule_match;
	struct hlist_head audit_rule_free;
	struct hlist_head bpf;
	struct hlist_head bpf_map;
	struct hlist_head bpf_prog;
	struct hlist_head bpf_map_alloc_security;
	struct hlist_head bpf_map_free_security;
	struct hlist_head bpf_prog_alloc_security;
	struct hlist_head bpf_prog_free_security;
	struct hlist_head locked_down;
	struct hlist_head perf_event_open;
	struct hlist_head perf_event_alloc;
	struct hlist_head perf_event_free;
	struct hlist_head perf_event_read;
	struct hlist_head perf_event_write;
	struct hlist_head uring_override_creds;
	struct hlist_head uring_sqpoll;
	struct hlist_head uring_cmd;
};

enum lsm_event {
	LSM_POLICY_CHANGE = 0,
};

struct x509_parse_context {
	struct x509_certificate *cert;
	unsigned long data;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID sig_algo;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

struct io_open {
	struct file *file;
	int dfd;
	u32 file_slot;
	struct filename *filename;
	struct open_how how;
	unsigned long nofile;
};

struct io_close {
	struct file *file;
	int fd;
	u32 file_slot;
};

struct strarray {
	char **array;
	size_t n;
};

struct sg_splitter {
	struct scatterlist *in_sg0;
	int nents;
	off_t skip_sg0;
	unsigned int length_last_sg;
	struct scatterlist *out_sg;
};

struct mbigen_device {
	struct platform_device *pdev;
	void *base;
};

struct ti_sci_inta_event_desc {
	u16 global_event;
	u32 hwirq;
	u8 vint_bit;
};

struct ti_sci_inta_vint_desc {
	struct irq_domain *domain;
	struct list_head list;
	unsigned long event_map[1];
	struct ti_sci_inta_event_desc events[64];
	unsigned int parent_virq;
	u16 vint_id;
};

struct ti_sci_inta_irq_domain {
	const struct ti_sci_handle *sci;
	struct ti_sci_resource *vint;
	struct ti_sci_resource *global_event;
	struct list_head vint_list;
	struct mutex vint_mutex;
	void *base;
	struct platform_device *pdev;
	u32 ti_sci_id;
	int unmapped_cnt;
	u16 *unmapped_dev_ids;
};

struct sunxi_rsb_addr_map {
	u16 hwaddr;
	u8 rtaddr;
};

struct sunxi_rsb {
	struct device *dev;
	void *regs;
	struct clk *clk;
	struct reset_control *rstc;
	struct completion complete;
	struct mutex lock;
	unsigned int status;
	u32 clk_freq;
};

struct sunxi_rsb_ctx {
	struct sunxi_rsb_device *rdev;
	int size;
};

struct mvebu_comphy_conf {
	enum phy_mode mode;
	int submode;
	unsigned int lane;
	unsigned int port;
	u32 mux;
	u32 fw_mode;
};

struct mvebu_comphy_priv {
	void *base;
	struct regmap *regmap;
	struct device *dev;
	struct clk *mg_domain_clk;
	struct clk *mg_core_clk;
	struct clk *axi_clk;
	unsigned long cp_phys;
};

struct mvebu_comphy_lane {
	struct mvebu_comphy_priv *priv;
	unsigned int id;
	enum phy_mode mode;
	int submode;
	int port;
};

struct pinctrl_maps {
	struct list_head node;
	const struct pinctrl_map *maps;
	unsigned int num_maps;
};

struct pctldev;

enum pad_func_e {
	IMX_SC_PAD_FUNC_SET = 15,
	IMX_SC_PAD_FUNC_GET = 16,
};

struct imx_sc_msg_resp_pad_get {
	struct imx_sc_rpc_msg hdr;
	u32 val;
};

struct imx_sc_msg_req_pad_get {
	struct imx_sc_rpc_msg hdr;
	u16 pad;
	long: 0;
};

struct imx_sc_msg_req_pad_set {
	struct imx_sc_rpc_msg hdr;
	u32 val;
	u16 pad;
};

struct imx_sc_msg_gpio_set_pad_wakeup {
	struct imx_sc_rpc_msg hdr;
	u16 pad;
	u8 wakeup;
};

struct meson_pmx_axg_data {
	unsigned int func;
};

struct armada_37xx_pin_group;

struct armada_37xx_pin_data {
	u8 nr_pins;
	char *name;
	struct armada_37xx_pin_group *groups;
	int ngroups;
};

struct armada_37xx_pin_group {
	const char *name;
	unsigned int start_pin;
	unsigned int npins;
	u32 reg_mask;
	u32 val[3];
	unsigned int extra_pin;
	unsigned int extra_npins;
	const char *funcs[3];
	unsigned int *pins;
};

struct armada_37xx_pm_state {
	u32 out_en_l;
	u32 out_en_h;
	u32 out_val_l;
	u32 out_val_h;
	u32 irq_en_l;
	u32 irq_en_h;
	u32 irq_pol_l;
	u32 irq_pol_h;
	u32 selection;
};

struct armada_37xx_pmx_func;

struct armada_37xx_pinctrl {
	struct regmap *regmap;
	void *base;
	const struct armada_37xx_pin_data *data;
	struct device *dev;
	struct gpio_chip gpio_chip;
	raw_spinlock_t irq_lock;
	struct pinctrl_desc pctl;
	struct pinctrl_dev *pctl_dev;
	struct armada_37xx_pin_group *groups;
	unsigned int ngroups;
	struct armada_37xx_pmx_func *funcs;
	unsigned int nfuncs;
	struct armada_37xx_pm_state pm;
};

struct armada_37xx_pmx_func {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct tile_info {
	u32 offset;
	u32 size;
};

typedef void (*btf_trace_gpio_direction)(void *, unsigned int, int, int);

typedef void (*btf_trace_gpio_value)(void *, unsigned int, int, int);

enum {
	GPIOLINE_CHANGED_REQUESTED = 1,
	GPIOLINE_CHANGED_RELEASED = 2,
	GPIOLINE_CHANGED_CONFIG = 3,
};

struct gpio_pin_range {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_gpio_range range;
};

struct trace_event_raw_gpio_direction {
	struct trace_entry ent;
	unsigned int gpio;
	int in;
	int err;
	char __data[0];
};

struct trace_event_raw_gpio_value {
	struct trace_entry ent;
	unsigned int gpio;
	int get;
	int value;
	char __data[0];
};

struct gpiod_hog {
	struct list_head list;
	const char *chip_label;
	u16 chip_hwnum;
	const char *line_name;
	unsigned long lflags;
	int dflags;
};

typedef struct {
	spinlock_t *lock;
	unsigned long flags;
} class_spinlock_irqsave_t;

struct trace_event_data_offsets_gpio_direction {};

struct trace_event_data_offsets_gpio_value {};

enum {
	MATCH_MTR = 0,
	MATCH_MEQ = 1,
	MATCH_MLE = 2,
	MATCH_MLT = 3,
	MATCH_MGE = 4,
	MATCH_MGT = 5,
};

struct acpi_table_hest {
	struct acpi_table_header header;
	u32 error_source_count;
};

struct acpi_hest_ia_corrected {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	struct acpi_hest_notify notify;
	u8 num_hardware_banks;
	u8 reserved2[3];
};

struct acpi_hest_ia_machine_check {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u64 global_capability_data;
	u64 global_control_data;
	u8 num_hardware_banks;
	u8 reserved3[7];
};

struct acpi_hest_ia_deferred_check {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	struct acpi_hest_notify notify;
	u8 num_hardware_banks;
	u8 reserved2[3];
};

typedef int (*apei_hest_func_t)(struct acpi_hest_header *, void *);

struct ghes_arr {
	struct platform_device **ghes_devs;
	unsigned int count;
};

struct acpipnp_parse_option_s {
	struct pnp_dev *dev;
	unsigned int option_flags;
};

enum s5m8767_reg {
	S5M8767_REG_ID = 0,
	S5M8767_REG_INT1 = 1,
	S5M8767_REG_INT2 = 2,
	S5M8767_REG_INT3 = 3,
	S5M8767_REG_INT1M = 4,
	S5M8767_REG_INT2M = 5,
	S5M8767_REG_INT3M = 6,
	S5M8767_REG_STATUS1 = 7,
	S5M8767_REG_STATUS2 = 8,
	S5M8767_REG_STATUS3 = 9,
	S5M8767_REG_CTRL1 = 10,
	S5M8767_REG_CTRL2 = 11,
	S5M8767_REG_LOWBAT1 = 12,
	S5M8767_REG_LOWBAT2 = 13,
	S5M8767_REG_BUCHG = 14,
	S5M8767_REG_DVSRAMP = 15,
	S5M8767_REG_DVSTIMER2 = 16,
	S5M8767_REG_DVSTIMER3 = 17,
	S5M8767_REG_DVSTIMER4 = 18,
	S5M8767_REG_LDO1 = 19,
	S5M8767_REG_LDO2 = 20,
	S5M8767_REG_LDO3 = 21,
	S5M8767_REG_LDO4 = 22,
	S5M8767_REG_LDO5 = 23,
	S5M8767_REG_LDO6 = 24,
	S5M8767_REG_LDO7 = 25,
	S5M8767_REG_LDO8 = 26,
	S5M8767_REG_LDO9 = 27,
	S5M8767_REG_LDO10 = 28,
	S5M8767_REG_LDO11 = 29,
	S5M8767_REG_LDO12 = 30,
	S5M8767_REG_LDO13 = 31,
	S5M8767_REG_LDO14 = 32,
	S5M8767_REG_LDO15 = 33,
	S5M8767_REG_LDO16 = 34,
	S5M8767_REG_LDO17 = 35,
	S5M8767_REG_LDO18 = 36,
	S5M8767_REG_LDO19 = 37,
	S5M8767_REG_LDO20 = 38,
	S5M8767_REG_LDO21 = 39,
	S5M8767_REG_LDO22 = 40,
	S5M8767_REG_LDO23 = 41,
	S5M8767_REG_LDO24 = 42,
	S5M8767_REG_LDO25 = 43,
	S5M8767_REG_LDO26 = 44,
	S5M8767_REG_LDO27 = 45,
	S5M8767_REG_LDO28 = 46,
	S5M8767_REG_UVLO = 49,
	S5M8767_REG_BUCK1CTRL1 = 50,
	S5M8767_REG_BUCK1CTRL2 = 51,
	S5M8767_REG_BUCK2CTRL = 52,
	S5M8767_REG_BUCK2DVS1 = 53,
	S5M8767_REG_BUCK2DVS2 = 54,
	S5M8767_REG_BUCK2DVS3 = 55,
	S5M8767_REG_BUCK2DVS4 = 56,
	S5M8767_REG_BUCK2DVS5 = 57,
	S5M8767_REG_BUCK2DVS6 = 58,
	S5M8767_REG_BUCK2DVS7 = 59,
	S5M8767_REG_BUCK2DVS8 = 60,
	S5M8767_REG_BUCK3CTRL = 61,
	S5M8767_REG_BUCK3DVS1 = 62,
	S5M8767_REG_BUCK3DVS2 = 63,
	S5M8767_REG_BUCK3DVS3 = 64,
	S5M8767_REG_BUCK3DVS4 = 65,
	S5M8767_REG_BUCK3DVS5 = 66,
	S5M8767_REG_BUCK3DVS6 = 67,
	S5M8767_REG_BUCK3DVS7 = 68,
	S5M8767_REG_BUCK3DVS8 = 69,
	S5M8767_REG_BUCK4CTRL = 70,
	S5M8767_REG_BUCK4DVS1 = 71,
	S5M8767_REG_BUCK4DVS2 = 72,
	S5M8767_REG_BUCK4DVS3 = 73,
	S5M8767_REG_BUCK4DVS4 = 74,
	S5M8767_REG_BUCK4DVS5 = 75,
	S5M8767_REG_BUCK4DVS6 = 76,
	S5M8767_REG_BUCK4DVS7 = 77,
	S5M8767_REG_BUCK4DVS8 = 78,
	S5M8767_REG_BUCK5CTRL1 = 79,
	S5M8767_REG_BUCK5CTRL2 = 80,
	S5M8767_REG_BUCK5CTRL3 = 81,
	S5M8767_REG_BUCK5CTRL4 = 82,
	S5M8767_REG_BUCK5CTRL5 = 83,
	S5M8767_REG_BUCK6CTRL1 = 84,
	S5M8767_REG_BUCK6CTRL2 = 85,
	S5M8767_REG_BUCK7CTRL1 = 86,
	S5M8767_REG_BUCK7CTRL2 = 87,
	S5M8767_REG_BUCK8CTRL1 = 88,
	S5M8767_REG_BUCK8CTRL2 = 89,
	S5M8767_REG_BUCK9CTRL1 = 90,
	S5M8767_REG_BUCK9CTRL2 = 91,
	S5M8767_REG_LDO1CTRL = 92,
	S5M8767_REG_LDO2_1CTRL = 93,
	S5M8767_REG_LDO2_2CTRL = 94,
	S5M8767_REG_LDO2_3CTRL = 95,
	S5M8767_REG_LDO2_4CTRL = 96,
	S5M8767_REG_LDO3CTRL = 97,
	S5M8767_REG_LDO4CTRL = 98,
	S5M8767_REG_LDO5CTRL = 99,
	S5M8767_REG_LDO6CTRL = 100,
	S5M8767_REG_LDO7CTRL = 101,
	S5M8767_REG_LDO8CTRL = 102,
	S5M8767_REG_LDO9CTRL = 103,
	S5M8767_REG_LDO10CTRL = 104,
	S5M8767_REG_LDO11CTRL = 105,
	S5M8767_REG_LDO12CTRL = 106,
	S5M8767_REG_LDO13CTRL = 107,
	S5M8767_REG_LDO14CTRL = 108,
	S5M8767_REG_LDO15CTRL = 109,
	S5M8767_REG_LDO16CTRL = 110,
	S5M8767_REG_LDO17CTRL = 111,
	S5M8767_REG_LDO18CTRL = 112,
	S5M8767_REG_LDO19CTRL = 113,
	S5M8767_REG_LDO20CTRL = 114,
	S5M8767_REG_LDO21CTRL = 115,
	S5M8767_REG_LDO22CTRL = 116,
	S5M8767_REG_LDO23CTRL = 117,
	S5M8767_REG_LDO24CTRL = 118,
	S5M8767_REG_LDO25CTRL = 119,
	S5M8767_REG_LDO26CTRL = 120,
	S5M8767_REG_LDO27CTRL = 121,
	S5M8767_REG_LDO28CTRL = 122,
};

struct s2mps11_clk {
	struct sec_pmic_dev *iodev;
	struct device_node *clk_np;
	struct clk_hw hw;
	struct clk *clk;
	struct clk_lookup *lookup;
	u32 mask;
	unsigned int reg;
};

struct hi6220_stub_clk {
	u32 id;
	struct device *dev;
	struct clk_hw hw;
	struct regmap *dfs_map;
	struct mbox_client cl;
	struct mbox_chan *mbox;
};

struct hi6220_mbox_msg {
	unsigned char type;
	unsigned char cmd;
	unsigned char obj;
	unsigned char src;
	unsigned char para[4];
};

union hi6220_mbox_data {
	unsigned int data[8];
	struct hi6220_mbox_msg msg;
};

struct mtk_clk_cpumux {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 mask;
	u8 shift;
};

struct div6_clock {
	struct clk_hw hw;
	void *reg;
	unsigned int div;
	u32 src_mask;
	struct notifier_block nb;
	u8 parents[0];
};

struct clk_rk3568_inits {
	void (*inits)(struct device_node *);
};

struct tegra_clk_device {
	struct notifier_block clk_nb;
	struct device *dev;
	struct clk_hw *hw;
	struct mutex lock;
};

struct vexpress_osc {
	struct regmap *reg;
	struct clk_hw hw;
	unsigned long rate_min;
	unsigned long rate_max;
};

enum pmic_type {
	PMIC_MT6323 = 0,
	PMIC_MT6331 = 1,
	PMIC_MT6332 = 2,
	PMIC_MT6351 = 3,
	PMIC_MT6357 = 4,
	PMIC_MT6358 = 5,
	PMIC_MT6359 = 6,
	PMIC_MT6380 = 7,
	PMIC_MT6397 = 8,
};

struct pwrap_slv_regops;

struct pwrap_slv_type {
	const u32 *dew_regs;
	enum pmic_type type;
	const u32 *comp_dew_regs;
	enum pmic_type comp_type;
	const struct pwrap_slv_regops *regops;
	u32 caps;
};

struct pmic_wrapper;

struct pwrap_slv_regops {
	const struct regmap_config *regmap;
	int (*pwrap_read)(struct pmic_wrapper *, u32, u32 *);
	int (*pwrap_write)(struct pmic_wrapper *, u32, u32);
};

struct pmic_wrapper_type;

struct pmic_wrapper {
	struct device *dev;
	void *base;
	struct regmap *regmap;
	const struct pmic_wrapper_type *master;
	const struct pwrap_slv_type *slave;
	struct clk *clk_spi;
	struct clk *clk_wrap;
	struct clk *clk_sys;
	struct clk *clk_tmr;
	struct reset_control *rstc;
	struct reset_control *rstc_bridge;
	void *bridge_base;
};

enum pwrap_type {
	PWRAP_MT2701 = 0,
	PWRAP_MT6765 = 1,
	PWRAP_MT6779 = 2,
	PWRAP_MT6795 = 3,
	PWRAP_MT6797 = 4,
	PWRAP_MT6873 = 5,
	PWRAP_MT7622 = 6,
	PWRAP_MT8135 = 7,
	PWRAP_MT8173 = 8,
	PWRAP_MT8183 = 9,
	PWRAP_MT8186 = 10,
	PWRAP_MT8195 = 11,
	PWRAP_MT8365 = 12,
	PWRAP_MT8516 = 13,
};

struct pmic_wrapper_type {
	int *regs;
	enum pwrap_type type;
	u32 arb_en_all;
	u32 int_en_all;
	u32 int1_en_all;
	u32 spi_w;
	u32 wdt_src;
	u32 caps;
	int (*init_reg_clock)(struct pmic_wrapper *);
	int (*init_soc_specific)(struct pmic_wrapper *);
};

enum pwrap_regs {
	PWRAP_MUX_SEL = 0,
	PWRAP_WRAP_EN = 1,
	PWRAP_DIO_EN = 2,
	PWRAP_SIDLY = 3,
	PWRAP_CSHEXT_WRITE = 4,
	PWRAP_CSHEXT_READ = 5,
	PWRAP_CSLEXT_START = 6,
	PWRAP_CSLEXT_END = 7,
	PWRAP_STAUPD_PRD = 8,
	PWRAP_STAUPD_GRPEN = 9,
	PWRAP_STAUPD_MAN_TRIG = 10,
	PWRAP_STAUPD_STA = 11,
	PWRAP_WRAP_STA = 12,
	PWRAP_HARB_INIT = 13,
	PWRAP_HARB_HPRIO = 14,
	PWRAP_HIPRIO_ARB_EN = 15,
	PWRAP_HARB_STA0 = 16,
	PWRAP_HARB_STA1 = 17,
	PWRAP_MAN_EN = 18,
	PWRAP_MAN_CMD = 19,
	PWRAP_MAN_RDATA = 20,
	PWRAP_MAN_VLDCLR = 21,
	PWRAP_WACS0_EN = 22,
	PWRAP_INIT_DONE0 = 23,
	PWRAP_WACS0_CMD = 24,
	PWRAP_WACS0_RDATA = 25,
	PWRAP_WACS0_VLDCLR = 26,
	PWRAP_WACS1_EN = 27,
	PWRAP_INIT_DONE1 = 28,
	PWRAP_WACS1_CMD = 29,
	PWRAP_WACS1_RDATA = 30,
	PWRAP_WACS1_VLDCLR = 31,
	PWRAP_WACS2_EN = 32,
	PWRAP_INIT_DONE2 = 33,
	PWRAP_WACS2_CMD = 34,
	PWRAP_WACS2_RDATA = 35,
	PWRAP_WACS2_VLDCLR = 36,
	PWRAP_INT_EN = 37,
	PWRAP_INT_FLG_RAW = 38,
	PWRAP_INT_FLG = 39,
	PWRAP_INT_CLR = 40,
	PWRAP_SIG_ADR = 41,
	PWRAP_SIG_MODE = 42,
	PWRAP_SIG_VALUE = 43,
	PWRAP_SIG_ERRVAL = 44,
	PWRAP_CRC_EN = 45,
	PWRAP_TIMER_EN = 46,
	PWRAP_TIMER_STA = 47,
	PWRAP_WDT_UNIT = 48,
	PWRAP_WDT_SRC_EN = 49,
	PWRAP_WDT_FLG = 50,
	PWRAP_DEBUG_INT_SEL = 51,
	PWRAP_CIPHER_KEY_SEL = 52,
	PWRAP_CIPHER_IV_SEL = 53,
	PWRAP_CIPHER_RDY = 54,
	PWRAP_CIPHER_MODE = 55,
	PWRAP_CIPHER_SWRST = 56,
	PWRAP_DCM_EN = 57,
	PWRAP_DCM_DBC_PRD = 58,
	PWRAP_EINT_STA0_ADR = 59,
	PWRAP_EINT_STA1_ADR = 60,
	PWRAP_SWINF_2_WDATA_31_0 = 61,
	PWRAP_SWINF_2_RDATA_31_0 = 62,
	PWRAP_ADC_CMD_ADDR = 63,
	PWRAP_PWRAP_ADC_CMD = 64,
	PWRAP_ADC_RDY_ADDR = 65,
	PWRAP_ADC_RDATA_ADDR1 = 66,
	PWRAP_ADC_RDATA_ADDR2 = 67,
	PWRAP_STA = 68,
	PWRAP_CLR = 69,
	PWRAP_DVFS_ADR8 = 70,
	PWRAP_DVFS_WDATA8 = 71,
	PWRAP_DVFS_ADR9 = 72,
	PWRAP_DVFS_WDATA9 = 73,
	PWRAP_DVFS_ADR10 = 74,
	PWRAP_DVFS_WDATA10 = 75,
	PWRAP_DVFS_ADR11 = 76,
	PWRAP_DVFS_WDATA11 = 77,
	PWRAP_DVFS_ADR12 = 78,
	PWRAP_DVFS_WDATA12 = 79,
	PWRAP_DVFS_ADR13 = 80,
	PWRAP_DVFS_WDATA13 = 81,
	PWRAP_DVFS_ADR14 = 82,
	PWRAP_DVFS_WDATA14 = 83,
	PWRAP_DVFS_ADR15 = 84,
	PWRAP_DVFS_WDATA15 = 85,
	PWRAP_EXT_CK = 86,
	PWRAP_ADC_RDATA_ADDR = 87,
	PWRAP_GPS_STA = 88,
	PWRAP_SW_RST = 89,
	PWRAP_DVFS_STEP_CTRL0 = 90,
	PWRAP_DVFS_STEP_CTRL1 = 91,
	PWRAP_DVFS_STEP_CTRL2 = 92,
	PWRAP_SPI2_CTRL = 93,
	PWRAP_CSHEXT = 94,
	PWRAP_EVENT_IN_EN = 95,
	PWRAP_EVENT_DST_EN = 96,
	PWRAP_RRARB_INIT = 97,
	PWRAP_RRARB_EN = 98,
	PWRAP_RRARB_STA0 = 99,
	PWRAP_RRARB_STA1 = 100,
	PWRAP_EVENT_STA = 101,
	PWRAP_EVENT_STACLR = 102,
	PWRAP_CIPHER_LOAD = 103,
	PWRAP_CIPHER_START = 104,
	PWRAP_RDDMY = 105,
	PWRAP_SI_CK_CON = 106,
	PWRAP_DVFS_ADR0 = 107,
	PWRAP_DVFS_WDATA0 = 108,
	PWRAP_DVFS_ADR1 = 109,
	PWRAP_DVFS_WDATA1 = 110,
	PWRAP_DVFS_ADR2 = 111,
	PWRAP_DVFS_WDATA2 = 112,
	PWRAP_DVFS_ADR3 = 113,
	PWRAP_DVFS_WDATA3 = 114,
	PWRAP_DVFS_ADR4 = 115,
	PWRAP_DVFS_WDATA4 = 116,
	PWRAP_DVFS_ADR5 = 117,
	PWRAP_DVFS_WDATA5 = 118,
	PWRAP_DVFS_ADR6 = 119,
	PWRAP_DVFS_WDATA6 = 120,
	PWRAP_DVFS_ADR7 = 121,
	PWRAP_DVFS_WDATA7 = 122,
	PWRAP_SPMINF_STA = 123,
	PWRAP_CIPHER_EN = 124,
	PWRAP_SI_SAMPLE_CTRL = 125,
	PWRAP_CSLEXT_WRITE = 126,
	PWRAP_CSLEXT_READ = 127,
	PWRAP_EXT_CK_WRITE = 128,
	PWRAP_STAUPD_CTRL = 129,
	PWRAP_WACS_P2P_EN = 130,
	PWRAP_INIT_DONE_P2P = 131,
	PWRAP_WACS_MD32_EN = 132,
	PWRAP_INIT_DONE_MD32 = 133,
	PWRAP_INT1_EN = 134,
	PWRAP_INT1_FLG = 135,
	PWRAP_INT1_CLR = 136,
	PWRAP_WDT_SRC_EN_1 = 137,
	PWRAP_INT_GPS_AUXADC_CMD_ADDR = 138,
	PWRAP_INT_GPS_AUXADC_CMD = 139,
	PWRAP_INT_GPS_AUXADC_RDATA_ADDR = 140,
	PWRAP_EXT_GPS_AUXADC_RDATA_ADDR = 141,
	PWRAP_GPSINF_0_STA = 142,
	PWRAP_GPSINF_1_STA = 143,
	PWRAP_OP_TYPE = 144,
	PWRAP_MSB_FIRST = 145,
};

enum dew_regs {
	PWRAP_DEW_BASE = 0,
	PWRAP_DEW_DIO_EN = 1,
	PWRAP_DEW_READ_TEST = 2,
	PWRAP_DEW_WRITE_TEST = 3,
	PWRAP_DEW_CRC_EN = 4,
	PWRAP_DEW_CRC_VAL = 5,
	PWRAP_DEW_MON_GRP_SEL = 6,
	PWRAP_DEW_CIPHER_KEY_SEL = 7,
	PWRAP_DEW_CIPHER_IV_SEL = 8,
	PWRAP_DEW_CIPHER_RDY = 9,
	PWRAP_DEW_CIPHER_MODE = 10,
	PWRAP_DEW_CIPHER_SWRST = 11,
	PWRAP_DEW_CIPHER_EN = 12,
	PWRAP_DEW_RDDMY_NO = 13,
	PWRAP_SMT_CON1 = 14,
	PWRAP_DRV_CON1 = 15,
	PWRAP_FILTER_CON0 = 16,
	PWRAP_GPIO_PULLEN0_CLR = 17,
	PWRAP_RG_SPI_CON0 = 18,
	PWRAP_RG_SPI_RECORD0 = 19,
	PWRAP_RG_SPI_CON2 = 20,
	PWRAP_RG_SPI_CON3 = 21,
	PWRAP_RG_SPI_CON4 = 22,
	PWRAP_RG_SPI_CON5 = 23,
	PWRAP_RG_SPI_CON6 = 24,
	PWRAP_RG_SPI_CON7 = 25,
	PWRAP_RG_SPI_CON8 = 26,
	PWRAP_RG_SPI_CON13 = 27,
	PWRAP_SPISLV_KEY = 28,
	PWRAP_DEW_CRC_SWRST = 29,
	PWRAP_DEW_RG_EN_RECORD = 30,
	PWRAP_DEW_RECORD_CMD0 = 31,
	PWRAP_DEW_RECORD_CMD1 = 32,
	PWRAP_DEW_RECORD_CMD2 = 33,
	PWRAP_DEW_RECORD_CMD3 = 34,
	PWRAP_DEW_RECORD_CMD4 = 35,
	PWRAP_DEW_RECORD_CMD5 = 36,
	PWRAP_DEW_RECORD_WDATA0 = 37,
	PWRAP_DEW_RECORD_WDATA1 = 38,
	PWRAP_DEW_RECORD_WDATA2 = 39,
	PWRAP_DEW_RECORD_WDATA3 = 40,
	PWRAP_DEW_RECORD_WDATA4 = 41,
	PWRAP_DEW_RECORD_WDATA5 = 42,
	PWRAP_DEW_RG_ADDR_TARGET = 43,
	PWRAP_DEW_RG_ADDR_MASK = 44,
	PWRAP_DEW_RG_WDATA_TARGET = 45,
	PWRAP_DEW_RG_WDATA_MASK = 46,
	PWRAP_DEW_RG_SPI_RECORD_CLR = 47,
	PWRAP_DEW_RG_CMD_ALERT_CLR = 48,
	PWRAP_DEW_EVENT_OUT_EN = 49,
	PWRAP_DEW_EVENT_SRC_EN = 50,
	PWRAP_DEW_EVENT_SRC = 51,
	PWRAP_DEW_EVENT_FLAG = 52,
	PWRAP_DEW_MON_FLAG_SEL = 53,
	PWRAP_DEW_EVENT_TEST = 54,
	PWRAP_DEW_CIPHER_LOAD = 55,
	PWRAP_DEW_CIPHER_START = 56,
};

struct exynos_soc_id {
	const char *name;
	unsigned int id;
};

struct exynos_chipid_variant {
	unsigned int rev_reg;
	unsigned int main_rev_shift;
	unsigned int sub_rev_shift;
};

struct exynos_chipid_info {
	u32 product_id;
	u32 revision;
};

struct meson_gx_pwrc_vpu {
	struct generic_pm_domain genpd;
	struct regmap *regmap_ao;
	struct regmap *regmap_hhi;
	struct reset_control *rstc;
	struct clk *vpu_clk;
	struct clk *vapb_clk;
};

struct scpsys_domain_data;

struct scpsys_soc_data {
	const struct scpsys_domain_data *domains_data;
	int num_domains;
};

struct scpsys_bus_prot_data {
	u32 bus_prot_set_clr_mask;
	u32 bus_prot_set;
	u32 bus_prot_clr;
	u32 bus_prot_sta_mask;
	u32 bus_prot_sta;
	u8 flags;
};

struct scpsys_domain_data {
	const char *name;
	u32 sta_mask;
	int ctl_offs;
	u32 sram_pdn_bits;
	u32 sram_pdn_ack_bits;
	int ext_buck_iso_offs;
	u32 ext_buck_iso_mask;
	u16 caps;
	const struct scpsys_bus_prot_data bp_cfg[6];
	int pwr_sta_offs;
	int pwr_sta2nd_offs;
};

enum scpsys_bus_prot_flags {
	BUS_PROT_REG_UPDATE = 2,
	BUS_PROT_IGNORE_CLR_ACK = 4,
	BUS_PROT_INVERTED = 8,
	BUS_PROT_COMPONENT_INFRA = 16,
	BUS_PROT_COMPONENT_SMI = 32,
	BUS_PROT_STA_COMPONENT_INFRA_NAO = 64,
};

struct scpsys;

struct scpsys_domain {
	struct generic_pm_domain genpd;
	const struct scpsys_domain_data *data;
	struct scpsys *scpsys;
	int num_clks;
	struct clk_bulk_data *clks;
	int num_subsys_clks;
	struct clk_bulk_data *subsys_clks;
	struct regmap *infracfg_nao;
	struct regmap *infracfg;
	struct regmap *smi;
	struct regulator *supply;
};

struct scpsys {
	struct device *dev;
	struct regmap *base;
	const struct scpsys_soc_data *soc_data;
	struct genpd_onecell_data pd_data;
	struct generic_pm_domain *domains[0];
};

struct evtchn_fifo_queue {
	uint32_t head[16];
};

typedef uint32_t event_word_t;

struct evtchn_fifo_control_block {
	uint32_t ready;
	uint32_t _rsvd;
	event_word_t head[16];
};

struct evtchn_init_control {
	uint64_t control_gfn;
	uint32_t offset;
	uint32_t vcpu;
	uint8_t link_bits;
	uint8_t _pad[7];
};

struct evtchn_expand_array {
	uint64_t array_gfn;
};

struct xenbus_transaction_holder {
	struct list_head list;
	struct xenbus_transaction handle;
	unsigned int generation_id;
};

struct read_buffer {
	struct list_head list;
	unsigned int cons;
	unsigned int len;
	char msg[0];
};

struct xenbus_file_priv {
	struct mutex msgbuffer_mutex;
	struct list_head transactions;
	struct list_head watches;
	unsigned int len;
	union {
		struct xsd_sockmsg msg;
		char buffer[4096];
	} u;
	struct mutex reply_mutex;
	struct list_head read_buffers;
	wait_queue_head_t read_waitq;
	struct kref kref;
	struct work_struct wq;
};

struct watch_adapter {
	struct list_head list;
	struct xenbus_watch watch;
	struct xenbus_file_priv *dev_data;
	char *token;
};

struct fixed_regulator_data {
	struct fixed_voltage_config cfg;
	struct regulator_init_data init_data;
	struct platform_device pdev;
};

struct uniphier_reset_data {
	unsigned int id;
	unsigned int reg;
	unsigned int bit;
	unsigned int flags;
};

struct uniphier_reset_priv {
	struct reset_controller_dev rcdev;
	struct device *dev;
	struct regmap *regmap;
	const struct uniphier_reset_data *data;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct dw8250_platform_data {
	u8 usr_reg;
	u32 cpr_val;
	unsigned int quirks;
};

struct dw8250_port_data {
	int line;
	struct uart_8250_dma dma;
	u8 dlf_size;
	bool hw_rs485_support;
};

struct dw8250_data {
	struct dw8250_port_data data;
	const struct dw8250_platform_data *pdata;
	int msr_mask_on;
	int msr_mask_off;
	struct clk *clk;
	struct clk *pclk;
	struct notifier_block clk_notifier;
	struct work_struct clk_work;
	struct reset_control *rst;
	unsigned int skip_autocfg: 1;
	unsigned int uart_16550_compatible: 1;
};

enum lpuart_type {
	VF610_LPUART = 0,
	LS1021A_LPUART = 1,
	LS1028A_LPUART = 2,
	IMX7ULP_LPUART = 3,
	IMX8ULP_LPUART = 4,
	IMX8QXP_LPUART = 5,
	IMXRT1050_LPUART = 6,
};

struct lpuart_port {
	struct uart_port port;
	enum lpuart_type devtype;
	struct clk *ipg_clk;
	struct clk *baud_clk;
	unsigned int txfifo_size;
	unsigned int rxfifo_size;
	u8 rx_watermark;
	bool lpuart_dma_tx_use;
	bool lpuart_dma_rx_use;
	struct dma_chan *dma_tx_chan;
	struct dma_chan *dma_rx_chan;
	struct dma_async_tx_descriptor *dma_tx_desc;
	struct dma_async_tx_descriptor *dma_rx_desc;
	dma_cookie_t dma_tx_cookie;
	dma_cookie_t dma_rx_cookie;
	unsigned int dma_tx_bytes;
	unsigned int dma_rx_bytes;
	bool dma_tx_in_progress;
	unsigned int dma_rx_timeout;
	struct timer_list lpuart_timer;
	struct scatterlist rx_sgl;
	struct scatterlist tx_sgl[2];
	struct circ_buf rx_ring;
	int rx_dma_rng_buf_len;
	int last_residue;
	unsigned int dma_tx_nents;
	wait_queue_head_t dma_wait;
	bool is_cs7;
	bool dma_idle_int;
};

struct lpuart_soc_data {
	enum lpuart_type devtype;
	char iotype;
	u8 reg_off;
	u8 rx_watermark;
};

struct arm_smmu_ctx_desc {
	u16 asid;
	u64 ttbr;
	u64 tcr;
	u64 mair;
	refcount_t refs;
	struct mm_struct *mm;
};

struct arm_smmu_option_prop {
	u32 opt;
	const char *prop;
};

enum pri_resp {
	PRI_RESP_DENY = 0,
	PRI_RESP_FAIL = 1,
	PRI_RESP_SUCC = 2,
};

enum iommu_fault_reason {
	IOMMU_FAULT_REASON_UNKNOWN = 0,
	IOMMU_FAULT_REASON_PASID_FETCH = 1,
	IOMMU_FAULT_REASON_BAD_PASID_ENTRY = 2,
	IOMMU_FAULT_REASON_PASID_INVALID = 3,
	IOMMU_FAULT_REASON_WALK_EABT = 4,
	IOMMU_FAULT_REASON_PTE_FETCH = 5,
	IOMMU_FAULT_REASON_PERMISSION = 6,
	IOMMU_FAULT_REASON_ACCESS = 7,
	IOMMU_FAULT_REASON_OOR_ADDRESS = 8,
};

enum arm_smmu_msi_index {
	EVTQ_MSI_INDEX = 0,
	GERROR_MSI_INDEX = 1,
	PRIQ_MSI_INDEX = 2,
	ARM_SMMU_MAX_MSIS = 3,
};

struct arm_smmu_l1_ctx_desc;

struct arm_smmu_ctx_desc_cfg {
	__le64 *cdtab;
	dma_addr_t cdtab_dma;
	struct arm_smmu_l1_ctx_desc *l1_desc;
	unsigned int num_l1_ents;
	u8 s1fmt;
	u8 s1cdmax;
	u8 stall_enabled: 1;
};

struct arm_smmu_device___2;

struct arm_smmu_domain___2;

struct arm_smmu_stream;

struct arm_smmu_master {
	struct arm_smmu_device___2 *smmu;
	struct device *dev;
	struct arm_smmu_domain___2 *domain;
	struct list_head domain_head;
	struct arm_smmu_stream *streams;
	struct arm_smmu_ctx_desc_cfg cd_table;
	unsigned int num_streams;
	bool ats_enabled;
	bool stall_enabled;
	bool sva_enabled;
	bool iopf_enabled;
	struct list_head bonds;
	unsigned int ssid_bits;
};

struct arm_smmu_ll_queue {
	union {
		u64 val;
		struct {
			u32 prod;
			u32 cons;
		};
		struct {
			atomic_t prod;
			atomic_t cons;
		} atomic;
		u8 __pad[64];
	};
	u32 max_n_shift;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_queue {
	struct arm_smmu_ll_queue llq;
	int irq;
	__le64 *base;
	dma_addr_t base_dma;
	u64 q_base;
	size_t ent_dwords;
	u32 *prod_reg;
	u32 *cons_reg;
	long: 64;
};

struct arm_smmu_cmdq {
	struct arm_smmu_queue q;
	atomic_long_t *valid_map;
	atomic_t owner_prod;
	atomic_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct iopf_queue;

struct arm_smmu_evtq {
	struct arm_smmu_queue q;
	struct iopf_queue *iopf;
	u32 max_stalls;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_priq {
	struct arm_smmu_queue q;
};

struct arm_smmu_strtab_l1_desc;

struct arm_smmu_strtab_cfg {
	__le64 *strtab;
	dma_addr_t strtab_dma;
	struct arm_smmu_strtab_l1_desc *l1_desc;
	unsigned int num_l1_ents;
	u64 strtab_base;
	u32 strtab_base_cfg;
};

struct arm_smmu_device___2 {
	struct device *dev;
	void *base;
	void *page1;
	u32 features;
	u32 options;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct arm_smmu_cmdq cmdq;
	struct arm_smmu_evtq evtq;
	struct arm_smmu_priq priq;
	int gerr_irq;
	int combined_irq;
	unsigned long ias;
	unsigned long oas;
	unsigned long pgsize_bitmap;
	unsigned int asid_bits;
	unsigned int vmid_bits;
	struct ida vmid_map;
	unsigned int ssid_bits;
	unsigned int sid_bits;
	struct arm_smmu_strtab_cfg strtab_cfg;
	struct iommu_device iommu;
	struct rb_root streams;
	struct mutex streams_mutex;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_strtab_l1_desc {
	u8 span;
	__le64 *l2ptr;
	dma_addr_t l2ptr_dma;
};

struct arm_smmu_s2_cfg {
	u16 vmid;
	u64 vttbr;
	u64 vtcr;
};

struct arm_smmu_domain___2 {
	struct arm_smmu_device___2 *smmu;
	struct mutex init_mutex;
	struct io_pgtable_ops *pgtbl_ops;
	atomic_t nr_ats_masters;
	enum arm_smmu_domain_stage stage;
	union {
		struct arm_smmu_ctx_desc cd;
		struct arm_smmu_s2_cfg s2_cfg;
	};
	struct iommu_domain domain;
	struct list_head devices;
	spinlock_t devices_lock;
	struct list_head mmu_notifiers;
};

struct arm_smmu_stream {
	u32 id;
	struct arm_smmu_master *master;
	struct rb_node node;
};

struct arm_smmu_l1_ctx_desc {
	__le64 *l2ptr;
	dma_addr_t l2ptr_dma;
};

struct arm_smmu_cmdq_ent {
	u8 opcode;
	bool substream_valid;
	union {
		struct {
			u32 sid;
		} prefetch;
		struct {
			u32 sid;
			u32 ssid;
			union {
				bool leaf;
				u8 span;
			};
		} cfgi;
		struct {
			u8 num;
			u8 scale;
			u16 asid;
			u16 vmid;
			bool leaf;
			u8 ttl;
			u8 tg;
			u64 addr;
		} tlbi;
		struct {
			u32 sid;
			u32 ssid;
			u64 addr;
			u8 size;
			bool global;
		} atc;
		struct {
			u32 sid;
			u32 ssid;
			u16 grpid;
			enum pri_resp resp;
		} pri;
		struct {
			u32 sid;
			u16 stag;
			u8 resp;
		} resume;
		struct {
			u64 msiaddr;
		} sync;
	};
};

struct arm_smmu_cmdq_batch {
	u64 cmds[128];
	int num;
};

struct arm_smmu_queue_poll {
	ktime_t timeout;
	unsigned int delay;
	unsigned int spin_cnt;
	bool wfe;
};

enum pce_status {
	PCE_STATUS_NONE = 0,
	PCE_STATUS_ACQUIRED = 1,
	PCE_STATUS_PREPARED = 2,
	PCE_STATUS_ENABLED = 3,
	PCE_STATUS_ERROR = 4,
};

struct pm_clock_entry {
	struct list_head node;
	char *con_id;
	struct clk *clk;
	enum pce_status status;
	bool enabled_when_prepared;
};

struct pm_clk_notifier_block {
	struct notifier_block nb;
	struct dev_pm_domain *pm_domain;
	char *con_ids[0];
};

struct regmap_mmio_context {
	void *regs;
	unsigned int val_bytes;
	bool big_endian;
	bool attached_clk;
	struct clk *clk;
	void (*reg_write)(struct regmap_mmio_context *, unsigned int, unsigned int);
	unsigned int (*reg_read)(struct regmap_mmio_context *, unsigned int);
};

struct irq_top_t;

struct pmic_irq_data {
	unsigned int num_top;
	unsigned int num_pmic_irqs;
	unsigned short top_int_status_reg;
	bool *enable_hwirq;
	bool *cache_hwirq;
	const struct irq_top_t *pmic_ints;
};

struct irq_top_t {
	int hwirq_base;
	unsigned int num_int_regs;
	unsigned int en_reg;
	unsigned int en_reg_shift;
	unsigned int sta_reg;
	unsigned int sta_reg_shift;
	unsigned int top_offset;
};

struct simple_mfd_data {
	const struct regmap_config *regmap_config;
	const struct mfd_cell *mfd_cell;
	size_t mfd_cell_size;
};

struct megasas_debug_buffer;

struct megasas_debugfs_buffer {
	void *buf;
	u32 len;
};

struct ahci_sg {
	__le32 addr;
	__le32 addr_hi;
	__le32 reserved;
	__le32 flags_size;
};

struct flash_info___3 {
	char *name;
	u64 jedec_id;
	unsigned int nr_pages;
	u16 pagesize;
	u16 pageoffset;
	u16 flags;
};

struct dataflash {
	u8 command[4];
	char name[24];
	unsigned short page_offset;
	unsigned int page_size;
	struct mutex lock;
	struct spi_device *spi;
	struct mtd_info mtd;
};

struct qcom_nandc_props {
	u32 ecc_modes;
	u32 dev_cmd_reg_start;
	bool is_bam;
	bool is_qpic;
	bool qpic_v2;
	bool use_codeword_fixup;
};

enum bam_command_type {
	BAM_WRITE_COMMAND = 0,
	BAM_READ_COMMAND = 1,
};

struct qcom_nand_boot_partition;

struct qcom_nand_host {
	struct qcom_nand_boot_partition *boot_partitions;
	struct nand_chip chip;
	struct list_head node;
	int nr_boot_partitions;
	int cs;
	int cw_size;
	int cw_data;
	int ecc_bytes_hw;
	int spare_bytes;
	int bbm_size;
	int last_command;
	u32 cfg0;
	u32 cfg1;
	u32 cfg0_raw;
	u32 cfg1_raw;
	u32 ecc_buf_cfg;
	u32 ecc_bch_cfg;
	u32 clrflashstatus;
	u32 clrreadstatus;
	u8 status;
	bool codeword_fixup;
	bool use_ecc;
	bool bch_enabled;
};

struct qcom_nand_boot_partition {
	u32 page_offset;
	u32 page_size;
};

struct nandc_regs;

struct bam_transaction;

struct qcom_nand_controller {
	struct device *dev;
	void *base;
	struct clk *core_clk;
	struct clk *aon_clk;
	struct nandc_regs *regs;
	struct bam_transaction *bam_txn;
	const struct qcom_nandc_props *props;
	struct nand_controller controller;
	struct list_head host_list;
	union {
		struct {
			struct dma_chan *tx_chan;
			struct dma_chan *rx_chan;
			struct dma_chan *cmd_chan;
		};
		struct {
			struct dma_chan *chan;
			unsigned int cmd_crci;
			unsigned int data_crci;
		};
	};
	struct list_head desc_list;
	u8 *data_buffer;
	__le32 *reg_read_buf;
	phys_addr_t base_phys;
	dma_addr_t base_dma;
	dma_addr_t reg_read_dma;
	int buf_size;
	int buf_count;
	int buf_start;
	unsigned int max_cwperpage;
	int reg_read_pos;
	u32 cmd1;
	u32 vld;
	bool exec_opwrite;
};

struct nandc_regs {
	__le32 cmd;
	__le32 addr0;
	__le32 addr1;
	__le32 chip_sel;
	__le32 exec;
	__le32 cfg0;
	__le32 cfg1;
	__le32 ecc_bch_cfg;
	__le32 clrflashstatus;
	__le32 clrreadstatus;
	__le32 cmd1;
	__le32 vld;
	__le32 orig_cmd1;
	__le32 orig_vld;
	__le32 ecc_buf_cfg;
	__le32 read_location0;
	__le32 read_location1;
	__le32 read_location2;
	__le32 read_location3;
	__le32 read_location_last0;
	__le32 read_location_last1;
	__le32 read_location_last2;
	__le32 read_location_last3;
	__le32 erased_cw_detect_cfg_clr;
	__le32 erased_cw_detect_cfg_set;
};

struct bam_cmd_element;

struct bam_transaction {
	struct bam_cmd_element *bam_ce;
	struct scatterlist *cmd_sgl;
	struct scatterlist *data_sgl;
	struct dma_async_tx_descriptor *last_data_desc;
	struct dma_async_tx_descriptor *last_cmd_desc;
	struct completion txn_done;
	u32 bam_ce_pos;
	u32 bam_ce_start;
	u32 cmd_sgl_pos;
	u32 cmd_sgl_start;
	u32 tx_sgl_pos;
	u32 tx_sgl_start;
	u32 rx_sgl_pos;
	u32 rx_sgl_start;
	bool wait_second_completion;
};

struct bam_cmd_element {
	__le32 cmd_and_addr;
	__le32 data;
	__le32 mask;
	__le32 reserved;
};

struct desc_info {
	struct dma_async_tx_descriptor *dma_desc;
	struct list_head node;
	union {
		struct scatterlist adm_sgl;
		struct {
			struct scatterlist *bam_sgl;
			int sgl_cnt;
		};
	};
	enum dma_data_direction dir;
};

struct read_stats {
	__le32 flash;
	__le32 buffer;
	__le32 erased_cw;
};

struct qcom_op {
	const struct nand_op_instr *data_instr;
	unsigned int data_instr_idx;
	unsigned int rdy_timeout_ms;
	unsigned int rdy_delay_ns;
	u32 addr1_reg;
	u32 addr2_reg;
	u32 cmd_reg;
	u8 flag;
};

enum xgene_enet_buf_len {
	SIZE_2K = 2048,
	SIZE_4K = 4096,
	SIZE_16K = 16384,
};

struct e1000_option___2 {
	enum {
		enable_option___2 = 0,
		range_option___2 = 1,
		list_option___2 = 2,
	} type;
	const char *name;
	const char *err;
	int def;
	union {
		struct {
			int min;
			int max;
		} r;
		struct {
			int nr;
			struct e1000_opt_list *p;
		} l;
	} arg;
};

struct sh_eth_cpu_data {
	int (*soft_reset)(struct net_device *);
	void (*chip_reset)(struct net_device *);
	void (*set_duplex)(struct net_device *);
	void (*set_rate)(struct net_device *);
	int register_type;
	u32 edtrr_trns;
	u32 eesipr_value;
	u32 ecsr_value;
	u32 ecsipr_value;
	u32 fdr_value;
	u32 fcftr_value;
	u32 tx_check;
	u32 eesr_err_check;
	u32 trscer_err_mask;
	unsigned long irq_flags;
	unsigned int no_psr: 1;
	unsigned int apr: 1;
	unsigned int mpr: 1;
	unsigned int tpauser: 1;
	unsigned int gecmr: 1;
	unsigned int bculr: 1;
	unsigned int tsu: 1;
	unsigned int hw_swap: 1;
	unsigned int nbst: 1;
	unsigned int rpadir: 1;
	unsigned int no_trimd: 1;
	unsigned int no_ade: 1;
	unsigned int no_xdfar: 1;
	unsigned int xdfar_rw: 1;
	unsigned int csmr: 1;
	unsigned int rx_csum: 1;
	unsigned int select_mii: 1;
	unsigned int rmiimode: 1;
	unsigned int rtrate: 1;
	unsigned int magic: 1;
	unsigned int no_tx_cntrs: 1;
	unsigned int cexcr: 1;
	unsigned int dual_port: 1;
};

enum {
	EDSR = 0,
	EDMR = 1,
	EDTRR = 2,
	EDRRR = 3,
	EESR = 4,
	EESIPR = 5,
	TDLAR = 6,
	TDFAR = 7,
	TDFXR = 8,
	TDFFR = 9,
	RDLAR = 10,
	RDFAR = 11,
	RDFXR = 12,
	RDFFR = 13,
	TRSCER = 14,
	RMFCR = 15,
	TFTR = 16,
	FDR = 17,
	RMCR = 18,
	EDOCR = 19,
	TFUCR = 20,
	RFOCR = 21,
	RMIIMODE = 22,
	FCFTR = 23,
	RPADIR = 24,
	TRIMD = 25,
	RBWAR = 26,
	TBRAR = 27,
	ECMR___2 = 28,
	ECSR___2 = 29,
	ECSIPR___2 = 30,
	PIR___2 = 31,
	PSR___2 = 32,
	RDMLR = 33,
	PIPR___2 = 34,
	RFLR___2 = 35,
	IPGR = 36,
	APR = 37,
	MPR___2 = 38,
	PFTCR___2 = 39,
	PFRCR___2 = 40,
	RFCR___2 = 41,
	RFCF = 42,
	TPAUSER = 43,
	TPAUSECR = 44,
	BCFR = 45,
	BCFRR = 46,
	GECMR___2 = 47,
	BCULR = 48,
	MAHR___2 = 49,
	MALR___2 = 50,
	TROCR___2 = 51,
	CDCR = 52,
	LCCR = 53,
	CNDCR = 54,
	CEFCR___2 = 55,
	FRECR___2 = 56,
	TSFRCR___2 = 57,
	TLFRCR___2 = 58,
	CERCR = 59,
	CEECR = 60,
	MAFCR___2 = 61,
	RTRATE = 62,
	CSMR = 63,
	RMII_MII = 64,
	ARSTR = 65,
	TSU_CTRST = 66,
	TSU_FWEN0 = 67,
	TSU_FWEN1 = 68,
	TSU_FCM = 69,
	TSU_BSYSL0 = 70,
	TSU_BSYSL1 = 71,
	TSU_PRISL0 = 72,
	TSU_PRISL1 = 73,
	TSU_FWSL0 = 74,
	TSU_FWSL1 = 75,
	TSU_FWSLC = 76,
	TSU_QTAG0 = 77,
	TSU_QTAG1 = 78,
	TSU_QTAGM0 = 79,
	TSU_QTAGM1 = 80,
	TSU_FWSR = 81,
	TSU_FWINMK = 82,
	TSU_ADQT0 = 83,
	TSU_ADQT1 = 84,
	TSU_VTAG0 = 85,
	TSU_VTAG1 = 86,
	TSU_ADSBSY = 87,
	TSU_TEN = 88,
	TSU_POST1 = 89,
	TSU_POST2 = 90,
	TSU_POST3 = 91,
	TSU_POST4 = 92,
	TSU_ADRH0 = 93,
	TXNLCR0 = 94,
	TXALCR0 = 95,
	RXNLCR0 = 96,
	RXALCR0 = 97,
	FWNLCR0 = 98,
	FWALCR0 = 99,
	TXNLCR1 = 100,
	TXALCR1 = 101,
	RXNLCR1 = 102,
	RXALCR1 = 103,
	FWNLCR1 = 104,
	FWALCR1 = 105,
	SH_ETH_MAX_REGISTER_OFFSET = 106,
};

enum {
	SH_ETH_REG_GIGABIT = 0,
	SH_ETH_REG_FAST_RCAR = 1,
	SH_ETH_REG_FAST_SH4 = 2,
	SH_ETH_REG_FAST_SH3_SH2 = 3,
};

enum ECSR_BIT___2 {
	ECSR_BRCRX = 32,
	ECSR_PSRTO = 16,
	ECSR_LCHNG___2 = 4,
	ECSR_MPD___2 = 2,
	ECSR_ICD___2 = 1,
};

enum ECSIPR_BIT___2 {
	ECSIPR_BRCRXIP = 32,
	ECSIPR_PSRTOIP = 16,
	ECSIPR_LCHNGIP___2 = 4,
	ECSIPR_MPDIP___2 = 2,
	ECSIPR_ICDIP___2 = 1,
};

enum FCFTR_BIT {
	FCFTR_RFF2 = 262144,
	FCFTR_RFF1 = 131072,
	FCFTR_RFF0 = 65536,
	FCFTR_RFD2 = 4,
	FCFTR_RFD1 = 2,
	FCFTR_RFD0 = 1,
};

enum EESR_BIT {
	EESR_TWB1 = 2147483648,
	EESR_TWB = 1073741824,
	EESR_TC1 = 536870912,
	EESR_TUC = 268435456,
	EESR_ROC = 134217728,
	EESR_TABT = 67108864,
	EESR_RABT = 33554432,
	EESR_RFRMER = 16777216,
	EESR_ADE = 8388608,
	EESR_ECI = 4194304,
	EESR_FTC = 2097152,
	EESR_TDE = 1048576,
	EESR_TFE = 524288,
	EESR_FRC = 262144,
	EESR_RDE = 131072,
	EESR_RFE = 65536,
	EESR_CND = 2048,
	EESR_DLC = 1024,
	EESR_CD = 512,
	EESR_TRO = 256,
	EESR_RMAF = 128,
	EESR_CEEF = 64,
	EESR_CELF = 32,
	EESR_RRF = 16,
	EESR_RTLF = 8,
	EESR_RTSF = 4,
	EESR_PRE = 2,
	EESR_CERF = 1,
};

enum TRSCER_BIT {
	TRSCER_CNDCE = 2048,
	TRSCER_DLCCE = 1024,
	TRSCER_CDCE = 512,
	TRSCER_TROCE = 256,
	TRSCER_RMAFCE = 128,
	TRSCER_RRFCE = 16,
	TRSCER_RTLFCE = 8,
	TRSCER_RTSFCE = 4,
	TRSCER_PRECE = 2,
	TRSCER_CERFCE = 1,
};

enum EESIPR_BIT {
	EESIPR_TWB1IP = 2147483648,
	EESIPR_TWBIP = 1073741824,
	EESIPR_TC1IP = 536870912,
	EESIPR_TUCIP = 268435456,
	EESIPR_ROCIP = 134217728,
	EESIPR_TABTIP = 67108864,
	EESIPR_RABTIP = 33554432,
	EESIPR_RFCOFIP = 16777216,
	EESIPR_ADEIP = 8388608,
	EESIPR_ECIIP = 4194304,
	EESIPR_FTCIP = 2097152,
	EESIPR_TDEIP = 1048576,
	EESIPR_TFUFIP = 524288,
	EESIPR_FRIP = 262144,
	EESIPR_RDEIP = 131072,
	EESIPR_RFOFIP = 65536,
	EESIPR_CNDIP = 2048,
	EESIPR_DLCIP = 1024,
	EESIPR_CDIP = 512,
	EESIPR_TROIP = 256,
	EESIPR_RMAFIP = 128,
	EESIPR_CEEFIP = 64,
	EESIPR_CELFIP = 32,
	EESIPR_RRFIP = 16,
	EESIPR_RTLFIP = 8,
	EESIPR_RTSFIP = 4,
	EESIPR_PREIP = 2,
	EESIPR_CERFIP = 1,
};

enum TD_STS_BIT {
	TD_TACT = 2147483648,
	TD_TDLE = 1073741824,
	TD_TFP1 = 536870912,
	TD_TFP0 = 268435456,
	TD_TFE = 134217728,
	TD_TWBI = 67108864,
};

enum ECMR_BIT___2 {
	ECMR_TRCCM___2 = 67108864,
	ECMR_RCSC___2 = 8388608,
	ECMR_DPAD___2 = 2097152,
	ECMR_RZPF___2 = 1048576,
	ECMR_ZPF___2 = 524288,
	ECMR_PFR___2 = 262144,
	ECMR_RXF___2 = 131072,
	ECMR_TXF___2 = 65536,
	ECMR_MCT = 8192,
	ECMR_PRCEF = 4096,
	ECMR_MPDE___2 = 512,
	ECMR_RE___2 = 64,
	ECMR_TE___2 = 32,
	ECMR_RTM = 16,
	ECMR_ILB = 8,
	ECMR_ELB = 4,
	ECMR_DM___2 = 2,
	ECMR_PRM___2 = 1,
};

enum EDMR_BIT {
	EDMR_NBST = 128,
	EDMR_EL = 64,
	EDMR_DL1 = 32,
	EDMR_DL0 = 16,
	EDMR_SRST_GETHER = 3,
	EDMR_SRST_ETHER = 1,
};

enum RMCR_BIT {
	RMCR_RNC = 1,
};

enum TPAUSER_BIT {
	TPAUSER_TPAUSE = 65535,
	TPAUSER_UNLIMITED = 0,
};

enum EDRRR_BIT {
	EDRRR_R = 1,
};

enum RD_STS_BIT {
	RD_RACT = 2147483648,
	RD_RDLE = 1073741824,
	RD_RFP1 = 536870912,
	RD_RFP0 = 268435456,
	RD_RFE = 134217728,
	RD_RFS10 = 512,
	RD_RFS9 = 256,
	RD_RFS8 = 128,
	RD_RFS7 = 64,
	RD_RFS6 = 32,
	RD_RFS5 = 16,
	RD_RFS4 = 8,
	RD_RFS3 = 4,
	RD_RFS2 = 2,
	RD_RFS1 = 1,
};

enum TSU_ADSBSY_BIT {
	TSU_ADSBSY_0 = 1,
};

enum TSU_FWSLC_BIT {
	TSU_FWSLC_POSTENU = 8192,
	TSU_FWSLC_POSTENL = 4096,
	TSU_FWSLC_CAMSEL03 = 128,
	TSU_FWSLC_CAMSEL02 = 64,
	TSU_FWSLC_CAMSEL01 = 32,
	TSU_FWSLC_CAMSEL00 = 16,
	TSU_FWSLC_CAMSEL13 = 8,
	TSU_FWSLC_CAMSEL12 = 4,
	TSU_FWSLC_CAMSEL11 = 2,
	TSU_FWSLC_CAMSEL10 = 1,
};

enum PIR_BIT___2 {
	PIR_MDI___2 = 8,
	PIR_MDO___2 = 4,
	PIR_MMD___2 = 2,
	PIR_MDC___2 = 1,
};

enum RD_LEN_BIT {
	RD_RFL = 65535,
	RD_RBL = 4294901760,
};

enum EDSR_BIT {
	EDSR_ENT = 1,
	EDSR_ENR = 2,
};

enum ARSTR_BIT {
	ARSTR_ARST = 1,
};

enum GECMR_BIT___2 {
	GECMR_10 = 0,
	GECMR_100 = 4,
	GECMR_1000 = 1,
};

struct bb_info {
	void (*set_gate)(void *);
	struct mdiobb_ctrl ctrl;
	void *addr;
};

struct sh_eth_rxdesc;

struct sh_eth_txdesc;

struct sh_eth_private {
	struct platform_device *pdev;
	struct sh_eth_cpu_data *cd;
	const u16 *reg_offset;
	void *addr;
	void *tsu_addr;
	struct clk *clk;
	u32 num_rx_ring;
	u32 num_tx_ring;
	dma_addr_t rx_desc_dma;
	dma_addr_t tx_desc_dma;
	struct sh_eth_rxdesc *rx_ring;
	struct sh_eth_txdesc *tx_ring;
	struct sk_buff **rx_skbuff;
	struct sk_buff **tx_skbuff;
	spinlock_t lock;
	u32 cur_rx;
	u32 dirty_rx;
	u32 cur_tx;
	u32 dirty_tx;
	u32 rx_buf_sz;
	struct napi_struct napi;
	bool irq_enabled;
	u32 phy_id;
	struct mii_bus *mii_bus;
	int link;
	phy_interface_t phy_interface;
	int msg_enable;
	int speed;
	int duplex;
	int port;
	int vlan_num_ids;
	unsigned int no_ether_link: 1;
	unsigned int ether_link_active_low: 1;
	unsigned int is_opened: 1;
	unsigned int wol_enabled: 1;
};

struct sh_eth_rxdesc {
	u32 status;
	u32 len;
	u32 addr;
	u32 pad0;
};

struct sh_eth_txdesc {
	u32 status;
	u32 len;
	u32 addr;
	u32 pad0;
};

struct sh_eth_plat_data {
	int phy;
	int phy_irq;
	phy_interface_t phy_interface;
	void (*set_mdio_gate)(void *);
	unsigned char mac_addr[6];
	unsigned int no_ether_link: 1;
	unsigned int ether_link_active_low: 1;
};

struct tegra_xtal_freq {
	unsigned int freq;
	u8 enable_delay;
	u8 stable_count;
	u8 active_delay;
	u8 xtal_freq_count;
	u16 debounce;
};

struct tegra_phy_soc_config {
	bool utmi_pll_config_in_car_module;
	bool has_hostpc;
	bool requires_usbmode_setup;
	bool requires_extra_tuning_parameters;
	bool requires_pmc_ao_power_up;
};

enum tegra_usb_phy_port_speed {
	TEGRA_USB_PHY_PORT_SPEED_FULL = 0,
	TEGRA_USB_PHY_PORT_SPEED_LOW = 1,
	TEGRA_USB_PHY_PORT_SPEED_HIGH = 2,
};

struct tegra_usb_phy {
	int irq;
	int instance;
	const struct tegra_xtal_freq *freq;
	void *regs;
	void *pad_regs;
	struct clk *clk;
	struct clk *pll_u;
	struct clk *pad_clk;
	struct regulator *vbus;
	struct regmap *pmc_regmap;
	enum usb_dr_mode mode;
	void *config;
	const struct tegra_phy_soc_config *soc_config;
	struct usb_phy *ulpi;
	struct usb_phy u_phy;
	bool is_legacy_phy;
	bool is_ulpi_phy;
	struct gpio_desc *reset_gpio;
	struct reset_control *pad_rst;
	bool wakeup_enabled;
	bool pad_wakeup;
	bool powered_on;
};

struct tegra_utmip_config {
	u8 hssync_start_delay;
	u8 elastic_limit;
	u8 idle_wait_delay;
	u8 term_range_adj;
	bool xcvr_setup_use_fuses;
	u8 xcvr_setup;
	u8 xcvr_lsfslew;
	u8 xcvr_lsrslew;
	u8 xcvr_hsslew;
	u8 hssquelch_level;
	u8 hsdiscon_level;
};

enum dwc2_hsotg_dmamode {
	S3C_HSOTG_DMA_NONE = 0,
	S3C_HSOTG_DMA_ONLY = 1,
	S3C_HSOTG_DMA_DRV = 2,
};

struct dwc2_hsotg_plat {
	enum dwc2_hsotg_dmamode dma;
	unsigned int is_osc: 1;
	int phy_type;
	int (*phy_init)(struct platform_device *, int);
	int (*phy_exit)(struct platform_device *, int);
};

struct riic_irq_desc {
	int res_num;
	irq_handler_t isr;
	char *name;
};

struct riic_dev {
	void *base;
	u8 *buf;
	struct i2c_msg *msg;
	int bytes_left;
	int err;
	int is_last;
	struct completion msg_done;
	struct i2c_adapter adapter;
	struct clk *clk;
};

struct devfreq_cooling_power;

struct devfreq_cooling_device {
	struct thermal_cooling_device *cdev;
	struct thermal_cooling_device_ops cooling_ops;
	struct devfreq *devfreq;
	unsigned long cooling_state;
	u32 *freq_table;
	size_t max_state;
	struct devfreq_cooling_power *power_ops;
	u32 res_util;
	int capped_state;
	struct dev_pm_qos_request req_max_freq;
	struct em_perf_domain *em_pd;
};

struct devfreq_cooling_power {
	int (*get_real_power)(struct devfreq *, u32 *, unsigned long, unsigned long);
};

enum dw_wdt_rmod {
	DW_WDT_RMOD_RESET = 1,
	DW_WDT_RMOD_IRQ = 2,
};

struct dw_wdt_timeout {
	u32 top_val;
	unsigned int sec;
	unsigned int msec;
};

struct dw_wdt {
	void *regs;
	struct clk *clk;
	struct clk *pclk;
	unsigned long rate;
	enum dw_wdt_rmod rmod;
	struct dw_wdt_timeout timeouts[16];
	struct watchdog_device wdd;
	struct reset_control *rst;
	u32 control;
	u32 timeout;
	struct dentry *dbgfs_dir;
};

struct ti_cpufreq_data;

struct ti_cpufreq_soc_data {
	const char * const *reg_names;
	unsigned long (*efuse_xlate)(struct ti_cpufreq_data *, unsigned long);
	unsigned long efuse_fallback;
	unsigned long efuse_offset;
	unsigned long efuse_mask;
	unsigned long efuse_shift;
	unsigned long rev_offset;
	bool multi_regulator;
};

struct ti_cpufreq_data {
	struct device *cpu_dev;
	struct device_node *opp_node;
	struct regmap *syscon;
	const struct ti_cpufreq_soc_data *soc_data;
};

struct uniphier_sd_priv {
	struct tmio_mmc_data tmio_data;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinstate_uhs;
	struct clk *clk;
	struct reset_control *rst;
	struct reset_control *rst_br;
	struct reset_control *rst_hw;
	struct dma_chan *chan;
	enum dma_data_direction dma_dir;
	struct regmap *sdctrl_regmap;
	u32 sdctrl_ch;
	unsigned long clk_rate;
	unsigned long caps;
};

struct xenon_emmc_phy_regs {
	u16 timing_adj;
	u16 func_ctrl;
	u16 pad_ctrl;
	u16 pad_ctrl2;
	u16 dll_ctrl;
	u16 logic_timing_adj;
	u32 dll_update;
	u32 logic_timing_val;
};

enum soc_pad_ctrl_type {
	SOC_PAD_SD = 0,
	SOC_PAD_FIXED_1_8V = 1,
};

enum xenon_phy_type_enum {
	EMMC_5_0_PHY = 0,
	EMMC_5_1_PHY = 1,
	NR_PHY_TYPES = 2,
};

struct soc_pad_ctrl {
	void *reg;
	enum soc_pad_ctrl_type pad_type;
	void (*set_soc_pad)(struct sdhci_host *, unsigned char);
};

struct xenon_emmc_phy_params {
	bool slow_mode;
	u8 znr;
	u8 zpr;
	u8 nr_tun_times;
	u8 tun_step_divider;
	struct soc_pad_ctrl pad_ctrl;
};

struct dmi_memdev_info {
	const char *device;
	const char *bank;
	u64 size;
	u16 handle;
	u8 type;
};

struct platform_mhu_link {
	int irq;
	void *tx_reg;
	void *rx_reg;
};

struct platform_mhu {
	void *base;
	struct platform_mhu_link mlink[3];
	struct mbox_chan chan[3];
	struct mbox_controller mbox;
};

struct fsl_ifc_global;

struct fsl_ifc_runtime;

struct fsl_ifc_ctrl {
	struct device *dev;
	struct fsl_ifc_global *gregs;
	struct fsl_ifc_runtime *rregs;
	int irq;
	int nand_irq;
	spinlock_t lock;
	void *nand;
	int version;
	int banks;
	u32 nand_stat;
	wait_queue_head_t nand_wait;
	bool little_endian;
};

struct fsl_ifc_global {
	__be32 ifc_rev;
	u32 res1[2];
	struct {
		__be32 cspr_ext;
		__be32 cspr;
		u32 res2;
	} cspr_cs[8];
	u32 res3[13];
	struct {
		__be32 amask;
		u32 res4[2];
	} amask_cs[8];
	u32 res5[12];
	struct {
		__be32 csor;
		__be32 csor_ext;
		u32 res6;
	} csor_cs[8];
	u32 res7[12];
	struct {
		__be32 ftim[4];
		u32 res8[8];
	} ftim_cs[8];
	u32 res9[48];
	__be32 rb_stat;
	__be32 rb_map;
	__be32 wb_map;
	__be32 ifc_gcr;
	u32 res10[2];
	__be32 cm_evter_stat;
	u32 res11[2];
	__be32 cm_evter_en;
	u32 res12[2];
	__be32 cm_evter_intr_en;
	u32 res13[2];
	__be32 cm_erattr0;
	__be32 cm_erattr1;
	u32 res14[2];
	__be32 ifc_ccr;
	__be32 ifc_csr;
	__be32 ddr_ccr_low;
};

struct fsl_ifc_nand {
	__be32 ncfgr;
	u32 res1[4];
	__be32 nand_fcr0;
	__be32 nand_fcr1;
	u32 res2[8];
	__be32 row0;
	u32 res3;
	__be32 col0;
	u32 res4;
	__be32 row1;
	u32 res5;
	__be32 col1;
	u32 res6;
	__be32 row2;
	u32 res7;
	__be32 col2;
	u32 res8;
	__be32 row3;
	u32 res9;
	__be32 col3;
	u32 res10[36];
	__be32 nand_fbcr;
	u32 res11;
	__be32 nand_fir0;
	__be32 nand_fir1;
	__be32 nand_fir2;
	u32 res12[16];
	__be32 nand_csel;
	u32 res13;
	__be32 nandseq_strt;
	u32 res14;
	__be32 nand_evter_stat;
	u32 res15;
	__be32 pgrdcmpl_evt_stat;
	u32 res16[2];
	__be32 nand_evter_en;
	u32 res17[2];
	__be32 nand_evter_intr_en;
	__be32 nand_vol_addr_stat;
	u32 res18;
	__be32 nand_erattr0;
	__be32 nand_erattr1;
	u32 res19[16];
	__be32 nand_fsr;
	u32 res20;
	__be32 nand_eccstat[8];
	u32 res21[28];
	__be32 nanndcr;
	u32 res22[2];
	__be32 nand_autoboot_trgr;
	u32 res23;
	__be32 nand_mdr;
	u32 res24[28];
	__be32 nand_dll_lowcfg0;
	__be32 nand_dll_lowcfg1;
	u32 res25;
	__be32 nand_dll_lowstat;
	u32 res26[60];
};

struct fsl_ifc_nor {
	__be32 nor_evter_stat;
	u32 res1[2];
	__be32 nor_evter_en;
	u32 res2[2];
	__be32 nor_evter_intr_en;
	u32 res3[2];
	__be32 nor_erattr0;
	__be32 nor_erattr1;
	__be32 nor_erattr2;
	u32 res4[4];
	__be32 norcr;
	u32 res5[239];
};

struct fsl_ifc_gpcm {
	__be32 gpcm_evter_stat;
	u32 res1[2];
	__be32 gpcm_evter_en;
	u32 res2[2];
	__be32 gpcm_evter_intr_en;
	u32 res3[2];
	__be32 gpcm_erattr0;
	__be32 gpcm_erattr1;
	__be32 gpcm_erattr2;
	__be32 gpcm_stat;
};

struct fsl_ifc_runtime {
	struct fsl_ifc_nand ifc_nand;
	struct fsl_ifc_nor ifc_nor;
	struct fsl_ifc_gpcm ifc_gpcm;
};

struct hisi_pa_pmu_int_regs {
	u32 mask_offset;
	u32 clear_offset;
	u32 status_offset;
};

struct snd_monitor_file {
	struct file *file;
	const struct file_operations *disconnected_f_op;
	struct list_head shutdown_list;
	struct list_head list;
};

struct action_ops {
	int (*pre_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	int (*do_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	void (*undo_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	void (*post_action)(struct snd_pcm_substream *, snd_pcm_state_t);
};

enum {
	SNDRV_TIMER_EVENT_RESOLUTION = 0,
	SNDRV_TIMER_EVENT_TICK = 1,
	SNDRV_TIMER_EVENT_START = 2,
	SNDRV_TIMER_EVENT_STOP = 3,
	SNDRV_TIMER_EVENT_CONTINUE = 4,
	SNDRV_TIMER_EVENT_PAUSE = 5,
	SNDRV_TIMER_EVENT_EARLY = 6,
	SNDRV_TIMER_EVENT_SUSPEND = 7,
	SNDRV_TIMER_EVENT_RESUME = 8,
	SNDRV_TIMER_EVENT_MSTART = 12,
	SNDRV_TIMER_EVENT_MSTOP = 13,
	SNDRV_TIMER_EVENT_MCONTINUE = 14,
	SNDRV_TIMER_EVENT_MPAUSE = 15,
	SNDRV_TIMER_EVENT_MSUSPEND = 17,
	SNDRV_TIMER_EVENT_MRESUME = 18,
};

enum {
	SNDRV_PCM_IOCTL_HW_REFINE32 = 3260825872,
	SNDRV_PCM_IOCTL_HW_PARAMS32 = 3260825873,
	SNDRV_PCM_IOCTL_SW_PARAMS32 = 3228057875,
	SNDRV_PCM_IOCTL_STATUS_COMPAT32 = 2154578208,
	SNDRV_PCM_IOCTL_STATUS_EXT_COMPAT32 = 3228320036,
	SNDRV_PCM_IOCTL_DELAY32 = 2147762465,
	SNDRV_PCM_IOCTL_CHANNEL_INFO32 = 2148548914,
	SNDRV_PCM_IOCTL_REWIND32 = 1074020678,
	SNDRV_PCM_IOCTL_FORWARD32 = 1074020681,
	SNDRV_PCM_IOCTL_WRITEI_FRAMES32 = 1074544976,
	SNDRV_PCM_IOCTL_READI_FRAMES32 = 2148286801,
	SNDRV_PCM_IOCTL_WRITEN_FRAMES32 = 1074544978,
	SNDRV_PCM_IOCTL_READN_FRAMES32 = 2148286803,
	SNDRV_PCM_IOCTL_STATUS_COMPAT64 = 2155888928,
	SNDRV_PCM_IOCTL_STATUS_EXT_COMPAT64 = 3229630756,
};

enum {
	SNDRV_PCM_MMAP_OFFSET_DATA = 0,
	SNDRV_PCM_MMAP_OFFSET_STATUS_OLD = 2147483648,
	SNDRV_PCM_MMAP_OFFSET_CONTROL_OLD = 2164260864,
	SNDRV_PCM_MMAP_OFFSET_STATUS_NEW = 2181038080,
	SNDRV_PCM_MMAP_OFFSET_CONTROL_NEW = 2197815296,
	SNDRV_PCM_MMAP_OFFSET_STATUS = 2181038080,
	SNDRV_PCM_MMAP_OFFSET_CONTROL = 2197815296,
};

typedef char __pad_before_u32[0];

struct __snd_pcm_mmap_control64_buggy {
	__pad_before_u32 __pad1;
	__u32 appl_ptr;
	__pad_before_u32 __pad2;
	__pad_before_u32 __pad3;
	__u32 avail_min;
	__pad_after_uframe __pad4;
};

struct snd_pcm_hw_params_old {
	unsigned int flags;
	unsigned int masks[3];
	struct snd_interval intervals[12];
	unsigned int rmask;
	unsigned int cmask;
	unsigned int info;
	unsigned int msbits;
	unsigned int rate_num;
	unsigned int rate_den;
	snd_pcm_uframes_t fifo_size;
	unsigned char reserved[64];
};

struct snd_pcm_file {
	struct snd_pcm_substream *substream;
	int no_compat_mmap;
	unsigned int user_pversion;
};

struct snd_pcm_sw_params {
	int tstamp_mode;
	unsigned int period_step;
	unsigned int sleep_min;
	snd_pcm_uframes_t avail_min;
	snd_pcm_uframes_t xfer_align;
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold;
	snd_pcm_uframes_t silence_size;
	snd_pcm_uframes_t boundary;
	unsigned int proto;
	unsigned int tstamp_type;
	unsigned char reserved[56];
};

struct snd_pcm_status32 {
	snd_pcm_state_t state;
	s32 trigger_tstamp_sec;
	s32 trigger_tstamp_nsec;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	u32 appl_ptr;
	u32 hw_ptr;
	s32 delay;
	u32 avail;
	u32 avail_max;
	u32 overrange;
	snd_pcm_state_t suspended_state;
	u32 audio_tstamp_data;
	s32 audio_tstamp_sec;
	s32 audio_tstamp_nsec;
	s32 driver_tstamp_sec;
	s32 driver_tstamp_nsec;
	u32 audio_tstamp_accuracy;
	unsigned char reserved[36];
};

struct snd_pcm_mmap_status32 {
	snd_pcm_state_t state;
	s32 pad1;
	u32 hw_ptr;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	snd_pcm_state_t suspended_state;
	s32 audio_tstamp_sec;
	s32 audio_tstamp_nsec;
};

struct snd_pcm_mmap_control32 {
	u32 appl_ptr;
	u32 avail_min;
};

struct snd_pcm_sync_ptr32 {
	u32 flags;
	union {
		struct snd_pcm_mmap_status32 status;
		unsigned char reserved[64];
	} s;
	union {
		struct snd_pcm_mmap_control32 control;
		unsigned char reserved[64];
	} c;
};

struct snd_pcm_sync_ptr {
	__u32 flags;
	__u32 pad1;
	union {
		struct snd_pcm_mmap_status status;
		unsigned char reserved[64];
	} s;
	union {
		struct snd_pcm_mmap_control control;
		unsigned char reserved[64];
	} c;
};

struct snd_xferi {
	snd_pcm_sframes_t result;
	void __attribute__((btf_type_tag("user"))) *buf;
	snd_pcm_uframes_t frames;
};

struct snd_xfern {
	snd_pcm_sframes_t result;
	void __attribute__((btf_type_tag("user"))) * __attribute__((btf_type_tag("user"))) *bufs;
	snd_pcm_uframes_t frames;
};

struct snd_pcm_hw_params32 {
	u32 flags;
	struct snd_mask masks[3];
	struct snd_mask mres[5];
	struct snd_interval intervals[12];
	struct snd_interval ires[9];
	u32 rmask;
	u32 cmask;
	u32 info;
	u32 msbits;
	u32 rate_num;
	u32 rate_den;
	u32 fifo_size;
	unsigned char reserved[64];
};

struct snd_pcm_sw_params32 {
	s32 tstamp_mode;
	u32 period_step;
	u32 sleep_min;
	u32 avail_min;
	u32 xfer_align;
	u32 start_threshold;
	u32 stop_threshold;
	u32 silence_threshold;
	u32 silence_size;
	u32 boundary;
	u32 proto;
	u32 tstamp_type;
	unsigned char reserved[56];
};

struct snd_pcm_channel_info32 {
	u32 channel;
	u32 offset;
	u32 first;
	u32 step;
};

struct snd_xferi32 {
	s32 result;
	u32 buf;
	u32 frames;
};

struct snd_xfern32 {
	s32 result;
	u32 bufs;
	u32 frames;
};

struct compat_snd_pcm_status64 {
	snd_pcm_state_t state;
	u8 rsvd[4];
	s64 trigger_tstamp_sec;
	s64 trigger_tstamp_nsec;
	s64 tstamp_sec;
	s64 tstamp_nsec;
	u32 appl_ptr;
	u32 hw_ptr;
	s32 delay;
	u32 avail;
	u32 avail_max;
	u32 overrange;
	snd_pcm_state_t suspended_state;
	u32 audio_tstamp_data;
	s64 audio_tstamp_sec;
	s64 audio_tstamp_nsec;
	s64 driver_tstamp_sec;
	s64 driver_tstamp_nsec;
	u32 audio_tstamp_accuracy;
	unsigned char reserved[20];
};

struct net_test {
	char name[32];
	int (*fn)(struct net_device *);
};

struct netsfhdr {
	__be32 version;
	__be64 magic;
	u8 id;
} __attribute__((packed));

struct net_packet_attrs {
	const unsigned char *src;
	const unsigned char *dst;
	u32 ip_src;
	u32 ip_dst;
	bool tcp;
	u16 sport;
	u16 dport;
	int timeout;
	int size;
	int max_size;
	u8 id;
	u16 queue_mapping;
};

struct net_test_priv {
	struct net_packet_attrs *packet;
	struct packet_type pt;
	struct completion comp;
	int double_vlan;
	int vlan_id;
	int ok;
};

enum {
	ETHTOOL_A_RSS_UNSPEC = 0,
	ETHTOOL_A_RSS_HEADER = 1,
	ETHTOOL_A_RSS_CONTEXT = 2,
	ETHTOOL_A_RSS_HFUNC = 3,
	ETHTOOL_A_RSS_INDIR = 4,
	ETHTOOL_A_RSS_HKEY = 5,
	__ETHTOOL_A_RSS_CNT = 6,
	ETHTOOL_A_RSS_MAX = 5,
};

struct rss_req_info {
	struct ethnl_req_info base;
	u32 rss_context;
};

struct rss_reply_data {
	struct ethnl_reply_data base;
	u32 indir_size;
	u32 hkey_size;
	u32 hfunc;
	u32 *indir_table;
	u8 *hkey;
};

struct nf_conntrack_zone {
	u16 id;
	u8 flags;
	u8 dir;
};

struct nfnl_ct_hook {
	size_t (*build_size)(const struct nf_conn *);
	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
	int (*parse)(const struct nlattr *, struct nf_conn *);
	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
};

struct nf_ct_hook {
	int (*update)(struct net *, struct sk_buff *);
	void (*destroy)(struct nf_conntrack *);
	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
	void (*attach)(struct sk_buff *, const struct sk_buff *);
	void (*set_closing)(struct nf_conntrack *);
};

enum nf_nat_manip_type;

struct nf_nat_hook {
	int (*parse_nat_setup)(struct nf_conn *, enum nf_nat_manip_type, const struct nlattr *);
	void (*decode_session)(struct sk_buff *, struct flowi *);
	unsigned int (*manip_pkt)(struct sk_buff *, struct nf_conn *, enum nf_nat_manip_type, enum ip_conntrack_dir);
	void (*remove_nat_bysrc)(struct nf_conn *);
};

struct nf_hook_entries_rcu_head {
	struct callback_head head;
	void *allocation;
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

typedef u32 inet6_ehashfn_t(const struct net *, const struct in6_addr *, const u16, const struct in6_addr *, const __be16);

typedef void (*btf_trace_rpcgss_import_ctx)(void *, int);

typedef void (*btf_trace_rpcgss_get_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_verify_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_wrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_unwrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_ctx_init)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_ctx_destroy)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_svc_wrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_unwrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_get_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_wrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_svc_unwrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_svc_seqno_bad)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_accept_upcall)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_authenticate)(void *, const struct svc_rqst *, const struct rpc_gss_wire_cred *);

typedef void (*btf_trace_rpcgss_unwrap_failed)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_bad_seqno)(void *, const struct rpc_task *, u32, u32);

typedef void (*btf_trace_rpcgss_seqno)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_need_reencode)(void *, const struct rpc_task *, u32, bool);

typedef void (*btf_trace_rpcgss_update_slack)(void *, const struct rpc_task *, const struct rpc_auth *);

typedef void (*btf_trace_rpcgss_svc_seqno_large)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_seen)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_low)(void *, const struct svc_rqst *, u32, u32, u32);

typedef void (*btf_trace_rpcgss_upcall_msg)(void *, const char *);

typedef void (*btf_trace_rpcgss_upcall_result)(void *, u32, int);

typedef void (*btf_trace_rpcgss_context)(void *, u32, unsigned long, unsigned long, unsigned int, unsigned int, const u8 *);

typedef void (*btf_trace_rpcgss_createauth)(void *, unsigned int, int);

typedef void (*btf_trace_rpcgss_oid_to_mech)(void *, const char *);

struct trace_event_raw_rpcgss_import_ctx {
	struct trace_entry ent;
	int status;
	char __data[0];
};

struct trace_event_raw_rpcgss_gssapi_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 maj_stat;
	char __data[0];
};

struct trace_event_raw_rpcgss_ctx_class {
	struct trace_entry ent;
	const void *cred;
	unsigned long service;
	u32 __data_loc_principal;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_gssapi_class {
	struct trace_entry ent;
	u32 xid;
	u32 maj_stat;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_wrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_unwrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_bad {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_accept_upcall {
	struct trace_entry ent;
	u32 minor_status;
	unsigned long major_status;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_authenticate {
	struct trace_entry ent;
	u32 seqno;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_unwrap_failed {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpcgss_bad_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 expected;
	u32 received;
	char __data[0];
};

struct trace_event_raw_rpcgss_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_need_reencode {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seq_xmit;
	u32 seqno;
	bool ret;
	char __data[0];
};

struct trace_event_raw_rpcgss_update_slack {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	const void *auth;
	unsigned int rslack;
	unsigned int ralign;
	unsigned int verfsize;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_class {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_low {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_result {
	struct trace_entry ent;
	u32 uid;
	int result;
	char __data[0];
};

struct trace_event_raw_rpcgss_context {
	struct trace_entry ent;
	unsigned long expiry;
	unsigned long now;
	unsigned int timeout;
	u32 window_size;
	int len;
	u32 __data_loc_acceptor;
	char __data[0];
};

struct trace_event_raw_rpcgss_createauth {
	struct trace_entry ent;
	unsigned int flavor;
	int error;
	char __data[0];
};

struct trace_event_raw_rpcgss_oid_to_mech {
	struct trace_entry ent;
	u32 __data_loc_oid;
	char __data[0];
};

struct trace_event_data_offsets_rpcgss_ctx_class {
	u32 principal;
};

struct trace_event_data_offsets_rpcgss_svc_gssapi_class {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_wrap_failed {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_unwrap_failed {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_seqno_bad {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_accept_upcall {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_authenticate {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_upcall_msg {
	u32 msg;
};

struct trace_event_data_offsets_rpcgss_context {
	u32 acceptor;
};

struct trace_event_data_offsets_rpcgss_oid_to_mech {
	u32 oid;
};

struct trace_event_data_offsets_rpcgss_gssapi_event {};

struct trace_event_data_offsets_rpcgss_import_ctx {};

struct trace_event_data_offsets_rpcgss_unwrap_failed {};

struct trace_event_data_offsets_rpcgss_bad_seqno {};

struct trace_event_data_offsets_rpcgss_seqno {};

struct trace_event_data_offsets_rpcgss_need_reencode {};

struct trace_event_data_offsets_rpcgss_update_slack {};

struct trace_event_data_offsets_rpcgss_svc_seqno_class {};

struct trace_event_data_offsets_rpcgss_svc_seqno_low {};

struct trace_event_data_offsets_rpcgss_upcall_result {};

struct trace_event_data_offsets_rpcgss_createauth {};

struct radix_tree_preload {
	local_lock_t lock;
	unsigned int nr;
	struct xa_node *nodes;
};

struct cpu_suspend_ctx {
	u64 ctx_regs[13];
	u64 sp;
};

struct sleep_stack_data {
	struct cpu_suspend_ctx system_regs;
	unsigned long callee_saved_regs[12];
};

struct acpi_pci_generic_root_info {
	struct acpi_pci_root_info common;
	struct pci_config_window *cfg;
};

union trap_config {
	u64 val;
	struct {
		unsigned long cgt: 10;
		unsigned long fgt: 4;
		unsigned long bit: 6;
		unsigned long pol: 1;
		unsigned long fgf: 5;
		unsigned long unused: 37;
		unsigned long mbz: 1;
	};
};

struct encoding_to_trap_config {
	const u32 encoding;
	const u32 end;
	const union trap_config tc;
	const unsigned int line;
};

enum cgt_group_id {
	__RESERVED__ = 0,
	CGT_HCR_TID1 = 1,
	CGT_HCR_TID2 = 2,
	CGT_HCR_TID3 = 3,
	CGT_HCR_IMO = 4,
	CGT_HCR_FMO = 5,
	CGT_HCR_TIDCP = 6,
	CGT_HCR_TACR = 7,
	CGT_HCR_TSW = 8,
	CGT_HCR_TPC = 9,
	CGT_HCR_TPU = 10,
	CGT_HCR_TTLB = 11,
	CGT_HCR_TVM = 12,
	CGT_HCR_TDZ = 13,
	CGT_HCR_TRVM = 14,
	CGT_HCR_TLOR = 15,
	CGT_HCR_TERR = 16,
	CGT_HCR_APK = 17,
	CGT_HCR_NV = 18,
	CGT_HCR_NV_nNV2 = 19,
	CGT_HCR_NV1_nNV2 = 20,
	CGT_HCR_AT = 21,
	CGT_HCR_nFIEN = 22,
	CGT_HCR_TID4 = 23,
	CGT_HCR_TICAB = 24,
	CGT_HCR_TOCU = 25,
	CGT_HCR_ENSCXT = 26,
	CGT_HCR_TTLBIS = 27,
	CGT_HCR_TTLBOS = 28,
	CGT_MDCR_TPMCR = 29,
	CGT_MDCR_TPM = 30,
	CGT_MDCR_TDE = 31,
	CGT_MDCR_TDA = 32,
	CGT_MDCR_TDOSA = 33,
	CGT_MDCR_TDRA = 34,
	CGT_MDCR_E2PB = 35,
	CGT_MDCR_TPMS = 36,
	CGT_MDCR_TTRF = 37,
	CGT_MDCR_E2TB = 38,
	CGT_MDCR_TDCC = 39,
	__MULTIPLE_CONTROL_BITS__ = 40,
	CGT_HCR_IMO_FMO = 40,
	CGT_HCR_TID2_TID4 = 41,
	CGT_HCR_TTLB_TTLBIS = 42,
	CGT_HCR_TTLB_TTLBOS = 43,
	CGT_HCR_TVM_TRVM = 44,
	CGT_HCR_TPU_TICAB = 45,
	CGT_HCR_TPU_TOCU = 46,
	CGT_HCR_NV1_nNV2_ENSCXT = 47,
	CGT_MDCR_TPM_TPMCR = 48,
	CGT_MDCR_TDE_TDA = 49,
	CGT_MDCR_TDE_TDOSA = 50,
	CGT_MDCR_TDE_TDRA = 51,
	CGT_MDCR_TDCC_TDE_TDA = 52,
	__COMPLEX_CONDITIONS__ = 53,
	CGT_CNTHCTL_EL1PCTEN = 53,
	CGT_CNTHCTL_EL1PTEN = 54,
	__NR_CGT_GROUP_IDS__ = 55,
};

enum trap_behaviour {
	BEHAVE_HANDLE_LOCALLY = 0,
	BEHAVE_FORWARD_READ = 1,
	BEHAVE_FORWARD_WRITE = 2,
	BEHAVE_FORWARD_ANY = 3,
};

struct trap_bits {
	const enum vcpu_sysreg index;
	const enum trap_behaviour behaviour;
	const u64 value;
	const u64 mask;
};

typedef enum trap_behaviour (*complex_condition_check)(struct kvm_vcpu___2 *);

enum fgt_group_id {
	__NO_FGT_GROUP__ = 0,
	HFGxTR_GROUP = 1,
	HDFGRTR_GROUP = 2,
	HDFGWTR_GROUP = 3,
	HFGITR_GROUP = 4,
	__NR_FGT_GROUP_IDS__ = 5,
};

enum fg_filter_id {
	__NO_FGF__ = 0,
	HCRX_FGTnXS = 1,
	__NR_FG_FILTER_IDS__ = 2,
};

typedef bool (*exit_handler_fn)(struct kvm_vcpu___2 *, u64 *);

struct timer_map___2 {
	struct arch_timer_context___2 *direct_vtimer;
	struct arch_timer_context___2 *direct_ptimer;
	struct arch_timer_context___2 *emul_vtimer;
	struct arch_timer_context___2 *emul_ptimer;
};

struct kvm_exception_table_entry {
	int insn;
	int fixup;
};

struct stage2_map_data___2 {
	const u64 phys;
	kvm_pte_t attr;
	u8 owner_id;
	kvm_pte_t *anchor;
	kvm_pte_t *childp;
	struct kvm_s2_mmu *mmu;
	void *memcache;
	bool force_pte;
};

typedef void (*btf_trace_notifier_register)(void *, void *);

typedef void (*btf_trace_notifier_unregister)(void *, void *);

typedef void (*btf_trace_notifier_run)(void *, void *);

struct trace_event_raw_notifier_info {
	struct trace_entry ent;
	void *cb;
	char __data[0];
};

struct trace_event_data_offsets_notifier_info {};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long err;
	int trapnr;
	int signr;
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

struct old_itimerval32 {
	struct old_timeval32 it_interval;
	struct old_timeval32 it_value;
};

struct audit_parent {
	struct list_head watches;
	struct fsnotify_mark mark;
};

struct audit_watch {
	refcount_t count;
	dev_t dev;
	char *path;
	unsigned long ino;
	struct audit_parent *parent;
	struct list_head wlist;
	struct list_head rules;
};

struct ustring_buffer {
	char buffer[1024];
};

enum filter_pred_fn {
	FILTER_PRED_FN_NOP = 0,
	FILTER_PRED_FN_64 = 1,
	FILTER_PRED_FN_64_CPUMASK = 2,
	FILTER_PRED_FN_S64 = 3,
	FILTER_PRED_FN_U64 = 4,
	FILTER_PRED_FN_32 = 5,
	FILTER_PRED_FN_32_CPUMASK = 6,
	FILTER_PRED_FN_S32 = 7,
	FILTER_PRED_FN_U32 = 8,
	FILTER_PRED_FN_16 = 9,
	FILTER_PRED_FN_16_CPUMASK = 10,
	FILTER_PRED_FN_S16 = 11,
	FILTER_PRED_FN_U16 = 12,
	FILTER_PRED_FN_8 = 13,
	FILTER_PRED_FN_8_CPUMASK = 14,
	FILTER_PRED_FN_S8 = 15,
	FILTER_PRED_FN_U8 = 16,
	FILTER_PRED_FN_COMM = 17,
	FILTER_PRED_FN_STRING = 18,
	FILTER_PRED_FN_STRLOC = 19,
	FILTER_PRED_FN_STRRELLOC = 20,
	FILTER_PRED_FN_PCHAR_USER = 21,
	FILTER_PRED_FN_PCHAR = 22,
	FILTER_PRED_FN_CPU = 23,
	FILTER_PRED_FN_CPU_CPUMASK = 24,
	FILTER_PRED_FN_CPUMASK = 25,
	FILTER_PRED_FN_CPUMASK_CPU = 26,
	FILTER_PRED_FN_FUNCTION = 27,
	FILTER_PRED_FN_ = 28,
	FILTER_PRED_TEST_VISITED = 29,
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum {
	TOO_MANY_CLOSE = -1,
	TOO_MANY_OPEN = -2,
	MISSING_QUOTE = -3,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_MISSING_BRACE_OPEN = 5,
	FILT_ERR_MISSING_BRACE_CLOSE = 6,
	FILT_ERR_OPERAND_TOO_LONG = 7,
	FILT_ERR_EXPECT_STRING = 8,
	FILT_ERR_EXPECT_DIGIT = 9,
	FILT_ERR_ILLEGAL_FIELD_OP = 10,
	FILT_ERR_FIELD_NOT_FOUND = 11,
	FILT_ERR_ILLEGAL_INTVAL = 12,
	FILT_ERR_BAD_SUBSYS_FILTER = 13,
	FILT_ERR_TOO_MANY_PREDS = 14,
	FILT_ERR_INVALID_FILTER = 15,
	FILT_ERR_INVALID_CPULIST = 16,
	FILT_ERR_IP_FIELD_ONLY = 17,
	FILT_ERR_INVALID_VALUE = 18,
	FILT_ERR_NO_FUNCTION = 19,
	FILT_ERR_ERRNO = 20,
	FILT_ERR_NO_FILTER = 21,
};

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

struct regex;

struct filter_pred {
	struct regex *regex;
	struct cpumask *mask;
	unsigned short *ops;
	struct ftrace_event_field *field;
	u64 val;
	u64 val2;
	enum filter_pred_fn fn_num;
	int offset;
	int not;
	int op;
};

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

struct function_filter_data {
	struct ftrace_ops *ops;
	int first_filter;
	int first_notrace;
};

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

enum {
	BPF_TASK_ITER_ALL_PROCS = 0,
	BPF_TASK_ITER_ALL_THREADS = 1,
	BPF_TASK_ITER_PROC_THREADS = 2,
};

enum bpf_task_vma_iter_find_op {
	task_vma_iter_first_vma = 0,
	task_vma_iter_next_vma = 1,
	task_vma_iter_find_vma = 2,
};

typedef u64 (*btf_bpf_find_vma)(struct task_struct *, u64, bpf_callback_t, void *, u64);

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
	enum bpf_iter_task_type type;
	u32 pid;
	u32 pid_visiting;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	union {
		struct file *file;
	};
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	u32 tid;
	u32 fd;
};

struct bpf_iter__task_vma {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	union {
		struct vm_area_struct *vma;
	};
};

struct bpf_iter_seq_task_vma_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	u32 tid;
	unsigned long prev_vm_start;
	unsigned long prev_vm_end;
};

struct bpf_iter_task_vma {
	__u64 __opaque[1];
};

struct bpf_iter_task_vma_kern_data;

struct bpf_iter_task_vma_kern {
	struct bpf_iter_task_vma_kern_data *data;
};

struct bpf_iter_task_vma_kern_data {
	struct task_struct *task;
	struct mm_struct *mm;
	struct mmap_unlock_irq_work *work;
	struct vma_iterator vmi;
};

struct bpf_iter_css_task {
	__u64 __opaque[1];
};

struct bpf_iter_css_task_kern {
	struct css_task_iter *css_it;
};

struct bpf_iter_task {
	__u64 __opaque[3];
};

struct bpf_iter_task_kern {
	struct task_struct *task;
	struct task_struct *pos;
	unsigned int flags;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

enum {
	BPF_F_BPRM_SECUREEXEC = 1,
};

typedef u64 (*btf_bpf_bprm_opts_set)(struct linux_binprm *, u64);

typedef u64 (*btf_bpf_ima_inode_hash)(struct inode *, void *, u32);

typedef u64 (*btf_bpf_ima_file_hash)(struct file *, void *, u32);

typedef u64 (*btf_bpf_get_attach_cookie)(void *);

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct memory_failure_entry {
	unsigned long pfn;
	int flags;
};

struct memory_failure_cpu {
	struct {
		union {
			struct __kfifo kfifo;
			struct memory_failure_entry *type;
			const struct memory_failure_entry *const_type;
			char (*rectype)[0];
			struct memory_failure_entry *ptr;
			const struct memory_failure_entry *ptr_const;
		};
		struct memory_failure_entry buf[16];
	} fifo;
	spinlock_t lock;
	struct work_struct work;
};

enum mf_action_page_type {
	MF_MSG_KERNEL = 0,
	MF_MSG_KERNEL_HIGH_ORDER = 1,
	MF_MSG_SLAB = 2,
	MF_MSG_DIFFERENT_COMPOUND = 3,
	MF_MSG_HUGE = 4,
	MF_MSG_FREE_HUGE = 5,
	MF_MSG_UNMAP_FAILED = 6,
	MF_MSG_DIRTY_SWAPCACHE = 7,
	MF_MSG_CLEAN_SWAPCACHE = 8,
	MF_MSG_DIRTY_MLOCKED_LRU = 9,
	MF_MSG_CLEAN_MLOCKED_LRU = 10,
	MF_MSG_DIRTY_UNEVICTABLE_LRU = 11,
	MF_MSG_CLEAN_UNEVICTABLE_LRU = 12,
	MF_MSG_DIRTY_LRU = 13,
	MF_MSG_CLEAN_LRU = 14,
	MF_MSG_TRUNCATED_LRU = 15,
	MF_MSG_BUDDY = 16,
	MF_MSG_DAX = 17,
	MF_MSG_UNSPLIT_THP = 18,
	MF_MSG_UNKNOWN = 19,
};

struct page_state {
	unsigned long mask;
	unsigned long res;
	enum mf_action_page_type type;
	int (*action)(struct page_state *, struct page *);
};

enum mf_result {
	MF_IGNORED = 0,
	MF_FAILED = 1,
	MF_DELAYED = 2,
	MF_RECOVERED = 3,
};

struct raw_hwp_page {
	struct llist_node node;
	struct page *page;
};

struct to_kill {
	struct list_head nd;
	struct task_struct *tsk;
	unsigned long addr;
	short size_shift;
};

struct hwpoison_walk {
	struct to_kill tk;
	unsigned long pfn;
	int flags;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	unsigned long c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	unsigned long c_entry_count;
	struct shrinker *c_shrink;
	struct work_struct c_shrink_work;
};

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

struct fat_fid {
	u32 i_gen;
	u32 i_pos_low;
	u16 i_pos_hi;
	u16 parent_i_pos_hi;
	u32 parent_i_pos_low;
	u32 parent_i_gen;
};

enum {
	FILEID_HIGH_OFF = 0,
	FILEID_LOW_OFF = 1,
	FILE_I_TYPE_OFF = 2,
	EMBED_FH_OFF = 3,
};

enum pnfs_notify_deviceid_type4 {
	NOTIFY_DEVICEID4_CHANGE = 2,
	NOTIFY_DEVICEID4_DELETE = 4,
};

struct nfs4_cached_acl {
	enum nfs4_acl_type type;
	int cached;
	size_t len;
	char data[0];
};

struct nfs41_exchange_id_data {
	struct nfs41_exchange_id_res res;
	struct nfs41_exchange_id_args args;
};

struct nfs4_get_lease_time_data {
	struct nfs4_get_lease_time_args *args;
	struct nfs4_get_lease_time_res *res;
	struct nfs_client *clp;
};

struct nfs4_lock_waiter {
	struct inode *inode;
	struct nfs_lowner owner;
	wait_queue_entry_t wait;
};

struct nfs4_call_sync_data {
	const struct nfs_server *seq_server;
	struct nfs4_sequence_args *seq_args;
	struct nfs4_sequence_res *seq_res;
};

struct nfs4_delegreturndata {
	struct nfs4_delegreturnargs args;
	struct nfs4_delegreturnres res;
	struct nfs_fh fh;
	nfs4_stateid stateid;
	unsigned long timestamp;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	int rpc_status;
	struct inode *inode;
};

struct nfs4_lockdata {
	struct nfs_lock_args arg;
	struct nfs_lock_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct file_lock fl;
	unsigned long timestamp;
	int rpc_status;
	int cancelled;
	struct nfs_server *server;
};

struct nfs4_createdata {
	struct rpc_message msg;
	struct nfs4_create_arg arg;
	struct nfs4_create_res res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
};

struct nfs4_unlockdata {
	struct nfs_locku_args arg;
	struct nfs_locku_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct file_lock fl;
	struct nfs_server *server;
	unsigned long timestamp;
};

struct nfs4_open_createattrs {
	struct nfs4_label *label;
	struct iattr *sattr;
	const __u32 verf[2];
};

struct nfs4_closedata {
	struct inode *inode;
	struct nfs4_state *state;
	struct nfs_closeargs arg;
	struct nfs_closeres res;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	unsigned long timestamp;
};

struct rpc_bind_conn_calldata {
	struct nfs_client *clp;
	const struct cred *cred;
};

struct nfs4_sequence_data {
	struct nfs_client *clp;
	struct nfs4_sequence_args args;
	struct nfs4_sequence_res res;
};

struct nfs_release_lockowner_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs_release_lockowner_data {
	struct nfs4_lock_state *lsp;
	struct nfs_server *server;
	struct nfs_release_lockowner_args args;
	struct nfs_release_lockowner_res res;
	unsigned long timestamp;
};

struct nfs4_renewdata {
	struct nfs_client *client;
	unsigned long timestamp;
};

struct nfs_free_stateid_data {
	struct nfs_server *server;
	struct nfs41_free_stateid_args args;
	struct nfs41_free_stateid_res res;
};

struct nfs4_reclaim_complete_data {
	struct nfs_client *clp;
	struct nfs41_reclaim_complete_args arg;
	struct nfs41_reclaim_complete_res res;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

enum {
	Opt_err___10 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

struct blk_rq_stat;

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat __attribute__((btf_type_tag("percpu"))) *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	u64 batch;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	int accounting;
};

struct bsg_set {
	struct blk_mq_tag_set tag_set;
	struct bsg_device *bd;
	bsg_job_fn *job_fn;
	bsg_timeout_fn *timeout_fn;
};

struct io_madvise {
	struct file *file;
	u64 addr;
	u32 len;
	u32 advice;
};

struct io_fadvise {
	struct file *file;
	u64 offset;
	u32 len;
	u32 advice;
};

struct io_waitid {
	struct file *file;
	int which;
	pid_t upid;
	int options;
	atomic_t refs;
	struct wait_queue_head *head;
	struct siginfo __attribute__((btf_type_tag("user"))) *infop;
	struct waitid_info info;
};

struct io_waitid_async {
	struct io_kiocb *req;
	struct wait_opts wo;
};

typedef uintptr_t uptrval;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	unsigned long long table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

struct xz_dec_bcj {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

enum {
	EI_ETYPE_NULL = 0,
	EI_ETYPE_ERRNO = 1,
	EI_ETYPE_ERRNO_NULL = 2,
	EI_ETYPE_TRUE = 3,
};

struct ei_entry {
	struct list_head list;
	unsigned long start_addr;
	unsigned long end_addr;
	int etype;
	void *priv;
};

struct bcm7120_l1_intc_data;

struct bcm7120_l2_intc_data {
	unsigned int n_words;
	void *map_base[8];
	void *pair_base[4];
	int en_offset[4];
	int stat_offset[4];
	struct irq_domain *domain;
	bool can_wake;
	u32 irq_fwd_mask[4];
	struct bcm7120_l1_intc_data *l1_data;
	int num_parent_irqs;
	const __be32 *map_mask_prop;
};

struct bcm7120_l1_intc_data {
	struct bcm7120_l2_intc_data *b;
	u32 irq_map_mask[4];
};

struct ns2_phy_data;

struct ns2_phy_driver {
	void *icfgdrd_regs;
	void *idmdrd_rst_ctrl;
	void *crmu_usb2_ctrl;
	void *usb2h_strap_reg;
	struct ns2_phy_data *data;
	struct extcon_dev *edev;
	struct gpio_desc *vbus_gpiod;
	struct gpio_desc *id_gpiod;
	int id_irq;
	int vbus_irq;
	unsigned long debounce_jiffies;
	struct delayed_work wq_extcon;
};

struct ns2_phy_data {
	struct ns2_phy_driver *driver;
	struct phy *phy;
	int new_state;
};

struct phy_gmii_sel_soc_data {
	u32 num_ports;
	u32 features;
	const struct reg_field (*regfields)[3];
	bool use_of_data;
	u64 extra_modes;
	u32 num_qsgmii_main_ports;
};

enum {
	PHY_GMII_SEL_PORT_MODE = 0,
	PHY_GMII_SEL_RGMII_ID_MODE = 1,
	PHY_GMII_SEL_RMII_IO_CLK_EN = 2,
	PHY_GMII_SEL_LAST = 3,
};

struct phy_gmii_sel_phy_priv;

struct phy_gmii_sel_priv {
	struct device *dev;
	const struct phy_gmii_sel_soc_data *soc_data;
	struct regmap *regmap;
	struct phy_provider *phy_provider;
	struct phy_gmii_sel_phy_priv *if_phys;
	u32 num_ports;
	u32 reg_offset;
	u32 qsgmii_main_ports;
	bool no_offset;
};

struct phy_gmii_sel_phy_priv {
	struct phy_gmii_sel_priv *priv;
	u32 id;
	struct phy *if_phy;
	int rmii_clock_external;
	int phy_if_mode;
	struct regmap_field *fields[3];
};

enum {
	V_ARMADA_7K = 1,
	V_ARMADA_8K_CPM = 2,
	V_ARMADA_8K_CPS = 4,
	V_CP115_STANDALONE = 8,
	V_ARMADA_7K_8K_CPM = 3,
	V_ARMADA_7K_8K_CPS = 5,
};

typedef struct irq_chip * (*gpio_get_irq_chip_cb_t)(unsigned int);

struct davinci_gpio_regs {
	u32 dir;
	u32 out_data;
	u32 set_data;
	u32 clr_data;
	u32 in_data;
	u32 set_rising;
	u32 clr_rising;
	u32 set_falling;
	u32 clr_falling;
	u32 intstat;
};

struct davinci_gpio_controller {
	struct gpio_chip chip;
	struct irq_domain *irq_domain;
	spinlock_t lock;
	void *regs[5];
	int gpio_unbanked;
	int irqs[32];
	struct davinci_gpio_regs context[5];
	u32 binten_context;
};

struct davinci_gpio_irq_data {
	void *regs;
	struct davinci_gpio_controller *chip;
	int bank_num;
};

struct davinci_gpio_platform_data {
	bool no_auto_base;
	u32 base;
	u32 ngpio;
	u32 gpio_unbanked;
};

struct ls_g4_pcie {
	struct mobiveil_pcie pci;
	struct delayed_work dwork;
	int irq;
};

struct acpi_madt_io_apic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 address;
	u32 global_irq_base;
};

struct acpi_madt_interrupt_override {
	struct acpi_subtable_header header;
	u8 bus;
	u8 source_irq;
	u32 global_irq;
	u16 inti_flags;
} __attribute__((packed));

struct acpi_madt_nmi_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 global_irq;
};

struct acpi_madt_local_apic_nmi {
	struct acpi_subtable_header header;
	u8 processor_id;
	u16 inti_flags;
	u8 lint;
} __attribute__((packed));

struct acpi_madt_local_x2apic_nmi {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 uid;
	u8 lint;
	u8 reserved[3];
};

struct acpi_madt_local_apic_override {
	struct acpi_subtable_header header;
	u16 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_madt_io_sapic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 global_irq_base;
	u64 address;
};

struct acpi_madt_interrupt_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u8 type;
	u8 id;
	u8 eid;
	u8 io_sapic_vector;
	u32 global_irq;
	u32 flags;
};

struct acpi_ged_event {
	struct list_head node;
	struct device *dev;
	unsigned int gsi;
	unsigned int irq;
	acpi_handle handle;
};

struct acpi_ged_device {
	struct device *dev;
	struct list_head event_list;
};

struct acpi_signal_fatal_info {
	u32 type;
	u32 code;
	u32 argument;
};

struct acpi_hmat_locality;

struct memory_locality {
	struct list_head node;
	struct acpi_hmat_locality *hmat_loc;
};

struct acpi_hmat_locality {
	struct acpi_hmat_structure header;
	u8 flags;
	u8 data_type;
	u8 min_transfer_size;
	u8 reserved1;
	u32 number_of_initiator_Pds;
	u32 number_of_target_Pds;
	u32 reserved2;
	u64 entry_base_unit;
};

enum acpi_hmat_type {
	ACPI_HMAT_TYPE_PROXIMITY = 0,
	ACPI_HMAT_TYPE_LOCALITY = 1,
	ACPI_HMAT_TYPE_CACHE = 2,
	ACPI_HMAT_TYPE_RESERVED = 3,
};

enum locality_types {
	WRITE_LATENCY = 0,
	READ_LATENCY = 1,
	WRITE_BANDWIDTH = 2,
	READ_BANDWIDTH = 3,
};

struct memory_target {
	struct list_head node;
	unsigned int memory_pxm;
	unsigned int processor_pxm;
	struct resource memregions;
	struct node_hmem_attrs hmem_attrs[2];
	struct list_head caches;
	struct node_cache_attrs cache_attrs;
	bool registered;
};

struct memory_initiator {
	struct list_head node;
	unsigned int processor_pxm;
	bool has_cpu;
};

struct target_cache {
	struct list_head node;
	struct node_cache_attrs cache_attrs;
};

struct acpi_hmat_proximity_domain {
	struct acpi_hmat_structure header;
	u16 flags;
	u16 reserved1;
	u32 processor_PD;
	u32 memory_PD;
	u32 reserved2;
	u64 reserved3;
	u64 reserved4;
};

struct acpi_hmat_cache {
	struct acpi_hmat_structure header;
	u32 memory_PD;
	u32 reserved1;
	u64 cache_size;
	u32 cache_attributes;
	u16 reserved2;
	u16 number_of_SMBIOShandles;
};

struct erst_erange {
	u64 base;
	u64 size;
	void *vaddr;
	u32 attr;
	u64 timings;
};

struct acpi_table_erst {
	struct acpi_table_header header;
	u32 header_length;
	u32 reserved;
	u32 entries;
};

struct erst_record_id_cache {
	struct mutex lock;
	u64 *entries;
	int len;
	int size;
	int refcount;
};

enum acpi_erst_actions {
	ACPI_ERST_BEGIN_WRITE = 0,
	ACPI_ERST_BEGIN_READ = 1,
	ACPI_ERST_BEGIN_CLEAR = 2,
	ACPI_ERST_END = 3,
	ACPI_ERST_SET_RECORD_OFFSET = 4,
	ACPI_ERST_EXECUTE_OPERATION = 5,
	ACPI_ERST_CHECK_BUSY_STATUS = 6,
	ACPI_ERST_GET_COMMAND_STATUS = 7,
	ACPI_ERST_GET_RECORD_ID = 8,
	ACPI_ERST_SET_RECORD_ID = 9,
	ACPI_ERST_GET_RECORD_COUNT = 10,
	ACPI_ERST_BEGIN_DUMMY_WRIITE = 11,
	ACPI_ERST_NOT_USED = 12,
	ACPI_ERST_GET_ERROR_RANGE = 13,
	ACPI_ERST_GET_ERROR_LENGTH = 14,
	ACPI_ERST_GET_ERROR_ATTRIBUTES = 15,
	ACPI_ERST_EXECUTE_TIMINGS = 16,
	ACPI_ERST_ACTION_RESERVED = 17,
};

struct cper_record_header {
	char signature[4];
	u16 revision;
	u32 signature_end;
	u16 section_count;
	u32 error_severity;
	u32 validation_bits;
	u32 record_length;
	u64 timestamp;
	guid_t platform_id;
	guid_t partition_id;
	guid_t creator_id;
	guid_t notification_type;
	u64 record_id;
	u32 flags;
	u64 persistence_information;
	u8 reserved[12];
} __attribute__((packed));

struct cper_section_descriptor {
	u32 section_offset;
	u32 section_length;
	u16 revision;
	u8 validation_bits;
	u8 reserved;
	u32 flags;
	guid_t section_type;
	guid_t fru_id;
	u32 section_severity;
	u8 fru_text[20];
};

struct cper_pstore_record {
	struct cper_record_header hdr;
	struct cper_section_descriptor sec_hdr;
	char data[0];
};

struct clk_frac_pll {
	struct clk_hw hw;
	void *base;
};

struct ti_syscon_gate_clk_data {
	char *name;
	u32 offset;
	u32 bit_idx;
};

struct ti_syscon_gate_clk_priv {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 idx;
};

struct meson_clk_cpu_dyndiv_data {
	struct parm div;
	struct parm dyn;
};

struct clk_cbf_8996_mux {
	u32 reg;
	struct notifier_block nb;
	struct clk_regmap clkr;
};

enum {
	CBF_XO_INDEX = 0,
	CBF_PLL_INDEX = 1,
	CBF_DIV_INDEX = 2,
	CBF_APCS_AUX_INDEX = 3,
};

enum clk_ids___8 {
	LAST_DT_CORE_CLK___8 = 50,
	CLK_EXTAL___8 = 51,
	CLK_EXTALR___8 = 52,
	CLK_MAIN___8 = 53,
	CLK_PLL1___8 = 54,
	CLK_PLL2___5 = 55,
	CLK_PLL3___7 = 56,
	CLK_PLL5___3 = 57,
	CLK_PLL6___2 = 58,
	CLK_PLL1_DIV2___8 = 59,
	CLK_PLL2_DIV2___2 = 60,
	CLK_PLL3_DIV2___2 = 61,
	CLK_PLL5_DIV2___3 = 62,
	CLK_PLL5_DIV4___3 = 63,
	CLK_PLL6_DIV2___2 = 64,
	CLK_S0___6 = 65,
	CLK_SASYNCPER___2 = 66,
	CLK_SDSRC___7 = 67,
	CLK_RPCSRC___7 = 68,
	CLK_OCO___3 = 69,
	MOD_CLK_BASE___8 = 70,
};

enum dfll_ctrl_mode {
	DFLL_UNINITIALIZED = 0,
	DFLL_DISABLED = 1,
	DFLL_OPEN_LOOP = 2,
	DFLL_CLOSED_LOOP = 3,
};

enum dfll_tune_range {
	DFLL_TUNE_UNINITIALIZED = 0,
	DFLL_TUNE_LOW = 1,
};

enum tegra_dfll_pmu_if {
	TEGRA_DFLL_PMU_I2C = 0,
	TEGRA_DFLL_PMU_PWM = 1,
};

struct dfll_rate_req {
	unsigned long rate;
	unsigned long dvco_target_rate;
	int lut_index;
	u8 mult_bits;
	u8 scale_bits;
};

struct tegra_dfll {
	struct device *dev;
	struct tegra_dfll_soc_data *soc;
	void *base;
	void *i2c_base;
	void *i2c_controller_base;
	void *lut_base;
	struct regulator *vdd_reg;
	struct clk *soc_clk;
	struct clk *ref_clk;
	struct clk *i2c_clk;
	struct clk *dfll_clk;
	struct reset_control *dfll_rst;
	struct reset_control *dvco_rst;
	unsigned long ref_rate;
	unsigned long i2c_clk_rate;
	unsigned long dvco_rate_min;
	enum dfll_ctrl_mode mode;
	enum dfll_tune_range tune_range;
	struct dentry *debugfs_dir;
	struct clk_hw dfll_clk_hw;
	const char *output_clock_name;
	struct dfll_rate_req last_req;
	unsigned long last_unrounded_rate;
	u32 droop_ctrl;
	u32 sample_rate;
	u32 force_mode;
	u32 cf;
	u32 ci;
	u32 cg;
	bool cg_scale;
	u32 i2c_fs_rate;
	u32 i2c_reg;
	u32 i2c_slave_addr;
	unsigned int lut[33];
	unsigned long lut_uv[33];
	int lut_size;
	u8 lut_bottom;
	u8 lut_min;
	u8 lut_max;
	u8 lut_safe;
	enum tegra_dfll_pmu_if pmu_if;
	unsigned long pwm_rate;
	struct pinctrl *pwm_pin;
	struct pinctrl_state *pwm_enable_state;
	struct pinctrl_state *pwm_disable_state;
	u32 reg_init_uV;
};

enum ch_command {
	HIDMA_CH_DISABLE = 0,
	HIDMA_CH_ENABLE = 1,
	HIDMA_CH_SUSPEND = 2,
	HIDMA_CH_RESET = 9,
};

enum ch_state {
	HIDMA_CH_DISABLED = 0,
	HIDMA_CH_ENABLED = 1,
	HIDMA_CH_RUNNING = 2,
	HIDMA_CH_SUSPENDED = 3,
	HIDMA_CH_STOPPED = 4,
};

enum err_code {
	HIDMA_EVRE_STATUS_COMPLETE = 1,
	HIDMA_EVRE_STATUS_ERROR = 4,
};

struct tegra234_cbb_fabric;

struct tegra234_cbb_acpi_uid {
	const char *hid;
	const char *uid;
	const struct tegra234_cbb_fabric *fabric;
};

struct tegra234_slave_lookup;

struct tegra234_cbb_fabric {
	const char *name;
	phys_addr_t off_mask_erd;
	phys_addr_t firewall_base;
	unsigned int firewall_ctl;
	unsigned int firewall_wr_ctl;
	const char * const *master_id;
	unsigned int notifier_offset;
	const struct tegra_cbb_error *errors;
	const int max_errors;
	const struct tegra234_slave_lookup *slave_map;
	const int max_slaves;
};

struct tegra234_slave_lookup {
	const char *name;
	unsigned int offset;
};

enum tegra234_cbb_fabric_ids {
	CBB_FAB_ID = 0,
	SCE_FAB_ID = 1,
	RCE_FAB_ID = 2,
	DCE_FAB_ID = 3,
	AON_FAB_ID = 4,
	PSC_FAB_ID = 5,
	BPMP_FAB_ID = 6,
	FSI_FAB_ID = 7,
	MAX_FAB_ID = 8,
};

struct tegra234_cbb {
	struct tegra_cbb base;
	const struct tegra234_cbb_fabric *fabric;
	struct resource *res;
	void *regs;
	int num_intr;
	int sec_irq;
	void *mon;
	unsigned int type;
	u32 mask;
	u64 access;
	u32 mn_attr0;
	u32 mn_attr1;
	u32 mn_attr2;
	u32 mn_user_bits;
};

struct imx8mp_blk_ctrl;

struct imx8mp_blk_ctrl_domain;

struct imx8mp_blk_ctrl_domain_data;

struct imx8mp_blk_ctrl_data {
	int max_reg;
	int (*probe)(struct imx8mp_blk_ctrl *);
	notifier_fn_t power_notifier_fn;
	void (*power_off)(struct imx8mp_blk_ctrl *, struct imx8mp_blk_ctrl_domain *);
	void (*power_on)(struct imx8mp_blk_ctrl *, struct imx8mp_blk_ctrl_domain *);
	const struct imx8mp_blk_ctrl_domain_data *domains;
	int num_domains;
};

struct imx8mp_blk_ctrl {
	struct device *dev;
	struct notifier_block power_nb;
	struct device *bus_power_dev;
	struct regmap *regmap;
	struct imx8mp_blk_ctrl_domain *domains;
	struct genpd_onecell_data onecell_data;
	void (*power_off)(struct imx8mp_blk_ctrl *, struct imx8mp_blk_ctrl_domain *);
	void (*power_on)(struct imx8mp_blk_ctrl *, struct imx8mp_blk_ctrl_domain *);
};

struct imx8mp_blk_ctrl_domain {
	struct generic_pm_domain genpd;
	const struct imx8mp_blk_ctrl_domain_data *data;
	struct clk_bulk_data clks[2];
	struct icc_bulk_data paths[3];
	struct device *power_dev;
	struct imx8mp_blk_ctrl *bc;
	int num_paths;
	int id;
};

struct imx8mp_blk_ctrl_domain_data {
	const char *name;
	const char * const *clk_names;
	int num_clks;
	const char * const *path_names;
	int num_paths;
	const char *gpc_name;
};

struct clk_hsio_pll {
	struct clk_hw hw;
	struct regmap *regmap;
};

struct ti_sci_reset_data {
	struct reset_controller_dev rcdev;
	struct device *dev;
	const struct ti_sci_handle *sci;
	struct idr idr;
};

struct ti_sci_reset_control {
	u32 dev_id;
	u32 reset_mask;
	struct mutex lock;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	int: 1;
	unsigned char modeflags: 5;
};

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef void fn_handler_fn(struct vc_data *);

struct kbd_led_trigger {
	struct led_trigger trigger;
	unsigned int mask;
};

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct fsl8250_data {
	int line;
};

struct cdns_platform_data {
	u32 quirks;
};

struct cdns_uart {
	struct uart_port *port;
	struct clk *uartclk;
	struct clk *pclk;
	struct uart_driver *cdns_uart_driver;
	unsigned int baud;
	struct notifier_block clk_rate_change_nb;
	u32 quirks;
	bool cts_override;
};

struct optee_rng_private {
	struct device *dev;
	struct tee_context *ctx;
	u32 session_id;
	u32 data_rate;
	struct tee_shm *entropy_shm_pool;
	struct hwrng optee_rng;
};

struct qcom_smmu_config;

struct qcom_smmu_match_data {
	const struct qcom_smmu_config *cfg;
	const struct arm_smmu_impl *impl;
	const struct arm_smmu_impl *adreno_impl;
};

struct qcom_smmu_config {
	const u32 *reg_offset;
};

struct qcom_smmu {
	struct arm_smmu_device smmu;
	const struct qcom_smmu_config *cfg;
	bool bypass_quirk;
	u8 bypass_cbndx;
	u32 stall_enabled;
};

struct adreno_smmu_fault_info;

struct adreno_smmu_priv {
	const void *cookie;
	const struct io_pgtable_cfg * (*get_ttbr1_cfg)(const void *);
	int (*set_ttbr0_cfg)(const void *, const struct io_pgtable_cfg *);
	void (*get_fault_info)(const void *, struct adreno_smmu_fault_info *);
	void (*set_stall)(const void *, bool);
	void (*resume_translation)(const void *, bool);
};

struct adreno_smmu_fault_info {
	u64 far;
	u64 ttbr0;
	u32 contextidr;
	u32 fsr;
	u32 fsynr0;
	u32 fsynr1;
	u32 cbfrsynra;
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

enum {
	BD718XX_INT_STBY_REQ = 0,
	BD718XX_INT_ON_REQ = 1,
	BD718XX_INT_WDOG = 2,
	BD718XX_INT_PWRBTN = 3,
	BD718XX_INT_PWRBTN_L = 4,
	BD718XX_INT_PWRBTN_S = 5,
	BD718XX_INT_SWRST = 6,
};

enum task_disposition {
	TASK_IS_DONE = 0,
	TASK_IS_ABORTED = 1,
	TASK_IS_AT_LU = 2,
	TASK_IS_NOT_AT_LU = 3,
	TASK_ABORT_FAILED = 4,
};

enum ahci_qoriq_type {
	AHCI_LS1021A = 0,
	AHCI_LS1028A = 1,
	AHCI_LS1043A = 2,
	AHCI_LS2080A = 3,
	AHCI_LS1046A = 4,
	AHCI_LS1088A = 5,
	AHCI_LS2088A = 6,
	AHCI_LX2160A = 7,
};

struct ccsr_ahci;

struct ahci_qoriq_priv {
	struct ccsr_ahci *reg_base;
	enum ahci_qoriq_type type;
	void *ecc_addr;
	bool is_dmacoherent;
};

enum dspi_trans_mode {
	DSPI_XSPI_MODE = 0,
	DSPI_DMA_MODE = 1,
};

struct fsl_dspi_devtype_data {
	enum dspi_trans_mode trans_mode;
	u8 max_clock_factor;
	int fifo_size;
};

enum {
	LS1021A = 0,
	LS1012A = 1,
	LS1028A = 2,
	LS1043A = 3,
	LS1046A = 4,
	LS2080A = 5,
	LS2085A = 6,
	LX2160A = 7,
	MCF5441X = 8,
	VF610 = 9,
};

struct chip_data___3;

struct fsl_dspi_dma;

struct fsl_dspi {
	struct spi_controller *ctlr;
	struct platform_device *pdev;
	struct regmap *regmap;
	struct regmap *regmap_pushr;
	int irq;
	struct clk *clk;
	struct spi_transfer *cur_transfer;
	struct spi_message *cur_msg;
	struct chip_data___3 *cur_chip;
	size_t progress;
	size_t len;
	const void *tx;
	void *rx;
	u16 tx_cmd;
	const struct fsl_dspi_devtype_data *devtype_data;
	struct completion xfer_done;
	struct fsl_dspi_dma *dma;
	int oper_word_size;
	int oper_bits_per_word;
	int words_in_flight;
	int pushr_cmd;
	int pushr_tx;
	void (*host_to_dev)(struct fsl_dspi *, u32 *);
	void (*dev_to_host)(struct fsl_dspi *, u32);
};

struct chip_data___3 {
	u32 ctar_val;
};

struct fsl_dspi_dma {
	u32 *tx_dma_buf;
	struct dma_chan *chan_tx;
	dma_addr_t tx_dma_phys;
	struct completion cmd_tx_complete;
	struct dma_async_tx_descriptor *tx_desc;
	u32 *rx_dma_buf;
	struct dma_chan *chan_rx;
	dma_addr_t rx_dma_phys;
	struct completion cmd_rx_complete;
	struct dma_async_tx_descriptor *rx_desc;
};

struct fsl_dspi_platform_data {
	u32 cs_num;
	u32 bus_num;
	u32 sck_cs_delay;
	u32 cs_sck_delay;
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

struct fman_sp_int_context_data_copy {
	u16 ext_buf_offset;
	u8 int_context_offset;
	u16 size;
};

struct fman_sp_buf_margins {
	u16 start_margins;
	u16 end_margins;
};

struct fman_sp_buffer_offsets {
	u32 data_offset;
	u32 prs_result_offset;
	u32 time_stamp_offset;
	u32 hash_result_offset;
};

struct fman_kg_scheme_regs {
	u32 kgse_mode;
	u32 kgse_ekfc;
	u32 kgse_ekdv;
	u32 kgse_bmch;
	u32 kgse_bmcl;
	u32 kgse_fqb;
	u32 kgse_hc;
	u32 kgse_ppc;
	u32 kgse_gec[8];
	u32 kgse_spc;
	u32 kgse_dv0;
	u32 kgse_dv1;
	u32 kgse_ccbs;
	u32 kgse_mv;
	u32 kgse_om;
	u32 kgse_vsp;
};

struct fman_kg_pe_regs {
	u32 fmkg_pe_sp;
	u32 fmkg_pe_cpp;
};

struct fman_kg_regs {
	u32 fmkg_gcr;
	u32 res004;
	u32 res008;
	u32 fmkg_eer;
	u32 fmkg_eeer;
	u32 res014;
	u32 res018;
	u32 fmkg_seer;
	u32 fmkg_seeer;
	u32 fmkg_gsr;
	u32 fmkg_tpc;
	u32 fmkg_serc;
	u32 res030[4];
	u32 fmkg_fdor;
	u32 fmkg_gdv0r;
	u32 fmkg_gdv1r;
	u32 res04c[6];
	u32 fmkg_feer;
	u32 res068[38];
	union {
		u32 fmkg_indirect[63];
		struct fman_kg_scheme_regs fmkg_sch;
		struct fman_kg_pe_regs fmkg_pe;
	};
	u32 fmkg_ar;
};

struct keygen_scheme {
	bool used;
	u8 hw_port_id;
	u32 base_fqid;
	u32 hash_fqid_count;
	bool use_hashing;
	bool symmetric_hash;
	u8 hashShift;
	u32 match_vector;
};

struct fman_keygen {
	struct keygen_scheme schemes[32];
	struct fman_kg_regs *keygen_regs;
};

enum fman_port_deq_type {
	FMAN_PORT_DEQ_BY_PRI = 0,
	FMAN_PORT_DEQ_ACTIVE_FQ = 1,
	FMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS = 2,
};

enum fman_port_deq_prefetch {
	FMAN_PORT_DEQ_NO_PREFETCH = 0,
	FMAN_PORT_DEQ_PART_PREFETCH = 1,
	FMAN_PORT_DEQ_FULL_PREFETCH = 2,
};

enum fman_port_dma_swap {
	FMAN_PORT_DMA_NO_SWAP = 0,
	FMAN_PORT_DMA_SWAP_LE = 1,
	FMAN_PORT_DMA_SWAP_BE = 2,
};

enum fman_port_color {
	FMAN_PORT_COLOR_GREEN = 0,
	FMAN_PORT_COLOR_YELLOW = 1,
	FMAN_PORT_COLOR_RED = 2,
	FMAN_PORT_COLOR_OVERRIDE = 3,
};

struct fman_port_rsrc {
	u32 num;
	u32 extra;
};

struct fman_port_rx_pools_params {
	u8 num_of_pools;
	u16 largest_buf_size;
};

struct fman_port_dts_params {
	void *base_addr;
	enum fman_port_type type;
	u16 speed;
	u8 id;
	u32 qman_channel_id;
	struct fman *fman;
};

union fman_port_bmi_regs;

struct fman_port_qmi_regs;

struct fman_port_hwp_regs;

struct fman_port_cfg;

struct fman_port {
	void *fm;
	struct device *dev;
	struct fman_rev_info rev_info;
	u8 port_id;
	enum fman_port_type port_type;
	u16 port_speed;
	union fman_port_bmi_regs *bmi_regs;
	struct fman_port_qmi_regs *qmi_regs;
	struct fman_port_hwp_regs *hwp_regs;
	struct fman_sp_buffer_offsets buffer_offsets;
	u8 internal_buf_offset;
	struct fman_ext_pools ext_buf_pools;
	u16 max_frame_length;
	struct fman_port_rsrc open_dmas;
	struct fman_port_rsrc tasks;
	struct fman_port_rsrc fifo_bufs;
	struct fman_port_rx_pools_params rx_pools_params;
	struct fman_port_cfg *cfg;
	struct fman_port_dts_params dts_params;
	u8 ext_pools_num;
	u32 max_port_fifo_size;
	u32 max_num_of_ext_pools;
	u32 max_num_of_sub_portals;
	u32 bm_max_num_of_pools;
};

struct fman_port_rx_bmi_regs {
	u32 fmbm_rcfg;
	u32 fmbm_rst;
	u32 fmbm_rda;
	u32 fmbm_rfp;
	u32 fmbm_rfed;
	u32 fmbm_ricp;
	u32 fmbm_rim;
	u32 fmbm_rebm;
	u32 fmbm_rfne;
	u32 fmbm_rfca;
	u32 fmbm_rfpne;
	u32 fmbm_rpso;
	u32 fmbm_rpp;
	u32 fmbm_rccb;
	u32 fmbm_reth;
	u32 reserved003c[1];
	u32 fmbm_rprai[8];
	u32 fmbm_rfqid;
	u32 fmbm_refqid;
	u32 fmbm_rfsdm;
	u32 fmbm_rfsem;
	u32 fmbm_rfene;
	u32 reserved0074[2];
	u32 fmbm_rcmne;
	u32 reserved0080[32];
	u32 fmbm_ebmpi[8];
	u32 fmbm_acnt[8];
	u32 reserved0130[8];
	u32 fmbm_rcgm[8];
	u32 fmbm_mpd;
	u32 reserved0184[31];
	u32 fmbm_rstc;
	u32 fmbm_rfrc;
	u32 fmbm_rfbc;
	u32 fmbm_rlfc;
	u32 fmbm_rffc;
	u32 fmbm_rfdc;
	u32 fmbm_rfldec;
	u32 fmbm_rodc;
	u32 fmbm_rbdc;
	u32 fmbm_rpec;
	u32 reserved0224[22];
	u32 fmbm_rpc;
	u32 fmbm_rpcp;
	u32 fmbm_rccn;
	u32 fmbm_rtuc;
	u32 fmbm_rrquc;
	u32 fmbm_rduc;
	u32 fmbm_rfuc;
	u32 fmbm_rpac;
	u32 reserved02a0[24];
	u32 fmbm_rdcfg[3];
	u32 fmbm_rgpr;
	u32 reserved0310[58];
};

struct fman_port_tx_bmi_regs {
	u32 fmbm_tcfg;
	u32 fmbm_tst;
	u32 fmbm_tda;
	u32 fmbm_tfp;
	u32 fmbm_tfed;
	u32 fmbm_ticp;
	u32 fmbm_tfdne;
	u32 fmbm_tfca;
	u32 fmbm_tcfqid;
	u32 fmbm_tefqid;
	u32 fmbm_tfene;
	u32 fmbm_trlmts;
	u32 fmbm_trlmt;
	u32 reserved0034[14];
	u32 fmbm_tccb;
	u32 fmbm_tfne;
	u32 fmbm_tpfcm[2];
	u32 fmbm_tcmne;
	u32 reserved0080[96];
	u32 fmbm_tstc;
	u32 fmbm_tfrc;
	u32 fmbm_tfdc;
	u32 fmbm_tfledc;
	u32 fmbm_tfufdc;
	u32 fmbm_tbdc;
	u32 reserved0218[26];
	u32 fmbm_tpc;
	u32 fmbm_tpcp;
	u32 fmbm_tccn;
	u32 fmbm_ttuc;
	u32 fmbm_ttcquc;
	u32 fmbm_tduc;
	u32 fmbm_tfuc;
	u32 reserved029c[16];
	u32 fmbm_tdcfg[3];
	u32 fmbm_tgpr;
	u32 reserved0310[58];
};

union fman_port_bmi_regs {
	struct fman_port_rx_bmi_regs rx;
	struct fman_port_tx_bmi_regs tx;
};

struct fman_port_qmi_regs {
	u32 fmqm_pnc;
	u32 fmqm_pns;
	u32 fmqm_pnts;
	u32 reserved00c[4];
	u32 fmqm_pnen;
	u32 fmqm_pnetfc;
	u32 reserved024[2];
	u32 fmqm_pndn;
	u32 fmqm_pndc;
	u32 fmqm_pndtfc;
	u32 fmqm_pndfdc;
	u32 fmqm_pndcc;
};

struct fman_port_hwp_regs {
	struct {
		u32 ssa;
		u32 lcv;
	} pmda[16];
	u32 reserved080[222];
	u32 fmpr_pcac;
};

struct fman_buf_pool_depletion {
	bool pools_grp_mode_enable;
	u8 num_of_pools;
	bool pools_to_consider[64];
	bool single_pool_mode_enable;
	bool pools_to_consider_for_single_mode[64];
};

struct fman_port_cfg {
	u32 dflt_fqid;
	u32 err_fqid;
	u32 pcd_base_fqid;
	u32 pcd_fqs_count;
	u8 deq_sp;
	bool deq_high_priority;
	enum fman_port_deq_type deq_type;
	enum fman_port_deq_prefetch deq_prefetch_option;
	u16 deq_byte_cnt;
	u8 cheksum_last_bytes_ignore;
	u8 rx_cut_end_bytes;
	struct fman_buf_pool_depletion buf_pool_depletion;
	struct fman_ext_pools ext_buf_pools;
	u32 tx_fifo_min_level;
	u32 tx_fifo_low_comf_level;
	u32 rx_pri_elevation;
	u32 rx_fifo_thr;
	struct fman_sp_buf_margins buf_margins;
	u32 int_buf_start_margin;
	struct fman_sp_int_context_data_copy int_context;
	u32 discard_mask;
	u32 err_mask;
	struct fman_buffer_prefix_content buffer_prefix_content;
	bool dont_release_buf;
	u8 rx_fd_bits;
	u32 tx_fifo_deq_pipeline_depth;
	bool errata_A006320;
	bool excessive_threshold_register;
	bool fmbm_tfne_has_features;
	enum fman_port_dma_swap dma_swap_data;
	enum fman_port_color color;
};

struct fman_port_bpools {
	u8 count;
	bool counters_enable;
	u8 grp_bp_depleted_num;
	struct {
		u8 bpid;
		u16 size;
		bool is_backup;
		bool grp_bp_depleted;
		bool single_bp_depleted;
	} bpool[8];
};

struct dpni_mask_cfg {
	u8 mask;
	u8 offset;
};

struct dpni_dist_extract {
	u8 prot;
	u8 efh_type;
	u8 size;
	u8 offset;
	__le32 field;
	u8 hdr_index;
	u8 constant;
	u8 num_of_repeats;
	u8 num_of_byte_masks;
	u8 extract_type;
	u8 pad[3];
	struct dpni_mask_cfg masks[4];
};

struct dpni_ext_set_rx_tc_dist {
	u8 num_extracts;
	u8 pad[7];
	struct dpni_dist_extract extracts[10];
};

struct dpni_cmd_open {
	__le32 dpni_id;
};

struct dpni_cmd_pool {
	__le16 dpbp_id;
	u8 priority_mask;
	u8 pad;
};

struct dpni_cmd_set_pools {
	u8 num_dpbp;
	u8 backup_pool_mask;
	u8 pad;
	u8 pool_options;
	struct dpni_cmd_pool pool[8];
	__le16 buffer_size[8];
};

struct dpni_rsp_is_enabled {
	u8 enabled;
};

struct dpni_cmd_set_irq_enable {
	u8 enable;
	u8 pad[3];
	u8 irq_index;
};

struct dpni_cmd_get_irq_enable {
	__le32 pad;
	u8 irq_index;
};

struct dpni_rsp_get_irq_enable {
	u8 enabled;
};

struct dpni_cmd_set_irq_mask {
	__le32 mask;
	u8 irq_index;
};

struct dpni_cmd_get_irq_mask {
	__le32 pad;
	u8 irq_index;
};

struct dpni_rsp_get_irq_mask {
	__le32 mask;
};

struct dpni_cmd_get_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dpni_rsp_get_irq_status {
	__le32 status;
};

struct dpni_cmd_clear_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dpni_rsp_get_attr {
	__le32 options;
	u8 num_queues;
	u8 num_tcs;
	u8 mac_filter_entries;
	u8 pad0;
	u8 vlan_filter_entries;
	u8 pad1;
	u8 qos_entries;
	u8 pad2;
	__le16 fs_entries;
	__le16 pad3;
	u8 qos_key_size;
	u8 fs_key_size;
	__le16 wriop_version;
};

struct dpni_cmd_set_errors_behavior {
	__le32 errors;
	u8 flags;
};

struct dpni_cmd_get_buffer_layout {
	u8 qtype;
};

struct dpni_rsp_get_buffer_layout {
	u8 pad0[6];
	u8 flags;
	u8 pad1;
	__le16 private_data_size;
	__le16 data_align;
	__le16 head_room;
	__le16 tail_room;
};

struct dpni_cmd_set_buffer_layout {
	u8 qtype;
	u8 pad0[3];
	__le16 options;
	u8 flags;
	u8 pad1;
	__le16 private_data_size;
	__le16 data_align;
	__le16 head_room;
	__le16 tail_room;
};

struct dpni_cmd_set_offload {
	u8 pad[3];
	u8 dpni_offload;
	__le32 config;
};

struct dpni_cmd_get_offload {
	u8 pad[3];
	u8 dpni_offload;
};

struct dpni_rsp_get_offload {
	__le32 pad;
	__le32 config;
};

struct dpni_cmd_get_qdid {
	u8 qtype;
};

struct dpni_rsp_get_qdid {
	__le16 qdid;
};

struct dpni_rsp_get_tx_data_offset {
	__le16 data_offset;
};

struct dpni_cmd_link_cfg {
	__le64 pad0;
	__le32 rate;
	__le32 pad1;
	__le64 options;
};

struct dpni_rsp_get_link_state {
	__le32 pad0;
	u8 flags;
	u8 pad1[3];
	__le32 rate;
	__le32 pad2;
	__le64 options;
};

struct dpni_cmd_set_max_frame_length {
	__le16 max_frame_length;
};

struct dpni_rsp_get_max_frame_length {
	__le16 max_frame_length;
};

struct dpni_cmd_set_multicast_promisc {
	u8 enable;
};

struct dpni_rsp_get_multicast_promisc {
	u8 enabled;
};

struct dpni_cmd_set_unicast_promisc {
	u8 enable;
};

struct dpni_rsp_get_unicast_promisc {
	u8 enabled;
};

struct dpni_cmd_set_primary_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_rsp_get_primary_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_rsp_get_port_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_cmd_enable_vlan_filter {
	u8 en;
};

struct dpni_cmd_vlan_id {
	u8 flags;
	u8 tc_id;
	u8 flow_id;
	u8 pad;
	__le16 vlan_id;
};

struct dpni_cmd_add_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_cmd_remove_mac_addr {
	__le16 pad;
	u8 mac_addr[6];
};

struct dpni_cmd_clear_mac_filters {
	u8 flags;
};

struct dpni_cmd_set_rx_tc_dist {
	__le16 dist_size;
	u8 tc_id;
	u8 flags;
	__le16 pad0;
	__le16 default_flow_id;
	__le64 pad1[5];
	__le64 key_cfg_iova;
};

struct dpni_cmd_set_congestion_notification {
	u8 qtype;
	u8 tc;
	u8 pad[6];
	__le32 dest_id;
	__le16 notification_mode;
	u8 dest_priority;
	u8 type_units;
	__le64 message_iova;
	__le64 message_ctx;
	__le32 threshold_entry;
	__le32 threshold_exit;
};

struct dpni_cmd_set_queue {
	u8 qtype;
	u8 tc;
	u8 index;
	u8 options;
	__le32 pad0;
	__le32 dest_id;
	__le16 pad1;
	u8 dest_prio;
	u8 flags;
	__le64 flc;
	__le64 user_context;
};

struct dpni_cmd_get_queue {
	u8 qtype;
	u8 tc;
	u8 index;
};

struct dpni_rsp_get_queue {
	__le64 pad0;
	__le32 dest_id;
	__le16 pad1;
	u8 dest_prio;
	u8 flags;
	__le64 flc;
	__le64 user_context;
	__le32 fqid;
	__le16 qdbin;
};

struct dpni_cmd_get_statistics {
	u8 page_number;
};

struct dpni_rsp_get_statistics {
	__le64 counter[7];
};

struct dpni_cmd_set_taildrop {
	u8 congestion_point;
	u8 qtype;
	u8 tc;
	u8 index;
	__le32 pad0;
	u8 enable;
	u8 pad1;
	u8 units;
	u8 pad2;
	__le32 threshold;
};

struct dpni_cmd_get_taildrop {
	u8 congestion_point;
	u8 qtype;
	u8 tc;
	u8 index;
};

struct dpni_rsp_get_taildrop {
	__le64 pad0;
	u8 enable;
	u8 pad1;
	u8 units;
	u8 pad2;
	__le32 threshold;
};

struct dpni_rsp_get_api_version {
	__le16 major;
	__le16 minor;
};

struct dpni_cmd_set_rx_fs_dist {
	__le16 dist_size;
	u8 enable;
	u8 tc;
	__le16 miss_flow_id;
	__le16 pad;
	__le64 key_cfg_iova;
};

struct dpni_cmd_set_rx_hash_dist {
	__le16 dist_size;
	u8 enable;
	u8 tc;
	__le32 pad;
	__le64 key_cfg_iova;
};

struct dpni_cmd_add_fs_entry {
	__le16 options;
	u8 tc_id;
	u8 key_size;
	__le16 index;
	__le16 flow_id;
	__le64 key_iova;
	__le64 mask_iova;
	__le64 flc;
};

struct dpni_cmd_remove_fs_entry {
	__le16 pad0;
	u8 tc_id;
	u8 key_size;
	__le32 pad1;
	__le64 key_iova;
	__le64 mask_iova;
};

struct dpni_cmd_set_qos_table {
	__le32 pad;
	u8 default_tc;
	u8 discard_on_miss;
	__le16 pad1[21];
	__le64 key_cfg_iova;
};

struct dpni_cmd_add_qos_entry {
	__le16 pad;
	u8 tc_id;
	u8 key_size;
	__le16 index;
	__le16 pad1;
	__le64 key_iova;
	__le64 mask_iova;
};

struct dpni_cmd_remove_qos_entry {
	u8 pad[3];
	u8 key_size;
	__le32 pad1;
	__le64 key_iova;
	__le64 mask_iova;
};

struct dpni_cmd_set_tx_shaping {
	__le16 tx_cr_max_burst_size;
	__le16 tx_er_max_burst_size;
	__le32 pad;
	__le32 tx_cr_rate_limit;
	__le32 tx_er_rate_limit;
	u8 coupled;
};

struct dpni_rsp_single_step_cfg {
	__le16 flags;
	__le16 offset;
	__le32 peer_delay;
	__le32 ptp_onestep_reg_base;
	__le32 pad0;
};

struct dpni_cmd_single_step_cfg {
	__le16 flags;
	__le16 offset;
	__le32 peer_delay;
	__le32 ptp_onestep_reg_base;
	__le32 pad0;
};

struct dpni_dest_cfg {
	enum dpni_dest dest_type;
	int dest_id;
	u8 priority;
};

struct dpni_congestion_notification_cfg {
	enum dpni_congestion_unit units;
	u32 threshold_entry;
	u32 threshold_exit;
	u64 message_ctx;
	u64 message_iova;
	struct dpni_dest_cfg dest_cfg;
	u16 notification_mode;
};

struct hclge_comm_rss_tc_mode_cmd {
	__le16 rss_tc_mode[8];
	u8 rsv[8];
};

struct hclge_comm_rss_input_tuple_cmd {
	u8 ipv4_tcp_en;
	u8 ipv4_udp_en;
	u8 ipv4_sctp_en;
	u8 ipv4_fragment_en;
	u8 ipv6_tcp_en;
	u8 ipv6_udp_en;
	u8 ipv6_sctp_en;
	u8 ipv6_fragment_en;
	u8 rsv[16];
};

struct hclge_comm_rss_ind_tbl_cmd {
	__le16 start_table_index;
	__le16 rss_set_bitmap;
	u8 rss_qid_h[4];
	u8 rss_qid_l[16];
};

struct hclge_comm_rss_config_cmd {
	u8 hash_config;
	u8 rsv[7];
	u8 hash_key[16];
};

enum GIS_BIT {
	GIS_PTCF = 1,
	GIS_PTMF = 4,
	GIS_RESERVED = 64512,
};

enum GIC_BIT {
	GIC_PTCE = 1,
	GIC_PTME = 4,
};

enum GIE_BIT {
	GIE_PTCS = 1,
	GIE_PTOS = 2,
	GIE_PTMS0 = 4,
	GIE_PTMS1 = 8,
	GIE_PTMS2 = 16,
	GIE_PTMS3 = 32,
	GIE_PTMS4 = 64,
	GIE_PTMS5 = 128,
	GIE_PTMS6 = 256,
	GIE_PTMS7 = 512,
	GIE_ATCS0 = 65536,
	GIE_ATCS1 = 131072,
	GIE_ATCS2 = 262144,
	GIE_ATCS3 = 524288,
	GIE_ATCS4 = 1048576,
	GIE_ATCS5 = 2097152,
	GIE_ATCS6 = 4194304,
	GIE_ATCS7 = 8388608,
	GIE_ATCS8 = 16777216,
	GIE_ATCS9 = 33554432,
	GIE_ATCS10 = 67108864,
	GIE_ATCS11 = 134217728,
	GIE_ATCS12 = 268435456,
	GIE_ATCS13 = 536870912,
	GIE_ATCS14 = 1073741824,
	GIE_ATCS15 = 2147483648,
};

enum GID_BIT {
	GID_PTCD = 1,
	GID_PTOD = 2,
	GID_PTMD0 = 4,
	GID_PTMD1 = 8,
	GID_PTMD2 = 16,
	GID_PTMD3 = 32,
	GID_PTMD4 = 64,
	GID_PTMD5 = 128,
	GID_PTMD6 = 256,
	GID_PTMD7 = 512,
	GID_ATCD0 = 65536,
	GID_ATCD1 = 131072,
	GID_ATCD2 = 262144,
	GID_ATCD3 = 524288,
	GID_ATCD4 = 1048576,
	GID_ATCD5 = 2097152,
	GID_ATCD6 = 4194304,
	GID_ATCD7 = 8388608,
	GID_ATCD8 = 16777216,
	GID_ATCD9 = 33554432,
	GID_ATCD10 = 67108864,
	GID_ATCD11 = 134217728,
	GID_ATCD12 = 268435456,
	GID_ATCD13 = 536870912,
	GID_ATCD14 = 1073741824,
	GID_ATCD15 = 2147483648,
};

struct am65_cpsw_regdump_hdr {
	u32 module_id;
	u32 len;
};

struct am65_cpsw_regdump_item {
	struct am65_cpsw_regdump_hdr hdr;
	u32 start_ofs;
	u32 end_ofs;
};

struct am65_cpsw_ethtool_stat {
	char desc[32];
	int offset;
};

enum {
	AM65_CPSW_REGDUMP_MOD_NUSS = 1,
	AM65_CPSW_REGDUMP_MOD_RGMII_STATUS = 2,
	AM65_CPSW_REGDUMP_MOD_MDIO = 3,
	AM65_CPSW_REGDUMP_MOD_CPSW = 4,
	AM65_CPSW_REGDUMP_MOD_CPSW_P0 = 5,
	AM65_CPSW_REGDUMP_MOD_CPSW_P1 = 6,
	AM65_CPSW_REGDUMP_MOD_CPSW_CPTS = 7,
	AM65_CPSW_REGDUMP_MOD_CPSW_ALE = 8,
	AM65_CPSW_REGDUMP_MOD_CPSW_ALE_TBL = 9,
	AM65_CPSW_REGDUMP_MOD_LAST = 10,
};

struct dwc3_haps {
	struct platform_device *dwc3;
	struct pci_dev *pci;
};

struct ignore_entry {
	u16 vid;
	u16 pid;
	u16 bcdmin;
	u16 bcdmax;
};

struct sunxi_musb_cfg {
	const struct musb_hdrc_config *hdrc_config;
	bool has_sram;
	bool has_reset;
	bool no_configdata;
};

struct sunxi_glue {
	struct device *dev;
	struct musb *musb;
	struct platform_device *musb_pdev;
	struct clk *clk;
	struct reset_control *rst;
	struct phy *phy;
	struct platform_device *usb_phy;
	struct usb_phy *xceiv;
	enum phy_mode phy_mode;
	unsigned long flags;
	struct work_struct work;
	struct extcon_dev *extcon;
	struct notifier_block host_nb;
};

struct udc_ep_regs;

struct udc_stp_dma;

struct udc_data_dma;

struct udc_request;

struct udc;

struct udc_ep {
	struct usb_ep ep;
	struct udc_ep_regs *regs;
	u32 *txfifo;
	u32 *dma;
	dma_addr_t td_phys;
	dma_addr_t td_stp_dma;
	struct udc_stp_dma *td_stp;
	struct udc_data_dma *td;
	struct udc_request *req;
	unsigned int req_used;
	unsigned int req_completed;
	struct udc_request *bna_dummy_req;
	unsigned int bna_occurred;
	unsigned int naking;
	struct udc *dev;
	struct list_head queue;
	unsigned int halted;
	unsigned int cancel_transfer;
	unsigned int num: 5;
	unsigned int fifo_depth: 14;
	unsigned int in: 1;
};

struct extcon_specific_cable_nb {
	struct notifier_block *user_nb;
	int cable_index;
	struct extcon_dev *edev;
	unsigned long previous_value;
};

struct udc_csrs;

struct udc_regs;

struct udc {
	struct usb_gadget gadget;
	spinlock_t lock;
	struct udc_ep ep[32];
	struct usb_gadget_driver *driver;
	unsigned int stall_ep0in: 1;
	unsigned int waiting_zlp_ack_ep0in: 1;
	unsigned int set_cfg_not_acked: 1;
	unsigned int data_ep_enabled: 1;
	unsigned int data_ep_queued: 1;
	unsigned int sys_suspended: 1;
	unsigned int connected;
	u16 chiprev;
	struct pci_dev *pdev;
	struct udc_csrs *csr;
	struct udc_regs *regs;
	struct udc_ep_regs *ep_regs;
	u32 *rxfifo;
	u32 *txfifo;
	struct dma_pool *data_requests;
	struct dma_pool *stp_requests;
	unsigned long phys_addr;
	void *virt_addr;
	unsigned int irq;
	u16 cur_config;
	u16 cur_intf;
	u16 cur_alt;
	struct device *dev;
	struct phy *udc_phy;
	struct extcon_dev *edev;
	struct extcon_specific_cable_nb extcon_nb;
	struct notifier_block nb;
	struct delayed_work drd_work;
	u32 conn_type;
};

struct udc_ep_regs {
	u32 ctl;
	u32 sts;
	u32 bufin_framenum;
	u32 bufout_maxpkt;
	u32 subptr;
	u32 desptr;
	u32 reserved;
	u32 confirm;
};

struct udc_stp_dma {
	u32 status;
	u32 _reserved;
	u32 data12;
	u32 data34;
};

struct udc_data_dma {
	u32 status;
	u32 _reserved;
	u32 bufptr;
	u32 next;
};

struct udc_request {
	struct usb_request req;
	unsigned int dma_going: 1;
	unsigned int dma_done: 1;
	dma_addr_t td_phys;
	struct udc_data_dma *td_data;
	struct udc_data_dma *td_data_last;
	struct list_head queue;
	unsigned int chain_len;
};

struct udc_csrs {
	u32 sca;
	u32 ne[9];
};

struct udc_regs {
	u32 cfg;
	u32 ctl;
	u32 sts;
	u32 irqsts;
	u32 irqmsk;
	u32 ep_irqsts;
	u32 ep_irqmsk;
};

struct tegra_rtc_info {
	struct platform_device *pdev;
	struct rtc_device *rtc;
	void *base;
	struct clk *clk;
	int irq;
	spinlock_t lock;
};

struct meson_i2c;

struct meson_i2c_data {
	void (*set_clk_div)(struct meson_i2c *, unsigned int);
};

struct meson_i2c {
	struct i2c_adapter adap;
	struct device *dev;
	void *regs;
	struct clk *clk;
	struct i2c_msg *msg;
	int state;
	bool last;
	int count;
	int pos;
	int error;
	spinlock_t lock;
	struct completion done;
	u32 tokens[2];
	int num_tokens;
	const struct meson_i2c_data *data;
};

enum {
	STATE_IDLE___4 = 0,
	STATE_READ___3 = 1,
	STATE_WRITE___3 = 2,
};

enum {
	TOKEN_END = 0,
	TOKEN_START = 1,
	TOKEN_SLAVE_ADDR_WRITE = 2,
	TOKEN_SLAVE_ADDR_READ = 3,
	TOKEN_DATA = 4,
	TOKEN_DATA_LAST = 5,
	TOKEN_STOP = 6,
};

struct pps_kinfo {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
};

struct pps_fdata {
	struct pps_kinfo info;
	struct pps_ktime timeout;
};

struct pps_bind_args {
	int tsformat;
	int edge;
	int consumer;
};

struct pps_ktime_compat {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kinfo_compat {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime_compat assert_tu;
	struct pps_ktime_compat clear_tu;
	int current_mode;
} __attribute__((packed));

struct pps_fdata_compat {
	struct pps_kinfo_compat info;
	struct pps_ktime_compat timeout;
} __attribute__((packed));

struct reset_reg_mask {
	u32 rst_src_en_mask;
	u32 sw_mstr_rst_mask;
};

typedef void (*btf_trace_watchdog_start)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_watchdog_ping)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_watchdog_stop)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_watchdog_set_timeout)(void *, struct watchdog_device *, unsigned int, int);

struct trace_event_raw_watchdog_template {
	struct trace_entry ent;
	int id;
	int err;
	char __data[0];
};

struct trace_event_raw_watchdog_set_timeout {
	struct trace_entry ent;
	int id;
	unsigned int timeout;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_watchdog_template {};

struct trace_event_data_offsets_watchdog_set_timeout {};

struct tegra_cpufreq_ops;

struct tegra_cpufreq_soc {
	struct tegra_cpufreq_ops *ops;
	int maxcpus_per_cluster;
	unsigned int num_clusters;
	phys_addr_t actmon_cntr_base;
	u32 refclk_delta_min;
};

struct tegra_cpu_ctr;

struct tegra_cpufreq_ops {
	void (*read_counters)(struct tegra_cpu_ctr *);
	void (*set_cpu_ndiv)(struct cpufreq_policy *, u64);
	void (*get_cpu_cluster_id)(u32, u32 *, u32 *);
	int (*get_cpu_ndiv)(u32, u32, u32, u64 *);
};

struct tegra_cpu_ctr {
	u32 cpu;
	u32 coreclk_cnt;
	u32 last_coreclk_cnt;
	u32 refclk_cnt;
	u32 last_refclk_cnt;
};

struct read_counters_work {
	struct work_struct work;
	struct tegra_cpu_ctr c;
};

struct mrq_cpu_ndiv_limits_response {
	uint32_t ref_clk_hz;
	uint16_t pdiv;
	uint16_t mdiv;
	uint16_t ndiv_max;
	uint16_t ndiv_min;
};

struct mrq_cpu_ndiv_limits_request {
	uint32_t cluster_id;
};

struct tegra_cpu_data;

struct tegra194_cpufreq_data {
	void *regs;
	struct cpufreq_frequency_table **bpmp_luts;
	const struct tegra_cpufreq_soc *soc;
	bool icc_dram_bw_scaling;
	struct tegra_cpu_data *cpu_data;
};

struct tegra_cpu_data {
	u32 cpuid;
	u32 clusterid;
	void *freq_core_reg;
};

struct mmci_platform_data {
	unsigned int ocr_mask;
	unsigned int (*status)(struct device *);
};

struct mmci_dmae_next {
	struct dma_async_tx_descriptor *desc;
	struct dma_chan *chan;
};

struct mmci_dmae_priv {
	struct dma_chan *cur;
	struct dma_chan *rx_channel;
	struct dma_chan *tx_channel;
	struct dma_async_tx_descriptor *desc_current;
	struct mmci_dmae_next next_data;
};

enum scmi_base_protocol_cmd {
	BASE_DISCOVER_VENDOR = 3,
	BASE_DISCOVER_SUB_VENDOR = 4,
	BASE_DISCOVER_IMPLEMENT_VERSION = 5,
	BASE_DISCOVER_LIST_PROTOCOLS = 6,
	BASE_DISCOVER_AGENT = 7,
	BASE_NOTIFY_ERRORS = 8,
	BASE_SET_DEVICE_PERMISSIONS = 9,
	BASE_SET_PROTOCOL_PERMISSIONS = 10,
	BASE_RESET_AGENT_CONFIGURATION = 11,
};

struct scmi_msg_resp_base_attributes {
	u8 num_protocols;
	u8 num_agents;
	__le16 reserved;
};

struct scmi_msg_resp_base_discover_agent {
	__le32 agent_id;
	u8 name[16];
};

struct scmi_msg_base_error_notify {
	__le32 event_control;
};

struct scmi_base_error_notify_payld {
	__le32 agent_id;
	__le32 error_status;
	__le64 msg_reports[1024];
};

struct scmi_base_error_report {
	ktime_t timestamp;
	unsigned int agent_id;
	bool fatal;
	unsigned int cmd_count;
	unsigned long long reports[0];
};

enum scmi_reset_protocol_cmd {
	RESET_DOMAIN_ATTRIBUTES = 3,
	RESET = 4,
	RESET_NOTIFY = 5,
	RESET_DOMAIN_NAME_GET = 6,
};

struct reset_dom_info;

struct scmi_reset_info {
	u32 version;
	int num_domains;
	struct reset_dom_info *dom_info;
};

struct reset_dom_info {
	bool async_reset;
	bool reset_notify;
	u32 latency_us;
	char name[64];
};

struct scmi_msg_resp_reset_domain_attributes {
	__le32 attributes;
	__le32 latency;
	u8 name[16];
};

struct scmi_msg_reset_domain_reset {
	__le32 domain_id;
	__le32 flags;
	__le32 reset_state;
};

struct scmi_msg_reset_notify {
	__le32 id;
	__le32 event_control;
};

struct scmi_reset_issued_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 reset_state;
};

struct scmi_reset_issued_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int reset_state;
};

struct tee_bnxt_fw_private {
	struct device *dev;
	struct tee_context *ctx;
	u32 session_id;
	struct tee_shm *fw_shm_pool;
};

enum ta_cmd {
	TA_CMD_BNXT_FASTBOOT = 0,
	TA_CMD_BNXT_COPY_COREDUMP = 3,
};

struct efifb_dmi_info {
	char *optname;
	unsigned long base;
	int stride;
	int width;
	int height;
	int flags;
};

enum {
	M_I17 = 0,
	M_I20 = 1,
	M_I20_SR = 2,
	M_I24 = 3,
	M_I24_8_1 = 4,
	M_I24_10_1 = 5,
	M_I27_11_1 = 6,
	M_MINI = 7,
	M_MINI_3_1 = 8,
	M_MINI_4_1 = 9,
	M_MB = 10,
	M_MB_2 = 11,
	M_MB_3 = 12,
	M_MB_5_1 = 13,
	M_MB_6_1 = 14,
	M_MB_7_1 = 15,
	M_MB_SR = 16,
	M_MBA = 17,
	M_MBA_3 = 18,
	M_MBP = 19,
	M_MBP_2 = 20,
	M_MBP_2_2 = 21,
	M_MBP_SR = 22,
	M_MBP_4 = 23,
	M_MBP_5_1 = 24,
	M_MBP_5_2 = 25,
	M_MBP_5_3 = 26,
	M_MBP_6_1 = 27,
	M_MBP_6_2 = 28,
	M_MBP_7_1 = 29,
	M_MBP_8_2 = 30,
	M_UNKNOWN = 31,
};

enum {
	OVERRIDE_NONE = 0,
	OVERRIDE_BASE = 1,
	OVERRIDE_STRIDE = 2,
	OVERRIDE_HEIGHT = 4,
	OVERRIDE_WIDTH = 8,
};

struct hid_control_fifo {
	unsigned char dir;
	struct hid_report *report;
	char *raw_report;
};

struct hid_output_fifo {
	struct hid_report *report;
	char *raw_report;
};

struct usbhid_device {
	struct hid_device *hid;
	struct usb_interface *intf;
	int ifnum;
	unsigned int bufsize;
	struct urb *urbin;
	char *inbuf;
	dma_addr_t inbuf_dma;
	struct urb *urbctrl;
	struct usb_ctrlrequest *cr;
	struct hid_control_fifo ctrl[256];
	unsigned char ctrlhead;
	unsigned char ctrltail;
	char *ctrlbuf;
	dma_addr_t ctrlbuf_dma;
	unsigned long last_ctrl;
	struct urb *urbout;
	struct hid_output_fifo out[256];
	unsigned char outhead;
	unsigned char outtail;
	char *outbuf;
	dma_addr_t outbuf_dma;
	unsigned long last_out;
	struct mutex mutex;
	spinlock_t lock;
	unsigned long iofl;
	struct timer_list io_retry;
	unsigned long stop_retry;
	unsigned int retry_delay;
	struct work_struct reset_work;
	wait_queue_head_t wait;
};

struct hid_class_descriptor {
	__u8 bDescriptorType;
	__le16 wDescriptorLength;
} __attribute__((packed));

struct hid_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdHID;
	__u8 bCountryCode;
	__u8 bNumDescriptors;
	struct hid_class_descriptor desc[1];
} __attribute__((packed));

struct qcom_apcs_ipc_data {
	int offset;
	char *clk_name;
};

struct qcom_apcs_ipc {
	struct mbox_controller mbox;
	struct mbox_chan mbox_chans[32];
	struct regmap *regmap;
	unsigned long offset;
	struct platform_device *clk;
};

typedef void (*btf_trace_devfreq_frequency)(void *, struct devfreq *, unsigned long, unsigned long);

typedef void (*btf_trace_devfreq_monitor)(void *, struct devfreq *);

enum devfreq_parent_dev_type {
	DEVFREQ_PARENT_DEV = 0,
	CPUFREQ_PARENT_DEV = 1,
};

struct trace_event_raw_devfreq_frequency {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	unsigned long freq;
	unsigned long prev_freq;
	unsigned long busy_time;
	unsigned long total_time;
	char __data[0];
};

struct trace_event_raw_devfreq_monitor {
	struct trace_entry ent;
	unsigned long freq;
	unsigned long busy_time;
	unsigned long total_time;
	unsigned int polling_ms;
	u32 __data_loc_dev_name;
	char __data[0];
};

struct trace_event_data_offsets_devfreq_frequency {
	u32 dev_name;
};

struct trace_event_data_offsets_devfreq_monitor {
	u32 dev_name;
};

struct devfreq_freqs {
	unsigned long old;
	unsigned long new;
};

struct devfreq_notifier_devres {
	struct devfreq *devfreq;
	struct notifier_block *nb;
	unsigned int list;
};

struct devfreq_passive_data {
	struct devfreq *parent;
	int (*get_target_freq)(struct devfreq *, unsigned long *);
	enum devfreq_parent_dev_type parent_type;
	struct devfreq *this;
	struct notifier_block nb;
	struct list_head cpu_data_list;
};

typedef void (*btf_trace_mc_event)(void *, const unsigned int, const char *, const char *, const int, const u8, const s8, const s8, const s8, unsigned long, const u8, unsigned long, const char *);

typedef void (*btf_trace_arm_event)(void *, const struct cper_sec_proc_arm *);

typedef void (*btf_trace_non_standard_event)(void *, const guid_t *, const guid_t *, const char *, const u8, const u8 *, const u32);

typedef void (*btf_trace_aer_event)(void *, const char *, const u32, const u8, const u8, struct aer_header_log_regs *);

typedef void (*btf_trace_memory_failure_event)(void *, unsigned long, int, int);

struct trace_event_raw_mc_event {
	struct trace_entry ent;
	unsigned int error_type;
	u32 __data_loc_msg;
	u32 __data_loc_label;
	u16 error_count;
	u8 mc_index;
	s8 top_layer;
	s8 middle_layer;
	s8 lower_layer;
	long address;
	u8 grain_bits;
	long syndrome;
	u32 __data_loc_driver_detail;
	char __data[0];
};

struct trace_event_raw_arm_event {
	struct trace_entry ent;
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
	u8 affinity;
	char __data[0];
};

struct trace_event_raw_non_standard_event {
	struct trace_entry ent;
	char sec_type[16];
	char fru_id[16];
	u32 __data_loc_fru_text;
	u8 sev;
	u32 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_aer_event {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 status;
	u8 severity;
	u8 tlp_header_valid;
	u32 tlp_header[4];
	char __data[0];
};

struct trace_event_raw_memory_failure_event {
	struct trace_entry ent;
	unsigned long pfn;
	int type;
	int result;
	char __data[0];
};

struct trace_event_data_offsets_mc_event {
	u32 msg;
	u32 label;
	u32 driver_detail;
};

struct trace_event_data_offsets_non_standard_event {
	u32 fru_text;
	u32 buf;
};

struct trace_event_data_offsets_aer_event {
	u32 dev_name;
};

struct trace_event_data_offsets_arm_event {};

struct trace_event_data_offsets_memory_failure_event {};

enum timer_tread_format {
	TREAD_FORMAT_NONE = 0,
	TREAD_FORMAT_TIME64 = 1,
	TREAD_FORMAT_TIME32 = 2,
};

enum {
	SNDRV_TIMER_IOCTL_GPARAMS32 = 1077695492,
	SNDRV_TIMER_IOCTL_INFO32 = 2162185233,
	SNDRV_TIMER_IOCTL_STATUS_COMPAT32 = 1079530516,
	SNDRV_TIMER_IOCTL_STATUS_COMPAT64 = 1080054804,
};

struct snd_timer_instance {
	struct snd_timer *timer;
	char *owner;
	unsigned int flags;
	void *private_data;
	void (*private_free)(struct snd_timer_instance *);
	void (*callback)(struct snd_timer_instance *, unsigned long, unsigned long);
	void (*ccallback)(struct snd_timer_instance *, int, struct timespec64 *, unsigned long);
	void (*disconnect)(struct snd_timer_instance *);
	void *callback_data;
	unsigned long ticks;
	unsigned long cticks;
	unsigned long pticks;
	unsigned long resolution;
	unsigned long lost;
	int slave_class;
	unsigned int slave_id;
	struct list_head open_list;
	struct list_head active_list;
	struct list_head ack_list;
	struct list_head slave_list_head;
	struct list_head slave_active_head;
	struct snd_timer_instance *master;
};

struct snd_timer_system_private {
	struct timer_list tlist;
	struct snd_timer *snd_timer;
	unsigned long last_expires;
	unsigned long last_jiffies;
	unsigned long correction;
};

struct snd_timer_gparams32 {
	struct snd_timer_id tid;
	u32 period_num;
	u32 period_den;
	unsigned char reserved[32];
};

struct snd_timer_gparams {
	struct snd_timer_id tid;
	unsigned long period_num;
	unsigned long period_den;
	unsigned char reserved[32];
};

struct snd_timer_info32 {
	u32 flags;
	s32 card;
	unsigned char id[64];
	unsigned char name[80];
	u32 reserved0;
	u32 resolution;
	unsigned char reserved[64];
};

struct snd_timer_read;

struct snd_timer_tread64;

struct snd_timer_user {
	struct snd_timer_instance *timeri;
	int tread;
	unsigned long ticks;
	unsigned long overrun;
	int qhead;
	int qtail;
	int qused;
	int queue_size;
	bool disconnected;
	struct snd_timer_read *queue;
	struct snd_timer_tread64 *tqueue;
	spinlock_t qlock;
	unsigned long last_resolution;
	unsigned int filter;
	struct timespec64 tstamp;
	wait_queue_head_t qchange_sleep;
	struct snd_fasync *fasync;
	struct mutex ioctl_lock;
};

struct snd_timer_read {
	unsigned int resolution;
	unsigned int ticks;
};

struct snd_timer_tread64 {
	int event;
	u8 pad1[4];
	s64 tstamp_sec;
	s64 tstamp_nsec;
	unsigned int val;
	u8 pad2[4];
};

struct snd_timer_select {
	struct snd_timer_id id;
	unsigned char reserved[32];
};

struct snd_timer_params {
	unsigned int flags;
	unsigned int ticks;
	unsigned int queue_size;
	unsigned int reserved0;
	unsigned int filter;
	unsigned char reserved[60];
};

struct snd_timer_ginfo {
	struct snd_timer_id tid;
	unsigned int flags;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	unsigned long reserved0;
	unsigned long resolution;
	unsigned long resolution_min;
	unsigned long resolution_max;
	unsigned int clients;
	unsigned char reserved[32];
};

struct snd_timer_info {
	unsigned int flags;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	unsigned long reserved0;
	unsigned long resolution;
	unsigned char reserved[64];
};

struct snd_timer_gstatus {
	struct snd_timer_id tid;
	unsigned long resolution;
	unsigned long resolution_num;
	unsigned long resolution_den;
	unsigned char reserved[32];
};

struct snd_timer_tread32 {
	int event;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	unsigned int val;
};

struct snd_timer_status32 {
	s32 tstamp_sec;
	s32 tstamp_nsec;
	unsigned int resolution;
	unsigned int lost;
	unsigned int overrun;
	unsigned int queue;
	unsigned char reserved[64];
};

struct snd_timer_status64 {
	s64 tstamp_sec;
	s64 tstamp_nsec;
	unsigned int resolution;
	unsigned int lost;
	unsigned int overrun;
	unsigned int queue;
	unsigned char reserved[64];
};

enum {
	ETHTOOL_TCP_DATA_SPLIT_UNKNOWN = 0,
	ETHTOOL_TCP_DATA_SPLIT_DISABLED = 1,
	ETHTOOL_TCP_DATA_SPLIT_ENABLED = 2,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	ETHTOOL_A_RINGS_RX_BUF_LEN = 10,
	ETHTOOL_A_RINGS_TCP_DATA_SPLIT = 11,
	ETHTOOL_A_RINGS_CQE_SIZE = 12,
	ETHTOOL_A_RINGS_TX_PUSH = 13,
	ETHTOOL_A_RINGS_RX_PUSH = 14,
	ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN = 15,
	ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX = 16,
	__ETHTOOL_A_RINGS_CNT = 17,
	ETHTOOL_A_RINGS_MAX = 16,
};

enum ethtool_supported_ring_param {
	ETHTOOL_RING_USE_RX_BUF_LEN = 1,
	ETHTOOL_RING_USE_CQE_SIZE = 2,
	ETHTOOL_RING_USE_TX_PUSH = 4,
	ETHTOOL_RING_USE_RX_PUSH = 8,
	ETHTOOL_RING_USE_TX_PUSH_BUF_LEN = 16,
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
	struct kernel_ethtool_ringparam kernel_ringparam;
	u32 supported_ring_params;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
	struct list_head quarantine;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

enum devlink_param_generic_id {
	DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET = 0,
	DEVLINK_PARAM_GENERIC_ID_MAX_MACS = 1,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV = 2,
	DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT = 3,
	DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI = 4,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX = 5,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN = 6,
	DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY = 7,
	DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE = 8,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE = 9,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_REMOTE_DEV_RESET = 10,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH = 11,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA = 12,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET = 13,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_IWARP = 14,
	DEVLINK_PARAM_GENERIC_ID_IO_EQ_SIZE = 15,
	DEVLINK_PARAM_GENERIC_ID_EVENT_EQ_SIZE = 16,
	__DEVLINK_PARAM_GENERIC_ID_MAX = 17,
	DEVLINK_PARAM_GENERIC_ID_MAX = 16,
};

struct devlink_param_item {
	struct list_head list;
	const struct devlink_param *param;
	union devlink_param_value driverinit_value;
	bool driverinit_value_valid;
	union devlink_param_value driverinit_value_new;
	bool driverinit_value_new_valid;
};

enum {
	SVC_HANDSHAKE_TO = 1250,
};

enum handshake_handler_class {
	HANDSHAKE_HANDLER_CLASS_NONE = 0,
	HANDSHAKE_HANDLER_CLASS_TLSHD = 1,
	HANDSHAKE_HANDLER_CLASS_MAX = 2,
};

struct compat_sigcontext {
	compat_ulong_t trap_no;
	compat_ulong_t error_code;
	compat_ulong_t oldmask;
	compat_ulong_t arm_r0;
	compat_ulong_t arm_r1;
	compat_ulong_t arm_r2;
	compat_ulong_t arm_r3;
	compat_ulong_t arm_r4;
	compat_ulong_t arm_r5;
	compat_ulong_t arm_r6;
	compat_ulong_t arm_r7;
	compat_ulong_t arm_r8;
	compat_ulong_t arm_r9;
	compat_ulong_t arm_r10;
	compat_ulong_t arm_fp;
	compat_ulong_t arm_ip;
	compat_ulong_t arm_sp;
	compat_ulong_t arm_lr;
	compat_ulong_t arm_pc;
	compat_ulong_t arm_cpsr;
	compat_ulong_t fault_address;
};

struct compat_ucontext {
	compat_ulong_t uc_flags;
	compat_uptr_t uc_link;
	compat_stack_t uc_stack;
	struct compat_sigcontext uc_mcontext;
	compat_sigset_t uc_sigmask;
	int __unused[30];
	compat_ulong_t uc_regspace[128];
};

struct compat_sigframe {
	struct compat_ucontext uc;
	compat_ulong_t retcode[2];
};

struct compat_rt_sigframe {
	struct compat_siginfo info;
	struct compat_sigframe sig;
};

struct compat_user_vfp {
	compat_u64 fpregs[32];
	compat_ulong_t fpscr;
};

struct compat_user_vfp_exc {
	compat_ulong_t fpexc;
	compat_ulong_t fpinst;
	compat_ulong_t fpinst2;
};

struct compat_vfp_sigframe {
	compat_ulong_t magic;
	compat_ulong_t size;
	struct compat_user_vfp ufp;
	struct compat_user_vfp_exc ufp_exc;
};

struct compat_aux_sigframe {
	struct compat_vfp_sigframe vfp;
	unsigned long end_magic;
};

union __fpsimd_vreg {
	__uint128_t raw;
	struct {
		u64 lo;
		u64 hi;
	};
};

struct arch_hibernate_hdr_invariants {
	char uts_version[65];
};

struct arch_hibernate_hdr {
	struct arch_hibernate_hdr_invariants invariants;
	phys_addr_t ttbr1_el1;
	void (*reenter_kernel)();
	phys_addr_t __hyp_stub_vectors;
	u64 sleep_cpu_mpidr;
};

typedef void (*btf_trace_kvm_userspace_exit)(void *, __u32, int);

typedef void (*btf_trace_kvm_vcpu_wakeup)(void *, __u64, bool, bool);

typedef void (*btf_trace_kvm_set_irq)(void *, unsigned int, int, int);

typedef void (*btf_trace_kvm_ack_irq)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_kvm_mmio)(void *, int, int, u64, void *);

typedef void (*btf_trace_kvm_fpu)(void *, int);

typedef void (*btf_trace_kvm_halt_poll_ns)(void *, bool, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kvm_dirty_ring_push)(void *, struct kvm_dirty_ring *, u32, u64);

typedef void (*btf_trace_kvm_dirty_ring_reset)(void *, struct kvm_dirty_ring *);

typedef void (*btf_trace_kvm_dirty_ring_exit)(void *, struct kvm_vcpu___2 *);

typedef void (*btf_trace_kvm_unmap_hva_range)(void *, unsigned long, unsigned long);

typedef void (*btf_trace_kvm_set_spte_hva)(void *, unsigned long);

typedef void (*btf_trace_kvm_age_hva)(void *, unsigned long, unsigned long);

typedef void (*btf_trace_kvm_test_age_hva)(void *, unsigned long);

union kvm_mmu_notifier_arg {
	pte_t pte;
};

enum kvm_mr_change {
	KVM_MR_CREATE = 0,
	KVM_MR_DELETE = 1,
	KVM_MR_MOVE = 2,
	KVM_MR_FLAGS_ONLY = 3,
};

struct trace_event_raw_kvm_userspace_exit {
	struct trace_entry ent;
	__u32 reason;
	int errno;
	char __data[0];
};

struct trace_event_raw_kvm_vcpu_wakeup {
	struct trace_entry ent;
	__u64 ns;
	bool waited;
	bool valid;
	char __data[0];
};

struct trace_event_raw_kvm_set_irq {
	struct trace_entry ent;
	unsigned int gsi;
	int level;
	int irq_source_id;
	char __data[0];
};

struct trace_event_raw_kvm_ack_irq {
	struct trace_entry ent;
	unsigned int irqchip;
	unsigned int pin;
	char __data[0];
};

struct trace_event_raw_kvm_mmio {
	struct trace_entry ent;
	u32 type;
	u32 len;
	u64 gpa;
	u64 val;
	char __data[0];
};

struct trace_event_raw_kvm_fpu {
	struct trace_entry ent;
	u32 load;
	char __data[0];
};

struct trace_event_raw_kvm_halt_poll_ns {
	struct trace_entry ent;
	bool grow;
	unsigned int vcpu_id;
	unsigned int new;
	unsigned int old;
	char __data[0];
};

struct trace_event_raw_kvm_dirty_ring_push {
	struct trace_entry ent;
	int index;
	u32 dirty_index;
	u32 reset_index;
	u32 slot;
	u64 offset;
	char __data[0];
};

struct trace_event_raw_kvm_dirty_ring_reset {
	struct trace_entry ent;
	int index;
	u32 dirty_index;
	u32 reset_index;
	char __data[0];
};

struct trace_event_raw_kvm_dirty_ring_exit {
	struct trace_entry ent;
	int vcpu_id;
	char __data[0];
};

struct trace_event_raw_kvm_unmap_hva_range {
	struct trace_entry ent;
	unsigned long start;
	unsigned long end;
	char __data[0];
};

struct trace_event_raw_kvm_set_spte_hva {
	struct trace_entry ent;
	unsigned long hva;
	char __data[0];
};

struct trace_event_raw_kvm_age_hva {
	struct trace_entry ent;
	unsigned long start;
	unsigned long end;
	char __data[0];
};

struct trace_event_raw_kvm_test_age_hva {
	struct trace_entry ent;
	unsigned long hva;
	char __data[0];
};

typedef u64 hpa_t;

struct kvm_userspace_memory_region {
	__u32 slot;
	__u32 flags;
	__u64 guest_phys_addr;
	__u64 memory_size;
	__u64 userspace_addr;
};

struct kvm_memslot_iter {
	struct kvm_memslots *slots;
	struct rb_node *node;
	struct kvm_memory_slot *slot;
};

typedef unsigned long hva_t;

struct kvm_dirty_log {
	__u32 slot;
	__u32 padding1;
	union {
		void __attribute__((btf_type_tag("user"))) *dirty_bitmap;
		__u64 padding2;
	};
};

struct kvm_clear_dirty_log {
	__u32 slot;
	__u32 num_pages;
	__u64 first_page;
	union {
		void __attribute__((btf_type_tag("user"))) *dirty_bitmap;
		__u64 padding2;
	};
};

struct kvm_gfn_range;

typedef bool (*hva_handler_t)(struct kvm___2 *, struct kvm_gfn_range *);

typedef void (*on_lock_fn_t)(struct kvm___2 *, unsigned long, unsigned long);

typedef void (*on_unlock_fn_t)(struct kvm___2 *);

struct kvm_hva_range {
	unsigned long start;
	unsigned long end;
	union kvm_mmu_notifier_arg arg;
	hva_handler_t handler;
	on_lock_fn_t on_lock;
	on_unlock_fn_t on_unlock;
	bool flush_on_ret;
	bool may_block;
};

struct kvm_gfn_range {
	struct kvm_memory_slot *slot;
	gfn_t start;
	gfn_t end;
	union kvm_mmu_notifier_arg arg;
	bool may_block;
};

struct trace_event_data_offsets_kvm_userspace_exit {};

struct trace_event_data_offsets_kvm_vcpu_wakeup {};

struct trace_event_data_offsets_kvm_set_irq {};

struct trace_event_data_offsets_kvm_ack_irq {};

struct trace_event_data_offsets_kvm_mmio {};

struct trace_event_data_offsets_kvm_fpu {};

struct trace_event_data_offsets_kvm_halt_poll_ns {};

struct trace_event_data_offsets_kvm_dirty_ring_push {};

struct trace_event_data_offsets_kvm_dirty_ring_reset {};

struct trace_event_data_offsets_kvm_dirty_ring_exit {};

struct trace_event_data_offsets_kvm_unmap_hva_range {};

struct trace_event_data_offsets_kvm_set_spte_hva {};

struct trace_event_data_offsets_kvm_age_hva {};

struct trace_event_data_offsets_kvm_test_age_hva {};

struct kvm_host_map {
	struct page *page;
	void *hva;
	kvm_pfn_t pfn;
	kvm_pfn_t gfn;
};

struct gfn_to_hva_cache {
	u64 generation;
	gpa_t gpa;
	unsigned long hva;
	unsigned long len;
	struct kvm_memory_slot *memslot;
};

typedef int (*kvm_vm_thread_fn_t)(struct kvm___2 *, uintptr_t);

struct kvm_vm_worker_thread_context {
	struct kvm___2 *kvm;
	struct task_struct *parent;
	struct completion init_done;
	kvm_vm_thread_fn_t thread_fn;
	uintptr_t data;
	int err;
};

struct kvm_irq_routing {
	__u32 nr;
	__u32 flags;
	struct kvm_irq_routing_entry entries[0];
};

struct kvm_create_device {
	__u32 type;
	__u32 fd;
	__u32 flags;
};

struct kvm_signal_mask {
	__u32 len;
	__u8 sigset[0];
};

struct snapshot_data {
	struct snapshot_handle handle;
	int swap;
	int mode;
	bool frozen;
	bool ready;
	bool platform_support;
	bool free_bitmaps;
	dev_t dev;
};

struct compat_resume_swap_area {
	compat_loff_t offset;
	u32 dev;
} __attribute__((packed));

struct resume_swap_area {
	__kernel_loff_t offset;
	__u32 dev;
} __attribute__((packed));

enum kcmp_type {
	KCMP_FILE = 0,
	KCMP_VM = 1,
	KCMP_FILES = 2,
	KCMP_FS = 3,
	KCMP_SIGHAND = 4,
	KCMP_IO = 5,
	KCMP_SYSVSEM = 6,
	KCMP_EPOLL_TFD = 7,
	KCMP_TYPES = 8,
};

struct kcmp_epoll_slot {
	__u32 efd;
	__u32 tfd;
	__u32 toff;
};

struct misc_res {
	u64 max;
	atomic64_t usage;
	atomic64_t events;
};

struct misc_cg {
	struct cgroup_subsys_state css;
	struct cgroup_file events_file;
	struct misc_res res[0];
};

enum misc_res_type {
	MISC_CG_RES_TYPES = 0,
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
	unsigned long caller;
	cpu_stop_fn_t fn;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

enum bpf_perf_event_type {
	BPF_PERF_EVENT_UNSPEC = 0,
	BPF_PERF_EVENT_UPROBE = 1,
	BPF_PERF_EVENT_URETPROBE = 2,
	BPF_PERF_EVENT_KPROBE = 3,
	BPF_PERF_EVENT_KRETPROBE = 4,
	BPF_PERF_EVENT_TRACEPOINT = 5,
	BPF_PERF_EVENT_EVENT = 6,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

typedef u64 (*btf_bpf_sys_bpf)(int, union bpf_attr *, u32);

typedef u64 (*btf_bpf_sys_close)(u32);

typedef u64 (*btf_bpf_kallsyms_lookup_name)(const char *, int, int, u64 *);

struct bpf_tracing_link {
	struct bpf_tramp_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
};

struct bpf_perf_link {
	struct bpf_link link;
	struct file *perf_file;
};

struct bpf_prog_kstats {
	u64 nsecs;
	u64 cnt;
	u64 misses;
};

typedef int fpi_t;

typedef void (*btf_trace_test_pages_isolated)(void *, unsigned long, unsigned long, unsigned long);

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	unsigned long start_pfn;
	unsigned long end_pfn;
	unsigned long fin_pfn;
	char __data[0];
};

struct trace_event_data_offsets_test_pages_isolated {};

struct dentry_stat_t {
	long nr_dentry;
	long nr_unused;
	long age_limit;
	long want_pages;
	long nr_negative;
	long dummy;
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

struct external_name {
	union {
		atomic_t count;
		struct callback_head head;
	} u;
	unsigned char name[0];
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct select_data {
	struct dentry *start;
	union {
		long found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	unsigned long long blocknr;
};

struct fatent_ra {
	sector_t cur;
	sector_t limit;
	unsigned int ra_blocks;
	sector_t ra_advance;
	sector_t ra_next;
	sector_t ra_limit;
};

typedef void (*btf_trace_nfs_set_inode_stale)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_revalidate_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_revalidate_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_invalidate_mapping_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_invalidate_mapping_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_getattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_getattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_setattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_fsync_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_fsync_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_access_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_set_cache_invalid)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_readdir_force_readdirplus)(void *, const struct inode *);

typedef void (*btf_trace_nfs_readdir_cache_fill_done)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_readdir_uncached_done)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_access_exit)(void *, const struct inode *, unsigned int, unsigned int, int);

typedef void (*btf_trace_nfs_size_truncate)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_wcc)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_update)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_grow)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_readdir_invalidate_cache_range)(void *, const struct inode *, loff_t, loff_t);

typedef void (*btf_trace_nfs_readdir_cache_fill)(void *, const struct file *, const __be32 *, u64, unsigned long, unsigned int);

typedef void (*btf_trace_nfs_readdir_uncached)(void *, const struct file *, const __be32 *, u64, unsigned long, unsigned int);

typedef void (*btf_trace_nfs_lookup_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_revalidate_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_revalidate_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_readdir_lookup)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_readdir_lookup_revalidate_failed)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_readdir_lookup_revalidate)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_atomic_open_enter)(void *, const struct inode *, const struct nfs_open_context *, unsigned int);

typedef void (*btf_trace_nfs_atomic_open_exit)(void *, const struct inode *, const struct nfs_open_context *, unsigned int, int);

typedef void (*btf_trace_nfs_create_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_create_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_mknod_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mknod_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mkdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mkdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rmdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rmdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_remove_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_remove_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_unlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_unlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_symlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_symlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_link_enter)(void *, const struct inode *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_link_exit)(void *, const struct inode *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rename_enter)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rename_exit)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_rename)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_unlink)(void *, const struct nfs_unlinkdata *, int);

typedef void (*btf_trace_nfs_aop_readpage)(void *, const struct inode *, struct folio *);

typedef void (*btf_trace_nfs_aop_readpage_done)(void *, const struct inode *, struct folio *, int);

typedef void (*btf_trace_nfs_writeback_folio)(void *, const struct inode *, struct folio *);

typedef void (*btf_trace_nfs_writeback_folio_done)(void *, const struct inode *, struct folio *, int);

typedef void (*btf_trace_nfs_invalidate_folio)(void *, const struct inode *, struct folio *);

typedef void (*btf_trace_nfs_launder_folio_done)(void *, const struct inode *, struct folio *, int);

typedef void (*btf_trace_nfs_aop_readahead)(void *, const struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_nfs_aop_readahead_done)(void *, const struct inode *, unsigned int, int);

typedef void (*btf_trace_nfs_initiate_read)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_short)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_pgio_error)(void *, const struct nfs_pgio_header *, int, loff_t);

typedef void (*btf_trace_nfs_initiate_write)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_writeback_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_write_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_comp_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_commit_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_initiate_commit)(void *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_commit_done)(void *, const struct rpc_task *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_direct_commit_complete)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_resched_write)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_complete)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_completion)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_schedule_iovec)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_reschedule_io)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_fh_to_dentry)(void *, const struct super_block *, const struct nfs_fh *, u64, int);

typedef void (*btf_trace_nfs_mount_assign)(void *, const char *, const char *);

typedef void (*btf_trace_nfs_mount_option)(void *, const struct fs_parameter *);

typedef void (*btf_trace_nfs_mount_path)(void *, const char *);

typedef void (*btf_trace_nfs_xdr_status)(void *, const struct xdr_stream *, int);

typedef void (*btf_trace_nfs_xdr_bad_filehandle)(void *, const struct xdr_stream *, int);

struct trace_event_raw_nfs_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event_done {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	unsigned long nfsi_flags;
	unsigned long cache_validity;
	char __data[0];
};

struct trace_event_raw_nfs_access_exit {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	unsigned long nfsi_flags;
	unsigned long cache_validity;
	unsigned int mask;
	unsigned int permitted;
	char __data[0];
};

struct trace_event_raw_nfs_update_size_class {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t cur_size;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_nfs_inode_range_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t range_start;
	loff_t range_end;
	char __data[0];
};

struct trace_event_raw_nfs_readdir_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char verifier[8];
	u64 cookie;
	unsigned long index;
	unsigned int dtsize;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event {
	struct trace_entry ent;
	unsigned long flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event_done {
	struct trace_entry ent;
	unsigned long error;
	unsigned long flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_enter {
	struct trace_entry ent;
	unsigned long flags;
	unsigned long fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_exit {
	struct trace_entry ent;
	unsigned long error;
	unsigned long flags;
	unsigned long fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_create_enter {
	struct trace_entry ent;
	unsigned long flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_create_exit {
	struct trace_entry ent;
	unsigned long error;
	unsigned long flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event {
	struct trace_entry ent;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event_done {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_link_enter {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_link_exit {
	struct trace_entry ent;
	unsigned long error;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event {
	struct trace_entry ent;
	dev_t dev;
	u64 old_dir;
	u64 new_dir;
	u32 __data_loc_old_name;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event_done {
	struct trace_entry ent;
	dev_t dev;
	unsigned long error;
	u64 old_dir;
	u32 __data_loc_old_name;
	u64 new_dir;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_sillyrename_unlink {
	struct trace_entry ent;
	dev_t dev;
	unsigned long error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_folio_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_folio_event_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	int ret;
	u64 fileid;
	u64 version;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_aop_readahead {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t offset;
	unsigned int nr_pages;
	char __data[0];
};

struct trace_event_raw_nfs_aop_readahead_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	int ret;
	u64 fileid;
	u64 version;
	loff_t offset;
	unsigned int nr_pages;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_read {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_short {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_pgio_error {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	loff_t pos;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_write {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	unsigned long stable;
	char __data[0];
};

struct trace_event_raw_nfs_writeback_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	int error;
	unsigned long stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_page_error_class {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	unsigned int count;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_commit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_commit_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	int error;
	unsigned long stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_direct_req_class {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u32 fhandle;
	loff_t offset;
	ssize_t count;
	ssize_t bytes_left;
	ssize_t error;
	int flags;
	char __data[0];
};

struct trace_event_raw_nfs_fh_to_dentry {
	struct trace_entry ent;
	int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	char __data[0];
};

struct trace_event_raw_nfs_mount_assign {
	struct trace_entry ent;
	u32 __data_loc_option;
	u32 __data_loc_value;
	char __data[0];
};

struct trace_event_raw_nfs_mount_option {
	struct trace_entry ent;
	u32 __data_loc_option;
	char __data[0];
};

struct trace_event_raw_nfs_mount_path {
	struct trace_entry ent;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_nfs_xdr_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	unsigned long error;
	u32 __data_loc_program;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_data_offsets_nfs_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_lookup_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_rename_event {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_rename_event_done {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_sillyrename_unlink {
	u32 name;
};

struct trace_event_data_offsets_nfs_mount_assign {
	u32 option;
	u32 value;
};

struct trace_event_data_offsets_nfs_mount_option {
	u32 option;
};

struct trace_event_data_offsets_nfs_mount_path {
	u32 path;
};

struct trace_event_data_offsets_nfs_xdr_event {
	u32 program;
	u32 procedure;
};

struct trace_event_data_offsets_nfs_inode_event {};

struct trace_event_data_offsets_nfs_inode_event_done {};

struct trace_event_data_offsets_nfs_access_exit {};

struct trace_event_data_offsets_nfs_update_size_class {};

struct trace_event_data_offsets_nfs_inode_range_event {};

struct trace_event_data_offsets_nfs_readdir_event {};

struct trace_event_data_offsets_nfs_folio_event {};

struct trace_event_data_offsets_nfs_folio_event_done {};

struct trace_event_data_offsets_nfs_aop_readahead {};

struct trace_event_data_offsets_nfs_aop_readahead_done {};

struct trace_event_data_offsets_nfs_initiate_read {};

struct trace_event_data_offsets_nfs_readpage_done {};

struct trace_event_data_offsets_nfs_readpage_short {};

struct trace_event_data_offsets_nfs_pgio_error {};

struct trace_event_data_offsets_nfs_initiate_write {};

struct trace_event_data_offsets_nfs_writeback_done {};

struct trace_event_data_offsets_nfs_page_error_class {};

struct trace_event_data_offsets_nfs_initiate_commit {};

struct trace_event_data_offsets_nfs_commit_done {};

struct trace_event_data_offsets_nfs_direct_req_class {};

struct trace_event_data_offsets_nfs_fh_to_dentry {};

struct getdents_callback___2 {
	struct dir_context ctx;
	char *name;
	u64 ino;
	int found;
	int sequence;
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum {
	SKCIPHER_WALK_PHYS = 1,
	SKCIPHER_WALK_SLOW = 2,
	SKCIPHER_WALK_COPY = 4,
	SKCIPHER_WALK_DIFF = 8,
	SKCIPHER_WALK_SLEEP = 16,
};

struct skcipher_walk_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	u8 *data;
	u8 buffer[0];
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct crypto_istat_cipher {
	atomic64_t encrypt_cnt;
	atomic64_t encrypt_tlen;
	atomic64_t decrypt_cnt;
	atomic64_t decrypt_tlen;
	atomic64_t err_cnt;
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_link {
	int (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
};

enum {
	CRYPTO_MSG_BASE = 16,
	CRYPTO_MSG_NEWALG = 16,
	CRYPTO_MSG_DELALG = 17,
	CRYPTO_MSG_UPDATEALG = 18,
	CRYPTO_MSG_GETALG = 19,
	CRYPTO_MSG_DELRNG = 20,
	CRYPTO_MSG_GETSTAT = 21,
	__CRYPTO_MSG_MAX = 22,
};

struct crypto_user_alg {
	char cru_name[64];
	char cru_driver_name[64];
	char cru_module_name[64];
	__u32 cru_type;
	__u32 cru_mask;
	__u32 cru_refcnt;
	__u32 cru_flags;
};

struct crypto_report_larval {
	char type[64];
};

struct crypto_report_cipher {
	char type[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
};

struct crypto_dump_info {
	struct sk_buff *in_skb;
	struct sk_buff *out_skb;
	u32 nlmsg_seq;
	u16 nlmsg_flags;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
	void (*probe)(dev_t);
};

enum {
	IOU_POLL_DONE = 0,
	IOU_POLL_NO_ACTION = 1,
	IOU_POLL_REMOVE_POLL_USE_RES = 2,
	IOU_POLL_REISSUE = 3,
};

struct io_poll_update {
	struct file *file;
	u64 old_user_data;
	u64 new_user_data;
	__poll_t events;
	bool update_events;
	bool update_user_data;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int nr_entries;
	int error;
	bool owning;
	__poll_t result_mask;
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
	struct module *module;
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

struct intmux_irqchip_data {
	u32 saved_reg;
	int chanidx;
	int irq;
	struct irq_domain *domain;
};

struct intmux_data {
	raw_spinlock_t lock;
	void *regs;
	struct clk *ipg_clk;
	int channum;
	struct intmux_irqchip_data irqchip_data[0];
};

struct mvebu_a3700_comphy_conf {
	unsigned int lane;
	enum phy_mode mode;
	int submode;
};

struct gbe_phy_init_data_fix {
	u16 addr;
	u16 value;
};

struct mvebu_a3700_comphy_priv;

struct mvebu_a3700_comphy_lane {
	struct mvebu_a3700_comphy_priv *priv;
	struct device *dev;
	unsigned int id;
	enum phy_mode mode;
	int submode;
	bool invert_tx;
	bool invert_rx;
};

struct mvebu_a3700_comphy_priv {
	void *comphy_regs;
	void *lane0_phy_regs;
	void *lane1_phy_regs;
	void *lane2_phy_indirect;
	spinlock_t lock;
	bool xtal_is_40m;
};

struct exynos_irq_chip {
	struct irq_chip chip;
	u32 eint_con;
	u32 eint_mask;
	u32 eint_pend;
	u32 *eint_wake_mask_value;
	u32 eint_wake_mask_reg;
	void (*set_eint_wakeup_mask)(struct samsung_pinctrl_drv_data *, struct exynos_irq_chip *);
};

struct exynos_eint_gpio_save {
	u32 eint_con;
	u32 eint_fltcon0;
	u32 eint_fltcon1;
	u32 eint_mask;
};

struct exynos_muxed_weint_data {
	unsigned int nr_banks;
	struct samsung_pin_bank *banks[0];
};

struct exynos_weint_data {
	unsigned int irq;
	struct samsung_pin_bank *bank;
};

struct iproc_gpio_chip {
	struct gpio_chip gc;
	spinlock_t lock;
	struct device *dev;
	void *base;
	void *intr;
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

struct acpiphp_attention_info {
	int (*set_attn)(struct hotplug_slot *, u8);
	int (*get_attn)(struct hotplug_slot *, u8 *);
	struct module *owner;
};

struct altera_msi {
	unsigned long used[1];
	struct mutex lock;
	struct platform_device *pdev;
	struct irq_domain *msi_domain;
	struct irq_domain *inner_domain;
	void *csr_base;
	void *vector_base;
	phys_addr_t vector_phy;
	u32 num_of_vectors;
	int irq;
};

struct acpi_power_resource;

struct acpi_power_resource_entry {
	struct list_head node;
	struct acpi_power_resource *resource;
};

struct acpi_power_resource {
	struct acpi_device device;
	struct list_head list_node;
	u32 system_level;
	u32 order;
	unsigned int ref_count;
	u8 state;
	struct mutex resource_lock;
	struct list_head dependents;
};

struct acpi_power_dependent_device {
	struct device *dev;
	struct list_head node;
};

struct acpi_fadt_info {
	const char *name;
	u16 address64;
	u16 address32;
	u16 length;
	u8 default_length;
	u8 flags;
};

struct acpi_fadt_pm_info {
	struct acpi_generic_address *target;
	u16 source;
	u8 register_num;
};

struct s5_hw_clk {
	struct clk_hw hw;
	void *reg;
};

struct s5_pll_conf {
	unsigned long freq;
	u8 div;
	bool rot_ena;
	u8 rot_sel;
	u8 rot_dir;
	u8 pre_div;
};

struct s5_clk_data {
	void *base;
	struct s5_hw_clk s5_hw[9];
};

struct bcm2835_cprman;

struct bcm2835_clk_desc {
	struct clk_hw * (*clk_register)(struct bcm2835_cprman *, const void *);
	unsigned int supported;
	const void *data;
};

struct bcm2835_cprman {
	struct device *dev;
	void *regs;
	spinlock_t regs_lock;
	unsigned int soc;
	const char *real_parent_names[7];
	struct clk_hw_onecell_data onecell;
};

struct bcm2835_pll_ana_bits {
	u32 mask0;
	u32 set0;
	u32 mask1;
	u32 set1;
	u32 mask3;
	u32 set3;
	u32 fb_prediv_mask;
};

struct cprman_plat_data {
	unsigned int soc;
};

struct bcm2835_pll_data;

struct bcm2835_pll {
	struct clk_hw hw;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_pll_data *data;
};

struct bcm2835_pll_data {
	const char *name;
	u32 cm_ctrl_reg;
	u32 a2w_ctrl_reg;
	u32 frac_reg;
	u32 ana_reg_base;
	u32 reference_enable_mask;
	u32 lock_mask;
	u32 flags;
	const struct bcm2835_pll_ana_bits *ana;
	unsigned long min_rate;
	unsigned long max_rate;
	unsigned long max_fb_rate;
};

struct bcm2835_pll_divider_data;

struct bcm2835_pll_divider {
	struct clk_divider div;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_pll_divider_data *data;
};

struct bcm2835_pll_divider_data {
	const char *name;
	const char *source_pll;
	u32 cm_reg;
	u32 a2w_reg;
	u32 load_mask;
	u32 hold_mask;
	u32 fixed_divider;
	u32 flags;
};

struct bcm2835_clock_data;

struct bcm2835_clock {
	struct clk_hw hw;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_clock_data *data;
};

struct bcm2835_clock_data {
	const char *name;
	const char * const *parents;
	int num_mux_parents;
	unsigned int set_rate_parent;
	u32 ctl_reg;
	u32 div_reg;
	u32 int_bits;
	u32 frac_bits;
	u32 flags;
	bool is_vpu_clock;
	bool is_mash_clock;
	bool low_jitter;
	u32 tcnt_mux;
	bool round_up;
};

struct bcm2835_gate_data {
	const char *name;
	const char *parent;
	u32 ctl_reg;
};

struct clk_pfdv2 {
	struct clk_hw hw;
	void *reg;
	u8 gate_bit;
	u8 vld_bit;
	u8 frac_off;
};

struct ma35d1_adc_clk_div {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u32 mask;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

enum clk_ids___9 {
	LAST_DT_CORE_CLK___9 = 49,
	CLK_EXTAL___9 = 50,
	CLK_EXTALR___9 = 51,
	CLK_MAIN___9 = 52,
	CLK_PLL0___6 = 53,
	CLK_PLL1___9 = 54,
	CLK_PLL3___8 = 55,
	CLK_PLL4___6 = 56,
	CLK_PLL1_DIV2___9 = 57,
	CLK_PLL1_DIV4___6 = 58,
	CLK_S0___7 = 59,
	CLK_S1___6 = 60,
	CLK_S2___5 = 61,
	CLK_S3___6 = 62,
	CLK_SDSRC___8 = 63,
	CLK_SSPSRC___3 = 64,
	CLK_RPCSRC___8 = 65,
	CLK_RINT___5 = 66,
	MOD_CLK_BASE___9 = 67,
};

struct clk_rk3588_inits {
	void (*inits)(struct device_node *);
};

struct visconti_pll {
	struct clk_hw hw;
	void *pll_base;
	spinlock_t *lock;
	unsigned long flags;
	const struct visconti_pll_rate_table *rate_table;
	size_t rate_count;
	struct visconti_pll_provider *ctx;
};

struct acpi_dma_spec;

struct acpi_dma {
	struct list_head dma_controllers;
	struct device *dev;
	struct dma_chan * (*acpi_dma_xlate)(struct acpi_dma_spec *, struct acpi_dma *);
	void *data;
	unsigned short base_request_line;
	unsigned short end_request_line;
};

struct acpi_dma_spec {
	int chan_id;
	int slave_id;
	struct device *dev;
};

struct acpi_csrt_group {
	u32 length;
	u32 vendor_id;
	u32 subvendor_id;
	u16 device_id;
	u16 subdevice_id;
	u16 revision;
	u16 reserved;
	u32 shared_info_length;
};

struct acpi_csrt_shared_info {
	u16 major_version;
	u16 minor_version;
	u32 mmio_base_low;
	u32 mmio_base_high;
	u32 gsi_interrupt;
	u8 interrupt_polarity;
	u8 interrupt_mode;
	u8 num_channels;
	u8 dma_address_width;
	u16 base_request_line;
	u16 num_handshake_signals;
	u32 max_block_size;
};

struct acpi_table_csrt {
	struct acpi_table_header header;
};

struct acpi_dma_parser_data {
	struct acpi_dma_spec dma_spec;
	size_t index;
	size_t n;
};

struct acpi_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct udma_oes_offsets {
	u32 udma_rchan;
	u32 bcdma_bchan_data;
	u32 bcdma_bchan_ring;
	u32 bcdma_tchan_data;
	u32 bcdma_tchan_ring;
	u32 bcdma_rchan_data;
	u32 bcdma_rchan_ring;
	u32 pktdma_tchan_flow;
	u32 pktdma_rchan_flow;
};

struct udma_soc_data {
	struct udma_oes_offsets oes;
	u32 bcdma_trigger_event_offset;
};

enum k3_dma_type {
	DMA_TYPE_UDMA = 0,
	DMA_TYPE_BCDMA = 1,
	DMA_TYPE_PKTDMA = 2,
};

struct udma_match_data {
	enum k3_dma_type type;
	u32 psil_base;
	bool enable_memcpy_support;
	u32 flags;
	u32 statictr_z_mask;
	u8 burst_size[3];
	struct udma_soc_data *soc_data;
};

enum udma_chan_state {
	UDMA_CHAN_IS_IDLE = 0,
	UDMA_CHAN_IS_ACTIVE = 1,
	UDMA_CHAN_IS_TERMINATING = 2,
};

enum udma_mmr {
	MMR_GCFG = 0,
	MMR_BCHANRT = 1,
	MMR_RCHANRT = 2,
	MMR_TCHANRT = 3,
	MMR_LAST = 4,
};

enum cppi5_tr_types {
	CPPI5_TR_TYPE0 = 0,
	CPPI5_TR_TYPE1 = 1,
	CPPI5_TR_TYPE2 = 2,
	CPPI5_TR_TYPE3 = 3,
	CPPI5_TR_TYPE4 = 4,
	CPPI5_TR_TYPE5 = 5,
	CPPI5_TR_TYPE8 = 8,
	CPPI5_TR_TYPE9 = 9,
	CPPI5_TR_TYPE10 = 10,
	CPPI5_TR_TYPE11 = 11,
	CPPI5_TR_TYPE15 = 15,
	CPPI5_TR_TYPE_MAX = 16,
};

enum cppi5_tr_event_size {
	CPPI5_TR_EVENT_SIZE_COMPLETION = 0,
	CPPI5_TR_EVENT_SIZE_ICNT1_DEC = 1,
	CPPI5_TR_EVENT_SIZE_ICNT2_DEC = 2,
	CPPI5_TR_EVENT_SIZE_ICNT3_DEC = 3,
	CPPI5_TR_EVENT_SIZE_MAX = 4,
};

enum cppi5_tr_trigger_type {
	CPPI5_TR_TRIGGER_TYPE_ICNT1_DEC = 0,
	CPPI5_TR_TRIGGER_TYPE_ICNT2_DEC = 1,
	CPPI5_TR_TRIGGER_TYPE_ICNT3_DEC = 2,
	CPPI5_TR_TRIGGER_TYPE_ALL = 3,
	CPPI5_TR_TRIGGER_TYPE_MAX = 4,
};

enum cppi5_tr_trigger {
	CPPI5_TR_TRIGGER_NONE = 0,
	CPPI5_TR_TRIGGER_GLOBAL0 = 1,
	CPPI5_TR_TRIGGER_GLOBAL1 = 2,
	CPPI5_TR_TRIGGER_LOCAL_EVENT = 3,
	CPPI5_TR_TRIGGER_MAX = 4,
};

enum udma_rm_range {
	RM_RANGE_BCHAN = 0,
	RM_RANGE_TCHAN = 1,
	RM_RANGE_RCHAN = 2,
	RM_RANGE_RFLOW = 3,
	RM_RANGE_TFLOW = 4,
	RM_RANGE_LAST = 5,
};

struct udma_static_tr {
	u8 elsize;
	u16 elcnt;
	u16 bstcnt;
};

struct udma_tx_drain {
	struct delayed_work work;
	ktime_t tstamp;
	u32 residue;
};

struct udma_chan_config {
	bool pkt_mode;
	bool needs_epib;
	u32 psd_size;
	u32 metadata_size;
	u32 hdesc_size;
	bool notdpkt;
	int remote_thread_id;
	u32 atype;
	u32 asel;
	u32 src_thread;
	u32 dst_thread;
	enum psil_endpoint_type ep_type;
	bool enable_acc32;
	bool enable_burst;
	enum udma_tp_level channel_tpl;
	u32 tr_trigger_type;
	unsigned long tx_flags;
	int mapped_channel_id;
	int default_flow_id;
	enum dma_transfer_direction dir;
};

struct udma_desc;

struct udma_chan {
	struct virt_dma_chan vc;
	struct dma_slave_config cfg;
	struct udma_dev *ud;
	struct device *dma_dev;
	struct udma_desc *desc;
	struct udma_desc *terminated_desc;
	struct udma_static_tr static_tr;
	char *name;
	struct udma_tchan *bchan;
	struct udma_tchan *tchan;
	struct udma_rchan *rchan;
	struct udma_rflow *rflow;
	bool psil_paired;
	int irq_num_ring;
	int irq_num_udma;
	bool cyclic;
	bool paused;
	enum udma_chan_state state;
	struct completion teardown_completed;
	struct udma_tx_drain tx_drain;
	struct udma_chan_config config;
	struct udma_chan_config backup_config;
	bool use_dma_pool;
	struct dma_pool *hdesc_pool;
	u32 id;
};

struct udma_tpl {
	u8 levels;
	u32 start_idx[3];
};

struct cppi5_tr_resp_t;

struct udma_hwdesc {
	size_t cppi5_desc_size;
	void *cppi5_desc_vaddr;
	dma_addr_t cppi5_desc_paddr;
	void *tr_req_base;
	struct cppi5_tr_resp_t *tr_resp_base;
};

struct udma_rx_flush {
	struct udma_hwdesc hwdescs[2];
	size_t buffer_size;
	void *buffer_vaddr;
	dma_addr_t buffer_paddr;
};

struct udma_dev {
	struct dma_device ddev;
	struct device *dev;
	void *mmrs[4];
	const struct udma_match_data *match_data;
	const struct udma_soc_data *soc_data;
	struct udma_tpl bchan_tpl;
	struct udma_tpl tchan_tpl;
	struct udma_tpl rchan_tpl;
	size_t desc_align;
	struct udma_tisci_rm tisci_rm;
	struct k3_ringacc *ringacc;
	struct work_struct purge_work;
	struct list_head desc_to_purge;
	spinlock_t lock;
	struct udma_rx_flush rx_flush;
	int bchan_cnt;
	int tchan_cnt;
	int echan_cnt;
	int rchan_cnt;
	int rflow_cnt;
	int tflow_cnt;
	unsigned long *bchan_map;
	unsigned long *tchan_map;
	unsigned long *rchan_map;
	unsigned long *rflow_gp_map;
	unsigned long *rflow_gp_map_allocated;
	unsigned long *rflow_in_use;
	unsigned long *tflow_map;
	struct udma_tchan *bchans;
	struct udma_tchan *tchans;
	struct udma_rchan *rchans;
	struct udma_rflow *rflows;
	struct udma_chan *channels;
	u32 psil_base;
	u32 atype;
	u32 asel;
};

struct cppi5_tr_resp_t {
	u8 status;
	u8 _reserved;
	u8 cmd_id;
	u8 flags;
};

struct udma_tchan {
	void *reg_rt;
	int id;
	struct k3_ring *t_ring;
	struct k3_ring *tc_ring;
	int tflow_id;
};

struct udma_rchan {
	void *reg_rt;
	int id;
};

struct udma_rflow {
	int id;
	struct k3_ring *fd_ring;
	struct k3_ring *r_ring;
};

struct udma_desc {
	struct virt_dma_desc vd;
	bool terminated;
	enum dma_transfer_direction dir;
	struct udma_static_tr static_tr;
	u32 residue;
	unsigned int sglen;
	unsigned int desc_idx;
	unsigned int tr_idx;
	u32 metadata_size;
	void *metadata;
	unsigned int hwdesc_count;
	struct udma_hwdesc hwdesc[0];
};

typedef u32 cppi5_tr_flags_t;

struct cppi5_tr_type1_t {
	cppi5_tr_flags_t flags;
	u16 icnt0;
	u16 icnt1;
	u64 addr;
	s32 dim1;
	long: 64;
};

struct cppi5_tr_type15_t {
	cppi5_tr_flags_t flags;
	u16 icnt0;
	u16 icnt1;
	u64 addr;
	s32 dim1;
	u16 icnt2;
	u16 icnt3;
	s32 dim2;
	s32 dim3;
	u32 _reserved;
	s32 ddim1;
	u64 daddr;
	s32 ddim2;
	s32 ddim3;
	u16 dicnt0;
	u16 dicnt1;
	u16 dicnt2;
	u16 dicnt3;
};

struct k3_event_route_data {
	void *priv;
	int (*set_event)(void *, u32);
};

struct udma_filter_param {
	int remote_thread_id;
	u32 atype;
	u32 asel;
	u32 tr_trigger_type;
};

struct rst_config {
	unsigned int modemr;
	int (*configure)(void *);
	int (*set_rproc_boot_addr)(u64);
};

struct sunxi_sram_func;

struct sunxi_sram_data {
	char *name;
	u8 reg;
	u8 offset;
	u8 width;
	struct sunxi_sram_func *func;
	struct list_head list;
};

struct sunxi_sram_desc {
	struct sunxi_sram_data data;
	bool claimed;
};

struct sunxi_sram_func {
	char *func;
	u8 val;
	u32 reg_val;
};

struct sunxi_sramc_variant {
	int num_emac_clocks;
	bool has_ldo_ctrl;
};

struct zynqmp_pm_domain {
	struct generic_pm_domain gpd;
	u32 node_id;
	bool requested;
};

struct xb_find_info {
	struct xenbus_device *dev;
	const char *nodename;
};

enum {
	REGULATOR_ERROR_CLEARED = 0,
	REGULATOR_FAILED_RETRY = 1,
	REGULATOR_ERROR_ON = 2,
};

struct regulator_irq {
	struct regulator_irq_data rdata;
	struct regulator_irq_desc desc;
	int irq;
	int retry_cnt;
	struct delayed_work isr_work;
};

enum mrq_reset_commands {
	CMD_RESET_ASSERT = 1,
	CMD_RESET_DEASSERT = 2,
	CMD_RESET_MODULE = 3,
	CMD_RESET_GET_MAX_ID = 4,
	CMD_RESET_MAX = 5,
};

struct mrq_reset_request {
	uint32_t cmd;
	uint32_t reset_id;
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	unsigned long char_map[4];
	unsigned long overrun_time;
	unsigned int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	u8 read_buf[4096];
	unsigned long read_flags[64];
	u8 echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	size_t lookahead_count;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

enum dma_rx_status {
	DMA_RX_START = 0,
	DMA_RX_RUNNING = 1,
	DMA_RX_SHUTDOWN = 2,
};

enum {
	MTK_UART_FC_NONE = 0,
	MTK_UART_FC_SW = 1,
	MTK_UART_FC_HW = 2,
};

struct mtk8250_data {
	int line;
	unsigned int rx_pos;
	unsigned int clk_count;
	struct clk *uart_clk;
	struct clk *bus_clk;
	struct uart_8250_dma *dma;
	enum dma_rx_status rx_status;
	int rx_wakeup_irq;
};

struct iproc_rng200_dev {
	struct hwrng rng;
	void *base;
};

enum tcpa_pc_event_ids {
	SMBIOS = 1,
	BIS_CERT = 2,
	POST_BIOS_ROM = 3,
	ESCD = 4,
	CMOS = 5,
	NVRAM = 6,
	OPTION_ROM_EXEC = 7,
	OPTION_ROM_CONFIG = 8,
	OPTION_ROM_MICROCODE = 10,
	S_CRTM_VERSION = 11,
	S_CRTM_CONTENTS = 12,
	POST_CONTENTS = 13,
	HOST_TABLE_OF_DEVICES = 14,
};

struct tcpa_pc_event {
	u32 event_id;
	u32 event_size;
	u8 event_data[0];
};

struct iova_magazine;

struct iova_cpu_rcache {
	spinlock_t lock;
	struct iova_magazine *loaded;
	struct iova_magazine *prev;
};

struct iova_magazine {
	union {
		unsigned long size;
		struct iova_magazine *next;
	};
	unsigned long pfns[127];
};

struct iova_rcache {
	spinlock_t lock;
	unsigned int depot_size;
	struct iova_magazine *depot;
	struct iova_cpu_rcache __attribute__((btf_type_tag("percpu"))) *cpu_rcaches;
	struct iova_domain *iovad;
	struct delayed_work work;
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	struct device classdev;
};

struct mfd_of_node_entry {
	struct list_head list;
	struct device *dev;
	struct device_node *np;
};

struct match_ids_walk_data {
	struct acpi_device_id *ids;
	struct acpi_device *adev;
};

struct discover_resp {
	u8 _r_a[5];
	u8 phy_id;
	__be16 _r_b;
	u8 _r_c: 4;
	u8 attached_dev_type: 3;
	u8 _r_d: 1;
	u8 linkrate: 4;
	u8 _r_e: 4;
	u8 attached_sata_host: 1;
	u8 iproto: 3;
	u8 _r_f: 4;
	u8 attached_sata_dev: 1;
	u8 tproto: 3;
	u8 _r_g: 3;
	u8 attached_sata_ps: 1;
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	u8 attached_phy_id;
	u8 _r_h[7];
	u8 hmin_linkrate: 4;
	u8 pmin_linkrate: 4;
	u8 hmax_linkrate: 4;
	u8 pmax_linkrate: 4;
	u8 change_count;
	u8 pptv: 4;
	u8 _r_i: 3;
	u8 virtual: 1;
	u8 routing_attr: 4;
	u8 _r_j: 4;
	u8 conn_type;
	u8 conn_el_index;
	u8 conn_phy_link;
	u8 _r_k[8];
};

struct smp_disc_resp {
	u8 frame_type;
	u8 function;
	u8 result;
	u8 reserved;
	struct discover_resp disc;
};

struct report_general_resp {
	__be16 change_count;
	__be16 route_indexes;
	u8 _r_a;
	u8 num_phys;
	u8 conf_route_table: 1;
	u8 configuring: 1;
	u8 config_others: 1;
	u8 orej_retry_supp: 1;
	u8 stp_cont_awt: 1;
	u8 self_config: 1;
	u8 zone_config: 1;
	u8 t2t_supp: 1;
	u8 _r_c;
	u8 enclosure_logical_id[8];
	u8 _r_d[12];
};

struct smp_rg_resp {
	u8 frame_type;
	u8 function;
	u8 result;
	u8 reserved;
	struct report_general_resp rg;
};

struct sil24_cerr_info {
	unsigned int err_mask;
	unsigned int action;
	const char *desc;
};

enum {
	SIL24_HOST_BAR = 0,
	SIL24_PORT_BAR = 2,
	SIL24_PRB_SZ = 64,
	SIL24_MAX_SGT = 63,
	SIL24_MAX_SGE = 253,
	HOST_SLOT_STAT = 0,
	HOST_CTRL = 64,
	HOST_IRQ_STAT___2 = 68,
	HOST_PHY_CFG = 72,
	HOST_BIST_CTRL = 80,
	HOST_BIST_PTRN = 84,
	HOST_BIST_STAT = 88,
	HOST_MEM_BIST_STAT = 92,
	HOST_FLASH_CMD = 112,
	HOST_FLASH_DATA = 116,
	HOST_TRANSITION_DETECT = 117,
	HOST_GPIO_CTRL = 118,
	HOST_I2C_ADDR = 120,
	HOST_I2C_DATA = 124,
	HOST_I2C_XFER_CNT = 126,
	HOST_I2C_CTRL = 127,
	HOST_SSTAT_ATTN = -2147483648,
	HOST_CTRL_M66EN = 65536,
	HOST_CTRL_TRDY = 131072,
	HOST_CTRL_STOP = 262144,
	HOST_CTRL_DEVSEL = 524288,
	HOST_CTRL_REQ64 = 1048576,
	HOST_CTRL_GLOBAL_RST = -2147483648,
	PORT_REGS_SIZE = 8192,
	PORT_LRAM = 0,
	PORT_LRAM_SLOT_SZ = 128,
	PORT_PMP = 3968,
	PORT_PMP_STATUS = 0,
	PORT_PMP_QACTIVE = 4,
	PORT_PMP_SIZE = 8,
	PORT_CTRL_STAT = 4096,
	PORT_CTRL_CLR = 4100,
	PORT_IRQ_STAT___2 = 4104,
	PORT_IRQ_ENABLE_SET = 4112,
	PORT_IRQ_ENABLE_CLR = 4116,
	PORT_ACTIVATE_UPPER_ADDR = 4124,
	PORT_EXEC_FIFO = 4128,
	PORT_CMD_ERR = 4132,
	PORT_FIS_CFG = 4136,
	PORT_FIFO_THRES = 4140,
	PORT_DECODE_ERR_CNT = 4160,
	PORT_DECODE_ERR_THRESH = 4162,
	PORT_CRC_ERR_CNT = 4164,
	PORT_CRC_ERR_THRESH = 4166,
	PORT_HSHK_ERR_CNT = 4168,
	PORT_HSHK_ERR_THRESH = 4170,
	PORT_PHY_CFG = 4176,
	PORT_SLOT_STAT = 6144,
	PORT_CMD_ACTIVATE = 7168,
	PORT_CONTEXT = 7684,
	PORT_EXEC_DIAG = 7680,
	PORT_PSD_DIAG = 7744,
	PORT_SCONTROL = 7936,
	PORT_SSTATUS = 7940,
	PORT_SERROR = 7944,
	PORT_SACTIVE = 7948,
	PORT_CS_PORT_RST = 1,
	PORT_CS_DEV_RST = 2,
	PORT_CS_INIT = 4,
	PORT_CS_IRQ_WOC = 8,
	PORT_CS_CDB16 = 32,
	PORT_CS_PMP_RESUME = 64,
	PORT_CS_32BIT_ACTV = 1024,
	PORT_CS_PMP_EN = 8192,
	PORT_CS_RDY = -2147483648,
	PORT_IRQ_COMPLETE = 1,
	PORT_IRQ_ERROR___2 = 2,
	PORT_IRQ_PORTRDY_CHG = 4,
	PORT_IRQ_PWR_CHG = 8,
	PORT_IRQ_PHYRDY_CHG = 16,
	PORT_IRQ_COMWAKE = 32,
	PORT_IRQ_UNK_FIS___2 = 64,
	PORT_IRQ_DEV_XCHG = 128,
	PORT_IRQ_8B10B = 256,
	PORT_IRQ_CRC = 512,
	PORT_IRQ_HANDSHAKE = 1024,
	PORT_IRQ_SDB_NOTIFY = 2048,
	DEF_PORT_IRQ___2 = 2259,
	PORT_IRQ_RAW_SHIFT = 16,
	PORT_IRQ_MASKED_MASK = 2047,
	PORT_IRQ_RAW_MASK = 134152192,
	PORT_IRQ_STEER_SHIFT = 30,
	PORT_IRQ_STEER_MASK = -1073741824,
	PORT_CERR_DEV = 1,
	PORT_CERR_SDB = 2,
	PORT_CERR_DATA = 3,
	PORT_CERR_SEND = 4,
	PORT_CERR_INCONSISTENT = 5,
	PORT_CERR_DIRECTION = 6,
	PORT_CERR_UNDERRUN = 7,
	PORT_CERR_OVERRUN = 8,
	PORT_CERR_PKT_PROT = 11,
	PORT_CERR_SGT_BOUNDARY = 16,
	PORT_CERR_SGT_TGTABRT = 17,
	PORT_CERR_SGT_MSTABRT = 18,
	PORT_CERR_SGT_PCIPERR = 19,
	PORT_CERR_CMD_BOUNDARY = 24,
	PORT_CERR_CMD_TGTABRT = 25,
	PORT_CERR_CMD_MSTABRT = 26,
	PORT_CERR_CMD_PCIPERR = 27,
	PORT_CERR_XFR_UNDEF = 32,
	PORT_CERR_XFR_TGTABRT = 33,
	PORT_CERR_XFR_MSTABRT = 34,
	PORT_CERR_XFR_PCIPERR = 35,
	PORT_CERR_SENDSERVICE = 36,
	PRB_CTRL_PROTOCOL = 1,
	PRB_CTRL_PACKET_READ = 16,
	PRB_CTRL_PACKET_WRITE = 32,
	PRB_CTRL_NIEN = 64,
	PRB_CTRL_SRST = 128,
	PRB_PROT_PACKET = 1,
	PRB_PROT_TCQ = 2,
	PRB_PROT_NCQ = 4,
	PRB_PROT_READ = 8,
	PRB_PROT_WRITE = 16,
	PRB_PROT_TRANSPARENT = 32,
	SGE_TRM = -2147483648,
	SGE_LNK = 1073741824,
	SGE_DRD = 536870912,
	SIL24_MAX_CMDS = 31,
	BID_SIL3124 = 0,
	BID_SIL3132 = 1,
	BID_SIL3131 = 2,
	SIL24_COMMON_FLAGS = 918658,
	SIL24_FLAG_PCIX_IRQ_WOC = 16777216,
	IRQ_STAT_4PORTS = 15,
};

struct sil24_sge {
	__le64 addr;
	__le32 cnt;
	__le32 flags;
};

struct sil24_prb {
	__le16 ctrl;
	__le16 prot;
	__le32 rx_cnt;
	u8 fis[24];
};

union sil24_cmd_block;

struct sil24_port_priv {
	union sil24_cmd_block *cmd_block;
	dma_addr_t cmd_block_dma;
	int do_port_rst;
};

struct sil24_ata_block {
	struct sil24_prb prb;
	struct sil24_sge sge[253];
};

struct sil24_atapi_block {
	struct sil24_prb prb;
	u8 cdb[16];
	struct sil24_sge sge[253];
};

union sil24_cmd_block {
	struct sil24_ata_block ata;
	struct sil24_atapi_block atapi;
};

enum cfi_quirks {
	CFI_QUIRK_DQ_TRUE_DATA = 1,
};

struct cfi_pri_amdstd {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint8_t SiliconRevision;
	uint8_t EraseSuspend;
	uint8_t BlkProt;
	uint8_t TmpBlkUnprotect;
	uint8_t BlkProtUnprot;
	uint8_t SimultaneousOps;
	uint8_t BurstMode;
	uint8_t PageMode;
	uint8_t VppMin;
	uint8_t VppMax;
	uint8_t TopBottom;
	uint8_t ProgramSuspend;
	uint8_t UnlockBypass;
	uint8_t SecureSiliconSector;
	uint8_t SoftwareFeatures;
};

struct ppb_lock {
	struct flchip *chip;
	unsigned long adr;
	int locked;
};

typedef int (*otp_op_t)(struct map_info *, struct flchip *, loff_t, size_t, u_char *, size_t);

struct fsl_ifc_mtd;

struct fsl_ifc_nand_ctrl {
	struct nand_controller controller;
	struct fsl_ifc_mtd *chips[8];
	void *addr;
	unsigned int page;
	unsigned int read_bytes;
	unsigned int column;
	unsigned int index;
	unsigned int oob;
	unsigned int eccread;
	unsigned int counter;
	unsigned int max_bitflips;
};

struct fsl_ifc_mtd {
	struct nand_chip chip;
	struct fsl_ifc_ctrl *ctrl;
	struct device *dev;
	int bank;
	unsigned int bufnum_mask;
	u8 *vbase;
};

enum ifc_nand_fir_opcodes {
	IFC_FIR_OP_NOP = 0,
	IFC_FIR_OP_CA0 = 1,
	IFC_FIR_OP_CA1 = 2,
	IFC_FIR_OP_CA2 = 3,
	IFC_FIR_OP_CA3 = 4,
	IFC_FIR_OP_RA0 = 5,
	IFC_FIR_OP_RA1 = 6,
	IFC_FIR_OP_RA2 = 7,
	IFC_FIR_OP_RA3 = 8,
	IFC_FIR_OP_CMD0 = 9,
	IFC_FIR_OP_CMD1 = 10,
	IFC_FIR_OP_CMD2 = 11,
	IFC_FIR_OP_CMD3 = 12,
	IFC_FIR_OP_CMD4 = 13,
	IFC_FIR_OP_CMD5 = 14,
	IFC_FIR_OP_CMD6 = 15,
	IFC_FIR_OP_CMD7 = 16,
	IFC_FIR_OP_CW0 = 17,
	IFC_FIR_OP_CW1 = 18,
	IFC_FIR_OP_CW2 = 19,
	IFC_FIR_OP_CW3 = 20,
	IFC_FIR_OP_CW4 = 21,
	IFC_FIR_OP_CW5 = 22,
	IFC_FIR_OP_CW6 = 23,
	IFC_FIR_OP_CW7 = 24,
	IFC_FIR_OP_WBCD = 25,
	IFC_FIR_OP_RBCD = 26,
	IFC_FIR_OP_BTRD = 27,
	IFC_FIR_OP_RDSTAT = 28,
	IFC_FIR_OP_NWAIT = 29,
	IFC_FIR_OP_WFR = 30,
	IFC_FIR_OP_SBRD = 31,
	IFC_FIR_OP_UA = 32,
	IFC_FIR_OP_RB = 33,
};

enum orion_spi_type {
	ORION_SPI = 0,
	ARMADA_SPI = 1,
};

struct orion_spi_dev {
	enum orion_spi_type typ;
	unsigned long max_hz;
	unsigned int min_divisor;
	unsigned int max_divisor;
	u32 prescale_mask;
	bool is_errata_50mhz_ac;
};

struct orion_direct_acc {
	void *vaddr;
	u32 size;
};

struct orion_child_options {
	struct orion_direct_acc direct_access;
};

struct orion_spi {
	struct spi_controller *host;
	void *base;
	struct clk *clk;
	struct clk *axi_clk;
	const struct orion_spi_dev *devdata;
	struct device *dev;
	struct orion_child_options child[8];
};

struct aqr107_hw_stat {
	const char *name;
	int reg;
	int size;
};

struct aqr107_priv {
	u64 sgmii_stats[10];
};

struct thunder_mdiobus_nexus {
	void *bar0;
	struct cavium_mdiobus *buses[4];
};

struct cvmx_smix_en_s {
	u64 en: 1;
	u64 reserved_1_63: 63;
};

union cvmx_smix_en {
	u64 u64;
	struct cvmx_smix_en_s s;
};

struct bgx;

struct dmac_map;

struct lmac {
	struct bgx *bgx;
	u8 dmacs_cfg;
	u8 dmacs_count;
	struct dmac_map *dmacs;
	u8 mac[6];
	u8 lmac_type;
	u8 lane_to_sds;
	bool use_training;
	bool autoneg;
	bool link_up;
	int lmacid;
	int lmacid_bd;
	long: 64;
	long: 64;
	struct net_device netdev;
	struct phy_device *phydev;
	unsigned int last_duplex;
	unsigned int last_link;
	unsigned int last_speed;
	bool is_sgmii;
	struct delayed_work dwork;
	struct workqueue_struct *check_link;
	long: 64;
};

struct bgx {
	u8 bgx_id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct lmac lmac[4];
	u8 lmac_count;
	u8 max_lmac;
	u8 acpi_lmac_idx;
	void *reg_base;
	struct pci_dev *pdev;
	bool is_dlm;
	bool is_rgx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dmac_map {
	u64 vf_map;
	u64 dmac;
};

enum MCAST_MODE {
	MCAST_MODE_REJECT = 0,
	MCAST_MODE_ACCEPT = 1,
	MCAST_MODE_CAM_FILTER = 2,
	RSVD = 3,
};

enum LMAC_TYPE {
	BGX_MODE_SGMII = 0,
	BGX_MODE_XAUI = 1,
	BGX_MODE_DXAUI = 1,
	BGX_MODE_RXAUI = 2,
	BGX_MODE_XFI = 3,
	BGX_MODE_XLAUI = 4,
	BGX_MODE_10G_KR = 3,
	BGX_MODE_40G_KR = 4,
	BGX_MODE_RGMII = 5,
	BGX_MODE_QSGMII = 6,
	BGX_MODE_INVALID = 7,
};

enum enetc_msg_cmd_status {
	ENETC_MSG_CMD_STATUS_OK = 0,
	ENETC_MSG_CMD_STATUS_FAIL = 1,
};

enum enetc_mac_addr_type {
	UC = 0,
	MC = 1,
	MADDR_TYPE = 2,
};

struct orion_mdio_dev;

struct orion_mdio_ops {
	int (*is_done)(struct orion_mdio_dev *);
	unsigned int poll_interval_min;
	unsigned int poll_interval_max;
};

struct orion_mdio_dev {
	void *regs;
	struct clk *clk[4];
	int err_interrupt;
	wait_queue_head_t smi_busy_wait;
};

enum orion_mdio_bus_type {
	BUS_TYPE_SMI = 0,
	BUS_TYPE_XSMI = 1,
};

enum rswitch_reg {
	FWGC = 0,
	FWTTC0 = 16,
	FWTTC1 = 20,
	FWLBMC = 24,
	FWCEPTC = 32,
	FWCEPRC0 = 36,
	FWCEPRC1 = 40,
	FWCEPRC2 = 44,
	FWCLPTC = 48,
	FWCLPRC = 52,
	FWCMPTC = 64,
	FWEMPTC = 68,
	FWSDMPTC = 80,
	FWSDMPVC = 84,
	FWLBWMC0 = 128,
	FWPC00 = 256,
	FWPC10 = 260,
	FWPC20 = 264,
	FWCTGC00 = 1024,
	FWCTGC10 = 1028,
	FWCTTC00 = 1032,
	FWCTTC10 = 1036,
	FWCTTC200 = 1040,
	FWCTSC00 = 1056,
	FWCTSC10 = 1060,
	FWCTSC20 = 1064,
	FWCTSC30 = 1068,
	FWCTSC40 = 1072,
	FWTWBFC0 = 4096,
	FWTWBFVC0 = 4100,
	FWTHBFC0 = 5120,
	FWTHBFV0C0 = 5124,
	FWTHBFV1C0 = 5128,
	FWFOBFC0 = 6144,
	FWFOBFV0C0 = 6148,
	FWFOBFV1C0 = 6152,
	FWRFC0 = 7168,
	FWRFVC0 = 7172,
	FWCFC0 = 8192,
	FWCFMC00 = 8196,
	FWIP4SC = 16392,
	FWIP6SC = 16408,
	FWIP6OC = 16412,
	FWL2SC = 16416,
	FWSFHEC = 16432,
	FWSHCR0 = 16448,
	FWSHCR1 = 16452,
	FWSHCR2 = 16456,
	FWSHCR3 = 16460,
	FWSHCR4 = 16464,
	FWSHCR5 = 16468,
	FWSHCR6 = 16472,
	FWSHCR7 = 16476,
	FWSHCR8 = 16480,
	FWSHCR9 = 16484,
	FWSHCR10 = 16488,
	FWSHCR11 = 16492,
	FWSHCR12 = 16496,
	FWSHCR13 = 16500,
	FWSHCRR = 16504,
	FWLTHHEC = 16528,
	FWLTHHC = 16532,
	FWLTHTL0 = 16544,
	FWLTHTL1 = 16548,
	FWLTHTL2 = 16552,
	FWLTHTL3 = 16556,
	FWLTHTL4 = 16560,
	FWLTHTL5 = 16564,
	FWLTHTL6 = 16568,
	FWLTHTL7 = 16572,
	FWLTHTL80 = 16576,
	FWLTHTL9 = 16592,
	FWLTHTLR = 16596,
	FWLTHTIM = 16608,
	FWLTHTEM = 16612,
	FWLTHTS0 = 16640,
	FWLTHTS1 = 16644,
	FWLTHTS2 = 16648,
	FWLTHTS3 = 16652,
	FWLTHTS4 = 16656,
	FWLTHTSR0 = 16672,
	FWLTHTSR1 = 16676,
	FWLTHTSR2 = 16680,
	FWLTHTSR3 = 16684,
	FWLTHTSR40 = 16688,
	FWLTHTSR5 = 16704,
	FWLTHTR = 16720,
	FWLTHTRR0 = 16724,
	FWLTHTRR1 = 16728,
	FWLTHTRR2 = 16732,
	FWLTHTRR3 = 16736,
	FWLTHTRR4 = 16740,
	FWLTHTRR5 = 16744,
	FWLTHTRR6 = 16748,
	FWLTHTRR7 = 16752,
	FWLTHTRR8 = 16756,
	FWLTHTRR9 = 16768,
	FWLTHTRR10 = 16784,
	FWIPHEC = 16916,
	FWIPHC = 16920,
	FWIPTL0 = 16928,
	FWIPTL1 = 16932,
	FWIPTL2 = 16936,
	FWIPTL3 = 16940,
	FWIPTL4 = 16944,
	FWIPTL5 = 16948,
	FWIPTL6 = 16952,
	FWIPTL7 = 16960,
	FWIPTL8 = 16976,
	FWIPTLR = 16980,
	FWIPTIM = 16992,
	FWIPTEM = 16996,
	FWIPTS0 = 17008,
	FWIPTS1 = 17012,
	FWIPTS2 = 17016,
	FWIPTS3 = 17020,
	FWIPTS4 = 17024,
	FWIPTSR0 = 17028,
	FWIPTSR1 = 17032,
	FWIPTSR2 = 17036,
	FWIPTSR3 = 17040,
	FWIPTSR4 = 17056,
	FWIPTR = 17072,
	FWIPTRR0 = 17076,
	FWIPTRR1 = 17080,
	FWIPTRR2 = 17084,
	FWIPTRR3 = 17088,
	FWIPTRR4 = 17092,
	FWIPTRR5 = 17096,
	FWIPTRR6 = 17100,
	FWIPTRR7 = 17104,
	FWIPTRR8 = 17120,
	FWIPTRR9 = 17136,
	FWIPHLEC = 17152,
	FWIPAGUSPC = 17664,
	FWIPAGC = 17668,
	FWIPAGM0 = 17680,
	FWIPAGM1 = 17684,
	FWIPAGM2 = 17688,
	FWIPAGM3 = 17692,
	FWIPAGM4 = 17696,
	FWMACHEC = 17952,
	FWMACHC = 17956,
	FWMACTL0 = 17968,
	FWMACTL1 = 17972,
	FWMACTL2 = 17976,
	FWMACTL3 = 17980,
	FWMACTL4 = 17984,
	FWMACTL5 = 18000,
	FWMACTLR = 18004,
	FWMACTIM = 18016,
	FWMACTEM = 18020,
	FWMACTS0 = 18032,
	FWMACTS1 = 18036,
	FWMACTSR0 = 18040,
	FWMACTSR1 = 18044,
	FWMACTSR2 = 18048,
	FWMACTSR3 = 18064,
	FWMACTR = 18080,
	FWMACTRR0 = 18084,
	FWMACTRR1 = 18088,
	FWMACTRR2 = 18092,
	FWMACTRR3 = 18096,
	FWMACTRR4 = 18100,
	FWMACTRR5 = 18112,
	FWMACTRR6 = 18128,
	FWMACHLEC = 18176,
	FWMACAGUSPC = 18560,
	FWMACAGC = 18564,
	FWMACAGM0 = 18568,
	FWMACAGM1 = 18572,
	FWVLANTEC = 18688,
	FWVLANTL0 = 18704,
	FWVLANTL1 = 18708,
	FWVLANTL2 = 18712,
	FWVLANTL3 = 18720,
	FWVLANTL4 = 18736,
	FWVLANTLR = 18740,
	FWVLANTIM = 18752,
	FWVLANTEM = 18756,
	FWVLANTS = 18768,
	FWVLANTSR0 = 18772,
	FWVLANTSR1 = 18776,
	FWVLANTSR2 = 18784,
	FWVLANTSR3 = 18800,
	FWPBFC0 = 18944,
	FWPBFCSDC00 = 18948,
	FWL23URL0 = 19968,
	FWL23URL1 = 19972,
	FWL23URL2 = 19976,
	FWL23URL3 = 19980,
	FWL23URLR = 19984,
	FWL23UTIM = 20000,
	FWL23URR = 20016,
	FWL23URRR0 = 20020,
	FWL23URRR1 = 20024,
	FWL23URRR2 = 20028,
	FWL23URRR3 = 20032,
	FWL23URMC0 = 20224,
	FWPMFGC0 = 20480,
	FWPGFC0 = 20736,
	FWPGFIGSC0 = 20740,
	FWPGFENC0 = 20744,
	FWPGFENM0 = 20748,
	FWPGFCSTC00 = 20752,
	FWPGFCSTC10 = 20756,
	FWPGFCSTM00 = 20760,
	FWPGFCSTM10 = 20764,
	FWPGFCTC0 = 20768,
	FWPGFCTM0 = 20772,
	FWPGFHCC0 = 20776,
	FWPGFSM0 = 20780,
	FWPGFGC0 = 20784,
	FWPGFGL0 = 21760,
	FWPGFGL1 = 21764,
	FWPGFGLR = 21784,
	FWPGFGR = 21776,
	FWPGFGRR0 = 21780,
	FWPGFGRR1 = 21784,
	FWPGFRIM = 21792,
	FWPMTRFC0 = 22016,
	FWPMTRCBSC0 = 22020,
	FWPMTRC0RC0 = 22024,
	FWPMTREBSC0 = 22028,
	FWPMTREIRC0 = 22032,
	FWPMTRFM0 = 22036,
	FWFTL0 = 24576,
	FWFTL1 = 24580,
	FWFTLR = 24584,
	FWFTOC = 24592,
	FWFTOPC = 24596,
	FWFTIM = 24608,
	FWFTR = 24624,
	FWFTRR0 = 24628,
	FWFTRR1 = 24632,
	FWFTRR2 = 24636,
	FWSEQNGC0 = 24832,
	FWSEQNGM0 = 24836,
	FWSEQNRC = 25088,
	FWCTFDCN0 = 25344,
	FWLTHFDCN0 = 25348,
	FWIPFDCN0 = 25352,
	FWLTWFDCN0 = 25356,
	FWPBFDCN0 = 25360,
	FWMHLCN0 = 25364,
	FWIHLCN0 = 25368,
	FWICRDCN0 = 25856,
	FWWMRDCN0 = 25860,
	FWCTRDCN0 = 25864,
	FWLTHRDCN0 = 25868,
	FWIPRDCN0 = 25872,
	FWLTWRDCN0 = 25876,
	FWPBRDCN0 = 25880,
	FWPMFDCN0 = 26368,
	FWPGFDCN0 = 26496,
	FWPMGDCN0 = 26624,
	FWPMYDCN0 = 26628,
	FWPMRDCN0 = 26632,
	FWFRPPCN0 = 27136,
	FWFRDPCN0 = 27140,
	FWEIS00 = 30976,
	FWEIE00 = 30980,
	FWEID00 = 30984,
	FWEIS1 = 31232,
	FWEIE1 = 31236,
	FWEID1 = 31240,
	FWEIS2 = 31248,
	FWEIE2 = 31252,
	FWEID2 = 31256,
	FWEIS3 = 31264,
	FWEIE3 = 31268,
	FWEID3 = 31272,
	FWEIS4 = 31280,
	FWEIE4 = 31284,
	FWEID4 = 31288,
	FWEIS5 = 31296,
	FWEIE5 = 31300,
	FWEID5 = 31304,
	FWEIS60 = 31312,
	FWEIE60 = 31316,
	FWEID60 = 31320,
	FWEIS61 = 31328,
	FWEIE61 = 31332,
	FWEID61 = 31336,
	FWEIS62 = 31344,
	FWEIE62 = 31348,
	FWEID62 = 31352,
	FWEIS63 = 31360,
	FWEIE63 = 31364,
	FWEID63 = 31368,
	FWEIS70 = 31376,
	FWEIE70 = 31380,
	FWEID70 = 31384,
	FWEIS71 = 31392,
	FWEIE71 = 31396,
	FWEID71 = 31400,
	FWEIS72 = 31408,
	FWEIE72 = 31412,
	FWEID72 = 31416,
	FWEIS73 = 31424,
	FWEIE73 = 31428,
	FWEID73 = 31432,
	FWEIS80 = 31440,
	FWEIE80 = 31444,
	FWEID80 = 31448,
	FWEIS81 = 31456,
	FWEIE81 = 31460,
	FWEID81 = 31464,
	FWEIS82 = 31472,
	FWEIE82 = 31476,
	FWEID82 = 31480,
	FWEIS83 = 31488,
	FWEIE83 = 31492,
	FWEID83 = 31496,
	FWMIS0 = 31744,
	FWMIE0 = 31748,
	FWMID0 = 31752,
	FWSCR0 = 32000,
	FWSCR1 = 32004,
	FWSCR2 = 32008,
	FWSCR3 = 32012,
	FWSCR4 = 32016,
	FWSCR5 = 32020,
	FWSCR6 = 32024,
	FWSCR7 = 32028,
	FWSCR8 = 32032,
	FWSCR9 = 32036,
	FWSCR10 = 32040,
	FWSCR11 = 32044,
	FWSCR12 = 32048,
	FWSCR13 = 32052,
	FWSCR14 = 32056,
	FWSCR15 = 32060,
	FWSCR16 = 32064,
	FWSCR17 = 32068,
	FWSCR18 = 32072,
	FWSCR19 = 32076,
	FWSCR20 = 32080,
	FWSCR21 = 32084,
	FWSCR22 = 32088,
	FWSCR23 = 32092,
	FWSCR24 = 32096,
	FWSCR25 = 32100,
	FWSCR26 = 32104,
	FWSCR27 = 32108,
	FWSCR28 = 32112,
	FWSCR29 = 32116,
	FWSCR30 = 32120,
	FWSCR31 = 32124,
	FWSCR32 = 32128,
	FWSCR33 = 32132,
	FWSCR34 = 32136,
	FWSCR35 = 32140,
	FWSCR36 = 32144,
	FWSCR37 = 32148,
	FWSCR38 = 32152,
	FWSCR39 = 32156,
	FWSCR40 = 32160,
	FWSCR41 = 32164,
	FWSCR42 = 32168,
	FWSCR43 = 32172,
	FWSCR44 = 32176,
	FWSCR45 = 32180,
	FWSCR46 = 32184,
	TPEMIMC0 = 32768,
	TPEMIMC1 = 32772,
	TPEMIMC2 = 32776,
	TPEMIMC3 = 32780,
	TPEMIMC4 = 32784,
	TPEMIMC5 = 32788,
	TPEMIMC60 = 32896,
	TPEMIMC70 = 33024,
	TSIM = 34560,
	TFIM = 34564,
	TCIM = 34568,
	TGIM0 = 34576,
	TGIM1 = 34580,
	TEIM0 = 34592,
	TEIM1 = 34596,
	TEIM2 = 34600,
	RIPV = 36864,
	RRC = 36868,
	RCEC = 36872,
	RCDC = 36876,
	RSSIS = 36880,
	RSSIE = 36884,
	RSSID = 36888,
	CABPIBWMC = 36896,
	CABPWMLC = 36928,
	CABPPFLC0 = 36944,
	CABPPWMLC0 = 36960,
	CABPPPFLC00 = 37024,
	CABPULC = 37120,
	CABPIRM = 37184,
	CABPPCM = 37188,
	CABPLCM = 37192,
	CABPCPM = 37248,
	CABPMCPM = 37376,
	CARDNM = 37504,
	CARDMNM = 37508,
	CARDCN = 37520,
	CAEIS0 = 37632,
	CAEIE0 = 37636,
	CAEID0 = 37640,
	CAEIS1 = 37648,
	CAEIE1 = 37652,
	CAEID1 = 37656,
	CAMIS0 = 37696,
	CAMIE0 = 37700,
	CAMID0 = 37704,
	CAMIS1 = 37712,
	CAMIE1 = 37716,
	CAMID1 = 37720,
	CASCR = 37760,
	EAMC = 0,
	EAMS = 4,
	EAIRC = 16,
	EATDQSC = 20,
	EATDQC = 24,
	EATDQAC = 28,
	EATPEC = 32,
	EATMFSC0 = 64,
	EATDQDC0 = 96,
	EATDQM0 = 128,
	EATDQMLM0 = 160,
	EACTQC = 256,
	EACTDQDC = 260,
	EACTDQM = 264,
	EACTDQMLM = 268,
	EAVCC = 304,
	EAVTC = 308,
	EATTFC = 312,
	EACAEC = 512,
	EACC = 516,
	EACAIVC0 = 544,
	EACAULC0 = 576,
	EACOEM = 608,
	EACOIVM0 = 640,
	EACOULM0 = 672,
	EACGSM = 704,
	EATASC = 768,
	EATASENC0 = 800,
	EATASCTENC = 832,
	EATASENM0 = 864,
	EATASCTENM = 896,
	EATASCSTC0 = 928,
	EATASCSTC1 = 932,
	EATASCSTM0 = 936,
	EATASCSTM1 = 940,
	EATASCTC = 944,
	EATASCTM = 948,
	EATASGL0 = 960,
	EATASGL1 = 964,
	EATASGLR = 968,
	EATASGR = 976,
	EATASGRR = 980,
	EATASHCC = 992,
	EATASRIRM = 996,
	EATASSM = 1000,
	EAUSMFSECN = 1024,
	EATFECN = 1028,
	EAFSECN = 1032,
	EADQOECN = 1036,
	EADQSECN = 1040,
	EACKSECN = 1044,
	EAEIS0 = 1280,
	EAEIE0 = 1284,
	EAEID0 = 1288,
	EAEIS1 = 1296,
	EAEIE1 = 1300,
	EAEID1 = 1304,
	EAEIS2 = 1312,
	EAEIE2 = 1316,
	EAEID2 = 1320,
	EASCR = 1408,
	MPSM = 4096,
	MPIC = 4100,
	MPIM = 4104,
	MIOC = 4112,
	MIOM = 4116,
	MXMS = 4120,
	MTFFC = 4128,
	MTPFC = 4132,
	MTPFC2 = 4136,
	MTPFC30 = 4144,
	MTATC0 = 4176,
	MTIM = 4192,
	MRGC = 4224,
	MRMAC0 = 4228,
	MRMAC1 = 4232,
	MRAFC = 4236,
	MRSCE = 4240,
	MRSCP = 4244,
	MRSCC = 4248,
	MRFSCE = 4252,
	MRFSCP = 4256,
	MTRC = 4260,
	MRIM = 4264,
	MRPFM = 4268,
	MPFC0 = 4352,
	MLVC = 4480,
	MEEEC = 4484,
	MLBC = 4488,
	MXGMIIC = 4496,
	MPCH = 4500,
	MANC = 4504,
	MANM = 4508,
	MPLCA1 = 4512,
	MPLCA2 = 4516,
	MPLCA3 = 4520,
	MPLCA4 = 4524,
	MPLCAM = 4528,
	MHDC1 = 4544,
	MHDC2 = 4548,
	MEIS = 4608,
	MEIE = 4612,
	MEID = 4616,
	MMIS0 = 4624,
	MMIE0 = 4628,
	MMID0 = 4632,
	MMIS1 = 4640,
	MMIE1 = 4644,
	MMID1 = 4648,
	MMIS2 = 4656,
	MMIE2 = 4660,
	MMID2 = 4664,
	MMPFTCT = 4864,
	MAPFTCT = 4868,
	MPFRCT = 4872,
	MFCICT = 4876,
	MEEECT = 4880,
	MMPCFTCT0 = 4896,
	MAPCFTCT0 = 4912,
	MPCFRCT0 = 4928,
	MHDCC = 4944,
	MROVFC = 4948,
	MRHCRCEC = 4952,
	MRXBCE = 5120,
	MRXBCP = 5124,
	MRGFCE = 5128,
	MRGFCP = 5132,
	MRBFC = 5136,
	MRMFC = 5140,
	MRUFC = 5144,
	MRPEFC = 5148,
	MRNEFC = 5152,
	MRFMEFC = 5156,
	MRFFMEFC = 5160,
	MRCFCEFC = 5164,
	MRFCEFC = 5168,
	MRRCFEFC = 5172,
	MRUEFC = 5180,
	MROEFC = 5184,
	MRBOEC = 5188,
	MTXBCE = 5376,
	MTXBCP = 5380,
	MTGFCE = 5384,
	MTGFCP = 5388,
	MTBFC = 5392,
	MTMFC = 5396,
	MTUFC = 5400,
	MTEFC = 5404,
	GWMC = 65536,
	GWMS = 65540,
	GWIRC = 65552,
	GWRDQSC = 65556,
	GWRDQC = 65560,
	GWRDQAC = 65564,
	GWRGC = 65568,
	GWRMFSC0 = 65600,
	GWRDQDC0 = 65632,
	GWRDQM0 = 65664,
	GWRDQMLM0 = 65696,
	GWMTIRM = 65792,
	GWMSTLS = 65796,
	GWMSTLR = 65800,
	GWMSTSS = 65804,
	GWMSTSR = 65808,
	GWMAC0 = 65824,
	GWMAC1 = 65828,
	GWVCC = 65840,
	GWVTC = 65844,
	GWTTFC = 65848,
	GWTDCAC00 = 65856,
	GWTDCAC10 = 65860,
	GWTSDCC0 = 65888,
	GWTNM = 65920,
	GWTMNM = 65924,
	GWAC = 65936,
	GWDCBAC0 = 65940,
	GWDCBAC1 = 65944,
	GWIICBSC = 65948,
	GWMDNC = 65952,
	GWTRC0 = 66048,
	GWTPC0 = 66304,
	GWARIRM = 66432,
	GWDCC0 = 66560,
	GWAARSS = 67584,
	GWAARSR0 = 67588,
	GWAARSR1 = 67592,
	GWIDAUAS0 = 67648,
	GWIDASM0 = 67712,
	GWIDASAM00 = 67840,
	GWIDASAM10 = 67844,
	GWIDACAM00 = 67968,
	GWIDACAM10 = 67972,
	GWGRLC = 68096,
	GWGRLULC = 68100,
	GWRLIVC0 = 68224,
	GWRLULC0 = 68228,
	GWIDPC = 68352,
	GWIDC0 = 68608,
	GWDIS0 = 69888,
	GWDIE0 = 69892,
	GWDID0 = 69896,
	GWTSDIS = 70016,
	GWTSDIE = 70020,
	GWTSDID = 70024,
	GWEIS0 = 70032,
	GWEIE0 = 70036,
	GWEID0 = 70040,
	GWEIS1 = 70048,
	GWEIE1 = 70052,
	GWEID1 = 70056,
	GWEIS20 = 70144,
	GWEIE20 = 70148,
	GWEID20 = 70152,
	GWEIS3 = 70272,
	GWEIE3 = 70276,
	GWEID3 = 70280,
	GWEIS4 = 70288,
	GWEIE4 = 70292,
	GWEID4 = 70296,
	GWEIS5 = 70304,
	GWEIE5 = 70308,
	GWEID5 = 70312,
	GWSCR0 = 71680,
	GWSCR1 = 71936,
};

enum DIE_DT___2 {
	DT_FSINGLE___2 = 128,
	DT_FSTART___2 = 144,
	DT_FMID___2 = 160,
	DT_FEND___2 = 176,
	DT_LEMPTY___2 = 192,
	DT_EEMPTY___2 = 208,
	DT_LINKFIX___2 = 0,
	DT_LINK___2 = 224,
	DT_EOS___2 = 240,
	DT_FEMPTY___2 = 64,
	DT_FEMPTY_IS___2 = 16,
	DT_FEMPTY_IC___2 = 32,
	DT_FEMPTY_ND___2 = 48,
	DT_FEMPTY_START = 80,
	DT_FEMPTY_MID = 96,
	DT_FEMPTY_END = 112,
	DT_MASK = 240,
	DIE = 8,
};

enum rswitch_gwca_mode {
	GWMC_OPC_RESET = 0,
	GWMC_OPC_DISABLE = 1,
	GWMC_OPC_CONFIG = 2,
	GWMC_OPC_OPERATION = 3,
};

enum rswitch_etha_mode {
	EAMC_OPC_RESET = 0,
	EAMC_OPC_DISABLE = 1,
	EAMC_OPC_CONFIG = 2,
	EAMC_OPC_OPERATION = 3,
};

struct rswitch_gwca_ts_info {
	struct sk_buff *skb;
	struct list_head list;
	int port;
	u8 tag;
};

struct rswitch_ext_desc;

struct rswitch_ext_ts_desc;

struct rswitch_ts_desc;

struct rswitch_gwca_queue {
	union {
		struct rswitch_ext_desc *tx_ring;
		struct rswitch_ext_ts_desc *rx_ring;
		struct rswitch_ts_desc *ts_ring;
	};
	dma_addr_t ring_dma;
	int ring_size;
	int cur;
	int dirty;
	int index;
	bool dir_tx;
	struct sk_buff **skbs;
	struct net_device *ndev;
};

struct rswitch_desc;

struct rswitch_gwca {
	int index;
	struct rswitch_desc *linkfix_table;
	dma_addr_t linkfix_table_dma;
	u32 linkfix_table_size;
	struct rswitch_gwca_queue *queues;
	int num_queues;
	struct rswitch_gwca_queue ts_queue;
	struct list_head ts_info_list;
	unsigned long used[2];
	u32 tx_irq_bits[4];
	u32 rx_irq_bits[4];
	int speed;
};

struct rswitch_etha {
	int index;
	void *addr;
	void *coma_addr;
	bool external_phy;
	struct mii_bus *mii;
	phy_interface_t phy_interface;
	u32 psmcs;
	u8 mac_addr[32];
	int link;
	int speed;
	bool operated;
};

struct rswitch_mac_table_entry;

struct rswitch_mfwd {
	struct rswitch_mac_table_entry *mac_table_entries;
	int num_mac_table_entries;
};

struct rswitch_device;

struct rswitch_private {
	struct platform_device *pdev;
	void *addr;
	struct rcar_gen4_ptp_private *ptp_priv;
	struct rswitch_device *rdev[3];
	unsigned long opened_ports[1];
	struct rswitch_gwca gwca;
	struct rswitch_etha etha[3];
	struct rswitch_mfwd mfwd;
	spinlock_t lock;
	struct clk *clk;
	bool etha_no_runtime_change;
	bool gwca_halt;
};

struct rswitch_device {
	struct rswitch_private *priv;
	struct net_device *ndev;
	struct napi_struct napi;
	void *addr;
	struct rswitch_gwca_queue *tx_queue;
	struct rswitch_gwca_queue *rx_queue;
	u8 ts_tag;
	bool disabled;
	int port;
	struct rswitch_etha *etha;
	struct device_node *np_port;
	struct phy *serdes;
};

struct rswitch_desc {
	__le16 info_ds;
	u8 die_dt;
	__u8 dptrh;
	__le32 dptrl;
};

struct rswitch_ext_desc {
	struct rswitch_desc desc;
	__le64 info1;
};

struct rswitch_ext_ts_desc {
	struct rswitch_desc desc;
	__le64 info1;
	__le32 ts_nsec;
	__le32 ts_sec;
};

struct rswitch_ts_desc {
	struct rswitch_desc desc;
	__le32 ts_nsec;
	__le32 ts_sec;
};

struct ep_device {
	struct usb_endpoint_descriptor *desc;
	struct usb_device *udev;
	struct device dev;
};

enum xhci_ep_reset_type {
	EP_HARD_RESET = 0,
	EP_SOFT_RESET = 1,
};

union udc_setup_data {
	u32 data[2];
	struct usb_ctrlrequest request;
};

struct amd5536udc;

struct brcmstb_waketmr {
	struct rtc_device *rtc;
	struct device *dev;
	void *base;
	unsigned int wake_irq;
	unsigned int alarm_irq;
	struct notifier_block reboot_notifier;
	struct clk *clk;
	u32 rate;
	unsigned long rtc_alarm;
	bool alarm_en;
	bool alarm_expired;
};

struct wktmr_time {
	u32 sec;
	u32 pre;
};

struct ec_params_i2c_passthru_msg {
	uint16_t addr_flags;
	uint16_t len;
};

struct ec_params_i2c_passthru {
	uint8_t port;
	uint8_t num_msgs;
	struct ec_params_i2c_passthru_msg msg[0];
};

struct ec_response_i2c_passthru {
	uint8_t i2c_status;
	uint8_t num_msgs;
	uint8_t data[0];
};

struct ec_i2c_device {
	struct device *dev;
	struct i2c_adapter adap;
	struct cros_ec_device *ec;
	u16 remote_bus;
	u8 request_buf[256];
	u8 response_buf[256];
};

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

enum hwmon_power_attributes {
	hwmon_power_enable = 0,
	hwmon_power_average = 1,
	hwmon_power_average_interval = 2,
	hwmon_power_average_interval_max = 3,
	hwmon_power_average_interval_min = 4,
	hwmon_power_average_highest = 5,
	hwmon_power_average_lowest = 6,
	hwmon_power_average_max = 7,
	hwmon_power_average_min = 8,
	hwmon_power_input = 9,
	hwmon_power_input_highest = 10,
	hwmon_power_input_lowest = 11,
	hwmon_power_reset_history = 12,
	hwmon_power_accuracy = 13,
	hwmon_power_cap = 14,
	hwmon_power_cap_hyst = 15,
	hwmon_power_cap_max = 16,
	hwmon_power_cap_min = 17,
	hwmon_power_min = 18,
	hwmon_power_max = 19,
	hwmon_power_crit = 20,
	hwmon_power_lcrit = 21,
	hwmon_power_label = 22,
	hwmon_power_alarm = 23,
	hwmon_power_cap_alarm = 24,
	hwmon_power_min_alarm = 25,
	hwmon_power_max_alarm = 26,
	hwmon_power_lcrit_alarm = 27,
	hwmon_power_crit_alarm = 28,
	hwmon_power_rated_min = 29,
	hwmon_power_rated_max = 30,
};

enum hwmon_energy_attributes {
	hwmon_energy_enable = 0,
	hwmon_energy_input = 1,
	hwmon_energy_label = 2,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_enable = 0,
	hwmon_humidity_input = 1,
	hwmon_humidity_label = 2,
	hwmon_humidity_min = 3,
	hwmon_humidity_min_hyst = 4,
	hwmon_humidity_max = 5,
	hwmon_humidity_max_hyst = 6,
	hwmon_humidity_alarm = 7,
	hwmon_humidity_fault = 8,
	hwmon_humidity_rated_min = 9,
	hwmon_humidity_rated_max = 10,
};

enum hwmon_fan_attributes {
	hwmon_fan_enable = 0,
	hwmon_fan_input = 1,
	hwmon_fan_label = 2,
	hwmon_fan_min = 3,
	hwmon_fan_max = 4,
	hwmon_fan_div = 5,
	hwmon_fan_pulses = 6,
	hwmon_fan_target = 7,
	hwmon_fan_alarm = 8,
	hwmon_fan_min_alarm = 9,
	hwmon_fan_max_alarm = 10,
	hwmon_fan_fault = 11,
	hwmon_fan_beep = 12,
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct hwmon_device {
	const char *name;
	const char *label;
	struct device dev;
	const struct hwmon_chip_info *chip;
	struct list_head tzdata;
	struct attribute_group group;
	const struct attribute_group **groups;
};

struct hwmon_thermal_data {
	struct list_head node;
	struct device *dev;
	int index;
	struct thermal_zone_device *tzd;
};

struct hwmon_device_attribute {
	struct device_attribute dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	u32 label;
};

struct rtd119x_watchdog_device {
	struct watchdog_device wdt_dev;
	void *base;
	struct clk *clk;
};

struct private_data {
	struct list_head node;
	cpumask_var_t cpus;
	struct device *cpu_dev;
	struct cpufreq_frequency_table *freq_table;
	bool have_static_opps;
	int opp_token;
};

struct mmc_clk_phase {
	bool valid;
	u16 in_deg;
	u16 out_deg;
};

struct mmc_clk_phase_map {
	struct mmc_clk_phase phase[11];
};

struct exynos_ufs_uic_attr;

struct exynos_ufs;

struct exynos_ufs_drv_data {
	const struct ufs_hba_variant_ops *vops;
	struct exynos_ufs_uic_attr *uic_attr;
	unsigned int quirks;
	unsigned int opts;
	int (*drv_init)(struct device *, struct exynos_ufs *);
	int (*pre_link)(struct exynos_ufs *);
	int (*post_link)(struct exynos_ufs *);
	int (*pre_pwr_change)(struct exynos_ufs *, struct ufs_pa_layer_attr *);
	int (*post_pwr_change)(struct exynos_ufs *, struct ufs_pa_layer_attr *);
	int (*pre_hce_enable)(struct exynos_ufs *);
	int (*post_hce_enable)(struct exynos_ufs *);
};

struct exynos_ufs_uic_attr {
	unsigned int tx_trailingclks;
	unsigned int tx_dif_p_nsec;
	unsigned int tx_dif_n_nsec;
	unsigned int tx_high_z_cnt_nsec;
	unsigned int tx_base_unit_nsec;
	unsigned int tx_gran_unit_nsec;
	unsigned int tx_sleep_cnt;
	unsigned int tx_min_activatetime;
	unsigned int rx_filler_enable;
	unsigned int rx_dif_p_nsec;
	unsigned int rx_hibern8_wait_nsec;
	unsigned int rx_base_unit_nsec;
	unsigned int rx_gran_unit_nsec;
	unsigned int rx_sleep_cnt;
	unsigned int rx_stall_cnt;
	unsigned int rx_hs_g1_sync_len_cap;
	unsigned int rx_hs_g2_sync_len_cap;
	unsigned int rx_hs_g3_sync_len_cap;
	unsigned int rx_hs_g1_prep_sync_len_cap;
	unsigned int rx_hs_g2_prep_sync_len_cap;
	unsigned int rx_hs_g3_prep_sync_len_cap;
	unsigned int cmn_pwm_clk_ctrl;
	unsigned int pa_dbg_option_suite;
	unsigned int rx_adv_fine_gran_sup_en;
	unsigned int rx_adv_fine_gran_step;
	unsigned int rx_min_actv_time_cap;
	unsigned int rx_hibern8_time_cap;
	unsigned int rx_adv_min_actv_time_cap;
	unsigned int rx_adv_hibern8_time_cap;
	unsigned int pa_granularity;
	unsigned int pa_tactivate;
	unsigned int pa_hibern8time;
};

struct ufs_phy_time_cfg {
	u32 tx_linereset_p;
	u32 tx_linereset_n;
	u32 tx_high_z_cnt;
	u32 tx_base_n_val;
	u32 tx_gran_n_val;
	u32 tx_sleep_cnt;
	u32 rx_linereset;
	u32 rx_hibern8_wait;
	u32 rx_base_n_val;
	u32 rx_gran_n_val;
	u32 rx_sleep_cnt;
	u32 rx_stall_cnt;
};

struct exynos_ufs {
	struct ufs_hba *hba;
	struct phy *phy;
	void *reg_hci;
	void *reg_unipro;
	void *reg_ufsp;
	struct clk *clk_hci_core;
	struct clk *clk_unipro_main;
	struct clk *clk_apb;
	u32 pclk_rate;
	u32 pclk_div;
	u32 pclk_avail_min;
	u32 pclk_avail_max;
	unsigned long mclk_rate;
	int avail_ln_rx;
	int avail_ln_tx;
	int rx_sel_idx;
	struct ufs_pa_layer_attr dev_req_params;
	struct ufs_phy_time_cfg t_cfg;
	ktime_t entry_hibern8_t;
	const struct exynos_ufs_drv_data *drv_data;
	struct regmap *sysreg;
	u32 shareability_reg_offset;
	u32 opts;
};

enum {
	UNIPRO_L1_5 = 0,
	UNIPRO_L2 = 1,
	UNIPRO_L3 = 2,
	UNIPRO_L4 = 3,
	UNIPRO_DME = 4,
};

enum {
	CPORT_IDLE = 0,
	CPORT_CONNECTED = 1,
};

enum {
	DEV_ID = 0,
	PEER_DEV_ID = 1,
	PEER_CPORT_ID = 0,
	TRAFFIC_CLASS = 0,
};

enum {
	SYNC_LEN_G1 = 80000,
	SYNC_LEN_G2 = 40000,
	SYNC_LEN_G3 = 20000,
};

enum scmi_sensor_protocol_cmd {
	SENSOR_DESCRIPTION_GET = 3,
	SENSOR_TRIP_POINT_NOTIFY = 4,
	SENSOR_TRIP_POINT_CONFIG = 5,
	SENSOR_READING_GET = 6,
	SENSOR_AXIS_DESCRIPTION_GET = 7,
	SENSOR_LIST_UPDATE_INTERVALS = 8,
	SENSOR_CONFIG_GET = 9,
	SENSOR_CONFIG_SET = 10,
	SENSOR_CONTINUOUS_UPDATE_NOTIFY = 11,
	SENSOR_NAME_GET = 12,
	SENSOR_AXIS_NAME_GET = 13,
};

struct scmi_sens_ipriv {
	void *priv;
	struct device *dev;
};

struct sensors_info {
	u32 version;
	int num_sensors;
	int max_requests;
	u64 reg_addr;
	u32 reg_size;
	struct scmi_sensor_info *sensors;
};

struct scmi_msg_resp_sensor_attributes {
	__le16 num_sensors;
	u8 max_requests;
	u8 reserved;
	__le32 reg_addr_low;
	__le32 reg_addr_high;
	__le32 reg_size;
};

struct scmi_apriv {
	bool any_axes_support_extended_names;
	struct scmi_sensor_info *s;
};

struct scmi_msg_resp_attrs {
	__le32 min_range_low;
	__le32 min_range_high;
	__le32 max_range_low;
	__le32 max_range_high;
};

struct scmi_sensor_reading_resp {
	__le32 sensor_value_low;
	__le32 sensor_value_high;
	__le32 timestamp_low;
	__le32 timestamp_high;
};

struct scmi_msg_sensor_request_notify {
	__le32 id;
	__le32 event_control;
};

struct scmi_msg_sensor_description {
	__le32 desc_index;
};

struct scmi_sensor_descriptor {
	__le32 id;
	__le32 attributes_low;
	__le32 attributes_high;
	u8 name[16];
	__le32 power;
	__le32 resolution;
	struct scmi_msg_resp_attrs scalar_attrs;
};

struct scmi_msg_resp_sensor_description {
	__le16 num_returned;
	__le16 num_remaining;
	struct scmi_sensor_descriptor desc[0];
};

struct scmi_msg_sensor_list_update_intervals {
	__le32 id;
	__le32 index;
};

struct scmi_msg_resp_sensor_list_update_intervals {
	__le32 num_intervals_flags;
	__le32 intervals[0];
};

struct scmi_msg_sensor_axis_description_get {
	__le32 id;
	__le32 axis_desc_index;
};

struct scmi_axis_descriptor {
	__le32 id;
	__le32 attributes_low;
	__le32 attributes_high;
	u8 name[16];
	__le32 resolution;
	struct scmi_msg_resp_attrs attrs;
};

struct scmi_msg_resp_sensor_axis_description {
	__le32 num_axis_flags;
	struct scmi_axis_descriptor desc[0];
};

struct scmi_sensor_axis_name_descriptor {
	__le32 axis_id;
	u8 name[64];
};

struct scmi_msg_resp_sensor_axis_names_description {
	__le32 num_axis_flags;
	struct scmi_sensor_axis_name_descriptor desc[0];
};

struct scmi_msg_set_sensor_trip_point {
	__le32 id;
	__le32 event_control;
	__le32 value_low;
	__le32 value_high;
};

struct scmi_msg_sensor_reading_get {
	__le32 id;
	__le32 flags;
};

struct scmi_resp_sensor_reading_complete {
	__le32 id;
	__le32 readings_low;
	__le32 readings_high;
};

struct scmi_resp_sensor_reading_complete_v3 {
	__le32 id;
	struct scmi_sensor_reading_resp readings[0];
};

struct scmi_msg_sensor_config_set {
	__le32 id;
	__le32 sensor_config;
};

struct scmi_sensor_trip_notify_payld {
	__le32 agent_id;
	__le32 sensor_id;
	__le32 trip_point_desc;
};

struct scmi_sensor_trip_point_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int sensor_id;
	unsigned int trip_point_desc;
};

struct scmi_sensor_update_notify_payld {
	__le32 agent_id;
	__le32 sensor_id;
	struct scmi_sensor_reading_resp readings[0];
};

struct scmi_sensor_update_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int sensor_id;
	unsigned int readings_count;
	struct scmi_sensor_reading readings[0];
};

struct capsule_info {
	efi_capsule_header_t header;
	efi_capsule_header_t *capsule;
	int reset_type;
	long index;
	size_t count;
	size_t total_size;
	struct page **pages;
	phys_addr_t *phys;
	size_t page_bytes_remain;
};

struct quirks_list_struct {
	struct hid_device_id hid_bl_item;
	struct list_head node;
};

struct cros_usbpd_notify_data {
	struct device *dev;
	struct cros_ec_device *ec;
	struct notifier_block nb;
};

struct ec_response_host_event_status {
	uint32_t status;
};

struct extcon_dev_notifier_devres {
	struct extcon_dev *edev;
	unsigned int id;
	struct notifier_block *nb;
};

struct pmu_irq_ops {
	void (*enable_pmuirq)(unsigned int);
	void (*disable_pmuirq)(unsigned int);
	void (*free_pmuirq)(unsigned int, int, void __attribute__((btf_type_tag("percpu"))) *);
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

struct snvs_lpgpr_cfg {
	int offset;
	int offset_hplr;
	int offset_lplr;
	int size;
};

struct device_d;

struct snvs_lpgpr_priv {
	struct device_d *dev;
	struct regmap *regmap;
	struct nvmem_config cfg;
	const struct snvs_lpgpr_cfg *dcfg;
};

struct dmaengine_pcm_runtime_data {
	struct dma_chan *dma_chan;
	dma_cookie_t cookie;
	unsigned int pos;
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
};

struct flow_indir_dev_info {
	void *data;
	struct net_device *dev;
	struct Qdisc *sch;
	enum tc_setup_type type;
	void (*cleanup)(struct flow_block_cb *);
	struct list_head list;
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	struct list_head *cb_list;
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_arp {
	struct flow_dissector_key_arp *key;
	struct flow_dissector_key_arp *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_dissector_key_ports_range;

struct flow_match_ports_range {
	struct flow_dissector_key_ports_range *key;
	struct flow_dissector_key_ports_range *mask;
};

struct flow_dissector_key_ports_range {
	union {
		struct flow_dissector_key_ports tp;
		struct {
			struct flow_dissector_key_ports tp_min;
			struct flow_dissector_key_ports tp_max;
		};
	};
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_ipsec {
	struct flow_dissector_key_ipsec *key;
	struct flow_dissector_key_ipsec *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

struct flow_match_pppoe {
	struct flow_dissector_key_pppoe *key;
	struct flow_dissector_key_pppoe *mask;
};

struct flow_match_l2tpv3 {
	struct flow_dissector_key_l2tpv3 *key;
	struct flow_dissector_key_l2tpv3 *mask;
};

struct bpf_dummy_ops_test_args {
	u64 args[12];
	struct bpf_dummy_ops_state state;
};

typedef int (*dummy_ops_test_ret_fn)(struct bpf_dummy_ops_state *, ...);

enum {
	ETHTOOL_A_MM_STAT_UNSPEC = 0,
	ETHTOOL_A_MM_STAT_PAD = 1,
	ETHTOOL_A_MM_STAT_REASSEMBLY_ERRORS = 2,
	ETHTOOL_A_MM_STAT_SMD_ERRORS = 3,
	ETHTOOL_A_MM_STAT_REASSEMBLY_OK = 4,
	ETHTOOL_A_MM_STAT_RX_FRAG_COUNT = 5,
	ETHTOOL_A_MM_STAT_TX_FRAG_COUNT = 6,
	ETHTOOL_A_MM_STAT_HOLD_COUNT = 7,
	__ETHTOOL_A_MM_STAT_CNT = 8,
	ETHTOOL_A_MM_STAT_MAX = 7,
};

enum {
	ETHTOOL_A_MM_UNSPEC = 0,
	ETHTOOL_A_MM_HEADER = 1,
	ETHTOOL_A_MM_PMAC_ENABLED = 2,
	ETHTOOL_A_MM_TX_ENABLED = 3,
	ETHTOOL_A_MM_TX_ACTIVE = 4,
	ETHTOOL_A_MM_TX_MIN_FRAG_SIZE = 5,
	ETHTOOL_A_MM_RX_MIN_FRAG_SIZE = 6,
	ETHTOOL_A_MM_VERIFY_ENABLED = 7,
	ETHTOOL_A_MM_VERIFY_STATUS = 8,
	ETHTOOL_A_MM_VERIFY_TIME = 9,
	ETHTOOL_A_MM_MAX_VERIFY_TIME = 10,
	ETHTOOL_A_MM_STATS = 11,
	__ETHTOOL_A_MM_CNT = 12,
	ETHTOOL_A_MM_MAX = 11,
};

struct mm_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_mm_state state;
	struct ethtool_mm_stats stats;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
	TCPF_ACK_DEFERRED = 64,
};

enum {
	BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,
	BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,
};

struct mptcp_out_options {};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_MST_STATE = 2,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 4,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL = 8,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 9,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 10,
	SWITCHDEV_ATTR_ID_BRIDGE_MST = 11,
	SWITCHDEV_ATTR_ID_MRP_PORT_ROLE = 12,
	SWITCHDEV_ATTR_ID_VLAN_MSTI = 13,
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
	SWITCHDEV_PORT_OBJ_ADD = 7,
	SWITCHDEV_PORT_OBJ_DEL = 8,
	SWITCHDEV_PORT_ATTR_SET = 9,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
	SWITCHDEV_BRPORT_OFFLOADED = 15,
	SWITCHDEV_BRPORT_UNOFFLOADED = 16,
	SWITCHDEV_BRPORT_REPLAY = 17,
};

typedef void switchdev_deferred_func_t(struct net_device *, const void *);

struct switchdev_deferred_item {
	struct list_head list;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	switchdev_deferred_func_t *func;
	unsigned long data[0];
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
	const void *ctx;
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		struct switchdev_mst_state mst_state;
		struct switchdev_brport_flags brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		u16 vlan_protocol;
		bool mst;
		bool mc_disabled;
		u8 mrp_port_role;
		struct switchdev_vlan_msti vlan_msti;
	} u;
};

struct switchdev_notifier_port_attr_info {
	struct switchdev_notifier_info info;
	const struct switchdev_attr *attr;
	bool handled;
};

struct switchdev_notifier_port_obj_info {
	struct switchdev_notifier_info info;
	const struct switchdev_obj *obj;
	bool handled;
};

struct switchdev_nested_priv {
	bool (*check_cb)(const struct net_device *);
	bool (*foreign_dev_check_cb)(const struct net_device *, const struct net_device *);
	const struct net_device *dev;
	struct net_device *lower_dev;
};

struct switchdev_notifier_fdb_info {
	struct switchdev_notifier_info info;
	const unsigned char *addr;
	u16 vid;
	u8 added_by_user: 1;
	u8 is_local: 1;
	u8 locked: 1;
	u8 offloaded: 1;
};

struct switchdev_brport {
	struct net_device *dev;
	const void *ctx;
	struct notifier_block *atomic_nb;
	struct notifier_block *blocking_nb;
	bool tx_fwd_offload;
};

struct switchdev_notifier_brport_info {
	struct switchdev_notifier_info info;
	const struct switchdev_brport brport;
};

enum aarch64_insn_special_register {
	AARCH64_INSN_SPCLREG_SPSR_EL1 = 49664,
	AARCH64_INSN_SPCLREG_ELR_EL1 = 49665,
	AARCH64_INSN_SPCLREG_SP_EL0 = 49672,
	AARCH64_INSN_SPCLREG_SPSEL = 49680,
	AARCH64_INSN_SPCLREG_CURRENTEL = 49682,
	AARCH64_INSN_SPCLREG_DAIF = 55825,
	AARCH64_INSN_SPCLREG_NZCV = 55824,
	AARCH64_INSN_SPCLREG_FPCR = 55840,
	AARCH64_INSN_SPCLREG_DSPSR_EL0 = 55848,
	AARCH64_INSN_SPCLREG_DLR_EL0 = 55849,
	AARCH64_INSN_SPCLREG_SPSR_EL2 = 57856,
	AARCH64_INSN_SPCLREG_ELR_EL2 = 57857,
	AARCH64_INSN_SPCLREG_SP_EL1 = 57864,
	AARCH64_INSN_SPCLREG_SPSR_INQ = 57880,
	AARCH64_INSN_SPCLREG_SPSR_ABT = 57881,
	AARCH64_INSN_SPCLREG_SPSR_UND = 57882,
	AARCH64_INSN_SPCLREG_SPSR_FIQ = 57883,
	AARCH64_INSN_SPCLREG_SPSR_EL3 = 61952,
	AARCH64_INSN_SPCLREG_ELR_EL3 = 61953,
	AARCH64_INSN_SPCLREG_SP_EL2 = 61968,
};

struct fault_info {
	int (*fn)(unsigned long, unsigned long, struct pt_regs *);
	int sig;
	int code;
	const char *name;
};

struct hyp_shared_pfn {
	u64 pfn;
	int count;
	struct rb_node node;
};

typedef void (*hcall_t)(struct kvm_cpu_context___2 *);

struct ghash_key {
	be128 k;
	u64 h[0];
};

struct gcm_aes_ctx {
	struct crypto_aes_ctx aes_key;
	u8 nonce[4];
	struct ghash_key ghash_key;
};

struct ghash_desc_ctx {
	u64 digest[2];
	u8 buf[16];
	u32 count;
};

typedef void (*btf_trace_contention_begin)(void *, void *, unsigned int);

typedef void (*btf_trace_contention_end)(void *, void *, int);

struct trace_event_raw_contention_begin {
	struct trace_entry ent;
	void *lock_addr;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_contention_end {
	struct trace_entry ent;
	void *lock_addr;
	int ret;
	char __data[0];
};

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

struct trace_event_data_offsets_contention_begin {};

struct trace_event_data_offsets_contention_end {};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

struct rcu_exp_work {
	unsigned long rew_s;
	struct work_struct rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	unsigned long gp_seq;
	unsigned long gp_seq_needed;
	unsigned long completedqs;
	unsigned long qsmask;
	unsigned long rcu_gp_init_mask;
	unsigned long qsmaskinit;
	unsigned long qsmaskinitnext;
	unsigned long expmask;
	unsigned long expmaskinit;
	unsigned long expmaskinitnext;
	unsigned long cbovldmask;
	unsigned long ffmask;
	unsigned long grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	unsigned long boost_time;
	struct mutex boost_kthread_mutex;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	unsigned long n_boosts;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	raw_spinlock_t fqslock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t exp_lock;
	unsigned long exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	raw_spinlock_t exp_poll_lock;
	unsigned long exp_seq_poll_rq;
	struct work_struct exp_poll_wq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_snap_record {
	unsigned long gp_seq;
	u64 cputime_irq;
	u64 cputime_softirq;
	u64 cputime_system;
	unsigned long nr_hardirqs;
	unsigned int nr_softirqs;
	unsigned long long nr_csw;
	unsigned long jiffies;
};

struct rcu_data {
	unsigned long gp_seq;
	unsigned long gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool cpu_started;
	struct rcu_node *mynode;
	unsigned long grpmask;
	unsigned long ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long qlen_last_fqs_check;
	unsigned long n_cbs_invoked;
	unsigned long n_force_qs_snap;
	long blimit;
	int dynticks_snap;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	unsigned long barrier_seq_snap;
	struct callback_head barrier_head;
	int exp_dynticks_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	unsigned long rcuc_activity;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	unsigned long rcu_iw_gp_seq;
	unsigned long rcu_ofl_gp_seq;
	short rcu_ofl_gp_flags;
	unsigned long rcu_onl_gp_seq;
	short rcu_onl_gp_flags;
	unsigned long last_fqs_resched;
	unsigned long last_sched_clock;
	struct rcu_snap_record snap_record;
	long lazy_len;
	int cpu;
};

struct rcu_state {
	struct rcu_node node[17];
	struct rcu_node *level[3];
	int ncpus;
	int n_online_cpus;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned long gp_seq;
	unsigned long gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short gp_flags;
	short gp_state;
	unsigned long gp_wake_time;
	unsigned long gp_wake_seq;
	unsigned long gp_seq_polled;
	unsigned long gp_seq_polled_snap;
	unsigned long gp_seq_polled_exp_snap;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	unsigned long barrier_sequence;
	raw_spinlock_t barrier_lock;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	unsigned long expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	unsigned long jiffies_force_qs;
	unsigned long jiffies_kick_kthreads;
	unsigned long n_force_qs;
	unsigned long gp_start;
	unsigned long gp_end;
	unsigned long gp_activity;
	unsigned long gp_req_activity;
	unsigned long jiffies_stall;
	int nr_fqs_jiffies_stall;
	unsigned long jiffies_resched;
	unsigned long n_force_qs_gpstart;
	const char *name;
	char abbr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	arch_spinlock_t ofl_lock;
	int nocb_is_setup;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rcu_gp_oldstate {
	unsigned long rgos_norm;
	unsigned long rgos_exp;
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct rcu_gp_oldstate head_free_gp_snap;
	struct list_head bulk_head_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	unsigned long head_gp_snap;
	atomic_t head_count;
	struct list_head bulk_head[2];
	atomic_t bulk_count[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool initialized;
	struct delayed_work page_cache_work;
	atomic_t backoff_page_cache_fill;
	atomic_t work_in_progress;
	struct hrtimer hrtimer;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

struct kvfree_rcu_bulk_data {
	struct list_head list;
	struct rcu_gp_oldstate gp_snap;
	unsigned long nr_records;
	void *records[0];
};

struct rcu_stall_chk_rdr {
	int nesting;
	union rcu_special rs;
	bool on_blkd_list;
};

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_favordynmods___2 = 1,
	Opt_memory_localevents = 2,
	Opt_memory_recursiveprot = 3,
	Opt_memory_hugetlb_accounting = 4,
	nr__cgroup2_params = 5,
};

enum cgroup_opt_features {
	OPT_FEATURE_COUNT = 0,
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_level;
	u64 dst_id;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	u32 comm;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
};

struct lpm_trie_node;

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node __attribute__((btf_type_tag("rcu"))) *root;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
};

struct lpm_trie_node {
	struct callback_head rcu;
	struct lpm_trie_node __attribute__((btf_type_tag("rcu"))) *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct bpf_lpm_trie_key {
	__u32 prefixlen;
	__u8 data[0];
};

typedef u64 (*btf_bpf_cgrp_storage_get)(struct bpf_map *, struct cgroup *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_cgrp_storage_delete)(struct bpf_map *, struct cgroup *);

struct vm_event_state {
	unsigned long event[107];
};

struct contig_page_info {
	unsigned long free_pages;
	unsigned long free_blocks_total;
	unsigned long free_blocks_suitable;
};

enum {
	ONLINE_POLICY_CONTIG_ZONES = 0,
	ONLINE_POLICY_AUTO_MOVABLE = 1,
};

enum {
	MEMMAP_ON_MEMORY_DISABLE = 0,
	MEMMAP_ON_MEMORY_ENABLE = 1,
	MEMMAP_ON_MEMORY_FORCE = 2,
};

struct auto_movable_stats {
	unsigned long kernel_early_pages;
	unsigned long movable_pages;
};

struct auto_movable_group_stats {
	unsigned long movable_pages;
	unsigned long req_kernel_early_pages;
};

struct files_stat_struct {
	unsigned long nr_files;
	unsigned long nr_free_files;
	unsigned long max_files;
};

struct backing_file {
	struct file file;
	struct path user_path;
};

struct old_utimbuf32 {
	old_time32_t actime;
	old_time32_t modtime;
};

struct if_dqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
};

struct fs_qfilestat {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
};

typedef struct fs_qfilestat fs_qfilestat_t;

struct fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	fs_qfilestat_t qs_uquota;
	fs_qfilestat_t qs_gquota;
	__u32 qs_incoredqs;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
};

struct fs_qfilestatv {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	__u32 qfs_pad;
};

struct fs_quota_statv {
	__s8 qs_version;
	__u8 qs_pad1;
	__u16 qs_flags;
	__u32 qs_incoredqs;
	struct fs_qfilestatv qs_uquota;
	struct fs_qfilestatv qs_gquota;
	struct fs_qfilestatv qs_pquota;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	__u16 qs_rtbwarnlimit;
	__u16 qs_pad3;
	__u32 qs_pad4;
	__u64 qs_pad2[7];
};

struct fs_disk_quota {
	__s8 d_version;
	__s8 d_flags;
	__u16 d_fieldmask;
	__u32 d_id;
	__u64 d_blk_hardlimit;
	__u64 d_blk_softlimit;
	__u64 d_ino_hardlimit;
	__u64 d_ino_softlimit;
	__u64 d_bcount;
	__u64 d_icount;
	__s32 d_itimer;
	__s32 d_btimer;
	__u16 d_iwarns;
	__u16 d_bwarns;
	__s8 d_itimer_hi;
	__s8 d_btimer_hi;
	__s8 d_rtbtimer_hi;
	__s8 d_padding2;
	__u64 d_rtb_hardlimit;
	__u64 d_rtb_softlimit;
	__u64 d_rtbcount;
	__s32 d_rtbtimer;
	__u16 d_rtbwarns;
	__s16 d_padding3;
	char d_padding4[8];
};

struct if_dqinfo {
	__u64 dqi_bgrace;
	__u64 dqi_igrace;
	__u32 dqi_flags;
	__u32 dqi_valid;
};

struct if_nextdqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	__u32 dqb_id;
};

enum {
	MOUNTPROC3_NULL = 0,
	MOUNTPROC3_MNT = 1,
	MOUNTPROC3_DUMP = 2,
	MOUNTPROC3_UMNT = 3,
	MOUNTPROC3_UMNTALL = 4,
	MOUNTPROC3_EXPORT = 5,
};

enum {
	MOUNTPROC_NULL = 0,
	MOUNTPROC_MNT = 1,
	MOUNTPROC_DUMP = 2,
	MOUNTPROC_UMNT = 3,
	MOUNTPROC_UMNTALL = 4,
	MOUNTPROC_EXPORT = 5,
};

struct mountres {
	int errno;
	struct nfs_fh *fh;
	unsigned int *auth_count;
	rpc_authflavor_t *auth_flavors;
};

struct callback_op {
	__be32 (*process_op)(void *, void *, struct cb_process_state *);
	__be32 (*decode_args)(struct svc_rqst *, struct xdr_stream *, void *);
	__be32 (*encode_res)(struct svc_rqst *, struct xdr_stream *, const void *);
	long res_maxsize;
};

enum nfs4_callback_opnum {
	OP_CB_GETATTR = 3,
	OP_CB_RECALL = 4,
	OP_CB_LAYOUTRECALL = 5,
	OP_CB_NOTIFY = 6,
	OP_CB_PUSH_DELEG = 7,
	OP_CB_RECALL_ANY = 8,
	OP_CB_RECALLABLE_OBJ_AVAIL = 9,
	OP_CB_RECALL_SLOT = 10,
	OP_CB_SEQUENCE = 11,
	OP_CB_WANTS_CANCELLED = 12,
	OP_CB_NOTIFY_LOCK = 13,
	OP_CB_NOTIFY_DEVICEID = 14,
	OP_CB_OFFLOAD = 15,
	OP_CB_ILLEGAL = 10044,
};

struct cb_compound_hdr_arg {
	unsigned int taglen;
	const char *tag;
	unsigned int minorversion;
	unsigned int cb_ident;
	unsigned int nops;
};

struct cb_compound_hdr_res {
	__be32 *status;
	unsigned int taglen;
	const char *tag;
	__be32 *nops;
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short semadj[0];
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	time64_t sem_otime;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sem sems[0];
};

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	long sem_otime;
	long sem_ctime;
	unsigned long sem_nsems;
	unsigned long __unused3;
	unsigned long __unused4;
};

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	unsigned short sem_nsems;
};

struct compat_semid64_ds {
	struct compat_ipc64_perm sem_perm;
	compat_ulong_t sem_otime;
	compat_ulong_t sem_otime_high;
	compat_ulong_t sem_ctime;
	compat_ulong_t sem_ctime_high;
	compat_ulong_t sem_nsems;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct compat_semid_ds {
	struct compat_ipc_perm sem_perm;
	old_time32_t sem_otime;
	old_time32_t sem_ctime;
	compat_uptr_t sem_base;
	compat_uptr_t sem_pending;
	compat_uptr_t sem_pending_last;
	compat_uptr_t undo;
	unsigned short sem_nsems;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct crypto_kpp {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct kpp_request;

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	struct crypto_alg base;
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct kpp_instance {
	void (*free)(struct kpp_instance *);
	union {
		struct {
			char head[48];
			struct crypto_instance base;
		} s;
		struct kpp_alg alg;
	};
};

struct crypto_istat_kpp {
	atomic64_t setsecret_cnt;
	atomic64_t generate_public_key_cnt;
	atomic64_t compute_shared_secret_cnt;
	atomic64_t err_cnt;
};

struct crypto_kpp_spawn {
	struct crypto_spawn base;
};

struct crypto_report_kpp {
	char type[64];
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct request_queue *, char *);
	ssize_t (*store)(struct request_queue *, const char *, size_t);
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

struct wrapper {
	cmp_func_t cmp;
	swap_func_t swap;
};

enum {
	MAX_OPT_ARGS = 3,
};

typedef void sg_free_fn(struct scatterlist *, unsigned int);

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

struct sg_append_table {
	struct sg_table sgt;
	struct scatterlist *prv;
	unsigned int total_nents;
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

struct mvebu_sei_interrupt_range {
	u32 first;
	u32 size;
};

struct mvebu_sei_caps {
	struct mvebu_sei_interrupt_range ap_range;
	struct mvebu_sei_interrupt_range cp_range;
};

struct mvebu_sei {
	struct device *dev;
	void *base;
	struct resource *res;
	struct irq_domain *sei_domain;
	struct irq_domain *ap_domain;
	struct irq_domain *cp_domain;
	const struct mvebu_sei_caps *caps;
	struct mutex cp_msi_lock;
	unsigned long cp_msi_bitmap[1];
	raw_spinlock_t mask_lock;
};

struct meson_gpio_irq_controller;

struct irq_ctl_ops {
	void (*gpio_irq_sel_pin)(struct meson_gpio_irq_controller *, unsigned int, unsigned long);
	void (*gpio_irq_init)(struct meson_gpio_irq_controller *);
	int (*gpio_irq_set_type)(struct meson_gpio_irq_controller *, unsigned int, u32 *);
};

struct meson_gpio_irq_params {
	unsigned int nr_hwirq;
	unsigned int nr_channels;
	bool support_edge_both;
	unsigned int edge_both_offset;
	unsigned int edge_single_offset;
	unsigned int pol_low_offset;
	unsigned int pin_sel_mask;
	struct irq_ctl_ops ops;
};

struct meson_gpio_irq_controller {
	const struct meson_gpio_irq_params *params;
	void *base;
	u32 channel_irqs[64];
	unsigned long channel_map[1];
	spinlock_t lock;
};

struct dpmcp_cmd_open {
	__le32 dpmcp_id;
};

struct mvebu_a3700_utmi_caps {
	int usb32;
	const struct phy_ops *ops;
};

struct mvebu_a3700_utmi {
	void *regs;
	struct regmap *usb_misc;
	const struct mvebu_a3700_utmi_caps *caps;
	struct phy *phy;
};

struct tegra210_xusb_fuse_calibration {
	u32 hs_curr_level[4];
	u32 hs_term_range_adj;
	u32 rpd_ctrl;
};

struct tegra210_xusb_padctl_context {
	u32 usb2_pad_mux;
	u32 usb2_port_cap;
	u32 ss_port_map;
	u32 usb3_pad_mux;
};

struct tegra210_xusb_padctl {
	struct tegra_xusb_padctl base;
	struct regmap *regmap;
	struct tegra210_xusb_fuse_calibration fuse;
	struct tegra210_xusb_padctl_context context;
};

struct fsl_gpio_soc_data {
	bool have_paddr;
	bool have_dual_base;
};

struct vf610_gpio_port {
	struct gpio_chip gc;
	void *base;
	void *gpio_base;
	const struct fsl_gpio_soc_data *sdata;
	u8 irqc[32];
	struct clk *clk_port;
	struct clk *clk_gpio;
	int irq;
};

struct pci_bridge_reg_behavior {
	u32 ro;
	u32 rw;
	u32 w1c;
};

enum {
	PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD = 1,
	PCI_BRIDGE_EMUL_NO_IO_FORWARD = 2,
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	bool is_firmware_default;
	unsigned int (*set_decode)(struct pci_dev *, bool);
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[16];
	spinlock_t lock;
};

enum iproc_msi_reg {
	IPROC_MSI_EQ_PAGE = 0,
	IPROC_MSI_EQ_PAGE_UPPER = 1,
	IPROC_MSI_PAGE = 2,
	IPROC_MSI_PAGE_UPPER = 3,
	IPROC_MSI_CTRL = 4,
	IPROC_MSI_EQ_HEAD = 5,
	IPROC_MSI_EQ_TAIL = 6,
	IPROC_MSI_INTS_EN = 7,
	IPROC_MSI_REG_SIZE = 8,
};

struct iproc_msi_grp;

struct iproc_msi {
	struct iproc_pcie *pcie;
	const u16 (*reg_offsets)[8];
	struct iproc_msi_grp *grps;
	int nr_irqs;
	int nr_cpus;
	bool has_inten_reg;
	unsigned long *bitmap;
	struct mutex bitmap_lock;
	unsigned int nr_msi_vecs;
	struct irq_domain *inner_domain;
	struct irq_domain *msi_domain;
	unsigned int nr_eq_region;
	unsigned int nr_msi_region;
	void *eq_cpu;
	dma_addr_t eq_dma;
	phys_addr_t msi_addr;
};

struct iproc_msi_grp {
	struct iproc_msi *msi;
	int gic_irq;
	unsigned int eq;
};

struct acpi_osi_config {
	u8 default_disabling;
	unsigned int linux_enable: 1;
	unsigned int linux_dmi: 1;
	unsigned int linux_cmdline: 1;
	unsigned int darwin_enable: 1;
	unsigned int darwin_dmi: 1;
	unsigned int darwin_cmdline: 1;
};

struct acpi_osi_entry {
	char string[64];
	bool enable;
};

struct acpi_dev_match_info {
	struct acpi_device_id hid[2];
	const char *uid;
	s64 hrv;
};

struct acpi_ac {
	struct power_supply *charger;
	struct power_supply_desc charger_desc;
	struct acpi_device *device;
	unsigned long long state;
	struct notifier_block battery_nb;
};

struct pnp_info_buffer {
	char *buffer;
	char *curr;
	unsigned long size;
	unsigned long len;
	int stop;
	int error;
};

typedef struct pnp_info_buffer pnp_info_buffer_t;

struct applnco_tables;

struct applnco_channel {
	void *base;
	struct applnco_tables *tbl;
	struct clk_hw hw;
	spinlock_t lock;
};

struct applnco_tables {
	u16 fwd[2048];
	u16 inv[2048];
};

struct clk_dvp {
	struct clk_hw_onecell_data *data;
	struct reset_simple_data reset;
};

struct mtk_clk_gate {
	struct clk_hw hw;
	struct regmap *regmap;
	int set_ofs;
	int clr_ofs;
	int sta_ofs;
	u8 bit;
};

struct vid_pll_div {
	unsigned int shift_val;
	unsigned int shift_sel;
	unsigned int divider;
	unsigned int multiplier;
};

struct meson_vid_pll_div_data {
	struct parm val;
	struct parm sel;
};

enum freq_policy {
	FLOOR = 0,
	CEIL = 1,
};

struct clk_rcg2_gfx3d {
	u8 div;
	struct clk_rcg2 rcg;
	struct clk_hw **hws;
};

enum clk_ids___10 {
	LAST_DT_CORE_CLK___10 = 37,
	CLK_EXTAL___10 = 38,
	CLK_EXTALR___10 = 39,
	CLK_MAIN___10 = 40,
	CLK_PLL1___10 = 41,
	CLK_PLL2___6 = 42,
	CLK_PLL3___9 = 43,
	CLK_PLL1_DIV2___10 = 44,
	CLK_PLL1_DIV4___7 = 45,
	CLK_S0___8 = 46,
	CLK_S1___7 = 47,
	CLK_S2___6 = 48,
	CLK_S3___7 = 49,
	CLK_SDSRC___9 = 50,
	CLK_RPCSRC___9 = 51,
	CLK_OCO___4 = 52,
	MOD_CLK_BASE___10 = 53,
};

struct samsung_clk_pll {
	struct clk_hw hw;
	void *lock_reg;
	void *con_reg;
	unsigned short enable_offs;
	unsigned short lock_offs;
	enum samsung_pll_type type;
	unsigned int rate_count;
	const struct samsung_pll_rate_table *rate_table;
};

struct socfpga_gate_clk {
	struct clk_gate hw;
	char *parent_name;
	u32 fixed_div;
	void *div_reg;
	void *bypass_reg;
	struct regmap *sys_mgr_base_addr;
	u32 width;
	u32 shift;
	u32 bypass_shift;
};

struct visconti_clk_gate {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 ckon_offset;
	u32 ckoff_offset;
	u8 ck_idx;
	u8 flags;
	u32 rson_offset;
	u32 rsoff_offset;
	u8 rs_idx;
	spinlock_t *lock;
};

struct rcar_dmac_of_data {
	u32 chan_offset_base;
	u32 chan_offset_stride;
};

struct rcar_dmac_chan_slave {
	phys_addr_t slave_addr;
	unsigned int xfer_size;
};

struct rcar_dmac_chan_map {
	dma_addr_t addr;
	enum dma_data_direction dir;
	struct rcar_dmac_chan_slave slave;
};

struct rcar_dmac_desc;

struct rcar_dmac_chan {
	struct dma_chan chan;
	void *iomem;
	unsigned int index;
	int irq;
	struct rcar_dmac_chan_slave src;
	struct rcar_dmac_chan_slave dst;
	struct rcar_dmac_chan_map map;
	int mid_rid;
	spinlock_t lock;
	struct {
		struct list_head free;
		struct list_head pending;
		struct list_head active;
		struct list_head done;
		struct list_head wait;
		struct rcar_dmac_desc *running;
		struct list_head chunks_free;
		struct list_head pages;
	} desc;
};

struct rcar_dmac_xfer_chunk;

struct rcar_dmac_hw_desc;

struct rcar_dmac_desc {
	struct dma_async_tx_descriptor async_tx;
	enum dma_transfer_direction direction;
	unsigned int xfer_shift;
	u32 chcr;
	struct list_head node;
	struct list_head chunks;
	struct rcar_dmac_xfer_chunk *running;
	unsigned int nchunks;
	struct {
		bool use;
		struct rcar_dmac_hw_desc *mem;
		dma_addr_t dma;
		size_t size;
	} hwdescs;
	unsigned int size;
	bool cyclic;
};

struct rcar_dmac_xfer_chunk {
	struct list_head node;
	dma_addr_t src_addr;
	dma_addr_t dst_addr;
	u32 size;
};

struct rcar_dmac_hw_desc {
	u32 sar;
	u32 dar;
	u32 tcr;
	u32 reserved;
};

struct rcar_dmac {
	struct dma_device engine;
	struct device *dev;
	void *dmac_base;
	void *chan_base;
	unsigned int n_channels;
	struct rcar_dmac_chan *channels;
	u32 channels_mask;
	unsigned long modules[4];
};

struct rcar_dmac_desc_page {
	struct list_head node;
	union {
		struct {
			struct {} __empty_descs;
			struct rcar_dmac_desc descs[0];
		};
		struct {
			struct {} __empty_chunks;
			struct rcar_dmac_xfer_chunk chunks[0];
		};
	};
};

struct qm_addr {
	void *ce;
	__be32 *ce_be;
	void *ci;
};

struct qm_eqcr_entry;

struct qm_eqcr {
	struct qm_eqcr_entry *ring;
	struct qm_eqcr_entry *cursor;
	u8 ci;
	u8 available;
	u8 ithresh;
	u8 vbit;
};

struct qm_dqrr {
	const struct qm_dqrr_entry *ring;
	const struct qm_dqrr_entry *cursor;
	u8 pi;
	u8 ci;
	u8 fill;
	u8 ithresh;
	u8 vbit;
};

struct qm_mr {
	union qm_mr_entry *ring;
	union qm_mr_entry *cursor;
	u8 pi;
	u8 ci;
	u8 fill;
	u8 ithresh;
	u8 vbit;
};

union qm_mc_command;

union qm_mc_result;

struct qm_mc {
	union qm_mc_command *cr;
	union qm_mc_result *rr;
	u8 rridx;
	u8 vbit;
};

struct qm_portal {
	struct qm_addr addr;
	struct qm_eqcr eqcr;
	struct qm_dqrr dqrr;
	struct qm_mr mr;
	struct qm_mc mc;
	long: 64;
};

struct qman_portal {
	struct qm_portal p;
	unsigned long bits;
	unsigned long irq_sources;
	u32 use_eqcr_ci_stashing;
	struct qman_fq *vdqcr_owned;
	u32 sdqcr;
	const struct qm_portal_config *config;
	struct qman_cgrs *cgrs;
	struct list_head cgr_cbs;
	spinlock_t cgr_lock;
	struct work_struct congestion_work;
	struct work_struct mr_work;
	char irqname[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct qm_eqcr_entry {
	u8 _ncw_verb;
	u8 dca;
	__be16 seqnum;
	u8 __reserved[4];
	__be32 fqid;
	__be32 tag;
	struct qm_fd fd;
	u8 __reserved3[32];
};

struct qm_mcc_fq {
	u8 _ncw_verb;
	u8 __reserved1[3];
	__be32 fqid;
	u8 __reserved2[56];
};

struct qm_mcc_cgr {
	u8 _ncw_verb;
	u8 __reserved1[30];
	u8 cgid;
	u8 __reserved2[32];
};

union qm_mc_command {
	struct {
		u8 _ncw_verb;
		u8 __reserved[63];
	};
	struct qm_mcc_initfq initfq;
	struct qm_mcc_initcgr initcgr;
	struct qm_mcc_fq fq;
	struct qm_mcc_cgr cgr;
};

struct qm_mcr_queryfq {
	u8 verb;
	u8 result;
	u8 __reserved1[8];
	struct qm_fqd fqd;
	u8 __reserved2[30];
};

struct qm_mcr_alterfq {
	u8 verb;
	u8 result;
	u8 fqs;
	u8 __reserved1[61];
};

struct qm_mcr_querycgr {
	u8 verb;
	u8 result;
	u16 __reserved1;
	struct __qm_mc_cgr cgr;
	u8 __reserved2[6];
	u8 i_bcnt_hi;
	__be32 i_bcnt_lo;
	u8 __reserved3[3];
	u8 a_bcnt_hi;
	__be32 a_bcnt_lo;
	__be32 cscn_targ_swp[4];
};

struct qm_mcr_querycongestion {
	u8 verb;
	u8 result;
	u8 __reserved[30];
	struct __qm_mcr_querycongestion state;
};

struct qm_mcr_querywq {
	u8 verb;
	u8 result;
	u16 channel_wq;
	u8 __reserved[28];
	u32 wq_len[8];
};

struct qm_mcr_queryfq_np {
	u8 verb;
	u8 result;
	u8 __reserved1;
	u8 state;
	u32 fqd_link;
	u16 odp_seq;
	u16 orp_nesn;
	u16 orp_ea_hseq;
	u16 orp_ea_tseq;
	u32 orp_ea_hptr;
	u32 orp_ea_tptr;
	u32 pfdr_hptr;
	u32 pfdr_tptr;
	u8 __reserved2[5];
	u8 is;
	u16 ics_surp;
	u32 byte_cnt;
	u32 frm_cnt;
	u32 __reserved3;
	u16 ra1_sfdr;
	u16 ra2_sfdr;
	u16 __reserved4;
	u16 od1_sfdr;
	u16 od2_sfdr;
	u16 od3_sfdr;
};

union qm_mc_result {
	struct {
		u8 verb;
		u8 result;
		u8 __reserved1[62];
	};
	struct qm_mcr_queryfq queryfq;
	struct qm_mcr_alterfq alterfq;
	struct qm_mcr_querycgr querycgr;
	struct qm_mcr_querycongestion querycongestion;
	struct qm_mcr_querywq querywq;
	struct qm_mcr_queryfq_np queryfq_np;
};

enum qm_eqcr_pmode {
	qm_eqcr_pci = 0,
	qm_eqcr_pce = 1,
	qm_eqcr_pvb = 2,
};

enum qm_dqrr_dmode {
	qm_dqrr_dpush = 0,
	qm_dqrr_dpull = 1,
};

enum qm_dqrr_pmode {
	qm_dqrr_pci = 0,
	qm_dqrr_pce = 1,
	qm_dqrr_pvb = 2,
};

enum qm_dqrr_cmode {
	qm_dqrr_cci = 0,
	qm_dqrr_cce = 1,
	qm_dqrr_cdc = 2,
};

enum qm_mr_pmode {
	qm_mr_pci = 0,
	qm_mr_pce = 1,
	qm_mr_pvb = 2,
};

enum qm_mr_cmode {
	qm_mr_cci = 0,
	qm_mr_cce = 1,
};

struct update_cgr_params {
	struct qman_cgr *cgr;
	struct qm_mcc_initcgr *opts;
	int ret;
};

struct exynos_usi_mode {
	const char *name;
	unsigned int val;
};

enum exynos_usi_ver {
	USI_VER2 = 2,
};

struct exynos_usi_variant {
	enum exynos_usi_ver ver;
	unsigned int sw_conf_mask;
	size_t min_mode;
	size_t max_mode;
	size_t num_clks;
	const char * const *clk_names;
};

struct exynos_usi {
	struct device *dev;
	void *regs;
	struct clk_bulk_data *clks;
	size_t mode;
	bool clkreq_on;
	struct regmap *sysreg;
	unsigned int sw_conf;
	const struct exynos_usi_variant *data;
};

struct meson_ee_pwrc_domain_desc;

struct meson_ee_pwrc_domain_data {
	unsigned int count;
	struct meson_ee_pwrc_domain_desc *domains;
};

struct meson_ee_pwrc_top_domain;

struct meson_ee_pwrc_mem_domain;

struct meson_ee_pwrc_domain;

struct meson_ee_pwrc_domain_desc {
	char *name;
	unsigned int reset_names_count;
	unsigned int clk_names_count;
	struct meson_ee_pwrc_top_domain *top_pd;
	unsigned int mem_pd_count;
	struct meson_ee_pwrc_mem_domain *mem_pd;
	bool (*is_powered_off)(struct meson_ee_pwrc_domain *);
};

struct meson_ee_pwrc_top_domain {
	unsigned int sleep_reg;
	unsigned int sleep_mask;
	unsigned int iso_reg;
	unsigned int iso_mask;
};

struct meson_ee_pwrc_mem_domain {
	unsigned int reg;
	unsigned int mask;
};

struct meson_ee_pwrc;

struct meson_ee_pwrc_domain {
	struct generic_pm_domain base;
	bool enabled;
	struct meson_ee_pwrc *pwrc;
	struct meson_ee_pwrc_domain_desc desc;
	struct clk_bulk_data *clks;
	int num_clks;
	struct reset_control *rstc;
	int num_rstc;
};

struct meson_ee_pwrc {
	struct regmap *regmap_ao;
	struct regmap *regmap_hhi;
	struct meson_ee_pwrc_domain *domains;
	struct genpd_onecell_data xlate;
};

struct cpr_desc;

struct acc_desc;

struct cpr_acc_desc {
	const struct cpr_desc *cpr_desc;
	const struct acc_desc *acc_desc;
};

struct fuse_corner_data;

struct cpr_fuses {
	int init_voltage_step;
	int init_voltage_width;
	struct fuse_corner_data *fuse_corner_data;
};

struct cpr_desc {
	unsigned int num_fuse_corners;
	int min_diff_quot;
	int *step_quot;
	unsigned int timer_delay_us;
	unsigned int timer_cons_up;
	unsigned int timer_cons_down;
	unsigned int up_threshold;
	unsigned int down_threshold;
	unsigned int idle_clocks;
	unsigned int gcnt_us;
	unsigned int vdd_apc_step_up_limit;
	unsigned int vdd_apc_step_down_limit;
	unsigned int clamp_timer_interval;
	struct cpr_fuses cpr_fuses;
	bool reduce_to_fuse_uV;
	bool reduce_to_corner_uV;
};

struct fuse_corner_data {
	int ref_uV;
	int max_uV;
	int min_uV;
	int max_volt_scale;
	int max_quot_scale;
	int quot_offset;
	int quot_scale;
	int quot_adjust;
	int quot_offset_scale;
	int quot_offset_adjust;
};

struct acc_desc {
	unsigned int enable_reg;
	u32 enable_mask;
	struct reg_sequence *config;
	struct reg_sequence *settings;
	int num_regs_per_fuse;
};

enum voltage_change_dir {
	NO_CHANGE = 0,
	DOWN___3 = 1,
	UP___3 = 2,
};

struct corner;

struct fuse_corner;

struct cpr_fuse;

struct cpr_drv {
	unsigned int num_corners;
	unsigned int ref_clk_khz;
	struct generic_pm_domain pd;
	struct device *dev;
	struct device *attached_cpu_dev;
	struct mutex lock;
	void *base;
	struct corner *corner;
	struct regulator *vdd_apc;
	struct clk *cpu_clk;
	struct regmap *tcsr;
	bool loop_disabled;
	u32 gcnt;
	unsigned long flags;
	struct fuse_corner *fuse_corners;
	struct corner *corners;
	const struct cpr_desc *desc;
	const struct acc_desc *acc_desc;
	const struct cpr_fuse *cpr_fuses;
	struct dentry *debugfs;
};

struct corner {
	int min_uV;
	int max_uV;
	int uV;
	int last_uV;
	int quot_adjust;
	u32 save_ctl;
	u32 save_irq;
	unsigned long freq;
	struct fuse_corner *fuse_corner;
};

struct fuse_corner {
	int min_uV;
	int max_uV;
	int uV;
	int quot;
	int step_quot;
	const struct reg_sequence *accs;
	int num_accs;
	unsigned long max_freq;
	u8 ring_osc_idx;
};

struct cpr_fuse {
	char *ring_osc;
	char *init_voltage;
	char *quotient;
	char *quotient_offset;
};

struct corner_data {
	unsigned int fuse_corner;
	unsigned long freq;
};

struct rk8xx_register_bit {
	u8 reg;
	u8 bit;
};

enum rk809_reg_id {
	RK809_ID_DCDC5 = 13,
	RK809_ID_SW1 = 14,
	RK809_ID_SW2 = 15,
	RK809_NUM_REGULATORS = 16,
};

enum rk817_reg_id {
	RK817_ID_DCDC1 = 0,
	RK817_ID_DCDC2 = 1,
	RK817_ID_DCDC3 = 2,
	RK817_ID_DCDC4 = 3,
	RK817_ID_LDO1 = 4,
	RK817_ID_LDO2 = 5,
	RK817_ID_LDO3 = 6,
	RK817_ID_LDO4 = 7,
	RK817_ID_LDO5 = 8,
	RK817_ID_LDO6 = 9,
	RK817_ID_LDO7 = 10,
	RK817_ID_LDO8 = 11,
	RK817_ID_LDO9 = 12,
	RK817_ID_BOOST = 13,
	RK817_ID_BOOST_OTG_SW = 14,
	RK817_NUM_REGULATORS = 15,
};

struct rk808_regulator_data {
	struct gpio_desc *dvs_gpio[2];
};

struct zynqmp_reset_soc_data {
	u32 reset_id;
	u32 num_resets;
};

struct zynqmp_reset_data {
	struct reset_controller_dev rcdev;
	const struct zynqmp_reset_soc_data *data;
};

struct tty_audit_buf {
	struct mutex mutex;
	dev_t dev;
	bool icanon;
	size_t valid;
	u8 *data;
};

struct exynos_trng_dev {
	struct device *dev;
	void *mem;
	struct clk *clk;
	struct hwrng rng;
};

struct cn10k_rng {
	void *reg_base;
	struct hwrng ops;
	struct pci_dev *pdev;
	bool extended_trng_regs;
};

struct arm_lpae_io_pgtable {
	struct io_pgtable iop;
	int pgd_bits;
	int start_level;
	int bits_per_level;
	void *pgd;
};

typedef u64 arm_lpae_iopte;

typedef void (*btf_trace_ata_qc_prep)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_issue)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_internal)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_failed)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_done)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_tf_load)(void *, struct ata_port *, const struct ata_taskfile *);

typedef void (*btf_trace_ata_exec_command)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_setup)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_start)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_stop)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_status)(void *, struct ata_port *, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy)(void *, struct ata_device *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy_qc)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_eh_about_to_do)(void *, struct ata_link *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_done)(void *, struct ata_link *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_link_hardreset_begin)(void *, struct ata_link *, unsigned int *, unsigned long);

typedef void (*btf_trace_ata_slave_hardreset_begin)(void *, struct ata_link *, unsigned int *, unsigned long);

typedef void (*btf_trace_ata_link_softreset_begin)(void *, struct ata_link *, unsigned int *, unsigned long);

typedef void (*btf_trace_ata_link_hardreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_slave_hardreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_link_softreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_link_postreset)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_slave_postreset)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_std_sched_eh)(void *, struct ata_port *);

typedef void (*btf_trace_ata_port_freeze)(void *, struct ata_port *);

typedef void (*btf_trace_ata_port_thaw)(void *, struct ata_port *);

typedef void (*btf_trace_ata_sff_hsm_state)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_sff_hsm_command_complete)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_sff_port_intr)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_sff_pio_transfer_data)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_atapi_pio_transfer_data)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_atapi_send_cdb)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_sff_flush_pio_task)(void *, struct ata_port *);

struct ata_force_param {
	const char *name;
	u8 cbl;
	u8 spd_limit;
	unsigned int xfer_mask;
	unsigned int horkage_on;
	unsigned int horkage_off;
	u16 lflags_on;
	u16 lflags_off;
};

struct ata_force_ent {
	int port;
	int device;
	struct ata_force_param param;
};

struct ata_xfer_ent {
	int shift;
	int bits;
	u8 base;
};

struct ata_blacklist_entry {
	const char *model_num;
	const char *model_rev;
	unsigned long horkage;
};

enum ata_xfer_mask {
	ATA_MASK_PIO = 127,
	ATA_MASK_MWDMA = 3968,
	ATA_MASK_UDMA = 1044480,
};

struct trace_event_raw_ata_qc_issue_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned char proto;
	unsigned long flags;
	char __data[0];
};

struct trace_event_raw_ata_qc_complete_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char status;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char error;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned long flags;
	char __data[0];
};

struct trace_event_raw_ata_tf_load {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char proto;
	char __data[0];
};

struct trace_event_raw_ata_exec_command_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int tag;
	unsigned char cmd;
	unsigned char feature;
	unsigned char hob_nsect;
	unsigned char proto;
	char __data[0];
};

struct trace_event_raw_ata_bmdma_status {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int tag;
	unsigned char host_stat;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy_qc {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_action_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	char __data[0];
};

struct trace_event_raw_ata_link_reset_begin_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int class[2];
	unsigned long deadline;
	char __data[0];
};

struct trace_event_raw_ata_link_reset_end_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int class[2];
	int rc;
	char __data[0];
};

struct trace_event_raw_ata_port_eh_begin_template {
	struct trace_entry ent;
	unsigned int ata_port;
	char __data[0];
};

struct trace_event_raw_ata_sff_hsm_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int protocol;
	unsigned int hsm_state;
	unsigned char dev_state;
	char __data[0];
};

struct trace_event_raw_ata_transfer_data_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int flags;
	unsigned int offset;
	unsigned int bytes;
	char __data[0];
};

struct trace_event_raw_ata_sff_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned char hsm_state;
	char __data[0];
};

struct trace_event_data_offsets_ata_qc_issue_template {};

struct trace_event_data_offsets_ata_qc_complete_template {};

struct trace_event_data_offsets_ata_tf_load {};

struct trace_event_data_offsets_ata_exec_command_template {};

struct trace_event_data_offsets_ata_bmdma_status {};

struct trace_event_data_offsets_ata_eh_link_autopsy {};

struct trace_event_data_offsets_ata_eh_link_autopsy_qc {};

struct trace_event_data_offsets_ata_eh_action_template {};

struct trace_event_data_offsets_ata_link_reset_begin_template {};

struct trace_event_data_offsets_ata_link_reset_end_template {};

struct trace_event_data_offsets_ata_port_eh_begin_template {};

struct trace_event_data_offsets_ata_sff_hsm_template {};

struct trace_event_data_offsets_ata_transfer_data_template {};

struct trace_event_data_offsets_ata_sff_template {};

struct pci_bits {
	unsigned int reg;
	unsigned int width;
	unsigned long mask;
	unsigned long val;
};

struct denali_dt_data {
	unsigned int revision;
	unsigned int caps;
	unsigned int oob_skip_bytes;
	const struct nand_ecc_caps *ecc_caps;
};

struct denali_dt {
	struct denali_controller controller;
	struct clk *clk;
	struct clk *clk_x;
	struct clk *clk_ecc;
	struct reset_control *rst;
	struct reset_control *rst_reg;
};

enum xgene_mdio_id {
	XGENE_MDIO_RGMII = 1,
	XGENE_MDIO_XFI = 2,
};

enum {
	MIIM_CMD_IDLE = 0,
	MIIM_CMD_LEGACY_WRITE = 1,
	MIIM_CMD_LEGACY_READ = 2,
};

enum bcmasp_stat_type {
	BCMASP_STAT_RX_EDPKT = 0,
	BCMASP_STAT_RX_CTRL = 1,
	BCMASP_STAT_RX_CTRL_PER_INTF = 2,
	BCMASP_STAT_SOFT = 3,
};

struct bcmasp_stats {
	char stat_string[32];
	enum bcmasp_stat_type type;
	u32 reg_offset;
};

enum forward_type {
	FILTER_ACTION_TYPE_PSFP = 1,
	FILTER_ACTION_TYPE_ACL = 2,
	FILTER_ACTION_TYPE_BOTH = 3,
};

struct actions_fwd {
	u64 actions;
	u64 keys;
	enum forward_type output;
};

struct enetc_psfp {
	unsigned long dev_bitmap;
	unsigned long *psfp_sfi_bitmap;
	struct hlist_head stream_list;
	struct hlist_head psfp_filter_list;
	struct hlist_head psfp_gate_list;
	struct hlist_head psfp_meter_list;
	spinlock_t psfp_lock;
};

enum bdcr_cmd_class {
	BDCR_CMD_UNSPEC = 0,
	BDCR_CMD_MAC_FILTER = 1,
	BDCR_CMD_VLAN_FILTER = 2,
	BDCR_CMD_RSS = 3,
	BDCR_CMD_RFS = 4,
	BDCR_CMD_PORT_GCL = 5,
	BDCR_CMD_RECV_CLASSIFIER = 6,
	BDCR_CMD_STREAM_IDENTIFY = 7,
	BDCR_CMD_STREAM_FILTER = 8,
	BDCR_CMD_STREAM_GCL = 9,
	BDCR_CMD_FLOW_METER = 10,
	__BDCR_CMD_MAX_LEN = 11,
	BDCR_CMD_MAX_LEN = 10,
};

enum streamid_type {
	STREAMID_TYPE_RESERVED = 0,
	STREAMID_TYPE_NULL = 1,
	STREAMID_TYPE_SMAC = 2,
};

enum streamid_vlan_tagged {
	STREAMID_VLAN_RESERVED = 0,
	STREAMID_VLAN_TAGGED = 1,
	STREAMID_VLAN_UNTAGGED = 2,
	STREAMID_VLAN_ALL = 3,
};

struct gce {
	__le32 period;
	u8 gate;
	u8 res[3];
};

struct enetc_psfp_filter {
	u32 index;
	s32 handle;
	s8 prio;
	u32 maxsdu;
	u32 gate_id;
	s32 meter_id;
	refcount_t refcount;
	struct hlist_node node;
};

struct enetc_psfp_meter {
	u32 index;
	u32 cir;
	u32 cbs;
	refcount_t refcount;
	struct hlist_node node;
};

struct enetc_psfp_gate {
	u32 index;
	s8 init_ipv;
	u64 basetime;
	u64 cycletime;
	u64 cycletimext;
	u32 num_entries;
	refcount_t refcount;
	struct hlist_node node;
	struct action_gate_entry entries[0];
};

struct enetc_streamid {
	u32 index;
	union {
		u8 src_mac[6];
		u8 dst_mac[6];
	};
	u8 filtertype;
	u16 vid;
	u8 tagged;
	s32 handle;
};

struct enetc_stream_filter {
	struct enetc_streamid sid;
	u32 sfi_index;
	u32 sgi_index;
	u32 flags;
	u32 fmi_index;
	struct flow_stats stats;
	struct hlist_node node;
};

struct tgs_gcl_data {
	__le32 btl;
	__le32 bth;
	__le32 ct;
	__le32 cte;
	struct gce entry[0];
};

struct psfp_streamfilter_counters {
	u64 matching_frames_count;
	u64 passing_frames_count;
	u64 not_passing_frames_count;
	u64 passing_sdu_count;
	u64 not_passing_sdu_count;
	u64 red_frames_count;
};

struct sfi_counter_data {
	u32 matchl;
	u32 matchh;
	u32 msdu_dropl;
	u32 msdu_droph;
	u32 stream_gate_dropl;
	u32 stream_gate_droph;
	u32 flow_meter_dropl;
	u32 flow_meter_droph;
};

struct sgce {
	u32 interval;
	u8 msdu[3];
	u8 multi;
};

struct sgcl_data {
	u32 btl;
	u32 bth;
	u32 ct;
	u32 cte;
	struct sgce sgcl[0];
};

struct streamid_data {
	union {
		u8 dmac[6];
		u8 smac[6];
	};
	u16 vid_vidm_tg;
};

struct k3_mdio_soc_data {
	bool manual_mode;
};

struct mdio_platform_data {
	unsigned long bus_freq;
};

struct davinci_mdio_of_param {
	int autosuspend_delay_ms;
	bool manual_mode;
};

struct davinci_mdio_regs;

struct davinci_mdio_data {
	struct mdio_platform_data pdata;
	struct mdiobb_ctrl bb_ctrl;
	struct davinci_mdio_regs *regs;
	struct clk *clk;
	struct device *dev;
	struct mii_bus *bus;
	bool active_in_suspend;
	unsigned long access_time;
	bool skip_scan;
	u32 clk_div;
	bool manual_mode;
};

struct davinci_mdio_regs {
	u32 version;
	u32 control;
	u32 alive;
	u32 link;
	u32 linkintraw;
	u32 linkintmasked;
	u32 __reserved_0[2];
	u32 userintraw;
	u32 userintmasked;
	u32 userintmaskset;
	u32 userintmaskclr;
	u32 manualif;
	u32 poll;
	u32 __reserved_1[18];
	struct {
		u32 access;
		u32 physel;
	} user[0];
};

struct vfio___3 {
	struct list_head iommu_drivers_list;
	struct mutex iommu_drivers_lock;
};

struct vfio_iommu_driver {
	const struct vfio_iommu_driver_ops *ops;
	struct list_head vfio_next;
};

struct vfio_container {
	struct kref kref;
	struct list_head group_list;
	struct rw_semaphore group_lock;
	struct vfio_iommu_driver *iommu_driver;
	void *iommu_data;
	bool noiommu;
};

struct usb_dynid {
	struct list_head node;
	struct usb_device_id id;
};

struct usb_phy_generic {
	struct usb_phy phy;
	struct device *dev;
	struct clk *clk;
	struct regulator *vcc;
	struct gpio_desc *gpiod_reset;
	struct gpio_desc *gpiod_vbus;
	struct regulator *vbus_draw;
	bool vbus_draw_enabled;
	unsigned long mA;
	unsigned int vbus;
};

typedef void (*btf_trace_mtu3_log)(void *, struct device *, struct va_format *);

typedef void (*btf_trace_mtu3_u3_ltssm_isr)(void *, u32);

typedef void (*btf_trace_mtu3_u2_common_isr)(void *, u32);

typedef void (*btf_trace_mtu3_qmu_isr)(void *, u32, u32);

typedef void (*btf_trace_mtu3_handle_setup)(void *, struct usb_ctrlrequest *);

typedef void (*btf_trace_mtu3_alloc_request)(void *, struct mtu3_request *);

typedef void (*btf_trace_mtu3_free_request)(void *, struct mtu3_request *);

typedef void (*btf_trace_mtu3_gadget_queue)(void *, struct mtu3_request *);

typedef void (*btf_trace_mtu3_gadget_dequeue)(void *, struct mtu3_request *);

typedef void (*btf_trace_mtu3_req_complete)(void *, struct mtu3_request *);

typedef void (*btf_trace_mtu3_prepare_gpd)(void *, struct mtu3_ep *, struct qmu_gpd *);

typedef void (*btf_trace_mtu3_complete_gpd)(void *, struct mtu3_ep *, struct qmu_gpd *);

typedef void (*btf_trace_mtu3_zlp_exp_gpd)(void *, struct mtu3_ep *, struct qmu_gpd *);

typedef void (*btf_trace_mtu3_gadget_ep_enable)(void *, struct mtu3_ep *);

typedef void (*btf_trace_mtu3_gadget_ep_disable)(void *, struct mtu3_ep *);

typedef void (*btf_trace_mtu3_gadget_ep_set_halt)(void *, struct mtu3_ep *);

struct trace_event_raw_mtu3_log {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_mtu3_u3_ltssm_isr {
	struct trace_entry ent;
	u32 intr;
	char __data[0];
};

struct trace_event_raw_mtu3_u2_common_isr {
	struct trace_entry ent;
	u32 intr;
	char __data[0];
};

struct trace_event_raw_mtu3_qmu_isr {
	struct trace_entry ent;
	u32 done_intr;
	u32 exp_intr;
	char __data[0];
};

struct trace_event_raw_mtu3_log_setup {
	struct trace_entry ent;
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	char __data[0];
};

struct trace_event_raw_mtu3_log_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct mtu3_request *mreq;
	struct qmu_gpd *gpd;
	unsigned int actual;
	unsigned int length;
	int status;
	int zero;
	int no_interrupt;
	char __data[0];
};

struct trace_event_raw_mtu3_log_gpd {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct qmu_gpd *gpd;
	u32 dw0;
	u32 dw1;
	u32 dw2;
	u32 dw3;
	char __data[0];
};

struct trace_event_raw_mtu3_log_ep {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int type;
	unsigned int slot;
	unsigned int maxp;
	unsigned int mult;
	unsigned int maxburst;
	unsigned int flags;
	unsigned int direction;
	struct mtu3_gpd_ring *gpd_ring;
	char __data[0];
};

struct trace_event_data_offsets_mtu3_log {
	u32 name;
	u32 msg;
};

struct trace_event_data_offsets_mtu3_log_request {
	u32 name;
};

struct trace_event_data_offsets_mtu3_log_gpd {
	u32 name;
};

struct trace_event_data_offsets_mtu3_log_ep {
	u32 name;
};

struct trace_event_data_offsets_mtu3_u3_ltssm_isr {};

struct trace_event_data_offsets_mtu3_u2_common_isr {};

struct trace_event_data_offsets_mtu3_qmu_isr {};

struct trace_event_data_offsets_mtu3_log_setup {};

typedef void (*btf_trace_usb_gadget_frame_number)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_wakeup)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_set_remote_wakeup)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_set_selfpowered)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_clear_selfpowered)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_connect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_draw)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_disconnect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_connect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_disconnect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_deactivate)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_activate)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_ep_set_maxpacket_limit)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_enable)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_disable)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_set_halt)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_clear_halt)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_set_wedge)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_fifo_status)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_fifo_flush)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_alloc_request)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_free_request)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_queue)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_dequeue)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_gadget_giveback_request)(void *, struct usb_ep *, struct usb_request *, int);

struct trace_event_raw_udc_log_gadget {
	struct trace_entry ent;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_device_state state;
	unsigned int mA;
	unsigned int sg_supported;
	unsigned int is_otg;
	unsigned int is_a_peripheral;
	unsigned int b_hnp_enable;
	unsigned int a_hnp_support;
	unsigned int hnp_polling_support;
	unsigned int host_request_flag;
	unsigned int quirk_ep_out_aligned_size;
	unsigned int quirk_altset_not_supp;
	unsigned int quirk_stall_not_supp;
	unsigned int quirk_zlp_not_supp;
	unsigned int is_selfpowered;
	unsigned int deactivated;
	unsigned int connected;
	int ret;
	char __data[0];
};

struct trace_event_raw_udc_log_ep {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int maxpacket;
	unsigned int maxpacket_limit;
	unsigned int max_streams;
	unsigned int mult;
	unsigned int maxburst;
	u8 address;
	bool claimed;
	bool enabled;
	int ret;
	char __data[0];
};

struct trace_event_raw_udc_log_req {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int length;
	unsigned int actual;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id;
	unsigned int no_interrupt;
	unsigned int zero;
	unsigned int short_not_ok;
	int status;
	int ret;
	struct usb_request *req;
	char __data[0];
};

struct trace_event_data_offsets_udc_log_ep {
	u32 name;
};

struct trace_event_data_offsets_udc_log_req {
	u32 name;
};

struct trace_event_data_offsets_udc_log_gadget {};

struct ps2pp_info {
	u8 model;
	u8 kind;
	u16 features;
};

struct max77686_rtc_driver_data {
	unsigned long delay;
	u8 mask;
	const unsigned int *map;
	bool alarm_enable_reg;
	int rtc_i2c_addr;
	bool rtc_irq_from_platform;
	int alarm_pending_status_reg;
	const struct regmap_irq_chip *rtc_irq_chip;
	const struct regmap_config *regmap_config;
};

enum max77686_irq {
	MAX77686_PMICIRQ_PWRONF = 0,
	MAX77686_PMICIRQ_PWRONR = 1,
	MAX77686_PMICIRQ_JIGONBF = 2,
	MAX77686_PMICIRQ_JIGONBR = 3,
	MAX77686_PMICIRQ_ACOKBF = 4,
	MAX77686_PMICIRQ_ACOKBR = 5,
	MAX77686_PMICIRQ_ONKEY1S = 6,
	MAX77686_PMICIRQ_MRSTB = 7,
	MAX77686_PMICIRQ_140C = 8,
	MAX77686_PMICIRQ_120C = 9,
	MAX77686_RTCIRQ_RTC60S = 0,
	MAX77686_RTCIRQ_RTCA1 = 1,
	MAX77686_RTCIRQ_RTCA2 = 2,
	MAX77686_RTCIRQ_SMPL = 3,
	MAX77686_RTCIRQ_RTC1S = 4,
	MAX77686_RTCIRQ_WTSR = 5,
};

enum max77686_rtc_reg_offset {
	REG_RTC_CONTROLM = 0,
	REG_RTC_CONTROL = 1,
	REG_RTC_UPDATE0 = 2,
	REG_WTSR_SMPL_CNTL = 3,
	REG_RTC_SEC = 4,
	REG_RTC_MIN = 5,
	REG_RTC_HOUR = 6,
	REG_RTC_WEEKDAY = 7,
	REG_RTC_MONTH = 8,
	REG_RTC_YEAR = 9,
	REG_RTC_MONTHDAY = 10,
	REG_ALARM1_SEC = 11,
	REG_ALARM1_MIN = 12,
	REG_ALARM1_HOUR = 13,
	REG_ALARM1_WEEKDAY = 14,
	REG_ALARM1_MONTH = 15,
	REG_ALARM1_YEAR = 16,
	REG_ALARM1_DATE = 17,
	REG_ALARM2_SEC = 18,
	REG_ALARM2_MIN = 19,
	REG_ALARM2_HOUR = 20,
	REG_ALARM2_WEEKDAY = 21,
	REG_ALARM2_MONTH = 22,
	REG_ALARM2_YEAR = 23,
	REG_ALARM2_DATE = 24,
	REG_RTC_AE1 = 25,
	REG_RTC_END = 26,
};

enum MAX77686_RTC_OP {
	MAX77686_RTC_WRITE = 0,
	MAX77686_RTC_READ = 1,
};

enum {
	RTC_SEC___2 = 0,
	RTC_MIN___2 = 1,
	RTC_HOUR___2 = 2,
	RTC_WEEKDAY___2 = 3,
	RTC_MONTH___2 = 4,
	RTC_YEAR = 5,
	RTC_MONTHDAY = 6,
	RTC_NR_TIME = 7,
};

struct max77686_rtc_info {
	struct device *dev;
	struct i2c_client *rtc;
	struct rtc_device *rtc_dev;
	struct mutex lock;
	struct regmap *regmap;
	struct regmap *rtc_regmap;
	const struct max77686_rtc_driver_data *drv_data;
	struct regmap_irq_chip_data *rtc_irq_data;
	int rtc_irq;
	int virq;
};

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, unsigned long);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

typedef void (*btf_trace_thermal_power_cpu_get_power_simple)(void *, int, u32);

typedef void (*btf_trace_thermal_power_cpu_limit)(void *, const struct cpumask *, unsigned int, unsigned long, u32);

typedef void (*btf_trace_thermal_power_devfreq_get_power)(void *, struct thermal_cooling_device *, struct devfreq_dev_status *, unsigned long, u32);

typedef void (*btf_trace_thermal_power_devfreq_limit)(void *, struct thermal_cooling_device *, unsigned long, unsigned long, u32);

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	unsigned long target;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_get_power_simple {
	struct trace_entry ent;
	int cpu;
	u32 power;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_limit {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	unsigned int freq;
	unsigned long cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_raw_thermal_power_devfreq_get_power {
	struct trace_entry ent;
	u32 __data_loc_type;
	unsigned long freq;
	u32 busy_time;
	u32 total_time;
	u32 power;
	char __data[0];
};

struct trace_event_raw_thermal_power_devfreq_limit {
	struct trace_entry ent;
	u32 __data_loc_type;
	unsigned int freq;
	unsigned long cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
};

struct trace_event_data_offsets_cdev_update {
	u32 type;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
};

struct trace_event_data_offsets_thermal_power_cpu_limit {
	u32 cpumask;
};

struct trace_event_data_offsets_thermal_power_devfreq_get_power {
	u32 type;
};

struct trace_event_data_offsets_thermal_power_devfreq_limit {
	u32 type;
};

struct trace_event_data_offsets_thermal_power_cpu_get_power_simple {};

struct uniphier_wdt_dev {
	struct watchdog_device wdt_dev;
	struct regmap *regmap;
};

struct mmc_pwrseq_emmc {
	struct mmc_pwrseq pwrseq;
	struct notifier_block reset_nb;
	struct gpio_desc *reset_gpio;
};

struct sdhci_acpi_slot;

struct sdhci_acpi_uid_slot {
	const char *hid;
	const char *uid;
	const struct sdhci_acpi_slot *slot;
};

struct sdhci_acpi_chip;

struct sdhci_acpi_slot {
	const struct sdhci_acpi_chip *chip;
	unsigned int quirks;
	unsigned int quirks2;
	unsigned long caps;
	unsigned int caps2;
	mmc_pm_flag_t pm_caps;
	unsigned int flags;
	size_t priv_size;
	int (*probe_slot)(struct platform_device *, struct acpi_device *);
	int (*remove_slot)(struct platform_device *);
	int (*free_slot)(struct platform_device *);
	int (*setup_host)(struct platform_device *);
};

struct sdhci_acpi_chip {
	const struct sdhci_ops *ops;
	unsigned int quirks;
	unsigned int quirks2;
	unsigned long caps;
	unsigned int caps2;
	mmc_pm_flag_t pm_caps;
};

enum {
	SDHCI_ACPI_SD_CD = 1,
	SDHCI_ACPI_RUNTIME_PM = 2,
	SDHCI_ACPI_SD_CD_OVERRIDE_LEVEL = 4,
};

enum {
	DMI_QUIRK_RESET_SD_SIGNAL_VOLT_ON_SUSP = 1,
	DMI_QUIRK_SD_NO_WRITE_PROTECT = 2,
};

enum {
	INTEL_DSM_FNS = 0,
	INTEL_DSM_V18_SWITCH = 3,
	INTEL_DSM_V33_SWITCH = 4,
	INTEL_DSM_HS_CAPS = 8,
};

struct sdhci_acpi_host {
	struct sdhci_host *host;
	const struct sdhci_acpi_slot *slot;
	struct platform_device *pdev;
	bool use_runtime_pm;
	bool is_intel;
	bool reset_signal_volt_on_suspend;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned long private[0];
};

struct intel_host {
	u32 dsm_fns;
	u32 hs_caps;
};

struct amd_sdhci_host {
	bool tuned_clock;
	bool dll_enabled;
};

struct sdhci_tegra_soc_data {
	const struct sdhci_pltfm_data *pdata;
	u64 dma_mask;
	u32 nvquirks;
	u8 min_tap_delay;
	u8 max_tap_delay;
};

struct sdhci_tegra_autocal_offsets {
	u32 pull_up_3v3;
	u32 pull_down_3v3;
	u32 pull_up_3v3_timeout;
	u32 pull_down_3v3_timeout;
	u32 pull_up_1v8;
	u32 pull_down_1v8;
	u32 pull_up_1v8_timeout;
	u32 pull_down_1v8_timeout;
	u32 pull_up_sdr104;
	u32 pull_down_sdr104;
	u32 pull_up_hs400;
	u32 pull_down_hs400;
};

struct sdhci_tegra {
	const struct sdhci_tegra_soc_data *soc_data;
	struct gpio_desc *power_gpio;
	struct clk *tmclk;
	bool ddr_signaling;
	bool pad_calib_required;
	bool pad_control_available;
	struct reset_control *rst;
	struct pinctrl *pinctrl_sdmmc;
	struct pinctrl_state *pinctrl_state_3v3;
	struct pinctrl_state *pinctrl_state_1v8;
	struct pinctrl_state *pinctrl_state_3v3_drv;
	struct pinctrl_state *pinctrl_state_1v8_drv;
	struct sdhci_tegra_autocal_offsets autocal_offsets;
	ktime_t last_calib;
	u32 default_tap;
	u32 default_trim;
	u32 dqs_trim;
	bool enable_hwcq;
	unsigned long curr_clk_rate;
	u8 tuned_tap_delay;
	u32 stream_id;
};

enum lg_g15_model {
	LG_G15 = 0,
	LG_G15_V2 = 1,
	LG_G510 = 2,
	LG_G510_USB_AUDIO = 3,
	LG_Z10 = 4,
};

enum lg_g15_led_type {
	LG_G15_KBD_BRIGHTNESS = 0,
	LG_G15_LCD_BRIGHTNESS = 1,
	LG_G15_BRIGHTNESS_MAX = 2,
	LG_G15_MACRO_PRESET1 = 2,
	LG_G15_MACRO_PRESET2 = 3,
	LG_G15_MACRO_PRESET3 = 4,
	LG_G15_MACRO_RECORD = 5,
	LG_G15_LED_MAX = 6,
};

struct lg_g15_led {
	struct led_classdev cdev;
	enum led_brightness brightness;
	enum lg_g15_led_type led;
	u8 red;
	u8 green;
	u8 blue;
};

struct lg_g15_data {
	u8 transfer_buf[20];
	struct mutex mutex;
	struct work_struct work;
	struct input_dev *input;
	struct hid_device *hdev;
	enum lg_g15_model model;
	struct lg_g15_led leds[6];
	bool game_mode_enabled;
};

enum imx_rproc_method {
	IMX_RPROC_NONE = 0,
	IMX_RPROC_MMIO = 1,
	IMX_RPROC_SMC = 2,
	IMX_RPROC_SCU_API = 3,
};

struct imx_rproc_att;

struct imx_rproc_dcfg {
	u32 src_reg;
	u32 src_mask;
	u32 src_start;
	u32 src_stop;
	u32 gpr_reg;
	u32 gpr_wait;
	const struct imx_rproc_att *att;
	size_t att_size;
	enum imx_rproc_method method;
};

struct imx_rproc_att {
	u32 da;
	u32 sa;
	u32 size;
	int flags;
};

struct imx_rproc_mem {
	void *cpu_addr;
	phys_addr_t sys_addr;
	size_t size;
};

struct imx_rproc {
	struct device *dev;
	struct regmap *regmap;
	struct regmap *gpr;
	struct rproc *rproc;
	const struct imx_rproc_dcfg *dcfg;
	struct imx_rproc_mem mem[32];
	struct clk *clk;
	struct mbox_client cl;
	struct mbox_chan *tx_ch;
	struct mbox_chan *rx_ch;
	struct work_struct rproc_work;
	struct workqueue_struct *workqueue;
	void *rsc_table;
	struct imx_sc_ipc *ipc_handle;
	struct notifier_block rproc_nb;
	u32 rproc_pt;
	u32 rsrc_id;
	u32 entry;
	int num_pd;
	u32 core_index;
	struct device **pd_dev;
	struct device_link **pd_dev_link;
};

struct tegra186_emc_dvfs;

struct tegra186_emc {
	struct tegra_bpmp *bpmp;
	struct device *dev;
	struct clk *clk;
	struct tegra186_emc_dvfs *dvfs;
	unsigned int num_dvfs;
	struct {
		struct dentry *root;
		unsigned long min_rate;
		unsigned long max_rate;
	} debugfs;
	struct icc_provider provider;
};

struct tegra186_emc_dvfs {
	unsigned long latency;
	unsigned long rate;
};

struct emc_dvfs_latency {
	uint32_t freq;
	uint32_t latency;
};

struct mrq_emc_dvfs_latency_response {
	uint32_t num_pairs;
	struct emc_dvfs_latency pairs[14];
};

struct rockchip_data {
	int size;
	const char * const *clks;
	int num_clks;
	nvmem_reg_read_t reg_read;
};

struct rockchip_otp {
	struct device *dev;
	void *base;
	struct clk_bulk_data *clks;
	struct reset_control *rst;
	const struct rockchip_data *data;
};

enum {
	NETDEV_A_DEV_IFINDEX = 1,
	NETDEV_A_DEV_PAD = 2,
	NETDEV_A_DEV_XDP_FEATURES = 3,
	NETDEV_A_DEV_XDP_ZC_MAX_SEGS = 4,
	NETDEV_A_DEV_XDP_RX_METADATA_FEATURES = 5,
	__NETDEV_A_DEV_MAX = 6,
	NETDEV_A_DEV_MAX = 5,
};

enum netdev_xdp_rx_metadata {
	NETDEV_XDP_RX_METADATA_TIMESTAMP = 1,
	NETDEV_XDP_RX_METADATA_HASH = 2,
	NETDEV_XDP_RX_METADATA_MASK = 3,
};

enum {
	NETDEV_CMD_DEV_GET = 1,
	NETDEV_CMD_DEV_ADD_NTF = 2,
	NETDEV_CMD_DEV_DEL_NTF = 3,
	NETDEV_CMD_DEV_CHANGE_NTF = 4,
	__NETDEV_CMD_MAX = 5,
	NETDEV_CMD_MAX = 4,
};

enum {
	NETDEV_NLGRP_MGMT = 0,
};

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	__ETHTOOL_A_HEADER_CNT = 4,
	ETHTOOL_A_HEADER_MAX = 3,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	unsigned long pos_ifindex;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[34];
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	IFA_PROTO = 11,
	__IFA_MAX = 12,
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct netconfmsg {
	__u8 ncm_family;
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct devlink_reload_combination {
	enum devlink_reload_action action;
	enum devlink_reload_limit limit;
};

enum devlink_info_version_type {
	DEVLINK_INFO_VERSION_TYPE_NONE = 0,
	DEVLINK_INFO_VERSION_TYPE_COMPONENT = 1,
};

struct devlink_info_req {
	struct sk_buff *msg;
	void (*version_cb)(const char *, enum devlink_info_version_type, void *);
	void *version_cb_priv;
};

enum devlink_attr_selftest_id {
	DEVLINK_ATTR_SELFTEST_ID_UNSPEC = 0,
	DEVLINK_ATTR_SELFTEST_ID_FLASH = 1,
	__DEVLINK_ATTR_SELFTEST_ID_MAX = 2,
	DEVLINK_ATTR_SELFTEST_ID_MAX = 1,
};

enum devlink_attr_selftest_result {
	DEVLINK_ATTR_SELFTEST_RESULT_UNSPEC = 0,
	DEVLINK_ATTR_SELFTEST_RESULT = 1,
	DEVLINK_ATTR_SELFTEST_RESULT_ID = 2,
	DEVLINK_ATTR_SELFTEST_RESULT_STATUS = 3,
	__DEVLINK_ATTR_SELFTEST_RESULT_MAX = 4,
	DEVLINK_ATTR_SELFTEST_RESULT_MAX = 3,
};

struct devlink_flash_notify {
	const char *status_msg;
	const char *component;
	unsigned long done;
	unsigned long total;
	unsigned long timeout;
};

struct devlink_flash_component_lookup_ctx {
	const char *lookup_name;
	bool lookup_name_found;
};

struct virtio_chan {
	bool inuse;
	spinlock_t lock;
	struct p9_client *client;
	struct virtio_device *vdev;
	struct virtqueue *vq;
	int ring_bufs_avail;
	wait_queue_head_t *vc_wq;
	unsigned long p9_max_pages;
	struct scatterlist sg[128];
	char *tag;
	struct list_head chan_list;
};

typedef struct {
	unsigned long key[2];
} hsiphash_key_t;

union efi_rng_protocol;

typedef union efi_rng_protocol efi_rng_protocol_t;

union efi_rng_protocol {
	struct {
		efi_status_t (*get_info)(efi_rng_protocol_t *, unsigned long *, efi_guid_t *);
		efi_status_t (*get_rng)(efi_rng_protocol_t *, efi_guid_t *, unsigned long, u8 *);
	};
	struct {
		u32 get_info;
		u32 get_rng;
	} mixed_mode;
};

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
