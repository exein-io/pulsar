use std::{
    fmt, ops,
    time::{Duration, SystemTime},
};

use nix::{
    sys::time::TimeValLike,
    time::{clock_gettime, ClockId},
};

/// Timestamp indicates a timestamp in nanoseconds since boot.
/// This is compatbile with timestamps generated by bpf_ktime_get_ns (see `man bpf-helpers`)
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct Timestamp(u64);

impl Timestamp {
    /// Get current timestamp
    pub fn now() -> Self {
        clock_gettime(ClockId::CLOCK_MONOTONIC)
            .map(|t| t.num_nanoseconds() as u64)
            .unwrap_or(0)
            .into()
    }

    pub fn raw(&self) -> u64 {
        self.0
    }
}

impl std::fmt::Debug for Timestamp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<u64> for Timestamp {
    fn from(ts: u64) -> Self {
        Self(ts)
    }
}

impl ops::Add<u64> for Timestamp {
    type Output = Timestamp;

    fn add(self, rhs: u64) -> Self::Output {
        Timestamp(self.0 + rhs)
    }
}

impl ops::Sub for Timestamp {
    type Output = Timestamp;

    fn sub(self, rhs: Timestamp) -> Self::Output {
        Timestamp(self.0 - rhs.0)
    }
}

/// Convert a eBPF timestamp (nanos since boot) to a SystemTime.
impl From<Timestamp> for SystemTime {
    fn from(event_timestamp: Timestamp) -> Self {
        // The monotonic clock will stop in case of a suspend, so we must check it
        // every time and compare it to the event time.
        let elapsed_since_event = Timestamp::now().raw() - event_timestamp.raw();
        SystemTime::now() - Duration::from_nanos(elapsed_since_event)
    }
}

impl fmt::Display for Timestamp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}
